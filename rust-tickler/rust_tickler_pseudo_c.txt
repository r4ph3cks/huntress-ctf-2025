/*
Type: PE
Platform: windows-x86_64
Architecture: x86_64

Libraries: 
  api-ms-win-core-synch-l1-2-0.dll
  KERNEL32.dll
  ntdll.dll
  VCRUNTIME140.dll
  api-ms-win-crt-runtime-l1-1-0.dll
  api-ms-win-crt-math-l1-1-0.dll
  api-ms-win-crt-stdio-l1-1-0.dll
  api-ms-win-crt-locale-l1-1-0.dll
  api-ms-win-crt-heap-l1-1-0.dll

Compiler(s) Used: 
  Imported Functions (229 objects)
  VS2019 v16.8.5 build 29337 and VS2019 v16.9.0 build 29910 (9 objects)
  VS2008 v9.0 SP1 build 30729 (12 objects)
  VS2022 17.5.4 build 32217 and VS2010 v10.0 SP1 build 40219 (34 objects)
  VS2022 17.5.4 build 32217 and VS2010 v10.0 SP1 build 40219 (1 objects)

Segments:
r--  0x140000000-0x140000400 
r-x  0x140001000-0x140006738  {Code}
r--  0x140007000-0x140009456  {Data}
rw-  0x14000a000-0x14000a200  {Data}
rw-  0x14000a200-0x14000a220  {Data}
r--  0x14000b000-0x14000b3f0  {Data}
r--  0x14000c000-0x14000c0a0  {Data}
---  0x14000c0a0-0x14000c2c0 
---  0x14000c2c0-0x14000c2f0 

Sections:
0x140001000-0x140006738  .text  {Code}
0x140007000-0x140009456  .rdata  {Read-only data}
0x14000a000-0x14000a220  .data  {Writable data}
0x14000b000-0x14000b3f0  .pdata  {Read-only data}
0x14000c000-0x14000c0a0  .reloc  {Read-only data}
0x14000c0a0-0x14000c2c0  .extern  {External}
0x14000c2c0-0x14000c2f0  .synthetic_builtins  {External}
*/
140000000  struct DOS_Header __dos_header = 
140000000  {
140000000      char e_magic[0x2] = "MZ"
140000002      uint16_t e_cblp = 0x90
140000004      uint16_t e_cp = 0x3
140000006      uint16_t e_crlc = 0x0
140000008      uint16_t e_cparhdr = 0x4
14000000a      uint16_t e_minalloc = 0x0
14000000c      uint16_t e_maxalloc = 0xffff
14000000e      uint16_t e_ss = 0x0
140000010      uint16_t e_sp = 0xb8
140000012      uint16_t e_csum = 0x0
140000014      uint16_t e_ip = 0x0
140000016      uint16_t e_cs = 0x0
140000018      uint16_t e_lfarlc = 0x40
14000001a      uint16_t e_ovno = 0x0
14000001c      char e_res1[0x8] = "\x00\x00\x00\x00\x00\x00\x00", 0
140000024      uint16_t e_oemid = 0x0
140000026      uint16_t e_oeminfo = 0x0
140000028      char e_res2[0x14] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 0
14000003c      uint32_t e_lfanew = 0xf0
140000040  }

140000040  __dos_stub:
140000040  0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f  ........!..L.!This program canno
140000060  74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00  t be run in DOS mode....$.......

140000080  struct Rich_Header __rich_header = 
140000080  {
140000080      uint32_t e_magic__DanS = 0xe9969406
140000084      uint32_t e_align[0x3] = 
140000084      {
140000084          [0x0] =  0xbaf8f542
140000088          [0x1] =  0xbaf8f542
14000008c          [0x2] =  0xbaf8f542
140000090      }
140000090      uint32_t e_entry_id0__00937809 = 0xba6b8d4b
140000094      uint32_t e_entry_count0__12 = 0xbaf8f54e
140000098      uint32_t e_entry_id1__01018611 = 0xbbf97353
14000009c      uint32_t e_entry_count1__2 = 0xbaf8f540
1400000a0      uint32_t e_entry_id2__01038611 = 0xbbfb7353
1400000a4      uint32_t e_entry_count2__3 = 0xbaf8f541
1400000a8      uint32_t e_entry_id3__01048611 = 0xbbfc7353
1400000ac      uint32_t e_entry_count3__9 = 0xbaf8f54b
1400000b0      uint32_t e_entry_id4__01058611 = 0xbbfd7353
1400000b4      uint32_t e_entry_count4__20 = 0xbaf8f556
1400000b8      uint32_t e_entry_id5__010172d3 = 0xbbf98791
1400000bc      uint32_t e_entry_count5__9 = 0xbaf8f54b
1400000c0      uint32_t e_entry_id6__00010000 = 0xbaf9f542
1400000c4      uint32_t e_entry_count6__175 = 0xbaf8f5ed
1400000c8      uint32_t e_entry_id7__00000000 = 0xbaf8f542
1400000cc      uint32_t e_entry_count7__54 = 0xbaf8f574
1400000d0      uint32_t e_entry_id8__010287f8 = 0xbbfa72ba
1400000d4      uint32_t e_entry_count8__1 = 0xbaf8f543
1400000d8      char e_magic[0x4] = "Rich"
1400000dc      uint32_t e_checksum = 0xbaf8f542
1400000e0  }

1400000e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

1400000f0  struct COFF_Header __coff_header = 
1400000f0  {
1400000f0      char magic[0x4] = "PE\x00", 0
1400000f4      enum coff_machine machine = IMAGE_FILE_MACHINE_AMD64
1400000f6      uint16_t numberOfSections = 0x5
1400000f8      uint32_t timeDateStamp = 0x68e58356
1400000fc      uint32_t pointerToSymbolTable = 0x0
140000100      uint32_t numberOfSymbols = 0x0
140000104      uint16_t sizeOfOptionalHeader = 0xf0
140000106      enum coff_characteristics characteristics = IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LARGE_ADDRESS_AWARE
140000108  }
140000108  struct PE64_Optional_Header __pe64_optional_header = 
140000108  {
140000108      enum pe_magic magic = PE_64BIT
14000010a      uint8_t majorLinkerVersion = 0xe
14000010b      uint8_t minorLinkerVersion = 0x2b
14000010c      uint32_t sizeOfCode = 0x5800
140000110      uint32_t sizeOfInitializedData = 0x3000
140000114      uint32_t sizeOfUninitializedData = 0x0
140000118      uint32_t addressOfEntryPoint = 0x55a0
14000011c      uint32_t baseOfCode = 0x1000
140000120      uint64_t imageBase = 0x140000000
140000128      uint32_t sectionAlignment = 0x1000
14000012c      uint32_t fileAlignment = 0x200
140000130      uint16_t majorOperatingSystemVersion = 0x6
140000132      uint16_t minorOperatingSystemVersion = 0x0
140000134      uint16_t majorImageVersion = 0x0
140000136      uint16_t minorImageVersion = 0x0
140000138      uint16_t majorSubsystemVersion = 0x6
14000013a      uint16_t minorSubsystemVersion = 0x0
14000013c      uint32_t win32VersionValue = 0x0
140000140      uint32_t sizeOfImage = 0xd000
140000144      uint32_t sizeOfHeaders = 0x400
140000148      uint32_t checkSum = 0x0
14000014c      enum pe_subsystem subsystem = IMAGE_SUBSYSTEM_WINDOWS_CUI
14000014e      enum pe_dll_characteristics dllCharacteristics = IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA | IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE | IMAGE_DLLCHARACTERISTICS_NX_COMPAT | IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE
140000150      uint64_t sizeOfStackReserve = 0x100000
140000158      uint64_t sizeOfStackCommit = 0x1000
140000160      uint64_t sizeOfHeapReserve = 0x100000
140000168      uint64_t sizeOfHeapCommit = 0x1000
140000170      uint32_t loaderFlags = 0x0
140000174      uint32_t numberOfRvaAndSizes = 0x10
140000178      struct PE_Data_Directory_Entry exportTableEntry = 
140000178      {
140000178          uint32_t virtualAddress = 0x0
14000017c          uint32_t size = 0x0
140000180      }
140000180      struct PE_Data_Directory_Entry importTableEntry = 
140000180      {
140000180          uint32_t virtualAddress = 0x8adc
140000184          uint32_t size = 0xc8
140000188      }
140000188      struct PE_Data_Directory_Entry resourceTableEntry = 
140000188      {
140000188          uint32_t virtualAddress = 0x0
14000018c          uint32_t size = 0x0
140000190      }
140000190      struct PE_Data_Directory_Entry exceptionTableEntry = 
140000190      {
140000190          uint32_t virtualAddress = 0xb000
140000194          uint32_t size = 0x3f0
140000198      }
140000198      struct PE_Data_Directory_Entry certificateTableEntry = 
140000198      {
140000198          uint32_t virtualAddress = 0x0
14000019c          uint32_t size = 0x0
1400001a0      }
1400001a0      struct PE_Data_Directory_Entry baseRelocationTableEntry = 
1400001a0      {
1400001a0          uint32_t virtualAddress = 0xc000
1400001a4          uint32_t size = 0xa0
1400001a8      }
1400001a8      struct PE_Data_Directory_Entry debugEntry = 
1400001a8      {
1400001a8          uint32_t virtualAddress = 0x8320
1400001ac          uint32_t size = 0x54
1400001b0      }
1400001b0      struct PE_Data_Directory_Entry architectureEntry = 
1400001b0      {
1400001b0          uint32_t virtualAddress = 0x0
1400001b4          uint32_t size = 0x0
1400001b8      }
1400001b8      struct PE_Data_Directory_Entry globalPtrEntry = 
1400001b8      {
1400001b8          uint32_t virtualAddress = 0x0
1400001bc          uint32_t size = 0x0
1400001c0      }
1400001c0      struct PE_Data_Directory_Entry tlsTableEntry = 
1400001c0      {
1400001c0          uint32_t virtualAddress = 0x8380
1400001c4          uint32_t size = 0x28
1400001c8      }
1400001c8      struct PE_Data_Directory_Entry loadConfigTableEntry = 
1400001c8      {
1400001c8          uint32_t virtualAddress = 0x81e0
1400001cc          uint32_t size = 0x140
1400001d0      }
1400001d0      struct PE_Data_Directory_Entry boundImportEntry = 
1400001d0      {
1400001d0          uint32_t virtualAddress = 0x0
1400001d4          uint32_t size = 0x0
1400001d8      }
1400001d8      struct PE_Data_Directory_Entry iatEntry = 
1400001d8      {
1400001d8          uint32_t virtualAddress = 0x7000
1400001dc          uint32_t size = 0x268
1400001e0      }
1400001e0      struct PE_Data_Directory_Entry delayImportDescriptorEntry = 
1400001e0      {
1400001e0          uint32_t virtualAddress = 0x0
1400001e4          uint32_t size = 0x0
1400001e8      }
1400001e8      struct PE_Data_Directory_Entry clrRuntimeHeaderEntry = 
1400001e8      {
1400001e8          uint32_t virtualAddress = 0x0
1400001ec          uint32_t size = 0x0
1400001f0      }
1400001f0      struct PE_Data_Directory_Entry reservedEntry = 
1400001f0      {
1400001f0          uint32_t virtualAddress = 0x0
1400001f4          uint32_t size = 0x0
1400001f8      }
1400001f8  }
1400001f8  struct Section_Header __section_headers[0x5] = 
1400001f8  {
1400001f8      [0x0] = 
1400001f8      {
1400001f8          char name[0x8] = ".text\x00\x00", 0
140000200          uint32_t virtualSize = 0x5738
140000204          uint32_t virtualAddress = 0x1000
140000208          uint32_t sizeOfRawData = 0x5800
14000020c          uint32_t pointerToRawData = 0x400
140000210          uint32_t pointerToRelocations = 0x0
140000214          uint32_t pointerToLineNumbers = 0x0
140000218          uint16_t numberOfRelocations = 0x0
14000021a          uint16_t numberOfLineNumbers = 0x0
14000021c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ
140000220      }
140000220      [0x1] = 
140000220      {
140000220          char name[0x8] = ".rdata\x00", 0
140000228          uint32_t virtualSize = 0x2456
14000022c          uint32_t virtualAddress = 0x7000
140000230          uint32_t sizeOfRawData = 0x2600
140000234          uint32_t pointerToRawData = 0x5c00
140000238          uint32_t pointerToRelocations = 0x0
14000023c          uint32_t pointerToLineNumbers = 0x0
140000240          uint16_t numberOfRelocations = 0x0
140000242          uint16_t numberOfLineNumbers = 0x0
140000244          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ
140000248      }
140000248      [0x2] = 
140000248      {
140000248          char name[0x8] = ".data\x00\x00", 0
140000250          uint32_t virtualSize = 0x220
140000254          uint32_t virtualAddress = 0xa000
140000258          uint32_t sizeOfRawData = 0x200
14000025c          uint32_t pointerToRawData = 0x8200
140000260          uint32_t pointerToRelocations = 0x0
140000264          uint32_t pointerToLineNumbers = 0x0
140000268          uint16_t numberOfRelocations = 0x0
14000026a          uint16_t numberOfLineNumbers = 0x0
14000026c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
140000270      }
140000270      [0x3] = 
140000270      {
140000270          char name[0x8] = ".pdata\x00", 0
140000278          uint32_t virtualSize = 0x3f0
14000027c          uint32_t virtualAddress = 0xb000
140000280          uint32_t sizeOfRawData = 0x400
140000284          uint32_t pointerToRawData = 0x8400
140000288          uint32_t pointerToRelocations = 0x0
14000028c          uint32_t pointerToLineNumbers = 0x0
140000290          uint16_t numberOfRelocations = 0x0
140000292          uint16_t numberOfLineNumbers = 0x0
140000294          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ
140000298      }
140000298      [0x4] = 
140000298      {
140000298          char name[0x8] = ".reloc\x00", 0
1400002a0          uint32_t virtualSize = 0xa0
1400002a4          uint32_t virtualAddress = 0xc000
1400002a8          uint32_t sizeOfRawData = 0x200
1400002ac          uint32_t pointerToRawData = 0x8800
1400002b0          uint32_t pointerToRelocations = 0x0
1400002b4          uint32_t pointerToLineNumbers = 0x0
1400002b8          uint16_t numberOfRelocations = 0x0
1400002ba          uint16_t numberOfLineNumbers = 0x0
1400002bc          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
1400002c0      }
1400002c0  }
1400002c0  data_1400002c0:
1400002c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400002e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400003a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400003c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400003e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

.text section started  {0x140001000-0x140006738}

140001000    int64_t sub_140001000(int64_t arg1)

140001000  {
140001004      (*(uint64_t*)arg1)();
14000100c      return 0;
140001000  }

14000100d                                         cc cc cc                                                               ...

140001010    int64_t sub_140001010(int64_t* arg1, int64_t* arg2, int512_t arg3 @ zmm0)

140001010  {
14000101d      /* tailcall */
14000101d      return sub_140004920(*(uint64_t*)arg1, arg1[1], arg2, arg3);
140001010  }

140001022        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                    ..............

140001030    int64_t sub_140001030(int64_t arg1, int64_t* arg2)

140001030  {
14000103a      /* tailcall */
14000103a      return sub_140004280(arg1, &data_140007398, arg2);
140001030  }

14000103f                                                                                               cc                                 .

140001040    void sub_140001040(int64_t* arg1)

140001040  {
140001040      int64_t rdx_1 = *(uint64_t*)arg1;
140001040      
140001046      if (!rdx_1)
140001057          return;
140001057      
140001052      /* tailcall */
140001052      return j_sub_1400023f0(arg1[1], rdx_1, 1);
140001040  }

140001058                                                                          cc cc cc cc cc cc cc cc                          ........

140001060    int64_t sub_140001060(int64_t* arg1, int32_t arg2)

140001060  {
140001068      int64_t rsi = arg1[2];
14000106c      int64_t rdi = 1;
14000106c      
140001077      if (arg2 >= 0x80)
140001077      {
140001079          rdi = 2;
140001079          
140001084          if (arg2 >= 0x800)
140001091              rdi = 4 - 0;
140001077      }
140001077      
14000109b      int64_t rax = rsi;
1400010a1      char* r8_2;
1400010a1      
1400010a1      if (rdi > *(uint64_t*)arg1 - rsi)
1400010a1      {
1400010b8          int64_t* rbx_1 = arg1;
1400010c3          sub_140006060(arg1, rsi, rdi);
1400010ca          arg1 = rbx_1;
1400010cd          rax = rbx_1[2];
1400010d1          r8_2 = arg1[1];
1400010d1          
1400010db          if (arg2 < 0x80)
1400010af              r8_2[rax] = (uint8_t)arg2;
1400010db          else
1400010db          {
1400010e0          label_1400010e0:
1400010e0              
1400010e6              if (arg2 < 0x800)
1400010e6              {
1400010f0                  r8_2[rax] = (char)(arg2 >> 6) | 0xc0;
1400010f4                  (uint8_t)arg2 &= 0x3f;
1400010f7                  (uint8_t)arg2 |= 0x80;
1400010fa                  r8_2[rax + 1] = (uint8_t)arg2;
1400010e6              }
1400010e6              else if (arg2 >= 0x10000)
140001107              {
14000113e                  r8_2[rax] = (char)(arg2 >> 0x12) | 0xf0;
140001151                  r8_2[rax + 1] = ((char)(arg2 >> 0xc) & 0x3f) | 0x80;
140001165                  r8_2[rax + 2] = ((char)(arg2 >> 6) & 0x3f) | 0x80;
14000116a                  (uint8_t)arg2 &= 0x3f;
14000116d                  (uint8_t)arg2 |= 0x80;
140001170                  r8_2[rax + 3] = (uint8_t)arg2;
140001107              }
140001107              else
140001107              {
140001111                  r8_2[rax] = (char)(arg2 >> 0xc) | 0xe0;
140001124                  r8_2[rax + 1] = ((char)(arg2 >> 6) & 0x3f) | 0x80;
140001129                  (uint8_t)arg2 &= 0x3f;
14000112c                  (uint8_t)arg2 |= 0x80;
14000112f                  r8_2[rax + 2] = (uint8_t)arg2;
140001107              }
1400010db          }
1400010a1      }
1400010a1      else
1400010a1      {
1400010a3          r8_2 = arg1[1];
1400010a3          
1400010ad          if (arg2 >= 0x80)
1400010ad              goto label_1400010e0;
1400010ad          
1400010af          r8_2[rax] = (uint8_t)arg2;
1400010a1      }
140001178      arg1[2] = rdi + rsi;
140001186      return 0;
140001060  }

140001187                       cc cc cc cc cc cc cc cc cc                                                         .........

140001190    int64_t sub_140001190(int64_t* arg1, int64_t arg2, int64_t arg3)

140001190  {
1400011a2      int64_t rbx = arg1[2];
1400011a2      
1400011ac      if (arg3 > *(uint64_t*)arg1 - rbx)
1400011ac      {
1400011dc          sub_140006060(arg1, rbx, arg3);
1400011e4          rbx = arg1[2];
1400011ac      }
1400011ac      
1400011b8      memcpy(arg1[1] + rbx, arg2, (uint32_t)arg3);
1400011c0      arg1[2] = rbx + arg3;
1400011cf      return 0;
140001190  }

1400011ea                                cc cc cc cc cc cc                                                            ......

1400011f0    int64_t sub_1400011f0()

1400011f0  {
14000120a      void* const var_60 = &data_1400073c8;
140001212      int64_t var_58 = 0x11;
140001225      void* const var_50 = &data_1400073d9;
14000122d      int64_t var_48 = 0x11;
140001241      void* const* var_c8 = &var_60;
14000124d      int32_t (* var_c0)(int64_t* arg1, int64_t* arg2) = sub_140001820;
140001259      void* const buffer2 = &data_1400073f0;
14000125e      int64_t var_f0 = 2;
140001267      int64_t var_d8 = 0;
140001275      void* const** var_e8 = &var_c8;
14000127a      int64_t var_e0 = 1;
140001288      sub_140002000(&buffer2);
14000128d      int64_t var_88 = 0;
140001299      char* var_80 = 1;
1400012a5      int64_t var_78 = 0;
1400012b1      sub_140001b60();
1400012b6      void* buffer1_1 = &data_14000a0e8;
1400012d1      char rax = sub_140001ba0(&buffer1_1, &var_88);
1400012e0      buffer2 = &data_140007410;
1400012e5      int64_t var_f0_1 = 0x1a;
1400012f5      void* const var_e8_1 = &data_14000742a;
1400012fa      int64_t var_e0_1 = 0x1a;
140001303      void* var_a8 = nullptr;
14000130c      void* var_a0 = 1;
140001315      int64_t var_98 = 0;
140001326      int64_t var_b8 = 0xe0000020;
140001330      var_c8 = &var_a8;
14000133c      void** const var_c0_1 = &data_140007398;
14000133c      
14000135e      if (sub_140001820(&buffer2, &var_c8) || rax & 1)
140001733          trap(6);
140001733      
140001364      void* rdx_2 = var_a8;
140001364      
14000136c      if (rdx_2)
140001379          j_sub_1400023f0(var_a0, rdx_2, 1);
140001379      
14000138e      void* rdx_3 = &var_80[var_78];
140001395      void* rax_3;
140001395      char* r8;
140001395      void* r9;
140001395      
140001395      if (!var_78)
140001395      {
1400014d3          r9 = nullptr;
1400014d6          r8 = var_80;
1400014d9          rax_3 = nullptr;
140001395      }
140001395      else
140001395      {
14000139b          void* r10_1 = data_14000a030;
1400013a2          r9 = nullptr;
1400013a5          r8 = var_80;
1400013a5          
1400013c9          while (true)
1400013c9          {
1400013c9              char* rbx_1 = r8;
1400013cc              rax_3 = r9;
1400013cf              uint32_t r11_2 = (uint32_t)*(uint8_t*)r8;
1400013cf              
1400013d6              if ((uint8_t)r11_2 < 0)
1400013d6              {
1400013e3                  int32_t r9_2 = r11_2 & 0x1f;
1400013ec                  int32_t r12_2 = (uint32_t)rbx_1[1] & 0x3f;
1400013ec                  
1400013f4                  if ((uint8_t)r11_2 <= 0xdf)
1400013f4                  {
14000142a                      r8 = &rbx_1[2];
140001435                      r11_2 = r9_2 << 6 | r12_2;
1400013f4                  }
1400013f4                  else
1400013f4                  {
140001401                      int32_t rbp_3 = ((uint32_t)rbx_1[2] & 0x3f) | r12_2 << 6;
140001401                      
140001408                      if ((uint8_t)r11_2 < 0xf0)
140001408                      {
14000143a                          r8 = &rbx_1[3];
140001445                          r11_2 = rbp_3 | r9_2 << 0xc;
140001408                      }
140001408                      else
140001408                      {
14000140a                          r8 = &rbx_1[4];
140001425                          r11_2 = ((uint32_t)rbx_1[3] & 0x3f) | rbp_3 << 6
140001425                              | (r9_2 & 7) << 0x12;
140001408                      }
1400013f4                  }
1400013d6              }
1400013d6              else
1400013d8                  r8 = &rbx_1[1];
1400013d8              
140001456              r9 = r8 - rbx_1 + rax_3;
140001456              
14000146a              if (r11_2 - 9 >= 5 && r11_2 != 0x20)
14000146a              {
140001477                  if (r11_2 < 0x80)
140001477                      break;
140001477                  
14000147c                  uint32_t rbx_4 = r11_2 >> 8;
14000147c                  
140001482                  if (rbx_4 > 0x1f)
140001482                  {
1400014a0                      if (rbx_4 == 0x20)
1400013b3                          (uint8_t)r11_2 =
1400013b3                              *(uint8_t*)((char*)r10_1 + (uint64_t)(uint8_t)r11_2) >> 1;
1400014a0                      else
1400014a0                      {
1400014a9                          if (rbx_4 != 0x30)
1400014a9                              break;
1400014a9                          
1400014b2                          (uint8_t)r11_2 = r11_2 == 0x3000;
1400014a0                      }
140001482                  }
140001482                  else if (!rbx_4)
1400014bf                      r11_2 =
1400014bf                          (uint32_t)*(uint8_t*)((char*)r10_1 + (uint64_t)(uint8_t)r11_2);
140001486                  else
140001486                  {
14000148b                      if (rbx_4 != 0x16)
14000148b                          break;
14000148b                      
140001494                      (uint8_t)r11_2 = r11_2 == 0x1680;
140001486                  }
140001486                  
1400013ba                  if (!((uint8_t)r11_2 & 1))
1400013ba                      break;
14000146a              }
14000146a              
1400013c3              if (r8 == rdx_3)
1400013c3              {
1400014c9                  rax_3 = nullptr;
1400014cb                  r9 = nullptr;
1400014ce                  goto label_1400015f0;
1400013c3              }
1400013c9          }
140001395      }
140001395      
1400014de      if (r8 != rdx_3)
1400014de      {
1400014e4          void* r10_2 = data_14000a030;
1400014e4          
140001503          do
140001503          {
140001509              void* r11_7 = rdx_3;
14000150c              uint32_t rbx_6 = (int32_t)*(uint8_t*)((char*)rdx_3 - 1);
14000150c              
140001512              if (rbx_6 < 0)
140001512              {
140001530                  uint32_t rbp_7 = (uint32_t)*(uint8_t*)((char*)r11_7 - 2);
140001539                  int32_t rbp_8;
140001539                  
140001539                  if ((uint8_t)rbp_7 >= 0xc0)
140001539                  {
140001560                      rdx_3 = (char*)r11_7 - 2;
140001564                      rbp_8 = rbp_7 & 0x1f;
140001539                  }
140001539                  else
140001539                  {
14000153b                      uint32_t r12_4 = (uint32_t)*(uint8_t*)((char*)r11_7 - 3);
140001544                      int32_t r12_6;
140001544                      
140001544                      if ((uint8_t)r12_4 >= 0xc0)
140001544                      {
140001569                          rdx_3 = (char*)r11_7 - 3;
14000156d                          r12_6 = r12_4 & 0xf;
140001544                      }
140001544                      else
140001544                      {
140001546                          rdx_3 = (char*)r11_7 - 4;
14000155b                          r12_6 = (r12_4 & 0x3f)
14000155b                              | ((uint32_t)*(uint8_t*)((char*)r11_7 - 4) & 7) << 6;
140001544                      }
140001544                      
140001578                      rbp_8 = (rbp_7 & 0x3f) | r12_6 << 6;
140001539                  }
140001539                  
140001581                  rbx_6 = (rbx_6 & 0x3f) | rbp_8 << 6;
140001581                  
140001589                  if (rbx_6 - 9 >= 5)
140001589                      goto label_14000158f;
140001512              }
140001512              else
140001512              {
140001514                  rdx_3 = (char*)r11_7 - 1;
140001514                  
14000151e                  if (rbx_6 - 9 >= 5)
14000151e                  {
14000158f                  label_14000158f:
14000158f                      
140001592                      if (rbx_6 != 0x20)
140001592                      {
14000159e                          if (rbx_6 < 0x80)
14000159e                          {
1400015ed                              r9 = (char*)r9 - r8 + r11_7;
1400015ed                              break;
14000159e                          }
14000159e                          
1400015a2                          uint32_t rbp_13 = rbx_6 >> 8;
1400015a2                          
1400015a8                          if (rbp_13 > 0x1f)
1400015a8                          {
1400015c4                              if (rbp_13 == 0x20)
1400014f5                                  (uint8_t)rbx_6 =
1400014f5                                      *(uint8_t*)((char*)r10_2 + (uint64_t)(uint8_t)rbx_6)
1400014f5                                      >> 1;
1400015c4                              else
1400015c4                              {
1400015cd                                  if (rbp_13 != 0x30)
1400015cd                                  {
1400015ed                                      r9 = (char*)r9 - r8 + r11_7;
1400015ed                                      break;
1400015ed                                      break;
1400015cd                                  }
1400015cd                                  
1400015d5                                  (uint8_t)rbx_6 = rbx_6 == 0x3000;
1400015c4                              }
1400015a8                          }
1400015a8                          else if (!rbp_13)
1400015e0                              rbx_6 = (uint32_t)
1400015e0                                  *(uint8_t*)((char*)r10_2 + (uint64_t)(uint8_t)rbx_6);
1400015ac                          else
1400015ac                          {
1400015b1                              if (rbp_13 != 0x16)
1400015b1                              {
1400015ed                                  r9 = (char*)r9 - r8 + r11_7;
1400015ed                                  break;
1400015ed                                  break;
1400015b1                              }
1400015b1                              
1400015b9                              (uint8_t)rbx_6 = rbx_6 == 0x1680;
1400015ac                          }
1400015ac                          
1400014fa                          if (!((uint8_t)rbx_6 & 1))
1400014fa                          {
1400015ed                              r9 = (char*)r9 - r8 + r11_7;
1400015ed                              break;
1400014fa                          }
140001592                      }
14000151e                  }
140001512              }
140001503          } while (r8 != rdx_3);
1400014de      }
1400014de      
1400015f0  label_1400015f0:
1400015f0      int64_t r9_11 = (char*)r9 - rax_3;
1400015f3      void* buffer1 = var_80 + rax_3;
1400015f6      buffer1_1 = buffer1;
1400015fe      int64_t var_68 = r9_11;
14000160d      var_e0_1 = data_14000a000[0x1e][0];
140001619      var_e8_1 = data_14000a000[0x10][0];
140001625      buffer2 = data_14000a000[0];
14000162e      int32_t rax_5;
14000162e      
14000162e      if (r9_11 == 0x26)
14000163b          rax_5 = memcmp(buffer1, &buffer2, 0x26);
14000163b      
140001642      if (r9_11 == 0x26 && !rax_5)
140001642      {
140001705          var_a8 = &data_140007444;
14000170a          int64_t var_a0_2 = 0x15;
14000171a          void* const var_98_2 = &data_140007459;
140001722          int64_t var_90_1 = 0x15;
140001642      }
140001642      else
140001642      {
14000164f          var_a8 = &data_1400074a0;
140001654          int64_t var_a0_1 = 0x1b;
140001664          void* const var_98_1 = &data_1400074bb;
14000166c          int64_t var_90 = 0x1b;
140001642      }
140001642      
140001678      var_c8 = &var_a8;
14000167d      int32_t (* var_c0_2)(int64_t* arg1, int64_t* arg2) = sub_140001820;
140001682      void** var_b8_1 = &buffer1_1;
14000168e      int64_t (* var_b0)(int64_t* arg1, int64_t* arg2, int512_t arg3 @ zmm0) =
14000168e          sub_140001010;
14000169a      buffer2 = &data_140007470;
14000169f      int64_t var_f0_2 = 3;
1400016a8      int64_t var_d8_1 = 0;
1400016b1      void* const** var_e8_2 = &var_c8;
1400016b6      int64_t var_e0_2 = 2;
1400016c4      int64_t result = sub_140002000(&buffer2);
1400016c9      int64_t rdx_5 = var_88;
1400016c9      
1400016d4      if (!rdx_5)
1400016fd          return result;
1400016fd      
1400016e4      return j_sub_1400023f0(var_80, rdx_5, 1);
1400011f0  }

1400013de                                                                                            66 90                                f.
140001522        66 66 66 66 66 2e 0f 1f 84 00 00 00 00 00                                                    fffff.........
140001735                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........
140001740  0f 28 05 d9 5b 00 00 0f 28 0d b2 88 00 00 0f 57 c8 0f 29 0d a8 88 00 00 0f 57 05 b1 88 00 00 0f  .(..[...(......W..)......W......
140001760  29 05 aa 88 00 00 0f 28 05 b3 88 00 00 0f 57 05 bc 5b 00 00 f3 0f 11 05 a4 88 00 00 80 35 a1 88  )......(......W..[...........5..
140001780  00 00 51 80 35 9b 88 00 00 51 31 c0 c3 cc cc cc                                                  ..Q.5....Q1.....

140001790    int64_t main(int32_t arg1)

140001790  {
1400017a1      int64_t (* var_8)() = sub_1400011f0;
1400017a6      char var_18 = 0;
1400017c0      return sub_140002250(&var_8, &data_140007340);
140001790  }

1400017c1     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                   ...............

1400017d0    int64_t j_sub_140002390(uint64_t arg1, int64_t arg2)

1400017d0  {
1400017d0      /* tailcall */
1400017d0      return sub_140002390(arg1, arg2);
1400017d0  }

1400017d5                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........

1400017e0    int64_t j_sub_1400023f0(void* arg1, int64_t arg2, int64_t arg3)

1400017e0  {
1400017e0      /* tailcall */
1400017e0      return sub_1400023f0(arg1, arg2, arg3);
1400017e0  }

1400017e5                 cc cc cc cc cc cc cc cc cc cc cc                                                       ...........

1400017f0    int64_t j_sub_140002420(void* arg1, uint64_t arg2, int64_t arg3, uint64_t arg4)

1400017f0  {
1400017f0      /* tailcall */
1400017f0      return sub_140002420(arg1, arg2, arg3, arg4);
1400017f0  }

1400017f5                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........

140001800    int64_t sub_140001800(void* arg1, int64_t* arg2, int512_t arg3 @ zmm0)

140001800  {
14000180e      /* tailcall */
14000180e      return sub_140004920(*(uint64_t*)((char*)arg1 + 8), 
14000180e          *(uint64_t*)((char*)arg1 + 0x10), arg2, arg3);
140001800  }

140001813                                                           cc cc cc cc cc cc cc cc cc cc cc cc cc                     .............

140001820    int32_t sub_140001820(int64_t* arg1, int64_t* arg2)

140001820  {
14000184b      uint64_t var_78;
14000184b      sub_140001940(&var_78, *(uint64_t*)arg1, arg1[1], arg1[2], arg1[3]);
140001850      char* var_70;
140001850      char* rbx = var_70;
140001855      char* var_68;
140001855      char* r14 = var_68;
140001865      char var_60;
140001865      sub_140004b10(&var_60, rbx, r14);
14000186f      int32_t result;
14000186f      char* rax_2;
14000186f      
14000186f      if (!(var_60 & 1))
14000186f      {
14000188f          rax_2 = var_78;
140001894      label_140001894:
140001894          var_78 = rax_2;
14000189e          char* var_68_1 = r14;
1400018a3          uint64_t* var_30 = &var_78;
1400018af          int64_t (* var_28_1)(void* arg1, int64_t* arg2, int512_t arg3 @ zmm0) =
1400018af              sub_140001800;
1400018be          var_60 = &data_1400074d8;
1400018c3          int64_t var_58_1 = 1;
1400018cc          int64_t var_40_1 = 0;
1400018da          uint64_t** var_50_1 = &var_30;
1400018df          int64_t var_48_1 = 1;
1400018f4          result = sub_140004280(*(uint64_t*)arg2, arg2[1], &var_60);
1400018f9          uint64_t rdx_4 = var_78;
1400018f9          
140001901          if (rdx_4)
140001910              j_sub_1400023f0(rbx, rdx_4, 1);
14000186f      }
14000186f      else
14000186f      {
140001871          uint64_t rdx_2 = var_78;
140001871          
14000187c          if (-(rdx_2) == -0x8000000000000000)
14000187c          {
140001882              rax_2 = rbx;
140001885              rbx = r14;
140001888              char* var_58;
140001888              r14 = var_58;
14000188d              goto label_140001894;
14000187c          }
14000187c          
140001919          (uint8_t)result = 1;
140001919          
14000191b          if (rdx_2)
14000191b          {
140001926              j_sub_1400023f0(rbx, rdx_2, 1);
14000192b              (uint8_t)result = 1;
14000191b          }
14000186f      }
140001939      return result;
140001820  }

14000193a                                                                                cc cc cc cc cc cc                            ......

140001940    uint64_t* sub_140001940(uint64_t* arg1, int64_t arg2, uint64_t arg3, char* arg4, int64_t arg5)

140001940  {
140001953      if (arg3 >= 0)
140001953      {
14000195c          if (!arg3)
14000195c          {
1400019e7              *(uint64_t*)arg1 = 0;
1400019ee              arg1[1] = 1;
1400019f6              arg1[2] = 0;
140001a93              return arg1;
14000195c          }
14000195c          
140001968          data_14000a0e0;
14000197d          char* rax_2 = j_sub_140002390(arg3, 1);
14000197d          
140001985          if (rax_2)
140001985          {
14000199f              memcpy(rax_2, arg2, (uint32_t)arg3);
1400019a4              *(uint64_t*)arg1 = arg3;
1400019a7              arg1[1] = rax_2;
1400019ab              arg1[2] = arg3;
1400019ab              
1400019b2              if (!arg5)
140001aa9                  trap(6);
140001aa9              
1400019bc              int64_t i;
1400019bc              
1400019bc              if (arg3 != 1)
1400019bc              {
140001a10                  i = 0;
140001a10                  
140001a34                  do
140001a34                  {
140001a40                      uint64_t rdx_6;
140001a40                      
140001a40                      rdx_6 = !((i | arg5) >> 0x20)
140001a40                          ? (uint64_t)(COMBINE(0, (uint32_t)i) % (uint32_t)arg5)
140001a40                          : COMBINE(0, i) % arg5;
140001a40                      
140001a5b                      rax_2[i] ^= arg4[rdx_6];
140001a6c                      uint64_t rdx_4;
140001a6c                      
140001a6c                      rdx_4 = ((i + 1) | arg5) >> 0x20 ? COMBINE(0, i + 1) % arg5
140001a6c                          : (uint64_t)(COMBINE(0, (i + 1)) % (uint32_t)arg5);
140001a6c                      
140001a29                      rax_2[i + 1] ^= arg4[rdx_4];
140001a2d                      i += 2;
140001a34                  } while ((0x7ffffffffffffffe & arg3) != i);
1400019bc              }
1400019bc              else
1400019be                  i = 0;
1400019be              
1400019c4              if ((uint8_t)arg3 & 1)
1400019c4              {
1400019d4                  uint64_t rdx_2;
1400019d4                  
1400019d4                  rdx_2 = !((i | arg5) >> 0x20)
1400019d4                      ? (uint64_t)(COMBINE(0, (uint32_t)i) % (uint32_t)arg5)
1400019d4                      : COMBINE(0, i) % arg5;
1400019d4                  
140001a80                  rax_2[i] ^= arg4[rdx_2];
1400019c4              }
1400019c4              
140001a93              return arg1;
140001985          }
140001953      }
140001953      
140001aa4      sub_140006700();
140001aa4      /* no return */
140001940  }

140001a14                                                              66 66 66 2e 0f 1f 84 00 00 00 00 00                      fff.........
140001a4c                                      0f 1f 40 00                                                              ..@.
140001aab                                   cc cc cc cc cc                                                             .....

140001ab0    void sub_140001ab0(int64_t* arg1)

140001ab0  {
140001ab5      void* rsi = *(uint64_t*)arg1;
140001ab8      char* rcx = *(uint64_t*)((char*)rsi + 0x18);
140001ab8      
140001abf      if (rcx)
140001abf      {
140001ac1          int64_t rdx_1 = *(uint64_t*)((char*)rsi + 0x20);
140001ac5          *(uint8_t*)rcx = 0;
140001ac5          
140001acb          if (rdx_1)
140001ad3              j_sub_1400023f0(rcx, rdx_1, 1);
140001abf      }
140001abf      
140001adc      if (rsi == -1)
140001adc          return;
140001adc      
140001ade      int64_t temp0_1 = *(uint64_t*)((char*)rsi + 8);
140001ade      *(uint64_t*)((char*)rsi + 8) -= 1;
140001ade      
140001ae3      if (temp0_1 == 1)
140001af8          /* tailcall */
140001af8          return j_sub_1400023f0(rsi, 0x30, 8);
140001ab0  }

140001b04              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

140001b10    void sub_140001b10(int64_t* arg1)

140001b10  {
140001b15      void* rsi = *(uint64_t*)arg1;
140001b18      int64_t rdx = *(uint64_t*)((char*)rsi + 0x18);
140001b18      
140001b1f      if (rdx)
140001b2b          j_sub_1400023f0(*(uint64_t*)((char*)rsi + 0x20), rdx, 1);
140001b2b      
140001b34      if (rsi == -1)
140001b34          return;
140001b34      
140001b36      int64_t temp0_1 = *(uint64_t*)((char*)rsi + 8);
140001b36      *(uint64_t*)((char*)rsi + 8) -= 1;
140001b36      
140001b3b      if (temp0_1 == 1)
140001b50          /* tailcall */
140001b50          return j_sub_1400023f0(rsi, 0x30, 8);
140001b10  }

140001b5c                                                                                      cc cc cc cc                              ....

140001b60    int64_t sub_140001b60()

140001b60  {
140001b6d      if (data_14000a120 == 3)
140001b7a          return &data_14000a0e8;
140001b7a      
140001b82      sub_1400063e1(&data_14000a0e8);
140001b92      return &data_14000a0e8;
140001b60  }

140001b93                                                           cc cc cc cc cc cc cc cc cc cc cc cc cc                     .............

140001ba0    int64_t sub_140001ba0(int64_t* arg1, int64_t* arg2)

140001ba0  {
140001bab      int64_t* rdi = arg2;
140001bae      char* Address = *(uint64_t*)arg1;
140001bb5      bool z;
140001bb5      
140001bb5      if (0 == *(uint8_t*)Address)
140001bb5      {
140001bb5          *(uint8_t*)Address = 1;
140001bb5          z = true;
140001bb5      }
140001bb5      else
140001bb5      {
140001bb5          int64_t rax;
140001bb5          (uint8_t)rax = *(uint8_t*)Address;
140001bb5          z = false;
140001bb5      }
140001bb5      
140001bb9      if (!z)
140001c2e          sub_140006430(Address);
140001c2e      
140001bbf      int64_t r15 = rdi[2];
140001bc3      (uint8_t)arg2 = 0xa;
140001bc8      int64_t result_1;
140001bc8      char const (** rdx)[0x23];
140001bc8      result_1 = sub_1400030b0(&Address[8], (uint8_t)arg2, rdi);
140001bcd      int64_t result = result_1;
140001be6      char var_40;
140001be6      sub_140004b10(&var_40, rdi[1] + r15, rdi[2] - r15);
140001be6      
140001bf0      if (!(var_40 & 1))
140001c09          r15 = rdi[2];
140001bf0      else
140001c01          result = 1;
140001c01      
140001c0d      rdi[2] = r15;
140001c13      char temp0 = *(uint8_t*)Address;
140001c13      *(uint8_t*)Address = 0;
140001c13      
140001c17      if (temp0 == 2)
140001c38          WakeByAddressSingle(Address);
140001c38      
140001c2a      return result;
140001ba0  }


140001c40    int64_t sub_140001c40()

140001c40  {
140001c47      char var_19 = 0;
140001c4c      int32_t result = data_14000a160;
140001c4c      
140001c55      if (result != 3)
140001c55      {
140001e47          result = sub_140006393(&data_14000a128, &var_19);
140001e47          
140001e51          if (!var_19)
140001e51          {
140001c79          label_140001c79:
140001c79              TEB* gsbase;
140001c79              int64_t rcx_2 = *(uint64_t*)(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
140001c79                  + ((uint64_t)data_14000a190 << 3)) + 0x40);
140001c79              
140001c83              if (!rcx_2)
140001c83              {
140001db3                  int64_t rax_5 = data_14000a170;
140001dd3                  bool z_1;
140001dd3                  
140001dd3                  do
140001dd3                  {
140001dc4                      if (rax_5 == -1)
140001e39                          trap(6);
140001e39                      
140001dc6                      rcx_2 = rax_5 + 1;
140001dc6                      
140001dca                      if (rax_5 == data_14000a170)
140001dca                      {
140001dca                          data_14000a170 = rcx_2;
140001dca                          z_1 = true;
140001dca                      }
140001dca                      else
140001dca                      {
140001dca                          rax_5 = data_14000a170;
140001dca                          z_1 = false;
140001dca                      }
140001dd3                  } while (!z_1);
140001de8                  *(uint64_t*)(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
140001de8                      + ((uint64_t)data_14000a190 << 3)) + 0x40) = rcx_2;
140001de8                  
140001df9                  if (rcx_2 == data_14000a128)
140001df9                      goto label_140001c99;
140001df9                  
140001df9                  goto label_140001e01;
140001c83              }
140001c83              
140001c93              if (rcx_2 != data_14000a128)
140001c93              {
140001e01              label_140001e01:
140001e01                  result = 0;
140001e03                  bool z_2;
140001e03                  
140001e03                  if (0 == data_14000a134)
140001e03                  {
140001e03                      data_14000a134 = 1;
140001e03                      z_2 = true;
140001e03                  }
140001e03                  else
140001e03                  {
140001e03                      (uint8_t)result = data_14000a134;
140001e03                      z_2 = false;
140001e03                  }
140001e03                  
140001e0b                  if (z_2)
140001e0b                  {
140001e0d                      data_14000a128 = rcx_2;
140001e14                      result = 1;
140001e19                      data_14000a130 = 1;
140001e19                      
140001e27                      if (!data_14000a138)
140001e27                          goto label_140001cbe;
140001e27                      
140001e34                      sub_140006700();
140001e34                      /* no return */
140001e0b                  }
140001c93              }
140001c93              else
140001c93              {
140001c99              label_140001c99:
140001c99                  result = data_14000a130;
140001c99                  
140001ca2                  if (result != 0xffffffff)
140001ca2                  {
140001ca8                      result += 1;
140001caa                      data_14000a130 = result;
140001caa                      
140001cb8                      if (data_14000a138)
140001cb8                      {
140001e34                          sub_140006700();
140001e34                          /* no return */
140001cb8                      }
140001cb8                      
140001cbe                  label_140001cbe:
140001cbe                      data_14000a138 = -1;
140001cbe                      
140001cd0                      if (!data_14000a158)
140001cd0                      {
140001cd9                          char const (** rax_3)[0x22] = sub_140002a70(&data_14000a140);
140001ce1                          result = (uint32_t)rax_3 & 3;
140001ce1                          
140001ce7                          if (result == 1)
140001ce7                          {
140001ce9                              void* rdi_1 = *(uint64_t*)((char*)rax_3 - 1);
140001ced                              int64_t* rbx_1 = *(uint64_t*)((char*)rax_3 + 7);
140001cf1                              int64_t rax_4 = *(uint64_t*)rbx_1;
140001cf1                              
140001cf7                              if (rax_4)
140001cfc                                  rax_4(rdi_1);
140001cfc                              
140001d01                              int64_t rdx_1 = rbx_1[1];
140001d01                              
140001d08                              if (rdx_1)
140001d11                                  j_sub_1400023f0(rdi_1, rdx_1, rbx_1[2]);
140001d11                              
140001d24                              result = j_sub_1400023f0((char*)rax_3 - 1, 0x18, 8);
140001ce7                          }
140001cd0                      }
140001cd0                      
140001d29                      int64_t rdx_2 = data_14000a140;
140001d29                      
140001d33                      if (rdx_2)
140001d42                          result = j_sub_1400023f0(data_14000a148, rdx_2, 1);
140001d42                      
140001d47                      data_14000a140 = 0;
140001d52                      data_14000a148 = 1;
140001d5d                      data_14000a150 = 0;
140001d68                      *(int64_t*)((char*)data_14000a150 + 6) = 0;
140001d73                      data_14000a138 += 1;
140001d7a                      int32_t temp1_1 = data_14000a130;
140001d7a                      data_14000a130 -= 1;
140001d7a                      
140001d80                      if (temp1_1 == 1)
140001d80                      {
140001d86                          data_14000a128 = 0;
140001d93                          char temp0_1 = data_14000a134;
140001d93                          data_14000a134 = 0;
140001d93                          (uint8_t)result = temp0_1;
140001d93                          
140001d9b                          if ((uint8_t)result == 2)
140001da8                              return WakeByAddressSingle(&data_14000a134);
140001d80                      }
140001ca2                  }
140001c93              }
140001e51          }
140001c55      }
140001c55      else if (!var_19)
140001c60          goto label_140001c79;
140001c60      
140001e5e      return result;
140001c40  }

140001e5f                                                                                               cc                                 .

140001e60    int64_t* sub_140001e60(int128_t* arg1)

140001e60  {
140001e74      if (data_14000a0e4)
140001e74      {
140001e8d          TEB* gsbase;
140001e8d          uint32_t rax_3 = (uint32_t)*(uint8_t*)(*(uint64_t*)(
140001e8d              gsbase->ThreadLocalStoragePointer + ((uint64_t)data_14000a190 << 3)) + 0x10);
140001e8d          
140001e97          if (rax_3 == 1)
140001e97              goto label_140001ed9;
140001e97          
140001e9c          if (rax_3 != 2)
140001e9c          {
140001ec2              sub_140006100(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
140001ec2                  + ((uint64_t)data_14000a190 << 3)) + 8);
140001ed9          label_140001ed9:
140001ed9              void* rax_8 = *(uint64_t*)(gsbase->ThreadLocalStoragePointer
140001ed9                  + ((uint64_t)data_14000a190 << 3));
140001edd              void* r14_1 = *(uint64_t*)((char*)rax_8 + 8);
140001ee4              *(uint64_t*)((char*)rax_8 + 8) = 0;
140001ee4              
140001ef2              if (r14_1)
140001ef2              {
140001f00                  bool z_1;
140001f00                  
140001f00                  if (0 == *(uint8_t*)((char*)r14_1 + 0x10))
140001f00                  {
140001f00                      *(uint8_t*)((char*)r14_1 + 0x10) = 1;
140001f00                      z_1 = true;
140001f00                  }
140001f00                  else
140001f00                  {
140001f00                      int64_t rax_9;
140001f00                      (uint8_t)rax_9 = *(uint8_t*)((char*)r14_1 + 0x10);
140001f00                      z_1 = false;
140001f00                  }
140001f00                  
140001f06                  if (!z_1)
140001fdd                      sub_140006430((char*)r14_1 + 0x10);
140001fdd                  
140001f1b                  int128_t var_38_1 = arg1[2];
140001f20                  int128_t var_48_1 = arg1[1];
140001f25                  int128_t var_58 = *(uint128_t*)arg1;
140001f32                  void* rax_11 = sub_1400029d0((char*)r14_1 + 0x18, &var_58);
140001f32                  
140001f40                  if (((uint32_t)rax_11 & 3) == 1)
140001f40                  {
140001f42                      void* rbx_1 = *(uint64_t*)((char*)rax_11 - 1);
140001f46                      int64_t* r15_1 = *(uint64_t*)((char*)rax_11 + 7);
140001f4a                      int64_t rax_13 = *(uint64_t*)r15_1;
140001f4a                      
140001f50                      if (rax_13)
140001f55                          rax_13(rbx_1);
140001f55                      
140001f5a                      int64_t rdx_5 = r15_1[1];
140001f5a                      
140001f61                      if (rdx_5)
140001f6a                          j_sub_1400023f0(rbx_1, rdx_5, r15_1[2]);
140001f6a                      
140001f7d                      j_sub_1400023f0((char*)rax_11 - 1, 0x18, 8);
140001f40                  }
140001f40                  
140001f84                  char temp0_1 = *(uint8_t*)((char*)r14_1 + 0x10);
140001f84                  *(uint8_t*)((char*)r14_1 + 0x10) = 0;
140001f84                  
140001f88                  if (temp0_1 == 2)
140001fed                      WakeByAddressSingle((char*)r14_1 + 0x10);
140001fed                  
140001f99                  void* rcx_6 = *(uint64_t*)(gsbase->ThreadLocalStoragePointer
140001f99                      + ((uint64_t)data_14000a190 << 3));
140001f9d                  int64_t* result = *(uint64_t*)((char*)rcx_6 + 8);
140001fa4                  (uint64_t)var_58 = result;
140001fa9                  *(uint64_t*)((char*)rcx_6 + 8) = r14_1;
140001fa9                  
140001fb3                  if (result)
140001fb3                  {
140001fb5                      int64_t temp1_1 = *(uint64_t*)result;
140001fb5                      *(uint64_t*)result -= 1;
140001fb5                      
140001fb9                      if (temp1_1 == 1)
140001fc0                          sub_140001b10(&var_58);
140001fb3                  }
140001fb3                  
140001fc5                  (uint8_t)result = 1;
140001fd6                  return result;
140001ef2              }
140001e9c          }
140001e74      }
140001e74      
140001fc9      return nullptr;
140001e60  }

140001ff5                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........

140002000    int64_t sub_140002000(int128_t* arg1)

140002000  {
14000200c      int32_t result = sub_140001e60(arg1);
14000200c      
140002013      if (!(uint8_t)result)
140002013      {
140002022          if (data_14000a160 != 3)
140002197              sub_140006349(&data_14000a128);
140002197          
14000203b          TEB* gsbase;
14000203b          int64_t rdi_1 = *(uint64_t*)(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
14000203b              + ((uint64_t)data_14000a190 << 3)) + 0x40);
14000203b          
140002045          if (!rdi_1)
140002045          {
140002066              int64_t rax_6 = data_14000a170;
140002087              bool z_1;
140002087              
140002087              do
140002087              {
140002074                  if (rax_6 == -1)
140002074                      goto label_1400021c4_2;
140002074                  
14000207a                  rdi_1 = rax_6 + 1;
14000207a                  
14000207e                  if (rax_6 == data_14000a170)
14000207e                  {
14000207e                      data_14000a170 = rdi_1;
14000207e                      z_1 = true;
14000207e                  }
14000207e                  else
14000207e                  {
14000207e                      rax_6 = data_14000a170;
14000207e                      z_1 = false;
14000207e                  }
140002087              } while (!z_1);
14000209c              *(uint64_t*)(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
14000209c                  + ((uint64_t)data_14000a190 << 3)) + 0x40) = rdi_1;
14000209c              
1400020ad              if (rdi_1 == data_14000a128)
1400020ad                  goto label_140002053;
1400020ad              
1400020ad              goto label_1400020b3;
140002045          }
140002045          
140002051          int32_t rax_5;
140002051          
140002051          if (rdi_1 != data_14000a128)
140002051          {
1400020b3          label_1400020b3:
1400020b3              bool z_2;
1400020b3              
1400020b3              if (0 == data_14000a134)
1400020b3              {
1400020b3                  data_14000a134 = 1;
1400020b3                  z_2 = true;
1400020b3              }
1400020b3              else
1400020b3              {
1400020b3                  int64_t rax_10;
1400020b3                  (uint8_t)rax_10 = data_14000a134;
1400020b3                  z_2 = false;
1400020b3              }
1400020b3              
1400020bb              if (!z_2)
1400021a8                  sub_140006430(&data_14000a134);
1400021a8              
1400020c1              data_14000a128 = rdi_1;
1400020c8              rax_5 = 1;
140002051          }
140002051          else
140002051          {
140002053          label_140002053:
140002053              int32_t rax_4 = data_14000a130;
140002053              
14000205c              if (rax_4 == 0xffffffff)
14000205c              {
1400021c4              labelid_0:
1400021c4                  trap(6);
14000205c              }
14000205c              
140002062              rax_5 = rax_4 + 1;
140002051          }
140002051          
1400020cd          data_14000a130 = rax_5;
1400020da          int64_t* var_38 = &data_14000a128;
1400020e4          int64_t** var_30 = &var_38;
1400020e9          void* var_28_1 = nullptr;
140002101          result = sub_140004280(&var_30, &data_140007c20, arg1);
140002101          
14000210d          if (!(uint8_t)result)
14000210d          {
140002121              if (((uint32_t)var_28_1 & 3) == 1)
140002121              {
140002125                  void* rdi_2 = *(uint64_t*)((char*)var_28_1 - 1);
140002129                  int64_t* r14_1 = *(uint64_t*)((char*)var_28_1 + 7);
14000212d                  int64_t rax_11 = *(uint64_t*)r14_1;
14000212d                  
140002133                  if (rax_11)
140002138                      rax_11(rdi_2);
140002138                  
14000213d                  int64_t rdx_1 = r14_1[1];
14000213d                  
140002144                  if (rdx_1)
14000214d                      j_sub_1400023f0(rdi_2, rdx_1, r14_1[2]);
14000214d                  
140002160                  j_sub_1400023f0((char*)var_28_1 - 1, 0x18, 8);
140002121              }
14000210d          }
14000210d          else if (!var_28_1)
140002112          {
1400021c4          label_1400021c4:
1400021c4              trap(6);
140002112          }
140002112          
140002167          int64_t* rcx_7 = var_38;
14000216c          int32_t temp1_1 = rcx_7[1];
14000216c          rcx_7[1] -= 1;
14000216f          char temp0_1;
14000216f          
14000216f          if (temp1_1 == 1)
14000216f          {
140002171              *(uint64_t*)rcx_7 = 0;
14000217a              temp0_1 = *(uint8_t*)((char*)rcx_7 + 0xc);
14000217a              *(uint8_t*)((char*)rcx_7 + 0xc) = 0;
14000216f          }
14000216f          
140002180          if (temp1_1 == 1 && temp0_1 == 2)
140002180          {
1400021b8              WakeByAddressSingle((char*)rcx_7 + 0xc);
1400021b8              
1400021c2              if ((uint8_t)result)
1400021c2              {
1400021c4              label_1400021c4_1:
1400021c4                  trap(6);
1400021c2              }
140002180          }
140002180          else if ((uint8_t)result)
140002184          {
1400021c4          label_1400021c4_2:
1400021c4              trap(6);
140002184          }
140002013      }
140002013      
14000218f      return result;
140002000  }

1400021c6                    cc cc cc cc cc cc cc cc cc cc                                                        ..........
1400021d0  data_1400021d0:
1400021d0                                                  48 8b 01 81 38 fd 00 00 c0 75 27 8b 05 af 7f 00                  H...8....u'.....
1400021e0  00 65 48 8b 0c 25 58 00 00 00 48 8b 04 c1 48 8b 80 18 00 00 00 48 83 f8 03 72 0a 48 83 78 08 00  .eH..%X...H...H......H...r.H.x..
140002200  74 03 31 c0 c3 48 8b 05 6c 7f 00 00 31 c0 c3 cc                                                  t.1..H..l...1...

140002210    int64_t sub_140002210(int64_t* arg1)

140002210  {
140002214      char* rax = *(uint64_t*)arg1;
140002217      bool cond:0 = !*(uint8_t*)rax;
14000221a      *(uint8_t*)rax = 0;
14000221a      
14000221d      if (cond:0)
140002240          trap(6);
140002240      
14000221f      sub_140001c40();
140002224      int32_t result = data_14000a188;
140002224      
14000222d      if (result != 3)
14000223f          return result;
14000223f      
140002233      /* jump -> data_14000a180 */
140002210  }

140002242        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                    ..............

140002250    int64_t sub_140002250(int64_t arg1, int64_t arg2)

140002250  {
140002265      AddVectoredExceptionHandler(0, &data_1400021d0);
14000226b      uint32_t StackSizeInBytes = 0x5000;
140002278      SetThreadStackGuarantee(&StackSizeInBytes);
140002295      data_14000a028(GetCurrentThread(), u"main");
1400022ab      TEB* gsbase;
1400022ab      int64_t rcx_3 = *(uint64_t*)(
1400022ab          *(uint64_t*)(gsbase->ThreadLocalStoragePointer + ((uint64_t)data_14000a190 << 3))
1400022ab          + 0x40);
1400022ab      
1400022b5      if (!rcx_3)
1400022b5      {
1400022b7          int64_t rax_3 = data_14000a170;
1400022d3          bool z_1;
1400022d3          
1400022d3          do
1400022d3          {
1400022c4              if (rax_3 == -1)
140002310                  trap(6);
140002310              
1400022c6              rcx_3 = rax_3 + 1;
1400022c6              
1400022ca              if (rax_3 == data_14000a170)
1400022ca              {
1400022ca                  data_14000a170 = rcx_3;
1400022ca                  z_1 = true;
1400022ca              }
1400022ca              else
1400022ca              {
1400022ca                  rax_3 = data_14000a170;
1400022ca                  z_1 = false;
1400022ca              }
1400022d3          } while (!z_1);
1400022e8          *(uint64_t*)(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
1400022e8              + ((uint64_t)data_14000a190 << 3)) + 0x40) = rcx_3;
1400022b5      }
1400022b5      
1400022ef      data_14000a178 = rcx_3;
1400022f9      int32_t rax_6 = (*(uint64_t*)(arg2 + 0x28))(arg1);
1400022f9      
140002305      if (data_14000a168 != 3)
140002305      {
140002312          char var_1d = 1;
14000231c          char* var_18 = &var_1d;
140002328          char const (** const var_28_1)[0xb] = &data_140007548;
140002344          sub_140006590(&data_14000a168, 0, &var_18, &data_140007560);
140002305      }
140002305      
14000230f      return (int64_t)rax_6;
140002250  }

14000234d                                         cc cc cc                                                               ...

140002350    int64_t sub_140002350(int64_t* arg1)

140002350  {
140002354      char* rax = *(uint64_t*)arg1;
140002357      char rcx = *(uint8_t*)rax;
14000235a      *(uint8_t*)rax = 0;
14000235a      
140002360      if (rcx != 1)
140002383          trap(6);
140002383      
140002362      sub_140001c40();
140002367      int32_t result = data_14000a188;
140002367      
140002370      if (result != 3)
140002382          return result;
140002382      
140002376      /* jump -> data_14000a180 */
140002350  }

140002385                 cc cc cc cc cc cc cc cc cc cc cc                                                       ...........

140002390    int64_t sub_140002390(uint64_t arg1, int64_t arg2)

140002390  {
14000239a      if (arg2 < 0x11)
1400023a7          /* tailcall */
1400023a7          return sub_140003410(arg1, HEAP_NONE, arg1);
1400023a7      
1400023af      uint64_t rcx_1 = arg1 + arg2;
1400023b2      int64_t result = 0;
1400023b9      int64_t rax_1 = sub_140003410(rcx_1, HEAP_NONE, rcx_1);
1400023b9      
1400023c1      if (rax_1)
1400023c1      {
1400023ca          int64_t rsi_1 = arg2 - ((arg2 - 1) & rax_1);
1400023d0          result = rax_1 + rsi_1;
1400023d3          *(uint64_t*)(rax_1 + rsi_1 - 8) = rax_1;
1400023c1      }
1400023c1      
1400023e1      return result;
140002390  }

1400023e2        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                    ..............

1400023f0    int64_t sub_1400023f0(void* arg1, int64_t arg2, int64_t arg3)

1400023f0  {
1400023f5      void* rsi = arg1;
1400023f5      
1400023fc      if (arg3 >= 0x11)
1400023fe          rsi = *(uint64_t*)((char*)rsi - 8);
1400023fe      
140002415      /* tailcall */
140002415      return HeapFree(GetProcessHeap(), HEAP_NONE, rsi);
1400023f0  }

14000241c                                                                                      cc cc cc cc                              ....

140002420    int64_t sub_140002420(void* arg1, uint64_t arg2, int64_t arg3, uint64_t arg4)

140002420  {
140002435      if (arg3 < 0x11)
140002453          /* tailcall */
140002453          return HeapReAlloc(GetProcessHeap(), HEAP_NONE, arg1, arg4);
140002453      
14000245d      uint64_t r14 = arg2;
140002463      int64_t result = 0;
140002467      int64_t rax_2 = sub_140003410(arg1, HEAP_NONE, arg3 + arg4);
140002467      
14000246f      if (rax_2)
14000246f      {
140002478          int64_t r15_1 = arg3 - ((arg3 - 1) & rax_2);
14000247e          result = rax_2 + r15_1;
140002481          *(uint64_t*)(rax_2 + r15_1 - 8) = rax_2;
140002481          
140002489          if (arg4 < r14)
140002489              r14 = arg4;
140002489          
140002496          memcpy(result, arg1, (uint32_t)r14);
1400024ad          HeapFree(GetProcessHeap(), HEAP_NONE, *(uint64_t*)((char*)arg1 - 8));
14000246f      }
14000246f      
1400024c1      return result;
140002420  }

1400024c2        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                    ..............

1400024d0    uint64_t sub_1400024d0(void* arg1)

1400024d0  {
1400024e3      switch ((uint64_t)(uint32_t)arg1 & 3)
1400024e3      {
1400024e9          case 0:
1400024e9          {
1400024e9              return (uint64_t)*(uint8_t*)((char*)arg1 + 0x10);
1400024e9              break;
1400024e9          }
14000252d          case 1:
14000252d          {
14000252d              return (uint64_t)*(uint8_t*)((char*)arg1 + 0xf);
14000252d              break;
14000252d          }
1400024ea          case 2:
1400024ea          {
1400024ea              uint32_t rcx = (int32_t)(arg1 >> 0x20);
1400024ee              void* result;
1400024ee              (uint8_t)result = 1;
1400024ee              
1400024f6              if (rcx > 0x460)
1400024f6              {
140002538                  if (rcx <= 0x271c)
140002538                  {
140002562                      if (rcx > 0x780)
140002562                      {
14000259d                          if (rcx <= 0x1b7f)
14000259d                          {
140002624                              if (rcx == 0x781)
140002624                              {
1400026bf                                  (uint8_t)result = 0x12;
1400026c1                                  return result;
140002624                              }
140002624                              
140002638                              if (rcx == 0x1716 || rcx == 0x1b64)
140002638                              {
140002674                                  (uint8_t)result = 0x16;
140002676                                  return result;
140002638                              }
140002638                              
14000264f                              (uint8_t)result = 0x29;
140002651                              return result;
14000259d                          }
14000259d                          
1400025a5                          if (rcx > 0x2021)
1400025a5                          {
140002672                              if (rcx == 0x2022 || rcx == 0x25e9)
140002672                              {
140002674                                  (uint8_t)result = 0x16;
140002676                                  return result;
140002672                              }
140002672                              
14000264f                              (uint8_t)result = 0x29;
140002651                              return result;
1400025a5                          }
1400025a5                          
1400025bd                          if (rcx == 0x1b80 || rcx == 0x1f4e)
1400025bd                          {
140002674                              (uint8_t)result = 0x16;
140002676                              return result;
1400025bd                          }
1400025bd                          
14000264f                          (uint8_t)result = 0x29;
140002651                          return result;
140002562                      }
140002562                      
14000256a                      if (rcx <= 0x4ce)
14000256a                      {
140002605                          if (rcx == 0x461)
140002605                          {
140002674                              (uint8_t)result = 0x16;
140002676                              return result;
140002605                          }
140002605                          
14000260d                          if (rcx == 0x46b)
14000260d                          {
1400026bc                              (uint8_t)result = 0x1e;
1400026be                              return result;
14000260d                          }
14000260d                          
140002619                          if (rcx == 0x476)
140002619                          {
14000261b                              (uint8_t)result = 0x20;
14000261d                              return result;
140002619                          }
140002619                          
14000264f                          (uint8_t)result = 0x29;
140002651                          return result;
14000256a                      }
14000256a                      
140002576                      if (rcx > 0x50e)
140002576                      {
140002658                          if (rcx == 0x50f)
140002658                          {
140002677                              (uint8_t)result = 0x1a;
140002679                              return result;
140002658                          }
140002658                          
140002660                          if (rcx == 0x5b4)
140002660                          {
140002674                              (uint8_t)result = 0x16;
140002676                              return result;
140002660                          }
140002660                          
14000264f                          (uint8_t)result = 0x29;
140002651                          return result;
140002576                      }
140002576                      
140002582                      if (rcx == 0x4cf)
140002582                      {
14000267a                          (uint8_t)result = 5;
14000267c                          return result;
140002582                      }
140002582                      
14000258e                      if (rcx != 0x4d0)
14000258e                      {
14000264f                          (uint8_t)result = 0x29;
140002651                          return result;
14000258e                      }
14000258e                      
140002594                      (uint8_t)result = 4;
140002596                      return result;
140002538                  }
140002538                  
14000253a                  uint64_t rdx_1 = (uint64_t)(rcx - 0x271d);
14000253a                  
140002543                  if ((uint32_t)rdx_1 > 0x38)
140002543                  {
1400025fb                      if (rcx - 0x3c2a < 2 || rcx == 0x35ed)
1400025fb                      {
140002674                          (uint8_t)result = 0x16;
140002676                          return result;
1400025fb                      }
1400025fb                      
14000264f                      (uint8_t)result = 0x29;
140002651                      return result;
140002543                  }
140002543                  
140002557                  switch (rdx_1)
140002557                  {
140002531                      case 0:
140002531                      {
140002531                          return result;
140002531                          break;
140002531                      }
14000264f                      case 1:
14000264f                      case 2:
14000264f                      case 3:
14000264f                      case 4:
14000264f                      case 5:
14000264f                      case 6:
14000264f                      case 7:
14000264f                      case 8:
14000264f                      case 0xa:
14000264f                      case 0xb:
14000264f                      case 0xc:
14000264f                      case 0xd:
14000264f                      case 0xe:
14000264f                      case 0xf:
14000264f                      case 0x10:
14000264f                      case 0x11:
14000264f                      case 0x12:
14000264f                      case 0x13:
14000264f                      case 0x14:
14000264f                      case 0x15:
14000264f                      case 0x17:
14000264f                      case 0x18:
14000264f                      case 0x19:
14000264f                      case 0x1a:
14000264f                      case 0x1b:
14000264f                      case 0x1c:
14000264f                      case 0x1d:
14000264f                      case 0x1e:
14000264f                      case 0x1f:
14000264f                      case 0x20:
14000264f                      case 0x21:
14000264f                      case 0x22:
14000264f                      case 0x27:
14000264f                      case 0x2a:
14000264f                      case 0x2b:
14000264f                      case 0x2d:
14000264f                      case 0x2e:
14000264f                      case 0x31:
14000264f                      case 0x32:
14000264f                      case 0x33:
14000264f                      case 0x35:
14000264f                      case 0x36:
14000264f                      case 0x37:
14000264f                      {
14000264f                          (uint8_t)result = 0x29;
140002651                          return result;
14000264f                          break;
14000264f                      }
140002559                      case 9:
140002559                      {
140002559                          (uint8_t)result = 0x14;
14000255b                          return result;
140002559                          break;
140002559                      }
140002698                      case 0x16:
140002698                      {
140002698                          (uint8_t)result = 0xd;
14000269a                          return result;
140002698                          break;
140002698                      }
14000268f                      case 0x23:
14000268f                      {
14000268f                          (uint8_t)result = 8;
140002691                          return result;
14000268f                          break;
14000268f                      }
14000268c                      case 0x24:
14000268c                      {
14000268c                          (uint8_t)result = 9;
14000268e                          return result;
14000268c                          break;
14000268c                      }
14000269e                      case 0x25:
14000269e                      {
14000269e                          (uint8_t)result = 0xa;
1400026a0                          return result;
14000269e                          break;
14000269e                      }
14000267a                      case 0x26:
14000267a                      {
14000267a                          (uint8_t)result = 5;
14000267c                          return result;
14000267a                          break;
14000267a                      }
140002692                      case 0x28:
140002692                      {
140002692                          (uint8_t)result = 6;
140002694                          return result;
140002692                          break;
140002692                      }
14000269b                      case 0x29:
14000269b                      {
14000269b                          (uint8_t)result = 3;
14000269d                          return result;
14000269b                          break;
14000269b                      }
140002695                      case 0x2c:
140002695                      {
140002695                          (uint8_t)result = 7;
140002697                          return result;
140002695                          break;
140002695                      }
140002674                      case 0x2f:
140002674                      {
140002674                          (uint8_t)result = 0x16;
140002676                          return result;
140002674                          break;
140002674                      }
140002689                      case 0x30:
140002689                      {
140002689                          (uint8_t)result = 2;
14000268b                          return result;
140002689                          break;
140002689                      }
140002594                      case 0x34:
140002594                      {
140002594                          (uint8_t)result = 4;
140002596                          return result;
140002594                          break;
140002594                      }
140002677                      case 0x38:
140002677                      {
140002677                          (uint8_t)result = 0x1a;
140002679                          return result;
140002677                          break;
140002677                      }
140002557                  }
1400024f6              }
1400024f6              else
1400024f6              {
1400024fe                  if (rcx > 0x14f)
1400024fe                  {
1400025ce                      if (rcx > 0x3e2)
1400025ce                      {
14000264d                          if (rcx == 0x3e3 || rcx == 0x41d)
14000264d                          {
140002674                              (uint8_t)result = 0x16;
140002676                              return result;
14000264d                          }
14000264d                          
14000264f                          (uint8_t)result = 0x29;
140002651                          return result;
1400025ce                      }
1400025ce                      
1400025d6                      if (rcx == 0x150)
1400025d6                      {
1400026b9                          (uint8_t)result = 0xf;
1400026bb                          return result;
1400025d6                      }
1400025d6                      
1400025e2                      if (rcx == 0x252)
1400025e2                      {
140002674                          (uint8_t)result = 0x16;
140002676                          return result;
1400025e2                      }
1400025e2                      
14000264f                      (uint8_t)result = 0x29;
140002651                      return result;
1400024fe                  }
1400024fe                  
140002504                  uint64_t rcx_1 = (uint64_t)(rcx - 2);
140002504                  
14000250d                  if ((uint32_t)rcx_1 > 0x109)
14000250d                  {
14000264f                      (uint8_t)result = 0x29;
140002651                      return result;
14000250d                  }
14000250d                  
140002521                  switch (rcx_1)
140002521                  {
140002525                      case 0:
140002525                      case 1:
140002525                      case 0xd:
140002525                      case 0x33:
140002525                      case 0x41:
140002525                      {
140002525                          return 0;
140002525                          break;
140002525                      }
14000264f                      case 2:
14000264f                      case 4:
14000264f                      case 5:
14000264f                      case 7:
14000264f                      case 8:
14000264f                      case 9:
14000264f                      case 0xa:
14000264f                      case 0xb:
14000264f                      case 0xe:
14000264f                      case 0x10:
14000264f                      case 0x12:
14000264f                      case 0x13:
14000264f                      case 0x14:
14000264f                      case 0x15:
14000264f                      case 0x16:
14000264f                      case 0x17:
14000264f                      case 0x18:
14000264f                      case 0x19:
14000264f                      case 0x1a:
14000264f                      case 0x1b:
14000264f                      case 0x1c:
14000264f                      case 0x1d:
14000264f                      case 0x1e:
14000264f                      case 0x1f:
14000264f                      case 0x20:
14000264f                      case 0x21:
14000264f                      case 0x22:
14000264f                      case 0x23:
14000264f                      case 0x24:
14000264f                      case 0x26:
14000264f                      case 0x27:
14000264f                      case 0x28:
14000264f                      case 0x29:
14000264f                      case 0x2a:
14000264f                      case 0x2b:
14000264f                      case 0x2c:
14000264f                      case 0x2d:
14000264f                      case 0x2e:
14000264f                      case 0x2f:
14000264f                      case 0x30:
14000264f                      case 0x31:
14000264f                      case 0x32:
14000264f                      case 0x34:
14000264f                      case 0x35:
14000264f                      case 0x36:
14000264f                      case 0x37:
14000264f                      case 0x38:
14000264f                      case 0x39:
14000264f                      case 0x3a:
14000264f                      case 0x3b:
14000264f                      case 0x3c:
14000264f                      case 0x3d:
14000264f                      case 0x3e:
14000264f                      case 0x3f:
14000264f                      case 0x40:
14000264f                      case 0x42:
14000264f                      case 0x43:
14000264f                      case 0x44:
14000264f                      case 0x45:
14000264f                      case 0x46:
14000264f                      case 0x47:
14000264f                      case 0x48:
14000264f                      case 0x49:
14000264f                      case 0x4a:
14000264f                      case 0x4b:
14000264f                      case 0x4c:
14000264f                      case 0x4d:
14000264f                      case 0x4f:
14000264f                      case 0x50:
14000264f                      case 0x51:
14000264f                      case 0x52:
14000264f                      case 0x53:
14000264f                      case 0x54:
14000264f                      case 0x56:
14000264f                      case 0x57:
14000264f                      case 0x58:
14000264f                      case 0x59:
14000264f                      case 0x5a:
14000264f                      case 0x5b:
14000264f                      case 0x5c:
14000264f                      case 0x5d:
14000264f                      case 0x5e:
14000264f                      case 0x5f:
14000264f                      case 0x60:
14000264f                      case 0x61:
14000264f                      case 0x62:
14000264f                      case 0x63:
14000264f                      case 0x64:
14000264f                      case 0x65:
14000264f                      case 0x66:
14000264f                      case 0x67:
14000264f                      case 0x68:
14000264f                      case 0x69:
14000264f                      case 0x6a:
14000264f                      case 0x6c:
14000264f                      case 0x6d:
14000264f                      case 0x6f:
14000264f                      case 0x70:
14000264f                      case 0x71:
14000264f                      case 0x72:
14000264f                      case 0x73:
14000264f                      case 0x74:
14000264f                      case 0x75:
14000264f                      case 0x78:
14000264f                      case 0x7a:
14000264f                      case 0x7b:
14000264f                      case 0x7c:
14000264f                      case 0x7d:
14000264f                      case 0x7e:
14000264f                      case 0x7f:
14000264f                      case 0x80:
14000264f                      case 0x81:
14000264f                      case 0x83:
14000264f                      case 0x84:
14000264f                      case 0x85:
14000264f                      case 0x86:
14000264f                      case 0x87:
14000264f                      case 0x88:
14000264f                      case 0x89:
14000264f                      case 0x8a:
14000264f                      case 0x8b:
14000264f                      case 0x8c:
14000264f                      case 0x8d:
14000264f                      case 0x8e:
14000264f                      case 0x90:
14000264f                      case 0x91:
14000264f                      case 0x92:
14000264f                      case 0x93:
14000264f                      case 0x94:
14000264f                      case 0x95:
14000264f                      case 0x96:
14000264f                      case 0x97:
14000264f                      case 0x98:
14000264f                      case 0x99:
14000264f                      case 0x9a:
14000264f                      case 0x9b:
14000264f                      case 0x9c:
14000264f                      case 0x9d:
14000264f                      case 0x9e:
14000264f                      case 0xa0:
14000264f                      case 0xa1:
14000264f                      case 0xa2:
14000264f                      case 0xa3:
14000264f                      case 0xa4:
14000264f                      case 0xa5:
14000264f                      case 0xa6:
14000264f                      case 0xa7:
14000264f                      case 0xa9:
14000264f                      case 0xaa:
14000264f                      case 0xab:
14000264f                      case 0xac:
14000264f                      case 0xad:
14000264f                      case 0xae:
14000264f                      case 0xaf:
14000264f                      case 0xb0:
14000264f                      case 0xb1:
14000264f                      case 0xb2:
14000264f                      case 0xb3:
14000264f                      case 0xb4:
14000264f                      case 0xb6:
14000264f                      case 0xb7:
14000264f                      case 0xb8:
14000264f                      case 0xb9:
14000264f                      case 0xba:
14000264f                      case 0xbb:
14000264f                      case 0xbc:
14000264f                      case 0xbd:
14000264f                      case 0xbe:
14000264f                      case 0xbf:
14000264f                      case 0xc0:
14000264f                      case 0xc1:
14000264f                      case 0xc2:
14000264f                      case 0xc3:
14000264f                      case 0xc4:
14000264f                      case 0xc5:
14000264f                      case 0xc6:
14000264f                      case 0xc7:
14000264f                      case 0xc8:
14000264f                      case 0xc9:
14000264f                      case 0xca:
14000264f                      case 0xcb:
14000264f                      case 0xcd:
14000264f                      case 0xce:
14000264f                      case 0xcf:
14000264f                      case 0xd0:
14000264f                      case 0xd1:
14000264f                      case 0xd2:
14000264f                      case 0xd3:
14000264f                      case 0xd4:
14000264f                      case 0xd5:
14000264f                      case 0xd6:
14000264f                      case 0xd7:
14000264f                      case 0xd8:
14000264f                      case 0xd9:
14000264f                      case 0xda:
14000264f                      case 0xdb:
14000264f                      case 0xdc:
14000264f                      case 0xde:
14000264f                      case 0xdf:
14000264f                      case 0xe0:
14000264f                      case 0xe1:
14000264f                      case 0xe2:
14000264f                      case 0xe3:
14000264f                      case 0xe4:
14000264f                      case 0xe5:
14000264f                      case 0xe7:
14000264f                      case 0xe8:
14000264f                      case 0xe9:
14000264f                      case 0xea:
14000264f                      case 0xeb:
14000264f                      case 0xec:
14000264f                      case 0xed:
14000264f                      case 0xee:
14000264f                      case 0xef:
14000264f                      case 0xf0:
14000264f                      case 0xf1:
14000264f                      case 0xf2:
14000264f                      case 0xf3:
14000264f                      case 0xf4:
14000264f                      case 0xf5:
14000264f                      case 0xf6:
14000264f                      case 0xf7:
14000264f                      case 0xf8:
14000264f                      case 0xf9:
14000264f                      case 0xfa:
14000264f                      case 0xfb:
14000264f                      case 0xfc:
14000264f                      case 0xfd:
14000264f                      case 0xfe:
14000264f                      case 0xff:
14000264f                      case 0x101:
14000264f                      case 0x102:
14000264f                      case 0x103:
14000264f                      case 0x104:
14000264f                      case 0x105:
14000264f                      case 0x106:
14000264f                      case 0x107:
14000264f                      case 0x108:
14000264f                      {
14000264f                          (uint8_t)result = 0x29;
140002651                          return result;
14000264f                          break;
14000264f                      }
140002531                      case 3:
140002531                      {
140002531                          return result;
140002531                          break;
140002531                      }
140002683                      case 6:
140002683                      case 0xc:
140002683                      {
140002683                          (uint8_t)result = 0x26;
140002685                          return result;
140002683                          break;
140002683                      }
1400026ad                      case 0xf:
1400026ad                      {
1400026ad                          (uint8_t)result = 0x1f;
1400026af                          return result;
1400026ad                          break;
1400026ad                      }
1400026b0                      case 0x11:
1400026b0                      {
1400026b0                          (uint8_t)result = 0x11;
1400026b2                          return result;
1400026b0                          break;
1400026b0                      }
140002686                      case 0x25:
140002686                      case 0x6e:
140002686                      {
140002686                          (uint8_t)result = 0x18;
140002688                          return result;
140002686                          break;
140002686                      }
140002680                      case 0x4e:
140002680                      case 0xb5:
140002680                      {
140002680                          (uint8_t)result = 0xc;
140002682                          return result;
140002680                          break;
140002680                      }
140002559                      case 0x55:
140002559                      {
140002559                          (uint8_t)result = 0x14;
14000255b                          return result;
140002559                          break;
140002559                      }
14000267d                      case 0x6b:
14000267d                      case 0xe6:
14000267d                      {
14000267d                          (uint8_t)result = 0xb;
14000267f                          return result;
14000267d                          break;
14000267d                      }
1400026b6                      case 0x76:
1400026b6                      {
1400026b6                          (uint8_t)result = 0x24;
1400026b8                          return result;
1400026b6                          break;
1400026b6                      }
140002674                      case 0x77:
140002674                      case 0x100:
140002674                      {
140002674                          (uint8_t)result = 0x16;
140002676                          return result;
140002674                          break;
140002674                      }
14000263c                      case 0x79:
14000263c                      case 0x9f:
14000263c                      case 0xcc:
14000263c                      {
14000263c                          (uint8_t)result = 0x21;
14000263e                          return result;
14000263c                          break;
14000263c                      }
1400026a4                      case 0x82:
1400026a4                      {
1400026a4                          (uint8_t)result = 0x19;
1400026a6                          return result;
1400026a4                          break;
1400026a4                      }
1400026aa                      case 0x8f:
1400026aa                      {
1400026aa                          (uint8_t)result = 0x10;
1400026ac                          return result;
1400026aa                          break;
1400026aa                      }
1400026a1                      case 0xa8:
1400026a1                      {
1400026a1                          (uint8_t)result = 0x1c;
1400026a3                          return result;
1400026a1                          break;
1400026a1                      }
1400026a7                      case 0xdd:
1400026a7                      {
1400026a7                          (uint8_t)result = 0x1b;
1400026a9                          return result;
1400026a7                          break;
1400026a7                      }
1400026b3                      case 0x109:
1400026b3                      {
1400026b3                          (uint8_t)result = 0xe;
1400026b5                          return result;
1400026b3                          break;
1400026b3                      }
140002521                  }
1400024f6              }
1400024ea              break;
1400024ea          }
14000252c          case 3:
14000252c          {
14000252c              return (uint64_t)(uint32_t)(arg1 >> 0x20);
14000252c              break;
14000252c          }
1400024e3      }
1400024d0  }

1400026c2        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                    ..............

1400026d0    int64_t sub_1400026d0(int64_t* arg1, int64_t arg2, int64_t arg3, int64_t arg4 @ rsi)

1400026d0  {
1400026d0      struct IO_STATUS_BLOCK IoStatusBlock;
1400026d0      IoStatusBlock.Information = arg4;
1400026d5      HANDLE rsi = *(uint64_t*)arg1;
1400026d8      int128_t zmm0 = data_1400075b0;
1400026df      IoStatusBlock..Status = (uint32_t)zmm0;
1400026df      IoStatusBlock..Pointer = *(uint64_t*)((char*)zmm0)[8];
1400026e4      uint32_t Length = -1;
1400026e4      
1400026ec      if (arg3 < 0xffffffff)
1400026ec          Length = (uint32_t)arg3;
1400026ec      
140002716      NTSTATUS Status =
140002716          NtReadFile(rsi, nullptr, nullptr, nullptr, &IoStatusBlock, arg2, Length, {0});
140002716      
140002721      if (Status == STATUS_PENDING)
140002721      {
14000272b          WaitForSingleObject(rsi, 0xffffffff);
140002731          Status = IoStatusBlock..Status;
140002721      }
140002721      
14000273a      if (Status == STATUS_END_OF_FILE)
140002745          return 0;
140002745      
14000274b      if (Status == STATUS_PENDING)
140002793          trap(0xd);
140002793      
14000274f      if (Status >= STATUS_SUCCESS)
14000275d          return 0;
14000275d      
140002781      int64_t result;
140002781      (uint8_t)result =
140002781          sub_1400024d0((uint64_t)RtlNtStatusToDosError(Status) << 0x20 | 2) != 0xb;
14000278d      return result;
1400026d0  }

140002795                                                                 0f 0b cc cc cc cc cc cc cc cc cc                       ...........
1400027a0  data_1400027a0:
1400027a0  c6 41 08 02 48 8b 01 48 85 c0 74 0b f0 48 ff 08 75 05 e9 59 f3 ff ff c3 cc cc cc cc cc cc cc cc  .A..H..H..t..H..u..Y............

1400027c0    int64_t sub_1400027c0(int64_t* arg1)

1400027c0  {
1400027ca      int64_t rax = *(uint64_t*)arg1;
1400027cd      int64_t rcx = rax * 2;
1400027d5      int64_t rbx = 4;
1400027d5      
1400027da      if (rcx >= 5)
1400027da          rbx = rcx;
1400027da      
1400027ea      if (rax >> 0x3b)
1400027ea      {
140002859          sub_140006700();
140002859          /* no return */
1400027ea      }
1400027ea      
1400027ef      int64_t r8_1 = rbx << 4;
1400027ef      
140002800      if (r8_1 <= 0x7ffffffffffffff8)
140002800      {
140002805          int64_t var_30;
140002805          int64_t rax_1;
140002805          
140002805          if (rax)
140002805          {
140002813              var_30 = arg1[1];
140002818              int64_t var_20_1 = rax << 4;
14000281d              rax_1 = 8;
140002805          }
140002805          else
140002807              rax_1 = 0;
140002807          
140002822          int64_t var_28_1 = rax_1;
140002836          int32_t var_48;
140002836          sub_1400061e0(&var_48, 8, r8_1, &var_30);
140002836          
140002840          if (var_48 != 1)
140002840          {
140002847              int64_t result;
140002847              arg1[1] = result;
14000284b              *(uint64_t*)arg1 = rbx;
140002855              return result;
140002840          }
140002800      }
140002800      
14000286b      sub_140006700();
14000286b      /* no return */
1400027c0  }

140002870                                                  cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                  ................
140002880  48 8b 11 48 8b 0a 48 8b 42 08 48 c7 02 00 00 00 00 48 85 c9 74 35 c6 01 01 48 c7 00 00 00 00 00  H..H..H.B.H......H..t5...H......
1400028a0  c7 40 08 00 00 00 00 c6 40 0c 00 0f 57 c0 0f 11 40 10 48 c7 40 20 01 00 00 00 48 c7 40 28 00 00  .@......@...W...@.H.@ ....H.@(..
1400028c0  00 00 48 c7 40 2e 00 00 00 00 c3 0f 0b cc cc cc                                                  ..H.@...........

1400028d0    int64_t sub_1400028d0(int64_t* arg1)

1400028d0  {
1400028d5      int64_t* rax = *(uint64_t*)arg1;
1400028d8      char* rsi = *(uint64_t*)rax;
1400028db      *(uint64_t*)rax = 0;
1400028db      
1400028e5      if (!rsi)
140002922          trap(6);
140002922      
1400028e7      data_14000a0e0;
1400028f8      int64_t result = j_sub_140002390(0x3000, 1);
1400028f8      
140002900      if (!result)
140002900      {
140002935          sub_140006700();
140002935          /* no return */
140002900      }
140002900      
140002902      *(uint8_t*)rsi = 0;
140002905      *(uint64_t*)(rsi + 8) = result;
140002909      *(uint64_t*)(rsi + 0x10) = 0x3000;
140002914      __builtin_memset(&rsi[0x18], 0, 0x20);
140002921      return result;
1400028d0  }

14000293a                                                                                cc cc cc cc cc cc                            ......

140002940    int64_t sub_140002940(int64_t* arg1)

140002940  {
140002945      int64_t* rax = *(uint64_t*)arg1;
140002948      int64_t* rsi = *(uint64_t*)rax;
14000294b      *(uint64_t*)rax = 0;
14000294b      
140002955      if (!rsi)
1400029ae          trap(6);
1400029ae      
140002957      data_14000a0e0;
140002968      int64_t result = j_sub_140002390(0x400, 1);
140002968      
140002970      if (!result)
140002970      {
1400029c1          sub_140006700();
1400029c1          /* no return */
140002970      }
140002970      
140002972      *(uint64_t*)rsi = 0;
140002979      rsi[1] = 0;
140002980      *(uint8_t*)((char*)rsi + 0xc) = 0;
140002984      rsi[2] = 0;
14000298c      rsi[3] = 0x400;
140002994      rsi[4] = result;
140002998      rsi[5] = 0;
1400029a0      *(uint64_t*)((char*)rsi + 0x2e) = 0;
1400029ad      return result;
140002940  }

1400029c6                    cc cc cc cc cc cc cc cc cc cc                                                        ..........

1400029d0    void* const sub_1400029d0(int64_t arg1, int64_t* arg2)

1400029d0  {
1400029da      int64_t var_28 = arg1;
1400029df      void* result = nullptr;
1400029df      
140002a02      if (sub_140004280(&var_28, &data_140007c50, arg2))
140002a02      {
140002a07          if (result)
140002a6a              return result;
140002a6a          
140002a09          trap(6);
140002a02      }
140002a02      
140002a13      if (((uint32_t)result & 3) == 1)
140002a13      {
140002a15          void* rsi_1 = *(uint64_t*)((char*)result - 1);
140002a19          int64_t* rdi_1 = *(uint64_t*)((char*)result + 7);
140002a1d          int64_t rdx = *(uint64_t*)rdi_1;
140002a1d          
140002a23          if (rdx)
140002a2b              rdx(rsi_1);
140002a2b          
140002a33          int64_t rdx_1 = rdi_1[1];
140002a33          
140002a3a          if (rdx_1)
140002a46              j_sub_1400023f0(rsi_1, rdx_1, rdi_1[2]);
140002a46          
140002a5c          j_sub_1400023f0((char*)result - 1, 0x18, 8);
140002a13      }
140002a13      
140002a61      return nullptr;
1400029d0  }

140002a6b                                   cc cc cc cc cc                                                             .....

140002a70    char const (** const )[0x22] sub_140002a70(void* arg1)

140002a70  {
140002a80      int64_t r14 = *(uint64_t*)((char*)arg1 + 0x10);
140002a80      
140002a87      if (r14)
140002a87      {
140002aaf          void* rdi_1 = nullptr;
140002aaf          
140002add          while (true)
140002add          {
140002add              *(uint8_t*)((char*)arg1 + 0x18) = 1;
140002ae1              char const (** result_1)[0x22] = r14 - rdi_1;
140002af6              char rax_1;
140002af6              char const (** const result)[0x22];
140002af6              rax_1 = sub_140003760(STD_OUTPUT_HANDLE, 
140002af6                  *(uint64_t*)((char*)arg1 + 8) + rdi_1, result_1, (char*)arg1 + 0x19);
140002af6              
140002afd              if (rax_1 & 1)
140002afd              {
140002b02                  void* rcx_1 = result & 0xffffffff00000003;
140002b02                  
140002b08                  if (rcx_1 == 0x600000002)
140002b08                      result = result_1;
140002b08                  
140002b0c                  if (rcx_1 == 0x600000002)
140002b0c                      rax_1 = 0;
140002afd              }
140002afd              
140002b10              *(uint8_t*)((char*)arg1 + 0x18) = 0;
140002b10              
140002b16              if (rax_1 & 1)
140002b2f                  switch ((uint64_t)(uint32_t)result & 3)
140002b2f                  {
140002abc                      case 0:
140002abc                      {
140002abc                          if (result[2] != 0x23)
140002abc                              goto label_140002c06;
140002abc                          
140002abc                          goto label_140002ad0;
140002abc                      }
140002b35                      case 1:
140002b35                      {
140002b35                          if (*(uint8_t*)((char*)result + 0xf) != 0x23)
140002b35                              goto label_140002c06;
140002b35                          
140002b3e                          void* r14_1 = *(uint64_t*)((char*)result - 1);
140002b42                          int64_t* r12_1 = *(uint64_t*)((char*)result + 7);
140002b46                          int64_t rax_6 = *(uint64_t*)r12_1;
140002b46                          
140002b4d                          if (rax_6)
140002b58                              rax_6(r14_1);
140002b58                          
140002b63                          int64_t rax_7 = r12_1[1];
140002b63                          
140002b6b                          if (rax_7)
140002b7b                              j_sub_1400023f0(r14_1, rax_7, r12_1[2]);
140002b7b                          
140002b94                          j_sub_1400023f0((char*)result - 1, 0x18, 8);
140002b6b                          goto label_140002ad0;
140002b35                      }
140002b2f                      case 2:
140002b2f                      {
140002b2f                          goto label_140002c06;
140002b2f                      }
140002bd0                      case 3:
140002bd0                      {
140002bd0                          if ((result & 0xffffffff00000000) == 0x2300000000)
140002bd0                              goto label_140002ad0;
140002bd0                          
140002bd0                          goto label_140002c06;
140002bd0                      }
140002b2f                  }
140002b16              else if (!result)
140002bb3              {
140002bff                  result = &data_140007bd0;
140002c06              label_140002c06:
140002c06                  
140002c09                  if (rdi_1)
140002c09                  {
140002c0b                      int64_t rax_10 = *(uint64_t*)((char*)arg1 + 0x10);
140002c12                      void* rbx_2 = rax_10 - rdi_1;
140002c12                      
140002c15                      if (rax_10 < rdi_1)
140002c15                      {
140002c5e                          sub_140006700();
140002c5e                          /* no return */
140002c15                      }
140002c15                      
140002c17                      *(uint64_t*)((char*)arg1 + 0x10) = 0;
140002c17                      
140002c1f                      if (rax_10 != rdi_1)
140002c1f                      {
140002c21                          int64_t rcx_6 = *(uint64_t*)((char*)arg1 + 8);
140002c31                          memmove(rcx_6, (char*)rdi_1 + rcx_6, (uint32_t)rbx_2);
140002c39                          *(uint64_t*)((char*)arg1 + 0x10) = rbx_2;
140002c1f                      }
140002c09                  }
140002bb3              }
140002bb3              else
140002bb3              {
140002bb5                  rdi_1 += result;
140002ad0              label_140002ad0:
140002ad0                  r14 = *(uint64_t*)((char*)arg1 + 0x10);
140002ad0                  
140002ad7                  if (rdi_1 >= r14)
140002ad7                  {
140002bdb                      if (!rdi_1)
140002bdb                          break;
140002bdb                      
140002bdf                      result = nullptr;
140002bdf                      
140002be7                      if (rdi_1 > r14)
140002be7                      {
140002bf6                          sub_140006700();
140002bf6                          /* no return */
140002be7                      }
140002ad7                  }
140002ad7                  else
140002ad7                      continue;
140002ad7                  
140002c39                  *(uint64_t*)((char*)arg1 + 0x10) = nullptr;
140002bb3              }
140002bb3              
140002c50              return result;
140002add          }
140002a87      }
140002a87      
140002bfb      return nullptr;
140002a70  }

140002ba6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
140002c63           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

140002c70    int64_t sub_140002c70(int64_t* arg1, int32_t arg2)

140002c70  {
140002c77      int32_t var_1c = 0;
140002c85      int64_t rsi;
140002c85      
140002c85      if (arg2 < 0x80)
140002c85      {
140002c87          (uint8_t)var_1c = (uint8_t)arg2;
140002c8b          rsi = 1;
140002c85      }
140002c85      else if (arg2 < 0x800)
140002c9d      {
140002ca4          (uint8_t)var_1c = (char)(arg2 >> 6) | 0xc0;
140002ca8          (uint8_t)arg2 &= 0x3f;
140002cab          (uint8_t)arg2 |= 0x80;
140002cae          *(uint8_t*)((char*)var_1c)[1] = (uint8_t)arg2;
140002cb2          rsi = 2;
140002c9d      }
140002c9d      else if (arg2 >= 0x10000)
140002cbf      {
140002ced          (uint8_t)var_1c = (char)(arg2 >> 0x12) | 0xf0;
140002cfa          *(uint8_t*)((char*)var_1c)[1] = ((char)(arg2 >> 0xc) & 0x3f) | 0x80;
140002d07          *(uint8_t*)((char*)var_1c)[2] = ((char)(arg2 >> 6) & 0x3f) | 0x80;
140002d0b          (uint8_t)arg2 &= 0x3f;
140002d0e          (uint8_t)arg2 |= 0x80;
140002d11          *(uint8_t*)((char*)var_1c)[3] = (uint8_t)arg2;
140002d15          rsi = 4;
140002cbf      }
140002cbf      else
140002cbf      {
140002cc6          (uint8_t)var_1c = (char)(arg2 >> 0xc) | 0xe0;
140002cd3          *(uint8_t*)((char*)var_1c)[1] = ((char)(arg2 >> 6) & 0x3f) | 0x80;
140002cd7          (uint8_t)arg2 &= 0x3f;
140002cda          (uint8_t)arg2 |= 0x80;
140002cdd          *(uint8_t*)((char*)var_1c)[2] = (uint8_t)arg2;
140002ce1          rsi = 3;
140002cbf      }
140002cbf      
140002d1a      int64_t* rdi = *(uint64_t*)arg1;
140002d20      int64_t rbx = rdi[2];
140002d20      
140002d2a      if (rsi > *(uint64_t*)rdi - rbx)
140002d2a      {
140002d69          sub_140006250(rdi, rbx, rsi, 1, 1);
140002d6e          rbx = rdi[2];
140002d2a      }
140002d2a      
140002d3b      memcpy(rdi[1] + rbx, &var_1c, (uint32_t)rsi);
140002d43      rdi[2] = rbx + rsi;
140002d50      return 0;
140002c70  }

140002d74                                                              cc cc cc cc cc cc cc cc cc cc cc cc                      ............

140002d80    char const (**)[0x22] sub_140002d80(int64_t* arg1, int32_t arg2)

140002d80  {
140002d8e      int32_t var_34 = 0;
140002d9c      void* r8;
140002d9c      
140002d9c      if (arg2 < 0x80)
140002d9c      {
140002d9e          (uint8_t)var_34 = (uint8_t)arg2;
140002da2          r8 = 1;
140002d9c      }
140002d9c      else if (arg2 < 0x800)
140002db5      {
140002dbc          (uint8_t)var_34 = (char)(arg2 >> 6) | 0xc0;
140002dc0          (uint8_t)arg2 &= 0x3f;
140002dc3          (uint8_t)arg2 |= 0x80;
140002dc6          *(uint8_t*)((char*)var_34)[1] = (uint8_t)arg2;
140002dca          r8 = 2;
140002db5      }
140002db5      else if (arg2 >= 0x10000)
140002dd8      {
140002e07          (uint8_t)var_34 = (char)(arg2 >> 0x12) | 0xf0;
140002e14          *(uint8_t*)((char*)var_34)[1] = ((char)(arg2 >> 0xc) & 0x3f) | 0x80;
140002e21          *(uint8_t*)((char*)var_34)[2] = ((char)(arg2 >> 6) & 0x3f) | 0x80;
140002e25          (uint8_t)arg2 &= 0x3f;
140002e28          (uint8_t)arg2 |= 0x80;
140002e2b          *(uint8_t*)((char*)var_34)[3] = (uint8_t)arg2;
140002e2f          r8 = 4;
140002dd8      }
140002dd8      else
140002dd8      {
140002ddf          (uint8_t)var_34 = (char)(arg2 >> 0xc) | 0xe0;
140002dec          *(uint8_t*)((char*)var_34)[1] = ((char)(arg2 >> 6) & 0x3f) | 0x80;
140002df0          (uint8_t)arg2 &= 0x3f;
140002df3          (uint8_t)arg2 |= 0x80;
140002df6          *(uint8_t*)((char*)var_34)[2] = (uint8_t)arg2;
140002dfa          r8 = 3;
140002dd8      }
140002dd8      
140002e38      void* rdi = **(uint64_t**)arg1;
140002e38      
140002e40      if (*(uint64_t*)((char*)rdi + 0x10))
140002e40      {
140002ee0          sub_140006700();
140002ee0          /* no return */
140002e40      }
140002e40      
140002e46      *(uint64_t*)((char*)rdi + 0x10) = -1;
140002e52      void* var_30 = (char*)rdi + 0x18;
140002e61      char const (** result)[0x22] = sub_140003450(&var_30, &var_34, r8);
140002e66      *(uint64_t*)((char*)rdi + 0x10) += 1;
140002e66      
140002e6d      if (result)
140002e6d      {
140002e6f          void* rdi_1 = arg1[1];
140002e6f          
140002e7b          if (((uint32_t)rdi_1 & 3) == 1)
140002e7b          {
140002e80              void* rbx_1 = *(uint64_t*)((char*)rdi_1 - 1);
140002e84              int64_t* r15_1 = *(uint64_t*)((char*)rdi_1 + 7);
140002e88              int64_t rax_13 = *(uint64_t*)r15_1;
140002e88              
140002e8e              if (rax_13)
140002e93                  rax_13(rbx_1);
140002e93              
140002e98              int64_t rdx_1 = r15_1[1];
140002e98              
140002e9f              if (rdx_1)
140002ea8                  j_sub_1400023f0(rbx_1, rdx_1, r15_1[2]);
140002ea8              
140002ebb              j_sub_1400023f0((char*)rdi_1 - 1, 0x18, 8);
140002e7b          }
140002e7b          
140002ec3          arg1[1] = result;
140002e6d      }
140002e6d      
140002eca      (uint8_t)result = result;
140002ed8      return result;
140002d80  }

140002ee5                 cc cc cc cc cc cc cc cc cc cc cc 49 89 d0 48 8d 15 56 4d 00 00 e9 81 13 00 00 cc       ...........I..H..VM........
140002f00  49 89 d0 48 8d 15 16 4d 00 00 e9 71 13 00 00 cc                                                  I..H...M...q....

140002f10    int64_t sub_140002f10(void* arg1)

140002f10  {
140002f17      void* rsi = *(uint64_t*)((char*)arg1 + 8);
140002f1d      int32_t result = (uint32_t)rsi & 3;
140002f1d      
140002f23      if (result != 1)
140002f74          return result;
140002f74      
140002f25      void* rdi = *(uint64_t*)((char*)rsi - 1);
140002f29      int64_t* rbx = *(uint64_t*)((char*)rsi + 7);
140002f2d      int64_t rax_1 = *(uint64_t*)rbx;
140002f2d      
140002f33      if (rax_1)
140002f38          rax_1(rdi);
140002f38      
140002f3d      int64_t rdx = rbx[1];
140002f3d      
140002f44      if (rdx)
140002f4d          j_sub_1400023f0(rdi, rdx, rbx[2]);
140002f4d      
140002f67      /* tailcall */
140002f67      return j_sub_1400023f0((char*)rsi - 1, 0x18, 8);
140002f10  }

140002f75                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........

140002f80    char const (**)[0x22] sub_140002f80(int64_t* arg1, void* arg2, void* arg3)

140002f80  {
140002f8e      void* rdi = **(uint64_t**)arg1;
140002f8e      
140002f96      if (*(uint64_t*)((char*)rdi + 0x10))
140002f96      {
140003034          sub_140006700();
140003034          /* no return */
140002f96      }
140002f96      
140002f9f      *(uint64_t*)((char*)rdi + 0x10) = -1;
140002fab      void* var_30 = (char*)rdi + 0x18;
140002fb5      char const (** result)[0x22] = sub_140003450(&var_30, arg2, arg3);
140002fba      *(uint64_t*)((char*)rdi + 0x10) += 1;
140002fba      
140002fc1      if (result)
140002fc1      {
140002fc3          void* rdi_1 = arg1[1];
140002fc3          
140002fcf          if (((uint32_t)rdi_1 & 3) == 1)
140002fcf          {
140002fd4              void* rbx_1 = *(uint64_t*)((char*)rdi_1 - 1);
140002fd8              int64_t* r15_1 = *(uint64_t*)((char*)rdi_1 + 7);
140002fdc              int64_t rax_2 = *(uint64_t*)r15_1;
140002fdc              
140002fe2              if (rax_2)
140002fe7                  rax_2(rbx_1);
140002fe7              
140002fec              int64_t rdx = r15_1[1];
140002fec              
140002ff3              if (rdx)
140002ffc                  j_sub_1400023f0(rbx_1, rdx, r15_1[2]);
140002ffc              
14000300f              j_sub_1400023f0((char*)rdi_1 - 1, 0x18, 8);
140002fcf          }
140002fcf          
140003017          arg1[1] = result;
140002fc1      }
140002fc1      
14000301e      (uint8_t)result = result;
14000302c      return result;
140002f80  }

140003039                                                                             cc cc cc cc cc cc cc                           .......

140003040    int64_t sub_140003040(int64_t* arg1, int64_t arg2, int64_t arg3)

140003040  {
14000304c      int64_t* rdi = *(uint64_t*)arg1;
140003052      int64_t rbx = rdi[2];
140003052      
14000305c      if (arg3 > *(uint64_t*)rdi - rbx)
14000305c      {
14000309b          sub_140006250(rdi, rbx, arg3, 1, 1);
1400030a3          rbx = rdi[2];
14000305c      }
14000305c      
140003068      memcpy(rdi[1] + rbx, arg2, (uint32_t)arg3);
140003070      rdi[2] = rbx + arg3;
14000307f      return 0;
140003040  }

1400030a9                             cc cc cc cc cc cc cc                                                           .......

1400030b0    int64_t sub_1400030b0(int64_t* arg1, char arg2, int64_t* arg3)

1400030b0  {
1400030e1      void* rcx = nullptr;
1400030fb      int64_t result;
1400030fb      
1400030fb      while (true)
1400030fb      {
1400030fb          void* r12_1 = *(uint64_t*)arg1;
1400030fe          int64_t rax_1 = arg1[2];
140003102          int64_t r15_2 = arg1[3];
140003106          void* r15_1 = r15_2 - rax_1;
140003106          
140003109          if (r15_2 <= rax_1)
140003109          {
140003130              uint64_t r13_1 = arg1[1];
140003134              void* rcx_5 = arg1[4];
140003143              memset((char*)rcx_5 + r12_1, 0, r13_1 - rcx_5);
140003151              char rax_2;
140003151              void* rdx_1;
140003151              rax_2 = sub_140003c30(&arg1[5], r12_1, r13_1);
140003156              r15_1 = rdx_1;
14000315b              void* rax_3;
14000315b              
14000315b              if (!(rax_2 & 1))
14000315b              {
140003238                  rax_3 = r15_1;
140003238                  
14000323e                  if (r13_1 >= r15_1)
14000323e                      goto label_140003247;
14000323e                  
1400033ec                  trap(6);
14000315b              }
14000315b              
140003164              if (!r15_1)
140003164              {
140003245                  rax_3 = nullptr;
140003247              label_140003247:
140003247                  arg1[2] = 0;
14000324f                  arg1[3] = rax_3;
140003253                  arg1[4] = r13_1;
140003257                  r15_1 = rax_3;
14000325a                  rax_1 = 0;
14000325c              label_14000325c:
14000325c                  char* r12_3 = (char*)r12_1 + rax_1;
140003263                  int64_t rdx_3;
140003263                  
140003263                  if (r15_1 <= 0xf)
140003263                  {
140003268                      if (!r15_1)
140003268                          goto label_1400032ad;
140003268                      
14000326a                      rdx_3 = 0;
14000326a                      
140003274                      while (r12_3[rdx_3] != arg2)
140003274                      {
14000327a                          rdx_3 += 1;
14000327a                          
140003280                          if (r15_1 == rdx_3)
140003280                              goto label_1400032ad;
140003274                      }
140003274                      
140003274                      goto label_14000334a;
140003263                  }
140003263                  
140003298                  char rax_7;
140003298                  rax_7 = sub_140004940(arg2, r12_3, r15_1);
140003298                  
14000329f                  if (!(rax_7 & 1))
14000329f                  {
1400032ad                  label_1400032ad:
1400032ad                      void* r13_3 = arg3[2];
1400032ad                      
1400032bc                      if (r15_1 > *(uint64_t*)arg3 - r13_3)
1400032bc                      {
14000332a                          sub_140006250(arg3, r13_3, r15_1, 1, 1);
14000332f                          r13_3 = arg3[2];
1400032bc                      }
1400032bc                      
1400032d0                      memcpy(arg3[1] + r13_3, r12_3, (uint32_t)r15_1);
1400032dc                      void* rax_11 = arg1[2] + r15_1;
1400032df                      void* rcx_21 = arg1[3];
1400032df                      
1400032e6                      if (rcx_21 < rax_11)
1400032e6                          rax_11 = rcx_21;
1400032e6                      
1400032ea                      arg3[2] = (char*)r13_3 + r15_1;
1400032ee                      arg1[2] = rax_11;
1400032f7                      rcx += r15_1;
1400032f7                      
140003302                      if (r15_1)
140003302                          continue;
140003302                      
1400033a3                      result = 0;
1400033a5                      break;
14000329f                  }
14000329f                  
140003340                  if (rdx_3 == -1)
1400033ec                      trap(6);
1400033ec                  
14000334a              label_14000334a:
14000334a                  
14000334d                  if (rdx_3 >= r15_1)
14000334d                  {
1400033fb                      sub_140006700();
1400033fb                      /* no return */
14000334d                  }
14000334d                  
14000335b                  int64_t r14_1 = arg3[2];
14000335b                  
140003365                  if (rdx_3 >= *(uint64_t*)arg3 - r14_1)
140003365                  {
1400033de                      sub_140006250(arg3, r14_1, rdx_3 + 1, 1, 1);
1400033e3                      r14_1 = arg3[2];
140003365                  }
140003365                  
140003379                  memcpy(arg3[1] + r14_1, r12_3, (rdx_3 + 1));
140003381                  arg3[2] = r14_1 + rdx_3 + 1;
140003389                  int64_t rax_15 = arg1[2] + rdx_3 + 1;
14000338c                  int64_t rcx_27 = arg1[3];
14000338c                  
140003393                  if (rcx_27 < rax_15)
140003393                      rax_15 = rcx_27;
140003393                  
140003397                  arg1[2] = rax_15;
1400033a3                  result = 0;
1400033a5                  break;
140003164              }
140003164              
14000317e              rax_3 = nullptr;
14000317e              
140003190              if ((r15_1 & 0xffffffff00000003) == 0x600000002)
140003190                  goto label_140003247;
140003190              
140003196              *(uint128_t*)((char*)arg1 + 0x10) = {0};
14000319a              arg1[4] = r13_1;
1400031a4              result = 1;
1400031a4              
1400031b0              switch ((uint64_t)(uint32_t)r15_1 & 3)
1400031b0              {
1400031b0                  case 0:
1400031b0                  {
1400031b0                      goto label_1400030f0;
1400031b0                  }
1400031b0                  case 1:
1400031b0                  {
1400031b0                      goto label_1400031b2;
1400031b0                  }
1400031b0                  case 2:
1400031b0                  {
1400031b0                      break;
1400031b0                      break;
1400031b0                  }
1400031b0                  case 3:
1400031b0                  {
1400031b0                      goto label_14000322a;
1400031b0                  }
1400031b0              }
140003109          }
140003109          else
140003109          {
14000310e              if (r12_1)
14000310e                  goto label_14000325c;
14000310e              
14000311a              result = 1;
14000311a              
140003126              switch ((uint64_t)(uint32_t)r15_1 & 3)
140003126              {
1400030f0                  case 0:
1400030f0                  {
1400030f0                  label_1400030f0:
1400030f0                      
1400030f5                      if (*(uint8_t*)((char*)r15_1 + 0x10) != 0x23)
1400030f5                          break;
1400030f5                      
1400030f5                      continue;
1400030f0                  }
1400031b2                  case 1:
1400031b2                  {
1400031b2                  label_1400031b2:
1400031b2                      
1400031b7                      if (*(uint8_t*)((char*)r15_1 + 0xf) != 0x23)
1400031b7                          break;
1400031b7                      
1400031bd                      void* r12_2 = *(uint64_t*)((char*)r15_1 - 1);
1400031c1                      int64_t* r13_2 = *(uint64_t*)((char*)r15_1 + 7);
1400031c5                      int64_t rax_4 = *(uint64_t*)r13_2;
1400031c5                      
1400031cc                      if (rax_4)
1400031d1                          rax_4(r12_2);
1400031d1                      
1400031d3                      int64_t rdx_2 = r13_2[1];
1400031d3                      
1400031da                      if (rdx_2)
1400031e3                          j_sub_1400023f0(r12_2, rdx_2, r13_2[2]);
1400031e3                      
1400031f9                      j_sub_1400023f0((char*)r15_1 - 1, 0x18, 8);
1400031fe                      continue;
1400031b2                  }
140003126                  case 2:
140003126                  {
140003126                      break;
140003126                      break;
140003126                  }
14000322a                  case 3:
14000322a                  {
14000322a                  label_14000322a:
14000322a                      
14000322d                      if ((r15_1 & 0xffffffff00000000) != 0x2300000000)
140003335                          return 1;
140003335                      
14000322d                      continue;
14000322a                  }
140003126              }
140003109          }
1400030fb      }
1400030fb      
1400033c0      return result;
1400030b0  }

1400030ea                                66 0f 1f 44 00 00                                                            f..D..
140003128                          0f 1f 84 00 00 00 00 00                                                          ........
140003203           66 66 66 66 2e 0f 1f 84 00 00 00 00 00                                                     ffff.........
140003284              66 66 66 2e 0f 1f 84 00 00 00 00 00                                                      fff.........
140003400  cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                  ................

140003410    int64_t sub_140003410(int64_t arg1, enum HEAP_FLAGS arg2, uint64_t arg3)

140003410  {
14000341b      HANDLE rax = GetProcessHeap();
14000341b      
140003424      if (!rax)
140003443          return 0;
140003443      
140003434      /* tailcall */
140003434      return HeapAlloc(rax, arg2, arg3);
140003410  }

140003444              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

140003450    char const (**)[0x22] sub_140003450(int64_t* arg1, void* arg2, void* arg3)

140003450  {
14000345b      void* rsi = arg3;
14000345e      void* rdi = arg2;
140003461      int64_t* rbx = arg1;
140003464      (uint8_t)arg1 = 0xa;
140003466      char rax;
140003466      void* rdx;
140003466      rax = sub_140004a20((uint8_t)arg1, arg2, arg3);
14000346d      char const (** result)[0x22];
14000346d      int64_t* rbx_1;
14000346d      void* const r14_2;
14000346d      
14000346d      if (!(rax & 1))
14000346d      {
1400034c8          rbx_1 = *(uint64_t*)rbx;
1400034cb          r14_2 = rbx_1[2];
1400034cb          
1400034d2          if (!r14_2)
1400034d2          {
1400034f3              r14_2 = nullptr;
1400034fc          label_1400034fc:
1400034fc              
1400034ff              if (rsi >= *(uint64_t*)rbx_1 - r14_2)
140003584                  /* tailcall */
140003584                  return sub_1400064f0(rbx_1, rdi, rsi);
140003584              
14000350e          label_14000350e:
14000350e              memcpy(rbx_1[1] + r14_2, rdi, (uint32_t)rsi);
140003516              rbx_1[2] = (char*)r14_2 + rsi;
14000351a              return nullptr;
1400034d2          }
1400034d2          
1400034de          if (*(uint8_t*)(rbx_1[1] + r14_2 - 1) != 0xa)
1400034de              goto label_1400034fc;
1400034de          
1400034e3          result = sub_140002a70(rbx_1);
1400034e3          
1400034eb          if (!result)
1400034eb          {
1400034ed              r14_2 = rbx_1[2];
1400034f1              goto label_1400034fc;
1400034eb          }
14000346d      }
14000346d      else
14000346d      {
140003475          void* temp0_1 = rsi;
140003475          rsi -= (char*)rdx + 1;
140003475          
140003478          if (temp0_1 < (char*)rdx + 1)
1400035a1              trap(6);
1400035a1          
14000347e          rbx_1 = *(uint64_t*)rbx;
140003481          void* r15_1 = rbx_1[2];
140003481          
140003488          if (!r15_1)
140003488          {
140003532              result = sub_1400035b0((char*)rbx_1 + 0x19, rdi, (char*)rdx + 1);
140003551              void* rcx_7;
140003551              (uint8_t)rcx_7 = (-0xfffffffd & result) == 0x600000002;
140003551              
14000355c              if (!result | (uint8_t)rcx_7)
14000355c              {
14000355e              label_14000355e:
14000355e                  rdi += (char*)rdx + 1;
140003564                  r14_2 = rbx_1[2];
140003564                  
14000356e                  if (rsi < *(uint64_t*)rbx_1 - r14_2)
14000356e                      goto label_14000350e;
14000356e                  
140003584                  /* tailcall */
140003584                  return sub_1400064f0(rbx_1, rdi, rsi);
14000355c              }
140003488          }
140003488          else if ((char*)rdx + 1 >= *(uint64_t*)rbx_1 - r15_1)
140003497          {
140003592              result = sub_1400064f0(rbx_1, rdi, (char*)rdx + 1);
140003592              
14000359a              if (!result)
14000359a                  goto label_1400034b9;
140003497          }
140003497          else
140003497          {
1400034aa              memcpy(rbx_1[1] + r15_1, rdi, ((char*)rdx + 1));
1400034b2              rbx_1[2] = (char*)r15_1 + (char*)rdx + 1;
1400034b9          label_1400034b9:
1400034b9              result = sub_140002a70(rbx_1);
1400034b9              
1400034c1              if (!result)
1400034c1                  goto label_14000355e;
140003497          }
14000346d      }
140003527      return result;
140003450  }

1400035a3           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

1400035b0    char const (** const )[0x1d] sub_1400035b0(char* arg1, char* arg2, void* arg3)

1400035b0  {
1400035c3      if (arg3)
1400035c3      {
1400035c9          void* i = arg3;
1400035cc          char* rdi_1 = arg2;
1400035cc          
1400035f3          do
1400035f3          {
140003607              char rax_1;
140003607              char const (** const result)[0x1d];
140003607              rax_1 = sub_140003760(STD_OUTPUT_HANDLE, rdi_1, i, arg1);
140003607              
14000360e              if (!(rax_1 & 1))
14000360e              {
140003683                  if (!result)
1400036c0                      return &data_140007d28;
1400036c0                  
14000368b                  if (i < result)
14000368b                  {
1400036d2                      sub_140006700();
1400036d2                      /* no return */
14000368b                  }
14000368b                  
14000368d                  rdi_1 += result;
140003690                  i -= result;
14000360e              }
14000360e              else
14000361c                  switch ((uint64_t)(uint32_t)result & 3)
14000361c                  {
1400035e6                      case 0:
1400035e6                      {
1400035e6                          if (result[2] != 0x23)
1400036bf                              return result;
1400035e6                          break;
1400035e6                      }
140003622                      case 1:
140003622                      {
140003622                          if (*(uint8_t*)((char*)result + 0xf) != 0x23)
1400036bf                              return result;
1400036bf                          
140003628                          void* r14_1 = *(uint64_t*)((char*)result - 1);
14000362c                          int64_t* r13_1 = *(uint64_t*)((char*)result + 7);
140003630                          int64_t rax_6 = *(uint64_t*)r13_1;
140003630                          
140003637                          if (rax_6)
14000363f                              rax_6(r14_1);
14000363f                          
140003644                          int64_t rax_7 = r13_1[1];
140003644                          
14000364b                          if (rax_7)
14000365a                              j_sub_1400023f0(r14_1, rax_7, r13_1[2]);
14000365a                          
140003673                          j_sub_1400023f0((char*)result - 1, 0x18, 8);
140003622                          break;
140003622                      }
1400036bf                      case 2:
1400036bf                      {
1400036bf                          return result;
1400036bf                          break;
1400036bf                      }
1400036a2                      case 3:
1400036a2                      {
1400036a2                          if ((int32_t)(result >> 0x20) != 0x23)
1400036bf                              return result;
1400036a2                          break;
1400036a2                      }
14000361c                  }
1400035f3          } while (i);
1400035c3      }
1400035c3      
1400036aa      return nullptr;
1400035b0  }

14000367d                                                                                         0f 1f 00                               ...
1400036d7                                                                       cc cc cc cc cc cc cc cc cc                         .........

1400036e0    int64_t sub_1400036e0()

1400036e0  {
1400036f3      HMODULE hModule = GetModuleHandleA("kernel32");
1400036fc      int64_t (* r8)();
1400036fc      
1400036fc      if (!hModule)
14000371e          r8 = sub_140003740;
1400036fc      else
1400036fc      {
140003708          int64_t (* rax)() = GetProcAddress(hModule, "SetThreadDescription");
140003711          r8 = sub_140003740;
140003711          
140003718          if (rax)
140003718              r8 = rax;
1400036fc      }
1400036fc      
140003725      data_14000a028 = r8;
140003738      /* jump -> r8 */
1400036e0  }

14000373b                                                                                   cc cc cc cc cc                             .....

140003740    int64_t sub_140003740()

140003740  {
140003749      SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
140003758      return 0x80004001;
140003740  }

140003759                                                                             cc cc cc cc cc cc cc                           .......

140003760    int64_t sub_140003760(enum STD_HANDLE arg1, char* arg2, int64_t arg3, char* arg4)

140003760  {
140003771      if (!arg3)
1400037a2          return 0;
1400037a2      
14000377c      HANDLE rax = GetStdHandle(arg1);
140003785      int64_t result = 1;
140003785      
14000378d      if (rax)
14000378d      {
140003793          if (rax == -1)
140003793          {
140003795              GetLastError();
1400038bb              return 1;
140003793          }
140003793          
1400037b8          NTSTATUS Status_1 = STATUS_SUCCESS;
1400037cb          BOOL rax_2 = GetConsoleMode(rax, &Status_1);
1400037d3          uint32_t rax_3;
1400037d3          
1400037d3          if (rax_2)
1400037d5              rax_3 = GetConsoleOutputCP();
1400037d5          
1400037e0          if (!rax_2 || rax_3 == 0xfde9)
1400037e0          {
1400037e9              Status_1 = data_1400075b0;
1400037ee              uint32_t Length = -1;
1400037ee              
1400037f6              if (arg3 < 0xffffffff)
1400037f6                  Length = (uint32_t)arg3;
1400037f6              
14000381b              NTSTATUS Status = NtWriteFile(rax, nullptr, nullptr, nullptr, &Status_1, 
14000381b                  arg2, Length, {0});
14000381b              
140003826              if (Status == STATUS_PENDING)
140003826              {
140003830                  WaitForSingleObject(rax, 0xffffffff);
140003836                  Status = Status_1;
140003836                  
14000383f                  if (Status == STATUS_PENDING)
140003a19                      trap(0xd);
140003826              }
140003826              
140003847              if (Status >= STATUS_SUCCESS)
14000384e                  return 0;
14000384e              
1400038ab              RtlNtStatusToDosError(Status);
1400038bb              return 1;
1400037e0          }
1400037e0          
140003852          uint64_t rcx_3 = (uint64_t)arg4[4];
14000385a          uint8_t* var_50;
14000385a          void* var_48;
14000385a          
14000385a          if (!rcx_3)
14000385a          {
1400038d6              int64_t r8_1 = 0x1000;
1400038d6              
1400038dc              if (arg3 < 0x1000)
1400038dc                  r8_1 = arg3;
1400038dc              
1400038e8              char var_40;
1400038e8              sub_140004b10(&var_40, arg2, r8_1);
1400038f2              uint8_t* var_38;
1400038f2              void* var_30;
1400038f2              
1400038f2              if (!(var_40 & 1))
140003949                  return sub_140003a20(rax, var_38, var_30);
140003949              
1400038fc              if (var_38)
1400038fc              {
140003905                  if (var_38 > arg3)
140003905                  {
140003a0f                      sub_140006700();
140003a0f                      /* no return */
140003905                  }
140003905                  
140003913                  sub_140004b10(&Status_1, arg2, var_38);
140003913                  
14000391d                  if ((uint8_t)Status_1 & 1)
1400039b5                      trap(6);
1400039b5                  
140003949                  return sub_140003a20(rax, var_50, var_48);
1400038fc              }
1400038fc              
1400039b7              uint64_t rax_6 = (uint64_t)*(uint8_t*)arg2;
1400039b7              
1400039c8              if (arg3 < (uint64_t)*(uint8_t*)(rax_6 + &data_140007d55))
1400039c8              {
1400039ca                  *(uint8_t*)arg4 = (uint8_t)rax_6;
1400039cd                  arg4[4] = 1;
1400038a5                  return 0;
1400039c8              }
1400039c8              
1400039d7              result = 1;
14000385a          }
14000385a          else
14000385a          {
14000385f              if ((uint8_t)rcx_3 >= 4)
1400039b5                  trap(6);
1400039b5              
140003868              char r8 = *(uint8_t*)arg2;
140003870              result = 1;
140003870              
140003875              if (r8 >= 0xc0)
14000392f                  arg4[4] = 0;
140003875              else
140003875              {
14000387b                  arg4[rcx_3] = r8;
140003883                  char rax_4 = arg4[4] + 1;
140003885                  arg4[4] = rax_4;
140003892                  void* rdi_2 =
140003892                      (uint64_t)*(uint8_t*)((uint64_t)*(uint8_t*)arg4 + &data_140007d55);
140003892                  
14000389a                  if (rax_4 < (uint8_t)rdi_2)
1400038a5                      return 0;
1400038a5                  
140003959                  if (rax_4 >= 5)
140003959                  {
1400039fa                      sub_140006700();
1400039fa                      /* no return */
140003959                  }
140003959                  
140003967                  sub_140004b10(&Status_1, arg4, (uint64_t)rax_4);
14000396c                  arg4[4] = 0;
140003970                  result = 1;
140003970                  
14000397a                  if (!((uint8_t)Status_1 & 1))
14000397a                  {
14000398d                      if (var_48 != rdi_2)
1400039b5                          trap(6);
1400039b5                      
14000399a                      char rax_5;
14000399a                      int64_t rdx_15;
14000399a                      rax_5 = sub_140003a20(rax, var_50, rdi_2);
1400039a1                      result = 1;
1400039a1                      
1400039a6                      if (!(rax_5 & 1))
1400039a6                      {
1400039af                          if (rdi_2 == rdx_15)
1400038a5                              return 0;
1400038a5                          
1400039b5                          trap(6);
1400039a6                      }
14000397a                  }
140003875              }
14000385a          }
14000378d      }
14000378d      
1400038ce      return result;
140003760  }

140003a1b                                                                                   0f 0b cc cc cc                             .....

140003a20    int64_t sub_140003a20(HANDLE arg1, uint8_t* arg2, void* arg3)

140003a20  {
140003a2a      __chkstk(0x2038);
140003a3f      void* rsi;
140003a3f      
140003a3f      if (arg3 >= 0x1001)
140003a3f      {
140003a46          rsi = 0x1000;
140003a46          
140003a52          if (arg2[0x1000] <= 0xbf)
140003a52          {
140003a54              rsi = 0xfff;
140003a54              
140003a60              if (arg2[0xfff] <= 0xbf)
140003a60              {
140003a6b                  void* const rcx;
140003a6b                  (uint8_t)rcx = arg2[0xffe] >= 0xc0;
140003a6e                  rsi = (char*)rcx + 0xffd;
140003a6e                  
140003a7d                  if (*(uint8_t*)(arg2 + rcx + 0xffd) < 0xc0)
140003a7d                  {
140003c1d                      sub_140006700();
140003c1d                      /* no return */
140003a7d                  }
140003a60              }
140003a52          }
140003a3f      }
140003a3f      else
140003a41          rsi = arg3;
140003a41      
140003aa5      wchar16 var_2020[0x1000];
140003aa5      int32_t nNumberOfCharsToWrite = MultiByteToWideChar(0xfde9, MB_ERR_INVALID_CHARS, 
140003aa5          arg2, (uint32_t)rsi, &var_2020, 0x1000);
140003aa5      
140003aad      if (nNumberOfCharsToWrite)
140003aad      {
140003ab3          int64_t nNumberOfCharsToWrite_1 = (int64_t)nNumberOfCharsToWrite;
140003ab3          
140003abb          if (nNumberOfCharsToWrite >= 0x1001)
140003abb          {
140003bfa              sub_140006700();
140003bfa              /* no return */
140003abb          }
140003abb          
140003ac1          uint32_t numberOfCharsWritten = 0;
140003ac1          
140003aea          if (!WriteConsoleW(arg1, &var_2020, nNumberOfCharsToWrite, 
140003aea              &numberOfCharsWritten, 0))
140003aea          {
140003bbe              GetLastError();
140003bce              return 1;
140003aea          }
140003aea          
140003af0          uint64_t numberOfCharsWritten_1 = (uint64_t)numberOfCharsWritten;
140003af0          
140003af7          if (nNumberOfCharsToWrite_1 == numberOfCharsWritten_1)
140003bd7              return 0;
140003bd7          
140003afd          if (nNumberOfCharsToWrite_1 > numberOfCharsWritten_1)
140003afd          {
140003b15              if ((uint32_t)(var_2020[numberOfCharsWritten_1] + 0x2312) < 0x312)
140003b15              {
140003b1f                  numberOfCharsWritten = 0;
140003b46                  void var_2058;
140003b46                  
140003b46                  if (!WriteConsoleW(arg1, 
140003b46                          &var_2058 + (numberOfCharsWritten_1 << 1) + 0x38, 1, 
140003b46                          &numberOfCharsWritten, 0))
140003b48                      GetLastError();
140003b48                  
140003b4e                  numberOfCharsWritten_1 += 1;
140003b15              }
140003b15              
140003b54              if (numberOfCharsWritten_1 > nNumberOfCharsToWrite_1)
140003b54              {
140003c0c                  sub_140006700();
140003c0c                  /* no return */
140003b54              }
140003b54              
140003b5d              if (numberOfCharsWritten_1)
140003b5d              {
140003b62                  int64_t i = 0;
140003b64                  rsi = nullptr;
140003b64                  
140003b7a                  do
140003b7a                  {
140003b7c                      uint32_t rcx_3 = (uint32_t)*(uint16_t*)(&var_2020 + i);
140003b81                      void* rdx_3 = 1;
140003b81                      
140003b8c                      if (rcx_3 >= 0x80)
140003b8c                      {
140003b92                          rdx_3 = 2;
140003b92                          
140003b9e                          if ((uint32_t)(uint16_t)rcx_3 >= 0x800)
140003b9e                          {
140003bb1                              int64_t rdx_4;
140003bb1                              (uint8_t)rdx_4 =
140003bb1                                  (uint32_t)((uint16_t)rcx_3 + 0x2312) >= 0x312;
140003bb4                              rdx_3 = (rdx_4 << 1) + 1;
140003b9e                          }
140003b8c                      }
140003b8c                      
140003b70                      rsi += rdx_3;
140003b73                      i += 2;
140003b7a                  } while (numberOfCharsWritten_1 * 2 != i);
140003b5d              }
140003b5d              
140003bd7              return 0;
140003afd          }
140003aad      }
140003aad      
140003be9      trap(6);
140003a20  }

140003b68                          0f 1f 84 00 00 00 00 00                                                          ........
140003c22        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                                                    ..............

140003c30    int64_t sub_140003c30(int16_t* arg1, int64_t arg2, uint64_t arg3)

140003c30  {
140003c38      int64_t rsi;
140003c38      int64_t var_28 = rsi;
140003c40      __chkstk(0x2040);
140003c56      HANDLE hConsoleHandle = GetStdHandle(STD_INPUT_HANDLE);
140003c56      
140003c5f      if (hConsoleHandle)
140003c5f      {
140003c65          if (hConsoleHandle != -1)
140003c65          {
140003c9e              enum CONSOLE_MODE var_2038 = 0;
140003cb9              int64_t result;
140003cb9              
140003cb9              if (!GetConsoleMode(hConsoleHandle, &var_2038))
140003cb9              {
140003d19                  var_2038 = hConsoleHandle;
140003d29                  uint64_t rdx_5;
140003d29                  result = sub_1400026d0(&var_2038, arg2, arg3, rsi);
140003c9d                  return result;
140003cb9              }
140003cb9              
140003cbb              uint64_t r13_1 = (uint64_t)arg1[3];
140003cc3              uint64_t rsi_3 = r13_1;
140003cc3              
140003cc6              if (arg3 < r13_1)
140003cc6                  rsi_3 = arg3;
140003cc6              
140003cce              if (rsi_3 >= 5)
140003cce              {
140003edf                  sub_140006700();
140003edf                  /* no return */
140003cce              }
140003cce              
140003ce1              memcpy(arg2, &arg1[1], (uint32_t)rsi_3);
140003ce9              HANDLE hConsoleHandle_1;
140003ce9              
140003ce9              if (arg3 >= r13_1)
140003ce9              {
140003d38                  hConsoleHandle_1 = hConsoleHandle;
140003d3b                  arg1[3] = 0;
140003d3b                  
140003d41                  if (arg3 <= r13_1)
140003d12                      return 0;
140003ce9              }
140003ce9              else
140003ce9              {
140003cfb                  memmove(&arg1[1], &arg1[1] + rsi_3, 4 - (uint32_t)rsi_3);
140003d07                  hConsoleHandle_1 = hConsoleHandle;
140003d0a                  arg1[3] -= (uint8_t)rsi_3;
140003d0a                  
140003d10                  if (arg3 <= r13_1)
140003d12                      return 0;
140003ce9              }
140003ce9              
140003d46              uint64_t r12_3 = arg3 - rsi_3;
140003d46              
140003d4d              if (r12_3 >= 4)
140003d4d              {
140003d94                  uint64_t r9_2 = 0x1000;
140003d94                  
140003d9a                  if (arg3 < 0x3003)
140003d9a                      r9_2 = (uint64_t)((uint16_t)arg3 / 3);
140003d9a                  
140003dae                  char rax_7;
140003dae                  uint64_t rdx_9;
140003dae                  rax_7 = sub_140003f10(hConsoleHandle_1, &var_2038, 0x1000, r9_2, arg1);
140003dae                  
140003db8                  if (!(rax_7 & 1))
140003db8                  {
140003e1b                      if (rdx_9 >= 0x1001)
140003e1b                      {
140003f07                          sub_140006700();
140003f07                          /* no return */
140003e1b                      }
140003e1b                      
140003e24                      int32_t rax_9;
140003e24                      
140003e24                      if (rdx_9)
140003e24                      {
140003e2d                          int128_t var_2048_2 = {0};
140003e32                          int32_t var_2050_2 = (uint32_t)arg3;
140003e37                          int64_t var_2058_4 = arg2;
140003e4b                          rax_9 = WideCharToMultiByte(0xfde9, 0x80, &var_2038);
140003e24                      }
140003e24                      
140003e53                      result = rdx_9 && !rax_9 ? 1 : 0;
140003db8                  }
140003db8                  else
140003dba                      result = 1;
140003dba                  
140003c9d                  return result;
140003d4d              }
140003d4d              
140003d4f              (uint16_t)var_2038 = 0;
140003d6c              char rax_3;
140003d6c              uint64_t rdx_7;
140003d6c              rax_3 = sub_140003f10(hConsoleHandle_1, &var_2038, 1, 1, arg1);
140003d6c              
140003d76              if (!(rax_3 & 1))
140003d76              {
140003dcb                  if (rdx_7 >= 2)
140003dcb                  {
140003ef3                      sub_140006700();
140003ef3                      /* no return */
140003dcb                  }
140003dcb                  
140003dd4                  int32_t rax_8;
140003dd4                  
140003dd4                  if (!rdx_7)
140003dd4                  {
140003e5a                      rax_8 = 0;
140003e5c                  label_140003e5c:
140003e5c                      arg1[3] = (uint8_t)rax_8;
140003e62                      uint64_t r13_2 = (uint64_t)(uint8_t)rax_8;
140003e69                      uint64_t r14_1 = r13_2;
140003e69                      
140003e6c                      if (r12_3 < r13_2)
140003e6c                          r14_1 = r12_3;
140003e6c                      
140003e79                      memcpy(arg2 + rsi_3, &arg1[1], (uint32_t)r14_1);
140003e81                      char rax_10;
140003e81                      
140003e81                      if (r12_3 >= r13_2)
140003ea1                          rax_10 = 0;
140003e81                      else
140003e81                      {
140003e93                          memmove(&arg1[1], &arg1[1] + r14_1, 4 - (uint32_t)r14_1);
140003e9c                          rax_10 = arg1[3] - (uint8_t)r14_1;
140003e81                      }
140003e81                      
140003ea3                      arg1[3] = rax_10;
140003ea9                      return 0;
140003dd4                  }
140003dd4                  
140003ddd                  int128_t var_2048_1 = {0};
140003de2                  void* var_2058_3 = &arg1[1];
140003de7                  int32_t var_2050_1 = 4;
140003dfe                  rax_8 = WideCharToMultiByte(0xfde9, 0x80, &var_2038);
140003dfe                  
140003e06                  if (rax_8)
140003e06                      goto label_140003e5c;
140003d76              }
140003c65          }
140003c65          else
140003c67              GetLastError();
140003c5f      }
140003c5f      
140003c83      return 1;
140003c30  }

140003f0c                                      cc cc cc cc                                                              ....

140003f10    int64_t sub_140003f10(HANDLE arg1, int16_t* arg2, int64_t arg3, int64_t arg4, int16_t* arg5)

140003f10  {
140003f20      int64_t rbx = arg4;
140003f2e      int16_t rax = *(uint16_t*)arg5;
140003f3e      int64_t var_70;
140003f3e      void* lpBuffer;
140003f3e      
140003f3e      if (!rax)
140003f3e      {
140003f80          if (rbx > arg3)
140003f80          {
1400040cf              sub_140006700();
1400040cf              /* no return */
140003f80          }
140003f80          
140003f86          var_70 = 0;
140003f8f          lpBuffer = arg2;
140003f3e      }
140003f3e      else
140003f3e      {
140003f40          *(uint16_t*)arg2 = rax;
140003f43          *(uint16_t*)arg5 = 0;
140003f4c          int64_t rcx_1 = 2;
140003f4c          
140003f51          if (rbx != 1)
140003f51              rcx_1 = rbx;
140003f51          
140003f58          if (!rcx_1)
140003f58          {
1400040ae              sub_140006700();
1400040ae              /* no return */
140003f58          }
140003f58          
140003f61          if (rcx_1 > arg3)
140003f61          {
1400040bd              sub_140006700();
1400040bd              /* no return */
140003f61          }
140003f61          
140003f6a          lpBuffer = &arg2[1];
140003f73          var_70 = 1;
140003f78          rbx = rcx_1 - 1;
140003f3e      }
140003f3e      
140003f92      int128_t zmm0 = data_140007cd0;
140003f99      CONSOLE_READCONSOLE_CONTROL inputControl;
140003f99      inputControl.nLength = (uint32_t)zmm0;
140003f99      inputControl.nInitialChars = *(uint32_t*)((char*)zmm0)[4];
140003f99      inputControl.dwCtrlWakeupMask = *(uint32_t*)((char*)zmm0)[8];
140003f99      inputControl.dwControlKeyState = *(uint32_t*)((char*)zmm0)[0xc];
140003f9e      uint32_t numberOfCharsRead = 0;
140003f9e      
140003fd2      while (true)
140003fd2      {
140003fd2          SetLastError(NO_ERROR);
140003fd2          
140003fea          if (!ReadConsoleW(arg1, lpBuffer, (uint32_t)rbx, &numberOfCharsRead, 
140003fea              &inputControl))
140003fea          {
140004064              GetLastError();
140004074              return 1;
140003fea          }
140003fea          
140003fec          uint32_t numberOfCharsRead_1 = numberOfCharsRead;
140003ff2          int64_t rcx_4;
140003ff2          int64_t rdx_2;
140003ff2          
140003ff2          if (numberOfCharsRead_1)
140003ff2          {
140004005          label_140004005:
140004005              uint64_t numberOfCharsRead_2 = (uint64_t)numberOfCharsRead_1;
140004005              
14000400e              if (numberOfCharsRead_2 - 1 < rbx)
14000400e              {
14000401d                  int32_t rax_4;
14000401d                  (uint8_t)rax_4 =
14000401d                      *(uint16_t*)((char*)lpBuffer + (numberOfCharsRead_2 << 1) - 2)
14000401d                      == 0x1a;
140004020                  uint64_t rdx_1 = (uint64_t)((uint32_t)numberOfCharsRead_2 - rax_4);
140004022                  rcx_4 = arg3;
140004027                  rdx_2 = rdx_1 + var_70;
140004027                  
14000402c                  if (rdx_1 == -(var_70))
14000402c                      break;
14000402c                  
140004032              label_140004032:
140004032                  
140004035                  if (rdx_2 - 1 < rcx_4)
140004035                  {
14000403c                      uint32_t rcx_6 = (uint32_t)arg2[rdx_2 - 1];
14000403c                      
140004052                      if ((rcx_6 & 0xfc00) == 0xd800)
14000405c                          *(uint16_t*)arg5 = (uint16_t)rcx_6;
14000405c                      
140004052                      break;
140004035                  }
14000400e              }
140003ff2          }
140003ff2          else
140003ff2          {
140003ffb              if (GetLastError() == ERROR_OPERATION_ABORTED)
140003ffb                  continue;
140003ffb              
140003ffd              numberOfCharsRead_1 = numberOfCharsRead;
140003ffd              
140004003              if (numberOfCharsRead_1)
140004003                  goto label_140004005;
140004003              
14000407d              rcx_4 = arg3;
140004082              rdx_2 = var_70;
140004082              
140004087              if (0 == -(var_70))
140004087                  break;
140004087              
140004087              goto label_140004032;
140003ff2          }
14000409e          trap(6);
140003fd2      }
140003fd2      
14000408b      return 0;
140003f10  }

1400040d4                                                              cc cc cc cc cc cc cc cc cc cc cc cc                      ............

1400040e0    int64_t sub_1400040e0() __pure

1400040e0  {
1400040e7      return _TLS_Entry_0;
1400040e0  }

1400040e8                          cc cc cc cc cc cc cc cc                                                          ........

1400040f0    void _TLS_Entry_0(int64_t arg1, int32_t arg2)

1400040f0  {
1400040fc      if (arg2 != 3 && arg2)
1400040f8          return;
1400040f8      
14000411d      TEB* gsbase;
14000411d      
14000411d      if (*(uint64_t*)(
14000411d          *(uint64_t*)(gsbase->ThreadLocalStoragePointer + ((uint64_t)data_14000a190 << 3))
14000411d          + 0x20))
14000411d      {
140004199      label_140004199:
140004199          sub_140006700();
140004199          /* no return */
14000411d      }
14000411d      
14000412f      while (true)
14000412f      {
14000412f          void* rax_4 = *(uint64_t*)(gsbase->ThreadLocalStoragePointer
14000412f              + ((uint64_t)data_14000a190 << 3));
140004133          *(uint64_t*)((char*)rax_4 + 0x20) = -1;
14000413e          int64_t rax_5 = *(uint64_t*)((char*)rax_4 + 0x38);
14000413e          
140004148          if (!rax_5)
140004148          {
1400041b1              int64_t rdx_2 = *(uint64_t*)(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
1400041b1                  + ((uint64_t)data_14000a190 << 3)) + 0x28);
1400041bb              int64_t rax_13;
1400041bb              
1400041bb              if (!rdx_2)
1400041f2                  rax_13 = 0;
1400041bb              else
1400041bb              {
1400041cc                  void* rsi_2 = *(uint64_t*)(gsbase->ThreadLocalStoragePointer
1400041cc                      + ((uint64_t)data_14000a190 << 3));
1400041e1                  j_sub_1400023f0(*(uint64_t*)((char*)rsi_2 + 0x30), rdx_2 << 4, 8);
1400041ed                  rax_13 = *(uint64_t*)((char*)rsi_2 + 0x20) + 1;
1400041bb              }
1400041bb              
140004203              void* rcx_9 = *(uint64_t*)(gsbase->ThreadLocalStoragePointer
140004203                  + ((uint64_t)data_14000a190 << 3));
140004207              *(uint64_t*)((char*)rcx_9 + 0x28) = 0;
140004212              *(uint64_t*)((char*)rcx_9 + 0x30) = 8;
14000421d              *(uint64_t*)((char*)rcx_9 + 0x38) = 0;
140004228              *(uint64_t*)((char*)rcx_9 + 0x20) = rax_13;
14000422f              void* rax = *(uint64_t*)((char*)rcx_9 + 0x18);
14000422f              
14000423a              if (rax >= 3)
14000423a              {
14000424f                  *(uint64_t*)(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
14000424f                      + ((uint64_t)data_14000a190 << 3)) + 0x18) = 2;
14000425e                  void* var_10 = (char*)rax - 0x10;
140004263                  int64_t temp0_1 = *(uint64_t*)((char*)rax - 0x10);
140004263                  *(uint64_t*)((char*)rax - 0x10) -= 1;
140004263                  
140004268                  if (temp0_1 == 1)
14000426f                      sub_140001ab0(&var_10);
14000423a              }
14000423a              
14000423a              break;
140004148          }
140004148          
14000415c          void* rsi_1 = *(uint64_t*)(gsbase->ThreadLocalStoragePointer
14000415c              + ((uint64_t)data_14000a190 << 3));
140004160          *(uint64_t*)((char*)rsi_1 + 0x38) = rax_5 - 1;
140004167          int64_t* rdx_1 = *(uint64_t*)((char*)rsi_1 + 0x30);
140004172          int64_t rcx_3 = rdx_1[(rax_5 - 1) * 2];
140004176          int64_t rax_8 = rdx_1[(rax_5 - 1) * 2 + 1];
14000417b          *(uint64_t*)((char*)rsi_1 + 0x20) = 0;
140004186          rax_8(rcx_3);
140004186          
140004190          if (*(uint64_t*)((char*)rsi_1 + 0x20))
140004190              goto label_140004199;
14000412f      }
1400040f0  }

14000427b                                                                                   cc cc cc cc cc                             .....

140004280    int64_t sub_140004280(int64_t arg1, int64_t arg2, int64_t* arg3)

140004280  {
140004295      int64_t var_50 = 0xe0000020;
14000429a      int64_t var_60 = arg1;
1400042a4      int16_t* r13 = arg3[4];
1400042ab      int64_t rbx_1;
1400042ab      
1400042ab      if (!r13)
1400042ab      {
1400043f5          int64_t rcx_8 = arg3[3];
1400043f5          
1400043fc          if (!rcx_8)
1400043fc          {
14000449c          label_14000449c:
14000449c              rbx_1 = 0;
14000449c              
1400044a2              if (0 < arg3[1])
1400044a2              {
1400044a4              label_1400044a4:
1400044a4                  int64_t* rax_12 = *(uint64_t*)arg3;
1400044a4                  
1400044c8                  if ((*(uint64_t*)(arg2 + 0x18))(var_60, rax_12[rbx_1 * 2], 
1400044c8                          rax_12[rbx_1 * 2 + 1], arg2))
1400044dc                      return 1;
1400044a2              }
1400043fc          }
1400043fc          else
1400043fc          {
140004402              int64_t* r12_2 = arg3[2];
140004410              void* rax_8 = &r12_2[2];
14000442b              rbx_1 = (0xfffffffffffffff & (rcx_8 - 1)) + 1;
14000442e              int64_t* r14_5 = *(uint64_t*)arg3 + 8;
140004432              int64_t r15_3 = 0;
140004432              
14000448b              do
14000448b              {
140004440                  int64_t* r13_1 = rax_8;
140004443                  int64_t r8_3 = *(uint64_t*)r14_5;
140004443                  
140004449                  if (r8_3 && (*(uint64_t*)(arg2 + 0x18))(var_60, r14_5[-1], r8_3))
140004498                      return 1;
140004498                  
14000446e                  if (r12_2[1](*(uint64_t*)r12_2, &var_60))
140004498                      return 1;
140004498                  
140004470                  r15_3 += 1;
140004478                  int32_t rax_10;
140004478                  (uint8_t)rax_10 = r13_1 != &r12_2[rcx_8 * 2];
14000447e                  rax_8 = (uint64_t)(rax_10 << 4) + r13_1;
140004481                  r14_5 = &r14_5[2];
140004485                  r12_2 = r13_1;
14000448b              } while (rbx_1 != r15_3);
14000448b              
140004494              if (rbx_1 < arg3[1])
140004494                  goto label_1400044a4;
1400043fc          }
1400042ab      }
1400042ab      else
1400042ab      {
1400042b1          int64_t rcx = arg3[5];
1400042b1          
1400042b8          if (!rcx)
1400042b8              goto label_14000449c;
1400042b8          
1400042c9          int16_t* rax_1 = &r13[0x18];
1400042d5          int64_t* r12_1 = arg3[2];
1400042e9          rbx_1 = (0xfffffffffffffff & (rcx - 1)) + 1;
1400042ec          int64_t* r15_2 = *(uint64_t*)arg3 + 8;
1400042f0          int64_t rbp_1 = 0;
1400042f0          
1400043db          do
1400043db          {
140004300              int16_t* rsi_1 = rax_1;
140004303              int64_t r8 = *(uint64_t*)r15_2;
140004309              char rax_3;
140004309              
140004309              if (r8)
140004319                  rax_3 = (*(uint64_t*)(arg2 + 0x18))(var_60, r15_2[-1], r8);
140004319              
14000431e              if (r8 && rax_3)
140004498                  return 1;
140004498              
140004324              uint32_t rax_4 = (uint32_t)r13[8];
14000432b              int16_t rax_7;
14000432b              int16_t rcx_6;
14000432b              uint32_t rcx_3;
14000432b              
14000432b              if (!rax_4)
14000432b              {
140004360                  rax_7 = r13[9];
140004365                  rcx_3 = (uint32_t)*(uint16_t*)r13;
140004365                  
14000436d                  if (rcx_3 != 2)
14000436d                  {
14000434a                  label_14000434a:
14000434a                      
14000434d                      if (rcx_3 != 1)
140004390                          rcx_6 = r13[1];
14000434d                      else
140004357                          rcx_6 = r12_1[*(uint64_t*)((char*)r13 + 8) * 2 + 1];
14000436d                  }
14000436d                  else
14000436f                      rcx_6 = 0;
14000432b              }
14000432b              else if (rax_4 != 1)
140004330              {
140004380                  rax_7 = 0;
140004382                  rcx_3 = (uint32_t)*(uint16_t*)r13;
140004382                  
14000438a                  if (rcx_3 != 2)
14000438a                      goto label_14000434a;
14000438a                  
14000436f                  rcx_6 = 0;
140004330              }
140004330              else
140004330              {
14000433a                  rax_7 = r12_1[*(uint64_t*)((char*)r13 + 0x18) * 2 + 1];
140004340                  rcx_3 = (uint32_t)*(uint16_t*)r13;
140004340                  
140004348                  if (rcx_3 != 2)
140004348                      goto label_14000434a;
140004348                  
14000436f                  rcx_6 = 0;
140004330              }
140004399              *(uint64_t*)((char*)r13 + 0x20);
1400043a1              (uint32_t)var_50 = *(uint32_t*)((char*)r13 + 0x28);
1400043a5              *(uint16_t*)((char*)var_50)[4] = rax_7;
1400043aa              *(uint16_t*)((char*)var_50)[6] = rcx_6;
1400043b6              rax_3 = r12_1[*(uint64_t*)((char*)r13 + 0x20) * 2 + 1](
1400043b6                  r12_1[*(uint64_t*)((char*)r13 + 0x20) * 2], &var_60);
1400043b6              
1400043bd              if (rax_3)
140004498                  return 1;
140004498              
1400043c3              rbp_1 += 1;
1400043c6              rax_1 = &rsi_1[0x18];
1400043c6              
1400043cd              if (rsi_1 == &r13[rcx * 0x18])
1400043cd                  rax_1 = rsi_1;
1400043cd              
1400043d1              r15_2 = &r15_2[2];
1400043d5              r13 = rsi_1;
1400043db          } while (rbx_1 != rbp_1);
1400043db          
1400043ea          if (rbx_1 < arg3[1])
1400043ea              goto label_1400044a4;
1400042ab      }
1400044ca      return 0;
140004280  }

14000435f                                                                                               90                                 .
140004373                                                           66 66 66 66 2e 0f 1f 84 00 00 00 00 00                     ffff.........
14000438e                                            66 90                                                                f.
1400044dd                                                                                         cc cc cc                               ...

1400044e0    uint32_t sub_1400044e0(int64_t* arg1, char* arg2, void* arg3, int32_t arg4[0x4] @ zmm0)

1400044e0  {
1400044f0      void* rbx = arg3;
1400044f6      int32_t rsi = arg1[2];
1400044f6      
1400044ff      if (rsi & 0x18000000)
1400044ff      {
14000450b          uint64_t r14_1;
14000450b          
14000450b          if (rsi & 0x10000000)
14000450b          {
140004534              uint64_t r14_2 = (uint64_t)*(uint16_t*)((char*)arg1 + 0x16);
14000453c              uint64_t rax_2;
14000453c              void* r9_1;
14000453c              
14000453c              if (!r14_2)
14000453c              {
1400045ad                  r9_1 = nullptr;
1400045b0              label_1400045b0:
1400045b0                  rax_2 = 0;
14000453c              }
14000453c              else
14000453c              {
140004541                  rax_2 = r14_2;
140004544                  r9_1 = nullptr;
140004547                  char* i = arg2;
140004547                  
14000456b                  while (i != (char*)rbx + arg2)
14000456b                  {
14000456d                      char r9_4 = *(uint8_t*)i;
140004574                      void* i_1;
140004574                      
140004574                      if (r9_4 >= 0)
140004550                          i_1 = &i[1];
140004574                      else if (r9_4 < 0xe0)
140004588                          i_1 = &i[2];
14000457a                      else if (r9_4 < 0xf0)
14000458e                          i_1 = &i[3];
140004580                      else
140004582                          i_1 = &i[4];
140004582                      
14000455a                      r9_1 += (char*)i_1 - i;
14000455d                      i = i_1;
140004560                      uint64_t temp0_1 = rax_2;
140004560                      rax_2 -= 1;
140004560                      
140004563                      if (temp0_1 == 1)
140004563                          goto label_1400045b0;
14000456b                  }
14000453c              }
14000453c              
1400045b7              r14_1 = r14_2 - rax_2;
1400045ba              rbx = r9_1;
14000450b          }
14000450b          else if (rbx >= 0x20)
1400045a5              r14_1 = sub_140004d10(arg2, rbx, arg4);
140004511          else if (!rbx)
14000451a          {
1400045c2              rbx = nullptr;
1400045c4              r14_1 = 0;
14000451a          }
14000451a          else
14000451a          {
140004524              uint64_t rax_1;
140004524              
140004524              if (rbx >= 4)
140004524              {
1400045ce                  rax_1 = (uint64_t)(uint32_t)rbx & 0x1c;
1400045de                  int32_t zmm1[0x4] = (uint128_t)*(uint16_t*)(arg2 + 2);
1400045e2                  uint16_t zmm2[0x8] = data_140007f70;
1400045ea                  arg4 = _mm_cmpgt_epi8((uint128_t)*(uint16_t*)arg2, zmm2);
1400045f7                  arg4 = _mm_shuffle_epi32(
1400045f7                      _mm_shufflelo_epi16(_mm_unpacklo_epi8(arg4, *(uint64_t*)&arg4[0]), 
1400045f7                          0xd4), 
1400045f7                      0xd4);
1400045fc                  int128_t zmm3 = data_140007f80;
140004604                  arg4 &= zmm3;
140004608                  zmm1 = _mm_cmpgt_epi8(zmm1, zmm2);
14000461a                  zmm1 = _mm_shuffle_epi32(
14000461a                      _mm_shufflelo_epi16(_mm_unpacklo_epi8(zmm1, *(uint64_t*)&zmm1[0]), 
14000461a                          0xd4), 
14000461a                      0xd4) & zmm3;
14000461a                  
140004622                  if (rax_1 != 4)
140004622                  {
140004636                      uint128_t zmm5 = (uint128_t)*(uint16_t*)(arg2 + 6);
14000463a                      int32_t zmm4[0x4] =
14000463a                          _mm_cmpgt_epi8((uint128_t)*(uint16_t*)(arg2 + 4), zmm2);
14000464c                      zmm4 = _mm_shuffle_epi32(
14000464c                          _mm_shufflelo_epi16(
14000464c                              _mm_unpacklo_epi8(zmm4, *(uint64_t*)&zmm4[0]), 0xd4), 
14000464c                          0xd4) & zmm3;
140004650                      zmm5 = _mm_cmpgt_epi8(zmm5, zmm2);
140004662                      zmm5 = _mm_shuffle_epi32(
140004662                          _mm_shufflelo_epi16(_mm_unpacklo_epi8(zmm5, (uint64_t)zmm5), 
140004662                              0xd4), 
140004662                          0xd4) & zmm3;
140004666                      arg4 = _mm_add_epi64(arg4, zmm4);
14000466a                      zmm1 = _mm_add_epi64(zmm1, zmm5);
14000466a                      
140004671                      if ((uint32_t)rax_1 != 8)
140004671                      {
140004685                          zmm5 = (uint128_t)*(uint16_t*)(arg2 + 0xa);
140004689                          zmm4 = _mm_cmpgt_epi8((uint128_t)*(uint16_t*)(arg2 + 8), zmm2);
14000469b                          zmm4 = _mm_shuffle_epi32(
14000469b                              _mm_shufflelo_epi16(
14000469b                                  _mm_unpacklo_epi8(zmm4, *(uint64_t*)&zmm4[0]), 0xd4), 
14000469b                              0xd4) & zmm3;
14000469f                          zmm5 = _mm_cmpgt_epi8(zmm5, zmm2);
1400046b1                          zmm5 = _mm_shuffle_epi32(
1400046b1                              _mm_shufflelo_epi16(_mm_unpacklo_epi8(zmm5, (uint64_t)zmm5), 
1400046b1                                  0xd4), 
1400046b1                              0xd4) & zmm3;
1400046b5                          arg4 = _mm_add_epi64(arg4, zmm4);
1400046b9                          zmm1 = _mm_add_epi64(zmm1, zmm5);
1400046b9                          
1400046c0                          if ((uint32_t)rax_1 != 0xc)
1400046c0                          {
1400046d4                              zmm5 = (uint128_t)*(uint16_t*)(arg2 + 0xe);
1400046d8                              zmm4 = _mm_cmpgt_epi8((uint128_t)*(uint16_t*)(arg2 + 0xc), 
1400046d8                                  zmm2);
1400046ea                              zmm4 = _mm_shuffle_epi32(
1400046ea                                  _mm_shufflelo_epi16(
1400046ea                                      _mm_unpacklo_epi8(zmm4, *(uint64_t*)&zmm4[0]), 
1400046ea                                      0xd4), 
1400046ea                                  0xd4) & zmm3;
1400046ee                              zmm5 = _mm_cmpgt_epi8(zmm5, zmm2);
140004700                              zmm5 = _mm_shuffle_epi32(
140004700                                  _mm_shufflelo_epi16(
140004700                                      _mm_unpacklo_epi8(zmm5, (uint64_t)zmm5), 0xd4), 
140004700                                  0xd4) & zmm3;
140004704                              arg4 = _mm_add_epi64(arg4, zmm4);
140004708                              zmm1 = _mm_add_epi64(zmm1, zmm5);
140004708                              
14000470f                              if ((uint32_t)rax_1 != 0x10)
14000470f                              {
140004723                                  zmm5 = (uint128_t)*(uint16_t*)(arg2 + 0x12);
140004727                                  zmm4 = _mm_cmpgt_epi8(
140004727                                      (uint128_t)*(uint16_t*)(arg2 + 0x10), zmm2);
140004739                                  zmm4 = _mm_shuffle_epi32(
140004739                                      _mm_shufflelo_epi16(
140004739                                          _mm_unpacklo_epi8(zmm4, *(uint64_t*)&zmm4[0]), 
140004739                                          0xd4), 
140004739                                      0xd4) & zmm3;
14000473d                                  zmm5 = _mm_cmpgt_epi8(zmm5, zmm2);
14000474f                                  zmm5 = _mm_shuffle_epi32(
14000474f                                      _mm_shufflelo_epi16(
14000474f                                          _mm_unpacklo_epi8(zmm5, (uint64_t)zmm5), 0xd4), 
14000474f                                      0xd4) & zmm3;
140004753                                  arg4 = _mm_add_epi64(arg4, zmm4);
140004757                                  zmm1 = _mm_add_epi64(zmm1, zmm5);
140004757                                  
14000475e                                  if ((uint32_t)rax_1 != 0x14)
14000475e                                  {
140004772                                      zmm5 = (uint128_t)*(uint16_t*)(arg2 + 0x16);
140004776                                      zmm4 = _mm_cmpgt_epi8(
140004776                                          (uint128_t)*(uint16_t*)(arg2 + 0x14), zmm2);
140004788                                      zmm4 = _mm_shuffle_epi32(
140004788                                          _mm_shufflelo_epi16(
140004788                                              _mm_unpacklo_epi8(zmm4, 
140004788                                                  *(uint64_t*)&zmm4[0]), 
140004788                                              0xd4), 
140004788                                          0xd4) & zmm3;
14000478c                                      zmm5 = _mm_cmpgt_epi8(zmm5, zmm2);
14000479e                                      zmm5 = _mm_shuffle_epi32(
14000479e                                          _mm_shufflelo_epi16(
14000479e                                              _mm_unpacklo_epi8(zmm5, (uint64_t)zmm5), 
14000479e                                              0xd4), 
14000479e                                          0xd4) & zmm3;
1400047a2                                      arg4 = _mm_add_epi64(arg4, zmm4);
1400047a6                                      zmm1 = _mm_add_epi64(zmm1, zmm5);
1400047a6                                      
1400047ad                                      if ((uint32_t)rax_1 != 0x18)
1400047ad                                      {
1400047bd                                          zmm5 = (uint128_t)*(uint16_t*)(arg2 + 0x1a);
1400047c1                                          zmm4 = _mm_cmpgt_epi8(
1400047c1                                              (uint128_t)*(uint16_t*)(arg2 + 0x18), zmm2);
1400047d3                                          zmm4 = _mm_shuffle_epi32(
1400047d3                                              _mm_shufflelo_epi16(
1400047d3                                                  _mm_unpacklo_epi8(zmm4, 
1400047d3                                                      *(uint64_t*)&zmm4[0]), 
1400047d3                                                  0xd4), 
1400047d3                                              0xd4) & zmm3;
1400047d7                                          zmm5 = _mm_cmpgt_epi8(zmm5, zmm2);
1400047e9                                          zmm2 = _mm_shuffle_epi32(
1400047e9                                              _mm_shufflelo_epi16(
1400047e9                                                  _mm_unpacklo_epi8(zmm5, (uint64_t)zmm5), 
1400047e9                                                  0xd4), 
1400047e9                                              0xd4) & zmm3;
1400047ed                                          arg4 = _mm_add_epi64(arg4, zmm4);
1400047f1                                          zmm1 = _mm_add_epi64(zmm1, zmm2);
1400047ad                                      }
14000475e                                  }
14000470f                              }
1400046c0                          }
140004671                      }
140004622                  }
140004622                  
1400047f5                  int32_t temp0_70[0x4] = _mm_add_epi64(arg4, zmm1);
140004802                  r14_1 = _mm_add_epi64(_mm_shuffle_epi32(temp0_70, 0xee), temp0_70)[0];
140004802                  goto label_140004807;
140004524              }
140004524              
14000452a              r14_1 = 0;
14000452d              rax_1 = 0;
14000452d              
14000480a              do
14000480a              {
140004813                  int64_t rdx_15;
140004813                  (uint8_t)rdx_15 = arg2[rax_1] >= 0xc0;
140004816                  r14_1 += rdx_15;
140004819                  rax_1 += 1;
140004807              label_140004807:
14000480a              } while (rbx != rax_1);
14000451a          }
14000451a          
14000481e          uint64_t r13_1 = (uint64_t)*(uint16_t*)((char*)arg1 + 0x14);
14000481e          
140004826          if (r14_1 < r13_1)
140004826          {
14000482b              uint32_t r8_2 = (uint32_t)r13_1 - (uint32_t)r14_1;
14000484e              uint32_t r12;
14000484e              
14000484e              switch ((uint64_t)(rsi >> 0x1d) & 3)
14000484e              {
140004850                  case 0:
140004850                  case 3:
140004850                  {
140004850                      r12 = 0;
140004850                      break;
140004850                  }
14000487c                  case 1:
14000487c                  {
14000487c                      r12 = r8_2;
14000487c                      break;
14000487c                  }
140004885                  case 2:
140004885                  {
140004885                      r12 = (uint32_t)(uint16_t)r8_2 >> 1;
140004885                      break;
140004885                  }
14000484e              }
14000484e              
140004888              int32_t rsi_1 = rsi & 0x1fffff;
14000488e              int64_t r15_1 = *(uint64_t*)arg1;
140004891              int64_t rbp = arg1[1];
140004895              uint32_t rdi_2 = r12 + 1;
1400048a3              uint32_t result;
1400048a3              
1400048a3              while (true)
1400048a3              {
1400048a3                  int16_t temp1_1 = (uint16_t)rdi_2;
1400048a3                  (uint16_t)rdi_2 -= 1;
1400048a3                  
1400048a6                  if (temp1_1 == 1)
1400048a6                  {
1400048c2                      (uint8_t)result = 1;
1400048c2                      
1400048c6                      if (!(*(uint64_t*)(rbp + 0x18))(r15_1, arg2, rbx))
1400048c6                      {
1400048c8                          uint32_t var_4c_1 = r8_2 - r12;
1400048d3                          (uint16_t)rdi_2 = 0xffff;
1400048d3                          
1400048f6                          do
1400048f6                          {
1400048e8                              if ((uint16_t)r12 + (uint16_t)r14_1 - (uint16_t)r13_1
1400048e8                                  + (uint16_t)rdi_2 == 0xffff)
1400048e8                              {
1400048fe                                  rdi_2 = var_4c_1;
1400048fe                                  break;
1400048e8                              }
1400048e8                              
1400048ef                              result = (*(uint64_t*)(rbp + 0x20))(r15_1, (uint64_t)rsi_1);
1400048f2                              rdi_2 += 1;
1400048f6                          } while (!(uint8_t)result);
1400048f6                          
140004905                          (uint8_t)result = (uint16_t)rdi_2 < (uint16_t)var_4c_1;
1400048c6                      }
1400048c6                      
1400048c6                      break;
1400048a6                  }
1400048a6                  
1400048af                  if ((*(uint64_t*)(rbp + 0x20))(r15_1, (uint64_t)rsi_1))
1400048af                  {
1400048b1                      (uint8_t)result = 1;
1400048b3                      break;
1400048af                  }
1400048a3              }
1400048a3              
140004918              return result;
140004826          }
1400044ff      }
1400044ff      
140004855      *(uint64_t*)arg1;
140004879      /* jump -> *(uint64_t*)(arg1[1] + 0x18) */
1400044e0  }

14000454c                                      0f 1f 40 00                                                              ..@.
140004919                                                                             cc cc cc cc cc cc cc                           .......

140004920    int64_t sub_140004920(char* arg1, void* arg2, int64_t* arg3, int512_t arg4 @ zmm0)

140004920  {
14000492c      /* tailcall */
14000492c      return sub_1400044e0(arg3, arg1, arg2, arg4);
140004920  }

140004931                                                     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                   ...............

140004940    int64_t sub_140004940(char arg1, int64_t* arg2, void* arg3)

140004940  {
14000494c      void* rdx_1 = ((char*)arg2 + 7) & 0xfffffffffffffff8;
140004950      void* i = (char*)rdx_1 - arg2;
140004953      void* rax;
140004953      
140004953      if (rdx_1 == arg2)
140004953      {
140004955          rax = (char*)arg3 - 0x10;
140004959          i = nullptr;
1400049a6      label_1400049a6:
1400049a6          int64_t rsi_1 = 0x101010101010101 * (uint64_t)arg1;
1400049a6          
1400049e3          do
1400049e3          {
1400049b4              int64_t rdi_3 = *(uint64_t*)((char*)arg2 + i) ^ rsi_1;
1400049c5              int64_t rdi_5 = *(uint64_t*)((char*)arg2 + i + 8) ^ rsi_1;
1400049c5              
1400049da              if ((((0x101010101010100 - rdi_3) | rdi_3) & 0x8080808080808080
1400049da                      & ((0x101010101010100 - rdi_5) | rdi_5)) != -0x7f7f7f7f7f7f7f80)
1400049da                  break;
1400049da              
1400049dc              i += 0x10;
1400049e3          } while (i <= rax);
1400049e3          
1400049da          goto label_1400049e5;
140004953      }
140004953      
140004960      if (arg3 < i)
140004960          i = arg3;
140004960      
140004967      int64_t result;
140004967      
140004967      if (!arg3)
140004967      {
140004982      label_140004982:
140004982          rax = (char*)arg3 - 0x10;
140004982          
140004989          if (i <= rax)
140004989              goto label_1400049a6;
140004989          
1400049e5      label_1400049e5:
1400049e5          result = 0;
1400049e5          
1400049ea          for (; arg3 != i; i += 1)
1400049ea          {
1400049f4              if (*(uint8_t*)((char*)arg2 + i) == arg1)
140004a00                  return 1;
1400049ea          }
140004967      }
140004967      else
140004967      {
140004969          int64_t r10_1 = 0;
140004969          
140004974          while (*(uint8_t*)((char*)arg2 + r10_1) != arg1)
140004974          {
14000497a              r10_1 += 1;
14000497a              
140004980              if (i == r10_1)
140004980                  goto label_140004982;
140004974          }
140004974          
140004a07          result = 1;
140004967      }
140004967      
140004a14      return result;
140004940  }

140004a15                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........

140004a20    int64_t sub_140004a20(char arg1, int64_t arg2, int64_t arg3)

140004a20  {
140004a2f      int64_t rax_2 = ((arg2 + 7) & 0xfffffffffffffff8) - arg2;
140004a35      int64_t r9;
140004a35      uint64_t r10;
140004a35      
140004a35      if (arg3 >= rax_2)
140004a35      {
140004a48          r10 = (uint64_t)((uint32_t)arg3 - (uint32_t)rax_2) & 0xf;
140004a4f          r9 = arg3 - r10;
140004a4f          
140004a52          if (arg3 >= r10)
140004a52              goto label_140004a58;
140004a35      }
140004a35      else
140004a35      {
140004a37          r10 = 0;
140004a3a          r9 = arg3;
140004a3d          rax_2 = arg3;
140004a58      label_140004a58:
140004a58          int64_t r10_3 = -(r10);
140004a5b          int64_t r11_1 = arg3;
140004a5b          
140004a63          while (true)
140004a63          {
140004a63              if (r9 == r11_1)
140004a63              {
140004a97                  int64_t rdi_1 = 0x101010101010101 * (uint64_t)arg1;
140004ad7                  int64_t r10_5;
140004ad7                  int64_t rbx_2;
140004ad7                  int64_t rbx_4;
140004ad7                  
140004ad7                  do
140004ad7                  {
140004aa0                      r10_5 = r9;
140004aa0                      
140004aa6                      if (r9 <= rax_2)
140004aa6                          break;
140004aa6                      
140004aa8                      r9 = r10_5 - 0x10;
140004ab1                      rbx_2 = *(uint64_t*)(arg2 + r10_5 - 0x10) ^ rdi_1;
140004ac2                      rbx_4 = *(uint64_t*)(arg2 + r10_5 - 8) ^ rdi_1;
140004ad7                  } while ((((0x101010101010100 - rbx_2) | rbx_2) & 0x8080808080808080
140004ad7                      & ((0x101010101010100 - rbx_4) | rbx_4)) == -0x7f7f7f7f7f7f7f80);
140004ad7                  
140004adc                  if (r10_5 > arg3)
140004adc                      break;
140004adc                  
140004af1                  bool cond:1_1;
140004af1                  
140004af1                  do
140004af1                  {
140004ae3                      if (!r10_5)
140004b04                          return 0;
140004b04                      
140004ae9                      cond:1_1 = *(uint8_t*)(arg2 + r10_5 - 1) != arg1;
140004aee                      r10_5 -= 1;
140004af1                  } while (cond:1_1);
140004a63              }
140004a63              else
140004a63              {
140004a69                  r10_3 += 1;
140004a6c                  bool cond:0_1 = *(uint8_t*)(arg2 + r11_1 - 1) != arg1;
140004a71                  r11_1 -= 1;
140004a71                  
140004a74                  if (cond:0_1)
140004a74                      continue;
140004a63              }
140004a63              
140004af3              return 1;
140004a63          }
140004a35      }
140004b05      trap(6);
140004a20  }

140004b07                       cc cc cc cc cc cc cc cc cc                                                         .........

140004b10    int64_t* sub_140004b10(int64_t* arg1, char* arg2, int64_t arg3)

140004b10  {
140004b19      int64_t r9 = 0;
140004b19      
140004b23      if (arg3 >= 0xf)
140004b23          r9 = arg3 - 0xf;
140004b23      
140004b2a      int64_t rcx_2;
140004b2a      
140004b2a      if (!arg3)
140004b2a      {
140004cd3      label_140004cd3:
140004cd3          arg1[1] = arg2;
140004cd7          arg1[2] = arg3;
140004cdb          rcx_2 = 0;
140004b2a      }
140004b2a      else
140004b2a      {
140004b3b          int64_t i = 0;
140004b3b          
140004b5f          while (true)
140004b5f          {
140004b5f              uint64_t rbx_1 = (uint64_t)arg2[i];
140004b5f              
140004b65              if ((uint8_t)rbx_1 < 0)
140004b65              {
140004bc0                  uint32_t rbp_1 = (uint32_t)*(uint8_t*)(rbx_1 + &data_1400080a0);
140004bc4                  uint64_t r11;
140004bc4                  (uint8_t)r11 = 1;
140004bca                  int64_t r14_2;
140004bca                  
140004bca                  if (rbp_1 == 4)
140004bca                  {
140004c2e                      if (i + 1 >= arg3)
140004c2e                      {
140004cdf                      label_140004cdf:
140004cdf                          r11 = 0;
140004cea                      label_140004cea:
140004cea                          arg1[1] = i;
140004cee                          arg1[2] = (uint8_t)r11;
140004cf2                          *(uint8_t*)((char*)arg1 + 0x11) = (uint8_t)rbx_1;
140004cf5                          rcx_2 = 1;
140004cf5                          break;
140004c2e                      }
140004c2e                      
140004c34                      char rbp_3 = arg2[i + 1];
140004c34                      
140004c40                      if (rbx_1 == 0xf0)
140004c40                      {
140004c6c                          if (rbp_3 + 0x70 >= 0x30)
140004c6c                          {
140004ce4                              (uint8_t)rbx_1 = 1;
140004ce6                              goto label_140004cea;
140004c6c                          }
140004c40                      }
140004c40                      else if ((uint32_t)rbx_1 != 0xf4)
140004c48                      {
140004c9e                          (uint8_t)rbx_1 += 0xf;
140004c9e                          
140004caa                          if ((uint8_t)rbx_1 > 2 || rbp_3 >= 0xc0)
140004caa                          {
140004ce4                              (uint8_t)rbx_1 = 1;
140004ce6                              goto label_140004cea;
140004caa                          }
140004c48                      }
140004c48                      else if (rbp_3 > 0x8f)
140004c4e                      {
140004ce4                          (uint8_t)rbx_1 = 1;
140004ce6                          goto label_140004cea;
140004c4e                      }
140004c4e                      
140004cac                      rbx_1 = i + 2;
140004cac                      
140004cb3                      if (rbx_1 >= arg3)
140004cb3                          goto label_140004cdf;
140004cb3                      
140004cb9                      if (arg2[rbx_1] > 0xbf)
140004cb9                      {
140004ce8                          (uint8_t)rbx_1 = 2;
140004ce8                          goto label_140004cea;
140004cb9                      }
140004cb9                      
140004cbb                      r14_2 = i + 3;
140004cbb                      
140004cc2                      if (r14_2 >= arg3)
140004cc2                          goto label_140004cdf;
140004cc2                      
140004cc9                      if (arg2[r14_2] >= 0xc0)
140004cc9                      {
140004ccf                          (uint8_t)rbx_1 = 3;
140004cd1                          goto label_140004cea;
140004cc9                      }
140004bca                  }
140004bca                  else if (rbp_1 == 3)
140004bcf                  {
140004c00                      if (i + 1 >= arg3)
140004c00                          goto label_140004cdf;
140004c00                      
140004c06                      char rbp_2 = arg2[i + 1];
140004c06                      
140004c12                      if (rbx_1 == 0xe0)
140004c12                      {
140004c5d                          if ((rbp_2 & 0xe0) != 0xa0)
140004c5d                          {
140004ce4                              (uint8_t)rbx_1 = 1;
140004ce6                              goto label_140004cea;
140004c5d                          }
140004c12                      }
140004c12                      else if ((uint32_t)rbx_1 != 0xed)
140004c1a                      {
140004c78                          if ((uint8_t)(rbx_1 + 0x1f) >= 0xc)
140004c78                          {
140004c7a                              (uint8_t)rbx_1 &= 0xfe;
140004c7a                              
140004c86                              if ((uint8_t)rbx_1 != 0xee || rbp_2 >= 0xc0)
140004c86                              {
140004ce4                                  (uint8_t)rbx_1 = 1;
140004ce6                                  goto label_140004cea;
140004c86                              }
140004c78                          }
140004c78                          else if (rbp_2 >= 0xc0)
140004c86                          {
140004ce4                              (uint8_t)rbx_1 = 1;
140004ce6                              goto label_140004cea;
140004c86                          }
140004c1a                      }
140004c1a                      else if (rbp_2 > 0x9f)
140004c20                      {
140004ce4                          (uint8_t)rbx_1 = 1;
140004ce6                          goto label_140004cea;
140004c20                      }
140004c20                      
140004c88                      r14_2 = i + 2;
140004c88                      
140004c8f                      if (r14_2 >= arg3)
140004c8f                          goto label_140004cdf;
140004c8f                      
140004c96                      if (arg2[r14_2] > 0xbf)
140004c96                      {
140004ce8                          (uint8_t)rbx_1 = 2;
140004ce8                          goto label_140004cea;
140004c96                      }
140004bcf                  }
140004bcf                  else
140004bcf                  {
140004bd4                      if (rbp_1 != 2)
140004bd4                      {
140004ce4                          (uint8_t)rbx_1 = 1;
140004ce6                          goto label_140004cea;
140004bd4                      }
140004bd4                      
140004bda                      r14_2 = i + 1;
140004bda                      
140004be1                      if (r14_2 >= arg3)
140004be1                          goto label_140004cdf;
140004be1                      
140004bec                      (uint8_t)rbx_1 = 1;
140004bec                      
140004bee                      if (arg2[r14_2] > 0xbf)
140004bee                          goto label_140004cea;
140004bcf                  }
140004bcf                  
140004b53                  i = r14_2 + 1;
140004b65              }
140004b65              else if (!(((((uint32_t)arg2 + 7) & 0xfffffff8) - (uint32_t)arg2
140004b65                  - (uint32_t)i) & 7))
140004b71              {
140004b87                  for (; i < r9; i += 0x10)
140004b87                  {
140004b95                      if ((*(uint64_t*)(arg2 + i + 8) | *(uint64_t*)(arg2 + i))
140004b95                              & 0x8080808080808080)
140004b95                          break;
140004b87                  }
140004b87                  
140004b9a                  if (i < arg3)
140004b9a                  {
140004ba4                      while (arg2[i] >= 0)
140004ba4                      {
140004ba6                          i += 1;
140004ba6                          
140004bac                          if (arg3 == i)
140004bac                              goto label_140004cd3;
140004ba4                      }
140004b9a                  }
140004b71              }
140004b71              else
140004b73                  i += 1;
140004b73              
140004b59              if (i >= arg3)
140004b59                  goto label_140004cd3;
140004b5f          }
140004b2a      }
140004b2a      
140004cfa      *(uint64_t*)arg1 = rcx_2;
140004d03      return arg1;
140004b10  }

140004b78                                                                          0f 1f 84 00 00 00 00 00                          ........
140004bb3                                                           66 66 66 66 2e 0f 1f 84 00 00 00 00 00                     ffff.........
140004d04              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

140004d10    int64_t sub_140004d10(char* arg1, int64_t arg2, int32_t arg3[0x4] @ zmm0)

140004d10  {
140004d1f      int32_t zmm11[0x4];
140004d1f      int32_t var_48[0x4] = zmm11;
140004d26      int32_t zmm10[0x4];
140004d26      int32_t var_58[0x4] = zmm10;
140004d2d      int32_t zmm9[0x4];
140004d2d      int32_t var_68[0x4] = zmm9;
140004d34      int32_t zmm8[0x4];
140004d34      int32_t var_78[0x4] = zmm8;
140004d3b      int32_t zmm7[0x4];
140004d3b      int32_t var_88[0x4] = zmm7;
140004d41      int32_t zmm6[0x4];
140004d41      int32_t var_98[0x4] = zmm6;
140004d4a      void* r10_1 = &arg1[7] & 0xfffffffffffffff8;
140004d51      void* r9_1 = (char*)r10_1 - arg1;
140004d57      void* r8_1 = arg2 - r9_1;
140004d75      int32_t zmm1[0x4];
140004d75      int32_t zmm2[0x4];
140004d75      int32_t zmm3[0x4];
140004d75      int32_t zmm4[0x4];
140004d75      uint128_t zmm5;
140004d75      
140004d75      if (arg2 < r9_1 || r8_1 < 8)
140004d75      {
140004d5f          if (!arg2)
140004d9d              return 0;
140004d9d          
140004d65          int64_t rax;
140004d65          int64_t r8_2;
140004d65          
140004d65          if (arg2 >= 4)
140004d65          {
140004da7              r8_2 = arg2 & 0xfffffffffffffffc;
140004dab              arg3 = {0};
140004daf              int64_t rax_3 = 0;
140004db1              zmm2 = data_140007f70;
140004db9              zmm3 = data_140007f80;
140004dc1              zmm1 = {0};
140004dc1              
140004e20              do
140004e20              {
140004de0                  zmm5 = (uint128_t)*(uint16_t*)(arg1 + rax_3 + 2);
140004de5                  zmm4 = _mm_cmpgt_epi8((uint128_t)*(uint16_t*)(arg1 + rax_3), zmm2);
140004dfb                  arg3 = _mm_add_epi64(arg3, 
140004dfb                      _mm_shuffle_epi32(
140004dfb                          _mm_shufflelo_epi16(
140004dfb                              _mm_unpacklo_epi8(zmm4, *(uint64_t*)&zmm4[0]), 0xd4), 
140004dfb                          0xd4) & zmm3);
140004dff                  zmm5 = _mm_cmpgt_epi8(zmm5, zmm2);
140004e15                  zmm1 = _mm_add_epi64(zmm1, 
140004e15                      _mm_shuffle_epi32(
140004e15                          _mm_shufflelo_epi16(_mm_unpacklo_epi8(zmm5, (uint64_t)zmm5), 
140004e15                              0xd4), 
140004e15                          0xd4) & zmm3);
140004e19                  rax_3 += 4;
140004e20              } while (r8_2 != rax_3);
140004e20              
140004e22              zmm1 = _mm_add_epi64(zmm1, arg3);
140004e2f              rax = _mm_add_epi64(_mm_shuffle_epi32(zmm1, 0xee), zmm1)[0];
140004e34              goto label_1400052f3;
140004d65          }
140004d65          
140004d67          rax = 0;
140004d69          r8_2 = 0;
140004d69          
1400052f6          do
1400052f6          {
140005300              int64_t r9_6;
140005300              (uint8_t)r9_6 = arg1[r8_2] >= 0xc0;
140005304              rax += r9_6;
140005307              r8_2 += 1;
1400052f3          label_1400052f3:
1400052f6          } while (arg2 != r8_2);
1400052f6          
14000533c          return rax;
140004d75      }
140004d75      
140004d7a      uint64_t rax_2 = (uint64_t)(uint32_t)r8_1 & 7;
140004d80      int64_t rdx;
140004d80      
140004d80      if (r10_1 != arg1)
140004d80      {
140004d8d          uint64_t r10_2;
140004d8d          
140004d8d          if (r9_1 >= 4)
140004d8d          {
140004e3c              r10_2 = (uint64_t)(uint32_t)r9_1 & 4;
140004e40              arg3 = {0};
140004e44              int64_t rdx_1 = 0;
140004e46              zmm2 = data_140007f70;
140004e4e              zmm3 = data_140007f80;
140004e56              zmm1 = {0};
140004e56              
140004eb0              do
140004eb0              {
140004e70                  zmm5 = (uint128_t)*(uint16_t*)(arg1 + rdx_1 + 2);
140004e75                  zmm4 = _mm_cmpgt_epi8((uint128_t)*(uint16_t*)(arg1 + rdx_1), zmm2);
140004e8b                  arg3 = _mm_add_epi64(arg3, 
140004e8b                      _mm_shuffle_epi32(
140004e8b                          _mm_shufflelo_epi16(
140004e8b                              _mm_unpacklo_epi8(zmm4, *(uint64_t*)&zmm4[0]), 0xd4), 
140004e8b                          0xd4) & zmm3);
140004e8f                  zmm5 = _mm_cmpgt_epi8(zmm5, zmm2);
140004ea5                  zmm1 = _mm_add_epi64(zmm1, 
140004ea5                      _mm_shuffle_epi32(
140004ea5                          _mm_shufflelo_epi16(_mm_unpacklo_epi8(zmm5, (uint64_t)zmm5), 
140004ea5                              0xd4), 
140004ea5                          0xd4) & zmm3);
140004ea9                  rdx_1 += 4;
140004eb0              } while (r10_2 != rdx_1);
140004eb0              
140004eb2              zmm1 = _mm_add_epi64(zmm1, arg3);
140004ebb              arg3 = _mm_add_epi64(_mm_shuffle_epi32(zmm1, 0xee), zmm1);
140004ebf              rdx = *(uint64_t*)&arg3[0];
140004ec4              goto label_140004ed8;
140004d8d          }
140004d8d          
140004d93          rdx = 0;
140004d95          r10_2 = 0;
140004d95          
140004edb          do
140004edb          {
140004ece              int64_t r11_3;
140004ece              (uint8_t)r11_3 = arg1[r10_2] >= 0xc0;
140004ed2              rdx += r11_3;
140004ed5              r10_2 += 1;
140004ed8          label_140004ed8:
140004edb          } while (r9_1 != r10_2);
140004d80      }
140004d80      else
140004d82          rdx = 0;
140004d82      
140004edd      void* j_7 = arg1 + r9_1;
140004ee3      int64_t rdi_1;
140004ee3      
140004ee3      if (!rax_2)
140004f79          rdi_1 = 0;
140004ee3      else
140004ee3      {
140004eec          void* r9_5 = r8_1 & 0xfffffffffffffff8;
140004ef7          (uint8_t)rdi_1 = *(uint8_t*)((char*)j_7 + r9_5) >= 0xc0;
140004ef7          
140004efe          if ((uint32_t)rax_2 != 1)
140004efe          {
140004f09              int64_t r10_4;
140004f09              (uint8_t)r10_4 = *(uint8_t*)((char*)j_7 + r9_5 + 1) >= 0xc0;
140004f0d              rdi_1 += r10_4;
140004f0d              
140004f13              if ((uint32_t)rax_2 != 2)
140004f13              {
140004f1e                  int64_t r10_5;
140004f1e                  (uint8_t)r10_5 = *(uint8_t*)((char*)j_7 + r9_5 + 2) >= 0xc0;
140004f22                  rdi_1 += r10_5;
140004f22                  
140004f28                  if ((uint32_t)rax_2 != 3)
140004f28                  {
140004f33                      int64_t r10_6;
140004f33                      (uint8_t)r10_6 = *(uint8_t*)((char*)j_7 + r9_5 + 3) >= 0xc0;
140004f37                      rdi_1 += r10_6;
140004f37                      
140004f3d                      if ((uint32_t)rax_2 != 4)
140004f3d                      {
140004f48                          int64_t r10_7;
140004f48                          (uint8_t)r10_7 = *(uint8_t*)((char*)j_7 + r9_5 + 4) >= 0xc0;
140004f4c                          rdi_1 += r10_7;
140004f4c                          
140004f52                          if ((uint32_t)rax_2 != 5)
140004f52                          {
140004f5d                              int64_t r10_8;
140004f5d                              (uint8_t)r10_8 = *(uint8_t*)((char*)j_7 + r9_5 + 5) >= 0xc0;
140004f61                              rdi_1 += r10_8;
140004f61                              
140004f67                              if ((uint32_t)rax_2 != 6)
140004f67                              {
140004f71                                  int64_t rax_4;
140004f71                                  (uint8_t)rax_4 =
140004f71                                      *(uint8_t*)((char*)j_7 + r9_5 + 6) >= 0xc0;
140004f74                                  rdi_1 += rax_4;
140004f67                              }
140004f52                          }
140004f3d                      }
140004f28                  }
140004f13              }
140004efe          }
140004ee3      }
140004ee3      
140004f7b      int64_t rdi_8 = rdi_1 + rdx;
140004f7e      uint64_t i = r8_1 >> 3;
140004fa0      arg3 = _mm_cmpeq_epi32(arg3, arg3);
140004fa4      zmm1 = data_1400081b0;
140004fa4      
140004fe6      while (i)
140004fe6      {
140004ff2          void* j_5 = j_7;
140004ffc          uint64_t i_1 = 0xc0;
140004ffc          
140005002          if (i < 0xc0)
140005002              i_1 = i;
140005002          
14000500a          int64_t rdi_2;
14000500a          
14000500a          if (i < 4)
140004fb0              rdi_2 = 0;
14000500a          else
14000500a          {
14000500f              uint64_t rcx_2 = (uint64_t)((uint32_t)i_1 >> 2);
140005012              void* j_2 = (char*)j_5 + 0x20;
14000501a              int64_t r15_2 = (rcx_2 + 0x7ffffffffffffff) & 0x7ffffffffffffff;
140005021              void* j_4;
140005021              
140005021              if (r15_2 >= 3)
140005021              {
140005036                  int64_t j_6 = (r15_2 + 1) & 0xfffffffffffffffc;
14000503d                  int64_t r14_4 = j_6 << 5;
140005041                  j_2 += r14_4;
140005044                  j_4 = r14_4 + j_5;
140005047                  void* rdi_9 = (char*)j_5 + 0x40;
14000504b                  zmm4 = {0};
14000504f                  int64_t j_3 = j_6;
140005052                  zmm6 = {0};
1400051d1                  int64_t j;
1400051d1                  
1400051d1                  do
1400051d1                  {
140005060                      zmm2 = *(uint128_t*)((char*)rdi_9 - 0x40);
140005065                      zmm5 = *(uint128_t*)((char*)rdi_9 - 0x20);
14000506e                      zmm3 = _mm_unpacklo_epi64(zmm2, (uint64_t)zmm5);
14000507a                      zmm7 = _mm_srli_epi64(zmm3 ^ arg3, 7);
14000508c                      zmm3 = _mm_add_epi64((_mm_srli_epi64(zmm3, 6) | zmm7) & zmm1, zmm4);
140005090                      zmm4 = *(uint128_t*)((char*)rdi_9 - 0x30);
140005095                      zmm7 = *(uint128_t*)((char*)rdi_9 - 0x10);
14000509a                      zmm2 = _mm_unpackhi_epi64(zmm2, (uint64_t)zmm5);
1400050a2                      zmm5 = _mm_unpacklo_epi64(zmm4, *(uint64_t*)&zmm7[0]);
1400050a6                      zmm4 = _mm_unpackhi_epi64(zmm4, *(uint64_t*)&zmm7[0]);
1400050aa                      zmm10 = *(uint128_t*)((char*)rdi_9 + 0x30);
1400050b0                      zmm7 = *(uint128_t*)((char*)rdi_9 + 0x20);
1400050b5                      zmm9 = *(uint128_t*)rdi_9;
1400050bf                      zmm8 = _mm_unpacklo_epi64(zmm9, *(uint64_t*)&zmm7[0]);
1400050ce                      zmm11 = _mm_srli_epi64(zmm8 ^ arg3, 7);
1400050e4                      zmm8 = _mm_add_epi64((_mm_srli_epi64(zmm8, 6) | zmm11) & zmm1, zmm6);
1400050e9                      zmm6 = *(uint128_t*)((char*)rdi_9 + 0x10);
1400050ee                      zmm9 = _mm_unpackhi_epi64(zmm9, *(uint64_t*)&zmm7[0]);
1400050f7                      zmm7 = _mm_unpacklo_epi64(zmm6, *(uint64_t*)&zmm10[0]);
1400050fc                      zmm6 = _mm_unpackhi_epi64(zmm6, *(uint64_t*)&zmm10[0]);
140005115                      zmm10 = _mm_srli_epi64(zmm2 ^ arg3, 7);
14000511b                      zmm11 = _mm_srli_epi64(zmm9 ^ arg3, 7);
140005126                      zmm2 = _mm_srli_epi64(zmm2, 6) | zmm10;
14000513a                      zmm9 = (_mm_srli_epi64(zmm9, 6) | zmm11) & zmm1;
140005153                      zmm10 = _mm_srli_epi64(zmm5 ^ arg3, 7);
140005159                      zmm11 = _mm_srli_epi64(zmm7 ^ arg3, 7);
140005164                      zmm5 = _mm_srli_epi64(zmm5, 6) | zmm10;
14000516e                      zmm7 = _mm_srli_epi64(zmm7, 6) | zmm11;
14000517b                      zmm5 = _mm_add_epi64(_mm_add_epi64(zmm5 & zmm1, zmm2 & zmm1), zmm3);
140005188                      zmm7 = _mm_add_epi64(_mm_add_epi64(zmm7 & zmm1, zmm9), zmm8);
14000519d                      zmm2 = _mm_srli_epi64(zmm4 ^ arg3, 7);
1400051a2                      zmm3 = _mm_srli_epi64(zmm6 ^ arg3, 7);
1400051ac                      zmm4 = _mm_srli_epi64(zmm4, 6) | zmm2;
1400051b5                      zmm6 = _mm_srli_epi64(zmm6, 6) | zmm3;
1400051bd                      zmm4 = _mm_add_epi64(zmm4 & zmm1, zmm5);
1400051c5                      zmm6 = _mm_add_epi64(zmm6 & zmm1, zmm7);
1400051c9                      rdi_9 -= -0x80;
1400051cd                      j = j_3;
1400051cd                      j_3 -= 4;
1400051d1                  } while (j != 4);
1400051d7                  zmm6 = _mm_add_epi64(zmm6, zmm4);
1400051e4                  rdi_2 = _mm_add_epi64(_mm_shuffle_epi32(zmm6, 0xee), zmm6)[0];
1400051e4                  
1400051ec                  if (r15_2 + 1 != j_6)
1400051ec                      goto label_140005261;
140005021              }
140005021              else
140005021              {
140005023                  j_4 = j_5;
140005026                  rdi_2 = 0;
140005261              label_140005261:
140005261                  void* j_1;
140005261                  
140005261                  do
140005261                  {
140005200                      j_1 = j_2;
140005203                      zmm2 = *(uint128_t*)j_4;
140005208                      zmm3 = *(uint128_t*)((char*)j_4 + 0x10);
14000521e                      zmm5 = _mm_srli_epi64(zmm3 ^ arg3, 7);
140005223                      zmm4 = _mm_srli_epi64(zmm2 ^ arg3, 7);
14000522d                      zmm3 = _mm_srli_epi64(zmm3, 6) | zmm5;
140005242                      zmm2 = _mm_add_epi64((_mm_srli_epi64(zmm2, 6) | zmm4) & zmm1, 
140005242                          zmm3 & zmm1);
140005254                      rdi_2 += _mm_add_epi64(_mm_shuffle_epi32(zmm2, 0xee), zmm2)[0];
140005257                      j_4 = j_1;
14000525a                      j_2 = (char*)j_1 + 0x20;
140005261                  } while (j_1 != (uint64_t)((uint32_t)rcx_2 << 5) + j_5);
140005021              }
14000500a          }
14000500a          
140004fb5          j_7 = (char*)j_5 + ((uint64_t)(uint32_t)i_1 << 3);
140004fb9          i -= i_1;
140004fbf          uint64_t rbx_2 = (uint64_t)(uint32_t)i_1 & 3;
140004fda          rdi_8 += (((rdi_2 >> 8 & 0xff00ff00ff00ff) + (rdi_2 & 0xff00ff00ff00ff))
140004fda              * 0x1000100010001) >> 0x30;
140004fda          
140004fe0          if (rbx_2)
140004fe0          {
140005272              uint64_t r11_4 = (uint64_t)(uint32_t)i_1 & 0xfc;
14000527c              int64_t rax_6 = *(uint64_t*)((char*)j_5 + ((uint64_t)(uint32_t)r11_4 << 3));
140005291              int64_t rax_9 = (rax_6 >> 6 | ~rax_6 >> 7) & 0x101010101010101;
140005291              
140005297              if ((uint32_t)rbx_2 != 1)
140005297              {
140005299                  int64_t r8_7 = *(uint64_t*)((char*)j_5 + (r11_4 << 3) + 8);
1400052b2                  rax_9 += (r8_7 >> 6 | ~r8_7 >> 7) & 0x101010101010101;
1400052b2                  
1400052b8                  if ((uint32_t)rbx_2 != 2)
1400052b8                  {
1400052ba                      int64_t r8_11 = *(uint64_t*)((char*)j_5 + (r11_4 << 3) + 0x10);
1400052d3                      rax_9 += (r8_11 >> 6 | ~r8_11 >> 7) & 0x101010101010101;
1400052b8                  }
140005297              }
140005297              
1400052ee              return ((((rax_9 >> 8 & 0xff00ff00ff00ff) + (rax_9 & 0xff00ff00ff00ff))
1400052ee                  * 0x1000100010001) >> 0x30) + rdi_8;
140004fe0          }
140004fe6      }
140004fe6      
14000533c      return rdi_8;
140004d10  }

140004fae                                            66 90                                                                f.
14000502d                                         0f 1f 00                                                               ...
14000533d                                                                                         cc cc cc                               ...

140005340    int64_t pre_c_initialization()

140005340  {
14000534b      _set_app_type(_crt_console_app);
140005357      _set_fmode(0x4000);
14000536d      *(uint32_t*)__p__commode() = 0;
14000536d      
140005376      if (__scrt_initialize_onexit_tables(1))
140005376      {
140005378          _RTC_Initialize();
140005384          atexit(_RTC_Terminate);
140005384          
140005397          if (!_configure_narrow_argv(_crt_argv_unexpanded_arguments))
140005397          {
140005399              sub_140005920();
140005399              
1400053a5              if (sub_140005964())
1400053ae                  __setusermatherr(sub_14000590c);
1400053ae              
1400053c4              _configthreadlocale(0);
1400053c4              
1400053d0              if (sub_140005930())
1400053d2                  _initialize_narrow_environment();
1400053d2              
1400053dc              j_sub_14000590c();
1400053ea              return 0;
140005397          }
140005376      }
140005376      
1400053f0      __scrt_fastfail(7);
1400053f5      breakpoint();
140005340  }

1400053f6                                                                    cc cc                                                ..

1400053f8    int64_t post_pgo_initialization()

1400053f8  {
1400053fc      __scrt_initialize_default_local_stdio_options();
140005407      return 0;
1400053f8  }


140005408    int64_t pre_cpp_initialization()

140005408  {
14000540c      sub_140005b2c();
14000541c      /* tailcall */
14000541c      return _set_new_mode(0);
140005408  }

140005421     cc cc cc                                                                                       ...

140005424    uint64_t __scrt_common_main_seh(uint64_t arg1 @ rbx)

140005424  {
140005424      uint64_t arg_8 = arg1;
140005424      
14000543f      if (!sub_14000565c(1))
14000543f      {
140005580          __scrt_fastfail(7);
14000558b          __scrt_fastfail(7);
14000543f      }
14000543f      else
14000543f      {
140005445          int64_t rsi;
140005445          (uint8_t)rsi = 0;
140005448          char var_18_1 = 0;
140005452          (uint8_t)arg1 = __scrt_acquire_startup_lock();
140005454          int32_t rcx_1 = data_14000a198;
140005454          
14000545d          if (rcx_1 == 1)
14000558b              __scrt_fastfail(7);
14000545d          else
14000545d          {
140005465              if (rcx_1)
140005465              {
1400054b1                  (uint8_t)rsi = 1;
1400054b4                  char var_18_2 = 1;
140005465              }
140005465              else
140005465              {
140005467                  data_14000a198 = 1;
140005467                  
140005486                  if (_initterm_e(&data_1400072c0, &data_1400072d8))
140005488                      return 0xff;
140005488                  
1400054a0                  _initterm(&data_1400072a0, &data_1400072b8);
1400054a5                  data_14000a198 = 2;
140005465              }
140005465              
1400054b9              (uint8_t)rcx_1 = (uint8_t)arg1;
1400054bb              __scrt_release_startup_lock((uint8_t)rcx_1);
1400054bb              
1400054cc              if (data_14000a218
1400054cc                      && __scrt_is_nonwritable_in_current_image(&data_14000a218))
140005540                  data_14000a218(0, 2, 0);
140005540              
1400054f8              if (data_14000a210
1400054f8                      && __scrt_is_nonwritable_in_current_image(&data_14000a210))
140005509                  _register_thread_local_exe_atexit_callback(data_14000a210);
140005509              
14000550e              _get_initial_narrow_environment();
14000551b              *(uint64_t*)__p___argv();
140005530              arg1 = (uint64_t)main(*(uint32_t*)__p___argc());
140005530              
140005539              if (sub_140005ad8())
140005539              {
14000553e                  if (!(uint8_t)rsi)
140005540                      _cexit();
140005540                  
140005549                  __scrt_uninitialize_crt(1, 0);
14000554e                  return (uint64_t)(uint32_t)arg1;
140005539              }
14000545d          }
14000543f      }
14000543f      
140005592      exit((uint32_t)arg1);
140005592      /* no return */
140005424  }


140005552    uint64_t sub_140005552(int32_t arg1 @ rax, char arg2, int64_t arg3, int64_t arg4, int64_t arg5)

140005552  {
14000555b      if (!sub_140005ad8())
14000555b      {
14000559a          _exit(arg1);
14000559a          /* no return */
14000555b      }
14000555b      
140005562      if (!arg2)
140005564          _c_exit();
140005564      
14000557a      return (uint64_t)arg1;
140005552  }

140005597                                                                       90                                                 .
14000559f                                                                                               90                                 .

1400055a0    int64_t _start()

1400055a0  {
1400055a4      sub_140005860();
1400055ad      uint64_t rbx;
1400055ad      /* tailcall */
1400055ad      return __scrt_common_main_seh(rbx);
1400055a0  }

1400055b2                                                        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                    ..............
1400055c0  cc cc cc cc cc cc 66 66 0f 1f 84 00 00 00 00 00                                                  ......ff........

1400055d0    void __chkstk(int64_t arg1 @ rax)

1400055d0  {
1400055e5      void arg_8;
1400055e5      void* r10 = &arg_8 - arg1;
1400055e5      
1400055e8      if (&arg_8 < arg1)
1400055e8          r10 = nullptr;
1400055e8      
1400055ec      TEB* gsbase;
1400055ec      void* StackLimit = gsbase->NtTib.StackLimit;
1400055ec      
1400055f8      if (r10 >= StackLimit)
1400055f8          return;
1400055f8      
1400055fa      (uint16_t)r10 &= 0xf000;
1400055fa      
14000560e      do
14000560e      {
140005600          StackLimit -= 0x1000;
140005607          *(uint8_t*)StackLimit = 0;
14000560e      } while (r10 != StackLimit);
1400055d0  }

14000561e                                                                                            cc cc                                ..

140005620    int64_t __scrt_acquire_startup_lock()

140005620  {
14000562b      int64_t result;
14000562b      
14000562b      if (!sub_140005edc())
14000562b      {
14000564e      label_14000564e:
14000564e          (uint8_t)result = 0;
14000562b      }
14000562b      else
14000562b      {
140005636          TEB* gsbase;
140005636          void* StackBase = gsbase->NtTib.Self->NtTib.StackBase;
140005636          
14000563f          do
14000563f          {
140005641              result = 0;
140005643              bool z_1;
140005643              
140005643              if (0 == data_14000a1a0)
140005643              {
140005643                  data_14000a1a0 = StackBase;
140005643                  z_1 = true;
140005643              }
140005643              else
140005643              {
140005643                  result = data_14000a1a0;
140005643                  z_1 = false;
140005643              }
140005643              
14000564c              if (z_1)
14000564c                  goto label_14000564e;
14000563f          } while (StackBase != result);
14000563f          
140005655          (uint8_t)result = 1;
14000562b      }
14000562b      
140005654      return result;
140005620  }

140005659                                                                             cc cc cc                                       ...

14000565c    int64_t sub_14000565c(int32_t arg1)

14000565c  {
140005662      if (!arg1)
140005664          data_14000a1a8 = 1;
140005664      
14000566b      int64_t xcr0;
14000566b      sub_140005c10(xcr0);
14000566b      
140005677      if (sub_140005930() && sub_140005930())
14000568f          return 1;
14000568f      
140005679      return 0;
14000565c  }

140005696                                                                    cc cc                                                ..

140005698    int32_t __scrt_initialize_onexit_tables(int32_t arg1)

140005698  {
1400056a7      int32_t result;
1400056a7      
1400056a7      if (data_14000a1a9)
140005710          (uint8_t)result = 1;
1400056a7      else
1400056a7      {
1400056ac          if (arg1 > 1)
1400056ac          {
14000571d              __scrt_fastfail(5);
140005722              breakpoint();
1400056ac          }
1400056ac          
1400056b9          if (!sub_140005edc() || arg1)
1400056b9          {
1400056eb              __builtin_memset(&data_14000a1b0, 0xff, 0x30);
140005709              data_14000a1a9 = 1;
140005710              (uint8_t)result = 1;
1400056b9          }
1400056b9          else if (_initialize_onexit_table(&data_14000a1b0))
1400056db              (uint8_t)result = 0;
1400056c9          else if (!_initialize_onexit_table(&data_14000a1c8))
1400056d9          {
140005709              data_14000a1a9 = 1;
140005710              (uint8_t)result = 1;
1400056d9          }
1400056d9          else
1400056db              (uint8_t)result = 0;
1400056a7      }
1400056a7      
140005717      return result;
140005698  }

140005723           cc                                                                                         .

140005724    uint64_t __scrt_is_nonwritable_in_current_image(int64_t arg1)

140005724  {
140005768      struct Section_Header* const rdx_1 = &__section_headers;
140005768      
140005777      while (true)
140005777      {
140005777          struct Section_Header* const var_18_1 = rdx_1;
140005777          
14000577e          if (rdx_1 == &data_1400002c0)
14000577e          {
140005798              rdx_1 = nullptr;
140005798              break;
14000577e          }
14000577e          
140005780          uint64_t virtualAddress = (uint64_t)rdx_1->virtualAddress;
140005780          
140005790          if (arg1 - &__dos_header >= virtualAddress && arg1 - &__dos_header
140005790                  < (uint64_t)(rdx_1->virtualSize + (uint32_t)virtualAddress))
140005790              break;
140005790          
140005792          rdx_1 = &rdx_1[1];
140005777      }
140005777      
14000579d      uint64_t result;
14000579d      
14000579d      if (!rdx_1)
14000579f          (uint8_t)result = 0;
14000579d      else if (rdx_1->characteristics >= 0)
1400057ad          (uint8_t)result = 1;
1400057a7      else
1400057a9          (uint8_t)result = 0;
1400057a9      
1400057bb      return result;
140005724  }

1400057b5                                                                 32 c0                                                  2.

1400057bc    int64_t __scrt_release_startup_lock(char arg1)

1400057bc  {
1400057c2      int64_t rbx;
1400057c2      (uint8_t)rbx = arg1;
1400057c4      int32_t result = sub_140005edc();
1400057c4      
1400057d1      if (result && !(uint8_t)rbx)
1400057d1      {
1400057d3          data_14000a1a0;
1400057d3          data_14000a1a0 = 0;
1400057d1      }
1400057d1      
1400057df      return result;
1400057bc  }


1400057e0    int64_t __scrt_uninitialize_crt(char arg1, char arg2)

1400057e0  {
1400057ed      int64_t rbx;
1400057ed      (uint8_t)rbx = arg1;
1400057e6      data_14000a1a8;
140005801      int64_t result;
140005801      (uint8_t)result = 1;
140005808      return result;
1400057e0  }

140005809                             cc cc cc                                                                       ...

14000580c    _onexit_t_1 _onexit(_PVFV arg1)

14000580c  {
14000581a      _onexit_t_1 _Function = arg1;
14000581d      int32_t rax;
14000581d      
14000581d      if (data_14000a1b0 != -1)
140005830          rax = _register_onexit_function(&data_14000a1b0, _Function);
14000581d      else
14000581f          rax = _crt_atexit(arg1);
14000581f      
140005839      if (!rax)
140005839          return _Function;
140005839      
140005845      return nullptr;
14000580c  }

140005846                    cc cc                                                                                ..

140005848    uint64_t atexit(_PVFV arg1)

140005848  {
14000584c      _onexit_t_1 rax = _onexit(arg1);
140005851      int32_t rax_1 = (int32_t)-(rax);
14000585e      return (uint64_t)(-((rax_1 - rax_1)) - 1);
140005848  }

14000585f                                                                                               cc                                 .

140005860    uint64_t sub_140005860()

140005860  {
14000586d      uint64_t __security_cookie_1 = __security_cookie;
14000586d      
140005881      if (__security_cookie_1 == 0x2b992ddfa232)
140005881      {
140005883          FILETIME systemTimeAsFileTime;
140005883          __builtin_memset(&systemTimeAsFileTime, 0, 8);
14000588c          GetSystemTimeAsFileTime(&systemTimeAsFileTime);
140005892          int64_t rax;
140005892          (uint32_t)rax = systemTimeAsFileTime.dwLowDateTime;
140005892          *(uint32_t*)((char*)rax)[4] = systemTimeAsFileTime.dwHighDateTime;
140005896          int64_t var_18 = rax;
1400058a0          uint64_t rax_2 = (uint64_t)GetCurrentThreadId();
1400058a2          var_18 ^= rax_2;
1400058ac          uint64_t rax_4 = (uint64_t)GetCurrentProcessId();
1400058b2          var_18 ^= rax_4;
1400058b6          int64_t performanceCount;
1400058b6          QueryPerformanceCounter(&performanceCount);
1400058dc          __security_cookie_1 = ((uint64_t)(uint32_t)performanceCount << 0x20
1400058dc              ^ performanceCount ^ var_18 ^ &var_18) & 0xffffffffffff;
1400058dc          
1400058ec          if (__security_cookie_1 == 0x2b992ddfa232)
1400058ec              __security_cookie_1 = 0x2b992ddfa233;
1400058ec          
1400058f0          __security_cookie = __security_cookie_1;
140005881      }
140005881      
1400058fc      uint64_t result = ~__security_cookie_1;
1400058ff      data_14000a0c0 = result;
14000590b      return result;
140005860  }


14000590c    int64_t sub_14000590c() __pure

14000590c  {
14000590e      return 0;
14000590c  }

14000590f                                               cc                                                                 .

140005910    int64_t sub_140005910() __pure

140005910  {
140005915      return 1;
140005910  }

140005916                                                                    cc cc                                                ..

140005918    int64_t sub_140005918() __pure

140005918  {
14000591d      return 0x4000;
140005918  }

14000591e                                                                                            cc cc                                ..

140005920    int64_t sub_140005920()

140005920  {
140005927      /* tailcall */
140005927      return InitializeSListHead(&data_14000a1e0);
140005920  }

14000592e                                            cc cc                                                                ..

140005930    int64_t sub_140005930() __pure

140005930  {
140005930      int64_t result;
140005930      (uint8_t)result = 1;
140005932      return result;
140005930  }

140005933                                                           cc                                                         .

140005934    void _guard_check_icall(void (* arg1)()) __pure

140005934  {
140005934      return;
140005934  }

140005937                                                                       cc                                                 .

140005938    int64_t sub_140005938() __pure

140005938  {
14000593f      return &data_14000a1f0;
140005938  }


140005940    int64_t sub_140005940() __pure

140005940  {
140005947      return &data_14000a1f8;
140005940  }


140005948    int64_t __scrt_initialize_default_local_stdio_options()

140005948  {
140005951      data_14000a1f0 |= 0x24;
14000595a      data_14000a1f8 |= 2;
140005962      return &data_14000a1f8;
140005948  }

140005963           cc                                                                                         .

140005964    int64_t sub_140005964()

140005964  {
14000596c      int64_t result;
14000596c      (uint8_t)result = !data_14000a048;
14000596f      return result;
140005964  }


140005970    int64_t sub_140005970() __pure

140005970  {
140005977      return &data_14000a218;
140005970  }


140005978    int64_t sub_140005978() __pure

140005978  {
14000597f      return &data_14000a210;
140005978  }


140005980    int64_t sub_140005980()

140005980  {
140005980      data_14000a200 = 0;
140005980  }


140005988    int32_t __scrt_fastfail(int32_t arg1)

140005988  {
1400059ac      if (IsProcessorFeaturePresent(PF_FASTFAIL_AVAILABLE))
1400059b0          trap(0xd);
1400059b0      
1400059b7      sub_140005980();
1400059c8      CONTEXT ContextRecord;
1400059c8      memset(&ContextRecord, 0, 0x4d0);
1400059d1      RtlCaptureContext(&ContextRecord);
1400059d7      uint64_t Rip = ContextRecord.Rip;
1400059eb      uint64_t ImageBase;
1400059eb      IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionEntry =
1400059eb          RtlLookupFunctionEntry(Rip, &ImageBase, nullptr);
1400059f4      uint64_t EstablisherFrame;
1400059f4      void HandlerData;
1400059f4      
1400059f4      if (FunctionEntry)
140005a2c          RtlVirtualUnwind(UNW_FLAG_NHANDLER, ImageBase, Rip, FunctionEntry, 
140005a2c              &ContextRecord, &HandlerData, &EstablisherFrame, nullptr);
140005a3e      ContextRecord.Rip = __return_addr;
140005a58      int64_t __saved_rbx;
140005a58      ContextRecord.Rsp = &__saved_rbx;
140005a5f      int32_t var_578;
140005a5f      memset(&var_578, 0, 0x98);
140005a6b      void* const __return_addr_1 = __return_addr;
140005a70      var_578 = 0x40000015;
140005a78      int32_t var_574 = 1;
140005a80      BOOL rax_3 = IsDebuggerPresent();
140005a8f      EXCEPTION_POINTERS ExceptionInfo;
140005a8f      ExceptionInfo.ExceptionRecord = &var_578;
140005a98      ExceptionInfo.ContextRecord = &ContextRecord;
140005a9d      SetUnhandledExceptionFilter(nullptr);
140005aa8      int32_t result = UnhandledExceptionFilter(&ExceptionInfo);
140005aa8      
140005ab5      if (!result && rax_3 != 1)
140005aba          sub_140005980();
140005aba      
140005acf      return result;
140005988  }


140005ad0    int64_t j_sub_14000590c()

140005ad0  {
140005ad0      /* tailcall */
140005ad0      return sub_14000590c();
140005ad0  }

140005ad5                                                                 cc cc cc                                               ...

140005ad8    HMODULE sub_140005ad8()

140005ad8  {
140005ade      HMODULE result = GetModuleHandleW(nullptr);
140005af1      int32_t* rcx_2;
140005af1      
140005af1      if (result && result->unused == 0x5a4d)
140005af7          rcx_2 = result * 2;
140005af7      
140005b14      if (!result || result->unused != 0x5a4d || *(uint32_t*)rcx_2 != 0x4550
140005b14              || rcx_2[6] != 0x20b || rcx_2[0x21] <= 0xe)
140005b22          (uint8_t)result = 0;
140005b14      else
140005b1d          (uint8_t)result = rcx_2[0x3e];
140005b1d      
140005b28      return result;
140005ad8  }

140005b29                             cc cc cc                                                                       ...

140005b2c    int64_t sub_140005b2c()

140005b2c  {
140005b33      /* tailcall */
140005b33      return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
140005b2c  }

140005b3a                                                                                cc cc                                        ..

140005b3c    int64_t __scrt_unhandled_exception_filter(int64_t* arg1)

140005b3c  {
140005b46      int32_t* rbx = *(uint64_t*)arg1;
140005b46      
140005b58      if (*(uint32_t*)rbx == 0xe06d7363 && rbx[6] == 4)
140005b58      {
140005b5a          int32_t rdx_1 = rbx[8];
140005b5a          
140005b6e          if (rdx_1 - 0x19930520 <= 2 || rdx_1 == 0x1994000)
140005b6e          {
140005b82              *(uint64_t*)__current_exception() = rbx;
140005b8e              *(uint64_t*)__current_exception_context() = arg1[1];
140005b91              terminate();
140005b91              /* no return */
140005b6e          }
140005b58      }
140005b58      
140005b7c      return 0;
140005b3c  }

140005b96                                                                    cc cc                                                ..

140005b98    void _RTC_Initialize()

140005b98  {
140005bc7      for (void* const i = &data_140008768; i < &data_140008768; i += 8)
140005bc7      {
140005bb2          int64_t rax = *(uint64_t*)i;
140005bb2          
140005bb8          if (rax)
140005bba              rax();
140005bc7      }
140005b98  }


140005bd4    void _RTC_Terminate()

140005bd4  {
140005c03      for (void* const i = &data_140008778; i < &data_140008778; i += 8)
140005c03      {
140005bee          int64_t rax = *(uint64_t*)i;
140005bee          
140005bf4          if (rax)
140005bf6              rax();
140005c03      }
140005bd4  }


140005c10    int64_t sub_140005c10(int64_t arg1 @ xcr0)

140005c10  {
140005c29      int32_t temp0;
140005c29      int32_t temp1;
140005c29      int32_t temp2;
140005c29      int32_t temp3;
140005c29      temp0 = __cpuid(0, 0);
140005c4c      int32_t temp0_1;
140005c4c      int32_t temp1_1;
140005c4c      int32_t temp2_1;
140005c4c      int32_t temp3_1;
140005c4c      temp0_1 = __cpuid(1, 0);
140005c51      int32_t var_28 = temp0_1;
140005c5b      int32_t var_24 = temp1_1;
140005c61      int32_t var_20 = temp2_1;
140005c66      int32_t var_1c = temp3_1;
140005c69      int32_t rax_2;
140005c69      uint64_t rax_3;
140005c69      
140005c69      if (!((temp3 ^ 0x49656e69) | (temp2 ^ 0x6c65746e) | (temp1 ^ 0x756e6547)))
140005c69      {
140005c6b          data_14000a068 = -1;
140005c73          rax_2 = temp0_1 & 0xfff3ff0;
140005c78          data_14000a060 = 0x8000;
140005c78          
140005c96          if (rax_2 != 0x106c0 && rax_2 != 0x20660 && rax_2 != 0x20670)
140005c98              rax_3 = (uint64_t)(rax_2 - 0x30650);
140005c69      }
140005c69      
140005cb0      int32_t r8_3;
140005cb0      
140005cb0      if ((temp3 ^ 0x49656e69) | (temp2 ^ 0x6c65746e) | (temp1 ^ 0x756e6547) || (
140005cb0              rax_2 != 0x106c0 && rax_2 != 0x20660 && rax_2 != 0x20670
140005cb0              && ((uint32_t)rax_3 > 0x20 || !TEST_BITQ(0x100010001, rax_3))))
140005cc6          r8_3 = data_14000a208;
140005cb0      else
140005cb0      {
140005cb9          r8_3 = data_14000a208 | 1;
140005cbd          data_14000a208 = r8_3;
140005cb0      }
140005cb0      
140005ccd      int32_t r9_2 = 0;
140005cd0      int32_t rsi = 0;
140005cd3      int32_t r10_4 = 0;
140005cd6      int32_t r11 = 0;
140005cd6      
140005cdd      if (temp0 >= 7)
140005cdd      {
140005ce5          int32_t temp0_2;
140005ce5          int32_t temp1_2;
140005ce5          int32_t temp2_2;
140005ce5          int32_t temp3_2;
140005ce5          temp0_2 = __cpuid(7, 0);
140005ce7          int32_t var_28_1 = temp0_2;
140005cea          rsi = temp3_2;
140005cec          int32_t var_24_1 = temp1_2;
140005cef          r9_2 = temp1_2;
140005cf2          int32_t var_20_1 = temp2_2;
140005cf5          int32_t var_1c_1 = temp3_2;
140005cf5          
140005cfc          if (TEST_BITD(temp1_2, 9))
140005d02              data_14000a208 = r8_3 | 2;
140005d02          
140005d0c          if (temp0_2 >= 1)
140005d0c          {
140005d16              int32_t temp0_3;
140005d16              int32_t temp1_3;
140005d16              int32_t temp2_3;
140005d16              int32_t temp3_3;
140005d16              temp0_3 = __cpuid(7, 1);
140005d18              r10_4 = temp3_3;
140005d1b              int32_t var_28_2 = temp0_3;
140005d1e              int32_t var_24_2 = temp1_3;
140005d21              int32_t var_20_2 = temp2_3;
140005d24              int32_t var_1c_2 = temp3_3;
140005d0c          }
140005d0c          
140005d2f          if (temp0 >= 0x24)
140005d2f          {
140005d33              int32_t temp0_4;
140005d33              int32_t temp1_4;
140005d33              int32_t temp2_4;
140005d33              int32_t temp3_4;
140005d33              temp0_4 = __cpuid(0x24, 0);
140005d35              r11 = temp1_4;
140005d38              int32_t var_28_3 = temp0_4;
140005d3b              int32_t var_24_3 = temp1_4;
140005d3e              int32_t var_20_3 = temp2_4;
140005d41              int32_t var_1c_3 = temp3_4;
140005d2f          }
140005cdd      }
140005cdd      
140005d50      int64_t rax_8 = data_14000a050 & 0xfffffffffffffffe;
140005d54      data_14000a058 = 1;
140005d5e      data_14000a05c = 2;
140005d68      data_14000a050 = rax_8;
140005d68      
140005d73      if (TEST_BITD(temp2_1, 0x14))
140005d73      {
140005d79          data_14000a058 = 2;
140005d83          data_14000a050 = rax_8 & 0xffffffffffffffef;
140005d8a          data_14000a05c = 6;
140005d73      }
140005d73      
140005d94      if (TEST_BITD(temp2_1, 0x1b))
140005d94      {
140005d9c          int32_t temp0_5;
140005d9c          int32_t temp1_5;
140005d9c          temp0_5 = _xgetbv(0, arg1);
140005da3          uint64_t rdx_7 = (uint64_t)temp0_5 << 0x20 | (uint64_t)temp1_5;
140005da3          
140005dbc          if (TEST_BITD(temp2_1, 0x1c) && ((uint8_t)rdx_7 & 6) == 6)
140005dbc          {
140005dca              int32_t rax_13 = data_14000a05c | 8;
140005dcd              data_14000a058 = 3;
140005dd7              data_14000a05c = rax_13;
140005de1              int64_t rax_16;
140005de1              
140005de1              if (!((uint8_t)r9_2 & 0x20))
140005e40                  rax_16 = data_14000a050;
140005de1              else
140005de1              {
140005de6                  data_14000a058 = 5;
140005df0                  data_14000a05c = rax_13 | 0x20;
140005e05                  rax_16 = data_14000a050 & 0xfffffffffffffffd;
140005e09                  data_14000a050 = rax_16;
140005e09                  
140005e13                  if ((r9_2 & 0xd0030000) == 0xd0030000)
140005e13                  {
140005e1d                      if (((uint8_t)rdx_7 & 0xe0) != 0xe0)
140005e40                          rax_16 = data_14000a050;
140005e1d                      else
140005e1d                      {
140005e1f                          int64_t rax_18 = data_14000a050;
140005e26                          data_14000a05c |= 0x40;
140005e2d                          rax_16 = rax_18 & 0xffffffffffffffdb;
140005e31                          data_14000a058 = 6;
140005e37                          data_14000a050 = rax_16;
140005e1d                      }
140005e13                  }
140005de1              }
140005de1              
140005e4b              if (TEST_BITD(rsi, 0x17))
140005e52                  data_14000a050 = rax_16 & 0xfffffffffeffffff;
140005e52              
140005e68              if (TEST_BITD(r10_4, 0x13) && ((uint8_t)rdx_7 & 0xe0) == 0xe0)
140005e68              {
140005e74                  int32_t rax_22 = r11 & 0x400ff;
140005e7c                  data_14000a204 = rax_22;
140005e8c                  int64_t rcx_10 =
140005e8c                      ~(((uint64_t)(r11 >> 0x10) & 7) | 0x1000028) & data_14000a050;
140005e93                  data_14000a050 = rcx_10;
140005e93                  
140005e9d                  if (rax_22 > 1)
140005ea3                      data_14000a050 = rcx_10 & 0xffffffffffffffbf;
140005e68              }
140005dbc          }
140005dbc          
140005eba          if (TEST_BITD(r10_4, 0x15) && TEST_BITQ(rdx_7, 0x13))
140005ebc              data_14000a050 &= 0xffffffffffffff7f;
140005d94      }
140005d94      
140005ed9      return 0;
140005c10  }

140005eda                                                                                cc cc                                        ..

140005edc    int64_t sub_140005edc()

140005edc  {
140005ee4      int64_t result;
140005ee4      (uint8_t)result = data_14000a0d0;
140005ee7      return result;
140005edc  }

140005ee8                          cc cc cc cc cc cc cc cc                                                          ........

140005ef0    int64_t memcpy(void* dest, void const* src, uint32_t count)

140005ef0  {
140005ef0      /* tailcall */
140005ef0      return memcpy(dest, src, count);
140005ef0  }


140005ef6    int32_t memcmp(void const* buffer1, void const* buffer2, uint64_t count)

140005ef6  {
140005ef6      /* tailcall */
140005ef6      return memcmp(buffer1, buffer2, count);
140005ef6  }


140005efc    int64_t memset(void* dest, int32_t c, uint64_t count)

140005efc  {
140005efc      /* tailcall */
140005efc      return memset(dest, c, count);
140005efc  }


140005f02    int64_t memmove(void* dest, void const* src, uint32_t count)

140005f02  {
140005f02      /* tailcall */
140005f02      return memmove(dest, src, count);
140005f02  }


140005f08    enum _EXCEPTION_DISPOSITION __C_specific_handler(struct _EXCEPTION_RECORD* ExceptionRecord, void* EstablisherFrame, struct _CONTEXT* ContextRecord, struct _DISPATCHER_CONTEXT* DispatcherContext)

140005f08  {
140005f08      /* tailcall */
140005f08      return __C_specific_handler(ExceptionRecord, EstablisherFrame, ContextRecord, 
140005f08          DispatcherContext);
140005f08  }


140005f0e    int64_t __current_exception()

140005f0e  {
140005f0e      /* tailcall */
140005f0e      return __current_exception();
140005f0e  }


140005f14    int64_t __current_exception_context()

140005f14  {
140005f14      /* tailcall */
140005f14      return __current_exception_context();
140005f14  }


140005f1a    int32_t _seh_filter_exe(uint32_t _ExceptionNum, struct _EXCEPTION_POINTERS* _ExceptionPtr)

140005f1a  {
140005f1a      /* tailcall */
140005f1a      return _seh_filter_exe(_ExceptionNum, _ExceptionPtr);
140005f1a  }


140005f20    void _set_app_type(enum _crt_app_type _Type)

140005f20  {
140005f20      /* tailcall */
140005f20      return _set_app_type(_Type);
140005f20  }


140005f26    void __setusermatherr(_UserMathErrorFunctionPointer _UserMathErrorFunction)

140005f26  {
140005f26      /* tailcall */
140005f26      return __setusermatherr(_UserMathErrorFunction);
140005f26  }


140005f2c    errno_t _configure_narrow_argv(enum _crt_argv_mode mode)

140005f2c  {
140005f2c      /* tailcall */
140005f2c      return _configure_narrow_argv(mode);
140005f2c  }


140005f32    int32_t _initialize_narrow_environment()

140005f32  {
140005f32      /* tailcall */
140005f32      return _initialize_narrow_environment();
140005f32  }


140005f38    char** _get_initial_narrow_environment()

140005f38  {
140005f38      /* tailcall */
140005f38      return _get_initial_narrow_environment();
140005f38  }


140005f3e    void _initterm(_PVFV* _First, _PVFV* _Last)

140005f3e  {
140005f3e      /* tailcall */
140005f3e      return _initterm(_First, _Last);
140005f3e  }


140005f44    int32_t _initterm_e(_PIFV* _First, _PIFV* _Last)

140005f44  {
140005f44      /* tailcall */
140005f44      return _initterm_e(_First, _Last);
140005f44  }


140005f4a    void exit(int32_t _Except) __noreturn

140005f4a  {
140005f4a      /* tailcall */
140005f4a      return exit(_Except);
140005f4a  }


140005f50    void _exit(int32_t _Except) __noreturn

140005f50  {
140005f50      /* tailcall */
140005f50      return _exit(_Except);
140005f50  }


140005f56    errno_t _set_fmode(int32_t _Value)

140005f56  {
140005f56      /* tailcall */
140005f56      return _set_fmode(_Value);
140005f56  }


140005f5c    int32_t* __p___argc()

140005f5c  {
140005f5c      /* tailcall */
140005f5c      return __p___argc();
140005f5c  }


140005f62    char*** __p___argv()

140005f62  {
140005f62      /* tailcall */
140005f62      return __p___argv();
140005f62  }


140005f68    void _cexit()

140005f68  {
140005f68      /* tailcall */
140005f68      return _cexit();
140005f68  }


140005f6e    void _c_exit()

140005f6e  {
140005f6e      /* tailcall */
140005f6e      return _c_exit();
140005f6e  }


140005f74    void _register_thread_local_exe_atexit_callback(_tls_callback_type _Callback)

140005f74  {
140005f74      /* tailcall */
140005f74      return _register_thread_local_exe_atexit_callback(_Callback);
140005f74  }


140005f7a    int32_t _configthreadlocale(int32_t _Flag)

140005f7a  {
140005f7a      /* tailcall */
140005f7a      return _configthreadlocale(_Flag);
140005f7a  }


140005f80    int32_t _set_new_mode(int32_t _NewMode)

140005f80  {
140005f80      /* tailcall */
140005f80      return _set_new_mode(_NewMode);
140005f80  }


140005f86    int32_t* __p__commode()

140005f86  {
140005f86      /* tailcall */
140005f86      return __p__commode();
140005f86  }


140005f8c    int32_t _initialize_onexit_table(struct _onexit_table_t* _Table)

140005f8c  {
140005f8c      /* tailcall */
140005f8c      return _initialize_onexit_table(_Table);
140005f8c  }


140005f92    int32_t _register_onexit_function(struct _onexit_table_t* _Table, _onexit_t_1 _Function)

140005f92  {
140005f92      /* tailcall */
140005f92      return _register_onexit_function(_Table, _Function);
140005f92  }


140005f98    int32_t _crt_atexit(_PVFV _Function)

140005f98  {
140005f98      /* tailcall */
140005f98      return _crt_atexit(_Function);
140005f98  }


140005f9e    void terminate() __noreturn

140005f9e  {
140005f9e      /* tailcall */
140005f9e      return terminate();
140005f9e  }

140005fa4              cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc 66 66 0f 1f 84 00 00 00 00 00      ..................ff........

140005fc0    void _guard_dispatch_icall_nop(void (* arg1)())

140005fc0  {
140005fc0      int64_t entry_rax;
140005fc0      /* jump -> entry_rax */
140005fc0  }

140005fc2        cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc 66 66 0f 1f 84 00 00 00 00 00    ....................ff........

140005fe0    int64_t sub_140005fe0()

140005fe0  {
140005fe0      int64_t rax;
140005fe0      /* tailcall */
140005fe0      return rax();
140005fe0  }

140005fe6                    cc cc cc cc cc cc cc cc cc cc                                                        ..........

140005ff0    int64_t sub_140005ff0(int64_t* arg1, uint64_t arg2, int64_t* arg3)

140005ff0  {
140006001      uint64_t rdx;
140006001      
140006001      if (arg3[1])
140006003          rdx = arg3[2];
140006003      
14000600a      int64_t result;
14000600a      
14000600a      if (!arg3[1] || !rdx)
14000600a      {
14000601f          data_14000a0e0;
14000602e          result = j_sub_140002390(arg2, 1);
14000600a      }
14000600a      else
140006018          result = j_sub_140002420(*(uint64_t*)arg3, rdx, 1, arg2);
140006018      
140006038      int64_t result_1 = 1;
140006038      
14000603d      if (result)
14000603d          result_1 = result;
14000603d      
140006041      int64_t rcx_2;
140006041      (uint8_t)rcx_2 = !result;
140006044      arg1[1] = result_1;
140006048      arg1[2] = arg2;
14000604c      *(uint64_t*)arg1 = rcx_2;
140006055      return result;
140005ff0  }

140006056                                                                    cc cc cc cc cc cc cc cc cc cc                        ..........

140006060    int64_t sub_140006060(int64_t* arg1, int64_t arg2, int64_t arg3)

140006060  {
140006066      uint64_t rdx = arg2 + arg3;
140006066      
140006069      if (arg2 + arg3 >= arg2)
140006069      {
14000606e          int64_t rax_1 = *(uint64_t*)arg1;
140006071          uint64_t rcx = rax_1 * 2;
140006071          
140006078          if (rdx > rcx)
140006078              rcx = rdx;
140006078          
140006080          uint64_t rdi_1 = 8;
140006080          
140006085          if (rcx >= 9)
140006085              rdi_1 = rcx;
140006085          
14000608c          if (rdi_1 >= 0)
14000608c          {
140006091              int64_t var_28;
140006091              int64_t rax_2;
140006091              
140006091              if (rax_1)
140006091              {
14000609b                  var_28 = arg1[1];
1400060a0                  int64_t var_18_1 = rax_1;
1400060a5                  rax_2 = 1;
140006091              }
140006091              else
140006093                  rax_2 = 0;
140006093              
1400060aa              int64_t var_20 = rax_2;
1400060bc              int32_t var_40;
1400060bc              sub_140005ff0(&var_40, rdi_1, &var_28);
1400060bc              
1400060c6              if (var_40 == 1)
1400060c6              {
1400060fa                  sub_140006700();
1400060fa                  /* no return */
1400060c6              }
1400060c6              
1400060cd              int64_t result;
1400060cd              arg1[1] = result;
1400060d1              *(uint64_t*)arg1 = rdi_1;
1400060da              return result;
14000608c          }
140006069      }
140006069      
1400060e4      sub_140006700();
1400060e4      /* no return */
140006060  }

1400060ff                                                                                               cc                                 .

140006100    void* sub_140006100(void* arg1)

140006100  {
140006125      TEB* gsbase;
140006125      
140006125      if (*(uint64_t*)(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
140006125              + ((uint64_t)data_14000a190 << 3)) + 0x20))
1400061da          trap(0xd);
1400061da      
14000613a      void* rbx = *
14000613a          (uint64_t*)(gsbase->ThreadLocalStoragePointer + ((uint64_t)data_14000a190 << 3));
14000613e      *(uint64_t*)((char*)rbx + 0x20) = -1;
14000614e      int64_t rdi = *(uint64_t*)((char*)rbx + 0x38);
14000614e      
14000615c      if (rdi == *(uint64_t*)((char*)rbx + 0x28))
14000617f          sub_1400027c0(*(uint64_t*)(gsbase->ThreadLocalStoragePointer
14000617f              + ((uint64_t)data_14000a190 << 3)) + 0x28);
14000617f      
140006193      void* rax_6 = *
140006193          (uint64_t*)(gsbase->ThreadLocalStoragePointer + ((uint64_t)data_14000a190 << 3));
140006197      int64_t* rcx_5 = *(uint64_t*)((char*)rax_6 + 0x30);
1400061a5      rcx_5[rdi * 2] = arg1;
1400061b0      rcx_5[rdi * 2 + 1] = &data_1400027a0;
1400061b8      *(uint64_t*)((char*)rax_6 + 0x38) = rdi + 1;
1400061bf      *(uint64_t*)((char*)rax_6 + 0x20) += 1;
1400061c6      *(uint8_t*)((char*)arg1 + 8) = 1;
1400061d4      return arg1;
140006100  }

1400061dc                                                                                      0f 0b cc cc                              ....

1400061e0    int64_t sub_1400061e0(int64_t* arg1, int64_t arg2, uint64_t arg3, int64_t* arg4)

1400061e0  {
1400061ea      int64_t result_1 = arg2;
1400061f5      uint64_t rdx;
1400061f5      
1400061f5      if (arg4[1])
1400061f7          rdx = arg4[2];
1400061f7      
1400061fe      int64_t result;
1400061fe      
1400061fe      if (arg4[1] && rdx)
140006209          result = j_sub_140002420(*(uint64_t*)arg4, rdx, result_1, arg3);
1400061fe      else if (!arg3)
140006229          result = result_1;
140006213      else
140006213      {
140006215          data_14000a0e0;
140006222          result = j_sub_140002390(arg3, result_1);
140006213      }
140006213      
140006231      if (result)
140006231          result_1 = result;
140006231      
140006235      int64_t rcx_2;
140006235      (uint8_t)rcx_2 = !result;
140006238      arg1[1] = result_1;
14000623c      arg1[2] = arg3;
140006240      *(uint64_t*)arg1 = rcx_2;
14000624a      return result;
1400061e0  }

14000624b                                   cc cc cc cc cc                                                             .....

140006250    int64_t sub_140006250(int64_t* arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5)

140006250  {
140006261      if (arg5)
140006261      {
140006267          int64_t rdx = arg2 + arg3;
140006267          
14000626a          if (arg2 + arg3 >= arg2)
14000626a          {
140006273              int64_t r8 = *(uint64_t*)arg1;
140006276              int64_t rax_1 = r8 * 2;
140006276              
14000627d              if (rdx > rax_1)
14000627d                  rax_1 = rdx;
14000627d              
14000628a              int64_t rcx;
14000628a              (uint8_t)rcx = arg5 < 0x401;
140006296              int64_t rdi_1 = 8;
140006296              
14000629b              if (arg5 != 1)
14000629b                  rdi_1 = rcx * 3 + 1;
14000629b              
1400062a2              if (rax_1 > rdi_1)
1400062a2                  rdi_1 = rax_1;
1400062a2              
1400062b3              int64_t rax_4 = -(arg4) & (arg4 + arg5 - 1);
1400062b8              uint64_t rax_5 = rax_4 * rdi_1;
1400062b8              
1400062bb              if ((rax_4 * rdi_1) >> 0x40 == {0})
1400062bb              {
1400062cd                  if (rax_5 <= -0x8000000000000000 - arg4)
1400062cd                  {
1400062d2                      int64_t var_28;
1400062d2                      int64_t rcx_5;
1400062d2                      
1400062d2                      if (r8)
1400062d2                      {
1400062e0                          var_28 = arg1[1];
1400062e5                          int64_t var_18_1 = r8 * arg5;
1400062ea                          rcx_5 = arg4;
1400062d2                      }
1400062d2                      else
1400062d4                          rcx_5 = 0;
1400062d4                      
1400062ed                      int64_t var_20_1 = rcx_5;
140006305                      int32_t var_40;
140006305                      sub_1400061e0(&var_40, arg4, rax_5, &var_28);
140006305                      
14000630f                      if (var_40 != 1)
14000630f                      {
140006316                          int64_t result;
140006316                          arg1[1] = result;
14000631a                          *(uint64_t*)arg1 = rdi_1;
140006323                          return result;
14000630f                      }
1400062cd                  }
1400062cd                  
140006343                  sub_140006700();
140006343                  /* no return */
1400062bb              }
14000626a          }
140006261      }
140006261      
14000632d      sub_140006700();
14000632d      /* no return */
140006250  }

140006348                          cc                                                                               .

140006349    int64_t sub_140006349(void* arg1)

140006349  {
14000634d      int32_t result = *(uint32_t*)((char*)arg1 + 0x38);
14000634d      
140006353      if (result == 3)
140006359          return result;
140006359      
14000635f      void* var_10 = arg1;
14000636b      void var_19;
14000636b      void* var_8_1 = &var_19;
140006374      void** var_18 = &var_10;
14000637e      char const (** const var_28_1)[0xb] = &data_140007b18;
14000638c      return sub_140006590((char*)arg1 + 0x38, 1, &var_18, &data_140007b80);
140006349  }


140006393    int64_t sub_140006393(void* arg1, int64_t arg2)

140006393  {
140006397      int32_t result = *(uint32_t*)((char*)arg1 + 0x38);
140006397      
14000639d      if (result == 3)
1400063a3          return result;
1400063a3      
1400063a9      int64_t var_18 = arg2;
1400063ac      void* var_10_1 = arg1;
1400063b9      void var_21;
1400063b9      void* var_8_1 = &var_21;
1400063c2      int64_t* var_20 = &var_18;
1400063cc      char const (** const var_38_1)[0xb] = &data_140007b18;
1400063da      return sub_140006590((char*)arg1 + 0x38, 1, &var_20, &data_140007b58);
140006393  }


1400063e1    int64_t sub_1400063e1(void* arg1)

1400063e1  {
1400063e5      int32_t result = *(uint32_t*)((char*)arg1 + 0x38);
1400063e5      
1400063eb      if (result == 3)
1400063f1          return result;
1400063f1      
1400063f7      void* var_10 = arg1;
140006403      void var_19;
140006403      void* var_8_1 = &var_19;
14000640c      void** var_18 = &var_10;
140006416      char const (** const var_28_1)[0xb] = &data_140007b18;
140006424      return sub_140006590((char*)arg1 + 0x38, 1, &var_18, &data_140007b30);
1400063e1  }

14000642b                                   cc cc cc cc cc                                                             .....

140006430    int64_t sub_140006430(char* arg1)

140006430  {
140006439      char* Address = arg1;
14000643c      char result = *(uint8_t*)arg1;
14000643c      
140006441      if (result == 1)
140006441      {
140006443          arg1 = 0xffffff9d;
140006460          bool cond:0_1;
140006460          
140006460          do
140006460          {
140006452              result = *(uint8_t*)Address;
140006452              
140006457              if (result != 1)
140006457                  break;
140006457              
14000645c              cond:0_1 = (uint32_t)arg1;
14000645e              arg1 = (uint64_t)(uint32_t)&arg1[1];
140006460          } while (cond:0_1);
140006441      }
140006441      
140006464      if (result)
140006464      {
140006492      label_140006492:
140006492          
140006492          while (true)
140006492          {
140006492              if (result != 2)
140006492              {
140006496                  char result_1 = *(uint8_t*)Address;
140006496                  *(uint8_t*)Address = 2;
140006496                  result = result_1;
140006496                  
14000649a                  if (!result)
14000649a                      break;
140006492              }
140006492              
14000649c              char CompareAddress = 2;
14000649c              
1400064b8              if (WaitOnAddress(Address, &CompareAddress, 1, 0xffffffff) != 1)
1400064ba                  GetLastError();
1400064ba              
1400064bd              result = *(uint8_t*)Address;
1400064bd              
1400064c2              if (result == 1)
1400064c2              {
1400064c4                  int32_t rcx_1 = -0x63;
1400064e0                  bool cond:1_1;
1400064e0                  
1400064e0                  do
1400064e0                  {
1400064d2                      result = *(uint8_t*)Address;
1400064d2                      
1400064da                      if (result != 1)
1400064da                          break;
1400064da                      
1400064dc                      cond:1_1 = rcx_1;
1400064de                      rcx_1 += 1;
1400064e0                  } while (cond:1_1);
1400064c2              }
140006492          }
140006464      }
140006464      else
140006464      {
140006468          result = 0;
14000646a          bool z_1;
14000646a          
14000646a          if (0 == *(uint8_t*)Address)
14000646a          {
14000646a              *(uint8_t*)Address = 1;
14000646a              z_1 = true;
14000646a          }
14000646a          else
14000646a          {
14000646a              result = *(uint8_t*)Address;
14000646a              z_1 = false;
14000646a          }
14000646a          
14000646e          if (!z_1)
14000646e              goto label_140006492;
140006464      }
140006464      
140006479      return result;
140006430  }

1400064e4              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

1400064f0    char const (**)[0x22] sub_1400064f0(int64_t* arg1, char* arg2, void* arg3)

1400064f0  {
1400064fd      int64_t rax = *(uint64_t*)arg1;
1400064fd      
14000650a      if (arg3 <= rax - arg1[2])
14000650a          goto label_140006522;
14000650a      
140006512      char const (** result)[0x22] = sub_140002a70(arg1);
140006512      
14000651a      if (!result)
14000651a      {
14000651c          rax = *(uint64_t*)arg1;
140006522      label_140006522:
140006522          
140006525          if (arg3 < rax)
140006525          {
140006527              void* rbx_2 = arg1[2];
140006535              memcpy(arg1[1] + rbx_2, arg2, (uint32_t)arg3);
14000653d              arg1[2] = (char*)rbx_2 + arg3;
140006541              return nullptr;
140006525          }
140006525          
140006545          arg1[3] = 1;
140006550          char const (** result_1)[0x22] = sub_1400035b0((char*)arg1 + 0x19, arg2, arg3);
140006565          result = nullptr;
140006565          
140006574          if ((-0xfffffffd & result_1) != 0x600000002)
140006574              result = result_1;
140006574          
140006578          arg1[3] = 0;
14000651a      }
14000651a      
140006583      return result;
1400064f0  }

140006584              cc cc cc cc cc cc cc cc cc cc cc cc                                                      ............

140006590    uint64_t sub_140006590(int32_t* arg1, char arg2, int64_t arg3, int64_t arg4)

140006590  {
1400065a8      uint64_t result = (uint64_t)*(uint32_t*)arg1;
1400065ac      int32_t CompareAddress;
1400065ac      
1400065ac      if (!arg2)
1400065ac      {
140006662          while (true)
140006662          {
140006662          label_140006662:
140006662              int32_t rdx_6 = (uint32_t)result & 4;
14000666c              int32_t rcx_3 = (uint32_t)result;
14000666c              
14000666e              switch ((uint64_t)(uint32_t)result & 3)
14000666e              {
140006653                  case 0:
140006653                  {
140006653                  label_140006653:
140006653                      result = (uint64_t)rcx_3;
140006655                      bool z_3;
140006655                      
140006655                      if ((uint32_t)result == *(uint32_t*)arg1)
140006655                      {
140006655                          *(uint32_t*)arg1 = rdx_6 | 2;
140006655                          z_3 = true;
140006655                      }
140006655                      else
140006655                      {
140006655                          result = (uint64_t)*(uint32_t*)arg1;
140006655                          z_3 = false;
140006655                      }
140006655                      
140006659                      if (z_3)
140006659                          break;
140006659                      
140006659                      continue;
140006653                  }
1400066b9                  case 1:
1400066b9                  {
1400066b9                  label_1400066b9:
1400066b9                      trap(6);
1400066b9                      break;
1400066b9                  }
140006673                  case 2:
140006673                  {
140006673                      while (true)
140006673                      {
140006673                          if (!rdx_6)
140006673                          {
140006675                              rcx_3 |= 4;
140006678                              result = 2;
14000667d                              bool z_4;
14000667d                              
14000667d                              if (2 == *(uint32_t*)arg1)
14000667d                              {
14000667d                                  *(uint32_t*)arg1 = rcx_3;
14000667d                                  z_4 = true;
14000667d                              }
14000667d                              else
14000667d                              {
14000667d                                  result = (uint64_t)*(uint32_t*)arg1;
14000667d                                  z_4 = false;
14000667d                              }
14000667d                              
140006681                              if (!z_4)
140006681                                  goto label_140006662;
140006673                          }
140006673                          
140006683                          CompareAddress = rcx_3;
140006683                          
14000669f                          if (WaitOnAddress(arg1, &CompareAddress, 4, 0xffffffff) != 1)
1400066a1                              GetLastError();
1400066a1                          
1400066a4                          rcx_3 = *(uint32_t*)arg1;
1400066ad                          rdx_6 = rcx_3 & 4;
1400066b4                          result = (int64_t)jump_table_140007f54[(uint64_t)rcx_3 & 3] +
1400066b4                              &jump_table_140007f54;
1400066b4                          
1400066b7                          switch (result)
1400066b7                          {
1400066b7                              case 0x140006650:
1400066b7                              {
1400066b7                                  break;
1400066b7                                  break;
1400066b7                              }
1400066b7                              case 0x140006671:
1400066b7                              {
1400066b7                                  continue;
1400066b7                              }
1400066b7                              case 0x1400066b9:
1400066b7                              {
1400066b7                                  goto label_1400066b9;
1400066b7                              }
1400066ff                              case 0x1400066ef:
1400066ff                              {
1400066ff                                  return result;
1400066ff                                  break;
1400066ff                              }
1400066b7                          }
140006673                      }
140006673                      
14000669f                      goto label_140006653;
140006673                  }
1400066ff                  case 3:
1400066ff                  {
1400066ff                      return result;
1400066ff                      break;
1400066ff                  }
14000666e              }
140006662          }
140006662          
1400066c3          result = 0;
1400065ac      }
1400065ac      else
1400065ac      {
1400065df          int32_t rcx_1;
1400065df          
1400065df          while (true)
1400065df          {
1400065df              rcx_1 = (uint32_t)result & 3;
1400065e4              int32_t rdx_2 = (uint32_t)result & 4;
1400065e4              
1400065ea              if (rcx_1 < 2)
1400065ea              {
1400065d3                  bool z_1;
1400065d3                  
1400065d3                  if ((uint32_t)result == *(uint32_t*)arg1)
1400065d3                  {
1400065d3                      *(uint32_t*)arg1 = rdx_2 | 2;
1400065d3                      z_1 = true;
1400065d3                  }
1400065d3                  else
1400065d3                  {
1400065d3                      result = (uint64_t)*(uint32_t*)arg1;
1400065d3                      z_1 = false;
1400065d3                  }
1400065d3                  
1400065d7                  if (z_1)
1400065d7                      break;
1400065ea              }
1400065ea              else
1400065ea              {
1400065ec                  if (rcx_1 != 2)
1400066ff                      return result;
1400066ff                  
1400065f2                  int32_t CompareAddress_1 = (uint32_t)result;
1400065f2                  
1400065f6                  if (!rdx_2)
1400065f6                  {
1400065f8                      CompareAddress_1 |= 4;
1400065fb                      result = 2;
140006600                      bool z_2;
140006600                      
140006600                      if (2 == *(uint32_t*)arg1)
140006600                      {
140006600                          *(uint32_t*)arg1 = CompareAddress_1;
140006600                          z_2 = true;
140006600                      }
140006600                      else
140006600                      {
140006600                          result = (uint64_t)*(uint32_t*)arg1;
140006600                          z_2 = false;
140006600                      }
140006600                      
140006604                      if (!z_2)
140006604                          continue;
1400065f6                  }
1400065f6                  
140006606                  CompareAddress = CompareAddress_1;
140006606                  
140006622                  if (WaitOnAddress(arg1, &CompareAddress, 4, 0xffffffff) != 1)
140006624                      GetLastError();
140006624                  
140006627                  result = (uint64_t)*(uint32_t*)arg1;
1400065ea              }
1400065df          }
1400065df          
1400066be          (uint8_t)result = rcx_1 == 1;
1400065ac      }
1400065ac      
1400066c5      CompareAddress = 3;
1400066cd      char var_3c_1 = (uint8_t)result;
1400066d9      (*(uint64_t*)(arg4 + 0x20))(arg3, &CompareAddress);
1400066e0      int32_t result_1 = *(uint32_t*)arg1;
1400066e0      *(uint32_t*)arg1 = CompareAddress;
1400066e0      result = (uint64_t)result_1;
1400066e0      
1400066e4      if ((uint8_t)result & 4)
1400066e9          return WakeByAddressAll(arg1);
1400066e9      
1400066ff      return result;
140006590  }

1400065c3           66 66 66 66 2e 0f 1f 84 00 00 00 00 00                                                     ffff.........
140006647                       66 0f 1f 84 00 00 00 00 00                                                         f........

140006700    void sub_140006700() __noreturn

140006700  {
140006700      trap(6);
140006700  }


140006702    int64_t thread_start<uint32_t (__cdecl*)(void* __ptr64)>::filt$0::filt$0(int64_t* arg1)

140006702  {
14000671e      return _seh_filter_exe(**(uint32_t**)arg1, arg1);
140006702  }

14000671f                                                                                               cc                                 .

140006720    uint64_t __scrt_is_nonwritable_in_current_image$filt$0(int64_t* arg1)

140006720  {
140006730      int32_t rcx;
140006730      (uint8_t)rcx = **(uint32_t**)arg1 == 0xc0000005;
140006736      return (uint64_t)rcx;
140006720  }

140006737                                                                       cc                                                 .
.text section ended  {0x140001000-0x140006738}

.rdata section started  {0x140007000-0x140009456}
140007000  LPTOP_LEVEL_EXCEPTION_FILTER (* const KERNEL32:SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter) = SetUnhandledExceptionFilter
140007008  int32_t (* const KERNEL32:UnhandledExceptionFilter)(EXCEPTION_POINTERS* ExceptionInfo) = UnhandledExceptionFilter
140007010  BOOL (* const KERNEL32:IsDebuggerPresent)() = IsDebuggerPresent
140007018  void (* const KERNEL32:InitializeSListHead)(SLIST_HEADER* ListHead) = InitializeSListHead
140007020  enum WAIT_EVENT (* const KERNEL32:WaitForSingleObject)(HANDLE hHandle, uint32_t dwMilliseconds) = WaitForSingleObject
140007028  enum WIN32_ERROR (* const KERNEL32:GetLastError)() = GetLastError
140007030  HANDLE (* const KERNEL32:GetStdHandle)(enum STD_HANDLE nStdHandle) = GetStdHandle
140007038  BOOL (* const KERNEL32:SetThreadStackGuarantee)(uint32_t* StackSizeInBytes) = SetThreadStackGuarantee
140007040  void* (* const KERNEL32:AddVectoredExceptionHandler)(uint32_t First, PVECTORED_EXCEPTION_HANDLER Handler) = AddVectoredExceptionHandler
140007048  HANDLE (* const KERNEL32:GetCurrentThread)() = GetCurrentThread
140007050  HANDLE (* const KERNEL32:GetProcessHeap)() = GetProcessHeap
140007058  BOOL (* const KERNEL32:HeapFree)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem) = HeapFree
140007060  void (* const KERNEL32:RtlCaptureContext)(CONTEXT* ContextRecord) = RtlCaptureContext
140007068  IMAGE_RUNTIME_FUNCTION_ENTRY* (* const KERNEL32:RtlLookupFunctionEntry)(uint64_t ControlPc, uint64_t* ImageBase, UNWIND_HISTORY_TABLE* HistoryTable) = RtlLookupFunctionEntry
140007070  EXCEPTION_ROUTINE (* const KERNEL32:RtlVirtualUnwind)(enum RTL_VIRTUAL_UNWIND_HANDLER_TYPE HandlerType, uint64_t ImageBase, uint64_t ControlPc, IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionEntry, CONTEXT* ContextRecord, void** HandlerData, uint64_t* EstablisherFrame, KNONVOLATILE_CONTEXT_POINTERS* ContextPointers) = RtlVirtualUnwind
140007078  void* (* const KERNEL32:HeapReAlloc)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem, uint64_t dwBytes) = HeapReAlloc
140007080  BOOL (* const KERNEL32:QueryPerformanceCounter)(int64_t* lpPerformanceCount) = QueryPerformanceCounter
140007088  uint32_t (* const KERNEL32:GetCurrentProcessId)() = GetCurrentProcessId
140007090  HMODULE (* const KERNEL32:GetModuleHandleW)(PWSTR lpModuleName) = GetModuleHandleW
140007098  BOOL (* const KERNEL32:GetConsoleMode)(HANDLE hConsoleHandle, enum CONSOLE_MODE* lpMode) = GetConsoleMode
1400070a0  FARPROC (* const KERNEL32:GetProcAddress)(HMODULE hModule, PSTR lpProcName) = GetProcAddress
1400070a8  void* (* const KERNEL32:HeapAlloc)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, uint64_t dwBytes) = HeapAlloc
1400070b0  HMODULE (* const KERNEL32:GetModuleHandleA)(PSTR lpModuleName) = GetModuleHandleA
1400070b8  void (* const KERNEL32:SetLastError)(enum WIN32_ERROR dwErrCode) = SetLastError
1400070c0  uint32_t (* const KERNEL32:GetConsoleOutputCP)() = GetConsoleOutputCP
1400070c8  int32_t (* const KERNEL32:MultiByteToWideChar)(uint32_t CodePage, enum MULTI_BYTE_TO_WIDE_CHAR_FLAGS dwFlags, uint8_t* lpMultiByteStr, int32_t cbMultiByte, wchar16* lpWideCharStr, int32_t cchWideChar) = MultiByteToWideChar
1400070d0  BOOL (* const KERNEL32:WriteConsoleW)(HANDLE hConsoleOutput, void* lpBuffer, uint32_t nNumberOfCharsToWrite, uint32_t* lpNumberOfCharsWritten, void* lpReserved) = WriteConsoleW
1400070d8  int32_t (* const KERNEL32:WideCharToMultiByte)(uint32_t CodePage, uint32_t dwFlags, wchar16* lpWideCharStr, int32_t cchWideChar, PSTR lpMultiByteStr, int32_t cbMultiByte, PSTR lpDefaultChar, BOOL* lpUsedDefaultChar) = WideCharToMultiByte
1400070e0  BOOL (* const KERNEL32:ReadConsoleW)(HANDLE hConsoleInput, void* lpBuffer, uint32_t nNumberOfCharsToRead, uint32_t* lpNumberOfCharsRead, CONSOLE_READCONSOLE_CONTROL* pInputControl) = ReadConsoleW
1400070e8  BOOL (* const KERNEL32:IsProcessorFeaturePresent)(enum PROCESSOR_FEATURE_ID ProcessorFeature) = IsProcessorFeaturePresent
1400070f0  void (* const KERNEL32:GetSystemTimeAsFileTime)(FILETIME* lpSystemTimeAsFileTime) = GetSystemTimeAsFileTime
1400070f8  uint32_t (* const KERNEL32:GetCurrentThreadId)() = GetCurrentThreadId

140007100  00 00 00 00 00 00 00 00                                                                          ........

140007108  void** (* const VCRUNTIME140:__current_exception)() = __current_exception
140007110  void** (* const VCRUNTIME140:__current_exception_context)() = __current_exception_context
140007118  enum _EXCEPTION_DISPOSITION (* const VCRUNTIME140:__C_specific_handler)(struct _EXCEPTION_RECORD* ExceptionRecord, void* EstablisherFrame, struct _CONTEXT* ContextRecord, struct _DISPATCHER_CONTEXT* DispatcherContext) = __C_specific_handler
140007120  void* (* const VCRUNTIME140:memmove)(void* dest, void const* src, uint32_t count) = memmove
140007128  void* (* const VCRUNTIME140:memset)(void* dest, int32_t c, uint64_t count) = memset
140007130  int32_t (* const VCRUNTIME140:memcmp)(void const* buffer1, void const* buffer2, uint64_t count) = memcmp
140007138  void* (* const VCRUNTIME140:memcpy)(void* dest, void const* src, uint32_t count) = memcpy

140007140  00 00 00 00 00 00 00 00                                                                          ........

140007148  BOOL (* const api-ms-win-core-synch-l1-2-0:WaitOnAddress)(void* Address, void* CompareAddress, uint64_t AddressSize, uint32_t dwMilliseconds) = WaitOnAddress
140007150  void (* const api-ms-win-core-synch-l1-2-0:WakeByAddressAll)(void* Address) = WakeByAddressAll
140007158  void (* const api-ms-win-core-synch-l1-2-0:WakeByAddressSingle)(void* Address) = WakeByAddressSingle

140007160  00 00 00 00 00 00 00 00                                                                          ........

140007168  int32_t (* const api-ms-win-crt-heap-l1-1-0:_set_new_mode)(int32_t _NewMode) = _set_new_mode

140007170                                                  00 00 00 00 00 00 00 00                                          ........

140007178  int32_t (* const api-ms-win-crt-locale-l1-1-0:_configthreadlocale)(int32_t _Flag) = _configthreadlocale

140007180  00 00 00 00 00 00 00 00                                                                          ........

140007188  void (* const api-ms-win-crt-math-l1-1-0:__setusermatherr)(_UserMathErrorFunctionPointer _UserMathErrorFunction) = __setusermatherr

140007190                                                  00 00 00 00 00 00 00 00                                          ........

140007198  void (* const api-ms-win-crt-runtime-l1-1-0:_initterm)(_PVFV* _First, _PVFV* _Last) = _initterm
1400071a0  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_initterm_e)(_PIFV* _First, _PIFV* _Last) = _initterm_e
1400071a8  void (* const api-ms-win-crt-runtime-l1-1-0:exit)(int32_t _Except) __noreturn = exit
1400071b0  void (* const api-ms-win-crt-runtime-l1-1-0:_exit)(int32_t _Except) __noreturn = _exit
1400071b8  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_initialize_narrow_environment)() = _initialize_narrow_environment
1400071c0  int32_t* (* const api-ms-win-crt-runtime-l1-1-0:__p___argc)() = __p___argc
1400071c8  char*** (* const api-ms-win-crt-runtime-l1-1-0:__p___argv)() = __p___argv
1400071d0  void (* const api-ms-win-crt-runtime-l1-1-0:_set_app_type)(enum _crt_app_type _Type) = _set_app_type
1400071d8  void (* const api-ms-win-crt-runtime-l1-1-0:_c_exit)() = _c_exit
1400071e0  void (* const api-ms-win-crt-runtime-l1-1-0:_register_thread_local_exe_atexit_callback)(_tls_callback_type _Callback) = _register_thread_local_exe_atexit_callback
1400071e8  errno_t (* const api-ms-win-crt-runtime-l1-1-0:_configure_narrow_argv)(enum _crt_argv_mode mode) = _configure_narrow_argv
1400071f0  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_seh_filter_exe)(uint32_t _ExceptionNum, struct _EXCEPTION_POINTERS* _ExceptionPtr) = _seh_filter_exe
1400071f8  char** (* const api-ms-win-crt-runtime-l1-1-0:_get_initial_narrow_environment)() = _get_initial_narrow_environment
140007200  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_initialize_onexit_table)(struct _onexit_table_t* _Table) = _initialize_onexit_table
140007208  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_register_onexit_function)(struct _onexit_table_t* _Table, _onexit_t_1 _Function) = _register_onexit_function
140007210  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_crt_atexit)(_PVFV _Function) = _crt_atexit
140007218  void (* const api-ms-win-crt-runtime-l1-1-0:terminate)() __noreturn = terminate
140007220  void (* const api-ms-win-crt-runtime-l1-1-0:_cexit)() = _cexit

140007228                          00 00 00 00 00 00 00 00                                                          ........

140007230  errno_t (* const api-ms-win-crt-stdio-l1-1-0:_set_fmode)(int32_t _Value) = _set_fmode
140007238  int32_t* (* const api-ms-win-crt-stdio-l1-1-0:__p__commode)() = __p__commode

140007240  00 00 00 00 00 00 00 00                                                                          ........

140007248  uint32_t (* const ntdll:RtlNtStatusToDosError)(NTSTATUS Status) = RtlNtStatusToDosError
140007250  NTSTATUS (* const ntdll:NtReadFile)(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, void* ApcContext, struct IO_STATUS_BLOCK* IoStatusBlock, void* Buffer, uint32_t Length, int64_t* ByteOffset, uint32_t* Key) = NtReadFile
140007258  NTSTATUS (* const ntdll:NtWriteFile)(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, void* ApcContext, struct IO_STATUS_BLOCK* IoStatusBlock, void* Buffer, uint32_t Length, int64_t* ByteOffset, uint32_t* Key) = NtWriteFile

140007260  00 00 00 00 00 00 00 00                                                                          ........

140007268  void (* __guard_check_icall_fptr)(void (*)()) = _guard_check_icall
140007270  void* data_140007270 = _guard_check_icall
140007278  void (* __guard_dispatch_icall_fptr)(void (*)()) = _guard_dispatch_icall_nop
140007280  void* data_140007280 = sub_140005fe0
140007288  void* data_140007288 = sub_140005fe0

140007290                                                  00 00 00 00 00 00 00 00                                          ........

140007298  void* data_140007298 = VCRUNTIME140:memcpy

1400072a0  data_1400072a0:
1400072a0  00 00 00 00 00 00 00 00                                                                          ........

1400072a8  void* data_1400072a8 = pre_cpp_initialization()
1400072b0  void* data_1400072b0 = 0x140001740

1400072b8  data_1400072b8:
1400072b8                                                                          00 00 00 00 00 00 00 00                          ........
1400072c0  data_1400072c0:
1400072c0  00 00 00 00 00 00 00 00                                                                          ........

1400072c8  void* data_1400072c8 = pre_c_initialization()
1400072d0  void* data_1400072d0 = post_pgo_initialization()

1400072d8  data_1400072d8:
1400072d8                                                                          00 00 00 00 00 00 00 00                          ........
1400072e0  00 00 00 00 00 00 00 00                                                                          ........

1400072e8  void* data_1400072e8 = _TLS_Entry_0

1400072f0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140007300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140007320  51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 00 00 00 00 00 00 00 00 00 00 00 00  QQQQQQQQQQQQQQQQQQQQ............
140007340  data_140007340:
140007340  00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00                          ........................

140007358  void* data_140007358 = sub_140001000
140007360  void* data_140007360 = sub_140001000
140007368  void* data_140007368 = sub_140001000
140007370  char const data_140007370[0xb] = "<redacted>", 0

14000737b                                                                                   00 00 00 00 00                             .....

140007380  char const (* data_140007380)[0xb] = data_140007370 {"<redacted>"}

140007388                          0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                  ................

140007398  void* data_140007398 = sub_140001040

1400073a0  18 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00                                                  ................

1400073b0  void* data_1400073b0 = sub_140001190
1400073b8  void* data_1400073b8 = sub_140001060
1400073c0  void* data_1400073c0 = sub_140001030

1400073c8  data_1400073c8:
1400073c8                          d8 d6 63 47 ca de 64 00 99 76 7c b8 40 6e 5c 21 bb                               ..cG..d..v|.@n\!.
1400073d9  data_1400073d9:
1400073d9                                                                             8f be 02 33 ea b7 17                           ...3...
1400073e0  20 ed 1e 19 98 26 02 3d 46 84 0a 00 00 00 00 00                                                   ....&.=F.......
1400073f0  data_1400073f0:
1400073f0                                                  01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................

140007400  void* data_140007400 = 0x1400073ea

140007408                          01 00 00 00 00 00 00 00                                                          ........
140007410  data_140007410:
140007410                                                  67 87 3a 9a 18 fc ec 12 85 ab 25 dd 1b 34 95 13                  g.:.......%..4..
140007420  78 32 92 1f 9b b5 53 bc 42 80                                                                    x2....S.B.
14000742a  data_14000742a:
14000742a                                32 f4 5f e8 38 95 82 62 f0 df 05 b4 68 14 fb 7c 0c 12 f3 3f e8 c1            2._.8..b....h..|...?..
140007440  21 d5 2c e7                                                                                      !.,.
140007444  data_140007444:
140007444              34 71 b9 fe 59 df 4e e8 46 c1 72 26 30 d2 e8 7f 62 b4 ea 0a b2                           4q..Y.N.F.r&0...b....
140007459  data_140007459:
140007459                                                                             77 1e cb 8c 3c bc 3a                           w...<.:
140007460  c9 66 95 1a 43 10 b4 84 1e 05 94 83 79 88 20 00                                                  .f..C.......y. .
140007470  data_140007470:
140007470                                                  01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................

140007480  void* data_140007480 = 0x14000746e

140007488                          01 00 00 00 00 00 00 00                                                          ........

140007490  void* data_140007490 = 0x1400073ea

140007498                                                                          01 00 00 00 00 00 00 00                          ........
1400074a0  data_1400074a0:
1400074a0  70 29 38 89 e1 99 b6 a3 57 ee b8 48 f9 b8 e7 b4 88 b7 58 3e c9 5a 16 77 c8 a4 7c                 p)8.....W..H......X>.Z.w..|
1400074bb  data_1400074bb:
1400074bb                                                                                   39 47 5b e6 93                             9G[..
1400074c0  eb d3 c0 23 cf 98 1c 91 dd c7 d2 e4 d6 3f 1e a0 29 36 19 a7 d0 46 00 00                          ...#.........?..)6...F..
1400074d8  data_1400074d8:
1400074d8                                                                          01 00 00 00 00 00 00 00                          ........
1400074e0  00 00 00 00 00 00 00 00                                                                          ........

1400074e8  char const data_1400074e8[0xb] = "<redacted>", 0

1400074f3                                                           00 00 00 00 00                                             .....

1400074f8  char const (* data_1400074f8)[0xb] = data_1400074e8 {"<redacted>"}

140007500  0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

140007510  char const data_140007510[0xb] = "<redacted>", 0

14000751b                                                                                   00 00 00 00 00                             .....

140007520  char const (* data_140007520)[0xb] = data_140007510 {"<redacted>"}

140007528                          0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                  ................

140007538  char const data_140007538[0xb] = "<redacted>", 0

140007543           00 00 00 00 00                                                                             .....

140007548  char const (* data_140007548)[0xb] = data_140007538 {"<redacted>"}

140007550                                                  0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140007560  data_140007560:
140007560  00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00                          ........................

140007578  void* data_140007578 = sub_140002210
140007580  void* data_140007580 = sub_140002350
140007588  char const data_140007588[0xb] = "<redacted>", 0

140007593                                                           00 00 00 00 00                                             .....

140007598  char const (* data_140007598)[0xb] = data_140007588 {"<redacted>"}

1400075a0  0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

1400075b0  int128_t data_1400075b0 = 
1400075b0                                                  03 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
1400075c0  uint32_t jump_table_1400075c0[0x4] = 
1400075c0  {
1400075c0      [0x0] =  0xffffaf25
1400075c4      [0x1] =  0xffffaf6d
1400075c8      [0x2] =  0xffffaf2a
1400075cc      [0x3] =  0xffffaf66
1400075d0  }
1400075d0  uint32_t jump_table_1400075d0[0x10a] = 
1400075d0  {
1400075d0      [0x000] =  0xffffaf53
1400075d4      [0x001] =  0xffffaf53
1400075d8      [0x002] =  0xffffb07f
1400075dc      [0x003] =  0xffffaf61
1400075e0      [0x004] =  0xffffb07f
1400075e4      [0x005] =  0xffffb07f
1400075e8      [0x006] =  0xffffb0b3
1400075ec      [0x007] =  0xffffb07f
1400075f0      [0x008] =  0xffffb07f
1400075f4      [0x009] =  0xffffb07f
1400075f8      [0x00a] =  0xffffb07f
1400075fc      [0x00b] =  0xffffb07f
140007600      [0x00c] =  0xffffb0b3
140007604      [0x00d] =  0xffffaf53
140007608      [0x00e] =  0xffffb07f
14000760c      [0x00f] =  0xffffb0dd
140007610      [0x010] =  0xffffb07f
140007614      [0x011] =  0xffffb0e0
140007618      [0x012] =  0xffffb07f
14000761c      [0x013] =  0xffffb07f
140007620      [0x014] =  0xffffb07f
140007624      [0x015] =  0xffffb07f
140007628      [0x016] =  0xffffb07f
14000762c      [0x017] =  0xffffb07f
140007630      [0x018] =  0xffffb07f
140007634      [0x019] =  0xffffb07f
140007638      [0x01a] =  0xffffb07f
14000763c      [0x01b] =  0xffffb07f
140007640      [0x01c] =  0xffffb07f
140007644      [0x01d] =  0xffffb07f
140007648      [0x01e] =  0xffffb07f
14000764c      [0x01f] =  0xffffb07f
140007650      [0x020] =  0xffffb07f
140007654      [0x021] =  0xffffb07f
140007658      [0x022] =  0xffffb07f
14000765c      [0x023] =  0xffffb07f
140007660      [0x024] =  0xffffb07f
140007664      [0x025] =  0xffffb0b6
140007668      [0x026] =  0xffffb07f
14000766c      [0x027] =  0xffffb07f
140007670      [0x028] =  0xffffb07f
140007674      [0x029] =  0xffffb07f
140007678      [0x02a] =  0xffffb07f
14000767c      [0x02b] =  0xffffb07f
140007680      [0x02c] =  0xffffb07f
140007684      [0x02d] =  0xffffb07f
140007688      [0x02e] =  0xffffb07f
14000768c      [0x02f] =  0xffffb07f
140007690      [0x030] =  0xffffb07f
140007694      [0x031] =  0xffffb07f
140007698      [0x032] =  0xffffb07f
14000769c      [0x033] =  0xffffaf53
1400076a0      [0x034] =  0xffffb07f
1400076a4      [0x035] =  0xffffb07f
1400076a8      [0x036] =  0xffffb07f
1400076ac      [0x037] =  0xffffb07f
1400076b0      [0x038] =  0xffffb07f
1400076b4      [0x039] =  0xffffb07f
1400076b8      [0x03a] =  0xffffb07f
1400076bc      [0x03b] =  0xffffb07f
1400076c0      [0x03c] =  0xffffb07f
1400076c4      [0x03d] =  0xffffb07f
1400076c8      [0x03e] =  0xffffb07f
1400076cc      [0x03f] =  0xffffb07f
1400076d0      [0x040] =  0xffffb07f
1400076d4      [0x041] =  0xffffaf53
1400076d8      [0x042] =  0xffffb07f
1400076dc      [0x043] =  0xffffb07f
1400076e0      [0x044] =  0xffffb07f
1400076e4      [0x045] =  0xffffb07f
1400076e8      [0x046] =  0xffffb07f
1400076ec      [0x047] =  0xffffb07f
1400076f0      [0x048] =  0xffffb07f
1400076f4      [0x049] =  0xffffb07f
1400076f8      [0x04a] =  0xffffb07f
1400076fc      [0x04b] =  0xffffb07f
140007700      [0x04c] =  0xffffb07f
140007704      [0x04d] =  0xffffb07f
140007708      [0x04e] =  0xffffb0b0
14000770c      [0x04f] =  0xffffb07f
140007710      [0x050] =  0xffffb07f
140007714      [0x051] =  0xffffb07f
140007718      [0x052] =  0xffffb07f
14000771c      [0x053] =  0xffffb07f
140007720      [0x054] =  0xffffb07f
140007724      [0x055] =  0xffffaf89
140007728      [0x056] =  0xffffb07f
14000772c      [0x057] =  0xffffb07f
140007730      [0x058] =  0xffffb07f
140007734      [0x059] =  0xffffb07f
140007738      [0x05a] =  0xffffb07f
14000773c      [0x05b] =  0xffffb07f
140007740      [0x05c] =  0xffffb07f
140007744      [0x05d] =  0xffffb07f
140007748      [0x05e] =  0xffffb07f
14000774c      [0x05f] =  0xffffb07f
140007750      [0x060] =  0xffffb07f
140007754      [0x061] =  0xffffb07f
140007758      [0x062] =  0xffffb07f
14000775c      [0x063] =  0xffffb07f
140007760      [0x064] =  0xffffb07f
140007764      [0x065] =  0xffffb07f
140007768      [0x066] =  0xffffb07f
14000776c      [0x067] =  0xffffb07f
140007770      [0x068] =  0xffffb07f
140007774      [0x069] =  0xffffb07f
140007778      [0x06a] =  0xffffb07f
14000777c      [0x06b] =  0xffffb0ad
140007780      [0x06c] =  0xffffb07f
140007784      [0x06d] =  0xffffb07f
140007788      [0x06e] =  0xffffb0b6
14000778c      [0x06f] =  0xffffb07f
140007790      [0x070] =  0xffffb07f
140007794      [0x071] =  0xffffb07f
140007798      [0x072] =  0xffffb07f
14000779c      [0x073] =  0xffffb07f
1400077a0      [0x074] =  0xffffb07f
1400077a4      [0x075] =  0xffffb07f
1400077a8      [0x076] =  0xffffb0e6
1400077ac      [0x077] =  0xffffb0a4
1400077b0      [0x078] =  0xffffb07f
1400077b4      [0x079] =  0xffffb06c
1400077b8      [0x07a] =  0xffffb07f
1400077bc      [0x07b] =  0xffffb07f
1400077c0      [0x07c] =  0xffffb07f
1400077c4      [0x07d] =  0xffffb07f
1400077c8      [0x07e] =  0xffffb07f
1400077cc      [0x07f] =  0xffffb07f
1400077d0      [0x080] =  0xffffb07f
1400077d4      [0x081] =  0xffffb07f
1400077d8      [0x082] =  0xffffb0d4
1400077dc      [0x083] =  0xffffb07f
1400077e0      [0x084] =  0xffffb07f
1400077e4      [0x085] =  0xffffb07f
1400077e8      [0x086] =  0xffffb07f
1400077ec      [0x087] =  0xffffb07f
1400077f0      [0x088] =  0xffffb07f
1400077f4      [0x089] =  0xffffb07f
1400077f8      [0x08a] =  0xffffb07f
1400077fc      [0x08b] =  0xffffb07f
140007800      [0x08c] =  0xffffb07f
140007804      [0x08d] =  0xffffb07f
140007808      [0x08e] =  0xffffb07f
14000780c      [0x08f] =  0xffffb0da
140007810      [0x090] =  0xffffb07f
140007814      [0x091] =  0xffffb07f
140007818      [0x092] =  0xffffb07f
14000781c      [0x093] =  0xffffb07f
140007820      [0x094] =  0xffffb07f
140007824      [0x095] =  0xffffb07f
140007828      [0x096] =  0xffffb07f
14000782c      [0x097] =  0xffffb07f
140007830      [0x098] =  0xffffb07f
140007834      [0x099] =  0xffffb07f
140007838      [0x09a] =  0xffffb07f
14000783c      [0x09b] =  0xffffb07f
140007840      [0x09c] =  0xffffb07f
140007844      [0x09d] =  0xffffb07f
140007848      [0x09e] =  0xffffb07f
14000784c      [0x09f] =  0xffffb06c
140007850      [0x0a0] =  0xffffb07f
140007854      [0x0a1] =  0xffffb07f
140007858      [0x0a2] =  0xffffb07f
14000785c      [0x0a3] =  0xffffb07f
140007860      [0x0a4] =  0xffffb07f
140007864      [0x0a5] =  0xffffb07f
140007868      [0x0a6] =  0xffffb07f
14000786c      [0x0a7] =  0xffffb07f
140007870      [0x0a8] =  0xffffb0d1
140007874      [0x0a9] =  0xffffb07f
140007878      [0x0aa] =  0xffffb07f
14000787c      [0x0ab] =  0xffffb07f
140007880      [0x0ac] =  0xffffb07f
140007884      [0x0ad] =  0xffffb07f
140007888      [0x0ae] =  0xffffb07f
14000788c      [0x0af] =  0xffffb07f
140007890      [0x0b0] =  0xffffb07f
140007894      [0x0b1] =  0xffffb07f
140007898      [0x0b2] =  0xffffb07f
14000789c      [0x0b3] =  0xffffb07f
1400078a0      [0x0b4] =  0xffffb07f
1400078a4      [0x0b5] =  0xffffb0b0
1400078a8      [0x0b6] =  0xffffb07f
1400078ac      [0x0b7] =  0xffffb07f
1400078b0      [0x0b8] =  0xffffb07f
1400078b4      [0x0b9] =  0xffffb07f
1400078b8      [0x0ba] =  0xffffb07f
1400078bc      [0x0bb] =  0xffffb07f
1400078c0      [0x0bc] =  0xffffb07f
1400078c4      [0x0bd] =  0xffffb07f
1400078c8      [0x0be] =  0xffffb07f
1400078cc      [0x0bf] =  0xffffb07f
1400078d0      [0x0c0] =  0xffffb07f
1400078d4      [0x0c1] =  0xffffb07f
1400078d8      [0x0c2] =  0xffffb07f
1400078dc      [0x0c3] =  0xffffb07f
1400078e0      [0x0c4] =  0xffffb07f
1400078e4      [0x0c5] =  0xffffb07f
1400078e8      [0x0c6] =  0xffffb07f
1400078ec      [0x0c7] =  0xffffb07f
1400078f0      [0x0c8] =  0xffffb07f
1400078f4      [0x0c9] =  0xffffb07f
1400078f8      [0x0ca] =  0xffffb07f
1400078fc      [0x0cb] =  0xffffb07f
140007900      [0x0cc] =  0xffffb06c
140007904      [0x0cd] =  0xffffb07f
140007908      [0x0ce] =  0xffffb07f
14000790c      [0x0cf] =  0xffffb07f
140007910      [0x0d0] =  0xffffb07f
140007914      [0x0d1] =  0xffffb07f
140007918      [0x0d2] =  0xffffb07f
14000791c      [0x0d3] =  0xffffb07f
140007920      [0x0d4] =  0xffffb07f
140007924      [0x0d5] =  0xffffb07f
140007928      [0x0d6] =  0xffffb07f
14000792c      [0x0d7] =  0xffffb07f
140007930      [0x0d8] =  0xffffb07f
140007934      [0x0d9] =  0xffffb07f
140007938      [0x0da] =  0xffffb07f
14000793c      [0x0db] =  0xffffb07f
140007940      [0x0dc] =  0xffffb07f
140007944      [0x0dd] =  0xffffb0d7
140007948      [0x0de] =  0xffffb07f
14000794c      [0x0df] =  0xffffb07f
140007950      [0x0e0] =  0xffffb07f
140007954      [0x0e1] =  0xffffb07f
140007958      [0x0e2] =  0xffffb07f
14000795c      [0x0e3] =  0xffffb07f
140007960      [0x0e4] =  0xffffb07f
140007964      [0x0e5] =  0xffffb07f
140007968      [0x0e6] =  0xffffb0ad
14000796c      [0x0e7] =  0xffffb07f
140007970      [0x0e8] =  0xffffb07f
140007974      [0x0e9] =  0xffffb07f
140007978      [0x0ea] =  0xffffb07f
14000797c      [0x0eb] =  0xffffb07f
140007980      [0x0ec] =  0xffffb07f
140007984      [0x0ed] =  0xffffb07f
140007988      [0x0ee] =  0xffffb07f
14000798c      [0x0ef] =  0xffffb07f
140007990      [0x0f0] =  0xffffb07f
140007994      [0x0f1] =  0xffffb07f
140007998      [0x0f2] =  0xffffb07f
14000799c      [0x0f3] =  0xffffb07f
1400079a0      [0x0f4] =  0xffffb07f
1400079a4      [0x0f5] =  0xffffb07f
1400079a8      [0x0f6] =  0xffffb07f
1400079ac      [0x0f7] =  0xffffb07f
1400079b0      [0x0f8] =  0xffffb07f
1400079b4      [0x0f9] =  0xffffb07f
1400079b8      [0x0fa] =  0xffffb07f
1400079bc      [0x0fb] =  0xffffb07f
1400079c0      [0x0fc] =  0xffffb07f
1400079c4      [0x0fd] =  0xffffb07f
1400079c8      [0x0fe] =  0xffffb07f
1400079cc      [0x0ff] =  0xffffb07f
1400079d0      [0x100] =  0xffffb0a4
1400079d4      [0x101] =  0xffffb07f
1400079d8      [0x102] =  0xffffb07f
1400079dc      [0x103] =  0xffffb07f
1400079e0      [0x104] =  0xffffb07f
1400079e4      [0x105] =  0xffffb07f
1400079e8      [0x106] =  0xffffb07f
1400079ec      [0x107] =  0xffffb07f
1400079f0      [0x108] =  0xffffb07f
1400079f4      [0x109] =  0xffffb0e3
1400079f8  }
1400079f8  uint32_t jump_table_1400079f8[0x39] = 
1400079f8  {
1400079f8      [0x00] =  0xffffab39
1400079fc      [0x01] =  0xffffac57
140007a00      [0x02] =  0xffffac57
140007a04      [0x03] =  0xffffac57
140007a08      [0x04] =  0xffffac57
140007a0c      [0x05] =  0xffffac57
140007a10      [0x06] =  0xffffac57
140007a14      [0x07] =  0xffffac57
140007a18      [0x08] =  0xffffac57
140007a1c      [0x09] =  0xffffab61
140007a20      [0x0a] =  0xffffac57
140007a24      [0x0b] =  0xffffac57
140007a28      [0x0c] =  0xffffac57
140007a2c      [0x0d] =  0xffffac57
140007a30      [0x0e] =  0xffffac57
140007a34      [0x0f] =  0xffffac57
140007a38      [0x10] =  0xffffac57
140007a3c      [0x11] =  0xffffac57
140007a40      [0x12] =  0xffffac57
140007a44      [0x13] =  0xffffac57
140007a48      [0x14] =  0xffffac57
140007a4c      [0x15] =  0xffffac57
140007a50      [0x16] =  0xffffaca0
140007a54      [0x17] =  0xffffac57
140007a58      [0x18] =  0xffffac57
140007a5c      [0x19] =  0xffffac57
140007a60      [0x1a] =  0xffffac57
140007a64      [0x1b] =  0xffffac57
140007a68      [0x1c] =  0xffffac57
140007a6c      [0x1d] =  0xffffac57
140007a70      [0x1e] =  0xffffac57
140007a74      [0x1f] =  0xffffac57
140007a78      [0x20] =  0xffffac57
140007a7c      [0x21] =  0xffffac57
140007a80      [0x22] =  0xffffac57
140007a84      [0x23] =  0xffffac97
140007a88      [0x24] =  0xffffac94
140007a8c      [0x25] =  0xffffaca6
140007a90      [0x26] =  0xffffac82
140007a94      [0x27] =  0xffffac57
140007a98      [0x28] =  0xffffac9a
140007a9c      [0x29] =  0xffffaca3
140007aa0      [0x2a] =  0xffffac57
140007aa4      [0x2b] =  0xffffac57
140007aa8      [0x2c] =  0xffffac9d
140007aac      [0x2d] =  0xffffac57
140007ab0      [0x2e] =  0xffffac57
140007ab4      [0x2f] =  0xffffac7c
140007ab8      [0x30] =  0xffffac91
140007abc      [0x31] =  0xffffac57
140007ac0      [0x32] =  0xffffac57
140007ac4      [0x33] =  0xffffac57
140007ac8      [0x34] =  0xffffab9c
140007acc      [0x35] =  0xffffac57
140007ad0      [0x36] =  0xffffac57
140007ad4      [0x37] =  0xffffac57
140007ad8      [0x38] =  0xffffac7f
140007adc  }
140007adc  char const data_140007adc[0xb] = "<redacted>", 0

140007ae7                       00                                                                                 .

140007ae8  char const (* data_140007ae8)[0xb] = data_140007adc {"<redacted>"}

140007af0                                                  0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................

140007b00  char const data_140007b00[0x9] = "kernel32", 0
140007b09  char const data_140007b09[0xb] = "<redacted>", 0

140007b14                                                              00 00 00 00                                              ....

140007b18  char const (* data_140007b18)[0xb] = data_140007b09 {"<redacted>"}

140007b20  0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
140007b30  data_140007b30:
140007b30                                                  00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00                  ................
140007b40  08 00 00 00 00 00 00 00                                                                          ........

140007b48  void* data_140007b48 = sub_1400028d0
140007b50  void* data_140007b50 = sub_1400028d0

140007b58  data_140007b58:
140007b58                                                                          00 00 00 00 00 00 00 00                          ........
140007b60  08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00                                                  ................

140007b70  void* data_140007b70 = 0x140002880
140007b78  void* data_140007b78 = 0x140002880

140007b80  data_140007b80:
140007b80  00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00                          ........................

140007b98  void* data_140007b98 = sub_140002940
140007ba0  void* data_140007ba0 = sub_140002940
140007ba8  char const data_140007ba8[0x22] = "failed to write the buffered data", 0

140007bca                                00 00 00 00 00 00                                                            ......

140007bd0  char const (* data_140007bd0)[0x22] = data_140007ba8 {"failed to write the buffered data"}

140007bd8                                                                          21 00 00 00 00 00 00 00                          !.......
140007be0  17 00 00 00 00 00 00 00                                                                          ........
140007be8  uint32_t jump_table_140007be8[0x4] = 
140007be8  {
140007be8      [0x0] =  0xffffaed0
140007bec      [0x1] =  0xffffaf49
140007bf0      [0x2] =  0xffffb01e
140007bf4      [0x3] =  0xffffafd5
140007bf8  }
140007bf8  char const data_140007bf8[0xb] = "<redacted>", 0

140007c03           00 00 00 00 00                                                                             .....

140007c08  char const (* data_140007c08)[0xb] = data_140007bf8 {"<redacted>"}

140007c10                                                  0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................

140007c20  void* data_140007c20 = sub_140002f10

140007c28                          10 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00                                  ................

140007c38  void* data_140007c38 = sub_140002f80
140007c40  void* data_140007c40 = sub_140002d80
140007c48  void* data_140007c48 = 0x140002f00
140007c50  void* data_140007c50 = sub_140002f10

140007c58                                                                          10 00 00 00 00 00 00 00                          ........
140007c60  08 00 00 00 00 00 00 00                                                                          ........

140007c68  void* data_140007c68 = sub_140003040
140007c70  void* data_140007c70 = sub_140002c70
140007c78  void* data_140007c78 = 0x140002ef0
140007c80  char const data_140007c80[0x23] = "stream did not contain valid UTF-8", 0

140007ca3           00 00 00 00 00                                                                             .....

140007ca8  char const (* data_140007ca8)[0x23] = data_140007c80 {"stream did not contain valid UTF-8"}

140007cb0                                                  22 00 00 00 00 00 00 00 15 00 00 00 00 00 00 00                  "...............
140007cc0  uint32_t jump_table_140007cc0[0x4] = 
140007cc0  {
140007cc0      [0x0] =  0xffffb430
140007cc4      [0x1] =  0xffffb4f2
140007cc8      [0x2] =  0xffffb6e8
140007ccc      [0x3] =  0xffffb550
140007cd0  }
140007cd0  int128_t data_140007cd0 = 
140007cd0                                                  10 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00                  ................
140007ce0  char const data_140007ce0[0xb] = "<redacted>", 0

140007ceb                                   00 00 00 00 00                                                             .....

140007cf0  char const (* data_140007cf0)[0xb] = data_140007ce0 {"<redacted>"}

140007cf8                                                                          0a 00 00 00 00 00 00 00                          ........
140007d00  00 00 00 00 00 00 00 00                                                                          ........

140007d08  char const data_140007d08[0x1d] = "failed to write whole buffer", 0

140007d25                 00 00 00                                                                               ...

140007d28  char const (* data_140007d28)[0x1d] = data_140007d08 {"failed to write whole buffer"}

140007d30                                                  1c 00 00 00 00 00 00 00 17 00 00 00 00 00 00 00                  ................

140007d40  char const data_140007d40[0x15] = "SetThreadDescription", 0

140007d55  data_140007d55:
140007d55                                                                 01 01 01 01 01 01 01 01 01 01 01                       ...........
140007d60  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  ................................
140007d80  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  ................................
140007da0  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  ................................
140007dc0  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 00 00 00 00 00 00 00 00 00 00 00  ................................
140007de0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140007e00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 02 02 02 02 02 02 02 02  ................................
140007e20  02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 03 03 03 03 03 03 03 03 03 03 03  ................................
140007e40  03 03 03 03 03 04 04 04 04 04 00 00 00 00 00 00 00 00 00 00 00                                   .....................

140007e55  char const data_140007e55[0x50] = "Windows stdio in console mode does not support writing non-UTF-8 byte sequences", 0

140007ea5                 00 00 00                                                                               ...

140007ea8  char const (* data_140007ea8)[0x50] = data_140007e55 {"Windows stdio in console mode does not support writing non-UTF-8 byte sequences"}

140007eb0                                                  4f 00 00 00 00 00 00 00 15 00 00 00 00 00 00 00                  O...............

140007ec0  char const data_140007ec0[0x60] = "Windows stdin in console mode does not support non-UTF-16 input; encountered unpaired surrogate", 0
140007f20  char const (* data_140007f20)[0x60] = data_140007ec0 {"Windows stdin in console mode does not support non-UTF-16 input; encountered unpaired surrogate"}

140007f28                          5f 00 00 00 00 00 00 00 15 00 00 00 00 00 00 00                                  _...............
140007f38  uint32_t jump_table_140007f38[0x4] = 
140007f38  {
140007f38      [0x0] =  0xffffb6aa
140007f3c      [0x1] =  0xffffb6e6
140007f40      [0x2] =  0xffffb774
140007f44      [0x3] =  0xffffb760
140007f48  }
140007f48  wchar16 const data_140007f48[0x5] = "main", 0

140007f52                                                        00 00                                                        ..
140007f54  uint32_t jump_table_140007f54[0x4] = 
140007f54  {
140007f54      [0x0] =  0xffffe6fc
140007f58      [0x1] =  0xffffe765
140007f5c      [0x2] =  0xffffe71d
140007f60      [0x3] =  0xffffe79b
140007f64  }

140007f64              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

140007f70  int128_t data_140007f70 = 
140007f70                                                  bf bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140007f80  int128_t data_140007f80 = 
140007f80  01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00                                                  ................
140007f90  uint32_t jump_table_140007f90[0x4] = 
140007f90  {
140007f90      [0x0] =  0xffffc8c0
140007f94      [0x1] =  0xffffc8ec
140007f98      [0x2] =  0xffffc8f1
140007f9c      [0x3] =  0xffffc8c0
140007fa0  }

140007fa0  02 02 02 02 02 02 02 02 02 03 03 01 01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140007fc0  01 00 00 00 00 00 00 00 02 02 00 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140007fe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02  ................................
140008000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140008020  00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140008040  01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140008060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140008080  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400080a0  data_1400080a0:
1400080a0  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  ................................
1400080c0  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  ................................
1400080e0  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  ................................
140008100  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  ................................
140008120  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140008140  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140008160  00 00 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02  ................................
140008180  03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 04 04 04 04 04 00 00 00 00 00 00 00 00 00 00 00  ................................
1400081a0  00 7c 00 7e 00 00 00 00 00 00 00 00 00 00 00 00                                                  .|.~............

1400081b0  int128_t data_1400081b0 = 
1400081b0                                                  01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01                  ................

1400081c0  00 7c 00 7e 00 00 00 00 00 00 00 00 00 00 00 00                                                  .|.~............

1400081d0  int128_t data_1400081d0 = 
1400081d0                                                  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff                  ................
1400081e0  struct Load_Configuration_Directory_Table __load_configuration_directory_table = 
1400081e0  {
1400081e0      uint32_t characteristics = 0x140
1400081e4      uint32_t timeDateStamp = 0x0
1400081e8      uint16_t majorVersion = 0x0
1400081ea      uint16_t minorVersion = 0x0
1400081ec      uint32_t globalFlagsClear = 0x0
1400081f0      uint32_t globalFlagsSet = 0x0
1400081f4      uint32_t criticalSectionDefaultTimeout = 0x0
1400081f8      uint64_t deCommitFreeBlockThreshold = 0x0
140008200      uint64_t deCommitTotalFreeThreshold = 0x0
140008208      uint64_t lockPrefixTable = 0x0
140008210      uint64_t maximumAllocationSize = 0x0
140008218      uint64_t virtualMemoryThreshold = 0x0
140008220      uint64_t processAffinityMask = 0x0
140008228      uint32_t processHeapFlags = 0x0
14000822c      uint16_t csdVersion = 0x0
14000822e      uint16_t reserved = 0x0
140008230      uint64_t editList = 0x0
140008238      uint64_t securityCookie = 0x14000a080
140008240      uint64_t seHandlerTable = 0x0
140008248      uint64_t seHandlerCount = 0x0
140008250      uint64_t guardCFCheckFunctionPointer = 0x140007268
140008258      uint64_t guardCFDispatchFunctionPointer = 0x140007278
140008260      uint64_t guardCFFunctionTable = 0x0
140008268      uint64_t guardCFFunctionCount = 0x0
140008270      uint32_t guardFlags = 0x100
140008274      uint16_t Flags = 0x0
140008276      uint16_t Catalog = 0x0
140008278      uint32_t CatalogOffset = 0x0
14000827c      uint32_t Reserved = 0x0
140008280      uint64_t guardAddressTakenIatEntryTable = 0x0
140008288      uint64_t guardAddressTakenIatEntryCount = 0x0
140008290      uint64_t guardLongJumpTargetTable = 0x0
140008298      uint64_t guardLongJumpTargetCount = 0x0
1400082a0      uint64_t dynamicValueRelocTable = 0x0
1400082a8      uint64_t CHPEMetadataPointer = 0x0
1400082b0      uint64_t guardRFFailureRoutine = 0x0
1400082b8      uint64_t guardRFFailureRoutineFunctionPointer = 0x0
1400082c0      uint32_t dynamicValueRelocTableOffset = 0x0
1400082c4      uint16_t dynamicValueRelocTableSection = 0x0
1400082c6      uint16_t reserved2 = 0x0
1400082c8      uint64_t guardRFVerifyStackPointerFunctionPointer = 0x0
1400082d0      uint32_t hotPatchTableOffset = 0x0
1400082d4      uint32_t reserved3 = 0x0
1400082d8      uint64_t enclaveConfigurationPointer = 0x0
1400082e0      uint64_t volatileMetadataPointer = 0x1400083a8
1400082e8      uint64_t guardEHContinuationTable = 0x0
1400082f0      uint64_t guardEHContinuationCount = 0x0
1400082f8      uint64_t guardXFGCheckFunctionPointer = 0x140007270
140008300      uint64_t guardXFGDispatchFunctionPointer = 0x140007280
140008308      uint64_t guardXFGTableDispatchFunctionPointer = 0x140007288
140008310  }
140008310  void* data_140008310 = 0x140007290
140008318  void* data_140008318 = data_140007298
140008320  struct Debug_Directory_Table __debug_directory_entries[0x3] = 
140008320  {
140008320      [0x0] = 
140008320      {
140008320          uint32_t characteristics = 0x0
140008324          uint32_t timeDateStamp = 0x68e58356
140008328          uint16_t majorVersion = 0x0
14000832a          uint16_t minorVersion = 0x0
14000832c          enum type = IMAGE_DEBUG_TYPE_CODEVIEW
140008330          uint32_t sizeOfData = 0x2b
140008334          uint32_t addressOfRawData = 0x8400
140008338          uint32_t pointerToRawData = 0x7000
14000833c      }
14000833c      [0x1] = 
14000833c      {
14000833c          uint32_t characteristics = 0x0
140008340          uint32_t timeDateStamp = 0x68e58356
140008344          uint16_t majorVersion = 0x0
140008346          uint16_t minorVersion = 0x0
140008348          enum type = IMAGE_DEBUG_TYPE_VC_FEATURE
14000834c          uint32_t sizeOfData = 0x14
140008350          uint32_t addressOfRawData = 0x842c
140008354          uint32_t pointerToRawData = 0x702c
140008358      }
140008358      [0x2] = 
140008358      {
140008358          uint32_t characteristics = 0x0
14000835c          uint32_t timeDateStamp = 0x68e58356
140008360          uint16_t majorVersion = 0x0
140008362          uint16_t minorVersion = 0x0
140008364          enum type = IMAGE_DEBUG_TYPE_POGO
140008368          uint32_t sizeOfData = 0x31c
14000836c          uint32_t addressOfRawData = 0x8440
140008370          uint32_t pointerToRawData = 0x7040
140008374      }
140008374  }

140008374                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

140008380  struct TLS_Directory __tls_directory = 
140008380  {
140008380      uint64_t rawDataStartVirtualAddress = 0x140008780
140008388      uint64_t rawDataEndVirtualAddress = 0x1400087c8
140008390      uint64_t addressOfIndex = 0x14000a190
140008398      uint64_t addressOfCallbacks = 0x1400072e8
1400083a0      uint32_t sizeOfZeroFill = 0x0
1400083a4      uint32_t characteristics = 0x400000
1400083a8  }

1400083a8                          18 00 00 00 03 80 03 80 c0 83 00 00 28 00 00 00 e8 83 00 00 18 00 00 00          ............(...........
1400083c0  2d 56 00 00 43 56 00 00 d3 57 00 00 32 5a 00 00 64 5a 00 00 a6 5d 00 00 b4 5d 00 00 15 5e 00 00  -V..CV...W..2Z..dZ...]...]...^..
1400083e0  60 5e 00 00 b1 5e 00 00 40 53 00 00 80 02 00 00 20 56 00 00 d0 08 00 00 02 67 00 00 36 00 00 00  `^...^..@S...... V.......g..6...

140008400  uint32_t debugInfoType = 'RSDS'
140008404  uint8_t PDBGuid[0x10] = 
140008404  {
140008404      [0x0] =  0xe5
140008405      [0x1] =  0x6a
140008406      [0x2] =  0xc9
140008407      [0x3] =  0x1f
140008408      [0x4] =  0xff
140008409      [0x5] =  0x6c
14000840a      [0x6] =  0xa3
14000840b      [0x7] =  0x4d
14000840c      [0x8] =  0x8d
14000840d      [0x9] =  0xf9
14000840e      [0xa] =  0xab
14000840f      [0xb] =  0x77
140008410      [0xc] =  0xdc
140008411      [0xd] =  0x83
140008412      [0xe] =  0x8c
140008413      [0xf] =  0x41
140008414  }
140008414  uint32_t PDBAge = 0x1
140008418  char PDBFileName[0x13] = "rust_tickler_1.pdb", 0

14000842b                                   00                                                                         .
14000842c  uint8_t debug_type_vc_feature[0x14] = 
14000842c  {
14000842c      [0x00] =  0x30
14000842d      [0x01] =  0x00
14000842e      [0x02] =  0x00
14000842f      [0x03] =  0x00
140008430      [0x04] =  0x1d
140008431      [0x05] =  0x00
140008432      [0x06] =  0x00
140008433      [0x07] =  0x00
140008434      [0x08] =  0x1d
140008435      [0x09] =  0x00
140008436      [0x0a] =  0x00
140008437      [0x0b] =  0x00
140008438      [0x0c] =  0x00
140008439      [0x0d] =  0x00
14000843a      [0x0e] =  0x00
14000843b      [0x0f] =  0x00
14000843c      [0x10] =  0x1d
14000843d      [0x11] =  0x00
14000843e      [0x12] =  0x00
14000843f      [0x13] =  0x00
140008440  }
140008440  uint8_t debug_type_pogo[0x31c] = 
140008440  {
140008440      [0x000] =  0x00
140008441      [0x001] =  0x00
140008442      [0x002] =  0x00
140008443      [0x003] =  0x00
140008444      [0x004] =  0x00
140008445      [0x005] =  0x10
140008446      [0x006] =  0x00
140008447      [0x007] =  0x00
140008448      [0x008] =  0x40
140008449      [0x009] =  0x43
14000844a      [0x00a] =  0x00
14000844b      [0x00b] =  0x00
14000844c      [0x00c] =  0x2e
14000844d      [0x00d] =  0x74
14000844e      [0x00e] =  0x65
14000844f      [0x00f] =  0x78
140008450      [0x010] =  0x74
140008451      [0x011] =  0x00
140008452      [0x012] =  0x00
140008453      [0x013] =  0x00
140008454      [0x014] =  0x40
140008455      [0x015] =  0x53
140008456      [0x016] =  0x00
140008457      [0x017] =  0x00
140008458      [0x018] =  0x70
140008459      [0x019] =  0x0c
14000845a      [0x01a] =  0x00
14000845b      [0x01b] =  0x00
14000845c      [0x01c] =  0x2e
14000845d      [0x01d] =  0x74
14000845e      [0x01e] =  0x65
14000845f      [0x01f] =  0x78
140008460      [0x020] =  0x74
140008461      [0x021] =  0x24
140008462      [0x022] =  0x6d
140008463      [0x023] =  0x6e
140008464      [0x024] =  0x00
140008465      [0x025] =  0x00
140008466      [0x026] =  0x00
140008467      [0x027] =  0x00
140008468      [0x028] =  0xb0
140008469      [0x029] =  0x5f
14000846a      [0x02a] =  0x00
14000846b      [0x02b] =  0x00
14000846c      [0x02c] =  0x40
14000846d      [0x02d] =  0x00
14000846e      [0x02e] =  0x00
14000846f      [0x02f] =  0x00
140008470      [0x030] =  0x2e
140008471      [0x031] =  0x74
140008472      [0x032] =  0x65
140008473      [0x033] =  0x78
140008474      [0x034] =  0x74
140008475      [0x035] =  0x24
140008476      [0x036] =  0x6d
140008477      [0x037] =  0x6e
140008478      [0x038] =  0x24
140008479      [0x039] =  0x30
14000847a      [0x03a] =  0x30
14000847b      [0x03b] =  0x00
14000847c      [0x03c] =  0xf0
14000847d      [0x03d] =  0x5f
14000847e      [0x03e] =  0x00
14000847f      [0x03f] =  0x00
140008480      [0x040] =  0x12
140008481      [0x041] =  0x07
140008482      [0x042] =  0x00
140008483      [0x043] =  0x00
140008484      [0x044] =  0x2e
140008485      [0x045] =  0x74
140008486      [0x046] =  0x65
140008487      [0x047] =  0x78
140008488      [0x048] =  0x74
140008489      [0x049] =  0x24
14000848a      [0x04a] =  0x75
14000848b      [0x04b] =  0x6e
14000848c      [0x04c] =  0x6c
14000848d      [0x04d] =  0x69
14000848e      [0x04e] =  0x6b
14000848f      [0x04f] =  0x65
140008490      [0x050] =  0x6c
140008491      [0x051] =  0x79
140008492      [0x052] =  0x00
140008493      [0x053] =  0x00
140008494      [0x054] =  0x02
140008495      [0x055] =  0x67
140008496      [0x056] =  0x00
140008497      [0x057] =  0x00
140008498      [0x058] =  0x36
140008499      [0x059] =  0x00
14000849a      [0x05a] =  0x00
14000849b      [0x05b] =  0x00
14000849c      [0x05c] =  0x2e
14000849d      [0x05d] =  0x74
14000849e      [0x05e] =  0x65
14000849f      [0x05f] =  0x78
1400084a0      [0x060] =  0x74
1400084a1      [0x061] =  0x24
1400084a2      [0x062] =  0x78
1400084a3      [0x063] =  0x00
1400084a4      [0x064] =  0x00
1400084a5      [0x065] =  0x70
1400084a6      [0x066] =  0x00
1400084a7      [0x067] =  0x00
1400084a8      [0x068] =  0x68
1400084a9      [0x069] =  0x02
1400084aa      [0x06a] =  0x00
1400084ab      [0x06b] =  0x00
1400084ac      [0x06c] =  0x2e
1400084ad      [0x06d] =  0x69
1400084ae      [0x06e] =  0x64
1400084af      [0x06f] =  0x61
1400084b0      [0x070] =  0x74
1400084b1      [0x071] =  0x61
1400084b2      [0x072] =  0x24
1400084b3      [0x073] =  0x35
1400084b4      [0x074] =  0x00
1400084b5      [0x075] =  0x00
1400084b6      [0x076] =  0x00
1400084b7      [0x077] =  0x00
1400084b8      [0x078] =  0x68
1400084b9      [0x079] =  0x72
1400084ba      [0x07a] =  0x00
1400084bb      [0x07b] =  0x00
1400084bc      [0x07c] =  0x38
1400084bd      [0x07d] =  0x00
1400084be      [0x07e] =  0x00
1400084bf      [0x07f] =  0x00
1400084c0      [0x080] =  0x2e
1400084c1      [0x081] =  0x30
1400084c2      [0x082] =  0x30
1400084c3      [0x083] =  0x63
1400084c4      [0x084] =  0x66
1400084c5      [0x085] =  0x67
1400084c6      [0x086] =  0x00
1400084c7      [0x087] =  0x00
1400084c8      [0x088] =  0xa0
1400084c9      [0x089] =  0x72
1400084ca      [0x08a] =  0x00
1400084cb      [0x08b] =  0x00
1400084cc      [0x08c] =  0x08
1400084cd      [0x08d] =  0x00
1400084ce      [0x08e] =  0x00
1400084cf      [0x08f] =  0x00
1400084d0      [0x090] =  0x2e
1400084d1      [0x091] =  0x43
1400084d2      [0x092] =  0x52
1400084d3      [0x093] =  0x54
1400084d4      [0x094] =  0x24
1400084d5      [0x095] =  0x58
1400084d6      [0x096] =  0x43
1400084d7      [0x097] =  0x41
1400084d8      [0x098] =  0x00
1400084d9      [0x099] =  0x00
1400084da      [0x09a] =  0x00
1400084db      [0x09b] =  0x00
1400084dc      [0x09c] =  0xa8
1400084dd      [0x09d] =  0x72
1400084de      [0x09e] =  0x00
1400084df      [0x09f] =  0x00
1400084e0      [0x0a0] =  0x08
1400084e1      [0x0a1] =  0x00
1400084e2      [0x0a2] =  0x00
1400084e3      [0x0a3] =  0x00
1400084e4      [0x0a4] =  0x2e
1400084e5      [0x0a5] =  0x43
1400084e6      [0x0a6] =  0x52
1400084e7      [0x0a7] =  0x54
1400084e8      [0x0a8] =  0x24
1400084e9      [0x0a9] =  0x58
1400084ea      [0x0aa] =  0x43
1400084eb      [0x0ab] =  0x41
1400084ec      [0x0ac] =  0x41
1400084ed      [0x0ad] =  0x00
1400084ee      [0x0ae] =  0x00
1400084ef      [0x0af] =  0x00
1400084f0      [0x0b0] =  0xb0
1400084f1      [0x0b1] =  0x72
1400084f2      [0x0b2] =  0x00
1400084f3      [0x0b3] =  0x00
1400084f4      [0x0b4] =  0x08
1400084f5      [0x0b5] =  0x00
1400084f6      [0x0b6] =  0x00
1400084f7      [0x0b7] =  0x00
1400084f8      [0x0b8] =  0x2e
1400084f9      [0x0b9] =  0x43
1400084fa      [0x0ba] =  0x52
1400084fb      [0x0bb] =  0x54
1400084fc      [0x0bc] =  0x24
1400084fd      [0x0bd] =  0x58
1400084fe      [0x0be] =  0x43
1400084ff      [0x0bf] =  0x55
140008500      [0x0c0] =  0x00
140008501      [0x0c1] =  0x00
140008502      [0x0c2] =  0x00
140008503      [0x0c3] =  0x00
140008504      [0x0c4] =  0xb8
140008505      [0x0c5] =  0x72
140008506      [0x0c6] =  0x00
140008507      [0x0c7] =  0x00
140008508      [0x0c8] =  0x08
140008509      [0x0c9] =  0x00
14000850a      [0x0ca] =  0x00
14000850b      [0x0cb] =  0x00
14000850c      [0x0cc] =  0x2e
14000850d      [0x0cd] =  0x43
14000850e      [0x0ce] =  0x52
14000850f      [0x0cf] =  0x54
140008510      [0x0d0] =  0x24
140008511      [0x0d1] =  0x58
140008512      [0x0d2] =  0x43
140008513      [0x0d3] =  0x5a
140008514      [0x0d4] =  0x00
140008515      [0x0d5] =  0x00
140008516      [0x0d6] =  0x00
140008517      [0x0d7] =  0x00
140008518      [0x0d8] =  0xc0
140008519      [0x0d9] =  0x72
14000851a      [0x0da] =  0x00
14000851b      [0x0db] =  0x00
14000851c      [0x0dc] =  0x08
14000851d      [0x0dd] =  0x00
14000851e      [0x0de] =  0x00
14000851f      [0x0df] =  0x00
140008520      [0x0e0] =  0x2e
140008521      [0x0e1] =  0x43
140008522      [0x0e2] =  0x52
140008523      [0x0e3] =  0x54
140008524      [0x0e4] =  0x24
140008525      [0x0e5] =  0x58
140008526      [0x0e6] =  0x49
140008527      [0x0e7] =  0x41
140008528      [0x0e8] =  0x00
140008529      [0x0e9] =  0x00
14000852a      [0x0ea] =  0x00
14000852b      [0x0eb] =  0x00
14000852c      [0x0ec] =  0xc8
14000852d      [0x0ed] =  0x72
14000852e      [0x0ee] =  0x00
14000852f      [0x0ef] =  0x00
140008530      [0x0f0] =  0x08
140008531      [0x0f1] =  0x00
140008532      [0x0f2] =  0x00
140008533      [0x0f3] =  0x00
140008534      [0x0f4] =  0x2e
140008535      [0x0f5] =  0x43
140008536      [0x0f6] =  0x52
140008537      [0x0f7] =  0x54
140008538      [0x0f8] =  0x24
140008539      [0x0f9] =  0x58
14000853a      [0x0fa] =  0x49
14000853b      [0x0fb] =  0x41
14000853c      [0x0fc] =  0x41
14000853d      [0x0fd] =  0x00
14000853e      [0x0fe] =  0x00
14000853f      [0x0ff] =  0x00
140008540      [0x100] =  0xd0
140008541      [0x101] =  0x72
140008542      [0x102] =  0x00
140008543      [0x103] =  0x00
140008544      [0x104] =  0x08
140008545      [0x105] =  0x00
140008546      [0x106] =  0x00
140008547      [0x107] =  0x00
140008548      [0x108] =  0x2e
140008549      [0x109] =  0x43
14000854a      [0x10a] =  0x52
14000854b      [0x10b] =  0x54
14000854c      [0x10c] =  0x24
14000854d      [0x10d] =  0x58
14000854e      [0x10e] =  0x49
14000854f      [0x10f] =  0x41
140008550      [0x110] =  0x43
140008551      [0x111] =  0x00
140008552      [0x112] =  0x00
140008553      [0x113] =  0x00
140008554      [0x114] =  0xd8
140008555      [0x115] =  0x72
140008556      [0x116] =  0x00
140008557      [0x117] =  0x00
140008558      [0x118] =  0x08
140008559      [0x119] =  0x00
14000855a      [0x11a] =  0x00
14000855b      [0x11b] =  0x00
14000855c      [0x11c] =  0x2e
14000855d      [0x11d] =  0x43
14000855e      [0x11e] =  0x52
14000855f      [0x11f] =  0x54
140008560      [0x120] =  0x24
140008561      [0x121] =  0x58
140008562      [0x122] =  0x49
140008563      [0x123] =  0x5a
140008564      [0x124] =  0x00
140008565      [0x125] =  0x00
140008566      [0x126] =  0x00
140008567      [0x127] =  0x00
140008568      [0x128] =  0xe0
140008569      [0x129] =  0x72
14000856a      [0x12a] =  0x00
14000856b      [0x12b] =  0x00
14000856c      [0x12c] =  0x08
14000856d      [0x12d] =  0x00
14000856e      [0x12e] =  0x00
14000856f      [0x12f] =  0x00
140008570      [0x130] =  0x2e
140008571      [0x131] =  0x43
140008572      [0x132] =  0x52
140008573      [0x133] =  0x54
140008574      [0x134] =  0x24
140008575      [0x135] =  0x58
140008576      [0x136] =  0x4c
140008577      [0x137] =  0x41
140008578      [0x138] =  0x00
140008579      [0x139] =  0x00
14000857a      [0x13a] =  0x00
14000857b      [0x13b] =  0x00
14000857c      [0x13c] =  0xe8
14000857d      [0x13d] =  0x72
14000857e      [0x13e] =  0x00
14000857f      [0x13f] =  0x00
140008580      [0x140] =  0x08
140008581      [0x141] =  0x00
140008582      [0x142] =  0x00
140008583      [0x143] =  0x00
140008584      [0x144] =  0x2e
140008585      [0x145] =  0x43
140008586      [0x146] =  0x52
140008587      [0x147] =  0x54
140008588      [0x148] =  0x24
140008589      [0x149] =  0x58
14000858a      [0x14a] =  0x4c
14000858b      [0x14b] =  0x42
14000858c      [0x14c] =  0x00
14000858d      [0x14d] =  0x00
14000858e      [0x14e] =  0x00
14000858f      [0x14f] =  0x00
140008590      [0x150] =  0xf0
140008591      [0x151] =  0x72
140008592      [0x152] =  0x00
140008593      [0x153] =  0x00
140008594      [0x154] =  0x08
140008595      [0x155] =  0x00
140008596      [0x156] =  0x00
140008597      [0x157] =  0x00
140008598      [0x158] =  0x2e
140008599      [0x159] =  0x43
14000859a      [0x15a] =  0x52
14000859b      [0x15b] =  0x54
14000859c      [0x15c] =  0x24
14000859d      [0x15d] =  0x58
14000859e      [0x15e] =  0x4c
14000859f      [0x15f] =  0x5a
1400085a0      [0x160] =  0x00
1400085a1      [0x161] =  0x00
1400085a2      [0x162] =  0x00
1400085a3      [0x163] =  0x00
1400085a4      [0x164] =  0xf8
1400085a5      [0x165] =  0x72
1400085a6      [0x166] =  0x00
1400085a7      [0x167] =  0x00
1400085a8      [0x168] =  0x08
1400085a9      [0x169] =  0x00
1400085aa      [0x16a] =  0x00
1400085ab      [0x16b] =  0x00
1400085ac      [0x16c] =  0x2e
1400085ad      [0x16d] =  0x43
1400085ae      [0x16e] =  0x52
1400085af      [0x16f] =  0x54
1400085b0      [0x170] =  0x24
1400085b1      [0x171] =  0x58
1400085b2      [0x172] =  0x50
1400085b3      [0x173] =  0x41
1400085b4      [0x174] =  0x00
1400085b5      [0x175] =  0x00
1400085b6      [0x176] =  0x00
1400085b7      [0x177] =  0x00
1400085b8      [0x178] =  0x00
1400085b9      [0x179] =  0x73
1400085ba      [0x17a] =  0x00
1400085bb      [0x17b] =  0x00
1400085bc      [0x17c] =  0x08
1400085bd      [0x17d] =  0x00
1400085be      [0x17e] =  0x00
1400085bf      [0x17f] =  0x00
1400085c0      [0x180] =  0x2e
1400085c1      [0x181] =  0x43
1400085c2      [0x182] =  0x52
1400085c3      [0x183] =  0x54
1400085c4      [0x184] =  0x24
1400085c5      [0x185] =  0x58
1400085c6      [0x186] =  0x50
1400085c7      [0x187] =  0x5a
1400085c8      [0x188] =  0x00
1400085c9      [0x189] =  0x00
1400085ca      [0x18a] =  0x00
1400085cb      [0x18b] =  0x00
1400085cc      [0x18c] =  0x08
1400085cd      [0x18d] =  0x73
1400085ce      [0x18e] =  0x00
1400085cf      [0x18f] =  0x00
1400085d0      [0x190] =  0x08
1400085d1      [0x191] =  0x00
1400085d2      [0x192] =  0x00
1400085d3      [0x193] =  0x00
1400085d4      [0x194] =  0x2e
1400085d5      [0x195] =  0x43
1400085d6      [0x196] =  0x52
1400085d7      [0x197] =  0x54
1400085d8      [0x198] =  0x24
1400085d9      [0x199] =  0x58
1400085da      [0x19a] =  0x54
1400085db      [0x19b] =  0x41
1400085dc      [0x19c] =  0x00
1400085dd      [0x19d] =  0x00
1400085de      [0x19e] =  0x00
1400085df      [0x19f] =  0x00
1400085e0      [0x1a0] =  0x10
1400085e1      [0x1a1] =  0x73
1400085e2      [0x1a2] =  0x00
1400085e3      [0x1a3] =  0x00
1400085e4      [0x1a4] =  0x10
1400085e5      [0x1a5] =  0x00
1400085e6      [0x1a6] =  0x00
1400085e7      [0x1a7] =  0x00
1400085e8      [0x1a8] =  0x2e
1400085e9      [0x1a9] =  0x43
1400085ea      [0x1aa] =  0x52
1400085eb      [0x1ab] =  0x54
1400085ec      [0x1ac] =  0x24
1400085ed      [0x1ad] =  0x58
1400085ee      [0x1ae] =  0x54
1400085ef      [0x1af] =  0x5a
1400085f0      [0x1b0] =  0x00
1400085f1      [0x1b1] =  0x00
1400085f2      [0x1b2] =  0x00
1400085f3      [0x1b3] =  0x00
1400085f4      [0x1b4] =  0x20
1400085f5      [0x1b5] =  0x73
1400085f6      [0x1b6] =  0x00
1400085f7      [0x1b7] =  0x00
1400085f8      [0x1b8] =  0x60
1400085f9      [0x1b9] =  0x10
1400085fa      [0x1ba] =  0x00
1400085fb      [0x1bb] =  0x00
1400085fc      [0x1bc] =  0x2e
1400085fd      [0x1bd] =  0x72
1400085fe      [0x1be] =  0x64
1400085ff      [0x1bf] =  0x61
140008600      [0x1c0] =  0x74
140008601      [0x1c1] =  0x61
140008602      [0x1c2] =  0x00
140008603      [0x1c3] =  0x00
140008604      [0x1c4] =  0x80
140008605      [0x1c5] =  0x83
140008606      [0x1c6] =  0x00
140008607      [0x1c7] =  0x00
140008608      [0x1c8] =  0x28
140008609      [0x1c9] =  0x00
14000860a      [0x1ca] =  0x00
14000860b      [0x1cb] =  0x00
14000860c      [0x1cc] =  0x2e
14000860d      [0x1cd] =  0x72
14000860e      [0x1ce] =  0x64
14000860f      [0x1cf] =  0x61
140008610      [0x1d0] =  0x74
140008611      [0x1d1] =  0x61
140008612      [0x1d2] =  0x24
140008613      [0x1d3] =  0x54
140008614      [0x1d4] =  0x00
140008615      [0x1d5] =  0x00
140008616      [0x1d6] =  0x00
140008617      [0x1d7] =  0x00
140008618      [0x1d8] =  0xa8
140008619      [0x1d9] =  0x83
14000861a      [0x1da] =  0x00
14000861b      [0x1db] =  0x00
14000861c      [0x1dc] =  0x58
14000861d      [0x1dd] =  0x00
14000861e      [0x1de] =  0x00
14000861f      [0x1df] =  0x00
140008620      [0x1e0] =  0x2e
140008621      [0x1e1] =  0x72
140008622      [0x1e2] =  0x64
140008623      [0x1e3] =  0x61
140008624      [0x1e4] =  0x74
140008625      [0x1e5] =  0x61
140008626      [0x1e6] =  0x24
140008627      [0x1e7] =  0x76
140008628      [0x1e8] =  0x6f
140008629      [0x1e9] =  0x6c
14000862a      [0x1ea] =  0x74
14000862b      [0x1eb] =  0x6d
14000862c      [0x1ec] =  0x64
14000862d      [0x1ed] =  0x00
14000862e      [0x1ee] =  0x00
14000862f      [0x1ef] =  0x00
140008630      [0x1f0] =  0x00
140008631      [0x1f1] =  0x84
140008632      [0x1f2] =  0x00
140008633      [0x1f3] =  0x00
140008634      [0x1f4] =  0x60
140008635      [0x1f5] =  0x03
140008636      [0x1f6] =  0x00
140008637      [0x1f7] =  0x00
140008638      [0x1f8] =  0x2e
140008639      [0x1f9] =  0x72
14000863a      [0x1fa] =  0x64
14000863b      [0x1fb] =  0x61
14000863c      [0x1fc] =  0x74
14000863d      [0x1fd] =  0x61
14000863e      [0x1fe] =  0x24
14000863f      [0x1ff] =  0x7a
140008640      [0x200] =  0x7a
140008641      [0x201] =  0x7a
140008642      [0x202] =  0x64
140008643      [0x203] =  0x62
140008644      [0x204] =  0x67
140008645      [0x205] =  0x00
140008646      [0x206] =  0x00
140008647      [0x207] =  0x00
140008648      [0x208] =  0x60
140008649      [0x209] =  0x87
14000864a      [0x20a] =  0x00
14000864b      [0x20b] =  0x00
14000864c      [0x20c] =  0x08
14000864d      [0x20d] =  0x00
14000864e      [0x20e] =  0x00
14000864f      [0x20f] =  0x00
140008650      [0x210] =  0x2e
140008651      [0x211] =  0x72
140008652      [0x212] =  0x74
140008653      [0x213] =  0x63
140008654      [0x214] =  0x24
140008655      [0x215] =  0x49
140008656      [0x216] =  0x41
140008657      [0x217] =  0x41
140008658      [0x218] =  0x00
140008659      [0x219] =  0x00
14000865a      [0x21a] =  0x00
14000865b      [0x21b] =  0x00
14000865c      [0x21c] =  0x68
14000865d      [0x21d] =  0x87
14000865e      [0x21e] =  0x00
14000865f      [0x21f] =  0x00
140008660      [0x220] =  0x08
140008661      [0x221] =  0x00
140008662      [0x222] =  0x00
140008663      [0x223] =  0x00
140008664      [0x224] =  0x2e
140008665      [0x225] =  0x72
140008666      [0x226] =  0x74
140008667      [0x227] =  0x63
140008668      [0x228] =  0x24
140008669      [0x229] =  0x49
14000866a      [0x22a] =  0x5a
14000866b      [0x22b] =  0x5a
14000866c      [0x22c] =  0x00
14000866d      [0x22d] =  0x00
14000866e      [0x22e] =  0x00
14000866f      [0x22f] =  0x00
140008670      [0x230] =  0x70
140008671      [0x231] =  0x87
140008672      [0x232] =  0x00
140008673      [0x233] =  0x00
140008674      [0x234] =  0x08
140008675      [0x235] =  0x00
140008676      [0x236] =  0x00
140008677      [0x237] =  0x00
140008678      [0x238] =  0x2e
140008679      [0x239] =  0x72
14000867a      [0x23a] =  0x74
14000867b      [0x23b] =  0x63
14000867c      [0x23c] =  0x24
14000867d      [0x23d] =  0x54
14000867e      [0x23e] =  0x41
14000867f      [0x23f] =  0x41
140008680      [0x240] =  0x00
140008681      [0x241] =  0x00
140008682      [0x242] =  0x00
140008683      [0x243] =  0x00
140008684      [0x244] =  0x78
140008685      [0x245] =  0x87
140008686      [0x246] =  0x00
140008687      [0x247] =  0x00
140008688      [0x248] =  0x08
140008689      [0x249] =  0x00
14000868a      [0x24a] =  0x00
14000868b      [0x24b] =  0x00
14000868c      [0x24c] =  0x2e
14000868d      [0x24d] =  0x72
14000868e      [0x24e] =  0x74
14000868f      [0x24f] =  0x63
140008690      [0x250] =  0x24
140008691      [0x251] =  0x54
140008692      [0x252] =  0x5a
140008693      [0x253] =  0x5a
140008694      [0x254] =  0x00
140008695      [0x255] =  0x00
140008696      [0x256] =  0x00
140008697      [0x257] =  0x00
140008698      [0x258] =  0x80
140008699      [0x259] =  0x87
14000869a      [0x25a] =  0x00
14000869b      [0x25b] =  0x00
14000869c      [0x25c] =  0x08
14000869d      [0x25d] =  0x00
14000869e      [0x25e] =  0x00
14000869f      [0x25f] =  0x00
1400086a0      [0x260] =  0x2e
1400086a1      [0x261] =  0x74
1400086a2      [0x262] =  0x6c
1400086a3      [0x263] =  0x73
1400086a4      [0x264] =  0x00
1400086a5      [0x265] =  0x00
1400086a6      [0x266] =  0x00
1400086a7      [0x267] =  0x00
1400086a8      [0x268] =  0x88
1400086a9      [0x269] =  0x87
1400086aa      [0x26a] =  0x00
1400086ab      [0x26b] =  0x00
1400086ac      [0x26c] =  0x40
1400086ad      [0x26d] =  0x00
1400086ae      [0x26e] =  0x00
1400086af      [0x26f] =  0x00
1400086b0      [0x270] =  0x2e
1400086b1      [0x271] =  0x74
1400086b2      [0x272] =  0x6c
1400086b3      [0x273] =  0x73
1400086b4      [0x274] =  0x24
1400086b5      [0x275] =  0x00
1400086b6      [0x276] =  0x00
1400086b7      [0x277] =  0x00
1400086b8      [0x278] =  0xc8
1400086b9      [0x279] =  0x87
1400086ba      [0x27a] =  0x00
1400086bb      [0x27b] =  0x00
1400086bc      [0x27c] =  0x08
1400086bd      [0x27d] =  0x00
1400086be      [0x27e] =  0x00
1400086bf      [0x27f] =  0x00
1400086c0      [0x280] =  0x2e
1400086c1      [0x281] =  0x74
1400086c2      [0x282] =  0x6c
1400086c3      [0x283] =  0x73
1400086c4      [0x284] =  0x24
1400086c5      [0x285] =  0x5a
1400086c6      [0x286] =  0x5a
1400086c7      [0x287] =  0x5a
1400086c8      [0x288] =  0x00
1400086c9      [0x289] =  0x00
1400086ca      [0x28a] =  0x00
1400086cb      [0x28b] =  0x00
1400086cc      [0x28c] =  0xd0
1400086cd      [0x28d] =  0x87
1400086ce      [0x28e] =  0x00
1400086cf      [0x28f] =  0x00
1400086d0      [0x290] =  0x0c
1400086d1      [0x291] =  0x03
1400086d2      [0x292] =  0x00
1400086d3      [0x293] =  0x00
1400086d4      [0x294] =  0x2e
1400086d5      [0x295] =  0x78
1400086d6      [0x296] =  0x64
1400086d7      [0x297] =  0x61
1400086d8      [0x298] =  0x74
1400086d9      [0x299] =  0x61
1400086da      [0x29a] =  0x00
1400086db      [0x29b] =  0x00
1400086dc      [0x29c] =  0xdc
1400086dd      [0x29d] =  0x8a
1400086de      [0x29e] =  0x00
1400086df      [0x29f] =  0x00
1400086e0      [0x2a0] =  0xb4
1400086e1      [0x2a1] =  0x00
1400086e2      [0x2a2] =  0x00
1400086e3      [0x2a3] =  0x00
1400086e4      [0x2a4] =  0x2e
1400086e5      [0x2a5] =  0x69
1400086e6      [0x2a6] =  0x64
1400086e7      [0x2a7] =  0x61
1400086e8      [0x2a8] =  0x74
1400086e9      [0x2a9] =  0x61
1400086ea      [0x2aa] =  0x24
1400086eb      [0x2ab] =  0x32
1400086ec      [0x2ac] =  0x00
1400086ed      [0x2ad] =  0x00
1400086ee      [0x2ae] =  0x00
1400086ef      [0x2af] =  0x00
1400086f0      [0x2b0] =  0x90
1400086f1      [0x2b1] =  0x8b
1400086f2      [0x2b2] =  0x00
1400086f3      [0x2b3] =  0x00
1400086f4      [0x2b4] =  0x40
1400086f5      [0x2b5] =  0x00
1400086f6      [0x2b6] =  0x00
1400086f7      [0x2b7] =  0x00
1400086f8      [0x2b8] =  0x2e
1400086f9      [0x2b9] =  0x69
1400086fa      [0x2ba] =  0x64
1400086fb      [0x2bb] =  0x61
1400086fc      [0x2bc] =  0x74
1400086fd      [0x2bd] =  0x61
1400086fe      [0x2be] =  0x24
1400086ff      [0x2bf] =  0x33
140008700      [0x2c0] =  0x00
140008701      [0x2c1] =  0x00
140008702      [0x2c2] =  0x00
140008703      [0x2c3] =  0x00
140008704      [0x2c4] =  0xd0
140008705      [0x2c5] =  0x8b
140008706      [0x2c6] =  0x00
140008707      [0x2c7] =  0x00
140008708      [0x2c8] =  0x68
140008709      [0x2c9] =  0x02
14000870a      [0x2ca] =  0x00
14000870b      [0x2cb] =  0x00
14000870c      [0x2cc] =  0x2e
14000870d      [0x2cd] =  0x69
14000870e      [0x2ce] =  0x64
14000870f      [0x2cf] =  0x61
140008710      [0x2d0] =  0x74
140008711      [0x2d1] =  0x61
140008712      [0x2d2] =  0x24
140008713      [0x2d3] =  0x34
140008714      [0x2d4] =  0x00
140008715      [0x2d5] =  0x00
140008716      [0x2d6] =  0x00
140008717      [0x2d7] =  0x00
140008718      [0x2d8] =  0x38
140008719      [0x2d9] =  0x8e
14000871a      [0x2da] =  0x00
14000871b      [0x2db] =  0x00
14000871c      [0x2dc] =  0x1e
14000871d      [0x2dd] =  0x06
14000871e      [0x2de] =  0x00
14000871f      [0x2df] =  0x00
140008720      [0x2e0] =  0x2e
140008721      [0x2e1] =  0x69
140008722      [0x2e2] =  0x64
140008723      [0x2e3] =  0x61
140008724      [0x2e4] =  0x74
140008725      [0x2e5] =  0x61
140008726      [0x2e6] =  0x24
140008727      [0x2e7] =  0x36
140008728      [0x2e8] =  0x00
140008729      [0x2e9] =  0x00
14000872a      [0x2ea] =  0x00
14000872b      [0x2eb] =  0x00
14000872c      [0x2ec] =  0x00
14000872d      [0x2ed] =  0xa0
14000872e      [0x2ee] =  0x00
14000872f      [0x2ef] =  0x00
140008730      [0x2f0] =  0xe0
140008731      [0x2f1] =  0x00
140008732      [0x2f2] =  0x00
140008733      [0x2f3] =  0x00
140008734      [0x2f4] =  0x2e
140008735      [0x2f5] =  0x64
140008736      [0x2f6] =  0x61
140008737      [0x2f7] =  0x74
140008738      [0x2f8] =  0x61
140008739      [0x2f9] =  0x00
14000873a      [0x2fa] =  0x00
14000873b      [0x2fb] =  0x00
14000873c      [0x2fc] =  0xe0
14000873d      [0x2fd] =  0xa0
14000873e      [0x2fe] =  0x00
14000873f      [0x2ff] =  0x00
140008740      [0x300] =  0x40
140008741      [0x301] =  0x01
140008742      [0x302] =  0x00
140008743      [0x303] =  0x00
140008744      [0x304] =  0x2e
140008745      [0x305] =  0x62
140008746      [0x306] =  0x73
140008747      [0x307] =  0x73
140008748      [0x308] =  0x00
140008749      [0x309] =  0x00
14000874a      [0x30a] =  0x00
14000874b      [0x30b] =  0x00
14000874c      [0x30c] =  0x00
14000874d      [0x30d] =  0xb0
14000874e      [0x30e] =  0x00
14000874f      [0x30f] =  0x00
140008750      [0x310] =  0xf0
140008751      [0x311] =  0x03
140008752      [0x312] =  0x00
140008753      [0x313] =  0x00
140008754      [0x314] =  0x2e
140008755      [0x315] =  0x70
140008756      [0x316] =  0x64
140008757      [0x317] =  0x61
140008758      [0x318] =  0x74
140008759      [0x319] =  0x61
14000875a      [0x31a] =  0x00
14000875b      [0x31b] =  0x00
14000875c  }

14000875c                                                                                      00 00 00 00                              ....
140008760  00 00 00 00 00 00 00 00                                                                          ........
140008768  data_140008768:
140008768                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                  ................
140008778  data_140008778:
140008778                                                                          00 00 00 00 00 00 00 00                          ........
140008780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400087a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400087c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

1400087d0  struct UNWIND_INFO data_1400087d0 = 
1400087d0  {
1400087d0      uint8_t VersionAndFlag = 0x1
1400087d1      uint8_t SizeOfProlog = 0x4
1400087d2      uint8_t CountOfUnwindCodes = 0x1
1400087d3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400087d4  }
1400087d4  uint16_t data_1400087d4[0x1] = 
1400087d4  {
1400087d4      [0x0] =  0x4204
1400087d6  }

1400087d6                                                                    00 00                                                ..

1400087d8  struct UNWIND_INFO data_1400087d8 = 
1400087d8  {
1400087d8      uint8_t VersionAndFlag = 0x1
1400087d9      uint8_t SizeOfProlog = 0x8
1400087da      uint8_t CountOfUnwindCodes = 0x5
1400087db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400087dc  }
1400087dc  uint16_t data_1400087dc[0x5] = 
1400087dc  {
1400087dc      [0x0] =  0x4208
1400087de      [0x1] =  0x3004
1400087e0      [0x2] =  0x5003
1400087e2      [0x3] =  0x7002
1400087e4      [0x4] =  0x6001
1400087e6  }

1400087e6                    00 00                                                                                ..

1400087e8  struct UNWIND_INFO data_1400087e8 = 
1400087e8  {
1400087e8      uint8_t VersionAndFlag = 0x1
1400087e9      uint8_t SizeOfProlog = 0x9
1400087ea      uint8_t CountOfUnwindCodes = 0x5
1400087eb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400087ec  }
1400087ec  uint16_t data_1400087ec[0x5] = 
1400087ec  {
1400087ec      [0x0] =  0x4209
1400087ee      [0x1] =  0x3005
1400087f0      [0x2] =  0x7004
1400087f2      [0x3] =  0x6003
1400087f4      [0x4] =  0xe002
1400087f6  }

1400087f6                                                                    00 00                                                ..

1400087f8  struct UNWIND_INFO data_1400087f8 = 
1400087f8  {
1400087f8      uint8_t VersionAndFlag = 0x1
1400087f9      uint8_t SizeOfProlog = 0x6
1400087fa      uint8_t CountOfUnwindCodes = 0x3
1400087fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400087fc  }
1400087fc  uint16_t data_1400087fc[0x3] = 
1400087fc  {
1400087fc      [0x0] =  0x4206
1400087fe      [0x1] =  0x7002
140008800      [0x2] =  0x6001
140008802  }

140008802        00 00                                                                                        ..

140008804  struct UNWIND_INFO data_140008804 = 
140008804  {
140008804      uint8_t VersionAndFlag = 0x1
140008805      uint8_t SizeOfProlog = 0x6
140008806      uint8_t CountOfUnwindCodes = 0x3
140008807      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008808  }
140008808  uint16_t data_140008808[0x3] = 
140008808  {
140008808      [0x0] =  0xa206
14000880a      [0x1] =  0x7002
14000880c      [0x2] =  0x6001
14000880e  }

14000880e                                            00 00                                                                ..

140008810  struct UNWIND_INFO data_140008810 = 
140008810  {
140008810      uint8_t VersionAndFlag = 0x1
140008811      uint8_t SizeOfProlog = 0x13
140008812      uint8_t CountOfUnwindCodes = 0xa
140008813      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008814  }
140008814  uint16_t data_140008814[0xa] = 
140008814  {
140008814      [0x0] =  0x0113
140008816      [0x1] =  0x001b
140008818      [0x2] =  0x300c
14000881a      [0x3] =  0x500b
14000881c      [0x4] =  0x700a
14000881e      [0x5] =  0x6009
140008820      [0x6] =  0xc008
140008822      [0x7] =  0xd006
140008824      [0x8] =  0xe004
140008826      [0x9] =  0xf002
140008828  }
140008828  struct UNWIND_INFO data_140008828 = 
140008828  {
140008828      uint8_t VersionAndFlag = 0x1
140008829      uint8_t SizeOfProlog = 0xc
14000882a      uint8_t CountOfUnwindCodes = 0x6
14000882b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14000882c  }
14000882c  uint16_t data_14000882c[0x6] = 
14000882c  {
14000882c      [0x0] =  0x010c
14000882e      [0x1] =  0x0011
140008830      [0x2] =  0x3005
140008832      [0x3] =  0x7004
140008834      [0x4] =  0x6003
140008836      [0x5] =  0xe002
140008838  }
140008838  struct UNWIND_INFO data_140008838 = 
140008838  {
140008838      uint8_t VersionAndFlag = 0x1
140008839      uint8_t SizeOfProlog = 0xd
14000883a      uint8_t CountOfUnwindCodes = 0x7
14000883b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14000883c  }
14000883c  uint16_t data_14000883c[0x7] = 
14000883c  {
14000883c      [0x0] =  0x420d
14000883e      [0x1] =  0x3009
140008840      [0x2] =  0x7008
140008842      [0x3] =  0x6007
140008844      [0x4] =  0xc006
140008846      [0x5] =  0xe004
140008848      [0x6] =  0xf002
14000884a  }

14000884a                                00 00                                                                        ..

14000884c  struct UNWIND_INFO data_14000884c = 
14000884c  {
14000884c      uint8_t VersionAndFlag = 0x1
14000884d      uint8_t SizeOfProlog = 0x5
14000884e      uint8_t CountOfUnwindCodes = 0x2
14000884f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008850  }
140008850  uint16_t data_140008850[0x2] = 
140008850  {
140008850      [0x0] =  0x3205
140008852      [0x1] =  0x6001
140008854  }
140008854  struct UNWIND_INFO data_140008854 = 
140008854  {
140008854      uint8_t VersionAndFlag = 0x1
140008855      uint8_t SizeOfProlog = 0xb
140008856      uint8_t CountOfUnwindCodes = 0x6
140008857      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008858  }
140008858  uint16_t data_140008858[0x6] = 
140008858  {
140008858      [0x0] =  0x720b
14000885a      [0x1] =  0x3007
14000885c      [0x2] =  0x7006
14000885e      [0x3] =  0x6005
140008860      [0x4] =  0xe004
140008862      [0x5] =  0xf002
140008864  }
140008864  struct UNWIND_INFO data_140008864 = 
140008864  {
140008864      uint8_t VersionAndFlag = 0x1
140008865      uint8_t SizeOfProlog = 0x7
140008866      uint8_t CountOfUnwindCodes = 0x4
140008867      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008868  }
140008868  uint16_t data_140008868[0x4] = 
140008868  {
140008868      [0x0] =  0x5207
14000886a      [0x1] =  0x3003
14000886c      [0x2] =  0x7002
14000886e      [0x3] =  0x6001
140008870  }
140008870  struct UNWIND_INFO data_140008870 = 
140008870  {
140008870      uint8_t VersionAndFlag = 0x1
140008871      uint8_t SizeOfProlog = 0xb
140008872      uint8_t CountOfUnwindCodes = 0x6
140008873      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008874  }
140008874  uint16_t data_140008874[0x6] = 
140008874  {
140008874      [0x0] =  0x920b
140008876      [0x1] =  0x3007
140008878      [0x2] =  0x7006
14000887a      [0x3] =  0x6005
14000887c      [0x4] =  0xe004
14000887e      [0x5] =  0xf002
140008880  }
140008880  struct UNWIND_INFO data_140008880 = 
140008880  {
140008880      uint8_t VersionAndFlag = 0x1
140008881      uint8_t SizeOfProlog = 0x9
140008882      uint8_t CountOfUnwindCodes = 0x5
140008883      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008884  }
140008884  uint16_t data_140008884[0x5] = 
140008884  {
140008884      [0x0] =  0x6209
140008886      [0x1] =  0x3005
140008888      [0x2] =  0x7004
14000888a      [0x3] =  0x6003
14000888c      [0x4] =  0xe002
14000888e  }

14000888e                                            00 00                                                                ..

140008890  struct UNWIND_INFO data_140008890 = 
140008890  {
140008890      uint8_t VersionAndFlag = 0x1
140008891      uint8_t SizeOfProlog = 0x6
140008892      uint8_t CountOfUnwindCodes = 0x3
140008893      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008894  }
140008894  uint16_t data_140008894[0x3] = 
140008894  {
140008894      [0x0] =  0x6206
140008896      [0x1] =  0x7002
140008898      [0x2] =  0x6001
14000889a  }

14000889a                                                                                00 00                                        ..

14000889c  struct UNWIND_INFO data_14000889c = 
14000889c  {
14000889c      uint8_t VersionAndFlag = 0x1
14000889d      uint8_t SizeOfProlog = 0xb
14000889e      uint8_t CountOfUnwindCodes = 0x6
14000889f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400088a0  }
1400088a0  uint16_t data_1400088a0[0x6] = 
1400088a0  {
1400088a0      [0x0] =  0x320b
1400088a2      [0x1] =  0x3007
1400088a4      [0x2] =  0x7006
1400088a6      [0x3] =  0x6005
1400088a8      [0x4] =  0xe004
1400088aa      [0x5] =  0xf002
1400088ac  }
1400088ac  struct UNWIND_INFO data_1400088ac = 
1400088ac  {
1400088ac      uint8_t VersionAndFlag = 0x1
1400088ad      uint8_t SizeOfProlog = 0x5
1400088ae      uint8_t CountOfUnwindCodes = 0x2
1400088af      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400088b0  }
1400088b0  uint16_t data_1400088b0[0x2] = 
1400088b0  {
1400088b0      [0x0] =  0xb205
1400088b2      [0x1] =  0x6001
1400088b4  }
1400088b4  struct UNWIND_INFO data_1400088b4 = 
1400088b4  {
1400088b4      uint8_t VersionAndFlag = 0x1
1400088b5      uint8_t SizeOfProlog = 0x7
1400088b6      uint8_t CountOfUnwindCodes = 0x4
1400088b7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400088b8  }
1400088b8  uint16_t data_1400088b8[0x4] = 
1400088b8  {
1400088b8      [0x0] =  0x3207
1400088ba      [0x1] =  0x3003
1400088bc      [0x2] =  0x7002
1400088be      [0x3] =  0x6001
1400088c0  }
1400088c0  struct UNWIND_INFO data_1400088c0 = 
1400088c0  {
1400088c0      uint8_t VersionAndFlag = 0x1
1400088c1      uint8_t SizeOfProlog = 0x7
1400088c2      uint8_t CountOfUnwindCodes = 0x4
1400088c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400088c4  }
1400088c4  uint16_t data_1400088c4[0x4] = 
1400088c4  {
1400088c4      [0x0] =  0x9207
1400088c6      [0x1] =  0x3003
1400088c8      [0x2] =  0x7002
1400088ca      [0x3] =  0x6001
1400088cc  }
1400088cc  struct UNWIND_INFO data_1400088cc = 
1400088cc  {
1400088cc      uint8_t VersionAndFlag = 0x1
1400088cd      uint8_t SizeOfProlog = 0x4
1400088ce      uint8_t CountOfUnwindCodes = 0x1
1400088cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400088d0  }
1400088d0  uint16_t data_1400088d0[0x1] = 
1400088d0  {
1400088d0      [0x0] =  0x8204
1400088d2  }

1400088d2                                                        00 00                                                        ..

1400088d4  struct UNWIND_INFO data_1400088d4 = 
1400088d4  {
1400088d4      uint8_t VersionAndFlag = 0x1
1400088d5      uint8_t SizeOfProlog = 0x4
1400088d6      uint8_t CountOfUnwindCodes = 0x1
1400088d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400088d8  }
1400088d8  uint16_t data_1400088d8[0x1] = 
1400088d8  {
1400088d8      [0x0] =  0xa204
1400088da  }

1400088da                                                                                00 00                                        ..

1400088dc  struct UNWIND_INFO data_1400088dc = 
1400088dc  {
1400088dc      uint8_t VersionAndFlag = 0x1
1400088dd      uint8_t SizeOfProlog = 0x10
1400088de      uint8_t CountOfUnwindCodes = 0x9
1400088df      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400088e0  }
1400088e0  uint16_t data_1400088e0[0x9] = 
1400088e0  {
1400088e0      [0x0] =  0x4210
1400088e2      [0x1] =  0x300c
1400088e4      [0x2] =  0x500b
1400088e6      [0x3] =  0x700a
1400088e8      [0x4] =  0x6009
1400088ea      [0x5] =  0xc008
1400088ec      [0x6] =  0xd006
1400088ee      [0x7] =  0xe004
1400088f0      [0x8] =  0xf002
1400088f2  }

1400088f2                                                        00 00                                                        ..

1400088f4  struct UNWIND_INFO data_1400088f4 = 
1400088f4  {
1400088f4      uint8_t VersionAndFlag = 0x1
1400088f5      uint8_t SizeOfProlog = 0xb
1400088f6      uint8_t CountOfUnwindCodes = 0x6
1400088f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400088f8  }
1400088f8  uint16_t data_1400088f8[0x6] = 
1400088f8  {
1400088f8      [0x0] =  0x520b
1400088fa      [0x1] =  0x3007
1400088fc      [0x2] =  0x7006
1400088fe      [0x3] =  0x6005
140008900      [0x4] =  0xe004
140008902      [0x5] =  0xf002
140008904  }
140008904  struct UNWIND_INFO data_140008904 = 
140008904  {
140008904      uint8_t VersionAndFlag = 0x1
140008905      uint8_t SizeOfProlog = 0x15
140008906      uint8_t CountOfUnwindCodes = 0xb
140008907      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008908  }
140008908  uint16_t data_140008908[0xb] = 
140008908  {
140008908      [0x0] =  0x6815
14000890a      [0x1] =  0x0004
14000890c      [0x2] =  0xa210
14000890e      [0x3] =  0x300c
140008910      [0x4] =  0x500b
140008912      [0x5] =  0x700a
140008914      [0x6] =  0x6009
140008916      [0x7] =  0xc008
140008918      [0x8] =  0xd006
14000891a      [0x9] =  0xe004
14000891c      [0xa] =  0xf002
14000891e  }

14000891e                                                                                            00 00                                ..

140008920  struct UNWIND_INFO data_140008920 = 
140008920  {
140008920      uint8_t VersionAndFlag = 0x1
140008921      uint8_t SizeOfProlog = 0xe
140008922      uint8_t CountOfUnwindCodes = 0x6
140008923      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008924  }
140008924  uint16_t data_140008924[0x6] = 
140008924  {
140008924      [0x0] =  0xf20e
140008926      [0x1] =  0x3007
140008928      [0x2] =  0x7006
14000892a      [0x3] =  0x6005
14000892c      [0x4] =  0xe004
14000892e      [0x5] =  0xf002
140008930  }
140008930  struct UNWIND_INFO data_140008930 = 
140008930  {
140008930      uint8_t VersionAndFlag = 0x1
140008931      uint8_t SizeOfProlog = 0x12
140008932      uint8_t CountOfUnwindCodes = 0x6
140008933      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008934  }
140008934  uint16_t data_140008934[0x6] = 
140008934  {
140008934      [0x0] =  0x0112
140008936      [0x1] =  0x0407
140008938      [0x2] =  0x3005
14000893a      [0x3] =  0x7004
14000893c      [0x4] =  0x6003
14000893e      [0x5] =  0xe002
140008940  }
140008940  struct UNWIND_INFO data_140008940 = 
140008940  {
140008940      uint8_t VersionAndFlag = 0x1
140008941      uint8_t SizeOfProlog = 0x18
140008942      uint8_t CountOfUnwindCodes = 0x9
140008943      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008944  }
140008944  uint16_t data_140008944[0x9] = 
140008944  {
140008944      [0x0] =  0x0118
140008946      [0x1] =  0x0408
140008948      [0x2] =  0x300b
14000894a      [0x3] =  0x700a
14000894c      [0x4] =  0x6009
14000894e      [0x5] =  0xc008
140008950      [0x6] =  0xd006
140008952      [0x7] =  0xe004
140008954      [0x8] =  0xf002
140008956  }

140008956                                                                    00 00                                                ..

140008958  struct UNWIND_INFO data_140008958 = 
140008958  {
140008958      uint8_t VersionAndFlag = 0x1
140008959      uint8_t SizeOfProlog = 0x10
14000895a      uint8_t CountOfUnwindCodes = 0x9
14000895b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14000895c  }
14000895c  uint16_t data_14000895c[0x9] = 
14000895c  {
14000895c      [0x0] =  0xc210
14000895e      [0x1] =  0x300c
140008960      [0x2] =  0x500b
140008962      [0x3] =  0x700a
140008964      [0x4] =  0x6009
140008966      [0x5] =  0xc008
140008968      [0x6] =  0xd006
14000896a      [0x7] =  0xe004
14000896c      [0x8] =  0xf002
14000896e  }

14000896e                                            00 00                                                                ..

140008970  struct UNWIND_INFO data_140008970 = 
140008970  {
140008970      uint8_t VersionAndFlag = 0x1
140008971      uint8_t SizeOfProlog = 0x5
140008972      uint8_t CountOfUnwindCodes = 0x2
140008973      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008974  }
140008974  uint16_t data_140008974[0x2] = 
140008974  {
140008974      [0x0] =  0x5205
140008976      [0x1] =  0x6001
140008978  }
140008978  struct UNWIND_INFO data_140008978 = 
140008978  {
140008978      uint8_t VersionAndFlag = 0x1
140008979      uint8_t SizeOfProlog = 0xf
14000897a      uint8_t CountOfUnwindCodes = 0x8
14000897b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14000897c  }
14000897c  uint16_t data_14000897c[0x8] = 
14000897c  {
14000897c      [0x0] =  0x520f
14000897e      [0x1] =  0x300b
140008980      [0x2] =  0x700a
140008982      [0x3] =  0x6009
140008984      [0x4] =  0xc008
140008986      [0x5] =  0xd006
140008988      [0x6] =  0xe004
14000898a      [0x7] =  0xf002
14000898c  }
14000898c  struct UNWIND_INFO data_14000898c = 
14000898c  {
14000898c      uint8_t VersionAndFlag = 0x1
14000898d      uint8_t SizeOfProlog = 0x10
14000898e      uint8_t CountOfUnwindCodes = 0x9
14000898f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008990  }
140008990  uint16_t data_140008990[0x9] = 
140008990  {
140008990      [0x0] =  0x8210
140008992      [0x1] =  0x300c
140008994      [0x2] =  0x500b
140008996      [0x3] =  0x700a
140008998      [0x4] =  0x6009
14000899a      [0x5] =  0xc008
14000899c      [0x6] =  0xd006
14000899e      [0x7] =  0xe004
1400089a0      [0x8] =  0xf002
1400089a2  }

1400089a2        00 00                                                                                        ..

1400089a4  struct UNWIND_INFO data_1400089a4 = 
1400089a4  {
1400089a4      uint8_t VersionAndFlag = 0x1
1400089a5      uint8_t SizeOfProlog = 0x10
1400089a6      uint8_t CountOfUnwindCodes = 0x9
1400089a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400089a8  }
1400089a8  uint16_t data_1400089a8[0x9] = 
1400089a8  {
1400089a8      [0x0] =  0x6210
1400089aa      [0x1] =  0x300c
1400089ac      [0x2] =  0x500b
1400089ae      [0x3] =  0x700a
1400089b0      [0x4] =  0x6009
1400089b2      [0x5] =  0xc008
1400089b4      [0x6] =  0xd006
1400089b6      [0x7] =  0xe004
1400089b8      [0x8] =  0xf002
1400089ba  }

1400089ba                                                                                00 00                                        ..

1400089bc  struct UNWIND_INFO data_1400089bc = 
1400089bc  {
1400089bc      uint8_t VersionAndFlag = 0x1
1400089bd      uint8_t SizeOfProlog = 0x5
1400089be      uint8_t CountOfUnwindCodes = 0x4
1400089bf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400089c0  }
1400089c0  uint16_t data_1400089c0[0x4] = 
1400089c0  {
1400089c0      [0x0] =  0x3005
1400089c2      [0x1] =  0x7004
1400089c4      [0x2] =  0x6003
1400089c6      [0x3] =  0xe002
1400089c8  }
1400089c8  struct UNWIND_INFO data_1400089c8 = 
1400089c8  {
1400089c8      uint8_t VersionAndFlag = 0x1
1400089c9      uint8_t SizeOfProlog = 0x7
1400089ca      uint8_t CountOfUnwindCodes = 0x5
1400089cb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400089cc  }
1400089cc  uint16_t data_1400089cc[0x5] = 
1400089cc  {
1400089cc      [0x0] =  0x3007
1400089ce      [0x1] =  0x7006
1400089d0      [0x2] =  0x6005
1400089d2      [0x3] =  0xe004
1400089d4      [0x4] =  0xf002
1400089d6  }

1400089d6                                                                    00 00                                                ..

1400089d8  struct UNWIND_INFO data_1400089d8 = 
1400089d8  {
1400089d8      uint8_t VersionAndFlag = 0x1
1400089d9      uint8_t SizeOfProlog = 0x6
1400089da      uint8_t CountOfUnwindCodes = 0x5
1400089db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400089dc  }
1400089dc  uint16_t data_1400089dc[0x5] = 
1400089dc  {
1400089dc      [0x0] =  0x3006
1400089de      [0x1] =  0x5005
1400089e0      [0x2] =  0x7004
1400089e2      [0x3] =  0x6003
1400089e4      [0x4] =  0xe002
1400089e6  }

1400089e6                    00 00                                                                                ..

1400089e8  struct UNWIND_INFO data_1400089e8 = 
1400089e8  {
1400089e8      uint8_t VersionAndFlag = 0x1
1400089e9      uint8_t SizeOfProlog = 0x36
1400089ea      uint8_t CountOfUnwindCodes = 0x14
1400089eb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400089ec  }
1400089ec  uint16_t data_1400089ec[0x14] = 
1400089ec  {
1400089ec      [0x00] =  0x6836
1400089ee      [0x01] =  0x0000
1400089f0      [0x02] =  0x7831
1400089f2      [0x03] =  0x0001
1400089f4      [0x04] =  0x882b
1400089f6      [0x05] =  0x0002
1400089f8      [0x06] =  0x9824
1400089fa      [0x07] =  0x0003
1400089fc      [0x08] =  0xa81d
1400089fe      [0x09] =  0x0004
140008a00      [0x0a] =  0xb816
140008a02      [0x0b] =  0x0005
140008a04      [0x0c] =  0xb20f
140008a06      [0x0d] =  0x300b
140008a08      [0x0e] =  0x700a
140008a0a      [0x0f] =  0x6009
140008a0c      [0x10] =  0xc008
140008a0e      [0x11] =  0xd006
140008a10      [0x12] =  0xe004
140008a12      [0x13] =  0xf002
140008a14  }
140008a14  struct UNWIND_INFO data_140008a14 = 
140008a14  {
140008a14      uint8_t VersionAndFlag = 0x1
140008a15      uint8_t SizeOfProlog = 0x6
140008a16      uint8_t CountOfUnwindCodes = 0x2
140008a17      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008a18  }
140008a18  uint16_t data_140008a18[0x2] = 
140008a18  {
140008a18      [0x0] =  0x3206
140008a1a      [0x1] =  0x3002
140008a1c  }
140008a1c  struct UNWIND_INFO data_140008a1c = 
140008a1c  {
140008a1c      uint8_t VersionAndFlag = 0x9
140008a1d      uint8_t SizeOfProlog = 0xf
140008a1e      uint8_t CountOfUnwindCodes = 0x6
140008a1f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008a20  }
140008a20  uint16_t data_140008a20[0x6] = 
140008a20  {
140008a20      [0x0] =  0x640f
140008a22      [0x1] =  0x0009
140008a24      [0x2] =  0x340f
140008a26      [0x3] =  0x0008
140008a28      [0x4] =  0x520f
140008a2a      [0x5] =  0x700b
140008a2c  }
140008a2c  uint32_t data_140008a2c = 0x5f08

140008a30                                                  02 00 00 00 4d 54 00 00 52 55 00 00 02 67 00 00                  ....MT..RU...g..
140008a40  52 55 00 00 86 55 00 00 98 55 00 00 02 67 00 00 52 55 00 00                                      RU...U...U...g..RU..

140008a54  struct UNWIND_INFO data_140008a54 = 
140008a54  {
140008a54      uint8_t VersionAndFlag = 0x1
140008a55      uint8_t SizeOfProlog = 0x6
140008a56      uint8_t CountOfUnwindCodes = 0x2
140008a57      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008a58  }
140008a58  uint16_t data_140008a58[0x2] = 
140008a58  {
140008a58      [0x0] =  0x3206
140008a5a      [0x1] =  0x5002
140008a5c  }

140008a5c                                                                                      00 00 00 00                              ....

140008a60  struct UNWIND_INFO data_140008a60 = 
140008a60  {
140008a60      uint8_t VersionAndFlag = 0x1
140008a61      uint8_t SizeOfProlog = 0x4
140008a62      uint8_t CountOfUnwindCodes = 0x1
140008a63      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008a64  }
140008a64  uint16_t data_140008a64[0x1] = 
140008a64  {
140008a64      [0x0] =  0x1204
140008a66  }

140008a66                    00 00                                                                                ..

140008a68  struct UNWIND_INFO data_140008a68 = 
140008a68  {
140008a68      uint8_t VersionAndFlag = 0x9
140008a69      uint8_t SizeOfProlog = 0x4
140008a6a      uint8_t CountOfUnwindCodes = 0x1
140008a6b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008a6c  }
140008a6c  uint16_t data_140008a6c[0x1] = 
140008a6c  {
140008a6c      [0x0] =  0x2204
140008a6e  }

140008a6e                                            00 00                                                                ..

140008a70  uint32_t data_140008a70 = 0x5f08

140008a74                                                              01 00 00 00 2b 57 00 00 b5 57 00 00                      ....+W...W..
140008a80  20 67 00 00 b5 57 00 00                                                                           g...W..

140008a88  struct UNWIND_INFO data_140008a88 = 
140008a88  {
140008a88      uint8_t VersionAndFlag = 0x1
140008a89      uint8_t SizeOfProlog = 0x2
140008a8a      uint8_t CountOfUnwindCodes = 0x1
140008a8b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008a8c  }
140008a8c  uint16_t data_140008a8c[0x1] = 
140008a8c  {
140008a8c      [0x0] =  0x5002
140008a8e  }

140008a8e                                            00 00                                                                ..

140008a90  struct UNWIND_INFO data_140008a90 = 
140008a90  {
140008a90      uint8_t VersionAndFlag = 0x1
140008a91      uint8_t SizeOfProlog = 0xd
140008a92      uint8_t CountOfUnwindCodes = 0x4
140008a93      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008a94  }
140008a94  uint16_t data_140008a94[0x4] = 
140008a94  {
140008a94      [0x0] =  0x340d
140008a96      [0x1] =  0x000a
140008a98      [0x2] =  0x520d
140008a9a      [0x3] =  0x5006
140008a9c  }
140008a9c  struct UNWIND_INFO data_140008a9c = 
140008a9c  {
140008a9c      uint8_t VersionAndFlag = 0x1
140008a9d      uint8_t SizeOfProlog = 0x15
140008a9e      uint8_t CountOfUnwindCodes = 0x5
140008a9f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008aa0  }
140008aa0  uint16_t data_140008aa0[0x5] = 
140008aa0  {
140008aa0      [0x0] =  0x3415
140008aa2      [0x1] =  0x00ba
140008aa4      [0x2] =  0x0115
140008aa6      [0x3] =  0x00b8
140008aa8      [0x4] =  0x5006
140008aaa  }

140008aaa                                00 00                                                                        ..

140008aac  struct UNWIND_INFO data_140008aac = 
140008aac  {
140008aac      uint8_t VersionAndFlag = 0x1
140008aad      uint8_t SizeOfProlog = 0xa
140008aae      uint8_t CountOfUnwindCodes = 0x4
140008aaf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008ab0  }
140008ab0  uint16_t data_140008ab0[0x4] = 
140008ab0  {
140008ab0      [0x0] =  0x340a
140008ab2      [0x1] =  0x0006
140008ab4      [0x2] =  0x320a
140008ab6      [0x3] =  0x7006
140008ab8  }
140008ab8  struct UNWIND_INFO data_140008ab8 = 
140008ab8  {
140008ab8      uint8_t VersionAndFlag = 0x1
140008ab9      uint8_t SizeOfProlog = 0x15
140008aba      uint8_t CountOfUnwindCodes = 0x8
140008abb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008abc  }
140008abc  uint16_t data_140008abc[0x8] = 
140008abc  {
140008abc      [0x0] =  0x6415
140008abe      [0x1] =  0x0008
140008ac0      [0x2] =  0x3415
140008ac2      [0x3] =  0x0007
140008ac4      [0x4] =  0x1215
140008ac6      [0x5] =  0xe00e
140008ac8      [0x6] =  0x700c
140008aca      [0x7] =  0x500b
140008acc  }

140008acc                                      00 00 00 00                                                              ....

140008ad0  struct UNWIND_INFO data_140008ad0 = 
140008ad0  {
140008ad0      uint8_t VersionAndFlag = 0x1
140008ad1      uint8_t SizeOfProlog = 0x0
140008ad2      uint8_t CountOfUnwindCodes = 0x0
140008ad3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008ad4  }

140008ad4                                                              00 00 00 00                                              ....

140008ad8  struct UNWIND_INFO data_140008ad8 = 
140008ad8  {
140008ad8      uint8_t VersionAndFlag = 0x1
140008ad9      uint8_t SizeOfProlog = 0x0
140008ada      uint8_t CountOfUnwindCodes = 0x0
140008adb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140008adc  }
140008adc  struct Import_Directory_Table __import_directory_entries[0xa] = 
140008adc  {
140008adc      [0x0] = 
140008adc      {
140008adc          uint32_t importLookupTableRva = 0x8d18
140008ae0          uint32_t timeDateStamp = 0x0
140008ae4          uint32_t forwarderChain = 0x0
140008ae8          uint32_t nameRva = 0x8e72
140008aec          uint32_t importAddressTableRva = 0x7148
140008af0      }
140008af0      [0x1] = 
140008af0      {
140008af0          uint32_t importLookupTableRva = 0x8bd0
140008af4          uint32_t timeDateStamp = 0x0
140008af8          uint32_t forwarderChain = 0x0
140008afc          uint32_t nameRva = 0x907e
140008b00          uint32_t importAddressTableRva = 0x7000
140008b04      }
140008b04      [0x2] = 
140008b04      {
140008b04          uint32_t importLookupTableRva = 0x8e18
140008b08          uint32_t timeDateStamp = 0x0
140008b0c          uint32_t forwarderChain = 0x0
140008b10          uint32_t nameRva = 0x90c0
140008b14          uint32_t importAddressTableRva = 0x7248
140008b18      }
140008b18      [0x3] = 
140008b18      {
140008b18          uint32_t importLookupTableRva = 0x8cd8
140008b1c          uint32_t timeDateStamp = 0x0
140008b20          uint32_t forwarderChain = 0x0
140008b24          uint32_t nameRva = 0x913e
140008b28          uint32_t importAddressTableRva = 0x7108
140008b2c      }
140008b2c      [0x4] = 
140008b2c      {
140008b2c          uint32_t importLookupTableRva = 0x8d68
140008b30          uint32_t timeDateStamp = 0x0
140008b34          uint32_t forwarderChain = 0x0
140008b38          uint32_t nameRva = 0x9302
140008b3c          uint32_t importAddressTableRva = 0x7198
140008b40      }
140008b40      [0x5] = 
140008b40      {
140008b40          uint32_t importLookupTableRva = 0x8d58
140008b44          uint32_t timeDateStamp = 0x0
140008b48          uint32_t forwarderChain = 0x0
140008b4c          uint32_t nameRva = 0x9324
140008b50          uint32_t importAddressTableRva = 0x7188
140008b54      }
140008b54      [0x6] = 
140008b54      {
140008b54          uint32_t importLookupTableRva = 0x8e00
140008b58          uint32_t timeDateStamp = 0x0
140008b5c          uint32_t forwarderChain = 0x0
140008b60          uint32_t nameRva = 0x9344
140008b64          uint32_t importAddressTableRva = 0x7230
140008b68      }
140008b68      [0x7] = 
140008b68      {
140008b68          uint32_t importLookupTableRva = 0x8d48
140008b6c          uint32_t timeDateStamp = 0x0
140008b70          uint32_t forwarderChain = 0x0
140008b74          uint32_t nameRva = 0x9364
140008b78          uint32_t importAddressTableRva = 0x7178
140008b7c      }
140008b7c      [0x8] = 
140008b7c      {
140008b7c          uint32_t importLookupTableRva = 0x8d38
140008b80          uint32_t timeDateStamp = 0x0
140008b84          uint32_t forwarderChain = 0x0
140008b88          uint32_t nameRva = 0x9386
140008b8c          uint32_t importAddressTableRva = 0x7168
140008b90      }
140008b90      [0x9] = 
140008b90      {
140008b90          uint32_t importLookupTableRva = 0x0
140008b94          uint32_t timeDateStamp = 0x0
140008b98          uint32_t forwarderChain = 0x0
140008b9c          uint32_t nameRva = 0x0
140008ba0          uint32_t importAddressTableRva = 0x0
140008ba4      }
140008ba4  }

140008ba4              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
140008bc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

140008bd0  uint64_t __import_lookup_table_1(KERNEL32:SetUnhandledExceptionFilter) = 0x941c
140008bd8  uint64_t __import_lookup_table_1(KERNEL32:UnhandledExceptionFilter) = 0x9400
140008be0  uint64_t __import_lookup_table_1(KERNEL32:IsDebuggerPresent) = 0x93ec
140008be8  uint64_t __import_lookup_table_1(KERNEL32:InitializeSListHead) = 0x93d6
140008bf0  uint64_t __import_lookup_table_1(KERNEL32:WaitForSingleObject) = 0x8e94
140008bf8  uint64_t __import_lookup_table_1(KERNEL32:GetLastError) = 0x8eaa
140008c00  uint64_t __import_lookup_table_1(KERNEL32:GetStdHandle) = 0x8eba
140008c08  uint64_t __import_lookup_table_1(KERNEL32:SetThreadStackGuarantee) = 0x8eca
140008c10  uint64_t __import_lookup_table_1(KERNEL32:AddVectoredExceptionHandler) = 0x8ee4
140008c18  uint64_t __import_lookup_table_1(KERNEL32:GetCurrentThread) = 0x8f02
140008c20  uint64_t __import_lookup_table_1(KERNEL32:GetProcessHeap) = 0x8f16
140008c28  uint64_t __import_lookup_table_1(KERNEL32:HeapFree) = 0x8f28
140008c30  uint64_t __import_lookup_table_1(KERNEL32:RtlCaptureContext) = 0x8f34
140008c38  uint64_t __import_lookup_table_1(KERNEL32:RtlLookupFunctionEntry) = 0x8f48
140008c40  uint64_t __import_lookup_table_1(KERNEL32:RtlVirtualUnwind) = 0x8f62
140008c48  uint64_t __import_lookup_table_1(KERNEL32:HeapReAlloc) = 0x8f76
140008c50  uint64_t __import_lookup_table_1(KERNEL32:QueryPerformanceCounter) = 0x8f84
140008c58  uint64_t __import_lookup_table_1(KERNEL32:GetCurrentProcessId) = 0x8f9e
140008c60  uint64_t __import_lookup_table_1(KERNEL32:GetModuleHandleW) = 0x8fb4
140008c68  uint64_t __import_lookup_table_1(KERNEL32:GetConsoleMode) = 0x8fc8
140008c70  uint64_t __import_lookup_table_1(KERNEL32:GetProcAddress) = 0x8fda
140008c78  uint64_t __import_lookup_table_1(KERNEL32:HeapAlloc) = 0x8fec
140008c80  uint64_t __import_lookup_table_1(KERNEL32:GetModuleHandleA) = 0x8ff8
140008c88  uint64_t __import_lookup_table_1(KERNEL32:SetLastError) = 0x900c
140008c90  uint64_t __import_lookup_table_1(KERNEL32:GetConsoleOutputCP) = 0x901c
140008c98  uint64_t __import_lookup_table_1(KERNEL32:MultiByteToWideChar) = 0x9032
140008ca0  uint64_t __import_lookup_table_1(KERNEL32:WriteConsoleW) = 0x9048
140008ca8  uint64_t __import_lookup_table_1(KERNEL32:WideCharToMultiByte) = 0x9058
140008cb0  uint64_t __import_lookup_table_1(KERNEL32:ReadConsoleW) = 0x906e
140008cb8  uint64_t __import_lookup_table_1(KERNEL32:IsProcessorFeaturePresent) = 0x943a
140008cc0  uint64_t __import_lookup_table_1(KERNEL32:GetSystemTimeAsFileTime) = 0x93bc
140008cc8  uint64_t __import_lookup_table_1(KERNEL32:GetCurrentThreadId) = 0x93a6
140008cd0  uint64_t data_140008cd0 = 0x0
140008cd8  uint64_t __import_lookup_table_3(VCRUNTIME140:__current_exception) = 0x910a
140008ce0  uint64_t __import_lookup_table_3(VCRUNTIME140:__current_exception_context) = 0x9120
140008ce8  uint64_t __import_lookup_table_3(VCRUNTIME140:__C_specific_handler) = 0x90f2
140008cf0  uint64_t __import_lookup_table_3(VCRUNTIME140:memmove) = 0x90e8
140008cf8  uint64_t __import_lookup_table_3(VCRUNTIME140:memset) = 0x90de
140008d00  uint64_t __import_lookup_table_3(VCRUNTIME140:memcmp) = 0x90d4
140008d08  uint64_t __import_lookup_table_3(VCRUNTIME140:memcpy) = 0x90ca
140008d10  uint64_t data_140008d10 = 0x0
140008d18  uint64_t __import_lookup_table_0(api-ms-win-core-synch-l1-2-0:WaitOnAddress) = 0x8e4e
140008d20  uint64_t __import_lookup_table_0(api-ms-win-core-synch-l1-2-0:WakeByAddressAll) = 0x8e5e
140008d28  uint64_t __import_lookup_table_0(api-ms-win-core-synch-l1-2-0:WakeByAddressSingle) = 0x8e38
140008d30  uint64_t data_140008d30 = 0x0
140008d38  uint64_t __import_lookup_table_8(api-ms-win-crt-heap-l1-1-0:_set_new_mode) = 0x9290
140008d40  uint64_t data_140008d40 = 0x0
140008d48  uint64_t __import_lookup_table_7(api-ms-win-crt-locale-l1-1-0:_configthreadlocale) = 0x927a
140008d50  uint64_t data_140008d50 = 0x0
140008d58  uint64_t __import_lookup_table_5(api-ms-win-crt-math-l1-1-0:__setusermatherr) = 0x9172
140008d60  uint64_t data_140008d60 = 0x0
140008d68  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_initterm) = 0x91e4
140008d70  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_initterm_e) = 0x91f0
140008d78  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:exit) = 0x91fe
140008d80  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_exit) = 0x9206
140008d88  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_initialize_narrow_environment) = 0x91a0
140008d90  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:__p___argc) = 0x921c
140008d98  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:__p___argv) = 0x922a
140008da0  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_set_app_type) = 0x9162
140008da8  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_c_exit) = 0x9242
140008db0  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_register_thread_local_exe_atexit_callback) = 0x924c
140008db8  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_configure_narrow_argv) = 0x9186
140008dc0  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_seh_filter_exe) = 0x9150
140008dc8  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_get_initial_narrow_environment) = 0x91c2
140008dd0  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_initialize_onexit_table) = 0x92b0
140008dd8  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_register_onexit_function) = 0x92cc
140008de0  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_crt_atexit) = 0x92e8
140008de8  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:terminate) = 0x92f6
140008df0  uint64_t __import_lookup_table_4(api-ms-win-crt-runtime-l1-1-0:_cexit) = 0x9238
140008df8  uint64_t data_140008df8 = 0x0
140008e00  uint64_t __import_lookup_table_6(api-ms-win-crt-stdio-l1-1-0:_set_fmode) = 0x920e
140008e08  uint64_t __import_lookup_table_6(api-ms-win-crt-stdio-l1-1-0:__p__commode) = 0x92a0
140008e10  uint64_t data_140008e10 = 0x0
140008e18  uint64_t __import_lookup_table_2(ntdll:RtlNtStatusToDosError) = 0x909a
140008e20  uint64_t __import_lookup_table_2(ntdll:NtReadFile) = 0x90b2
140008e28  uint64_t __import_lookup_table_2(ntdll:NtWriteFile) = 0x908c
140008e30  uint64_t data_140008e30 = 0x0
140008e38  uint16_t __export_name_ptr_table_0(api-ms-win-core-synch-l1-2-0:WakeByAddressSingle) = 0x0
140008e3a  char __import_name_0(api-ms-win-core-synch-l1-2-0:WakeByAddressSingle)[0x14] = "WakeByAddressSingle", 0
140008e4e  uint16_t __export_name_ptr_table_0(api-ms-win-core-synch-l1-2-0:WaitOnAddress) = 0x0
140008e50  char __import_name_0(api-ms-win-core-synch-l1-2-0:WaitOnAddress)[0xe] = "WaitOnAddress", 0
140008e5e  uint16_t __export_name_ptr_table_0(api-ms-win-core-synch-l1-2-0:WakeByAddressAll) = 0x0
140008e60  char __import_name_0(api-ms-win-core-synch-l1-2-0:WakeByAddressAll)[0x11] = "WakeByAddressAll", 0

140008e71                                                     00                                                             .

140008e72  char __import_dll_name(api-ms-win-core-synch-l1-2-0)[0x21] = "api-ms-win-core-synch-l1-2-0.dll", 0

140008e93                                                           00                                                         .

140008e94  uint16_t __export_name_ptr_table_1(KERNEL32:WaitForSingleObject) = 0x602
140008e96  char __import_name_1(KERNEL32:WaitForSingleObject)[0x14] = "WaitForSingleObject", 0
140008eaa  uint16_t __export_name_ptr_table_1(KERNEL32:GetLastError) = 0x274
140008eac  char __import_name_1(KERNEL32:GetLastError)[0xd] = "GetLastError", 0

140008eb9                                                                             00                                             .

140008eba  uint16_t __export_name_ptr_table_1(KERNEL32:GetStdHandle) = 0x2ea
140008ebc  char __import_name_1(KERNEL32:GetStdHandle)[0xd] = "GetStdHandle", 0

140008ec9                             00                                                                             .

140008eca  uint16_t __export_name_ptr_table_1(KERNEL32:SetThreadStackGuarantee) = 0x58a
140008ecc  char __import_name_1(KERNEL32:SetThreadStackGuarantee)[0x18] = "SetThreadStackGuarantee", 0
140008ee4  uint16_t __export_name_ptr_table_1(KERNEL32:AddVectoredExceptionHandler) = 0x14
140008ee6  char __import_name_1(KERNEL32:AddVectoredExceptionHandler)[0x1c] = "AddVectoredExceptionHandler", 0
140008f02  uint16_t __export_name_ptr_table_1(KERNEL32:GetCurrentThread) = 0x22e
140008f04  char __import_name_1(KERNEL32:GetCurrentThread)[0x11] = "GetCurrentThread", 0

140008f15                                                                 00                                                     .

140008f16  uint16_t __export_name_ptr_table_1(KERNEL32:GetProcessHeap) = 0x2cb
140008f18  char __import_name_1(KERNEL32:GetProcessHeap)[0xf] = "GetProcessHeap", 0

140008f27                       00                                                                                 .

140008f28  uint16_t __export_name_ptr_table_1(KERNEL32:HeapFree) = 0x367
140008f2a  char __import_name_1(KERNEL32:HeapFree)[0x9] = "HeapFree", 0

140008f33                                                           00                                                         .

140008f34  uint16_t __export_name_ptr_table_1(KERNEL32:RtlCaptureContext) = 0x4e9
140008f36  char __import_name_1(KERNEL32:RtlCaptureContext)[0x12] = "RtlCaptureContext", 0
140008f48  uint16_t __export_name_ptr_table_1(KERNEL32:RtlLookupFunctionEntry) = 0x4f1
140008f4a  char __import_name_1(KERNEL32:RtlLookupFunctionEntry)[0x17] = "RtlLookupFunctionEntry", 0

140008f61     00                                                                                             .

140008f62  uint16_t __export_name_ptr_table_1(KERNEL32:RtlVirtualUnwind) = 0x4f8
140008f64  char __import_name_1(KERNEL32:RtlVirtualUnwind)[0x11] = "RtlVirtualUnwind", 0

140008f75                                                                 00                                                     .

140008f76  uint16_t __export_name_ptr_table_1(KERNEL32:HeapReAlloc) = 0x36a
140008f78  char __import_name_1(KERNEL32:HeapReAlloc)[0xc] = "HeapReAlloc", 0
140008f84  uint16_t __export_name_ptr_table_1(KERNEL32:QueryPerformanceCounter) = 0x464
140008f86  char __import_name_1(KERNEL32:QueryPerformanceCounter)[0x18] = "QueryPerformanceCounter", 0
140008f9e  uint16_t __export_name_ptr_table_1(KERNEL32:GetCurrentProcessId) = 0x22b
140008fa0  char __import_name_1(KERNEL32:GetCurrentProcessId)[0x14] = "GetCurrentProcessId", 0
140008fb4  uint16_t __export_name_ptr_table_1(KERNEL32:GetModuleHandleW) = 0x28c
140008fb6  char __import_name_1(KERNEL32:GetModuleHandleW)[0x11] = "GetModuleHandleW", 0

140008fc7                       00                                                                                 .

140008fc8  uint16_t __export_name_ptr_table_1(KERNEL32:GetConsoleMode) = 0x20e
140008fca  char __import_name_1(KERNEL32:GetConsoleMode)[0xf] = "GetConsoleMode", 0

140008fd9                                                                             00                                             .

140008fda  uint16_t __export_name_ptr_table_1(KERNEL32:GetProcAddress) = 0x2c4
140008fdc  char __import_name_1(KERNEL32:GetProcAddress)[0xf] = "GetProcAddress", 0

140008feb                                   00                                                                         .

140008fec  uint16_t __export_name_ptr_table_1(KERNEL32:HeapAlloc) = 0x363
140008fee  char __import_name_1(KERNEL32:HeapAlloc)[0xa] = "HeapAlloc", 0
140008ff8  uint16_t __export_name_ptr_table_1(KERNEL32:GetModuleHandleA) = 0x289
140008ffa  char __import_name_1(KERNEL32:GetModuleHandleA)[0x11] = "GetModuleHandleA", 0

14000900b                                   00                                                                         .

14000900c  uint16_t __export_name_ptr_table_1(KERNEL32:SetLastError) = 0x557
14000900e  char __import_name_1(KERNEL32:SetLastError)[0xd] = "SetLastError", 0

14000901b                                                                                   00                                         .

14000901c  uint16_t __export_name_ptr_table_1(KERNEL32:GetConsoleOutputCP) = 0x212
14000901e  char __import_name_1(KERNEL32:GetConsoleOutputCP)[0x13] = "GetConsoleOutputCP", 0

140009031                                                     00                                                             .

140009032  uint16_t __export_name_ptr_table_1(KERNEL32:MultiByteToWideChar) = 0x408
140009034  char __import_name_1(KERNEL32:MultiByteToWideChar)[0x14] = "MultiByteToWideChar", 0
140009048  uint16_t __export_name_ptr_table_1(KERNEL32:WriteConsoleW) = 0x63c
14000904a  char __import_name_1(KERNEL32:WriteConsoleW)[0xe] = "WriteConsoleW", 0
140009058  uint16_t __export_name_ptr_table_1(KERNEL32:WideCharToMultiByte) = 0x629
14000905a  char __import_name_1(KERNEL32:WideCharToMultiByte)[0x14] = "WideCharToMultiByte", 0
14000906e  uint16_t __export_name_ptr_table_1(KERNEL32:ReadConsoleW) = 0x489
140009070  char __import_name_1(KERNEL32:ReadConsoleW)[0xd] = "ReadConsoleW", 0

14000907d                                                                                         00                                     .

14000907e  char __import_dll_name(KERNEL32)[0xd] = "KERNEL32.dll", 0

14000908b                                   00                                                                         .

14000908c  uint16_t __export_name_ptr_table_2(ntdll:NtWriteFile) = 0x29d
14000908e  char __import_name_2(ntdll:NtWriteFile)[0xc] = "NtWriteFile", 0
14000909a  uint16_t __export_name_ptr_table_2(ntdll:RtlNtStatusToDosError) = 0x515
14000909c  char __import_name_2(ntdll:RtlNtStatusToDosError)[0x16] = "RtlNtStatusToDosError", 0
1400090b2  uint16_t __export_name_ptr_table_2(ntdll:NtReadFile) = 0x210
1400090b4  char __import_name_2(ntdll:NtReadFile)[0xb] = "NtReadFile", 0

1400090bf                                                                                               00                                 .

1400090c0  char __import_dll_name(ntdll)[0xa] = "ntdll.dll", 0
1400090ca  uint16_t __export_name_ptr_table_3(VCRUNTIME140:memcpy) = 0x3c
1400090cc  char __import_name_3(VCRUNTIME140:memcpy)[0x7] = "memcpy", 0

1400090d3                                                           00                                                         .

1400090d4  uint16_t __export_name_ptr_table_3(VCRUNTIME140:memcmp) = 0x3b
1400090d6  char __import_name_3(VCRUNTIME140:memcmp)[0x7] = "memcmp", 0

1400090dd                                                                                         00                                     .

1400090de  uint16_t __export_name_ptr_table_3(VCRUNTIME140:memset) = 0x3e
1400090e0  char __import_name_3(VCRUNTIME140:memset)[0x7] = "memset", 0

1400090e7                       00                                                                                 .

1400090e8  uint16_t __export_name_ptr_table_3(VCRUNTIME140:memmove) = 0x3d
1400090ea  char __import_name_3(VCRUNTIME140:memmove)[0x8] = "memmove", 0
1400090f2  uint16_t __export_name_ptr_table_3(VCRUNTIME140:__C_specific_handler) = 0x8
1400090f4  char __import_name_3(VCRUNTIME140:__C_specific_handler)[0x15] = "__C_specific_handler", 0

140009109                             00                                                                             .

14000910a  uint16_t __export_name_ptr_table_3(VCRUNTIME140:__current_exception) = 0x1b
14000910c  char __import_name_3(VCRUNTIME140:__current_exception)[0x14] = "__current_exception", 0
140009120  uint16_t __export_name_ptr_table_3(VCRUNTIME140:__current_exception_context) = 0x1c
140009122  char __import_name_3(VCRUNTIME140:__current_exception_context)[0x1c] = "__current_exception_context", 0
14000913e  char __import_dll_name(VCRUNTIME140)[0x11] = "VCRUNTIME140.dll", 0

14000914f                                               00                                                                 .

140009150  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_seh_filter_exe) = 0x40
140009152  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_seh_filter_exe)[0x10] = "_seh_filter_exe", 0
140009162  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_set_app_type) = 0x42
140009164  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_set_app_type)[0xe] = "_set_app_type", 0
140009172  uint16_t __export_name_ptr_table_5(api-ms-win-crt-math-l1-1-0:__setusermatherr) = 0x9
140009174  char __import_name_5(api-ms-win-crt-math-l1-1-0:__setusermatherr)[0x11] = "__setusermatherr", 0

140009185                 00                                                                                     .

140009186  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_configure_narrow_argv) = 0x18
140009188  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_configure_narrow_argv)[0x17] = "_configure_narrow_argv", 0

14000919f                                                                                               00                                 .

1400091a0  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_initialize_narrow_environment) = 0x33
1400091a2  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_initialize_narrow_environment)[0x1f] = "_initialize_narrow_environment", 0

1400091c1     00                                                                                             .

1400091c2  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_get_initial_narrow_environment) = 0x28
1400091c4  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_get_initial_narrow_environment)[0x20] = "_get_initial_narrow_environment", 0
1400091e4  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_initterm) = 0x36
1400091e6  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_initterm)[0xa] = "_initterm", 0
1400091f0  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_initterm_e) = 0x37
1400091f2  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_initterm_e)[0xc] = "_initterm_e", 0
1400091fe  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:exit) = 0x55
140009200  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:exit)[0x5] = "exit", 0

140009205                 00                                                                                     .

140009206  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_exit) = 0x23
140009208  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_exit)[0x6] = "_exit", 0
14000920e  uint16_t __export_name_ptr_table_6(api-ms-win-crt-stdio-l1-1-0:_set_fmode) = 0x54
140009210  char __import_name_6(api-ms-win-crt-stdio-l1-1-0:_set_fmode)[0xb] = "_set_fmode", 0

14000921b                                                                                   00                                         .

14000921c  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:__p___argc) = 0x4
14000921e  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:__p___argc)[0xb] = "__p___argc", 0

140009229                             00                                                                             .

14000922a  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:__p___argv) = 0x5
14000922c  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:__p___argv)[0xb] = "__p___argv", 0

140009237                                                                       00                                                 .

140009238  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_cexit) = 0x16
14000923a  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_cexit)[0x7] = "_cexit", 0

140009241     00                                                                                             .

140009242  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_c_exit) = 0x15
140009244  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_c_exit)[0x8] = "_c_exit", 0
14000924c  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_register_thread_local_exe_atexit_callback) = 0x3d
14000924e  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_register_thread_local_exe_atexit_callback)[0x2b] = "_register_thread_local_exe_atexit_callback", 0

140009279                                                                             00                                             .

14000927a  uint16_t __export_name_ptr_table_7(api-ms-win-crt-locale-l1-1-0:_configthreadlocale) = 0x8
14000927c  char __import_name_7(api-ms-win-crt-locale-l1-1-0:_configthreadlocale)[0x14] = "_configthreadlocale", 0
140009290  uint16_t __export_name_ptr_table_8(api-ms-win-crt-heap-l1-1-0:_set_new_mode) = 0x16
140009292  char __import_name_8(api-ms-win-crt-heap-l1-1-0:_set_new_mode)[0xe] = "_set_new_mode", 0
1400092a0  uint16_t __export_name_ptr_table_6(api-ms-win-crt-stdio-l1-1-0:__p__commode) = 0x1
1400092a2  char __import_name_6(api-ms-win-crt-stdio-l1-1-0:__p__commode)[0xd] = "__p__commode", 0

1400092af                                               00                                                                 .

1400092b0  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_initialize_onexit_table) = 0x34
1400092b2  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_initialize_onexit_table)[0x19] = "_initialize_onexit_table", 0

1400092cb                                   00                                                                         .

1400092cc  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_register_onexit_function) = 0x3c
1400092ce  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_register_onexit_function)[0x1a] = "_register_onexit_function", 0
1400092e8  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:_crt_atexit) = 0x1e
1400092ea  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:_crt_atexit)[0xc] = "_crt_atexit", 0
1400092f6  uint16_t __export_name_ptr_table_4(api-ms-win-crt-runtime-l1-1-0:terminate) = 0x67
1400092f8  char __import_name_4(api-ms-win-crt-runtime-l1-1-0:terminate)[0xa] = "terminate", 0
140009302  char __import_dll_name(api-ms-win-crt-runtime-l1-1-0)[0x22] = "api-ms-win-crt-runtime-l1-1-0.dll", 0
140009324  char __import_dll_name(api-ms-win-crt-math-l1-1-0)[0x1f] = "api-ms-win-crt-math-l1-1-0.dll", 0

140009343           00                                                                                         .

140009344  char __import_dll_name(api-ms-win-crt-stdio-l1-1-0)[0x20] = "api-ms-win-crt-stdio-l1-1-0.dll", 0
140009364  char __import_dll_name(api-ms-win-crt-locale-l1-1-0)[0x21] = "api-ms-win-crt-locale-l1-1-0.dll", 0

140009385                 00                                                                                     .

140009386  char __import_dll_name(api-ms-win-crt-heap-l1-1-0)[0x1f] = "api-ms-win-crt-heap-l1-1-0.dll", 0

1400093a5                 00                                                                                     .

1400093a6  uint16_t __export_name_ptr_table_1(KERNEL32:GetCurrentThreadId) = 0x22f
1400093a8  char __import_name_1(KERNEL32:GetCurrentThreadId)[0x13] = "GetCurrentThreadId", 0

1400093bb                                                                                   00                                         .

1400093bc  uint16_t __export_name_ptr_table_1(KERNEL32:GetSystemTimeAsFileTime) = 0x301
1400093be  char __import_name_1(KERNEL32:GetSystemTimeAsFileTime)[0x18] = "GetSystemTimeAsFileTime", 0
1400093d6  uint16_t __export_name_ptr_table_1(KERNEL32:InitializeSListHead) = 0x381
1400093d8  char __import_name_1(KERNEL32:InitializeSListHead)[0x14] = "InitializeSListHead", 0
1400093ec  uint16_t __export_name_ptr_table_1(KERNEL32:IsDebuggerPresent) = 0x397
1400093ee  char __import_name_1(KERNEL32:IsDebuggerPresent)[0x12] = "IsDebuggerPresent", 0
140009400  uint16_t __export_name_ptr_table_1(KERNEL32:UnhandledExceptionFilter) = 0x5d8
140009402  char __import_name_1(KERNEL32:UnhandledExceptionFilter)[0x19] = "UnhandledExceptionFilter", 0

14000941b                                                                                   00                                         .

14000941c  uint16_t __export_name_ptr_table_1(KERNEL32:SetUnhandledExceptionFilter) = 0x597
14000941e  char __import_name_1(KERNEL32:SetUnhandledExceptionFilter)[0x1c] = "SetUnhandledExceptionFilter", 0
14000943a  uint16_t __export_name_ptr_table_1(KERNEL32:IsProcessorFeaturePresent) = 0x39e
14000943c  char __import_name_1(KERNEL32:IsProcessorFeaturePresent)[0x1a] = "IsProcessorFeaturePresent", 0
.rdata section ended  {0x140007000-0x140009456}

.data section started  {0x14000a000-0x14000a220}
14000a000  char data_14000a000[0x27] = "7=06*gagg30d03gf2`f5g5dba3c0hhcd2c`4b,", 0

14000a027                       00                                                                                 .

14000a028  void* data_14000a028 = sub_1400036e0
14000a030  void* data_14000a030 = 0x140007fa0

14000a038                                                                          00 00 00 00 00 00 00 00                          ........
14000a040  75 98 00 00 ff ff ff ff                                                                          u.......

14000a048  int32_t data_14000a048 = 0x1

14000a04c                                      00 00 00 00                                                              ....

14000a050  int64_t data_14000a050 = -0x1
14000a058  int32_t data_14000a058 = 0x1
14000a05c  int32_t data_14000a05c = 0x2
14000a060  int64_t data_14000a060 = 0x80000
14000a068  int64_t data_14000a068 = 0x2000000

14000a070                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................

14000a080  uint64_t __security_cookie = 0x2b992ddfa232

14000a088                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
14000a0a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

14000a0c0  int64_t data_14000a0c0 = -0x2b992ddfa233

14000a0c8                          00 00 00 00 00 00 00 00                                                          ........

14000a0d0  int32_t data_14000a0d0 = 0x1

14000a0d4                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

14000a0e0  char data_14000a0e0 = 0x0

14000a0e1     00 00 00                                                                                       ...

14000a0e4  char data_14000a0e4 = 0x0

14000a0e5                 00 00 00                                                                               ...
14000a0e8  data_14000a0e8:
14000a0e8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
14000a100  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

14000a120  int32_t data_14000a120 = 0x0

14000a124              00 00 00 00                                                                              ....

14000a128  int64_t data_14000a128 = 0x0
14000a130  int32_t data_14000a130 = 0x0
14000a134  char data_14000a134 = 0x0

14000a135                                                                 00 00 00                                               ...

14000a138  int64_t data_14000a138 = 0x0
14000a140  int64_t data_14000a140 = 0x0
14000a148  int64_t data_14000a148 = 0x0
14000a150  int64_t data_14000a150 = 0x0
14000a158  char data_14000a158 = 0x0

14000a159                                                                             00 00 00 00 00 00 00                           .......

14000a160  int32_t data_14000a160 = 0x0

14000a164              00 00 00 00                                                                              ....

14000a168  int32_t data_14000a168 = 0x0

14000a16c                                      00 00 00 00                                                              ....

14000a170  int64_t data_14000a170 = 0x0
14000a178  int64_t data_14000a178 = 0x0
14000a180  int64_t data_14000a180 = 0x0
14000a188  int32_t data_14000a188 = 0x0

14000a18c                                      00 00 00 00                                                              ....

14000a190  int32_t data_14000a190 = 0x0

14000a194                                                              00 00 00 00                                              ....

14000a198  int32_t data_14000a198 = 0x0

14000a19c                                                                                      00 00 00 00                              ....

14000a1a0  int64_t data_14000a1a0 = 0x0
14000a1a8  char data_14000a1a8 = 0x0
14000a1a9  char data_14000a1a9 = 0x0

14000a1aa                                00 00 00 00 00 00                                                            ......

14000a1b0  int64_t data_14000a1b0 = 0x0

14000a1b8                                                                          00 00 00 00 00 00 00 00                          ........

14000a1c0  int64_t data_14000a1c0 = 0x0
14000a1c8  int128_t data_14000a1c8 = 
14000a1c8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                  ................
14000a1d8  int64_t data_14000a1d8 = 0x0

14000a1e0  data_14000a1e0:
14000a1e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

14000a1f0  int64_t data_14000a1f0 = 0x0
14000a1f8  int64_t data_14000a1f8 = 0x0
14000a200  int32_t data_14000a200 = 0x0
14000a204  int32_t data_14000a204 = 0x0
14000a208  int32_t data_14000a208 = 0x0

14000a20c                                      00 00 00 00                                                              ....

14000a210  int64_t data_14000a210 = 0x0
14000a218  int64_t data_14000a218 = 0x0
.data section ended  {0x14000a000-0x14000a220}

.pdata section started  {0x14000b000-0x14000b3f0}
14000b000  struct Exception_Directory_Entry __exception_directory_entries(0) = 
14000b000  {
14000b000      uint32_t beginAddress = 0x1000
14000b004      uint32_t endAddress = 0x100d
14000b008      uint32_t unwindInformation = 0x87d0
14000b00c  }
14000b00c  struct Exception_Directory_Entry __exception_directory_entries(1) = 
14000b00c  {
14000b00c      uint32_t beginAddress = 0x1060
14000b010      uint32_t endAddress = 0x1187
14000b014      uint32_t unwindInformation = 0x87d8
14000b018  }
14000b018  struct Exception_Directory_Entry __exception_directory_entries(2) = 
14000b018  {
14000b018      uint32_t beginAddress = 0x1190
14000b01c      uint32_t endAddress = 0x11ea
14000b020      uint32_t unwindInformation = 0x87e8
14000b024  }
14000b024  struct Exception_Directory_Entry __exception_directory_entries(3) = 
14000b024  {
14000b024      uint32_t beginAddress = 0x11f0
14000b028      uint32_t endAddress = 0x1735
14000b02c      uint32_t unwindInformation = 0x8810
14000b030  }
14000b030  struct Exception_Directory_Entry __exception_directory_entries(4) = 
14000b030  {
14000b030      uint32_t beginAddress = 0x1820
14000b034      uint32_t endAddress = 0x193a
14000b038      uint32_t unwindInformation = 0x8828
14000b03c  }
14000b03c  struct Exception_Directory_Entry __exception_directory_entries(5) = 
14000b03c  {
14000b03c      uint32_t beginAddress = 0x1940
14000b040      uint32_t endAddress = 0x1aab
14000b044      uint32_t unwindInformation = 0x8838
14000b048  }
14000b048  struct Exception_Directory_Entry __exception_directory_entries(6) = 
14000b048  {
14000b048      uint32_t beginAddress = 0x1ab0
14000b04c      uint32_t endAddress = 0x1b04
14000b050      uint32_t unwindInformation = 0x884c
14000b054  }
14000b054  struct Exception_Directory_Entry __exception_directory_entries(7) = 
14000b054  {
14000b054      uint32_t beginAddress = 0x1b10
14000b058      uint32_t endAddress = 0x1b5c
14000b05c      uint32_t unwindInformation = 0x884c
14000b060  }
14000b060  struct Exception_Directory_Entry __exception_directory_entries(8) = 
14000b060  {
14000b060      uint32_t beginAddress = 0x1b60
14000b064      uint32_t endAddress = 0x1b93
14000b068      uint32_t unwindInformation = 0x87d0
14000b06c  }
14000b06c  struct Exception_Directory_Entry __exception_directory_entries(9) = 
14000b06c  {
14000b06c      uint32_t beginAddress = 0x1ba0
14000b070      uint32_t endAddress = 0x1c40
14000b074      uint32_t unwindInformation = 0x8854
14000b078  }
14000b078  struct Exception_Directory_Entry __exception_directory_entries(10) = 
14000b078  {
14000b078      uint32_t beginAddress = 0x1c40
14000b07c      uint32_t endAddress = 0x1e5f
14000b080      uint32_t unwindInformation = 0x8864
14000b084  }
14000b084  struct Exception_Directory_Entry __exception_directory_entries(11) = 
14000b084  {
14000b084      uint32_t beginAddress = 0x1e60
14000b088      uint32_t endAddress = 0x1ff5
14000b08c      uint32_t unwindInformation = 0x8870
14000b090  }
14000b090  struct Exception_Directory_Entry __exception_directory_entries(12) = 
14000b090  {
14000b090      uint32_t beginAddress = 0x2000
14000b094      uint32_t endAddress = 0x21c6
14000b098      uint32_t unwindInformation = 0x8880
14000b09c  }
14000b09c  struct Exception_Directory_Entry __exception_directory_entries(13) = 
14000b09c  {
14000b09c      uint32_t beginAddress = 0x2210
14000b0a0      uint32_t endAddress = 0x2242
14000b0a4      uint32_t unwindInformation = 0x87d0
14000b0a8  }
14000b0a8  struct Exception_Directory_Entry __exception_directory_entries(14) = 
14000b0a8  {
14000b0a8      uint32_t beginAddress = 0x2250
14000b0ac      uint32_t endAddress = 0x234d
14000b0b0      uint32_t unwindInformation = 0x8890
14000b0b4  }
14000b0b4  struct Exception_Directory_Entry __exception_directory_entries(15) = 
14000b0b4  {
14000b0b4      uint32_t beginAddress = 0x2350
14000b0b8      uint32_t endAddress = 0x2385
14000b0bc      uint32_t unwindInformation = 0x87d0
14000b0c0  }
14000b0c0  struct Exception_Directory_Entry __exception_directory_entries(16) = 
14000b0c0  {
14000b0c0      uint32_t beginAddress = 0x2390
14000b0c4      uint32_t endAddress = 0x23e2
14000b0c8      uint32_t unwindInformation = 0x87f8
14000b0cc  }
14000b0cc  struct Exception_Directory_Entry __exception_directory_entries(17) = 
14000b0cc  {
14000b0cc      uint32_t beginAddress = 0x23f0
14000b0d0      uint32_t endAddress = 0x241c
14000b0d4      uint32_t unwindInformation = 0x884c
14000b0d8  }
14000b0d8  struct Exception_Directory_Entry __exception_directory_entries(18) = 
14000b0d8  {
14000b0d8      uint32_t beginAddress = 0x2420
14000b0dc      uint32_t endAddress = 0x24c2
14000b0e0      uint32_t unwindInformation = 0x889c
14000b0e4  }
14000b0e4  struct Exception_Directory_Entry __exception_directory_entries(19) = 
14000b0e4  {
14000b0e4      uint32_t beginAddress = 0x26d0
14000b0e8      uint32_t endAddress = 0x2797
14000b0ec      uint32_t unwindInformation = 0x88ac
14000b0f0  }
14000b0f0  struct Exception_Directory_Entry __exception_directory_entries(20) = 
14000b0f0  {
14000b0f0      uint32_t beginAddress = 0x27c0
14000b0f4      uint32_t endAddress = 0x2871
14000b0f8      uint32_t unwindInformation = 0x88c0
14000b0fc  }
14000b0fc  struct Exception_Directory_Entry __exception_directory_entries(21) = 
14000b0fc  {
14000b0fc      uint32_t beginAddress = 0x28d0
14000b100      uint32_t endAddress = 0x293b
14000b104      uint32_t unwindInformation = 0x884c
14000b108  }
14000b108  struct Exception_Directory_Entry __exception_directory_entries(22) = 
14000b108  {
14000b108      uint32_t beginAddress = 0x2940
14000b10c      uint32_t endAddress = 0x29c7
14000b110      uint32_t unwindInformation = 0x884c
14000b114  }
14000b114  struct Exception_Directory_Entry __exception_directory_entries(23) = 
14000b114  {
14000b114      uint32_t beginAddress = 0x29d0
14000b118      uint32_t endAddress = 0x2a6b
14000b11c      uint32_t unwindInformation = 0x8864
14000b120  }
14000b120  struct Exception_Directory_Entry __exception_directory_entries(24) = 
14000b120  {
14000b120      uint32_t beginAddress = 0x2a70
14000b124      uint32_t endAddress = 0x2c64
14000b128      uint32_t unwindInformation = 0x88dc
14000b12c  }
14000b12c  struct Exception_Directory_Entry __exception_directory_entries(25) = 
14000b12c  {
14000b12c      uint32_t beginAddress = 0x2c70
14000b130      uint32_t endAddress = 0x2d74
14000b134      uint32_t unwindInformation = 0x8864
14000b138  }
14000b138  struct Exception_Directory_Entry __exception_directory_entries(26) = 
14000b138  {
14000b138      uint32_t beginAddress = 0x2d80
14000b13c      uint32_t endAddress = 0x2ee6
14000b140      uint32_t unwindInformation = 0x88f4
14000b144  }
14000b144  struct Exception_Directory_Entry __exception_directory_entries(27) = 
14000b144  {
14000b144      uint32_t beginAddress = 0x2f10
14000b148      uint32_t endAddress = 0x2f75
14000b14c      uint32_t unwindInformation = 0x88b4
14000b150  }
14000b150  struct Exception_Directory_Entry __exception_directory_entries(28) = 
14000b150  {
14000b150      uint32_t beginAddress = 0x2f80
14000b154      uint32_t endAddress = 0x303a
14000b158      uint32_t unwindInformation = 0x88f4
14000b15c  }
14000b15c  struct Exception_Directory_Entry __exception_directory_entries(29) = 
14000b15c  {
14000b15c      uint32_t beginAddress = 0x3040
14000b160      uint32_t endAddress = 0x30a9
14000b164      uint32_t unwindInformation = 0x87e8
14000b168  }
14000b168  struct Exception_Directory_Entry __exception_directory_entries(30) = 
14000b168  {
14000b168      uint32_t beginAddress = 0x30b0
14000b16c      uint32_t endAddress = 0x3401
14000b170      uint32_t unwindInformation = 0x8904
14000b174  }
14000b174  struct Exception_Directory_Entry __exception_directory_entries(31) = 
14000b174  {
14000b174      uint32_t beginAddress = 0x3410
14000b178      uint32_t endAddress = 0x3444
14000b17c      uint32_t unwindInformation = 0x87f8
14000b180  }
14000b180  struct Exception_Directory_Entry __exception_directory_entries(32) = 
14000b180  {
14000b180      uint32_t beginAddress = 0x3450
14000b184      uint32_t endAddress = 0x35a3
14000b188      uint32_t unwindInformation = 0x889c
14000b18c  }
14000b18c  struct Exception_Directory_Entry __exception_directory_entries(33) = 
14000b18c  {
14000b18c      uint32_t beginAddress = 0x35b0
14000b190      uint32_t endAddress = 0x36d8
14000b194      uint32_t unwindInformation = 0x88dc
14000b198  }
14000b198  struct Exception_Directory_Entry __exception_directory_entries(34) = 
14000b198  {
14000b198      uint32_t beginAddress = 0x36e0
14000b19c      uint32_t endAddress = 0x373b
14000b1a0      uint32_t unwindInformation = 0x87f8
14000b1a4  }
14000b1a4  struct Exception_Directory_Entry __exception_directory_entries(35) = 
14000b1a4  {
14000b1a4      uint32_t beginAddress = 0x3740
14000b1a8      uint32_t endAddress = 0x3759
14000b1ac      uint32_t unwindInformation = 0x87d0
14000b1b0  }
14000b1b0  struct Exception_Directory_Entry __exception_directory_entries(36) = 
14000b1b0  {
14000b1b0      uint32_t beginAddress = 0x3760
14000b1b4      uint32_t endAddress = 0x3a1d
14000b1b8      uint32_t unwindInformation = 0x8920
14000b1bc  }
14000b1bc  struct Exception_Directory_Entry __exception_directory_entries(37) = 
14000b1bc  {
14000b1bc      uint32_t beginAddress = 0x3a20
14000b1c0      uint32_t endAddress = 0x3c23
14000b1c4      uint32_t unwindInformation = 0x8930
14000b1c8  }
14000b1c8  struct Exception_Directory_Entry __exception_directory_entries(38) = 
14000b1c8  {
14000b1c8      uint32_t beginAddress = 0x3c30
14000b1cc      uint32_t endAddress = 0x3f0d
14000b1d0      uint32_t unwindInformation = 0x8940
14000b1d4  }
14000b1d4  struct Exception_Directory_Entry __exception_directory_entries(39) = 
14000b1d4  {
14000b1d4      uint32_t beginAddress = 0x3f10
14000b1d8      uint32_t endAddress = 0x40d5
14000b1dc      uint32_t unwindInformation = 0x8958
14000b1e0  }
14000b1e0  struct Exception_Directory_Entry __exception_directory_entries(40) = 
14000b1e0  {
14000b1e0      uint32_t beginAddress = 0x40f0
14000b1e4      uint32_t endAddress = 0x427b
14000b1e8      uint32_t unwindInformation = 0x8970
14000b1ec  }
14000b1ec  struct Exception_Directory_Entry __exception_directory_entries(41) = 
14000b1ec  {
14000b1ec      uint32_t beginAddress = 0x4280
14000b1f0      uint32_t endAddress = 0x44dd
14000b1f4      uint32_t unwindInformation = 0x898c
14000b1f8  }
14000b1f8  struct Exception_Directory_Entry __exception_directory_entries(42) = 
14000b1f8  {
14000b1f8      uint32_t beginAddress = 0x44e0
14000b1fc      uint32_t endAddress = 0x4919
14000b200      uint32_t unwindInformation = 0x89a4
14000b204  }
14000b204  struct Exception_Directory_Entry __exception_directory_entries(43) = 
14000b204  {
14000b204      uint32_t beginAddress = 0x4940
14000b208      uint32_t endAddress = 0x4a15
14000b20c      uint32_t unwindInformation = 0x89bc
14000b210  }
14000b210  struct Exception_Directory_Entry __exception_directory_entries(44) = 
14000b210  {
14000b210      uint32_t beginAddress = 0x4a20
14000b214      uint32_t endAddress = 0x4b07
14000b218      uint32_t unwindInformation = 0x89c8
14000b21c  }
14000b21c  struct Exception_Directory_Entry __exception_directory_entries(45) = 
14000b21c  {
14000b21c      uint32_t beginAddress = 0x4b10
14000b220      uint32_t endAddress = 0x4d04
14000b224      uint32_t unwindInformation = 0x89d8
14000b228  }
14000b228  struct Exception_Directory_Entry __exception_directory_entries(46) = 
14000b228  {
14000b228      uint32_t beginAddress = 0x4d10
14000b22c      uint32_t endAddress = 0x533d
14000b230      uint32_t unwindInformation = 0x89e8
14000b234  }
14000b234  struct Exception_Directory_Entry __exception_directory_entries(47) = 
14000b234  {
14000b234      uint32_t beginAddress = 0x5340
14000b238      uint32_t endAddress = 0x53f6
14000b23c      uint32_t unwindInformation = 0x8a14
14000b240  }
14000b240  struct Exception_Directory_Entry __exception_directory_entries(48) = 
14000b240  {
14000b240      uint32_t beginAddress = 0x53f8
14000b244      uint32_t endAddress = 0x5408
14000b248      uint32_t unwindInformation = 0x87d0
14000b24c  }
14000b24c  struct Exception_Directory_Entry __exception_directory_entries(49) = 
14000b24c  {
14000b24c      uint32_t beginAddress = 0x5408
14000b250      uint32_t endAddress = 0x5421
14000b254      uint32_t unwindInformation = 0x87d0
14000b258  }
14000b258  struct Exception_Directory_Entry __exception_directory_entries(50) = 
14000b258  {
14000b258      uint32_t beginAddress = 0x5424
14000b25c      uint32_t endAddress = 0x55a0
14000b260      uint32_t unwindInformation = 0x8a1c
14000b264  }
14000b264  struct Exception_Directory_Entry __exception_directory_entries(51) = 
14000b264  {
14000b264      uint32_t beginAddress = 0x55a0
14000b268      uint32_t endAddress = 0x55b2
14000b26c      uint32_t unwindInformation = 0x87d0
14000b270  }
14000b270  struct Exception_Directory_Entry __exception_directory_entries(52) = 
14000b270  {
14000b270      uint32_t beginAddress = 0x55d0
14000b274      uint32_t endAddress = 0x561e
14000b278      uint32_t unwindInformation = 0x8a60
14000b27c  }
14000b27c  struct Exception_Directory_Entry __exception_directory_entries(53) = 
14000b27c  {
14000b27c      uint32_t beginAddress = 0x5620
14000b280      uint32_t endAddress = 0x5659
14000b284      uint32_t unwindInformation = 0x87d0
14000b288  }
14000b288  struct Exception_Directory_Entry __exception_directory_entries(54) = 
14000b288  {
14000b288      uint32_t beginAddress = 0x565c
14000b28c      uint32_t endAddress = 0x5696
14000b290      uint32_t unwindInformation = 0x87d0
14000b294  }
14000b294  struct Exception_Directory_Entry __exception_directory_entries(55) = 
14000b294  {
14000b294      uint32_t beginAddress = 0x5698
14000b298      uint32_t endAddress = 0x5723
14000b29c      uint32_t unwindInformation = 0x8a14
14000b2a0  }
14000b2a0  struct Exception_Directory_Entry __exception_directory_entries(56) = 
14000b2a0  {
14000b2a0      uint32_t beginAddress = 0x5724
14000b2a4      uint32_t endAddress = 0x57bc
14000b2a8      uint32_t unwindInformation = 0x8a68
14000b2ac  }
14000b2ac  struct Exception_Directory_Entry __exception_directory_entries(57) = 
14000b2ac  {
14000b2ac      uint32_t beginAddress = 0x57bc
14000b2b0      uint32_t endAddress = 0x57e0
14000b2b4      uint32_t unwindInformation = 0x8a14
14000b2b8  }
14000b2b8  struct Exception_Directory_Entry __exception_directory_entries(58) = 
14000b2b8  {
14000b2b8      uint32_t beginAddress = 0x57e0
14000b2bc      uint32_t endAddress = 0x5809
14000b2c0      uint32_t unwindInformation = 0x8a14
14000b2c4  }
14000b2c4  struct Exception_Directory_Entry __exception_directory_entries(59) = 
14000b2c4  {
14000b2c4      uint32_t beginAddress = 0x580c
14000b2c8      uint32_t endAddress = 0x5846
14000b2cc      uint32_t unwindInformation = 0x8a14
14000b2d0  }
14000b2d0  struct Exception_Directory_Entry __exception_directory_entries(60) = 
14000b2d0  {
14000b2d0      uint32_t beginAddress = 0x5848
14000b2d4      uint32_t endAddress = 0x585f
14000b2d8      uint32_t unwindInformation = 0x87d0
14000b2dc  }
14000b2dc  struct Exception_Directory_Entry __exception_directory_entries(61) = 
14000b2dc  {
14000b2dc      uint32_t beginAddress = 0x5860
14000b2e0      uint32_t endAddress = 0x590c
14000b2e4      uint32_t unwindInformation = 0x8a90
14000b2e8  }
14000b2e8  struct Exception_Directory_Entry __exception_directory_entries(62) = 
14000b2e8  {
14000b2e8      uint32_t beginAddress = 0x5948
14000b2ec      uint32_t endAddress = 0x5963
14000b2f0      uint32_t unwindInformation = 0x87d0
14000b2f4  }
14000b2f4  struct Exception_Directory_Entry __exception_directory_entries(63) = 
14000b2f4  {
14000b2f4      uint32_t beginAddress = 0x5988
14000b2f8      uint32_t endAddress = 0x5ad0
14000b2fc      uint32_t unwindInformation = 0x8a9c
14000b300  }
14000b300  struct Exception_Directory_Entry __exception_directory_entries(64) = 
14000b300  {
14000b300      uint32_t beginAddress = 0x5ad8
14000b304      uint32_t endAddress = 0x5b29
14000b308      uint32_t unwindInformation = 0x87d0
14000b30c  }
14000b30c  struct Exception_Directory_Entry __exception_directory_entries(65) = 
14000b30c  {
14000b30c      uint32_t beginAddress = 0x5b3c
14000b310      uint32_t endAddress = 0x5b97
14000b314      uint32_t unwindInformation = 0x8aac
14000b318  }
14000b318  struct Exception_Directory_Entry __exception_directory_entries(66) = 
14000b318  {
14000b318      uint32_t beginAddress = 0x5b98
14000b31c      uint32_t endAddress = 0x5bd4
14000b320      uint32_t unwindInformation = 0x8aac
14000b324  }
14000b324  struct Exception_Directory_Entry __exception_directory_entries(67) = 
14000b324  {
14000b324      uint32_t beginAddress = 0x5bd4
14000b328      uint32_t endAddress = 0x5c10
14000b32c      uint32_t unwindInformation = 0x8aac
14000b330  }
14000b330  struct Exception_Directory_Entry __exception_directory_entries(68) = 
14000b330  {
14000b330      uint32_t beginAddress = 0x5c10
14000b334      uint32_t endAddress = 0x5eda
14000b338      uint32_t unwindInformation = 0x8ab8
14000b33c  }
14000b33c  struct Exception_Directory_Entry __exception_directory_entries(69) = 
14000b33c  {
14000b33c      uint32_t beginAddress = 0x5fc0
14000b340      uint32_t endAddress = 0x5fc2
14000b344      uint32_t unwindInformation = 0x8ad0
14000b348  }
14000b348  struct Exception_Directory_Entry __exception_directory_entries(70) = 
14000b348  {
14000b348      uint32_t beginAddress = 0x5fe0
14000b34c      uint32_t endAddress = 0x5fe6
14000b350      uint32_t unwindInformation = 0x8ad8
14000b354  }
14000b354  struct Exception_Directory_Entry __exception_directory_entries(71) = 
14000b354  {
14000b354      uint32_t beginAddress = 0x5ff0
14000b358      uint32_t endAddress = 0x6056
14000b35c      uint32_t unwindInformation = 0x87f8
14000b360  }
14000b360  struct Exception_Directory_Entry __exception_directory_entries(72) = 
14000b360  {
14000b360      uint32_t beginAddress = 0x6060
14000b364      uint32_t endAddress = 0x6100
14000b368      uint32_t unwindInformation = 0x8804
14000b36c  }
14000b36c  struct Exception_Directory_Entry __exception_directory_entries(73) = 
14000b36c  {
14000b36c      uint32_t beginAddress = 0x6100
14000b370      uint32_t endAddress = 0x61de
14000b374      uint32_t unwindInformation = 0x88b4
14000b378  }
14000b378  struct Exception_Directory_Entry __exception_directory_entries(74) = 
14000b378  {
14000b378      uint32_t beginAddress = 0x61e0
14000b37c      uint32_t endAddress = 0x624b
14000b380      uint32_t unwindInformation = 0x88b4
14000b384  }
14000b384  struct Exception_Directory_Entry __exception_directory_entries(75) = 
14000b384  {
14000b384      uint32_t beginAddress = 0x6250
14000b388      uint32_t endAddress = 0x6349
14000b38c      uint32_t unwindInformation = 0x8804
14000b390  }
14000b390  struct Exception_Directory_Entry __exception_directory_entries(76) = 
14000b390  {
14000b390      uint32_t beginAddress = 0x6349
14000b394      uint32_t endAddress = 0x6393
14000b398      uint32_t unwindInformation = 0x88cc
14000b39c  }
14000b39c  struct Exception_Directory_Entry __exception_directory_entries(77) = 
14000b39c  {
14000b39c      uint32_t beginAddress = 0x6393
14000b3a0      uint32_t endAddress = 0x63e1
14000b3a4      uint32_t unwindInformation = 0x88d4
14000b3a8  }
14000b3a8  struct Exception_Directory_Entry __exception_directory_entries(78) = 
14000b3a8  {
14000b3a8      uint32_t beginAddress = 0x63e1
14000b3ac      uint32_t endAddress = 0x642b
14000b3b0      uint32_t unwindInformation = 0x88cc
14000b3b4  }
14000b3b4  struct Exception_Directory_Entry __exception_directory_entries(79) = 
14000b3b4  {
14000b3b4      uint32_t beginAddress = 0x6430
14000b3b8      uint32_t endAddress = 0x64e4
14000b3bc      uint32_t unwindInformation = 0x87e8
14000b3c0  }
14000b3c0  struct Exception_Directory_Entry __exception_directory_entries(80) = 
14000b3c0  {
14000b3c0      uint32_t beginAddress = 0x64f0
14000b3c4      uint32_t endAddress = 0x6584
14000b3c8      uint32_t unwindInformation = 0x88b4
14000b3cc  }
14000b3cc  struct Exception_Directory_Entry __exception_directory_entries(81) = 
14000b3cc  {
14000b3cc      uint32_t beginAddress = 0x6590
14000b3d0      uint32_t endAddress = 0x6700
14000b3d4      uint32_t unwindInformation = 0x8978
14000b3d8  }
14000b3d8  struct Exception_Directory_Entry __exception_directory_entries(82) = 
14000b3d8  {
14000b3d8      uint32_t beginAddress = 0x6702
14000b3dc      uint32_t endAddress = 0x6720
14000b3e0      uint32_t unwindInformation = 0x8a54
14000b3e4  }
14000b3e4  struct Exception_Directory_Entry __exception_directory_entries(83) = 
14000b3e4  {
14000b3e4      uint32_t beginAddress = 0x6720
14000b3e8      uint32_t endAddress = 0x6738
14000b3ec      uint32_t unwindInformation = 0x8a88
14000b3f0  }
.pdata section ended  {0x14000b000-0x14000b3f0}

.reloc section started  {0x14000c000-0x14000c0a0}
14000c000  00 70 00 00 70 00 00 00 68 a2 70 a2 78 a2 80 a2 88 a2 98 a2 a8 a2 b0 a2 c8 a2 d0 a2 e8 a2 58 a3  .p..p...h.p.x.................X.
14000c020  60 a3 68 a3 80 a3 98 a3 b0 a3 b8 a3 c0 a3 00 a4 80 a4 90 a4 f8 a4 20 a5 48 a5 78 a5 80 a5 98 a5  `.h................... .H.x.....
14000c040  e8 aa 18 ab 48 ab 50 ab 70 ab 78 ab 98 ab a0 ab d0 ab 08 ac 20 ac 38 ac 40 ac 48 ac 50 ac 68 ac  ....H.P.p.x......... .8.@.H.P.h.
14000c060  70 ac 78 ac a8 ac f0 ac 28 ad a8 ae 20 af 00 00 00 80 00 00 24 00 00 00 38 a2 50 a2 58 a2 e0 a2  p.x.....(... .......$...8.P.X...
14000c080  f8 a2 00 a3 08 a3 10 a3 18 a3 80 a3 88 a3 90 a3 98 a3 00 00 00 a0 00 00 0c 00 00 00 28 a0 30 a0  ............................(.0.
.reloc section ended  {0x14000c000-0x14000c0a0}

.extern section started  {0x14000c0a0-0x14000c2c0}
14000c0a0  extern void* AddVectoredExceptionHandler(uint32_t First, PVECTORED_EXCEPTION_HANDLER Handler)
14000c0a8  extern BOOL GetConsoleMode(HANDLE hConsoleHandle, enum CONSOLE_MODE* lpMode)
14000c0b0  extern uint32_t GetConsoleOutputCP()
14000c0b8  extern uint32_t GetCurrentProcessId()
14000c0c0  extern HANDLE GetCurrentThread()
14000c0c8  extern uint32_t GetCurrentThreadId()
14000c0d0  extern enum WIN32_ERROR GetLastError()
14000c0d8  extern HMODULE GetModuleHandleA(PSTR lpModuleName)
14000c0e0  extern HMODULE GetModuleHandleW(PWSTR lpModuleName)
14000c0e8  extern FARPROC GetProcAddress(HMODULE hModule, PSTR lpProcName)
14000c0f0  extern HANDLE GetProcessHeap()
14000c0f8  extern HANDLE GetStdHandle(enum STD_HANDLE nStdHandle)
14000c100  extern void GetSystemTimeAsFileTime(FILETIME* lpSystemTimeAsFileTime)
14000c108  extern void* HeapAlloc(HANDLE hHeap, enum HEAP_FLAGS dwFlags, uint64_t dwBytes)
14000c110  extern BOOL HeapFree(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem)
14000c118  extern void* HeapReAlloc(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem, uint64_t dwBytes)
14000c120  extern void InitializeSListHead(SLIST_HEADER* ListHead)
14000c128  extern BOOL IsDebuggerPresent()
14000c130  extern BOOL IsProcessorFeaturePresent(enum PROCESSOR_FEATURE_ID ProcessorFeature)
14000c138  extern int32_t MultiByteToWideChar(uint32_t CodePage, enum MULTI_BYTE_TO_WIDE_CHAR_FLAGS dwFlags, uint8_t* lpMultiByteStr, int32_t cbMultiByte, wchar16* lpWideCharStr, int32_t cchWideChar)
14000c140  extern NTSTATUS NtReadFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, void* ApcContext, struct IO_STATUS_BLOCK* IoStatusBlock, void* Buffer, uint32_t Length, int64_t* ByteOffset, uint32_t* Key)
14000c148  extern NTSTATUS NtWriteFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, void* ApcContext, struct IO_STATUS_BLOCK* IoStatusBlock, void* Buffer, uint32_t Length, int64_t* ByteOffset, uint32_t* Key)
14000c150  extern BOOL QueryPerformanceCounter(int64_t* lpPerformanceCount)
14000c158  extern BOOL ReadConsoleW(HANDLE hConsoleInput, void* lpBuffer, uint32_t nNumberOfCharsToRead, uint32_t* lpNumberOfCharsRead, CONSOLE_READCONSOLE_CONTROL* pInputControl)
14000c160  extern void RtlCaptureContext(CONTEXT* ContextRecord)
14000c168  extern IMAGE_RUNTIME_FUNCTION_ENTRY* RtlLookupFunctionEntry(uint64_t ControlPc, uint64_t* ImageBase, UNWIND_HISTORY_TABLE* HistoryTable)
14000c170  extern uint32_t RtlNtStatusToDosError(NTSTATUS Status)
14000c178  extern EXCEPTION_ROUTINE RtlVirtualUnwind(enum RTL_VIRTUAL_UNWIND_HANDLER_TYPE HandlerType, uint64_t ImageBase, uint64_t ControlPc, IMAGE_RUNTIME_FUNCTION_ENTRY* FunctionEntry, CONTEXT* ContextRecord, void** HandlerData, uint64_t* EstablisherFrame, KNONVOLATILE_CONTEXT_POINTERS* ContextPointers)
14000c180  extern void SetLastError(enum WIN32_ERROR dwErrCode)
14000c188  extern BOOL SetThreadStackGuarantee(uint32_t* StackSizeInBytes)
14000c190  extern LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
14000c198  extern int32_t UnhandledExceptionFilter(EXCEPTION_POINTERS* ExceptionInfo)
14000c1a0  extern enum WAIT_EVENT WaitForSingleObject(HANDLE hHandle, uint32_t dwMilliseconds)
14000c1a8  extern BOOL WaitOnAddress(void* Address, void* CompareAddress, uint64_t AddressSize, uint32_t dwMilliseconds)
14000c1b0  extern void WakeByAddressAll(void* Address)
14000c1b8  extern void WakeByAddressSingle(void* Address)
14000c1c0  extern int32_t WideCharToMultiByte(uint32_t CodePage, uint32_t dwFlags, wchar16* lpWideCharStr, int32_t cchWideChar, PSTR lpMultiByteStr, int32_t cbMultiByte, PSTR lpDefaultChar, BOOL* lpUsedDefaultChar)
14000c1c8  extern BOOL WriteConsoleW(HANDLE hConsoleOutput, void* lpBuffer, uint32_t nNumberOfCharsToWrite, uint32_t* lpNumberOfCharsWritten, void* lpReserved)
14000c1d0  extern enum _EXCEPTION_DISPOSITION __C_specific_handler(struct _EXCEPTION_RECORD* ExceptionRecord, void* EstablisherFrame, struct _CONTEXT* ContextRecord, struct _DISPATCHER_CONTEXT* DispatcherContext)
14000c1d8  extern void** __current_exception()
14000c1e0  extern void** __current_exception_context()
14000c1e8  extern int32_t* __p___argc()
14000c1f0  extern char*** __p___argv()
14000c1f8  extern int32_t* __p__commode()
14000c200  extern void __setusermatherr(_UserMathErrorFunctionPointer _UserMathErrorFunction)
14000c208  extern void _c_exit()
14000c210  extern void _cexit()
14000c218  extern int32_t _configthreadlocale(int32_t _Flag)
14000c220  extern errno_t _configure_narrow_argv(enum _crt_argv_mode mode)
14000c228  extern int32_t _crt_atexit(_PVFV _Function)
14000c230  extern void _exit(int32_t _Except) __noreturn
14000c238  extern char** _get_initial_narrow_environment()
14000c240  extern int32_t _initialize_narrow_environment()
14000c248  extern int32_t _initialize_onexit_table(struct _onexit_table_t* _Table)
14000c250  extern void _initterm(_PVFV* _First, _PVFV* _Last)
14000c258  extern int32_t _initterm_e(_PIFV* _First, _PIFV* _Last)
14000c260  extern int32_t _register_onexit_function(struct _onexit_table_t* _Table, _onexit_t_1 _Function)
14000c268  extern void _register_thread_local_exe_atexit_callback(_tls_callback_type _Callback)
14000c270  extern int32_t _seh_filter_exe(uint32_t _ExceptionNum, struct _EXCEPTION_POINTERS* _ExceptionPtr)
14000c278  extern void _set_app_type(enum _crt_app_type _Type)
14000c280  extern errno_t _set_fmode(int32_t _Value)
14000c288  extern int32_t _set_new_mode(int32_t _NewMode)
14000c290  extern void exit(int32_t _Except) __noreturn
14000c298  extern int32_t memcmp(void const* buffer1, void const* buffer2, uint64_t count)
14000c2a0  extern void* memcpy(void* dest, void const* src, uint32_t count)
14000c2a8  extern void* memmove(void* dest, void const* src, uint32_t count)
14000c2b0  extern void* memset(void* dest, int32_t c, uint64_t count)
14000c2b8  extern void terminate() __noreturn
.extern section ended  {0x14000c0a0-0x14000c2c0}

.synthetic_builtins section started  {0x14000c2c0-0x14000c2f0}
14000c2c0  extern void* __builtin_memcpy(void* dest, void const* src, uint64_t count)
14000c2c8  extern void* __builtin_memset(void* dest, int32_t ch, uint64_t count)
14000c2d0  extern char* __builtin_strcpy(char* dest, char const* src)
14000c2d8  extern char* __builtin_strncpy(char* dest, char const* src, uint64_t count)
14000c2e0  extern wchar16* __builtin_wcscpy(wchar16* dest, wchar16 const* src)
14000c2e8  extern wchar16* __builtin_wmemcpy(wchar16* dest, wchar16 const* src, uint64_t count)
.synthetic_builtins section ended  {0x14000c2c0-0x14000c2f0}

