/*
Type: PE
Platform: windows-x86_64
Architecture: x86_64

Libraries: 
  KERNEL32.dll
  api-ms-win-crt-convert-l1-1-0.dll
  api-ms-win-crt-environment-l1-1-0.dll
  api-ms-win-crt-filesystem-l1-1-0.dll
  api-ms-win-crt-heap-l1-1-0.dll
  api-ms-win-crt-locale-l1-1-0.dll
  api-ms-win-crt-math-l1-1-0.dll
  api-ms-win-crt-private-l1-1-0.dll
  api-ms-win-crt-runtime-l1-1-0.dll
  api-ms-win-crt-stdio-l1-1-0.dll
  api-ms-win-crt-string-l1-1-0.dll
  api-ms-win-crt-time-l1-1-0.dll

Segments:
r--  0x140000000-0x140000600 
r-x  0x140001000-0x14001ee38  {Code} {Data}
rw-  0x14001f000-0x14001f4a0  {Data}
r--  0x140020000-0x140022a70  {Data}
r--  0x140023000-0x140024950  {Data}
r--  0x140025000-0x140026848  {Data}
rw-  0x140027000-0x140027d80  {Data}
rw-  0x140028000-0x1400292cc  {Data}
rw-  0x14002a000-0x14002a068  {Data}
rw-  0x14002b000-0x14002b010  {Data}
r--  0x14002c000-0x14002c154  {Data}
r--  0x14002d000-0x14002d080  {Data}
r--  0x14002e000-0x140030a58  {Data}
r--  0x140031000-0x140031430  {Data}
r--  0x140032000-0x14003247c  {Data}
r--  0x140033000-0x140033150  {Data}
r--  0x140034000-0x1400340b0  {Data}
r--  0x140035000-0x1400353d6  {Data}
r--  0x140036000-0x1400362f8  {Data}
r--  0x140037000-0x14003704d  {Data}
---  0x140037050-0x1400373a8 
---  0x1400373b0-0x1400373e0 

Sections:
0x140001000-0x14001ee38  .text  {Code}
0x14001f000-0x14001f4a0  .data  {Writable data}
0x140020000-0x140022a70  .rdata  {Read-only data}
0x140023000-0x140024950  .pdata  {Read-only data}
0x140025000-0x140026848  .xdata  {Read-only data}
0x140027000-0x140027d80  .bss  {Writable data}
0x140028000-0x1400292cc  .idata  {Writable data}
0x14002a000-0x14002a068  .CRT  {Writable data}
0x14002b000-0x14002b010  .tls  {Writable data}
0x14002c000-0x14002c154  .reloc  {Read-only data}
0x14002d000-0x14002d080  .debug_aranges  {Read-only data}
0x14002e000-0x140030a58  .debug_info  {Read-only data}
0x140031000-0x140031430  .debug_abbrev  {Read-only data}
0x140032000-0x14003247c  .debug_line  {Read-only data}
0x140033000-0x140033150  .debug_frame  {Read-only data}
0x140034000-0x1400340b0  .debug_str  {Read-only data}
0x140035000-0x1400353d6  .debug_line_str  {Read-only data}
0x140036000-0x1400362f8  .debug_loclists  {Read-only data}
0x140037000-0x14003704d  .debug_rnglists  {Read-only data}
0x140037050-0x1400373a8  .extern  {External}
0x1400373b0-0x1400373e0  .synthetic_builtins  {External}
*/
140000000  struct DOS_Header __dos_header = 
140000000  {
140000000      char e_magic[0x2] = "MZ"
140000002      uint16_t e_cblp = 0x90
140000004      uint16_t e_cp = 0x3
140000006      uint16_t e_crlc = 0x0
140000008      uint16_t e_cparhdr = 0x4
14000000a      uint16_t e_minalloc = 0x0
14000000c      uint16_t e_maxalloc = 0xffff
14000000e      uint16_t e_ss = 0x0
140000010      uint16_t e_sp = 0xb8
140000012      uint16_t e_csum = 0x0
140000014      uint16_t e_ip = 0x0
140000016      uint16_t e_cs = 0x0
140000018      uint16_t e_lfarlc = 0x40
14000001a      uint16_t e_ovno = 0x0
14000001c      char e_res1[0x8] = "\x00\x00\x00\x00\x00\x00\x00", 0
140000024      uint16_t e_oemid = 0x0
140000026      uint16_t e_oeminfo = 0x0
140000028      char e_res2[0x14] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 0
14000003c      uint32_t e_lfanew = 0x80
140000040  }

140000040  __dos_stub:
140000040  0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f  ........!..L.!This program canno
140000060  74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00  t be run in DOS mode....$.......

140000080  struct COFF_Header __coff_header = 
140000080  {
140000080      char magic[0x4] = "PE\x00", 0
140000084      enum coff_machine machine = IMAGE_FILE_MACHINE_AMD64
140000086      uint16_t numberOfSections = 0x13
140000088      uint32_t timeDateStamp = 0x68db33bb
14000008c      uint32_t pointerToSymbolTable = 0x2ae00
140000090      uint32_t numberOfSymbols = 0xc3f
140000094      uint16_t sizeOfOptionalHeader = 0xf0
140000096      enum coff_characteristics characteristics = IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LARGE_ADDRESS_AWARE
140000098  }
140000098  struct PE64_Optional_Header __pe64_optional_header = 
140000098  {
140000098      enum pe_magic magic = PE_64BIT
14000009a      uint8_t majorLinkerVersion = 0x2
14000009b      uint8_t minorLinkerVersion = 0x27
14000009c      uint32_t sizeOfCode = 0x1e000
1400000a0      uint32_t sizeOfInitializedData = 0x26000
1400000a4      uint32_t sizeOfUninitializedData = 0xe00
1400000a8      uint32_t addressOfEntryPoint = 0x13f0
1400000ac      uint32_t baseOfCode = 0x1000
1400000b0      uint64_t imageBase = 0x140000000
1400000b8      uint32_t sectionAlignment = 0x1000
1400000bc      uint32_t fileAlignment = 0x200
1400000c0      uint16_t majorOperatingSystemVersion = 0x4
1400000c2      uint16_t minorOperatingSystemVersion = 0x0
1400000c4      uint16_t majorImageVersion = 0x0
1400000c6      uint16_t minorImageVersion = 0x0
1400000c8      uint16_t majorSubsystemVersion = 0x5
1400000ca      uint16_t minorSubsystemVersion = 0x2
1400000cc      uint32_t win32VersionValue = 0x0
1400000d0      uint32_t sizeOfImage = 0x38000
1400000d4      uint32_t sizeOfHeaders = 0x600
1400000d8      uint32_t checkSum = 0x430c9
1400000dc      enum pe_subsystem subsystem = IMAGE_SUBSYSTEM_WINDOWS_CUI
1400000de      enum pe_dll_characteristics dllCharacteristics = IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA | IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE | IMAGE_DLLCHARACTERISTICS_NX_COMPAT
1400000e0      uint64_t sizeOfStackReserve = 0x200000
1400000e8      uint64_t sizeOfStackCommit = 0x1000
1400000f0      uint64_t sizeOfHeapReserve = 0x100000
1400000f8      uint64_t sizeOfHeapCommit = 0x1000
140000100      uint32_t loaderFlags = 0x0
140000104      uint32_t numberOfRvaAndSizes = 0x10
140000108      struct PE_Data_Directory_Entry exportTableEntry = 
140000108      {
140000108          uint32_t virtualAddress = 0x0
14000010c          uint32_t size = 0x0
140000110      }
140000110      struct PE_Data_Directory_Entry importTableEntry = 
140000110      {
140000110          uint32_t virtualAddress = 0x28000
140000114          uint32_t size = 0x12cc
140000118      }
140000118      struct PE_Data_Directory_Entry resourceTableEntry = 
140000118      {
140000118          uint32_t virtualAddress = 0x0
14000011c          uint32_t size = 0x0
140000120      }
140000120      struct PE_Data_Directory_Entry exceptionTableEntry = 
140000120      {
140000120          uint32_t virtualAddress = 0x23000
140000124          uint32_t size = 0x1950
140000128      }
140000128      struct PE_Data_Directory_Entry certificateTableEntry = 
140000128      {
140000128          uint32_t virtualAddress = 0x0
14000012c          uint32_t size = 0x0
140000130      }
140000130      struct PE_Data_Directory_Entry baseRelocationTableEntry = 
140000130      {
140000130          uint32_t virtualAddress = 0x2c000
140000134          uint32_t size = 0x154
140000138      }
140000138      struct PE_Data_Directory_Entry debugEntry = 
140000138      {
140000138          uint32_t virtualAddress = 0x0
14000013c          uint32_t size = 0x0
140000140      }
140000140      struct PE_Data_Directory_Entry architectureEntry = 
140000140      {
140000140          uint32_t virtualAddress = 0x0
140000144          uint32_t size = 0x0
140000148      }
140000148      struct PE_Data_Directory_Entry globalPtrEntry = 
140000148      {
140000148          uint32_t virtualAddress = 0x0
14000014c          uint32_t size = 0x0
140000150      }
140000150      struct PE_Data_Directory_Entry tlsTableEntry = 
140000150      {
140000150          uint32_t virtualAddress = 0x21c40
140000154          uint32_t size = 0x28
140000158      }
140000158      struct PE_Data_Directory_Entry loadConfigTableEntry = 
140000158      {
140000158          uint32_t virtualAddress = 0x0
14000015c          uint32_t size = 0x0
140000160      }
140000160      struct PE_Data_Directory_Entry boundImportEntry = 
140000160      {
140000160          uint32_t virtualAddress = 0x0
140000164          uint32_t size = 0x0
140000168      }
140000168      struct PE_Data_Directory_Entry iatEntry = 
140000168      {
140000168          uint32_t virtualAddress = 0x284bc
14000016c          uint32_t size = 0x3b8
140000170      }
140000170      struct PE_Data_Directory_Entry delayImportDescriptorEntry = 
140000170      {
140000170          uint32_t virtualAddress = 0x0
140000174          uint32_t size = 0x0
140000178      }
140000178      struct PE_Data_Directory_Entry clrRuntimeHeaderEntry = 
140000178      {
140000178          uint32_t virtualAddress = 0x0
14000017c          uint32_t size = 0x0
140000180      }
140000180      struct PE_Data_Directory_Entry reservedEntry = 
140000180      {
140000180          uint32_t virtualAddress = 0x0
140000184          uint32_t size = 0x0
140000188      }
140000188  }
140000188  struct Section_Header __section_headers[0x13] = 
140000188  {
140000188      [0x00] = 
140000188      {
140000188          char name[0x8] = ".text\x00\x00", 0
140000190          uint32_t virtualSize = 0x1de38
140000194          uint32_t virtualAddress = 0x1000
140000198          uint32_t sizeOfRawData = 0x1e000
14000019c          uint32_t pointerToRawData = 0x600
1400001a0          uint32_t pointerToRelocations = 0x0
1400001a4          uint32_t pointerToLineNumbers = 0x0
1400001a8          uint16_t numberOfRelocations = 0x0
1400001aa          uint16_t numberOfLineNumbers = 0x0
1400001ac          enum pe_section_flags characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ
1400001b0      }
1400001b0      [0x01] = 
1400001b0      {
1400001b0          char name[0x8] = ".data\x00\x00", 0
1400001b8          uint32_t virtualSize = 0x4a0
1400001bc          uint32_t virtualAddress = 0x1f000
1400001c0          uint32_t sizeOfRawData = 0x600
1400001c4          uint32_t pointerToRawData = 0x1e600
1400001c8          uint32_t pointerToRelocations = 0x0
1400001cc          uint32_t pointerToLineNumbers = 0x0
1400001d0          uint16_t numberOfRelocations = 0x0
1400001d2          uint16_t numberOfLineNumbers = 0x0
1400001d4          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
1400001d8      }
1400001d8      [0x02] = 
1400001d8      {
1400001d8          char name[0x8] = ".rdata\x00", 0
1400001e0          uint32_t virtualSize = 0x2a70
1400001e4          uint32_t virtualAddress = 0x20000
1400001e8          uint32_t sizeOfRawData = 0x2c00
1400001ec          uint32_t pointerToRawData = 0x1ec00
1400001f0          uint32_t pointerToRelocations = 0x0
1400001f4          uint32_t pointerToLineNumbers = 0x0
1400001f8          uint16_t numberOfRelocations = 0x0
1400001fa          uint16_t numberOfLineNumbers = 0x0
1400001fc          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ
140000200      }
140000200      [0x03] = 
140000200      {
140000200          char name[0x8] = ".pdata\x00", 0
140000208          uint32_t virtualSize = 0x1950
14000020c          uint32_t virtualAddress = 0x23000
140000210          uint32_t sizeOfRawData = 0x1a00
140000214          uint32_t pointerToRawData = 0x21800
140000218          uint32_t pointerToRelocations = 0x0
14000021c          uint32_t pointerToLineNumbers = 0x0
140000220          uint16_t numberOfRelocations = 0x0
140000222          uint16_t numberOfLineNumbers = 0x0
140000224          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ
140000228      }
140000228      [0x04] = 
140000228      {
140000228          char name[0x8] = ".xdata\x00", 0
140000230          uint32_t virtualSize = 0x1848
140000234          uint32_t virtualAddress = 0x25000
140000238          uint32_t sizeOfRawData = 0x1a00
14000023c          uint32_t pointerToRawData = 0x23200
140000240          uint32_t pointerToRelocations = 0x0
140000244          uint32_t pointerToLineNumbers = 0x0
140000248          uint16_t numberOfRelocations = 0x0
14000024a          uint16_t numberOfLineNumbers = 0x0
14000024c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ
140000250      }
140000250      [0x05] = 
140000250      {
140000250          char name[0x8] = ".bss\x00\x00\x00", 0
140000258          uint32_t virtualSize = 0xd80
14000025c          uint32_t virtualAddress = 0x27000
140000260          uint32_t sizeOfRawData = 0x0
140000264          uint32_t pointerToRawData = 0x0
140000268          uint32_t pointerToRelocations = 0x0
14000026c          uint32_t pointerToLineNumbers = 0x0
140000270          uint16_t numberOfRelocations = 0x0
140000272          uint16_t numberOfLineNumbers = 0x0
140000274          enum pe_section_flags characteristics = IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
140000278      }
140000278      [0x06] = 
140000278      {
140000278          char name[0x8] = ".idata\x00", 0
140000280          uint32_t virtualSize = 0x12cc
140000284          uint32_t virtualAddress = 0x28000
140000288          uint32_t sizeOfRawData = 0x1400
14000028c          uint32_t pointerToRawData = 0x24c00
140000290          uint32_t pointerToRelocations = 0x0
140000294          uint32_t pointerToLineNumbers = 0x0
140000298          uint16_t numberOfRelocations = 0x0
14000029a          uint16_t numberOfLineNumbers = 0x0
14000029c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
1400002a0      }
1400002a0      [0x07] = 
1400002a0      {
1400002a0          char name[0x8] = ".CRT\x00\x00\x00", 0
1400002a8          uint32_t virtualSize = 0x68
1400002ac          uint32_t virtualAddress = 0x2a000
1400002b0          uint32_t sizeOfRawData = 0x200
1400002b4          uint32_t pointerToRawData = 0x26000
1400002b8          uint32_t pointerToRelocations = 0x0
1400002bc          uint32_t pointerToLineNumbers = 0x0
1400002c0          uint16_t numberOfRelocations = 0x0
1400002c2          uint16_t numberOfLineNumbers = 0x0
1400002c4          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
1400002c8      }
1400002c8      [0x08] = 
1400002c8      {
1400002c8          char name[0x8] = ".tls\x00\x00\x00", 0
1400002d0          uint32_t virtualSize = 0x10
1400002d4          uint32_t virtualAddress = 0x2b000
1400002d8          uint32_t sizeOfRawData = 0x200
1400002dc          uint32_t pointerToRawData = 0x26200
1400002e0          uint32_t pointerToRelocations = 0x0
1400002e4          uint32_t pointerToLineNumbers = 0x0
1400002e8          uint16_t numberOfRelocations = 0x0
1400002ea          uint16_t numberOfLineNumbers = 0x0
1400002ec          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
1400002f0      }
1400002f0      [0x09] = 
1400002f0      {
1400002f0          char name[0x8] = ".reloc\x00", 0
1400002f8          uint32_t virtualSize = 0x154
1400002fc          uint32_t virtualAddress = 0x2c000
140000300          uint32_t sizeOfRawData = 0x200
140000304          uint32_t pointerToRawData = 0x26400
140000308          uint32_t pointerToRelocations = 0x0
14000030c          uint32_t pointerToLineNumbers = 0x0
140000310          uint16_t numberOfRelocations = 0x0
140000312          uint16_t numberOfLineNumbers = 0x0
140000314          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
140000318      }
140000318      [0x0a] = 
140000318      {
140000318          char name[0x8] = "/4\x00\x00\x00\x00\x00", 0
140000320          uint32_t virtualSize = 0x80
140000324          uint32_t virtualAddress = 0x2d000
140000328          uint32_t sizeOfRawData = 0x200
14000032c          uint32_t pointerToRawData = 0x26600
140000330          uint32_t pointerToRelocations = 0x0
140000334          uint32_t pointerToLineNumbers = 0x0
140000338          uint16_t numberOfRelocations = 0x0
14000033a          uint16_t numberOfLineNumbers = 0x0
14000033c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
140000340      }
140000340      [0x0b] = 
140000340      {
140000340          char name[0x8] = "/19\x00\x00\x00\x00", 0
140000348          uint32_t virtualSize = 0x2a58
14000034c          uint32_t virtualAddress = 0x2e000
140000350          uint32_t sizeOfRawData = 0x2c00
140000354          uint32_t pointerToRawData = 0x26800
140000358          uint32_t pointerToRelocations = 0x0
14000035c          uint32_t pointerToLineNumbers = 0x0
140000360          uint16_t numberOfRelocations = 0x0
140000362          uint16_t numberOfLineNumbers = 0x0
140000364          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
140000368      }
140000368      [0x0c] = 
140000368      {
140000368          char name[0x8] = "/31\x00\x00\x00\x00", 0
140000370          uint32_t virtualSize = 0x430
140000374          uint32_t virtualAddress = 0x31000
140000378          uint32_t sizeOfRawData = 0x600
14000037c          uint32_t pointerToRawData = 0x29400
140000380          uint32_t pointerToRelocations = 0x0
140000384          uint32_t pointerToLineNumbers = 0x0
140000388          uint16_t numberOfRelocations = 0x0
14000038a          uint16_t numberOfLineNumbers = 0x0
14000038c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
140000390      }
140000390      [0x0d] = 
140000390      {
140000390          char name[0x8] = "/45\x00\x00\x00\x00", 0
140000398          uint32_t virtualSize = 0x47c
14000039c          uint32_t virtualAddress = 0x32000
1400003a0          uint32_t sizeOfRawData = 0x600
1400003a4          uint32_t pointerToRawData = 0x29a00
1400003a8          uint32_t pointerToRelocations = 0x0
1400003ac          uint32_t pointerToLineNumbers = 0x0
1400003b0          uint16_t numberOfRelocations = 0x0
1400003b2          uint16_t numberOfLineNumbers = 0x0
1400003b4          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
1400003b8      }
1400003b8      [0x0e] = 
1400003b8      {
1400003b8          char name[0x8] = "/57\x00\x00\x00\x00", 0
1400003c0          uint32_t virtualSize = 0x150
1400003c4          uint32_t virtualAddress = 0x33000
1400003c8          uint32_t sizeOfRawData = 0x200
1400003cc          uint32_t pointerToRawData = 0x2a000
1400003d0          uint32_t pointerToRelocations = 0x0
1400003d4          uint32_t pointerToLineNumbers = 0x0
1400003d8          uint16_t numberOfRelocations = 0x0
1400003da          uint16_t numberOfLineNumbers = 0x0
1400003dc          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
1400003e0      }
1400003e0      [0x0f] = 
1400003e0      {
1400003e0          char name[0x8] = "/70\x00\x00\x00\x00", 0
1400003e8          uint32_t virtualSize = 0xb0
1400003ec          uint32_t virtualAddress = 0x34000
1400003f0          uint32_t sizeOfRawData = 0x200
1400003f4          uint32_t pointerToRawData = 0x2a200
1400003f8          uint32_t pointerToRelocations = 0x0
1400003fc          uint32_t pointerToLineNumbers = 0x0
140000400          uint16_t numberOfRelocations = 0x0
140000402          uint16_t numberOfLineNumbers = 0x0
140000404          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
140000408      }
140000408      [0x10] = 
140000408      {
140000408          char name[0x8] = "/81\x00\x00\x00\x00", 0
140000410          uint32_t virtualSize = 0x3d6
140000414          uint32_t virtualAddress = 0x35000
140000418          uint32_t sizeOfRawData = 0x400
14000041c          uint32_t pointerToRawData = 0x2a400
140000420          uint32_t pointerToRelocations = 0x0
140000424          uint32_t pointerToLineNumbers = 0x0
140000428          uint16_t numberOfRelocations = 0x0
14000042a          uint16_t numberOfLineNumbers = 0x0
14000042c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
140000430      }
140000430      [0x11] = 
140000430      {
140000430          char name[0x8] = "/97\x00\x00\x00\x00", 0
140000438          uint32_t virtualSize = 0x2f8
14000043c          uint32_t virtualAddress = 0x36000
140000440          uint32_t sizeOfRawData = 0x400
140000444          uint32_t pointerToRawData = 0x2a800
140000448          uint32_t pointerToRelocations = 0x0
14000044c          uint32_t pointerToLineNumbers = 0x0
140000450          uint16_t numberOfRelocations = 0x0
140000452          uint16_t numberOfLineNumbers = 0x0
140000454          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
140000458      }
140000458      [0x12] = 
140000458      {
140000458          char name[0x8] = "/113\x00\x00\x00", 0
140000460          uint32_t virtualSize = 0x4d
140000464          uint32_t virtualAddress = 0x37000
140000468          uint32_t sizeOfRawData = 0x200
14000046c          uint32_t pointerToRawData = 0x2ac00
140000470          uint32_t pointerToRelocations = 0x0
140000474          uint32_t pointerToLineNumbers = 0x0
140000478          uint16_t numberOfRelocations = 0x0
14000047a          uint16_t numberOfLineNumbers = 0x0
14000047c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ
140000480      }
140000480  }

140000480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400004a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400004c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400004e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140000580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400005a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400005c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400005e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

.text section started  {0x140001000-0x14001ee38}

140001000    int64_t __mingw_invalidParameterHandler() __pure

140001000  {
140001000      return;
140001000  }

140001001     66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00                                                   ff...........@.

140001010    int64_t pre_c_init()

140001010  {
14000101d      __mingw_initltsdrot_force = 1;
14000102a      __mingw_initltsdyn_force = 1;
140001037      _.bss = 1;
1400010e9      int32_t rcx;
1400010e9      (uint8_t)rcx = false;
140001061      managedapp = rcx;
140001061      
14000106b      if (!_.bss)
1400010b5          _set_app_type(_crt_console_app);
14000106b      else
140001072          _set_app_type(_crt_gui_app);
140001072      
140001077      int32_t* rax_1 = __p__fmode();
140001085      *(uint32_t*)rax_1 = _.bss;
140001087      int32_t* rax_2 = __p__commode();
140001095      *(uint32_t*)rax_2 = _.bss;
140001095      
1400010a6      if (_.data != 1)
1400010ae          return 0;
1400010ae      
1400010ff      __mingw_setusermatherr(_matherr);
14000110a      return 0;
140001010  }

1400010af                                               90                                                                 .
1400010bc                                                                                      0f 1f 40 00                              ..@.
1400010f1                                                     0f 1f 80 00 00 00 00                                           .......
14000110b                                   0f 1f 44 00 00                                                             ..D..
14000112e                                            66 90                                                                f.

140001130    int64_t pre_cpp_init()

140001130  {
140001152      startinfo = _.bss;
14000116e      __getmainargs(&argc, &argv, &envp, _.data, &startinfo);
140001178      return 0;
140001130  }

140001179                                                                             0f 1f 80 00 00 00 00                           .......

140001180    uint64_t __tmainCRTStartup()

140001180  {
1400011a3      TEB* gsbase;
1400011a3      void* StackBase = gsbase->NtTib.Self->NtTib.StackBase;
1400011c0      int32_t rdi;
1400011c0      
1400011c0      while (true)
1400011c0      {
1400011c0          int64_t _.bss_1 = 0;
1400011c0          
1400011c3          if (0 == _.bss)
1400011c3              _.bss = StackBase;
1400011c3          else
1400011c3              _.bss_1 = _.bss;
1400011c3          
1400011cb          if (!_.bss_1)
1400011cb          {
1400011d4              rdi = 0;
1400011d4              
1400011db              if (__native_startup_state != 1)
1400011db                  break;
1400011cb          }
1400011cb          else if (StackBase == _.bss_1)
1400011b3          {
140001327              rdi = 1;
140001327              
140001331              if (__native_startup_state != 1)
140001331                  break;
1400011b3          }
1400011b3          else
1400011b3          {
1400011be              Sleep(0x3e8);
1400011be              continue;
1400011b3          }
1400011b3          
14000133c          _amsg_exit(0x1f);
14000133c          /* no return */
1400011c0      }
1400011c0      
1400011e5      if (!__native_startup_state)
1400011e5      {
1400013a7          __native_startup_state = 1;
1400013b4          _initterm(&_.CRT$XIA, &_.CRT$XIZ);
1400011e5      }
1400011e5      else
1400011eb          has_cctor = 1;
1400011eb      
1400011fa      if (__native_startup_state == 1)
1400011fa      {
14000135a          _initterm(&_.CRT$XCA, &_.CRT$XCZ);
140001361          __native_startup_state = 2;
140001361          
140001367          if (!rdi)
140001367          {
14000136f              _.bss;
14000136f              _.bss = 0;
140001367          }
1400011fa      }
1400011fa      else if (!rdi)
140001202      {
14000136f          _.bss;
14000136f          _.bss = 0;
140001202      }
140001202      
140001221      _TLS_Entry_0(0, 2);
140001223      _pei386_runtime_relocator();
140001243      _.bss = SetUnhandledExceptionFilter(_gnu_exception_handler);
140001246      _set_invalid_parameter_handler(__mingw_invalidParameterHandler);
140001250      int32_t argc_2 = argc;
14000125c      int64_t _Size_1 = (int64_t)(argc_2 + 1) << 3;
140001263      void* rax_5 = malloc(_Size_1);
14000126a      int64_t* argv_1 = argv;
140001271      int64_t* r12 = rax_5;
140001274      void* rdi_4;
140001274      
140001274      if (argc_2 <= 0)
1400013c0          rdi_4 = rax_5;
140001274      else
140001274      {
14000127e          int64_t i = 0;
14000127e          
1400012b1          do
1400012b1          {
14000128a              uint64_t _Size = strlen(*(uint64_t*)((char*)argv_1 + i)) + 1;
140001291              int64_t rax_7 = malloc(_Size);
140001299              *(uint64_t*)((char*)r12 + i) = rax_7;
14000129d              int64_t rdx_1 = *(uint64_t*)((char*)argv_1 + i);
1400012a5              i += 8;
1400012a9              memcpy(rax_7, rdx_1, _Size);
1400012b1          } while (_Size_1 - 8 != i);
1400012b1          
1400012b3          rdi_4 = _Size_1 - 8 + r12;
140001274      }
140001274      
1400012b6      *(uint64_t*)rdi_4 = 0;
1400012bd      argv = r12;
1400012c4      __main();
1400012d0      int64_t envp_1 = envp;
1400012d7      int32_t argc_1 = argc;
1400012e0      **(uint64_t**)&__imp___initenv = envp_1;
1400012ea      int32_t result = main(argc_1, argv, envp_1);
1400012ef      int32_t managedapp_1 = managedapp;
1400012f5      mainret = result;
1400012f5      
1400012fd      if (!managedapp_1)
1400012fd      {
1400013ca          exit(result);
1400013ca          /* no return */
1400012fd      }
1400012fd      
14000130b      if (has_cctor)
140001317          return result;
140001317      
140001380      _cexit();
140001395      return (uint64_t)mainret;
140001180  }

1400011a9                             0f 1f 80 00 00 00 00                                                           .......
140001318                                                                          0f 1f 84 00 00 00 00 00                          ........
140001341     8b 06 83 f8 01 0f 85 b4 fe ff ff                                                               ...........
140001377                                                                       66 0f 1f 84 00 00 00 00 00                         f........
140001396                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
1400013be                                                                                            66 90                                f.
1400013cf                                               90                                                                 .

1400013d0    uint64_t WinMainCRTStartup()

1400013d0  {
1400013db      _.bss = 1;
1400013ec      return __tmainCRTStartup();
1400013d0  }

1400013ed                                         0f 1f 00                                                               ...

1400013f0    uint64_t _start()

1400013f0  {
1400013fb      _.bss = 0;
14000140c      return __tmainCRTStartup();
1400013f0  }

14000140d                                         0f 1f 00                                                               ...

140001410    uint64_t atexit(_PVFV arg1)

140001410  {
140001414      _PVFV rax = _onexit(arg1);
140001423      return (uint64_t)((uint32_t)rax - (uint32_t)rax);
140001410  }

140001424              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

140001430    int64_t __gcc_register_frame()

140001430  {
140001437      /* tailcall */
140001437      return atexit(__gcc_deregister_frame);
140001430  }

14000143c                                                                                      0f 1f 40 00                              ..@.

140001440    int64_t __gcc_deregister_frame() __pure

140001440  {
140001440      return;
140001440  }

140001441     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

140001450    int64_t nimFrame(void** arg1)

140001450  {
140001471      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
14000149f          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
14000149f              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
140001471      else
140001477          *(uint16_t*)((char*)arg1 + 0x22) = 0;
140001477      
1400014ad      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
1400014b9      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
1400014c0      *(uint64_t*)rax_8 = arg1;
1400014c7      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
1400014c7      
1400014cf      if (result != 0x7d0)
1400014df          return result;
1400014df      
1400014d1      return callDepthLimitReached__system_u4678();
140001450  }


1400014e0    int64_t* popFrame()

1400014e0  {
1400014f2      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
1400014fd      *(uint64_t*)result = **(uint64_t**)result;
140001506      return result;
1400014e0  }


140001507    int64_t minuspercent___system_u813(int64_t arg1, int64_t arg2)

140001507  {
14000151e      void* const var_40 = &data_140020080;
140001529      char const* const var_30 =
140001529          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
14000152d      int64_t var_38 = 0;
140001535      int16_t var_28 = 0;
140001542      void* var_48;
140001542      nimFrame(&var_48);
140001547      int64_t var_38_1 = 0x16c;
140001556      char const* const var_30_1 =
140001556          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
14000155a      int64_t var_38_2 = 0x170;
140001571      popFrame();
14000157f      return arg1 - arg2;
140001507  }


140001580    int64_t nimErrorFlag()

140001580  {
1400015a4      return __emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
140001580  }


1400015a5    uint64_t nimDecRefIsLastCyclicDyn(void** arg1)

1400015a5  {
1400015b8      char const* const var_50 = "nimDecRefIsLastCyclicDyn";
1400015c3      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
1400015c7      int64_t var_48 = 0;
1400015cf      int16_t var_38 = 0;
1400015dc      void* var_58;
1400015dc      nimFrame(&var_58);
1400015e6      char* var_18 = nimErrorFlag();
1400015ea      int64_t var_48_1 = 0x200;
1400015f9      char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
1400015fd      char var_9 = 0;
140001601      int64_t var_48_2 = 0x201;
140001601      
14000160e      if (arg1)
14000160e      {
140001614          int64_t var_48_3 = 0x202;
14000161c          int64_t var_48_4 = 0x3a;
14000162b          char const* const var_40_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000162f          int64_t var_20_1 = 0;
140001643          int64_t* rax_2 = minuspercent___system_u813(arg1, 0x10);
140001654          int64_t var_48_5 = 0x203;
140001663          char const* const var_40_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140001672          int64_t var_48_8;
140001672          
140001672          if (*(uint64_t*)rax_2 > 0xf)
140001672          {
140001683              int64_t var_48_7 = 0x207;
14000168f              int64_t rax_7 = *(uint64_t*)rax_2;
140001692              char rdx_1 = 0;
140001692              
14000169b              if (rax_7 - 0x10)
14000169d                  rdx_1 = 1;
14000169d              
1400016b4              if (!(rdx_1 & 1))
1400016b4              {
1400016c5                  *(uint64_t*)rax_2 = rax_7 - 0x10;
1400016c8                  var_48_8 = 0x209;
1400016e4                  rememberCycle__system_u3495(var_9, rax_2, *(uint64_t*)arg1);
1400016b4              }
1400016b4              else
1400016b6                  raiseOverflow();
140001672          }
140001672          else
140001672          {
140001674              int64_t var_48_6 = 0x204;
14000167c              var_9 = 1;
1400016c8              var_48_8 = 0x209;
1400016e4              rememberCycle__system_u3495(var_9, rax_2, *(uint64_t*)arg1);
140001672          }
14000160e      }
14000160e      
1400016f8      popFrame();
140001706      return (uint64_t)var_9;
1400015a5  }


140001707    int64_t eqdestroy___system_u5217(void* arg1)

140001707  {
140001713      char var_9 = 0;
140001713      
140001733      if (nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 8)) == 1)
140001740          nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 8));
140001740      
140001773      if (*(uint64_t*)((char*)arg1 + 0x20)
140001773              && !(0x4000000000000000 & **(uint64_t**)((char*)arg1 + 0x20)))
140001780          deallocShared(*(uint64_t*)((char*)arg1 + 0x20));
140001780      
140001789      int64_t rdx_2 = *(uint64_t*)((char*)arg1 + 0x30);
140001791      int64_t var_28 = *(uint64_t*)((char*)arg1 + 0x28);
140001795      int64_t var_20 = rdx_2;
1400017a0      eqdestroy___stdZassertions_u74(&var_28);
1400017a5      char var_a = 0;
1400017c0      char result = nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 0x38)) ^ 1;
1400017c0      
1400017c5      if (result)
1400017e0          return result;
1400017e0      
1400017d2      return nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 0x38));
140001707  }


1400017e1    uint64_t rttiDestroy__systemZexceptions_u56(void* arg1)

1400017e1  {
1400017ed      char* rax = nimErrorFlag();
1400017fd      eqdestroy___system_u5217(arg1);
140001815      return (uint64_t)*(uint8_t*)rax;
1400017e1  }


140001816    int64_t* add__system_u2978(int64_t* arg1, int64_t arg2, int64_t arg3)

140001816  {
140001831      void* const var_50 = &data_14002014a;
14000183c      char const* const var_40 =
14000183c          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140001840      int64_t var_48 = 0;
140001848      int16_t var_38 = 0;
140001855      void* var_58;
140001855      nimFrame(&var_58);
14000185a      int64_t var_48_1 = 0x1c;
140001869      char const* const var_40_1 =
140001869          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140001869      
14000187f      if (arg1[1] <= *(uint64_t*)arg1)
14000187f      {
140001881          int64_t var_48_2 = 0x1d;
140001890          resize__system_u2986(arg1);
14000187f      }
14000187f      
140001898      int64_t var_48_3 = 0x1e;
1400018ca      *(uint64_t*)((*(uint64_t*)arg1 << 4) + arg1[2]) = arg2;
1400018e7      *(uint64_t*)((*(uint64_t*)arg1 << 4) + arg1[2] + 8) = arg3;
1400018eb      int64_t var_48_4 = 0x1f;
1400018f7      int64_t rax_17 = *(uint64_t*)arg1;
1400018fa      char rdx_5 = 0;
1400018fa      
140001903      if (rax_17 + 1)
140001905          rdx_5 = 1;
140001905      
14000191c      if (!(rdx_5 & 1))
14000192d          *(uint64_t*)arg1 = rax_17 + 1;
14000191c      else
14000191e          raiseOverflow();
14000191e      
14000193b      return popFrame();
140001816  }


14000193c    int64_t* nimTraceRefDyn(int64_t* arg1, int64_t* arg2)

14000193c  {
140001953      char const* const var_40 = "nimTraceRefDyn";
14000195e      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140001962      int64_t var_38 = 0;
14000196a      int16_t var_28 = 0;
140001977      void* var_48;
140001977      nimFrame(&var_48);
14000197c      int64_t var_38_1 = 0x88;
14000198b      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140001997      int64_t var_38_2 = 0x89;
140001997      
1400019a9      if (*(uint64_t*)arg1)
1400019a9      {
1400019ab          int64_t var_38_3 = 0x8a;
1400019bb          int64_t var_38_4 = 0x8b;
1400019db          add__system_u2978(arg2, arg1, **(uint64_t**)arg1);
1400019a9      }
1400019a9      
1400019ee      return popFrame();
14000193c  }


1400019ef    int64_t* eqtrace___system_u5229(void* arg1, int64_t* arg2)

1400019ef  {
140001a0e      nimTraceRefDyn((char*)arg1 + 8, arg2);
140001a2d      return nimTraceRefDyn((char*)arg1 + 0x38, arg2);
1400019ef  }


140001a2e    int64_t eqdestroy___system_u4744(void* arg1)

140001a2e  {
140001a3a      char var_9 = 0;
140001a3a      
140001a5a      if (nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 8)) == 1)
140001a67          nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 8));
140001a67      
140001a9a      if (*(uint64_t*)((char*)arg1 + 0x20)
140001a9a              && !(0x4000000000000000 & **(uint64_t**)((char*)arg1 + 0x20)))
140001aa7          deallocShared(*(uint64_t*)((char*)arg1 + 0x20));
140001aa7      
140001ab0      int64_t rdx_2 = *(uint64_t*)((char*)arg1 + 0x30);
140001ab8      int64_t var_28 = *(uint64_t*)((char*)arg1 + 0x28);
140001abc      int64_t var_20 = rdx_2;
140001ac7      eqdestroy___stdZassertions_u74(&var_28);
140001acc      char var_a = 0;
140001ae7      char result = nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 0x38)) ^ 1;
140001ae7      
140001aec      if (result)
140001b07          return result;
140001b07      
140001af9      return nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 0x38));
140001a2e  }


140001b08    uint64_t rttiDestroy__systemZexceptions_u60(void* arg1)

140001b08  {
140001b14      char* rax = nimErrorFlag();
140001b24      eqdestroy___system_u4744(arg1);
140001b3c      return (uint64_t)*(uint8_t*)rax;
140001b08  }


140001b3d    int64_t* eqtrace___system_u4756(void* arg1, int64_t* arg2)

140001b3d  {
140001b5c      nimTraceRefDyn((char*)arg1 + 8, arg2);
140001b7b      return nimTraceRefDyn((char*)arg1 + 0x38, arg2);
140001b3d  }


140001b7c    int64_t eqdestroy___system_u4813(void* arg1)

140001b7c  {
140001b88      char var_9 = 0;
140001b88      
140001ba8      if (nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 8)) == 1)
140001bb5          nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 8));
140001bb5      
140001be8      if (*(uint64_t*)((char*)arg1 + 0x20)
140001be8              && !(0x4000000000000000 & **(uint64_t**)((char*)arg1 + 0x20)))
140001bf5          deallocShared(*(uint64_t*)((char*)arg1 + 0x20));
140001bf5      
140001bfe      int64_t rdx_2 = *(uint64_t*)((char*)arg1 + 0x30);
140001c06      int64_t var_28 = *(uint64_t*)((char*)arg1 + 0x28);
140001c0a      int64_t var_20 = rdx_2;
140001c15      eqdestroy___stdZassertions_u74(&var_28);
140001c1a      char var_a = 0;
140001c35      char result = nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 0x38)) ^ 1;
140001c35      
140001c3a      if (result)
140001c55          return result;
140001c55      
140001c47      return nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 0x38));
140001b7c  }


140001c56    uint64_t rttiDestroy__systemZexceptions_u62(void* arg1)

140001c56  {
140001c62      char* rax = nimErrorFlag();
140001c72      eqdestroy___system_u4813(arg1);
140001c8a      return (uint64_t)*(uint8_t*)rax;
140001c56  }


140001c8b    int64_t* eqtrace___system_u4825(void* arg1, int64_t* arg2)

140001c8b  {
140001caa      nimTraceRefDyn((char*)arg1 + 8, arg2);
140001cc9      return nimTraceRefDyn((char*)arg1 + 0x38, arg2);
140001c8b  }


140001cca    int64_t eqdestroy___system_u4903(void* arg1)

140001cca  {
140001cd6      char var_9 = 0;
140001cd6      
140001cf6      if (nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 8)) == 1)
140001d03          nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 8));
140001d03      
140001d36      if (*(uint64_t*)((char*)arg1 + 0x20)
140001d36              && !(0x4000000000000000 & **(uint64_t**)((char*)arg1 + 0x20)))
140001d43          deallocShared(*(uint64_t*)((char*)arg1 + 0x20));
140001d43      
140001d4c      int64_t rdx_2 = *(uint64_t*)((char*)arg1 + 0x30);
140001d54      int64_t var_28 = *(uint64_t*)((char*)arg1 + 0x28);
140001d58      int64_t var_20 = rdx_2;
140001d63      eqdestroy___stdZassertions_u74(&var_28);
140001d68      char var_a = 0;
140001d83      char result = nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 0x38)) ^ 1;
140001d83      
140001d88      if (result)
140001da3          return result;
140001da3      
140001d95      return nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 0x38));
140001cca  }


140001da4    uint64_t rttiDestroy__systemZexceptions_u64(void* arg1)

140001da4  {
140001db0      char* rax = nimErrorFlag();
140001dc0      eqdestroy___system_u4903(arg1);
140001dd8      return (uint64_t)*(uint8_t*)rax;
140001da4  }


140001dd9    int64_t* eqtrace___system_u4915(void* arg1, int64_t* arg2)

140001dd9  {
140001df8      nimTraceRefDyn((char*)arg1 + 8, arg2);
140001e17      return nimTraceRefDyn((char*)arg1 + 0x38, arg2);
140001dd9  }


140001e18    int64_t eqdestroy___system_u5283(void* arg1)

140001e18  {
140001e24      char var_9 = 0;
140001e24      
140001e44      if (nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 8)) == 1)
140001e51          nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 8));
140001e51      
140001e84      if (*(uint64_t*)((char*)arg1 + 0x20)
140001e84              && !(0x4000000000000000 & **(uint64_t**)((char*)arg1 + 0x20)))
140001e91          deallocShared(*(uint64_t*)((char*)arg1 + 0x20));
140001e91      
140001e9a      int64_t rdx_2 = *(uint64_t*)((char*)arg1 + 0x30);
140001ea2      int64_t var_28 = *(uint64_t*)((char*)arg1 + 0x28);
140001ea6      int64_t var_20 = rdx_2;
140001eb1      eqdestroy___stdZassertions_u74(&var_28);
140001eb6      char var_a = 0;
140001ed1      char result = nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 0x38)) ^ 1;
140001ed1      
140001ed6      if (result)
140001ef1          return result;
140001ef1      
140001ee3      return nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 0x38));
140001e18  }


140001ef2    uint64_t rttiDestroy__systemZexceptions_u66(void* arg1)

140001ef2  {
140001efe      char* rax = nimErrorFlag();
140001f0e      eqdestroy___system_u5283(arg1);
140001f26      return (uint64_t)*(uint8_t*)rax;
140001ef2  }


140001f27    int64_t* eqtrace___system_u5295(void* arg1, int64_t* arg2)

140001f27  {
140001f46      nimTraceRefDyn((char*)arg1 + 8, arg2);
140001f65      return nimTraceRefDyn((char*)arg1 + 0x38, arg2);
140001f27  }


140001f66    int64_t eqdestroy___system_u9056(void* arg1)

140001f66  {
140001f72      char var_9 = 0;
140001f72      
140001f92      if (nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 8)) == 1)
140001f9f          nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 8));
140001f9f      
140001fd2      if (*(uint64_t*)((char*)arg1 + 0x20)
140001fd2              && !(0x4000000000000000 & **(uint64_t**)((char*)arg1 + 0x20)))
140001fdf          deallocShared(*(uint64_t*)((char*)arg1 + 0x20));
140001fdf      
140001fe8      int64_t rdx_2 = *(uint64_t*)((char*)arg1 + 0x30);
140001ff0      int64_t var_28 = *(uint64_t*)((char*)arg1 + 0x28);
140001ff4      int64_t var_20 = rdx_2;
140001fff      eqdestroy___stdZassertions_u74(&var_28);
140002004      char var_a = 0;
14000201f      char result = nimDecRefIsLastCyclicDyn(*(uint64_t*)((char*)arg1 + 0x38)) ^ 1;
14000201f      
140002024      if (result)
14000203f          return result;
14000203f      
140002031      return nimDestroyAndDispose(*(uint64_t*)((char*)arg1 + 0x38));
140001f66  }


140002040    uint64_t rttiDestroy__systemZexceptions_u68(void* arg1)

140002040  {
14000204c      char* rax = nimErrorFlag();
14000205c      eqdestroy___system_u9056(arg1);
140002074      return (uint64_t)*(uint8_t*)rax;
140002040  }


140002075    int64_t* eqtrace___system_u9068(void* arg1, int64_t* arg2)

140002075  {
140002094      nimTraceRefDyn((char*)arg1 + 8, arg2);
1400020b3      return nimTraceRefDyn((char*)arg1 + 0x38, arg2);
140002075  }

1400020b4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

1400020c0    int64_t* nimAddCharV1(int64_t* arg1, char arg2)

1400020c0  {
1400020dd      prepareAdd(arg1, 1);
1400020f5      *(uint8_t*)(arg1[1] + *(uint64_t*)arg1 + 8) = arg2;
1400020fd      int64_t rax_6 = *(uint64_t*)arg1;
140002100      char rdx_1 = 0;
140002100      
140002109      if (rax_6 + 1)
14000210b          rdx_1 = 1;
14000210b      
140002122      if (rdx_1 & 1)
140002124          return raiseOverflow();
140002124      
140002133      *(uint64_t*)arg1 = rax_6 + 1;
140002142      int64_t* result = *(uint64_t*)arg1;
140002145      *(uint8_t*)(arg1[1] + result + 8) = 0;
140002151      return result;
1400020c0  }


140002152    int64_t nimCopyMem(int64_t arg1, int64_t arg2, uint64_t arg3)

140002152  {
140002166      int64_t var_10 = 0;
140002180      int64_t result = memcpy(arg1, arg2, arg3);
140002185      int64_t result_1 = result;
14000218f      return result;
140002152  }


140002190    int64_t copyMem__system_u1731(int64_t arg1, int64_t arg2, uint64_t arg3)

140002190  {
1400021c1      return nimCopyMem(arg1, arg2, arg3);
140002190  }


1400021c2    int64_t nimFrame(void** arg1)

1400021c2  {
1400021e3      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
140002211          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
140002211              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
1400021e3      else
1400021e9          *(uint16_t*)((char*)arg1 + 0x22) = 0;
1400021e9      
14000221f      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
14000222b      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
140002232      *(uint64_t*)rax_8 = arg1;
140002239      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
140002239      
140002241      if (result != 0x7d0)
140002251          return result;
140002251      
140002243      return callDepthLimitReached__system_u4678();
1400021c2  }


140002252    int64_t* popFrame()

140002252  {
140002264      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
14000226f      *(uint64_t*)result = **(uint64_t**)result;
140002278      return result;
140002252  }


140002279    int64_t* addChars__stdZprivateZdigitsutils_u104(int64_t* arg1, int64_t arg2, int64_t arg3, uint64_t arg4)

140002279  {
140002298      char const* const var_40 = "addChars";
1400022a3      char const* const var_30 =
1400022a3          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\private\digitsutils.nim";
1400022a7      int64_t var_38 = 0;
1400022af      int16_t var_28 = 0;
1400022bc      void* var_48;
1400022bc      nimFrame(&var_48);
1400022c1      int64_t var_38_1 = 0x2c;
1400022d0      char const* const var_30_1 =
1400022d0          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\private\digitsutils.nim";
1400022d8      int64_t rax_1 = *(uint64_t*)arg1;
1400022df      int64_t var_38_2 = 0x2d;
1400022e7      char rcx_1 = 0;
1400022f4      uint64_t rax_3 = arg4 + rax_1;
1400022f4      
1400022f7      if (arg4 + rax_1)
1400022f9          rcx_1 = 1;
1400022f9      
140002310      if (rcx_1 & 1)
140002312          raiseOverflow();
140002310      else if (rax_3 >= 0)
140002323      {
140002350          setLengthStrV2(arg1, rax_3);
140002355          int64_t var_38_3 = 0x35;
140002355          
14000236f          if (rax_1 < 0 || rax_1 >= *(uint64_t*)arg1)
140002383              raiseIndexError2(rax_1, *(uint64_t*)arg1 - 1);
14000236f          else if (arg3 > 0x17)
1400023a0              raiseIndexError2(arg3, 0x17);
140002392          else if (arg4 >= 0)
1400023f3              copyMem__system_u1731(rax_1 + arg1[1] + 8, arg3 + arg2, arg4);
1400023ac          else
1400023c4              raiseRangeErrorI(arg4, 0, 0x7fffffffffffffff);
140002323      }
140002323      else
14000233b          raiseRangeErrorI(rax_3, 0, 0x7fffffffffffffff);
14000233b      
140002403      return popFrame();
140002279  }


140002404    int64_t nimErrorFlag()

140002404  {
140002428      return __emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
140002404  }


140002429    int64_t* addIntImpl__stdZprivateZdigitsutils_u61(int64_t* arg1, uint64_t arg2)

140002429  {
140002443      char const* const var_90 = "addIntImpl";
140002451      char const* const var_80 =
140002451          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\private\digitsutils.nim";
140002455      int64_t var_88 = 0;
14000245d      int16_t var_78 = 0;
14000246d      void* var_98;
14000246d      nimFrame(&var_98);
140002477      char* var_20 = nimErrorFlag();
14000247b      int64_t var_88_1 = 0x3c;
140002487      uint64_t var_10 = arg2;
14000248b      int64_t var_88_2 = 0x3d;
140002493      int64_t var_18 = 0x17;
14000249b      int64_t var_88_3 = 0x40;
14000249b      
1400024a8      while (true)
1400024a8      {
1400024a8          char var_58[0x20];
1400024a8          
1400024a8          if (var_10 <= 0x63)
1400024a8          {
1400026e3              int64_t var_88_10 = 0x49;
1400026e3              
1400026f0              if (var_10 > 9)
1400026f0              {
140002736                  int64_t var_88_12 = 0x4c;
140002742                  uint64_t rax_50 = var_10 * 2;
140002749                  int64_t var_88_13 = 0x4d;
140002749                  
140002759                  if (var_18 > 0x17)
140002767                      raiseIndexError2(var_18, 0x17);
140002759                  else if (rax_50 + 1 <= 0xc7)
14000277f                  {
1400027b9                      var_58[var_18] = _.rdata[1][rax_50];
1400027bb                      int64_t var_88_14 = 0x4e;
1400027c3                      char rdx_13 = 0;
1400027c3                      
1400027d0                      if (var_18 - 1)
1400027d2                          rdx_13 = 1;
1400027d2                      
1400027ec                      if (rdx_13 & 1)
1400027ee                          raiseOverflow();
1400027ec                      else if (var_18 - 1 > 0x17)
140002814                          raiseIndexError2(var_18 - 1, 0x17);
140002803                      else if (rax_50 <= 0xc7)
140002826                      {
140002856                          var_58[var_18 - 1] = _.rdata[rax_50];
14000285a                          int64_t var_88_15 = 0x4f;
140002862                          char rdx_15 = 0;
140002862                          
14000286f                          if (var_18 - 1)
140002871                              rdx_15 = 1;
140002871                          
14000288b                          if (!(rdx_15 & 1))
14000288b                          {
14000289b                              var_18 -= 1;
14000289b                              goto label_14000289f;
14000288b                          }
14000288b                          
14000288d                          raiseOverflow();
140002826                      }
140002826                      else
140002834                          raiseIndexError2(rax_50, 0xc7);
14000277f                  }
14000277f                  else
140002791                      raiseIndexError2(rax_50 + 1, 0xc7);
1400026f0              }
1400026f0              else
1400026f0              {
1400026f2                  int64_t var_88_11 = 0x4a;
1400026f2                  
140002702                  if (var_18 <= 0x17)
140002702                  {
14000272e                      var_58[var_18] = (uint8_t)var_10 + 0x30;
14000289f                  label_14000289f:
14000289f                      int64_t var_88_16 = 0x50;
1400028a7                      char rdx_16 = 0;
1400028a7                      
1400028b5                      if (0x18 + -(var_18))
1400028b7                          rdx_16 = 1;
1400028b7                      
1400028ce                      if (!(rdx_16 & 1))
1400028f0                          addChars__stdZprivateZdigitsutils_u104(arg1, &var_58, var_18, 
1400028f0                              0x18 - var_18);
1400028ce                      else
1400028d0                          raiseOverflow();
140002702                  }
140002702                  else
140002710                      raiseIndexError2(var_18, 0x17);
1400026f0              }
1400026f0              
1400026f0              break;
1400024a8          }
1400024a8          
1400024ae          int64_t var_88_4 = 0x41;
1400024ba          uint64_t var_28_1 = var_10;
1400024be          int64_t var_88_5 = 0x42;
1400024e2          var_10 u/= 0x64;
1400024e6          int64_t var_88_6 = 0x43;
1400024e6          
140002507          if ((var_28_1 - var_10 * 0x64) * 2 > 0x7fff)
140002507          {
140002509              raiseRangeErrorNoArgs();
14000250e              break;
140002507          }
140002507          
140002524          int16_t rax_14 = ((uint16_t)var_28_1 - (uint16_t)var_10 * 0x64) * 2;
14000252a          int64_t var_88_7 = 0x44;
14000252a          
14000253a          if (var_18 > 0x17)
14000253a          {
140002548              raiseIndexError2(var_18, 0x17);
14000254d              break;
14000253a          }
14000253a          
14000259d          if ((int64_t)rax_14 + 1 < -0x8000 || (int64_t)rax_14 + 1 > 0x7fff)
14000259d          {
14000259f              raiseOverflow();
1400025a4              break;
14000259d          }
14000259d          
1400025b4          if (rax_14 + 1 > 0xc7)
1400025b4          {
1400025c9              raiseIndexError2((int64_t)(rax_14 + 1), 0xc7);
1400025ce              break;
1400025b4          }
1400025b4          
1400025f3          var_58[var_18] = _.rdata[(int64_t)(rax_14 + 1)];
1400025f5          int64_t var_88_8 = 0x45;
1400025fd          char rdx_7 = 0;
1400025fd          
14000260a          if (var_18 - 1)
14000260c              rdx_7 = 1;
14000260c          
140002626          if (rdx_7 & 1)
140002626          {
140002628              raiseOverflow();
14000262d              break;
140002626          }
140002626          
14000263d          if (var_18 - 1 > 0x17)
14000263d          {
14000264e              raiseIndexError2(var_18 - 1, 0x17);
140002653              break;
14000263d          }
14000263d          
140002660          if (rax_14 > 0xc7)
140002660          {
14000266f              raiseIndexError2((int64_t)rax_14, 0xc7);
140002674              break;
140002660          }
140002660          
140002691          var_58[var_18 - 1] = _.rdata[(int64_t)rax_14];
140002695          int64_t var_88_9 = 0x46;
14000269d          char rdx_9 = 0;
14000269d          
1400026aa          if (var_18 - 2)
1400026ac              rdx_9 = 1;
1400026ac          
1400026c6          if (rdx_9 & 1)
1400026c6          {
1400026c8              raiseOverflow();
1400026cd              break;
1400026c6          }
1400026c6          
1400026d9          var_18 -= 2;
1400026dd          continue;
1400024a8      }
1400024a8      
140002910      return popFrame();
140002429  }


140002911    int64_t* addInt__stdZprivateZdigitsutils_u184(int64_t* arg1, uint64_t arg2)

140002911  {
140002928      char const* const var_40 = "addInt";
140002933      char const* const var_30 =
140002933          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\private\digitsutils.nim";
140002937      int64_t var_38 = 0;
14000293f      int16_t var_28 = 0;
14000294c      void* var_48;
14000294c      nimFrame(&var_48);
140002956      char* var_10 = nimErrorFlag();
14000295a      int64_t var_38_1 = 0x58;
14000296d      addIntImpl__stdZprivateZdigitsutils_u61(arg1, arg2);
14000298a      return popFrame();
140002911  }


14000298b    int64_t* addInt__stdZprivateZdigitsutils_u187(int64_t* arg1, uint64_t arg2)

14000298b  {
1400029a2      char const* const var_40 = "addInt";
1400029ad      char const* const var_30 =
1400029ad          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\private\digitsutils.nim";
1400029b1      int64_t var_38 = 0;
1400029b9      int16_t var_28 = 0;
1400029c6      void* var_48;
1400029c6      nimFrame(&var_48);
1400029cb      int64_t var_10 = 0;
1400029d3      int64_t var_38_1 = 0x64;
1400029e0      int64_t var_38_7;
1400029e0      
1400029e0      if (arg2 >= 0)
1400029e0      {
140002a53          int64_t var_38_6 = 0x6b;
140002a63          var_38_7 = 0x71;
140002a76          addInt__stdZprivateZdigitsutils_u184(arg1, arg2);
1400029e0      }
1400029e0      else
1400029e0      {
1400029e2          int64_t var_38_2 = 0x65;
1400029f8          uint64_t var_10_1;
1400029f8          
1400029f8          if (arg2 != -0x8000000000000000)
1400029f8          {
140002a0d              int64_t var_38_4 = 0x68;
140002a0d              
140002a23              if (arg2 != -0x8000000000000000)
140002a23              {
140002a33                  var_10_1 = -(arg2);
140002a33                  goto label_140002a37;
140002a23              }
140002a23              
140002a25              raiseOverflow();
1400029f8          }
1400029f8          else
1400029f8          {
1400029fa              int64_t var_38_3 = 0x66;
140002a06              var_10_1 = arg2;
140002a37          label_140002a37:
140002a37              int64_t var_38_5 = 0x69;
140002a4b              nimAddCharV1(arg1, 0x2d);
140002a63              var_38_7 = 0x71;
140002a76              addInt__stdZprivateZdigitsutils_u184(arg1, var_10_1);
1400029f8          }
1400029e0      }
140002a86      return popFrame();
14000298b  }

140002a87                       90 90 90 90 90 90 90 90 90                                                         .........

140002a90    int64_t nimFrame(void** arg1)

140002a90  {
140002ab1      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
140002adf          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
140002adf              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
140002ab1      else
140002ab7          *(uint16_t*)((char*)arg1 + 0x22) = 0;
140002ab7      
140002aed      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140002af9      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
140002b00      *(uint64_t*)rax_8 = arg1;
140002b07      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
140002b07      
140002b0f      if (result != 0x7d0)
140002b1f          return result;
140002b1f      
140002b11      return callDepthLimitReached__system_u4678();
140002a90  }


140002b20    int64_t* popFrame()

140002b20  {
140002b32      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140002b3d      *(uint64_t*)result = **(uint64_t**)result;
140002b46      return result;
140002b20  }


140002b47    int64_t* addInt__stdZprivateZdigitsutils_u204(int64_t* arg1, uint64_t arg2)

140002b47  {
140002b5e      char const* const var_30 = "addInt";
140002b69      char const* const var_20 =
140002b69          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\private\digitsutils.nim";
140002b6d      int64_t var_28 = 0;
140002b75      int16_t var_18 = 0;
140002b82      void* var_38;
140002b82      nimFrame(&var_38);
140002b87      int64_t var_28_1 = 0x74;
140002b96      char const* const var_20_1 =
140002b96          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\private\digitsutils.nim";
140002ba5      addInt__stdZprivateZdigitsutils_u187(arg1, arg2);
140002bb5      return popFrame();
140002b47  }


140002bb6    int64_t* dollar___systemZdollars_u14(int64_t* arg1, int64_t arg2)

140002bb6  {
140002bcd      void* const var_40 = &data_140020357;
140002bd8      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\dollars.nim";
140002bdc      int64_t var_38 = 0;
140002be4      int16_t var_28 = 0;
140002bf1      void* var_48;
140002bf1      nimFrame(&var_48);
140002bf6      int64_t var_38_1 = 0x14;
140002c05      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\dollars.nim";
140002c09      int64_t var_18 = 0;
140002c18      void* const var_10 = &TM__n49a9aYp5BrbXv9a6OCpJYm0g_2;
140002c1c      int64_t var_38_2 = 0x15;
140002c2f      addInt__stdZprivateZdigitsutils_u204(&var_18, arg2);
140002c34      popFrame();
140002c45      *(uint64_t*)arg1 = var_18;
140002c48      arg1[1] = var_10;
140002c55      return arg1;
140002bb6  }


140002c56    int64_t* dollar___systemZdollars_u34(int64_t* arg1, uint64_t arg2)

140002c56  {
140002c6d      void* const var_40 = &data_140020357;
140002c78      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\dollars.nim";
140002c7c      int64_t var_38 = 0;
140002c84      int16_t var_28 = 0;
140002c91      void* var_48;
140002c91      nimFrame(&var_48);
140002c96      int64_t var_38_1 = 0x14;
140002c9e      int64_t var_18 = 0;
140002cad      void* const var_10 = &TM__n49a9aYp5BrbXv9a6OCpJYm0g_2;
140002cb1      int64_t var_38_2 = 0x15;
140002cc4      addInt__stdZprivateZdigitsutils_u187(&var_18, arg2);
140002cc9      popFrame();
140002cda      *(uint64_t*)arg1 = var_18;
140002cdd      arg1[1] = var_10;
140002cea      return arg1;
140002c56  }

140002ceb                                   90 90 90 90 90                                                             .....

140002cf0    int64_t initLock__coreZlocks_u7(CRITICAL_SECTION* arg1)

140002cf0  {
140002d12      return InitializeCriticalSection(arg1);
140002cf0  }


140002d13    int64_t nimErrorFlag()

140002d13  {
140002d37      return __emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
140002d13  }


140002d38    int64_t acquire__coreZlocks_u14(CRITICAL_SECTION* arg1)

140002d38  {
140002d5a      return EnterCriticalSection(arg1);
140002d38  }


140002d5b    int64_t nimSetMem__systemZmemory_u7(int64_t arg1, int32_t arg2, uint64_t arg3)

140002d5b  {
140002d6e      int64_t var_10 = 0;
140002d87      int64_t result = memset(arg1, arg2, arg3);
140002d8c      int64_t result_1 = result;
140002d96      return result;
140002d5b  }


140002d97    uint64_t nimZeroMem(int64_t arg1, uint64_t arg2)

140002d97  {
140002da7      char* rax = nimErrorFlag();
140002dc3      nimSetMem__systemZmemory_u7(arg1, 0, arg2);
140002ddb      return (uint64_t)*(uint8_t*)rax;
140002d97  }


140002ddc    int64_t nimFrame(void** arg1)

140002ddc  {
140002dfd      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
140002e2b          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
140002e2b              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
140002dfd      else
140002e03          *(uint16_t*)((char*)arg1 + 0x22) = 0;
140002e03      
140002e39      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140002e45      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
140002e4c      *(uint64_t*)rax_8 = arg1;
140002e53      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
140002e53      
140002e5b      if (result != 0x7d0)
140002e6b          return result;
140002e6b      
140002e5d      return callDepthLimitReached__system_u4678();
140002ddc  }


140002e6c    int64_t* popFrame()

140002e6c  {
140002e7e      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140002e89      *(uint64_t*)result = **(uint64_t**)result;
140002e92      return result;
140002e6c  }


140002e93    int64_t minuspercent___system_u813(int64_t arg1, int64_t arg2)

140002e93  {
140002eaa      void* const var_40 = &data_1400204e0;
140002eb5      char const* const var_30 =
140002eb5          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
140002eb9      int64_t var_38 = 0;
140002ec1      int16_t var_28 = 0;
140002ece      void* var_48;
140002ece      nimFrame(&var_48);
140002ed3      int64_t var_38_1 = 0x16c;
140002ee2      char const* const var_30_1 =
140002ee2          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
140002ee6      int64_t var_38_2 = 0x170;
140002efd      popFrame();
140002f0b      return arg1 - arg2;
140002e93  }


140002f0c    int64_t* nimIncRefCyclic(int64_t arg1)

140002f0c  {
140002f1a      char rdx;
140002f1a      char arg_10 = rdx;
140002f24      char const* const var_50 = "nimIncRefCyclic";
140002f2f      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140002f33      int64_t var_48 = 0;
140002f3b      int16_t var_38 = 0;
140002f48      void* var_58;
140002f48      nimFrame(&var_58);
140002f4d      int64_t var_48_1 = 0x2d;
140002f5c      char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140002f60      int64_t var_48_2 = 0x3a;
140002f6f      char const* const var_40_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
140002f73      int64_t var_10 = 0;
140002f87      int64_t* rax_2 = minuspercent___system_u813(arg1, 0x10);
140002f98      int64_t var_48_3 = 0x2e;
140002fa7      char const* const var_40_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140002faf      int64_t rax_5 = *(uint64_t*)rax_2;
140002fb2      char rdx_1 = 0;
140002fb2      
140002fbb      if (rax_5 + 0x10)
140002fbd          rdx_1 = 1;
140002fbd      
140002fd4      if (!(rdx_1 & 1))
140002fe5          *(uint64_t*)rax_2 = rax_5 + 0x10;
140002fd4      else
140002fd6          raiseOverflow();
140002fd6      
140002ff3      return popFrame();
140002f0c  }


140002ff4    uint64_t nimDecRefIsLastCyclicDyn(void** arg1)

140002ff4  {
140003007      char const* const var_50 = "nimDecRefIsLastCyclicDyn";
140003012      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140003016      int64_t var_48 = 0;
14000301e      int16_t var_38 = 0;
14000302b      void* var_58;
14000302b      nimFrame(&var_58);
140003035      char* var_18 = nimErrorFlag();
140003039      int64_t var_48_1 = 0x200;
140003041      char var_9 = 0;
140003045      int64_t var_48_2 = 0x201;
140003045      
140003052      if (arg1)
140003052      {
140003058          int64_t var_48_3 = 0x202;
140003060          int64_t var_48_4 = 0x3a;
14000306f          char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
140003073          int64_t var_20_1 = 0;
140003087          int64_t* rax_2 = minuspercent___system_u813(arg1, 0x10);
140003098          int64_t var_48_5 = 0x203;
1400030a7          char const* const var_40_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
1400030b6          int64_t var_48_8;
1400030b6          
1400030b6          if (*(uint64_t*)rax_2 > 0xf)
1400030b6          {
1400030c7              int64_t var_48_7 = 0x207;
1400030d3              int64_t rax_7 = *(uint64_t*)rax_2;
1400030d6              char rdx_1 = 0;
1400030d6              
1400030df              if (rax_7 - 0x10)
1400030e1                  rdx_1 = 1;
1400030e1              
1400030f8              if (!(rdx_1 & 1))
1400030f8              {
140003109                  *(uint64_t*)rax_2 = rax_7 - 0x10;
14000310c                  var_48_8 = 0x209;
140003128                  rememberCycle__system_u3495(var_9, rax_2, *(uint64_t*)arg1);
1400030f8              }
1400030f8              else
1400030fa                  raiseOverflow();
1400030b6          }
1400030b6          else
1400030b6          {
1400030b8              int64_t var_48_6 = 0x204;
1400030c0              var_9 = 1;
14000310c              var_48_8 = 0x209;
140003128              rememberCycle__system_u3495(var_9, rax_2, *(uint64_t*)arg1);
1400030b6          }
140003052      }
140003052      
14000313c      popFrame();
14000314a      return (uint64_t)var_9;
140002ff4  }


14000314b    uint32_t eqcopy___stdZexitprocs_u97(int64_t* arg1, char* arg2)

14000314b  {
140003169      int64_t var_48;
140003169      nimZeroMem(&var_48, 0x18);
140003175      var_48 = *(uint64_t*)arg1;
14000317d      int64_t var_40 = arg1[1];
140003181      int64_t* rax_1 = arg1[2];
140003195      nimZeroMem(arg1, 0x18);
1400031a1      *(uint8_t*)arg1 = *(uint8_t*)arg2;
1400031a1      
1400031af      if (!(uint32_t)*(uint8_t*)arg1)
1400031af      {
1400031e1          nimZeroMem(&arg1[1], 0x10);
1400031ea          void** rax_12 = arg1[2];
1400031ea          
1400031f9          if (*(uint64_t*)(arg2 + 0x10))
140003207              nimIncRefCyclic(*(uint64_t*)(arg2 + 0x10));
140003207          
140003217          arg1[2] = *(uint64_t*)(arg2 + 0x10);
140003223          arg1[1] = *(uint64_t*)(arg2 + 8);
140003227          char var_21_1 = 0;
140003227          
140003243          if (nimDecRefIsLastCyclicDyn(rax_12) == 1)
14000324c              nimDestroyAndDispose(rax_12);
1400031af      }
1400031af      else
1400031af      {
1400031b8          arg1[1] = 0;
1400031c8          arg1[1] = *(uint64_t*)(arg2 + 8);
1400031af      }
1400031af      
140003259      uint32_t result = (uint32_t)(uint8_t)var_48;
140003259      
14000325e      if (!result)
14000325e      {
140003265          char var_22_1 = 0;
14000327c          result = (uint32_t)nimDecRefIsLastCyclicDyn(rax_1) ^ 1;
14000327c          
140003281          if (!(uint8_t)result)
14000328a              return nimDestroyAndDispose(rax_1);
14000325e      }
14000325e      
14000329a      return result;
14000314b  }


14000329b    int64_t* dollar___stdZexitprocs_u6(int64_t* arg1, char arg2)

14000329b  {
1400032ac      uint32_t rax_1 = (uint32_t)arg2;
1400032b2      int64_t var_18;
1400032b2      void* const var_10;
1400032b2      
1400032b2      if (!rax_1)
1400032b2      {
1400032bb          var_18 = 8;
1400032ca          var_10 = &TM__JXL39bfraktrl3ZkJ5EQGjw_7;
1400032b2      }
1400032b2      else if (rax_1 == 1)
1400032b7      {
1400032d0          var_18 = 7;
1400032df          var_10 = &TM__JXL39bfraktrl3ZkJ5EQGjw_9;
1400032b7      }
1400032b7      else
1400032b7      {
1400032e5          var_18 = 0;
1400032f4          var_10 = &TM__JXL39bfraktrl3ZkJ5EQGjw_11;
1400032b7      }
1400032b7      
140003305      *(uint64_t*)arg1 = var_18;
140003308      arg1[1] = var_10;
140003315      return arg1;
14000329b  }


140003316    uint32_t eqdestroy___stdZexitprocs_u94(char* arg1)

140003316  {
140003329      uint32_t result = (uint32_t)*(uint8_t*)arg1;
140003329      
14000332e      if (!result)
14000332e      {
140003335          char var_9_1 = 0;
140003350          result = (uint32_t)nimDecRefIsLastCyclicDyn(*(uint64_t*)(arg1 + 0x10)) ^ 1;
140003350          
140003355          if (!(uint8_t)result)
140003362              return nimDestroyAndDispose(*(uint64_t*)(arg1 + 0x10));
14000332e      }
14000332e      
140003371      return result;
140003316  }


140003372    char* eqwasMoved___stdZexitprocs_u91(char* arg1)

140003372  {
140003382      *(uint8_t*)arg1 = 0;
140003382      
140003391      if (!(uint32_t)*(uint8_t*)arg1)
1400033b4          return nimZeroMem(&arg1[8], 0x10);
1400033b4      
14000339a      *(uint64_t*)(arg1 + 8) = 0;
1400033c0      return arg1;
140003372  }


1400033c1    int64_t release__coreZlocks_u16(CRITICAL_SECTION* arg1)

1400033c1  {
1400033e3      return LeaveCriticalSection(arg1);
1400033c1  }


1400033e4    int64_t* callClosures__stdZexitprocs_u19()

1400033e4  {
1400033fb      char const* const var_80 = "callClosures";
140003406      char const* const var_70 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
14000340a      int64_t var_78 = 0;
140003412      int16_t var_68 = 0;
14000341f      void* var_88;
14000341f      nimFrame(&var_88);
140003424      char* rax = nimErrorFlag();
140003430      int64_t var_78_1 = 0x53;
14000343f      char const* const var_70_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\core\locks.nim";
14000344d      acquire__coreZlocks_u14(&gFunsLock__stdZexitprocs_u14);
14000344d      
140003461      if (!(uint32_t)*(uint8_t*)rax)
140003461      {
140003467          int64_t var_20_1 = 0;
14000346f          int64_t var_28_1 = 0;
140003477          int64_t var_78_2 = 6;
140003486          char const* const var_70_2 =
140003486              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
14000348a          int64_t var_78_3 = 0x2d;
140003499          char const* const var_70_3 =
140003499              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
14000349d          int64_t _.bss_1 = _.bss;
1400034a8          char rdx_1 = 0;
1400034a8          
1400034b5          if (_.bss_1 - 1)
1400034b7              rdx_1 = 1;
1400034b7          
1400034ce          if (!(rdx_1 & 1))
1400034ce          {
1400034e2              int64_t var_78_4 = 0x21;
1400034f1              char const* const var_70_4 =
1400034f1                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
1400034f9              int64_t var_10_1 = _.bss_1 - 1;
140003500              int64_t var_78_5 = 0x22;
140003500              
140003510              while (true)
140003510              {
140003510                  if (var_10_1 < 0)
140003510                  {
140003787                      int64_t var_78_13 = 0x32;
140003796                      char const* const var_70_10 =
140003796                          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
1400037a9                      setLen__stdZexitprocs_u31(&_.bss, nullptr);
1400037ae                      break;
140003510                  }
140003510                  
140003522                  char var_a8;
140003522                  nimZeroMem(&var_a8, 0x18);
140003527                  int64_t var_78_6 = 0x2d;
140003536                  char const* const var_70_5 =
140003536                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
140003545                  int64_t var_78_7 = 0x3a6;
140003554                  char const* const var_70_6 =
140003554                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
140003554                  
14000356a                  if (var_10_1 < 0 || var_10_1 >= _.bss)
14000356a                  {
14000357e                      raiseIndexError2(var_10_1, _.bss - 1);
140003583                      break;
14000356a                  }
14000356a                  
1400035a0                  void* rax_18 = var_10_1 * 0x18 + data_140027048;
1400035a7                  int64_t var_d8 = *(uint64_t*)((char*)rax_18 + 8);
1400035af                  int64_t var_d0_1 = *(uint64_t*)((char*)rax_18 + 0x10);
1400035b7                  int64_t var_c8_1 = *(uint64_t*)((char*)rax_18 + 0x18);
1400035c6                  eqcopy___stdZexitprocs_u97(&var_a8, &var_d8);
1400035cb                  int64_t var_78_8 = 0x2f;
1400035da                  char const* const var_70_7 =
1400035da                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
1400035e7                  int64_t var_f8;
1400035e7                  int64_t var_e8;
1400035e7                  int64_t var_a0;
1400035e7                  
1400035e7                  if (!(uint32_t)var_a8)
1400035e7                  {
14000360d                      int64_t var_78_10 = 0x30;
14000360d                      
140003622                      if ((uint64_t)var_a8 & 7)
140003622                      {
140003632                          int64_t var_58;
140003632                          dollar___stdZexitprocs_u6(&var_58, var_a8);
140003645                          var_e8 = 0x3c;
140003649                          void* const var_e0_1 = &TM__JXL39bfraktrl3ZkJ5EQGjw_5;
140003655                          var_f8 = var_58;
140003659                          int64_t var_50;
140003659                          int64_t var_f0_1 = var_50;
140003668                          raiseFieldErrorStr(&var_e8, &var_f8);
14000366d                          break;
140003622                      }
140003622                      
140003679                      int64_t var_98;
140003679                      
140003679                      if (!var_98)
14000368e                          var_a0();
140003679                      else
140003686                          var_a0(var_98);
140003686                      
14000369f                      if ((uint32_t)*(uint8_t*)rax)
14000369f                          break;
1400035e7                  }
1400035e7                  else
1400035e7                  {
1400035ec                      int64_t var_78_9 = 0x31;
1400035ec                      
140003602                      if (((uint64_t)var_a8 & 7) != 1)
140003602                      {
1400036b4                          int64_t var_48;
1400036b4                          dollar___stdZexitprocs_u6(&var_48, var_a8);
1400036c7                          var_e8 = 0x3c;
1400036cb                          void* const var_e0_2 = &TM__JXL39bfraktrl3ZkJ5EQGjw_14;
1400036d7                          var_f8 = var_48;
1400036db                          int64_t var_40;
1400036db                          int64_t var_f0_2 = var_40;
1400036ea                          raiseFieldErrorStr(&var_e8, &var_f8);
1400036ef                          break;
140003602                      }
140003602                      
1400036f8                      var_a0();
1400036f8                      
140003709                      if ((uint32_t)*(uint8_t*)rax)
140003709                          break;
1400035e7                  }
140003712                  int64_t var_78_11 = 0x27;
140003721                  char const* const var_70_8 =
140003721                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
140003725                  char rdx_14 = 0;
140003725                  
140003735                  if (var_10_1 - 1)
140003737                      rdx_14 = 1;
140003737                  
14000374e                  if (rdx_14 & 1)
14000374e                  {
140003750                      raiseOverflow();
140003755                      break;
14000374e                  }
14000374e                  
14000375b                  var_10_1 -= 1;
140003762                  int64_t var_78_12 = 0x3a6;
140003771                  char const* const var_70_9 =
140003771                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000377c                  eqdestroy___stdZexitprocs_u94(&var_a8);
140003781                  continue;
140003510              }
1400034ce          }
1400034ce          else
1400034d0              raiseOverflow();
1400034d0          
1400037b8          char rax_48 = *(uint8_t*)rax;
1400037c5          *(uint8_t*)rax = 0;
1400037c8          int64_t var_78_14 = 0x58;
1400037d7          char const* const var_70_11 =
1400037d7              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\core\locks.nim";
1400037e5          release__coreZlocks_u16(&gFunsLock__stdZexitprocs_u14);
1400037e5          
1400037f9          if (!(uint32_t)*(uint8_t*)rax)
140003806              *(uint8_t*)rax = rax_48;
140003461      }
140003461      
14000382b      return popFrame();
1400033e4  }


14000382c    int64_t* addExitProc__stdZexitprocs_u184(int64_t* arg1)

14000382c  {
140003840      int64_t rax = *(uint64_t*)arg1;
140003843      int64_t rdx = arg1[1];
14000385c      char const* const var_90 = "addExitProc";
140003867      char const* const var_80 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
14000386b      int64_t var_88 = 0;
140003873      int16_t var_78 = 0;
140003880      void* var_98;
140003880      nimFrame(&var_98);
140003885      char* rax_1 = nimErrorFlag();
14000388e      int64_t var_88_1 = 0x53;
1400038a0      acquire__coreZlocks_u14(&gFunsLock__stdZexitprocs_u14);
1400038a0      
1400038b1      if (!(uint32_t)*(uint8_t*)rax_1)
1400038b1      {
1400038c3          int64_t var_48;
1400038c3          nimZeroMem(&var_48, 0x10);
1400038c8          int64_t var_88_2 = 0x3f;
1400038d7          char const* const var_80_1 =
1400038d7              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
1400038db          int64_t var_88_3 = 0x35;
1400038db          
1400038f3          if (!_.bss)
1400038f3          {
1400038f5              int64_t var_88_4 = 0x36;
140003907              atexit(callClosures__stdZexitprocs_u19);
1400038f3          }
1400038f3          
14000390f          int64_t var_88_5 = 0x40;
140003923          char var_68;
140003923          nimZeroMem(&var_68, 0x18);
140003928          var_68 = 0;
14000392c          int64_t var_88_6 = 0x26;
14000393b          char const* const var_80_2 =
14000393b              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\threadimpl.nim";
14000394d          int64_t var_b8 = rax;
140003954          int64_t var_b0_1 = rdx;
140003971          eqdup___system_u4017(&var_b8, 1, &var_48);
14000397e          int64_t rax_8 = var_48;
140003986          int64_t var_88_7 = 0x40;
140003995          char const* const var_80_3 =
140003995              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
14000399d          int64_t var_d8 = var_68;
1400039a8          int64_t var_d0_1 = rax_8;
1400039b3          int64_t var_40;
1400039b3          int64_t var_c8_1 = var_40;
1400039ce          add__stdZexitprocs_u190(&_.bss, &var_d8);
1400039d7          char rax_13 = *(uint8_t*)rax_1;
1400039e1          *(uint8_t*)rax_1 = 0;
1400039e4          int64_t var_88_8 = 0x58;
1400039f3          char const* const var_80_4 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\core\locks.nim";
140003a01          release__coreZlocks_u16(&gFunsLock__stdZexitprocs_u14);
140003a01          
140003a12          if (!(uint32_t)*(uint8_t*)rax_1)
140003a1c              *(uint8_t*)rax_1 = rax_13;
1400038b1      }
1400038b1      
140003a3f      return popFrame();
14000382c  }


140003a40    int64_t* atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatsstdatsexitprocsdotnim_Init000()

140003a40  {
140003a4f      char const* const var_40 = "exitprocs";
140003a5a      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
140003a5e      int64_t var_38 = 0;
140003a66      int16_t var_28 = 0;
140003a73      void* var_48;
140003a73      nimFrame(&var_48);
140003a7d      char* var_10 = nimErrorFlag();
140003a81      int64_t var_38_1 = 0x1b;
140003a90      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\exitprocs.nim";
140003a9e      initLock__coreZlocks_u7(&gFunsLock__stdZexitprocs_u14);
140003ab0      nimTestErrorFlag();
140003ac0      return popFrame();
140003a40  }

140003ac1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

140003ad0    int64_t nimFrame(void** arg1)

140003ad0  {
140003af1      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
140003b1f          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
140003b1f              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
140003af1      else
140003af7          *(uint16_t*)((char*)arg1 + 0x22) = 0;
140003af7      
140003b2d      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140003b39      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
140003b40      *(uint64_t*)rax_8 = arg1;
140003b47      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
140003b47      
140003b4f      if (result != 0x7d0)
140003b5f          return result;
140003b5f      
140003b51      return callDepthLimitReached__system_u4678();
140003ad0  }


140003b60    int64_t* popFrame()

140003b60  {
140003b72      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140003b7d      *(uint64_t*)result = **(uint64_t**)result;
140003b86      return result;
140003b60  }


140003b87    int64_t* restoreConsoleOutputCP__stdZsyncio_u657()

140003b87  {
140003b96      char const* const var_40 = "restoreConsoleOutputCP";
140003ba1      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\syncio.nim";
140003ba5      int64_t var_38 = 0;
140003bad      int16_t var_28 = 0;
140003bba      void* var_48;
140003bba      nimFrame(&var_48);
140003bbf      int32_t var_c = 0;
140003bd7      int32_t var_c_1 = Dl_520094344_((uint64_t)_.bss);
140003be5      return popFrame();
140003b87  }


140003be6    int64_t nimSetMem__systemZmemory_u7(int64_t arg1, int32_t arg2, uint64_t arg3)

140003be6  {
140003bf9      int64_t var_10 = 0;
140003c12      int64_t result = memset(arg1, arg2, arg3);
140003c17      int64_t result_1 = result;
140003c21      return result;
140003be6  }


140003c22    int64_t nimErrorFlag()

140003c22  {
140003c46      return __emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
140003c22  }


140003c47    uint64_t nimZeroMem(int64_t arg1, uint64_t arg2)

140003c47  {
140003c57      char* rax = nimErrorFlag();
140003c73      nimSetMem__systemZmemory_u7(arg1, 0, arg2);
140003c8b      return (uint64_t)*(uint8_t*)rax;
140003c47  }


140003c8c    int64_t* restoreConsoleCP__stdZsyncio_u658()

140003c8c  {
140003c9b      char const* const var_40 = "restoreConsoleCP";
140003ca6      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\syncio.nim";
140003caa      int64_t var_38 = 0;
140003cb2      int16_t var_28 = 0;
140003cbf      void* var_48;
140003cbf      nimFrame(&var_48);
140003cc4      int32_t var_c = 0;
140003cdc      int32_t var_c_1 = Dl_520094346_((uint64_t)consoleCP__stdZsyncio_u656);
140003cea      return popFrame();
140003c8c  }


140003ceb    int64_t* atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatsstdatssynciodotnim_Init000()

140003ceb  {
140003cfd      char const* const var_70 = "syncio";
140003d08      char const* const var_60 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\syncio.nim";
140003d0c      int64_t var_68 = 0;
140003d14      int16_t var_58 = 0;
140003d21      void* var_78;
140003d21      nimFrame(&var_78);
140003d26      char* rax = nimErrorFlag();
140003d2f      int64_t var_68_1 = 0x33d;
140003d3e      char const* const var_60_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\syncio.nim";
140003d42      int32_t var_14 = 0;
140003d77      _setmode(_fileno(__acrt_iob_func(0)), 0x8000);
140003d79      int64_t var_68_2 = 0x33e;
140003d81      int32_t var_18 = 0;
140003db6      _setmode(_fileno(__acrt_iob_func(1)), 0x8000);
140003db8      int64_t var_68_3 = 0x33f;
140003dc0      int32_t var_1c = 0;
140003df5      _setmode(_fileno(__acrt_iob_func(2)), 0x8000);
140003df7      int64_t var_68_4 = 0x351;
140003e08      _.bss = Dl_520094348_();
140003e0e      int64_t var_68_5 = 0x352;
140003e1f      consoleCP__stdZsyncio_u656 = Dl_520094349_();
140003e25      int64_t var_68_6 = 0x357;
140003e38      int64_t* (* var_88)();
140003e38      
140003e38      if (_.bss != 0xfde9)
140003e38      {
140003e3a          int64_t var_68_7 = 0x358;
140003e42          int32_t var_20_1 = 0;
140003e57          int32_t var_20_2 = Dl_520094344_(0xfde9);
140003e5a          int64_t var_68_8 = 0x359;
140003e6e          int64_t* (* var_38)();
140003e6e          nimZeroMem(&var_38, 0x10);
140003e7a          var_38 = restoreConsoleOutputCP__stdZsyncio_u657;
140003e8e          var_88 = var_38;
140003e92          int64_t var_80_1 = 0;
140003e9d          addExitProc__stdZexitprocs_u184(&var_88);
140003e38      }
140003e38      
140003eae      if (_.bss == 0xfde9 || !(uint32_t)*(uint8_t*)rax)
140003eae      {
140003eb7          int64_t var_68_9 = 0x35b;
140003eb7          
140003eca          if (consoleCP__stdZsyncio_u656 != 0xfde9)
140003eca          {
140003ecc              int64_t var_68_10 = 0x35c;
140003ed4              int32_t var_24_1 = 0;
140003ee9              int32_t var_24_2 = Dl_520094346_(0xfde9);
140003eec              int64_t var_68_11 = 0x35d;
140003f00              int64_t* (* var_48)();
140003f00              nimZeroMem(&var_48, 0x10);
140003f0c              var_48 = restoreConsoleCP__stdZsyncio_u658;
140003f20              var_88 = var_48;
140003f24              int64_t var_80_2 = 0;
140003f2f              addExitProc__stdZexitprocs_u184(&var_88);
140003eca          }
140003eae      }
140003eae      
140003f46      nimTestErrorFlag();
140003f59      return popFrame();
140003ceb  }


140003f5a    int64_t atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatsstdatssynciodotnim_DatInit000()

140003f5a  {
140003f70      int64_t var_18 = 8;
140003f74      void* const var_10 = &TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_4;
140003f84      TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_2 = nimLoadLibrary(&var_18);
140003f84      
140003f95      if (!TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_2)
140003f95      {
140003fa5          var_18 = 8;
140003fa9          void* const var_10_1 = &TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_6;
140003fb4          nimLoadLibraryError(&var_18);
140003fb4          /* no return */
140003f95      }
140003f95      
140003fcf      Dl_520094348_ = nimGetProcAddr(TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_2, "GetConsoleOutputCP");
140003fec      Dl_520094349_ = nimGetProcAddr(TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_2, "GetConsoleCP");
140004009      Dl_520094344_ = nimGetProcAddr(TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_2, "SetConsoleOutputCP");
140004021      int64_t result = nimGetProcAddr(TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_2, "SetConsoleCP");
140004026      Dl_520094346_ = result;
140004033      return result;
140003f5a  }

140004034                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

140004040    uint64_t fprintf(FILE* arg1, char* arg2, int64_t arg3)

140004040  {
140004050      int64_t arg_18 = arg3;
140004054      int64_t r9;
140004054      int64_t arg_20 = r9;
140004082      return (uint64_t)__mingw_vfprintf(arg1, arg2, &arg_18);
140004040  }


140004083    uint64_t printf(char* arg1, int64_t arg2)

140004083  {
140004092      int64_t arg_10 = arg2;
140004096      int64_t r8;
140004096      int64_t arg_18 = r8;
14000409a      int64_t r9;
14000409a      int64_t arg_20 = r9;
1400040d6      return (uint64_t)__mingw_vfprintf(__acrt_iob_func(1), arg1, &arg_10);
140004083  }


1400040d7    void* const nimToCStringConv(int64_t* arg1)

1400040d7  {
1400040fb      if (*(uint64_t*)arg1)
140004113          return arg1[1] + 8;
140004113      
140004104      return &data_140021110;
1400040d7  }


140004122    HMODULE nimLoadLibrary(int64_t* arg1)

140004122  {
140004133      int64_t rdx = arg1[1];
14000413f      int64_t var_20 = 0;
14000414f      int64_t var_48 = *(uint64_t*)arg1;
140004153      int64_t var_40 = rdx;
140004185      return LoadLibraryA(nimToCStringConv(&var_48));
140004122  }


140004186    int32_t rawWrite(FILE* arg1, char* arg2)

140004186  {
140004196      int64_t var_10 = 0;
1400041ae      int64_t var_18 = 0;
1400041d5      uint64_t var_18_1 = fwrite(arg2, 1, strlen(arg2), arg1);
1400041d9      int32_t var_1c = 0;
1400041e7      int32_t result = fflush(arg1);
1400041ec      int32_t result_1 = result;
1400041f5      return result;
140004186  }


1400041f6    void nimLoadLibraryError(int64_t* arg1) __noreturn

1400041f6  {
140004204      int64_t rax = *(uint64_t*)arg1;
140004207      int64_t rdx = arg1[1];
14000422e      rawWrite(__acrt_iob_func(2), "could not load: ");
14000423b      int64_t var_48 = rax;
14000423f      int64_t var_40 = rdx;
14000424a      void* rax_3 = nimToCStringConv(&var_48);
140004266      rawWrite(__acrt_iob_func(2), rax_3);
140004266      
14000427e      if (GetLastError() == ERROR_BAD_EXE_FORMAT)
14000429b          rawWrite(__acrt_iob_func(2), 
14000429b              "\n(bad format; library may be wrong architecture)");
14000429b      
1400042be      rawWrite(__acrt_iob_func(2), "\n");
1400042c8      exit(1);
1400042c8      /* no return */
1400041f6  }

1400042cd                                         90                                                                     .

1400042ce    int64_t nimSetMem__systemZmemory_u7(int64_t arg1, int32_t arg2, uint64_t arg3)

1400042ce  {
1400042e1      int64_t var_10 = 0;
1400042fa      int64_t result = memset(arg1, arg2, arg3);
1400042ff      int64_t result_1 = result;
140004309      return result;
1400042ce  }


14000430a    int64_t nimErrorFlag()

14000430a  {
14000432e      return __emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
14000430a  }


14000432f    uint64_t nimZeroMem(int64_t arg1, uint64_t arg2)

14000432f  {
14000433f      char* rax = nimErrorFlag();
14000435b      nimSetMem__systemZmemory_u7(arg1, 0, arg2);
140004373      return (uint64_t)*(uint8_t*)rax;
14000432f  }


140004374    int64_t nimCopyMem(int64_t arg1, int64_t arg2, uint64_t arg3)

140004374  {
140004388      int64_t var_10 = 0;
1400043a2      int64_t result = memcpy(arg1, arg2, arg3);
1400043a7      int64_t result_1 = result;
1400043b1      return result;
140004374  }


1400043b2    int64_t copyMem__system_u1731(int64_t arg1, int64_t arg2, uint64_t arg3)

1400043b2  {
1400043e3      return nimCopyMem(arg1, arg2, arg3);
1400043b2  }


1400043e4    int64_t* popFrame()

1400043e4  {
1400043f6      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140004401      *(uint64_t*)result = **(uint64_t**)result;
14000440a      return result;
1400043e4  }


14000440b    int64_t* unregisterCycle__system_u3092(void* arg1)

14000440b  {
140004427      char const* const var_70 = "unregisterCycle";
140004432      char const* const var_60 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140004436      int64_t var_68 = 0;
14000443e      int16_t var_58 = 0;
14000444b      void* var_78;
14000444b      nimFrame(&var_78);
140004450      int64_t var_68_1 = 0x92;
14000445f      char const* const var_60_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140004467      int64_t rax_1 = *(uint64_t*)((char*)arg1 + 8);
14000446b      char rdx = 0;
14000446b      
140004474      if (rax_1 - 1)
140004476          rdx = 1;
140004476      
14000448d      if (!(rdx & 1))
14000448d      {
1400044a1          int64_t var_68_2 = 0x97;
1400044b8          int64_t rax_7 =
1400044b8              *(uint64_t*)__emutls_get_address(&__emutls_v.roots__system_u3091);
1400044bb          char rdx_1 = 0;
1400044bb          
1400044c4          if (rax_7 - 1)
1400044c6              rdx_1 = 1;
1400044c6          
1400044dd          if (!(rdx_1 & 1))
1400044dd          {
1400044f3              void* rax_11 = __emutls_get_address(&__emutls_v.roots__system_u3091);
140004504              int64_t* rdx_4 = ((rax_7 - 1) << 4) + *(uint64_t*)((char*)rax_11 + 0x10);
140004513              int64_t* rcx_5 = *(uint64_t*)((char*)rax_11 + 0x10) + ((rax_1 - 1) << 4);
140004519              int64_t rdx_5 = rdx_4[1];
14000451d              *(uint64_t*)rcx_5 = *(uint64_t*)rdx_4;
140004520              rcx_5[1] = rdx_5;
140004524              int64_t var_68_3 = 0x98;
14000452c              char rdx_6 = 0;
14000452c              
140004539              if (rax_1 - 1 + 1)
14000453b                  rdx_6 = 1;
14000453b              
140004552              if (!(rdx_6 & 1))
140004552              {
140004568                  int64_t* rax_19 = __emutls_get_address(&__emutls_v.roots__system_u3091);
140004583                  *(uint64_t*)(*(uint64_t*)(((rax_1 - 1) << 4) + rax_19[2]) + 8) = rax_1;
140004587                  int64_t var_68_4 = 0x99;
14000458f                  int64_t rax_20 = *(uint64_t*)rax_19;
140004592                  char rdx_11 = 0;
140004592                  
14000459b                  if (rax_20 - 1)
14000459d                      rdx_11 = 1;
14000459d                  
1400045b4                  if (!(rdx_11 & 1))
1400045b4                  {
1400045d0                      *(uint64_t*)__emutls_get_address(&__emutls_v.roots__system_u3091) =
1400045d0                          rax_20 - 1;
1400045d3                      int64_t var_68_5 = 0x9a;
1400045df                      *(uint64_t*)((char*)arg1 + 8) = 0;
1400045b4                  }
1400045b4                  else
1400045b6                      raiseOverflow();
140004552              }
140004552              else
140004554                  raiseOverflow();
1400044dd          }
1400044dd          else
1400044df              raiseOverflow();
14000448d      }
14000448d      else
14000448f          raiseOverflow();
14000448f      
1400045f6      return popFrame();
14000440b  }


1400045f7    int64_t roundup__system_u5881(int64_t arg1, int64_t arg2)

1400045f7  {
14000460e      char const* const var_40 = "roundup";
140004619      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\osalloc.nim";
14000461d      int64_t var_38 = 0;
140004625      int16_t var_28 = 0;
140004632      void* var_48;
140004632      nimFrame(&var_48);
140004637      int64_t var_38_1 = 0xb;
140004646      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\osalloc.nim";
140004667      popFrame();
140004675      return -(arg2) & (arg2 - 1 + arg1);
1400045f7  }


140004676    int64_t msbit__system_u6016(int32_t arg1)

140004676  {
14000468b      char const* const var_70 = "msbit";
140004696      char const* const var_60 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000469a      int64_t var_68 = 0;
1400046a2      int16_t var_58 = 0;
1400046af      void* var_78;
1400046af      nimFrame(&var_78);
1400046b4      int64_t var_28 = 0;
1400046bc      int64_t var_10 = 0;
1400046c4      int64_t var_18 = 0;
1400046cc      int64_t var_68_1 = 0xd8;
1400046db      char const* const var_60_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400046e6      int64_t var_20;
1400046e6      
1400046e6      if (arg1 > 0xffff)
1400046e6      {
140004737          int64_t var_40_1 = 0;
14000473f          int64_t var_48_1 = 0;
140004747          int64_t var_68_3 = 0xdb;
140004756          int64_t var_18_1;
140004756          
140004756          var_18_1 = arg1 > 0xffffff ? 0x18 : 0x10;
140004756          
14000477f          var_20 = var_18_1;
1400046e6      }
1400046e6      else
1400046e6      {
1400046e8          int64_t var_30_1 = 0;
1400046f0          int64_t var_38_1 = 0;
1400046f8          int64_t var_68_2 = 0xd9;
140004707          int64_t var_10_1;
140004707          
140004707          var_10_1 = arg1 > 0xff ? 8 : 0;
140004707          
140004730          var_20 = var_10_1;
1400046e6      }
1400046e6      
140004783      int64_t var_68_4 = 0xdc;
1400047b0      int64_t result = (int64_t)*(uint8_t*)(
1400047b0          (int64_t)(uint32_t)(uint8_t)(arg1 >> (uint8_t)var_20) +
1400047b0          &fsLookupTable__system_u6015) + var_20;
1400047b7      popFrame();
1400047c8      return result;
140004676  }


1400047c9    int64_t* mappingSearch__system_u6041(int64_t* arg1, int64_t* arg2, int64_t* arg3)

1400047c9  {
1400047e4      char const* const var_50 = "mappingSearch";
1400047ef      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400047f3      int64_t var_48 = 0;
1400047fb      int16_t var_38 = 0;
140004808      void* var_58;
140004808      nimFrame(&var_58);
14000480d      int64_t var_48_1 = 0xeb;
140004815      int64_t var_10 = 0;
14000482f      int64_t var_18 = 0;
140004860      int64_t rax_8 = roundup__system_u5881(
140004860          1 << (msbit__system_u6016((int32_t)*(uint64_t*)arg1) - 5), 0x1000) - 1;
140004868      int64_t var_48_2 = 0xec;
140004882      *(uint64_t*)arg1 += rax_8;
140004885      int64_t var_48_3 = 0xed;
1400048a2      *(uint64_t*)arg1 &= ~rax_8;
1400048a5      int64_t var_48_4 = 0xee;
1400048b1      int64_t rax_17 = *(uint64_t*)arg1;
1400048b1      
1400048bc      if (rax_17 > 0x3f000000)
1400048bc          rax_17 = 0x3f000000;
1400048bc      
1400048c4      *(uint64_t*)arg1 = rax_17;
1400048c7      int64_t var_48_5 = 0xef;
1400048e1      *(uint64_t*)arg2 = msbit__system_u6016((int32_t)*(uint64_t*)arg1);
1400048e4      int64_t var_48_6 = 0xf0;
14000490d      *(uint64_t*)arg3 = (*(uint64_t*)arg1 >> ((char)*(uint64_t*)arg2 - 5)) - 0x20;
140004910      int64_t var_48_7 = 0xf1;
140004927      *(uint64_t*)arg2 -= 6;
140004935      return popFrame();
1400047c9  }


140004936    int64_t lsbit__system_u6024(int32_t arg1)

140004936  {
140004948      char const* const var_40 = "lsbit";
140004953      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140004957      int64_t var_38 = 0;
14000495f      int16_t var_28 = 0;
14000496c      void* var_48;
14000496c      nimFrame(&var_48);
140004971      int64_t var_38_1 = 0xdf;
140004983      int64_t result = msbit__system_u6016(-(arg1) & arg1);
14000498c      popFrame();
14000499a      return result;
140004936  }


14000499b    int64_t findSuitableBlock__system_u6074(void* arg1, int64_t* arg2, int64_t* arg3)

14000499b  {
1400049b6      char const* const var_40 = "findSuitableBlock";
1400049c1      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400049c5      int64_t var_38 = 0;
1400049cd      int16_t var_28 = 0;
1400049da      void* var_48;
1400049da      nimFrame(&var_48);
1400049df      int64_t var_38_1 = 0x100;
140004a0e      int32_t rax_5 = (int32_t)(0xffffffff << (char)*(uint64_t*)arg3)
140004a0e          & *(uint32_t*)((char*)arg1 + ((*(uint64_t*)arg2 + 0x400) << 2) + 4);
140004a13      int64_t var_38_2 = 0x101;
140004a1b      int64_t result = 0;
140004a23      int64_t var_38_3 = 0x102;
140004a23      
140004a2f      if (!rax_5)
140004a2f      {
140004a81          int64_t var_38_6 = 0x106;
140004ab8          *(uint64_t*)arg2 = lsbit__system_u6024(
140004ab8              (int32_t)(0xffffffff << ((char)*(uint64_t*)arg2 + 1))
140004ab8              & *(uint32_t*)((char*)arg1 + 0x1000));
140004abb          int64_t var_38_7 = 0x107;
140004abb          
140004acd          if (*(uint64_t*)arg2 > 0)
140004acd          {
140004acf              int64_t var_38_8 = 0x108;
140004af8              *(uint64_t*)arg3 = lsbit__system_u6024(
140004af8                  *(uint32_t*)((char*)arg1 + ((*(uint64_t*)arg2 + 0x400) << 2) + 4));
140004afb              int64_t var_38_9 = 0x109;
140004b28              result = *(uint64_t*)((char*)arg1
140004b28                  + ((*(uint64_t*)arg3 + (*(uint64_t*)arg2 << 5) + 0x20c) << 3) + 8);
140004acd          }
140004a2f      }
140004a2f      else
140004a2f      {
140004a31          int64_t var_38_4 = 0x103;
140004a47          *(uint64_t*)arg3 = lsbit__system_u6024(rax_5);
140004a4a          int64_t var_38_5 = 0x104;
140004a77          result = *(uint64_t*)((char*)arg1
140004a77              + ((*(uint64_t*)arg3 + (*(uint64_t*)arg2 << 5) + 0x20c) << 3) + 8);
140004a2f      }
140004a2f      
140004b2f      popFrame();
140004b3d      return result;
14000499b  }


140004b3e    void raiseOutOfMem__system_u5876() __noreturn

140004b3e  {
140004b4d      char const* const var_30 = "raiseOutOfMem";
140004b58      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\mmdisp.nim";
140004b5c      int64_t var_28 = 0;
140004b64      int16_t var_18 = 0;
140004b71      void* var_38;
140004b71      nimFrame(&var_38);
140004b76      int64_t var_28_1 = 0x2f;
140004b85      char const* const var_20_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\mmdisp.nim";
140004b85      
140004b93      if (outOfMemHook__system_u3635)
140004b9c          outOfMemHook__system_u3635();
140004b9c      
140004ba1      int64_t var_28_2 = 0x30;
140004bc4      rawWrite(__acrt_iob_func(2), "out of memory\n");
140004bc9      int64_t var_28_3 = 0x31;
140004bd6      exit(1);
140004bd6      /* no return */
140004b3e  }

140004bdb                                                                                   90                                         .

140004bdc    int64_t osAllocPages__system_u5901(uint64_t arg1)

140004bdc  {
140004bef      char const* const var_40 = "osAllocPages";
140004bfa      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\osalloc.nim";
140004bfe      int64_t var_38 = 0;
140004c06      int16_t var_28 = 0;
140004c13      void* var_48;
140004c13      nimFrame(&var_48);
140004c18      int64_t var_38_1 = 0xae;
140004c27      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\osalloc.nim";
140004c4a      int64_t result =
140004c4a          VirtualAlloc(nullptr, arg1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
140004c50      int64_t var_38_2 = 0xb0;
140004c50      
140004c5d      if (result)
140004c5d      {
140004c67          popFrame();
140004c75          return result;
140004c5d      }
140004c5d      
140004c5f      raiseOutOfMem__system_u5876();
140004c5f      /* no return */
140004bdc  }

140004c64              eb 01                                                                                    ..

140004c76    int64_t allocPages__system_u6210(int64_t arg1, uint64_t arg2)

140004c76  {
140004c7e      int64_t arg_8 = arg1;
140004c8d      char const* const var_40 = "allocPages";
140004c98      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140004c9c      int64_t var_38 = 0;
140004ca4      int16_t var_28 = 0;
140004cb1      void* var_48;
140004cb1      nimFrame(&var_48);
140004cb6      int64_t var_38_1 = 0x13f;
140004cc5      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140004cc9      int64_t var_38_2 = 0x142;
140004cd8      int64_t result = osAllocPages__system_u5901(arg2);
140004ce1      popFrame();
140004cef      return result;
140004c76  }


140004cf0    int64_t osTryAllocPages__system_u5904(uint64_t arg1)

140004cf0  {
140004d03      char const* const var_40 = "osTryAllocPages";
140004d0e      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\osalloc.nim";
140004d12      int64_t var_38 = 0;
140004d1a      int16_t var_28 = 0;
140004d27      void* var_48;
140004d27      nimFrame(&var_48);
140004d2c      int64_t var_38_1 = 0xb3;
140004d3b      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\osalloc.nim";
140004d5e      int64_t result =
140004d5e          VirtualAlloc(nullptr, arg1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
140004d64      popFrame();
140004d72      return result;
140004cf0  }


140004d73    int64_t tryAllocPages__system_u6214(int64_t arg1, uint64_t arg2)

140004d73  {
140004d7b      int64_t arg_8 = arg1;
140004d8a      char const* const var_40 = "tryAllocPages";
140004d95      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140004d99      int64_t var_38 = 0;
140004da1      int16_t var_28 = 0;
140004dae      void* var_48;
140004dae      nimFrame(&var_48);
140004db3      int64_t var_38_1 = 0x145;
140004dc2      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140004dc6      int64_t var_38_2 = 0x148;
140004dd5      int64_t result = osTryAllocPages__system_u5904(arg2);
140004dde      popFrame();
140004dec      return result;
140004d73  }


140004ded    int64_t* incCurrMem__system_u6190(void* arg1, int64_t arg2)

140004ded  {
140004e04      char const* const var_30 = "incCurrMem";
140004e0f      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140004e13      int64_t var_28 = 0;
140004e1b      int16_t var_18 = 0;
140004e28      void* var_38;
140004e28      nimFrame(&var_38);
140004e2d      int64_t var_28_1 = 0x130;
140004e4b      *(uint64_t*)((char*)arg1 + 0x2870) += arg2;
140004e5d      return popFrame();
140004ded  }


140004e5e    uint64_t zeroMem__system_u1728(int64_t arg1, uint64_t arg2)

140004e5e  {
140004e84      return nimZeroMem(arg1, arg2);
140004e5e  }


140004e85    int64_t llAlloc__system_u6218(void* arg1, uint64_t arg2)

140004e85  {
140004e9c      char const* const var_50 = "llAlloc";
140004ea7      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140004eab      int64_t var_48 = 0;
140004eb3      int16_t var_38 = 0;
140004ec0      void* var_58;
140004ec0      nimFrame(&var_58);
140004ec5      int64_t var_48_1 = 0x14d;
140004ecd      char var_9 = 0;
140004edf      int64_t rax_1;
140004edf      (uint8_t)rax_1 = !*(uint64_t*)((char*)arg1 + 0x2868);
140004ee2      char var_9_1 = (uint8_t)rax_1;
140004ee2      
140004ee9      if (!var_9_1)
140004ee9      {
140004efd          int64_t rax_4;
140004efd          (uint8_t)rax_4 = arg2 > **(uint64_t**)((char*)arg1 + 0x2868);
140004f00          var_9_1 = (uint8_t)rax_4;
140004ee9      }
140004ee9      
140004f0f      if (var_9_1 == 1)
140004f0f      {
140004f15          int64_t var_48_2 = 0x152;
140004f21          int64_t rax_8 = *(uint64_t*)((char*)arg1 + 0x2868);
140004f2c          int64_t var_48_3 = 0x153;
140004f34          int64_t var_20_1 = 0;
140004f59          *(uint64_t*)((char*)arg1 + 0x2868) = allocPages__system_u6210(arg1, 0x1000);
140004f60          int64_t var_48_4 = 0x156;
140004f74          incCurrMem__system_u6190(arg1, 0x1000);
140004f79          int64_t var_48_5 = 0x157;
140004f8c          **(uint64_t**)((char*)arg1 + 0x2868) = 0xfe8;
140004f93          int64_t var_48_6 = 0x158;
140004fa6          *(uint64_t*)(*(uint64_t*)((char*)arg1 + 0x2868) + 8) = 0x18;
140004fae          int64_t var_48_7 = 0x159;
140004fc5          *(uint64_t*)(*(uint64_t*)((char*)arg1 + 0x2868) + 0x10) = rax_8;
140004f0f      }
140004f0f      
140004fcc      int64_t var_48_8 = 0x15a;
140004ff1      int64_t result = *(uint64_t*)(*(uint64_t*)((char*)arg1 + 0x2868) + 8)
140004ff1          + *(uint64_t*)((char*)arg1 + 0x2868);
140004ff8      int64_t var_48_9 = 0x15b;
14000501d      **(uint64_t**)((char*)arg1 + 0x2868) -= arg2;
140005020      int64_t var_48_10 = 0x15c;
140005049      *(uint64_t*)(*(uint64_t*)((char*)arg1 + 0x2868) + 8) += arg2;
14000504d      int64_t var_48_11 = 0x15d;
140005060      zeroMem__system_u1728(result, arg2);
140005065      popFrame();
140005073      return result;
140004e85  }


140005074    int64_t* addHeapLink__system_u6256(void* arg1, int64_t arg2, int64_t arg3)

140005074  {
140005092      char const* const var_80 = "addHeapLink";
14000509d      char const* const var_70 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400050a1      int64_t var_78 = 0;
1400050a9      int16_t var_68 = 0;
1400050b6      void* var_88;
1400050b6      nimFrame(&var_88);
1400050bb      int64_t var_78_1 = 0x17f;
1400050cd      int64_t* result_1 = (char*)arg1 + 0x30b0;
1400050d1      int64_t var_78_2 = 0x180;
1400050d1      
1400050d9      while (true)
1400050d9      {
1400050d9          char var_19_1 = 0;
1400050e2          int64_t* rax_1;
1400050e2          (uint8_t)rax_1 = result_1;
1400050e5          char var_19_2 = (uint8_t)rax_1;
1400050e5          
1400050f1          if (var_19_2 == 1)
1400050f1          {
1400050fe              int64_t rax_5;
1400050fe              (uint8_t)rax_5 = *(uint64_t*)result_1 > 0x1d;
140005101              var_19_2 = (uint8_t)rax_5;
1400050f1          }
1400050f1          
140005110          if (var_19_2 != 1)
140005110              break;
140005110          
14000511d          result_1 = result_1[0x3d];
1400050d9      }
1400050d9      
140005124      int64_t var_78_3 = 0x181;
140005131      int64_t* result;
140005131      
140005131      if (result_1)
140005131      {
1400051f2          int64_t var_78_10 = 0x189;
1400051fe          int64_t rax_21 = *(uint64_t*)result_1;
140005205          int64_t var_78_11 = 0x18a;
140005234          result_1[rax_21 * 2 + 1] = arg2;
14000524e          result_1[rax_21 * 2 + 2] = arg3;
140005251          int64_t var_78_12 = 0x18b;
140005268          *(uint64_t*)result_1 += 1;
14000526b          int64_t var_78_13 = 0x18c;
140005277          result = result_1;
140005131      }
140005131      else
140005131      {
140005137          int64_t var_78_4 = 0x182;
14000513f          int64_t var_28_1 = 0;
140005153          int64_t* result_2 = llAlloc__system_u6218(arg1, 0x1f0);
140005164          int64_t var_78_5 = 0x183;
14000517b          result_2[0x3d] = *(uint64_t*)((char*)arg1 + 0x3298);
140005182          int64_t var_78_6 = 0x184;
140005192          *(uint64_t*)((char*)arg1 + 0x3298) = result_2;
140005199          int64_t var_78_7 = 0x185;
1400051b9          result_2[1] = arg2;
1400051c5          result_2[2] = arg3;
1400051c9          int64_t var_78_8 = 0x186;
1400051d5          *(uint64_t*)result_2 = 1;
1400051dc          int64_t var_78_9 = 0x187;
1400051e8          result = result_2;
140005131      }
140005131      
14000527b      popFrame();
14000528c      return result;
140005074  }


14000528d    int64_t pluspercent___system_u793(int64_t arg1, int64_t arg2)

14000528d  {
1400052a4      void* const var_40 = &data_1400212f1;
1400052af      char const* const var_30 =
1400052af          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
1400052b3      int64_t var_38 = 0;
1400052bb      int16_t var_28 = 0;
1400052c8      void* var_48;
1400052c8      nimFrame(&var_48);
1400052cd      int64_t var_38_1 = 0x161;
1400052dc      char const* const var_30_1 =
1400052dc          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
1400052e0      int64_t var_38_2 = 0x165;
1400052f7      popFrame();
140005305      return arg2 + arg1;
14000528d  }


140005306    void* const intSetGet__system_u6351(int64_t arg1, int64_t arg2)

140005306  {
14000531d      char const* const var_40 = "intSetGet";
140005328      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000532c      int64_t var_38 = 0;
140005334      int16_t var_28 = 0;
140005341      void* var_48;
140005341      nimFrame(&var_48);
140005346      int64_t var_38_1 = 0x19b;
140005355      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140005368      void* result_1 = *(uint64_t*)(arg1 + ((uint64_t)(uint8_t)arg2 << 3));
14000536c      int64_t var_38_2 = 0x19c;
140005379      void* const result;
140005379      
140005379      while (true)
140005379      {
140005379          if (!result_1)
140005379          {
1400053c2              int64_t var_38_7 = 0x19f;
1400053ca              result = nullptr;
1400053ca              break;
140005379          }
140005379          
14000537b          int64_t var_38_3 = 0x19d;
14000537b          
14000538f          if (arg2 == *(uint64_t*)((char*)result_1 + 8))
14000538f          {
140005391              int64_t var_38_4 = 0x19a;
140005399              int64_t var_38_5 = 0x19d;
1400053a5              result = result_1;
1400053a9              break;
14000538f          }
14000538f          
1400053ac          int64_t var_38_6 = 0x19e;
1400053bb          result_1 = *(uint64_t*)result_1;
140005379      }
140005379      
1400053d2      popFrame();
1400053e0      return result;
140005306  }


1400053e1    uint64_t contains__system_u6400(int64_t arg1, int64_t arg2)

1400053e1  {
1400053f8      char const* const var_50 = "contains";
140005403      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140005407      int64_t var_48 = 0;
14000540f      int16_t var_38 = 0;
14000541c      void* var_58;
14000541c      nimFrame(&var_58);
140005421      int64_t var_48_1 = 0x1aa;
14000543b      void* rax_3 = intSetGet__system_u6351(arg1, arg2 >> 9);
140005444      int64_t var_48_2 = 0x1ab;
140005451      char var_9;
140005451      
140005451      if (!rax_3)
140005451      {
1400054a5          int64_t var_48_5 = 0x1af;
1400054ad          var_9 = 0;
140005451      }
140005451      else
140005451      {
140005453          int64_t var_48_3 = 0x1ac;
14000545f          uint64_t rax_5 = (uint64_t)(uint32_t)arg2 & 0x1ff;
140005468          int64_t var_48_4 = 0x1ad;
14000549c          uint64_t rax_12;
14000549c          (uint8_t)rax_12 = (uint64_t)(uint32_t)(
14000549c              *(uint64_t*)((char*)rax_3 + (((rax_5 >> 6) + 2) << 3))
14000549c              >> ((uint8_t)rax_5 & 0x3f)) & 1;
14000549f          var_9 = (uint8_t)rax_12;
140005451      }
140005451      
1400054b1      popFrame();
1400054bf      return (uint64_t)var_9;
1400053e1  }


1400054c0    int64_t pageIndex__system_u6636(int64_t arg1)

1400054c0  {
1400054d3      char const* const var_40 = "pageIndex";
1400054de      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400054e2      int64_t var_38 = 0;
1400054ea      int16_t var_28 = 0;
1400054f7      void* var_48;
1400054f7      nimFrame(&var_48);
1400054fc      int64_t var_38_1 = 0x1f3;
140005510      popFrame();
14000551e      return arg1 >> 0xc;
1400054c0  }


14000551f    int64_t minuspercent___system_u813(int64_t arg1, int64_t arg2)

14000551f  {
140005536      void* const var_40 = &data_14002134f;
140005541      char const* const var_30 =
140005541          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
140005545      int64_t var_38 = 0;
14000554d      int16_t var_28 = 0;
14000555a      void* var_48;
14000555a      nimFrame(&var_48);
14000555f      int64_t var_38_1 = 0x16c;
14000556e      char const* const var_30_1 =
14000556e          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
140005572      int64_t var_38_2 = 0x170;
140005589      popFrame();
140005597      return arg1 - arg2;
14000551f  }


140005598    int64_t* requestOsChunks__system_u6653(void* arg1, uint64_t arg2)

140005598  {
1400055b2      char const* const var_d0 = "requestOsChunks";
1400055c0      char const* const var_c0 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400055c7      int64_t var_c8 = 0;
1400055d2      int16_t var_b8 = 0;
1400055e5      void* var_d8;
1400055e5      nimFrame(&var_d8);
1400055ea      int64_t var_30 = 0;
1400055f2      int64_t var_38 = 0;
1400055fa      int64_t var_c8_1 = 0x207;
14000560c      char const* const var_c0_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000560c      
140005620      if (!*(uint8_t*)((char*)arg1 + 0x30a2))
140005620      {
140005626          int64_t var_c8_2 = 0x208;
140005635          int64_t rax_3 = *(uint64_t*)((char*)arg1 + 0x2888);
140005640          int64_t var_c8_3 = 0x209;
140005640          
140005653          if (rax_3 > 0xffff)
140005653          {
140005675              int64_t var_c8_5 = 0x20c;
140005680              int64_t var_48_1 = 0;
140005698              int64_t rax_7 = roundup__system_u5881(rax_3 >> 2, 0x1000);
1400056ac              int64_t rdx = *(uint64_t*)((char*)arg1 + 0x30a8) * 2;
1400056b0              int64_t rax_10 = rax_7;
1400056b0              
1400056b7              if (rdx <= rax_10)
1400056b7                  rax_10 = rdx;
1400056b7              
1400056bf              *(uint64_t*)((char*)arg1 + 0x30a8) = rax_10;
1400056c6              int64_t var_c8_6 = 0x20d;
1400056d5              int64_t rax_12 = *(uint64_t*)((char*)arg1 + 0x30a8);
1400056d5              
1400056e4              if (rax_12 > 0x3f000000)
1400056e4                  rax_12 = 0x3f000000;
1400056e4              
1400056ec              *(uint64_t*)((char*)arg1 + 0x30a8) = rax_12;
140005653          }
140005653          else
140005653          {
140005655              int64_t var_c8_4 = 0x20a;
140005664              *(uint64_t*)((char*)arg1 + 0x30a8) = 0x4000;
140005653          }
140005620      }
140005620      
1400056f6      int64_t var_c8_7 = 0x20f;
140005705      uint64_t var_18 = arg2;
140005709      int64_t var_c8_8 = 0x210;
140005723      int64_t* result;
140005723      
140005723      if (var_18 <= *(uint64_t*)((char*)arg1 + 0x30a8))
140005723      {
14000575a          int64_t var_c8_10 = 0x213;
140005765          int64_t var_58_1 = 0;
14000578c          result = tryAllocPages__system_u6214(arg1, *(uint64_t*)((char*)arg1 + 0x30a8));
140005790          int64_t var_c8_11 = 0x214;
140005790          
1400057a0          if (result)
1400057a0          {
1400057ea              int64_t var_c8_14 = 0x218;
140005800              var_18 = *(uint64_t*)((char*)arg1 + 0x30a8);
1400057a0          }
1400057a0          else
1400057a0          {
1400057a2              int64_t var_c8_12 = 0x215;
1400057ad              int64_t var_60_1 = 0;
1400057cd              result = allocPages__system_u6210(arg1, var_18);
1400057d1              int64_t var_c8_13 = 0x216;
1400057e0              *(uint8_t*)((char*)arg1 + 0x30a2) = 1;
1400057a0          }
140005723      }
140005723      else
140005723      {
140005725          int64_t var_c8_9 = 0x211;
140005730          int64_t var_50_1 = 0;
140005750          result = allocPages__system_u6210(arg1, var_18);
140005723      }
140005723      
140005804      int64_t var_c8_15 = 0x21a;
14000581a      incCurrMem__system_u6190(arg1, var_18);
14000581f      int64_t var_c8_16 = 0x21b;
140005840      *(uint64_t*)((char*)arg1 + 0x2880) += var_18;
140005847      int64_t var_c8_17 = 0x21c;
140005869      int64_t* var_68 = addHeapLink__system_u6256(arg1, result, var_18);
14000586d      int64_t var_c8_18 = 0x226;
14000587c      result[3] = 0;
140005884      int64_t var_c8_19 = 0x227;
140005893      result[4] = 0;
14000589b      int64_t var_c8_20 = 0x228;
1400058ae      result[1] = var_18;
1400058b2      int64_t var_c8_21 = 0x22a;
1400058c8      uint64_t* rax_39 = pluspercent___system_u793(result, var_18);
1400058d1      int64_t var_c8_22 = 0x22c;
1400058e4      int64_t var_c8_23 = 0x22d;
1400058ef      int64_t var_80 = 0;
140005907      char var_81 = 0;
140005907      
14000592d      if (contains__system_u6400((char*)arg1 + 0x28a0, pageIndex__system_u6636(rax_39))
14000592d          == 1)
14000592d      {
14000592f          int64_t var_c8_24 = 0x22f;
14000594c          *(uint64_t*)rax_39 = ((uint64_t)(uint32_t)*(uint64_t*)rax_39 & 1) | var_18;
14000592d      }
14000592d      
140005952      int64_t var_c8_25 = 0x231;
14000596b      int64_t var_20;
14000596b      
14000596b      if (!*(uint64_t*)((char*)arg1 + 0x2890))
140005993          var_20 = 0x1000;
14000596b      else
140005980          var_20 = *(uint64_t*)((char*)arg1 + 0x2890);
140005980      
140005997      int64_t var_c8_26 = 0x232;
1400059ad      void* rax_58 = minuspercent___system_u813(result, var_20);
1400059b9      int64_t var_c8_27 = 0x234;
1400059d2      int64_t var_c8_28 = 0x235;
1400059dd      char var_21 = 0;
1400059e1      int64_t var_a0 = 0;
140005a1b      char var_21_1 =
140005a1b          contains__system_u6400((char*)arg1 + 0x28a0, pageIndex__system_u6636(rax_58));
140005a1b      
140005a27      if (var_21_1 == 1)
140005a27      {
140005a38          int64_t rax_68;
140005a38          (uint8_t)rax_68 = var_20 == *(uint64_t*)((char*)rax_58 + 8);
140005a3b          var_21_1 = (uint8_t)rax_68;
140005a27      }
140005a27      
140005a4a      if (var_21_1 != 1)
140005a4a      {
140005a6f          int64_t var_c8_30 = 0x239;
140005a8b          *(uint64_t*)result = (uint64_t)(uint32_t)*(uint64_t*)result & 1;
140005a4a      }
140005a4a      else
140005a4a      {
140005a4c          int64_t var_c8_29 = 0x237;
140005a69          *(uint64_t*)result = ((uint64_t)(uint32_t)*(uint64_t*)result & 1) | var_20;
140005a4a      }
140005a4a      
140005a8e      int64_t var_c8_31 = 0x23b;
140005aa1      *(uint64_t*)((char*)arg1 + 0x2890) = var_18;
140005aa8      popFrame();
140005ab9      return result;
140005598  }


140005aba    int64_t pageIndex__system_u6643(int64_t arg1)

140005aba  {
140005acd      char const* const var_40 = "pageIndex";
140005ad8      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140005adc      int64_t var_38 = 0;
140005ae4      int16_t var_28 = 0;
140005af1      void* var_48;
140005af1      nimFrame(&var_48);
140005af6      int64_t var_38_1 = 0x1f6;
140005b0a      popFrame();
140005b18      return arg1 >> 0xc;
140005aba  }


140005b19    uint64_t isAccessible__system_u6678(int64_t arg1, int64_t arg2)

140005b19  {
140005b30      char const* const var_40 = "isAccessible";
140005b3b      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140005b3f      int64_t var_38 = 0;
140005b47      int16_t var_28 = 0;
140005b54      void* var_48;
140005b54      nimFrame(&var_48);
140005b59      int64_t var_38_1 = 0x23f;
140005b61      int64_t var_10 = 0;
140005b8a      char rax_4 = contains__system_u6400(arg1 + 0x28a0, pageIndex__system_u6643(arg2));
140005b92      popFrame();
140005ba0      return (uint64_t)rax_4;
140005b19  }


140005ba1    int64_t* updatePrevSize__system_u6696(int64_t arg1, void* arg2, int64_t arg3)

140005ba1  {
140005bbc      char const* const var_50 = "updatePrevSize";
140005bc7      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140005bcb      int64_t var_48 = 0;
140005bd3      int16_t var_38 = 0;
140005be0      void* var_58;
140005be0      nimFrame(&var_58);
140005be5      int64_t var_48_1 = 0x261;
140005bed      int64_t var_10 = 0;
140005c04      int64_t* rax_2 = pluspercent___system_u793(arg2, *(uint64_t*)((char*)arg2 + 8));
140005c15      int64_t var_48_2 = 0x263;
140005c1d      char var_19 = 0;
140005c1d      
140005c3d      if (isAccessible__system_u6678(arg1, rax_2) == 1)
140005c3d      {
140005c3f          int64_t var_48_3 = 0x264;
140005c59          *(uint64_t*)rax_2 = ((uint64_t)(uint32_t)*(uint64_t*)rax_2 & 1) | arg3;
140005c3d      }
140005c3d      
140005c6a      return popFrame();
140005ba1  }


140005c6b    void* intSetPut__system_u6383(void* arg1, int64_t arg2, int64_t arg3)

140005c6b  {
140005c86      char const* const var_40 = "intSetPut";
140005c91      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140005c95      int64_t var_38 = 0;
140005c9d      int16_t var_28 = 0;
140005caa      void* var_48;
140005caa      nimFrame(&var_48);
140005caf      int64_t var_38_1 = 0x1a2;
140005cc7      void* result = intSetGet__system_u6351(arg2, arg3);
140005ccb      int64_t var_38_2 = 0x1a3;
140005ccb      
140005cd8      if (!result)
140005cd8      {
140005cda          int64_t var_38_3 = 0x1a4;
140005ce2          int64_t var_18_1 = 0;
140005d03          result = llAlloc__system_u6218(arg1, 0x50);
140005d07          int64_t var_38_4 = 0x1a5;
140005d22          *(uint64_t*)result = *(uint64_t*)(arg2 + ((uint64_t)(uint8_t)arg3 << 3));
140005d25          int64_t var_38_5 = 0x1a6;
140005d3c          *(uint64_t*)(arg2 + ((uint64_t)(uint8_t)arg3 << 3)) = result;
140005d40          int64_t var_38_6 = 0x1a7;
140005d50          *(uint64_t*)((char*)result + 8) = arg3;
140005cd8      }
140005cd8      
140005d57      popFrame();
140005d65      return result;
140005c6b  }


140005d66    int64_t* incl__system_u6441(void* arg1, int64_t arg2, int64_t arg3)

140005d66  {
140005d81      char const* const var_40 = "incl";
140005d8c      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140005d90      int64_t var_38 = 0;
140005d98      int16_t var_28 = 0;
140005da5      void* var_48;
140005da5      nimFrame(&var_48);
140005daa      int64_t var_38_1 = 0x1b2;
140005dcb      void* rax_3 = intSetPut__system_u6383(arg1, arg2, arg3 >> 9);
140005dd4      int64_t var_38_2 = 0x1b3;
140005de0      uint64_t rax_5 = (uint64_t)(uint32_t)arg3 & 0x1ff;
140005de9      int64_t var_38_3 = 0x1b4;
140005e32      *(uint64_t*)((char*)rax_3 + (((rax_5 >> 6) + 2) << 3)) |=
140005e32          1 << ((uint8_t)rax_5 & 0x3f);
140005e41      return popFrame();
140005d66  }


140005e42    int64_t* splitChunk2__system_u6701(void* arg1, void* arg2, int64_t arg3)

140005e42  {
140005e5d      char const* const var_50 = "splitChunk2";
140005e68      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140005e6c      int64_t var_48 = 0;
140005e74      int16_t var_38 = 0;
140005e81      void* var_58;
140005e81      nimFrame(&var_58);
140005e86      int64_t var_48_1 = 0x267;
140005e8e      int64_t var_10 = 0;
140005ea1      int64_t* result = pluspercent___system_u793(arg2, arg3);
140005eb2      int64_t var_48_2 = 0x268;
140005eca      result[1] = *(uint64_t*)((char*)arg2 + 8) - arg3;
140005ece      int64_t var_48_3 = 0x26c;
140005eda      result[3] = 0;
140005ee2      int64_t var_48_4 = 0x26d;
140005eee      result[4] = 0;
140005ef6      int64_t var_48_5 = 0x26f;
140005f06      *(uint64_t*)result = arg3;
140005f09      int64_t var_48_6 = 0x270;
140005f19      result[2] = arg1;
140005f1d      int64_t var_48_7 = 0x274;
140005f3b      updatePrevSize__system_u6696(arg1, arg2, result[1]);
140005f40      int64_t var_48_8 = 0x275;
140005f50      *(uint64_t*)((char*)arg2 + 8) = arg3;
140005f54      int64_t var_48_9 = 0x276;
140005f5c      int64_t var_18 = 0;
140005f6c      int64_t var_20 = 0;
140005fa0      incl__system_u6441(arg1, (char*)arg1 + 0x28a0, pageIndex__system_u6636(result));
140005fa5      popFrame();
140005fb3      return result;
140005e42  }


140005fb4    int64_t* mappingInsert__system_u6059(int64_t* arg1, int64_t arg2)

140005fb4  {
140005fcb      char const* const var_40 = "mappingInsert";
140005fd6      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140005fda      int64_t var_38 = 0;
140005fe2      int16_t var_28 = 0;
140005fef      void* var_48;
140005fef      nimFrame(&var_48);
140006000      int64_t var_18;
140006000      nimZeroMem(&var_18, 0x10);
140006005      int64_t var_38_1 = 0xf9;
140006018      var_18 = msbit__system_u6016((uint32_t)arg2);
14000601c      int64_t var_38_2 = 0xfa;
140006037      int64_t rax_5 = (arg2 >> ((char)var_18 - 5)) - 0x20;
14000603f      int64_t var_38_3 = 0xfb;
14000604f      var_18 -= 6;
140006053      popFrame();
140006064      *(uint64_t*)arg1 = var_18;
140006067      arg1[1] = rax_5;
140006074      return arg1;
140005fb4  }


140006075    int64_t* setBit__system_u6027(char arg1, int32_t* arg2)

140006075  {
14000608c      char const* const var_30 = "setBit";
140006097      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000609b      int64_t var_28 = 0;
1400060a3      int16_t var_18 = 0;
1400060b0      void* var_38;
1400060b0      nimFrame(&var_38);
1400060b5      int64_t var_28_1 = 0xe2;
1400060de      *(uint32_t*)arg2 |= (int32_t)(1 << (arg1 & 0x1f));
1400060eb      return popFrame();
140006075  }


1400060ec    int64_t* addChunkToMatrix__system_u6180(void* arg1, void* arg2)

1400060ec  {
140006103      char const* const var_50 = "addChunkToMatrix";
14000610e      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006112      int64_t var_48 = 0;
14000611a      int16_t var_38 = 0;
140006127      void* var_58;
140006127      nimFrame(&var_58);
14000612c      int64_t var_48_1 = 0x126;
140006143      int64_t var_28;
140006143      mappingInsert__system_u6059(&var_28, *(uint64_t*)((char*)arg2 + 8));
140006148      int64_t rax_1 = var_28;
140006158      int64_t var_48_2 = 0x127;
140006164      *(uint64_t*)((char*)arg2 + 0x20) = 0;
14000616c      int64_t var_48_3 = 0x128;
14000619a      int64_t var_20;
14000619a      *(uint64_t*)((char*)arg2 + 0x18) =
14000619a          *(uint64_t*)((char*)arg1 + ((var_20 + (rax_1 << 5) + 0x20c) << 3) + 8);
14000619e      int64_t var_48_4 = 0x129;
14000619e      
1400061cb      if (*(uint64_t*)((char*)arg1 + ((var_20 + (rax_1 << 5) + 0x20c) << 3) + 8))
1400061cb      {
1400061cd          int64_t var_48_5 = 0x12a;
1400061fb          *(uint64_t*)(
1400061fb              *(uint64_t*)((char*)arg1 + ((var_20 + (rax_1 << 5) + 0x20c) << 3) + 8)
1400061fb              + 0x20) = arg2;
1400061cb      }
1400061cb      
140006202      int64_t var_48_6 = 0x12b;
14000622b      *(uint64_t*)((char*)arg1 + ((var_20 + (rax_1 << 5) + 0x20c) << 3) + 8) = arg2;
140006230      int64_t var_48_7 = 0x12c;
14000625c      setBit__system_u6027((uint8_t)var_20, (char*)arg1 + ((rax_1 + 0x400) << 2) + 4);
140006261      int64_t var_48_8 = 0x12d;
14000627b      setBit__system_u6027((uint8_t)rax_1, (char*)arg1 + 0x1000);
14000628b      return popFrame();
1400060ec  }


14000628c    int64_t* splitChunk__system_u6725(void* arg1, void* arg2, int64_t arg3)

14000628c  {
1400062a7      char const* const var_40 = "splitChunk";
1400062b2      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400062b6      int64_t var_38 = 0;
1400062be      int16_t var_28 = 0;
1400062cb      void* var_48;
1400062cb      nimFrame(&var_48);
1400062d0      int64_t var_38_1 = 0x279;
1400062f3      int64_t var_38_2 = 0x27a;
140006306      addChunkToMatrix__system_u6180(arg1, splitChunk2__system_u6701(arg1, arg2, arg3));
140006316      return popFrame();
14000628c  }


140006317    int64_t* clearBit__system_u6034(char arg1, int32_t* arg2)

140006317  {
14000632e      char const* const var_30 = "clearBit";
140006339      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000633d      int64_t var_28 = 0;
140006345      int16_t var_18 = 0;
140006352      void* var_38;
140006352      nimFrame(&var_38);
140006357      int64_t var_28_1 = 0xe5;
140006382      *(uint32_t*)arg2 &= ~(int32_t)(1 << (arg1 & 0x1f));
14000638f      return popFrame();
140006317  }


140006390    int64_t* removeChunkFromMatrix2__system_u6171(void* arg1, void* arg2, int64_t arg3, int64_t arg4)

140006390  {
1400063af      char const* const var_30 = "removeChunkFromMatrix2";
1400063ba      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400063be      int64_t var_28 = 0;
1400063c6      int16_t var_18 = 0;
1400063d3      void* var_38;
1400063d3      nimFrame(&var_38);
1400063d8      int64_t var_28_1 = 0x11d;
140006405      *(uint64_t*)((char*)arg1 + ((arg4 + (arg3 << 5) + 0x20c) << 3) + 8) =
140006405          *(uint64_t*)((char*)arg2 + 0x18);
14000640a      int64_t var_28_2 = 0x11e;
14000640a      
140006437      if (!*(uint64_t*)((char*)arg1 + ((arg4 + (arg3 << 5) + 0x20c) << 3) + 8))
140006437      {
14000646e          int64_t var_28_4 = 0x10c;
14000649a          clearBit__system_u6034((uint8_t)arg4, (char*)arg1 + ((arg3 + 0x400) << 2) + 4);
14000649f          int64_t var_28_5 = 0x121;
1400064a7          int64_t var_28_6 = 0x10d;
1400064a7          
1400064c4          if (!*(uint32_t*)((char*)arg1 + ((arg3 + 0x400) << 2) + 4))
1400064c4          {
1400064c6              int64_t var_28_7 = 0x10f;
1400064e0              clearBit__system_u6034((uint8_t)arg3, (char*)arg1 + 0x1000);
1400064c4          }
140006437      }
140006437      else
140006437      {
140006439          int64_t var_28_3 = 0x11f;
140006463          *(uint64_t*)(*(uint64_t*)((char*)arg1 + ((arg4 + (arg3 << 5) + 0x20c) << 3) + 8)
140006463              + 0x20) = 0;
140006437      }
140006437      
1400064e8      int64_t var_28_8 = 0x122;
1400064f4      *(uint64_t*)((char*)arg2 + 0x20) = 0;
1400064fc      int64_t var_28_9 = 0x123;
140006508      *(uint64_t*)((char*)arg2 + 0x18) = 0;
14000651b      return popFrame();
140006390  }


14000651c    int64_t* getBigChunk__system_u6754(void* arg1, uint64_t arg2)

14000651c  {
140006533      char const* const var_60 = "getBigChunk";
14000653e      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006542      int64_t var_58 = 0;
14000654a      int16_t var_48 = 0;
140006557      void* var_68;
140006557      nimFrame(&var_68);
14000655c      int64_t var_58_1 = 0x2a4;
140006568      uint64_t var_28 = arg2;
14000656c      int64_t var_58_2 = 0x2a5;
140006574      int64_t var_30 = 0;
14000657c      int64_t var_58_3 = 0x2a6;
140006584      int64_t var_38 = 0;
14000658c      int64_t var_58_4 = 0x2a7;
1400065a6      mappingSearch__system_u6041(&var_28, &var_30, &var_38);
1400065ab      int64_t var_58_5 = 0x2a9;
1400065ca      int64_t* result = findSuitableBlock__system_u6074(arg1, &var_30, &var_38);
1400065ce      int64_t var_58_6 = 0x2b1;
1400065ce      
1400065dd      if (result)
1400065dd      {
1400066a4          int64_t var_58_14 = 0x2bc;
1400066c5          removeChunkFromMatrix2__system_u6171(arg1, result, var_30, var_38);
1400066ca          int64_t var_58_15 = 0x2bd;
1400066ca          
1400066e8          if (var_28 + 0xfff < result[1])
1400066e8          {
1400066ea              int64_t var_58_16 = 0x2be;
140006704              splitChunk__system_u6725(arg1, result, var_28);
1400066e8          }
1400065dd      }
1400065dd      else
1400065dd      {
1400065e3          int64_t var_58_7 = 0x2b2;
1400065e3          
1400065f5          if (var_28 > 0x7ffff)
1400065f5          {
140006636              int64_t var_58_10 = 0x2b6;
14000664e              result = requestOsChunks__system_u6653(arg1, var_28);
140006652              int64_t var_58_11 = 0x2b8;
140006652              
140006669              if (result[1] > var_28)
140006669              {
14000666b                  int64_t var_58_12 = 0x2b9;
140006685                  splitChunk__system_u6725(arg1, result, var_28);
140006669              }
1400065f5          }
1400065f5          else
1400065f5          {
1400065f7              int64_t var_58_8 = 0x2b3;
140006610              result = requestOsChunks__system_u6653(arg1, 0x80000);
140006614              int64_t var_58_9 = 0x2b4;
14000662e              splitChunk__system_u6725(arg1, result, var_28);
1400065f5          }
1400065f5          
14000668d          int64_t var_58_13 = 0x2ba;
14000669d          result[2] = arg1;
1400065dd      }
1400065dd      
14000670c      int64_t var_58_17 = 0x2c0;
140006718      *(uint64_t*)result = 1;
14000671f      int64_t var_58_18 = 0x2c4;
140006727      int64_t var_10 = 0;
140006737      int64_t var_18 = 0;
14000676b      incl__system_u6441(arg1, (char*)arg1 + 0x28a0, pageIndex__system_u6636(result));
140006770      int64_t var_58_19 = 0x2c5;
14000678e      *(uint64_t*)((char*)arg1 + 0x2880) -= var_28;
140006795      popFrame();
1400067a3      return result;
14000651c  }


1400067a4    int64_t* getSmallChunk__system_u6782(void* arg1)

1400067a4  {
1400067b7      char const* const var_40 = "getSmallChunk";
1400067c2      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400067c6      int64_t var_38 = 0;
1400067ce      int16_t var_28 = 0;
1400067db      void* var_48;
1400067db      nimFrame(&var_48);
1400067e0      int64_t var_38_1 = 0x2e6;
1400067f4      int64_t* result = getBigChunk__system_u6754(arg1, 0x1000);
1400067fd      int64_t var_38_2 = 0x2e9;
14000680d      popFrame();
14000681b      return result;
1400067a4  }


14000681c    int64_t pageAddr__system_u6650(int64_t arg1)

14000681c  {
14000682f      char const* const var_40 = "pageAddr";
14000683a      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000683e      int64_t var_38 = 0;
140006846      int16_t var_28 = 0;
140006853      void* var_48;
140006853      nimFrame(&var_48);
140006858      int64_t var_38_1 = 0x1f9;
14000686e      popFrame();
14000687c      return arg1 & 0xfffffffffffff000;
14000681c  }


14000687d    int64_t* compensateCounters__system_u6876(void* arg1, void* arg2, int64_t arg3)

14000687d  {
140006898      char const* const var_50 = "compensateCounters";
1400068a3      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400068a7      int64_t var_48 = 0;
1400068af      int16_t var_38 = 0;
1400068bc      void* var_58;
1400068bc      nimFrame(&var_58);
1400068c1      int64_t var_48_1 = 0x343;
1400068d1      int64_t* i = *(uint64_t*)((char*)arg2 + 0x28);
1400068d5      int64_t var_48_2 = 0x344;
1400068dd      int64_t var_18 = 0;
1400068e5      int64_t var_48_3 = 0x345;
1400068e5      
1400068f2      for (; i; i = *(uint64_t*)i)
1400068f2      {
1400068f8          int64_t var_48_4 = 0x346;
140006904          var_18 += arg3;
140006908          int64_t var_48_5 = 0x347;
140006910          int64_t var_20_1 = 0;
140006930          int64_t var_48_6 = 0x348;
140006930          
140006940          if (arg2 != pageAddr__system_u6650(i))
140006940          {
140006942              int64_t var_48_7 = 0x34b;
14000695a              *(uint64_t*)((char*)arg2 + 0x38) += 1;
140006940          }
140006940          
140006961          int64_t var_48_8 = 0x34c;
1400068f2      }
1400068f2      
14000697a      int64_t var_48_9 = 0x34e;
140006997      *(uint32_t*)((char*)arg2 + 0x30) += (uint32_t)var_18;
14000699a      int64_t var_48_10 = 0x34f;
1400069b5      *(uint64_t*)((char*)arg1 + 0x2888) -= var_18;
1400069c7      return popFrame();
14000687d  }


1400069c8    int64_t* listAdd__system_u6975(int64_t* arg1, void* arg2)

1400069c8  {
1400069df      char const* const var_30 = "listAdd";
1400069ea      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400069ee      int64_t var_28 = 0;
1400069f6      int16_t var_18 = 0;
140006a03      void* var_38;
140006a03      nimFrame(&var_38);
140006a08      int64_t var_28_1 = 0x24c;
140006a1b      *(uint64_t*)((char*)arg2 + 0x18) = *(uint64_t*)arg1;
140006a1f      int64_t var_28_2 = 0x24d;
140006a1f      
140006a31      if (*(uint64_t*)arg1)
140006a31      {
140006a33          int64_t var_28_3 = 0x24f;
140006a46          *(uint64_t*)(*(uint64_t*)arg1 + 0x20) = arg2;
140006a31      }
140006a31      
140006a4d      int64_t var_28_4 = 0x250;
140006a5d      *(uint64_t*)arg1 = arg2;
140006a6b      return popFrame();
1400069c8  }


140006a6c    int64_t* listRemove__system_u7052(int64_t* arg1, void* arg2)

140006a6c  {
140006a83      char const* const var_30 = "listRemove";
140006a8e      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006a92      int64_t var_28 = 0;
140006a9a      int16_t var_18 = 0;
140006aa7      void* var_38;
140006aa7      nimFrame(&var_38);
140006aac      int64_t var_28_1 = 0x254;
140006aac      
140006abf      if (arg2 != *(uint64_t*)arg1)
140006abf      {
140006b01          int64_t var_28_4 = 0x25a;
140006b19          *(uint64_t*)(*(uint64_t*)((char*)arg2 + 0x20) + 0x18) =
140006b19              *(uint64_t*)((char*)arg2 + 0x18);
140006b1d          int64_t var_28_5 = 0x25b;
140006b1d          
140006b30          if (*(uint64_t*)((char*)arg2 + 0x18))
140006b42              *(uint64_t*)(*(uint64_t*)((char*)arg2 + 0x18) + 0x20) =
140006b42                  *(uint64_t*)((char*)arg2 + 0x20);
140006abf      }
140006abf      else
140006abf      {
140006ac1          int64_t var_28_2 = 0x255;
140006ad5          *(uint64_t*)arg1 = *(uint64_t*)((char*)arg2 + 0x18);
140006ad8          int64_t var_28_3 = 0x257;
140006ad8          
140006aea          if (*(uint64_t*)arg1)
140006af3              *(uint64_t*)(*(uint64_t*)arg1 + 0x20) = 0;
140006abf      }
140006abf      
140006b49      int64_t var_28_6 = 0x25c;
140006b55      *(uint64_t*)((char*)arg2 + 0x18) = 0;
140006b5d      int64_t var_28_7 = 0x25d;
140006b69      *(uint64_t*)((char*)arg2 + 0x20) = 0;
140006b7c      return popFrame();
140006a6c  }


140006b7d    int64_t* excl__system_u6463(int64_t arg1, int64_t arg2)

140006b7d  {
140006b94      char const* const var_40 = "excl";
140006b9f      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006ba3      int64_t var_38 = 0;
140006bab      int16_t var_28 = 0;
140006bb8      void* var_48;
140006bb8      nimFrame(&var_48);
140006bbd      int64_t var_38_1 = 0x1b7;
140006bd7      void* rax_3 = intSetGet__system_u6351(arg1, arg2 >> 9);
140006be0      int64_t var_38_2 = 0x1b8;
140006be0      
140006bed      if (rax_3)
140006bed      {
140006bef          int64_t var_38_3 = 0x1b9;
140006bfb          uint64_t rax_5 = (uint64_t)(uint32_t)arg2 & 0x1ff;
140006c04          int64_t var_38_4 = 0x1ba;
140006c0c          int64_t var_38_5 = 0x1bb;
140006c5b          *(uint64_t*)((char*)rax_3 + (((rax_5 >> 6) + 2) << 3)) &=
140006c5b              ~(1 << ((uint8_t)rax_5 & 0x3f));
140006bed      }
140006bed      
140006c6d      return popFrame();
140006b7d  }


140006c6e    int64_t* decCurrMem__system_u6198(void* arg1, int64_t arg2)

140006c6e  {
140006c85      char const* const var_30 = "decCurrMem";
140006c90      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006c94      int64_t var_28 = 0;
140006c9c      int16_t var_18 = 0;
140006ca9      void* var_38;
140006ca9      nimFrame(&var_38);
140006cae      int64_t var_28_1 = 0x133;
140006cba      int64_t rdx = *(uint64_t*)((char*)arg1 + 0x2878);
140006cc5      int64_t rax_2 = *(uint64_t*)((char*)arg1 + 0x2870);
140006cc5      
140006ccf      if (rdx >= rax_2)
140006ccf          rax_2 = rdx;
140006ccf      
140006cd7      *(uint64_t*)((char*)arg1 + 0x2878) = rax_2;
140006cde      int64_t var_28_2 = 0x134;
140006cf9      *(uint64_t*)((char*)arg1 + 0x2870) -= arg2;
140006d0b      return popFrame();
140006c6e  }


140006d0c    int64_t* osDeallocPages__system_u5907(int64_t arg1)

140006d0c  {
140006d18      int64_t rdx;
140006d18      int64_t arg_10 = rdx;
140006d23      char const* const var_40 = "osDeallocPages";
140006d2e      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\osalloc.nim";
140006d32      int64_t var_38 = 0;
140006d3a      int16_t var_28 = 0;
140006d47      void* var_48;
140006d47      nimFrame(&var_48);
140006d4c      int64_t var_38_1 = 0xbe;
140006d5b      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\osalloc.nim";
140006d5f      int32_t var_c = 0;
140006d7f      BOOL rax_1;
140006d7f      int64_t rdx_1;
140006d7f      rax_1 = VirtualFree(arg1, 0, MEM_RELEASE);
140006d7f      
140006d88      if (rax_1)
140006dc9          return popFrame();
140006dc9      
140006d8a      int64_t var_38_2 = 0xbf;
140006d92      int32_t var_10 = 0;
140006da8      int32_t var_10_1 = printf("virtualFree failing!", rdx_1);
140006dab      int64_t var_38_3 = 0xc0;
140006db8      exit(1);
140006db8      /* no return */
140006d0c  }


140006dca    int64_t* freeHugeChunk__system_u6778(void* arg1, void* arg2)

140006dca  {
140006de1      char const* const var_40 = "freeHugeChunk";
140006dec      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006df0      int64_t var_38 = 0;
140006df8      int16_t var_28 = 0;
140006e05      void* var_48;
140006e05      nimFrame(&var_48);
140006e0a      int64_t var_38_1 = 0x2df;
140006e19      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006e21      int64_t rax_1 = *(uint64_t*)((char*)arg2 + 8);
140006e29      int64_t var_38_2 = 0x2e1;
140006e31      int64_t var_18 = 0;
140006e5a      excl__system_u6463((char*)arg1 + 0x28a0, pageIndex__system_u6636(arg2));
140006e5f      int64_t var_38_3 = 0x2e2;
140006e72      decCurrMem__system_u6198(arg1, rax_1);
140006e77      int64_t var_38_4 = 0x2e3;
140006e8a      osDeallocPages__system_u5907(arg2);
140006e9a      return popFrame();
140006dca  }


140006e9b    uint64_t chunkUnused__system_u6539(int64_t* arg1)

140006e9b  {
140006eae      char const* const var_40 = "chunkUnused";
140006eb9      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006ebd      int64_t var_38 = 0;
140006ec5      int16_t var_28 = 0;
140006ed2      void* var_48;
140006ed2      nimFrame(&var_48);
140006ed7      int64_t var_38_1 = 0x1d3;
140006eec      uint64_t rax_2;
140006eec      (uint8_t)rax_2 = !((uint64_t)(uint32_t)*(uint64_t*)arg1 & 1);
140006eef      char var_9 = (uint8_t)rax_2;
140006ef2      popFrame();
140006f00      return (uint64_t)var_9;
140006e9b  }


140006f01    uint64_t isSmallChunk__system_u6533(void* arg1)

140006f01  {
140006f14      char const* const var_40 = "isSmallChunk";
140006f1f      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006f23      int64_t var_38 = 0;
140006f2b      int16_t var_28 = 0;
140006f38      void* var_48;
140006f38      nimFrame(&var_48);
140006f3d      int64_t var_38_1 = 0x1d0;
140006f53      int64_t rax_1;
140006f53      (uint8_t)rax_1 = *(uint64_t*)((char*)arg1 + 8) <= 0xfc0;
140006f56      char var_9 = (uint8_t)rax_1;
140006f59      popFrame();
140006f67      return (uint64_t)var_9;
140006f01  }


140006f68    int64_t* removeChunkFromMatrix__system_u6129(void* arg1, void* arg2)

140006f68  {
140006f7f      char const* const var_50 = "removeChunkFromMatrix";
140006f8a      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140006f8e      int64_t var_48 = 0;
140006f96      int16_t var_38 = 0;
140006fa3      void* var_58;
140006fa3      nimFrame(&var_58);
140006fa8      int64_t var_48_1 = 0x112;
140006fbf      int64_t var_28;
140006fbf      mappingInsert__system_u6059(&var_28, *(uint64_t*)((char*)arg2 + 8));
140006fc4      int64_t rax_1 = var_28;
140006fd4      int64_t var_48_2 = 0x113;
140006fd4      
140006fe7      if (*(uint64_t*)((char*)arg2 + 0x18))
140006ff9          *(uint64_t*)(*(uint64_t*)((char*)arg2 + 0x18) + 0x20) =
140006ff9              *(uint64_t*)((char*)arg2 + 0x20);
140006ff9      
140007000      int64_t var_48_3 = 0x114;
140007000      
140007013      if (*(uint64_t*)((char*)arg2 + 0x20))
140007025          *(uint64_t*)(*(uint64_t*)((char*)arg2 + 0x20) + 0x18) =
140007025              *(uint64_t*)((char*)arg2 + 0x18);
140007025      
14000702c      int64_t var_48_4 = 0x115;
14000705a      int64_t var_20;
14000705a      
14000705a      if (arg2 == *(uint64_t*)((char*)arg1 + ((var_20 + (rax_1 << 5) + 0x20c) << 3) + 8))
14000705a      {
140007060          int64_t var_48_5 = 0x116;
14000708d          *(uint64_t*)((char*)arg1 + ((var_20 + (rax_1 << 5) + 0x20c) << 3) + 8) =
14000708d              *(uint64_t*)((char*)arg2 + 0x18);
140007092          int64_t var_48_6 = 0x117;
140007092          
1400070bf          if (!*(uint64_t*)((char*)arg1 + ((var_20 + (rax_1 << 5) + 0x20c) << 3) + 8))
1400070bf          {
1400070c1              int64_t var_48_7 = 0x10c;
1400070ed              clearBit__system_u6034((uint8_t)var_20, 
1400070ed                  (char*)arg1 + ((rax_1 + 0x400) << 2) + 4);
1400070f2              int64_t var_48_8 = 0x118;
1400070fa              int64_t var_48_9 = 0x10d;
1400070fa              
140007117              if (!*(uint32_t*)((char*)arg1 + ((rax_1 + 0x400) << 2) + 4))
140007117              {
140007119                  int64_t var_48_10 = 0x10f;
140007133                  clearBit__system_u6034((uint8_t)rax_1, (char*)arg1 + 0x1000);
140007117              }
1400070bf          }
14000705a      }
14000705a      
140007141      int64_t var_48_11 = 0x119;
14000714d      *(uint64_t*)((char*)arg2 + 0x20) = 0;
140007155      int64_t var_48_12 = 0x11a;
140007161      *(uint64_t*)((char*)arg2 + 0x18) = 0;
140007174      return popFrame();
140006f68  }


140007175    int64_t* freeBigChunk__system_u6730(void* arg1, int64_t* arg2)

140007175  {
14000718f      char const* const var_a0 = "freeBigChunk";
14000719d      char const* const var_90 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400071a4      int64_t var_98 = 0;
1400071af      int16_t var_88 = 0;
1400071bf      void* var_a8;
1400071bf      nimFrame(&var_a8);
1400071c4      int64_t var_98_1 = 0x27d;
1400071d3      int64_t* var_70 = arg2;
1400071d7      int64_t var_98_2 = 0x27f;
1400071fc      *(uint64_t*)((char*)arg1 + 0x2880) += var_70[1];
140007203      int64_t var_98_3 = 0x280;
14000721d      *(uint64_t*)var_70 &= 0xfffffffffffffffe;
140007220      int64_t var_98_4 = 0x282;
14000722f      int64_t rax_8 = *(uint64_t*)var_70;
140007236      int64_t var_98_5 = 0x283;
140007236      
140007246      if (rax_8)
140007246      {
14000724c          int64_t var_98_6 = 0x284;
140007257          int64_t var_20_1 = 0;
14000726d          int64_t* rax_11 = minuspercent___system_u813(var_70, rax_8);
14000727e          int64_t var_98_7 = 0x286;
140007289          char var_9_1 = 0;
14000729d          char var_9_2 = isAccessible__system_u6678(arg1, rax_11);
14000729d          
1400072a9          if (var_9_2 == 1)
1400072b7              var_9_2 = chunkUnused__system_u6539(rax_11);
1400072b7          
1400072c6          if (var_9_2 == 1)
1400072c6          {
1400072cc              int64_t var_98_8 = 0x288;
1400072d7              char var_a_1 = 0;
1400072db              char var_29_1 = 0;
1400072f4              uint32_t rax_23;
1400072f4              (uint8_t)rax_23 = (uint32_t)isSmallChunk__system_u6533(rax_11);
140007300              char var_a_3 = ((uint8_t)rax_23 ^ 1) & 1;
140007300              
14000730d              if (var_a_3 == 1)
14000730d              {
14000731d                  int64_t rax_29;
14000731d                  (uint8_t)rax_29 = rax_11[1] <= 0x3effffff;
140007320                  var_a_3 = (uint8_t)rax_29;
14000730d              }
14000730d              
14000732f              if (var_a_3 == 1)
14000732f              {
140007335                  int64_t var_98_9 = 0x289;
14000734b                  removeChunkFromMatrix__system_u6129(arg1, rax_11);
140007350                  int64_t var_98_10 = 0x28a;
140007372                  rax_11[1] += var_70[1];
140007376                  int64_t var_98_11 = 0x28b;
140007381                  int64_t var_38_1 = 0;
1400073ad                  excl__system_u6463((char*)arg1 + 0x28a0, 
1400073ad                      pageIndex__system_u6636(var_70));
1400073b2                  int64_t var_98_12 = 0x28c;
1400073c1                  var_70 = rax_11;
1400073c5                  int64_t var_98_13 = 0x28d;
1400073c5                  
1400073de                  if (var_70[1] > 0x3f000000)
1400073de                  {
1400073e0                      int64_t var_98_14 = 0x28e;
1400073fc                      int64_t* rax_45 =
1400073fc                          splitChunk2__system_u6701(arg1, var_70, 0x3f000000);
140007405                      int64_t var_98_15 = 0x292;
14000741b                      addChunkToMatrix__system_u6180(arg1, var_70);
140007420                      int64_t var_98_16 = 0x293;
14000742f                      var_70 = rax_45;
1400073de                  }
14000732f              }
1400072c6          }
140007246      }
140007246      
14000743f      int64_t var_98_17 = 0x295;
14000744a      int64_t var_48 = 0;
140007464      int64_t* rax_50 = pluspercent___system_u793(var_70, var_70[1]);
140007475      int64_t var_98_18 = 0x297;
140007480      char var_b = 0;
140007494      char var_b_1 = isAccessible__system_u6678(arg1, rax_50);
140007494      
1400074a0      if (var_b_1 == 1)
1400074ae          var_b_1 = chunkUnused__system_u6539(rax_50);
1400074ae      
1400074bd      if (var_b_1 == 1)
1400074bd      {
1400074c3          int64_t var_98_19 = 0x299;
1400074ce          char var_c_1 = 0;
1400074d2          char var_51_1 = 0;
1400074eb          uint32_t rax_62;
1400074eb          (uint8_t)rax_62 = (uint32_t)isSmallChunk__system_u6533(rax_50);
1400074f7          char var_c_3 = ((uint8_t)rax_62 ^ 1) & 1;
1400074f7          
140007504          if (var_c_3 == 1)
140007504          {
140007514              int64_t rax_68;
140007514              (uint8_t)rax_68 = var_70[1] <= 0x3effffff;
140007517              var_c_3 = (uint8_t)rax_68;
140007504          }
140007504          
140007526          if (var_c_3 == 1)
140007526          {
14000752c              int64_t var_98_20 = 0x29a;
140007542              removeChunkFromMatrix__system_u6129(arg1, rax_50);
140007547              int64_t var_98_21 = 0x29b;
140007569              var_70[1] += rax_50[1];
14000756d              int64_t var_98_22 = 0x29c;
140007578              int64_t var_60_1 = 0;
1400075a1              excl__system_u6463((char*)arg1 + 0x28a0, pageIndex__system_u6636(rax_50));
1400075a6              int64_t var_98_23 = 0x29d;
1400075a6              
1400075bf              if (var_70[1] > 0x3f000000)
1400075bf              {
1400075c1                  int64_t var_98_24 = 0x29e;
1400075e6                  int64_t var_98_25 = 0x29f;
1400075fc                  addChunkToMatrix__system_u6180(arg1, 
1400075fc                      splitChunk2__system_u6701(arg1, var_70, 0x3f000000));
1400075bf              }
140007526          }
1400074bd      }
1400074bd      
14000760a      int64_t var_98_26 = 0x2a0;
140007620      addChunkToMatrix__system_u6180(arg1, var_70);
140007633      return popFrame();
140007175  }


140007634    int64_t* deallocBigChunk__system_u6800(void* arg1, int64_t* arg2)

140007634  {
14000764b      char const* const var_30 = "deallocBigChunk";
140007656      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000765a      int64_t var_28 = 0;
140007662      int16_t var_18 = 0;
14000766f      void* var_38;
14000766f      nimFrame(&var_38);
140007674      int64_t var_28_1 = 0x31f;
140007696      *(uint64_t*)((char*)arg1 + 0x2888) -= arg2[1];
14000769d      int64_t var_28_2 = 0x325;
14000769d      
1400076b3      if (arg2[1] <= 0x3f000000)
1400076b3      {
1400076c8          int64_t var_28_3 = 0x326;
1400076db          freeBigChunk__system_u6730(arg1, arg2);
1400076b3      }
1400076b3      else
1400076c0          freeHugeChunk__system_u6778(arg1, arg2);
1400076c0      
1400076eb      return popFrame();
140007634  }


1400076ec    int64_t* addToSharedFreeListBigChunks__system_u6811(void* arg1, void* arg2)

1400076ec  {
140007703      char const* const var_40 = "addToSharedFreeListBigChunks";
14000770e      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140007712      int64_t var_38 = 0;
14000771a      int16_t var_28 = 0;
140007727      void* var_48;
140007727      nimFrame(&var_48);
14000772c      int64_t var_38_1 = 0x338;
1400077a8      int64_t rax_8;
1400077a8      
1400077a8      do
1400077a8      {
140007734          int64_t var_38_2 = 0x32f;
14000773c          int64_t var_10_1 = 0;
140007761          *(uint64_t*)((char*)arg2 + 0x18) = *(uint64_t*)((char*)arg1 + 0x2898);
140007764          int64_t var_38_3 = 0x330;
14000776c          char var_11_1 = 0;
140007787          rax_8 = *(uint64_t*)((char*)arg2 + 0x18);
14000778a          bool z_1;
14000778a          
14000778a          if (rax_8 == *(uint64_t*)((char*)arg1 + 0x2898))
14000778a          {
14000778a              *(uint64_t*)((char*)arg1 + 0x2898) = arg2;
14000778a              z_1 = true;
14000778a          }
14000778a          else
14000778a          {
14000778a              rax_8 = *(uint64_t*)((char*)arg1 + 0x2898);
14000778a              z_1 = false;
14000778a          }
14000778a          
14000778f          int64_t rcx_2 = rax_8;
140007792          (uint8_t)rax_8 = z_1;
140007792          
140007797          if (!(uint8_t)rax_8)
140007799              *(uint64_t*)((char*)arg2 + 0x18) = rcx_2;
1400077a8      } while ((uint8_t)rax_8 != 1);
1400077aa      int64_t var_38_4 = 0x331;
1400077c5      return popFrame();
1400076ec  }


1400077c6    int64_t* freeDeferredObjects__system_u6911(void* arg1, int64_t* arg2)

1400077c6  {
1400077dd      char const* const var_50 = "freeDeferredObjects";
1400077e8      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400077ec      int64_t var_48 = 0;
1400077f4      int16_t var_38 = 0;
140007801      void* var_58;
140007801      nimFrame(&var_58);
140007806      int64_t var_48_1 = 0x352;
140007812      int64_t* i = arg2;
140007816      int64_t var_48_2 = 0x353;
14000781e      int64_t var_18 = 0x14;
140007826      int64_t var_48_3 = 0x354;
140007826      
1400078e3      do
1400078e3      {
14000782e          int64_t var_48_4 = 0x355;
14000783e          int64_t* i_1 = i[3];
140007845          int64_t var_48_5 = 0x356;
14000785a          i[3] = 0;
14000785d          int64_t var_48_6 = 0x357;
140007870          deallocBigChunk__system_u6800(arg1, i);
140007875          int64_t var_48_7 = 0x358;
140007875          
140007882          if (!var_18)
140007882          {
140007884              int64_t var_48_8 = 0x359;
140007884              
140007891              if (i_1)
140007891              {
140007893                  int64_t var_48_9 = 0x35a;
1400078a6                  addToSharedFreeListBigChunks__system_u6811(arg1, i_1);
140007891              }
140007891              
1400078ae              int64_t var_48_10 = 0x35c;
1400078b6              break;
140007882          }
140007882          
1400078b9          int64_t var_48_11 = 0x35d;
1400078c5          i = i_1;
1400078c9          int64_t var_48_12 = 0x35e;
1400078d1          var_18 -= 1;
1400078d6          int64_t var_48_13 = 0x35f;
1400078e3      } while (i);
1400078e3      
1400078f7      return popFrame();
1400077c6  }


1400078f8    int64_t* getHugeChunk__system_u6774(void* arg1, uint64_t arg2)

1400078f8  {
14000790f      char const* const var_50 = "getHugeChunk";
14000791a      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000791e      int64_t var_48 = 0;
140007926      int16_t var_38 = 0;
140007933      void* var_58;
140007933      nimFrame(&var_58);
140007938      int64_t var_48_1 = 0x2ca;
140007940      int64_t var_10 = 0;
140007953      int64_t* result = allocPages__system_u6210(arg1, arg2);
140007964      int64_t var_48_2 = 0x2d0;
140007977      incCurrMem__system_u6190(arg1, arg2);
14000797c      int64_t var_48_3 = 0x2d4;
140007988      result[3] = 0;
140007990      int64_t var_48_4 = 0x2d5;
14000799c      result[4] = 0;
1400079a4      int64_t var_48_5 = 0x2d6;
1400079b4      result[1] = arg2;
1400079b8      int64_t var_48_6 = 0x2d8;
1400079c4      *(uint64_t*)result = 1;
1400079cb      int64_t var_48_7 = 0x2d9;
1400079db      result[2] = arg1;
1400079df      int64_t var_48_8 = 0x2da;
1400079e7      int64_t var_18 = 0;
1400079f7      int64_t var_20 = 0;
140007a2b      incl__system_u6441(arg1, (char*)arg1 + 0x28a0, pageIndex__system_u6636(result));
140007a30      popFrame();
140007a3e      return result;
1400078f8  }


140007a3f    void* rawAlloc__system_u6943(void* arg1, int64_t arg2)

140007a3f  {
140007a59      char const* const var_80 = "rawAlloc";
140007a64      char const* const var_70 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140007a68      int64_t var_78 = 0;
140007a70      int16_t var_68 = 0;
140007a7d      void* var_88;
140007a7d      nimFrame(&var_88);
140007a82      int64_t var_10 = 0;
140007a8a      int64_t var_78_1 = 0x366;
140007a9e      int64_t rax_1 = roundup__system_u5881(arg2, 0x10);
140007aa7      int64_t var_78_2 = 0x36b;
140007ab7      void* result;
140007ab7      
140007ab7      if (rax_1 > 0xfc0)
140007ab7      {
140007e64          int64_t var_48_1 = 0;
140007e6c          int64_t var_50_1 = 0;
140007e74          int64_t var_78_36 = 0x3c3;
140007e8c          int64_t* temp0_3 = *(uint64_t*)((char*)arg1 + 0x2898);
140007e8c          *(uint64_t*)((char*)arg1 + 0x2898) = nullptr;
140007e93          int64_t var_78_37 = 0x3c7;
140007e93          
140007ea0          if (temp0_3)
140007ea0          {
140007ea2              int64_t var_78_38 = 0x3c8;
140007eb5              freeDeferredObjects__system_u6911(arg1, temp0_3);
140007ea0          }
140007ea0          
140007ebd          int64_t var_78_39 = 0x3ca;
140007ed1          int64_t var_78_40 = 0x3cc;
140007ee1          int64_t* var_18_1;
140007ee1          
140007ee1          if (arg2 + 0x30 <= 0x3f000000)
140007ee1          {
140007f02              int64_t var_78_41 = 0x3cd;
140007f22              var_18_1 = getBigChunk__system_u6754(arg1, arg2 + 0x30);
140007ee1          }
140007ee1          else
140007efb              var_18_1 = getHugeChunk__system_u6774(arg1, arg2 + 0x30);
140007efb          
140007f26          int64_t var_78_42 = 0x3d0;
140007f36          result = &var_18_1[6];
140007f3a          int64_t var_78_43 = 0x3d6;
140007f5c          *(uint64_t*)((char*)arg1 + 0x2888) += var_18_1[1];
140007ab7      }
140007ab7      else
140007ab7      {
140007abd          int64_t var_78_3 = 0x37b;
140007ac5          int64_t rax_2 = rax_1;
140007ac5          
140007ad0          if (rax_2 < 0)
140007ad0              rax_2 += 0xf;
140007ad0          
140007ad4          int64_t rax_3 = rax_2 >> 4;
140007adc          int64_t var_78_4 = 0x37c;
140007aec          void* rax_5 = *(uint64_t*)((char*)arg1 + (rax_3 << 3));
140007af4          int64_t var_78_5 = 0x37d;
140007af4          
140007b01          if (rax_5)
140007b01          {
140007c80              int64_t var_78_21 = 0x39a;
140007c80              
140007c93              if (*(uint64_t*)((char*)rax_5 + 0x28))
140007c93              {
140007ce9                  int64_t var_78_24 = 0x3a1;
140007cf9                  result = *(uint64_t*)((char*)rax_5 + 0x28);
140007cfd                  int64_t var_78_25 = 0x3a4;
140007d14                  *(uint64_t*)((char*)rax_5 + 0x28) = **(uint64_t**)((char*)rax_5 + 0x28);
140007d18                  int64_t var_78_26 = 0x3a5;
140007d20                  int64_t var_40_1 = 0;
140007d20                  
140007d40                  if (pageAddr__system_u6650(result) != rax_5)
140007d40                  {
140007d42                      int64_t var_78_27 = 0x3a7;
140007d5a                      *(uint64_t*)((char*)rax_5 + 0x38) -= 1;
140007d40                  }
140007c93              }
140007c93              else
140007c93              {
140007c95                  int64_t var_78_22 = 0x39d;
140007c9d                  int64_t var_38_1 = 0;
140007cc6                  result = pluspercent___system_u793((char*)rax_5 + 0x40, 
140007cc6                      (uint64_t)*(uint32_t*)((char*)rax_5 + 0x34));
140007cca                  int64_t var_78_23 = 0x39e;
140007ce3                  *(uint32_t*)((char*)rax_5 + 0x34) += (uint32_t)rax_1;
140007c93              }
140007c93              
140007d61              int64_t var_78_28 = 0x3ae;
140007d82              *(uint32_t*)((char*)rax_5 + 0x30) -= (uint32_t)rax_1;
140007d85              int64_t var_78_29 = 0x3b4;
140007d8d              int64_t var_78_30 = 0x36f;
140007d8d              
140007da0              if (!*(uint64_t*)((char*)rax_5 + 0x28))
140007da0              {
140007da2                  int64_t var_78_31 = 0x372;
140007dc0                  void* rdx_19 = ((rax_3 + 0x100) << 3) + arg1;
140007dc8                  int64_t temp0_2 = *(uint64_t*)rdx_19;
140007dc8                  *(uint64_t*)rdx_19 = 0;
140007dd2                  *(uint64_t*)((char*)rax_5 + 0x28) = temp0_2;
140007dd6                  int64_t var_78_32 = 0x378;
140007df0                  compensateCounters__system_u6876(arg1, rax_5, rax_1);
140007da0              }
140007da0              
140007df8              int64_t var_78_33 = 0x3b6;
140007df8              
140007e0d              if (rax_1 > (int64_t)*(uint32_t*)((char*)rax_5 + 0x30))
140007e0d              {
140007e0f                  int64_t var_78_34 = 0x3b9;
140007e31                  listRemove__system_u7052((char*)arg1 + (rax_3 << 3), rax_5);
140007e0d              }
140007b01          }
140007b01          else
140007b01          {
140007b07              int64_t var_78_6 = 0x37f;
140007b16              int64_t* rax_7 = getSmallChunk__system_u6782(arg1);
140007b1f              int64_t var_78_7 = 0x381;
140007b2b              rax_7[5] = 0;
140007b33              int64_t var_78_8 = 0x382;
140007b3f              rax_7[7] = 0;
140007b47              int64_t var_78_9 = 0x384;
140007b57              rax_7[1] = rax_1;
140007b5b              int64_t var_78_10 = 0x385;
140007b6d              *(uint32_t*)((char*)rax_7 + 0x34) = (uint32_t)rax_1;
140007b70              int64_t var_78_11 = 0x386;
140007b87              rax_7[6] = 0xfc0 - (uint32_t)rax_1;
140007b8a              int64_t var_78_12 = 0x388;
140007b96              rax_7[3] = 0;
140007b9e              int64_t var_78_13 = 0x389;
140007baa              rax_7[4] = 0;
140007bb2              int64_t var_78_14 = 0x38c;
140007bba              int64_t var_78_15 = 0x36f;
140007bba              
140007bcd              if (!rax_7[5])
140007bcd              {
140007bcf                  int64_t var_78_16 = 0x372;
140007bed                  int64_t* rdx_6 = ((rax_3 + 0x100) << 3) + arg1;
140007bf5                  int64_t temp0_1 = *(uint64_t*)rdx_6;
140007bf5                  *(uint64_t*)rdx_6 = 0;
140007bff                  rax_7[5] = temp0_1;
140007c03                  int64_t var_78_17 = 0x378;
140007c1d                  compensateCounters__system_u6876(arg1, rax_7, rax_1);
140007bcd              }
140007bcd              
140007c25              int64_t var_78_18 = 0x38d;
140007c25              
140007c3a              if (rax_1 <= (int64_t)rax_7[6])
140007c3a              {
140007c3c                  int64_t var_78_19 = 0x390;
140007c5e                  listAdd__system_u6975((char*)arg1 + (rax_3 << 3), rax_7);
140007c3a              }
140007c3a              
140007c66              int64_t var_78_20 = 0x391;
140007c76              result = &rax_7[8];
140007b01          }
140007b01          
140007e39          int64_t var_78_35 = 0x3be;
140007e57          *(uint64_t*)((char*)arg1 + 0x2888) += rax_1;
140007ab7      }
140007ab7      
140007f63      popFrame();
140007f74      return result;
140007a3f  }


140007f75    void* alloc__system_u7201(void* arg1, int64_t arg2)

140007f75  {
140007f8c      char const* const var_40 = "alloc";
140007f97      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140007f9b      int64_t var_38 = 0;
140007fa3      int16_t var_28 = 0;
140007fb0      void* var_48;
140007fb0      nimFrame(&var_48);
140007fb5      int64_t var_38_1 = 0x47c;
140007fc8      void* result = rawAlloc__system_u6943(arg1, arg2);
140007fd1      popFrame();
140007fdf      return result;
140007f75  }


140007fe0    void* allocImpl__system_u1747(int64_t arg1)

140007fe0  {
140008017      return alloc__system_u7201(__emutls_get_address(&_.data), arg1);
140007fe0  }


140008018    void* allocSharedImpl(int64_t arg1)

140008018  {
14000803d      return allocImpl__system_u1747(arg1);
140008018  }


14000803e    int64_t* raiseRangeErrorNoArgs()

14000803e  {
140008054      int64_t var_18 = 0x12;
140008058      void* const var_10 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_13;
14000806e      return sysFatal__system_u4979(&var_18);
14000803e  }


14000806f    int64_t* init__system_u3330(int64_t* arg1, int64_t arg2)

14000806f  {
140008086      char const* const var_40 = "init";
140008091      char const* const var_30 =
140008091          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140008095      int64_t var_38 = 0;
14000809d      int16_t var_28 = 0;
1400080aa      void* var_48;
1400080aa      nimFrame(&var_48);
1400080af      int64_t var_38_1 = 0x22;
1400080be      char const* const var_30_1 =
1400080be          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
1400080c6      *(uint64_t*)arg1 = 0;
1400080cd      int64_t var_38_2 = 0x23;
1400080dd      arg1[1] = arg2;
1400080e1      int64_t var_38_3 = 0x25;
1400080f1      char rdx_1 = 0;
1400080f6      int64_t rax_4 = arg1[1] * 0x10;
1400080f6      bool o = /* bool o = unimplemented  {imul rax, rax, 0x10} */;
1400080f6      
1400080fa      if (o)
1400080fc          rdx_1 = 1;
1400080fc      
140008113      if (rdx_1 & 1)
140008115          raiseOverflow();
140008113      else if (rax_4 >= 0)
140008123      {
14000812c          int64_t var_10_1 = 0;
14000814c          arg1[2] = allocSharedImpl(rax_4);
140008123      }
140008123      else
140008125          raiseRangeErrorNoArgs();
140008125      
14000815b      return popFrame();
14000806f  }


14000815c    int64_t ptrSize__system_u7189(int64_t arg1)

14000815c  {
14000816f      char const* const var_50 = "ptrSize";
14000817a      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000817e      int64_t var_48 = 0;
140008186      int16_t var_38 = 0;
140008193      void* var_58;
140008193      nimFrame(&var_58);
140008198      int64_t var_48_1 = 0x46e;
1400081a7      char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400081b2      void* rax_1 = pageAddr__system_u6650(arg1);
1400081bb      int64_t var_48_2 = 0x470;
1400081cb      int64_t result = *(uint64_t*)((char*)rax_1 + 8);
1400081cf      int64_t var_48_3 = 0x471;
1400081d7      char var_19 = 0;
1400081d7      
1400081ee      if (!isSmallChunk__system_u6533(rax_1))
1400081ee      {
1400081f0          int64_t var_48_4 = 0x472;
1400081f8          result -= 0x30;
1400081ee      }
1400081ee      
140008200      popFrame();
14000820e      return result;
14000815c  }


14000820f    int64_t* addToSharedFreeList__system_u6835(void* arg1, int64_t* arg2, int64_t arg3)

14000820f  {
14000822a      char const* const var_40 = "addToSharedFreeList";
140008235      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
140008239      int64_t var_38 = 0;
140008241      int16_t var_28 = 0;
14000824e      void* var_48;
14000824e      nimFrame(&var_48);
140008253      int64_t var_38_1 = 0x33b;
1400082e4      int64_t* rax_12;
1400082e4      
1400082e4      do
1400082e4      {
14000825b          int64_t var_38_2 = 0x32f;
140008263          int64_t var_10_1 = 0;
140008293          *(uint64_t*)arg2 =
140008293              *(uint64_t*)(((arg3 + 0x100) << 3) + *(uint64_t*)((char*)arg1 + 0x10));
140008296          int64_t var_38_3 = 0x330;
14000829e          char var_11_1 = 0;
1400082c0          int64_t** r8_1 = *(uint64_t*)((char*)arg1 + 0x10) + ((arg3 + 0x100) << 3);
1400082c3          rax_12 = *(uint64_t*)arg2;
1400082c6          bool z_1;
1400082c6          
1400082c6          if (rax_12 == *(uint64_t*)r8_1)
1400082c6          {
1400082c6              *(uint64_t*)r8_1 = arg2;
1400082c6              z_1 = true;
1400082c6          }
1400082c6          else
1400082c6          {
1400082c6              rax_12 = *(uint64_t*)r8_1;
1400082c6              z_1 = false;
1400082c6          }
1400082c6          
1400082cb          int64_t* rcx_2 = rax_12;
1400082ce          (uint8_t)rax_12 = z_1;
1400082ce          
1400082d3          if (!(uint8_t)rax_12)
1400082d5              *(uint64_t*)arg2 = rcx_2;
1400082e4      } while ((uint8_t)rax_12 != 1);
1400082e6      int64_t var_38_4 = 0x331;
140008301      return popFrame();
14000820f  }


140008302    int64_t* rawDealloc__system_u7119(void* arg1, int64_t* arg2)

140008302  {
14000831c      char const* const var_70 = "rawDealloc";
140008327      char const* const var_60 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000832b      int64_t var_68 = 0;
140008333      int16_t var_58 = 0;
140008340      void* var_78;
140008340      nimFrame(&var_78);
140008345      int64_t var_68_1 = 0x3e5;
140008354      int64_t* rax_1 = pageAddr__system_u6650(arg2);
14000835d      int64_t var_68_2 = 0x3e7;
140008365      char var_19 = 0;
140008365      
140008381      if (isSmallChunk__system_u6533(rax_1) != 1)
140008381      {
140008670          int64_t var_68_25 = 0x424;
140008670          
140008684          if (arg1 != rax_1[2])
140008684          {
1400086a1              int64_t var_68_27 = 0x427;
1400086b8              addToSharedFreeListBigChunks__system_u6811(rax_1[2], rax_1);
140008684          }
140008684          else
140008684          {
140008686              int64_t var_68_26 = 0x425;
140008699              deallocBigChunk__system_u6800(arg1, rax_1);
140008684          }
140008381      }
140008381      else
140008381      {
140008387          int64_t var_68_3 = 0x3e9;
140008397          int64_t var_68_4 = 0x3ea;
1400083a3          int64_t rax_8 = rax_1[1];
1400083ab          int64_t var_68_5 = 0x3ed;
1400083bb          int64_t var_68_6 = 0x3ee;
1400083bb          
1400083cf          if (arg1 != rax_1[2])
1400083cf          {
14000863a              int64_t var_68_24 = 0x41c;
140008642              int64_t rax_69 = rax_8;
140008642              
14000864d              if (rax_69 < 0)
14000864d                  rax_69 += 0xf;
14000864d              
140008666              addToSharedFreeList__system_u6835(rax_1, arg2, rax_69 >> 4);
1400083cf          }
1400083cf          else
1400083cf          {
1400083d5              int64_t var_68_7 = 0x3f0;
1400083f0              *(uint64_t*)((char*)arg1 + 0x2888) -= rax_8;
1400083f7              int64_t var_68_8 = 0x3fd;
1400083ff              int64_t rax_15 = rax_8;
1400083ff              
14000840a              if (rax_15 < 0)
14000840a                  rax_15 += 0xf;
14000840a              
14000841d              void* var_40_1 = *(uint64_t*)((char*)arg1 + (rax_15 >> 4 << 3));
140008421              int64_t var_68_9 = 0x3fe;
140008429              char var_9_1 = 0;
140008432              void* rax_18;
140008432              (uint8_t)rax_18 = var_40_1;
140008435              char var_9_2 = (uint8_t)rax_18;
140008435              
140008441              if (var_9_2 == 1)
140008441              {
14000844b                  int64_t* rax_21;
14000844b                  (uint8_t)rax_21 = rax_1 != var_40_1;
14000844e                  var_9_2 = (uint8_t)rax_21;
140008441              }
140008441              
14000845d              if (var_9_2 != 1)
14000845d              {
1400084cc                  int64_t var_68_14 = 0x409;
1400084e0                  *(uint64_t*)arg2 = rax_1[5];
1400084e3                  int64_t var_68_15 = 0x40a;
1400084f3                  rax_1[5] = arg2;
1400084f7                  int64_t var_68_16 = 0x40b;
1400084f7                  
14000850c                  if (rax_8 <= (int64_t)rax_1[6])
14000850c                  {
14000856a                      int64_t var_68_19 = 0x410;
140008587                      rax_1[6] += (uint32_t)rax_8;
14000858a                      int64_t var_68_20 = 0x414;
140008592                      char var_a_1 = 0;
1400085a2                      int32_t rax_56;
1400085a2                      (uint8_t)rax_56 = rax_1[6] == 0xfc0;
1400085a5                      char var_a_2 = (uint8_t)rax_56;
1400085a5                      
1400085b1                      if (var_a_2 == 1)
1400085b1                      {
1400085be                          int64_t rax_60;
1400085be                          (uint8_t)rax_60 = !rax_1[7];
1400085c1                          var_a_2 = (uint8_t)rax_60;
1400085b1                      }
1400085b1                      
1400085d0                      if (var_a_2 == 1)
1400085d0                      {
1400085d2                          int64_t var_68_21 = 0x415;
1400085da                          int64_t rax_63 = rax_8;
1400085da                          
1400085e5                          if (rax_63 < 0)
1400085e5                              rax_63 += 0xf;
1400085e5                          
140008603                          listRemove__system_u7052((char*)arg1 + (rax_63 >> 4 << 3), 
140008603                              rax_1);
140008608                          int64_t var_68_22 = 0x416;
140008614                          rax_1[1] = 0x1000;
14000861c                          int64_t var_68_23 = 0x417;
14000862f                          freeBigChunk__system_u6730(arg1, rax_1);
1400085d0                      }
14000850c                  }
14000850c                  else
14000850c                  {
14000850e                      int64_t var_68_17 = 0x40d;
140008516                      int64_t rax_41 = rax_8;
140008516                      
140008521                      if (rax_41 < 0)
140008521                          rax_41 += 0xf;
140008521                      
14000853f                      listAdd__system_u6975((char*)arg1 + (rax_41 >> 4 << 3), rax_1);
140008544                      int64_t var_68_18 = 0x40e;
140008561                      rax_1[6] += (uint32_t)rax_8;
14000850c                  }
14000845d              }
14000845d              else
14000845d              {
14000845f                  int64_t var_68_10 = 0x404;
140008473                  *(uint64_t*)arg2 = *(uint64_t*)((char*)var_40_1 + 0x28);
140008476                  int64_t var_68_11 = 0x405;
140008486                  *(uint64_t*)((char*)var_40_1 + 0x28) = arg2;
14000848a                  int64_t var_68_12 = 0x406;
1400084a7                  *(uint32_t*)((char*)var_40_1 + 0x30) += (uint32_t)rax_8;
1400084aa                  int64_t var_68_13 = 0x407;
1400084c2                  *(uint64_t*)((char*)var_40_1 + 0x38) += 1;
14000845d              }
1400083cf          }
140008381      }
140008381      
1400086cb      return popFrame();
140008302  }


1400086cc    int64_t* dealloc__system_u7209(void* arg1, int64_t* arg2)

1400086cc  {
1400086e3      char const* const var_30 = "dealloc";
1400086ee      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
1400086f2      int64_t var_28 = 0;
1400086fa      int16_t var_18 = 0;
140008707      void* var_38;
140008707      nimFrame(&var_38);
14000870c      int64_t var_28_1 = 0x48d;
14000871f      rawDealloc__system_u7119(arg1, arg2);
14000872f      return popFrame();
1400086cc  }


140008730    void* realloc__system_u7212(void* arg1, int64_t* arg2, uint64_t arg3)

140008730  {
14000874b      char const* const var_40 = "realloc";
140008756      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\alloc.nim";
14000875a      int64_t var_38 = 0;
140008762      int16_t var_28 = 0;
14000876f      void* var_48;
14000876f      nimFrame(&var_48);
140008774      int64_t var_38_1 = 0x490;
14000877c      void* result = nullptr;
140008784      int64_t var_38_2 = 0x491;
140008784      
140008791      if (arg3 <= 0)
140008791      {
140008825          int64_t var_38_7 = 0x496;
140008825          
140008832          if (arg2)
140008832          {
140008834              int64_t var_38_8 = 0x497;
140008847              dealloc__system_u7209(arg1, arg2);
140008832          }
140008791      }
140008791      else
140008791      {
140008797          int64_t var_38_3 = 0x492;
1400087af          result = alloc__system_u7201(arg1, arg3);
1400087b3          int64_t var_38_4 = 0x493;
1400087b3          
1400087c0          if (arg2)
1400087c0          {
1400087c2              int64_t var_38_5 = 0x494;
1400087ca              int64_t var_18_1 = 0;
1400087d9              uint64_t rax_4 = ptrSize__system_u7189(arg2);
1400087e6              uint64_t rax_5 = arg3;
1400087e6              
1400087ed              if (rax_4 <= rax_5)
1400087ed                  rax_5 = rax_4;
1400087ed              
140008802              copyMem__system_u1731(result, arg2, rax_5);
140008807              int64_t var_38_6 = 0x495;
14000881a              dealloc__system_u7209(arg1, arg2);
1400087c0          }
140008791      }
140008791      
14000884f      popFrame();
14000885d      return result;
140008730  }


14000885e    void* reallocImpl__system_u1753(int64_t* arg1, uint64_t arg2)

14000885e  {
1400088a0      return realloc__system_u7212(__emutls_get_address(&_.data), arg1, arg2);
14000885e  }


1400088a1    void* reallocSharedImpl__system_u1766(int64_t* arg1, uint64_t arg2)

1400088a1  {
1400088ce      return reallocImpl__system_u1753(arg1, arg2);
1400088a1  }


1400088cf    int64_t* resize__system_u3246(void* arg1)

1400088cf  {
1400088e2      char const* const var_50 = "resize";
1400088ed      char const* const var_40 =
1400088ed          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
1400088f1      int64_t var_48 = 0;
1400088f9      int16_t var_38 = 0;
140008906      void* var_58;
140008906      nimFrame(&var_58);
14000890b      int64_t var_48_1 = 0x14;
14000891a      char const* const var_40_1 =
14000891a          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140008922      int64_t rax_1 = *(uint64_t*)((char*)arg1 + 8);
140008930      int64_t rax_3 = (rax_1 + (rax_1 >> 0x3f)) >> 1;
14000893a      int64_t rax_5 = *(uint64_t*)((char*)arg1 + 8);
14000893e      char rdx_2 = 0;
14000893e      
140008946      if (rax_5 + rax_3)
140008948          rdx_2 = 1;
140008948      
14000895f      if (!(rdx_2 & 1))
14000895f      {
140008973          *(uint64_t*)((char*)arg1 + 8) = rax_5 + rax_3;
140008977          int64_t var_48_2 = 0x15;
140008987          char rdx_4 = 0;
14000898c          uint64_t rax_12 = *(uint64_t*)((char*)arg1 + 8) * 0x10;
14000898c          bool o_1 = /* bool o_1 = unimplemented  {imul rax, rax, 0x10} */;
14000898c          
140008990          if (o_1)
140008992              rdx_4 = 1;
140008992          
1400089a9          if (!(rdx_4 & 1))
1400089a9          {
1400089ba              int64_t var_48_3 = 0x17;
1400089ba              
1400089c7              if (rax_12 >= 0)
1400089c7              {
1400089e6                  int64_t var_18_1 = 0;
140008a0e                  *(uint64_t*)((char*)arg1 + 0x10) = reallocSharedImpl__system_u1766(
140008a0e                      *(uint64_t*)((char*)arg1 + 0x10), rax_12);
1400089c7              }
1400089c7              else
1400089df                  raiseRangeErrorI(rax_12, 0, 0x7fffffffffffffff);
1400089a9          }
1400089a9          else
1400089ab              raiseOverflow();
14000895f      }
14000895f      else
140008961          raiseOverflow();
140008961      
140008a1d      return popFrame();
1400088cf  }


140008a1e    int64_t* add__system_u3238(int64_t* arg1, int64_t arg2, int64_t arg3)

140008a1e  {
140008a39      void* const var_50 = &data_140021590;
140008a44      char const* const var_40 =
140008a44          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140008a48      int64_t var_48 = 0;
140008a50      int16_t var_38 = 0;
140008a5d      void* var_58;
140008a5d      nimFrame(&var_58);
140008a62      int64_t var_48_1 = 0x1c;
140008a62      
140008a7c      if (arg1[1] <= *(uint64_t*)arg1)
140008a7c      {
140008a7e          int64_t var_48_2 = 0x1d;
140008a8d          resize__system_u3246(arg1);
140008a7c      }
140008a7c      
140008a95      int64_t var_48_3 = 0x1e;
140008ac7      *(uint64_t*)((*(uint64_t*)arg1 << 4) + arg1[2]) = arg2;
140008ae4      *(uint64_t*)((*(uint64_t*)arg1 << 4) + arg1[2] + 8) = arg3;
140008ae8      int64_t var_48_4 = 0x1f;
140008af4      int64_t rax_17 = *(uint64_t*)arg1;
140008af7      char rdx_5 = 0;
140008af7      
140008b00      if (rax_17 + 1)
140008b02          rdx_5 = 1;
140008b02      
140008b19      if (!(rdx_5 & 1))
140008b2a          *(uint64_t*)arg1 = rax_17 + 1;
140008b19      else
140008b1b          raiseOverflow();
140008b1b      
140008b38      return popFrame();
140008a1e  }


140008b39    int64_t* init__system_u3382(int64_t* arg1, int64_t arg2)

140008b39  {
140008b50      char const* const var_40 = "init";
140008b5b      char const* const var_30 =
140008b5b          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140008b5f      int64_t var_38 = 0;
140008b67      int16_t var_28 = 0;
140008b74      void* var_48;
140008b74      nimFrame(&var_48);
140008b79      int64_t var_38_1 = 0x22;
140008b85      *(uint64_t*)arg1 = 0;
140008b8c      int64_t var_38_2 = 0x23;
140008b9c      arg1[1] = arg2;
140008ba0      int64_t var_38_3 = 0x25;
140008bb0      char rdx_1 = 0;
140008bb5      int64_t rax_4 = arg1[1] * 0x10;
140008bb5      bool o = /* bool o = unimplemented  {imul rax, rax, 0x10} */;
140008bb5      
140008bb9      if (o)
140008bbb          rdx_1 = 1;
140008bbb      
140008bd2      if (rdx_1 & 1)
140008bd4          raiseOverflow();
140008bd2      else if (rax_4 >= 0)
140008be2      {
140008beb          int64_t var_10_1 = 0;
140008c0b          arg1[2] = allocSharedImpl(rax_4);
140008be2      }
140008be2      else
140008be4          raiseRangeErrorNoArgs();
140008be4      
140008c1a      return popFrame();
140008b39  }


140008c1b    int64_t* trace__system_u2913(int64_t arg1, void* arg2, int64_t arg3)

140008c1b  {
140008c36      char const* const var_50 = "trace";
140008c41      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140008c45      int64_t var_48 = 0;
140008c4d      int16_t var_38 = 0;
140008c5a      void* var_58;
140008c5a      nimFrame(&var_58);
140008c64      char* var_10 = nimErrorFlag();
140008c68      int64_t var_48_1 = 0x4e;
140008c77      char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140008c77      
140008c86      if (*(uint64_t*)((char*)arg2 + 0x20))
140008c86      {
140008c88          int64_t var_48_2 = 0x4f;
140008c90          int64_t var_48_3 = 0x3d;
140008c9f          char const* const var_40_2 =
140008c9f              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\seqs_v2.nim";
140008ca3          int64_t var_18_1 = 0;
140008cc8          int64_t var_48_4 = 0x50;
140008cd7          char const* const var_40_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140008cf1          (*(uint64_t*)((char*)arg2 + 0x20))(pluspercent___system_u793(arg1, 0x10), arg3);
140008c86      }
140008c86      
140008d0e      return popFrame();
140008c1b  }


140008d0f    int64_t* pop__system_u3128(int64_t* arg1, int64_t* arg2)

140008d0f  {
140008d26      void* const var_50 = &data_1400215d6;
140008d31      char const* const var_40 =
140008d31          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140008d35      int64_t var_48 = 0;
140008d3d      int16_t var_38 = 0;
140008d4a      void* var_58;
140008d4a      nimFrame(&var_58);
140008d4f      int64_t var_48_1 = 0x34;
140008d5e      char const* const var_40_1 =
140008d5e          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140008d66      int64_t rax_1 = *(uint64_t*)arg2;
140008d69      char rdx = 0;
140008d69      
140008d72      if (rax_1 - 1)
140008d74          rdx = 1;
140008d74      
140008d8b      int64_t var_18;
140008d8b      int64_t var_10;
140008d8b      
140008d8b      if (!(rdx & 1))
140008d8b      {
140008da4          int64_t* rax_8 = ((rax_1 - 1) << 4) + arg2[2];
140008dae          var_18 = *(uint64_t*)rax_8;
140008db2          var_10 = rax_8[1];
140008db6          int64_t var_48_2 = 0x35;
140008dc2          int64_t rax_11 = *(uint64_t*)arg2;
140008dc5          char rdx_3 = 0;
140008dc5          
140008dce          if (rax_11 - 1)
140008dd0              rdx_3 = 1;
140008dd0          
140008de7          if (!(rdx_3 & 1))
140008df8              *(uint64_t*)arg2 = rax_11 - 1;
140008de7          else
140008de9              raiseOverflow();
140008d8b      }
140008d8b      else
140008d8d          raiseOverflow();
140008d8d      
140008dfb      popFrame();
140008e0c      *(uint64_t*)arg1 = var_18;
140008e0f      arg1[1] = var_10;
140008e1c      return arg1;
140008d0f  }


140008e1d    int64_t* markGray__system_u3149(int64_t* arg1, void* arg2, int64_t* arg3)

140008e1d  {
140008e3b      char const* const var_60 = "markGray";
140008e46      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140008e4a      int64_t var_58 = 0;
140008e52      int16_t var_48 = 0;
140008e5f      void* var_68;
140008e5f      nimFrame(&var_68);
140008e64      char* rax = nimErrorFlag();
140008e6d      int64_t var_58_1 = 0xbc;
140008e7c      char const* const var_50_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140008e7c      
140008e8e      if (((uint64_t)(uint32_t)*(uint64_t*)arg1 & 3) != 1)
140008e8e      {
140008e94          int64_t var_58_2 = 0x26;
140008eb2          *(uint64_t*)arg1 = (*(uint64_t*)arg1 & 0xfffffffffffffffc) | 1;
140008eb5          int64_t var_58_3 = 0xbe;
140008ec1          int64_t rax_10 = arg3[7];
140008ec5          char rdx_1 = 0;
140008ec5          
140008ece          if (rax_10 + 1)
140008ed0              rdx_1 = 1;
140008ed0          
140008ee7          if (!(rdx_1 & 1))
140008ee7          {
140008efb              arg3[7] = rax_10 + 1;
140008eff              int64_t var_58_4 = 0xc0;
140008f0e              int64_t rax_17 = *(uint64_t*)arg1 >> 4;
140008f12              char rdx_3 = 0;
140008f12              
140008f1b              if (rax_17 + 1)
140008f1d                  rdx_3 = 1;
140008f1d              
140008f34              if (!(rdx_3 & 1))
140008f34              {
140008f44                  int64_t rdx_4 = arg3[9];
140008f4c                  char rcx_3 = 0;
140008f4c                  
140008f54                  if (rax_17 + 1 + rdx_4)
140008f56                      rcx_3 = 1;
140008f56                  
140008f6d                  if (!(rcx_3 & 1))
140008f6d                  {
140008f81                      arg3[9] = rax_17 + 1 + rdx_4;
140008f85                      int64_t var_58_5 = 0xc2;
140008f9f                      trace__system_u2913(arg1, arg2, arg3);
140008f9f                      
140008fb0                      if (!(uint32_t)*(uint8_t*)rax)
140008fb0                      {
140008fb6                          int64_t var_58_6 = 0xc3;
140008fb6                          
140008fc8                          while (*(uint64_t*)arg3 > 0)
140008fc8                          {
140008fce                              int64_t var_58_7 = 0xc4;
140008fe4                              int64_t* var_98;
140008fe4                              pop__system_u3128(&var_98, arg3);
140008fff                              int64_t var_58_8 = 0xc5;
140009007                              int64_t var_58_9 = 0x3a;
140009016                              char const* const var_50_2 =
140009016                                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000901a                              int64_t var_28_1 = 0;
140009031                              int64_t* rax_37 =
140009031                                  minuspercent___system_u813(*(uint64_t*)var_98, 0x10);
140009042                              int64_t var_58_10 = 0xc6;
140009051                              char const* const var_50_3 =
140009051                                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009059                              int64_t rax_40 = *(uint64_t*)rax_37;
14000905c                              char rdx_9 = 0;
14000905c                              
140009065                              if (rax_40 - 0x10)
140009067                                  rdx_9 = 1;
140009067                              
140009081                              if (rdx_9 & 1)
140009081                              {
140009083                                  raiseOverflow();
140009088                                  break;
140009081                              }
140009081                              
140009098                              *(uint64_t*)rax_37 = rax_40 - 0x10;
14000909b                              int64_t var_58_11 = 0xc7;
1400090a7                              int64_t rax_46 = arg3[8];
1400090ab                              char rdx_11 = 0;
1400090ab                              
1400090b4                              if (rax_46 + 1)
1400090b6                                  rdx_11 = 1;
1400090b6                              
1400090d0                              if (rdx_11 & 1)
1400090d0                              {
1400090d2                                  raiseOverflow();
1400090d7                                  break;
1400090d0                              }
1400090d0                              
1400090e7                              arg3[8] = rax_46 + 1;
1400090eb                              int64_t var_58_12 = 0xce;
1400090eb                              
140009101                              if (((uint64_t)(uint32_t)*(uint64_t*)rax_37 & 3) != 1)
140009101                              {
140009107                                  int64_t var_58_13 = 0x26;
140009125                                  *(uint64_t*)rax_37 =
140009125                                      (*(uint64_t*)rax_37 & 0xfffffffffffffffc) | 1;
140009128                                  int64_t var_58_14 = 0xd0;
140009134                                  int64_t rax_60 = arg3[7];
140009138                                  char rdx_14 = 0;
140009138                                  
140009141                                  if (rax_60 + 1)
140009143                                      rdx_14 = 1;
140009143                                  
14000915d                                  if (rdx_14 & 1)
14000915d                                  {
14000915f                                      raiseOverflow();
140009164                                      break;
14000915d                                  }
14000915d                                  
140009174                                  arg3[7] = rax_60 + 1;
140009178                                  int64_t var_58_15 = 0xd2;
140009187                                  int64_t rax_67 = *(uint64_t*)rax_37 >> 4;
14000918b                                  char rdx_16 = 0;
14000918b                                  
140009194                                  if (rax_67 + 2)
140009196                                      rdx_16 = 1;
140009196                                  
1400091b0                                  if (rdx_16 & 1)
1400091b0                                  {
1400091b2                                      raiseOverflow();
1400091b7                                      break;
1400091b0                                  }
1400091b0                                  
1400091bd                                  int64_t rdx_17 = arg3[9];
1400091c8                                  char rcx_12 = 0;
1400091c8                                  
1400091d0                                  if (rax_67 + 2 + rdx_17)
1400091d2                                      rcx_12 = 1;
1400091d2                                  
1400091ec                                  if (rcx_12 & 1)
1400091ec                                  {
1400091ee                                      raiseOverflow();
1400091f3                                      break;
1400091ec                                  }
1400091ec                                  
140009200                                  arg3[9] = rax_67 + 2 + rdx_17;
140009204                                  int64_t var_58_16 = 0xd3;
14000921e                                  void* var_90;
14000921e                                  trace__system_u2913(rax_37, var_90, arg3);
14000921e                                  
14000922f                                  if ((uint32_t)*(uint8_t*)rax)
14000922f                                      break;
140009101                              }
140008fc8                          }
140008fb0                      }
140008f6d                  }
140008f6d                  else
140008f6f                      raiseOverflow();
140008f34              }
140008f34              else
140008f36                  raiseOverflow();
140008ee7          }
140008ee7          else
140008ee9              raiseOverflow();
140008e8e      }
140008e8e      
140009255      return popFrame();
140008e1d  }


140009256    int64_t* scanBlack__system_u3120(int64_t* arg1, void* arg2, int64_t* arg3)

140009256  {
140009274      char const* const var_60 = "scanBlack";
14000927f      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009283      int64_t var_58 = 0;
14000928b      int16_t var_48 = 0;
140009298      void* var_68;
140009298      nimFrame(&var_68);
14000929d      char* rax = nimErrorFlag();
1400092a6      int64_t var_58_1 = 0x24;
1400092c0      *(uint64_t*)arg1 &= 0xfffffffffffffffc;
1400092c3      int64_t var_58_2 = 0xa6;
1400092cf      int64_t i = *(uint64_t*)arg3;
1400092d6      int64_t var_58_3 = 0xa7;
1400092f0      trace__system_u2913(arg1, arg2, arg3);
1400092f0      
140009301      if (!(uint32_t)*(uint8_t*)rax)
140009301      {
140009307          int64_t var_58_4 = 0xa9;
140009307          
14000931a          while (i < *(uint64_t*)arg3)
14000931a          {
140009320              int64_t var_58_5 = 0xaa;
140009333              int64_t* var_78;
140009333              pop__system_u3128(&var_78, arg3);
140009348              int64_t var_58_6 = 0xab;
140009350              int64_t var_58_7 = 0x3a;
14000935f              char const* const var_50_1 =
14000935f                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
140009363              int64_t var_30_1 = 0;
14000937a              int64_t* rax_16 = minuspercent___system_u813(*(uint64_t*)var_78, 0x10);
14000938b              int64_t var_58_8 = 0xac;
14000939a              char const* const var_50_2 =
14000939a                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
1400093a2              int64_t rax_19 = *(uint64_t*)rax_16;
1400093a5              char rdx_3 = 0;
1400093a5              
1400093ae              if (rax_19 + 0x10)
1400093b0                  rdx_3 = 1;
1400093b0              
1400093c7              if (rdx_3 & 1)
1400093c7              {
1400093c9                  raiseOverflow();
1400093ce                  break;
1400093c7              }
1400093c7              
1400093d8              *(uint64_t*)rax_16 = rax_19 + 0x10;
1400093db              int64_t var_58_9 = 0xad;
1400093db              
1400093f0              if ((uint64_t)(uint32_t)*(uint64_t*)rax_16 & 3)
1400093f0              {
1400093f2                  int64_t var_58_10 = 0x24;
14000940c                  *(uint64_t*)rax_16 &= 0xfffffffffffffffc;
14000940f                  int64_t var_58_11 = 0xaf;
140009429                  void* var_70;
140009429                  trace__system_u2913(rax_16, var_70, arg3);
140009429                  
14000943a                  if ((uint32_t)*(uint8_t*)rax)
14000943a                      break;
1400093f0              }
14000931a          }
140009301      }
140009301      
140009459      return popFrame();
140009256  }


14000945a    int64_t* scan__system_u3205(int64_t* arg1, void* arg2, int64_t* arg3)

14000945a  {
140009478      char const* const var_60 = "scan";
140009483      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009487      int64_t var_58 = 0;
14000948f      int16_t var_48 = 0;
14000949c      void* var_68;
14000949c      nimFrame(&var_68);
1400094a1      char* rax = nimErrorFlag();
1400094aa      int64_t var_58_1 = 0xdf;
1400094aa      
1400094c0      if (((uint64_t)(uint32_t)*(uint64_t*)arg1 & 3) == 1)
1400094c0      {
1400094c6          int64_t var_58_2 = 0xe0;
1400094c6          
1400094dc          if (*(uint64_t*)arg1 >> 4 < 0)
1400094dc          {
14000950f              int64_t var_58_4 = 0x26;
14000952d              *(uint64_t*)arg1 = (*(uint64_t*)arg1 & 0xfffffffffffffffc) | 2;
140009530              int64_t var_58_5 = 0xf8;
14000954a              trace__system_u2913(arg1, arg2, arg3);
14000954a              
14000955b              if (!(uint32_t)*(uint8_t*)rax)
14000955b              {
140009561                  int64_t var_58_6 = 0xf9;
140009561                  
140009573                  while (*(uint64_t*)arg3 > 0)
140009573                  {
140009579                      int64_t var_58_7 = 0xfa;
14000958c                      int64_t* var_78;
14000958c                      pop__system_u3128(&var_78, arg3);
1400095a1                      int64_t var_58_8 = 0xfb;
1400095a9                      int64_t var_58_9 = 0x3a;
1400095b8                      char const* const var_50_1 =
1400095b8                          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
1400095bc                      int64_t var_28_1 = 0;
1400095d3                      int64_t* rax_23 =
1400095d3                          minuspercent___system_u813(*(uint64_t*)var_78, 0x10);
1400095e4                      int64_t var_58_10 = 0xfc;
1400095f3                      char const* const var_50_2 =
1400095f3                          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
1400095f3                      
140009605                      if (((uint64_t)(uint32_t)*(uint64_t*)rax_23 & 3) == 1)
140009605                      {
14000960b                          int64_t var_58_11 = 0xfd;
140009621                          void* var_70;
140009621                          
140009621                          if (*(uint64_t*)rax_23 >> 4 < 0)
140009621                          {
140009653                              int64_t var_58_13 = 0x26;
140009671                              *(uint64_t*)rax_23 =
140009671                                  (*(uint64_t*)rax_23 & 0xfffffffffffffffc) | 2;
140009674                              int64_t var_58_14 = 0x111;
14000968e                              trace__system_u2913(rax_23, var_70, arg3);
14000968e                              
14000969f                              if ((uint32_t)*(uint8_t*)rax)
14000969f                                  break;
140009621                          }
140009621                          else
140009621                          {
140009623                              int64_t var_58_12 = 0xfe;
14000963d                              scanBlack__system_u3120(rax_23, var_70, arg3);
14000963d                              
14000964e                              if ((uint32_t)*(uint8_t*)rax)
14000964e                                  break;
140009621                          }
140009605                      }
140009573                  }
14000955b              }
1400094dc          }
1400094dc          else
1400094dc          {
1400094de              int64_t var_58_3 = 0xe1;
1400094f8              scanBlack__system_u3120(arg1, arg2, arg3);
1400094dc          }
1400094c0      }
1400094c0      
1400096c7      return popFrame();
14000945a  }


1400096c8    int64_t* collectColor__system_u3230(int64_t* arg1, void* arg2, int64_t arg3, int64_t* arg4)

1400096c8  {
1400096ea      char const* const var_60 = "collectColor";
1400096f5      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
1400096f9      int64_t var_58 = 0;
140009701      int16_t var_48 = 0;
14000970e      void* var_68;
14000970e      nimFrame(&var_68);
140009713      char* rax = nimErrorFlag();
14000971c      int64_t var_58_1 = 0x123;
140009724      char var_9 = 0;
140009736      uint64_t rax_3;
140009736      (uint8_t)rax_3 = arg3 == ((uint64_t)(uint32_t)*(uint64_t*)arg1 & 3);
140009739      char var_9_1 = (uint8_t)rax_3;
140009739      
140009745      if (var_9_1 == 1)
140009745      {
140009752          int64_t rax_7;
140009752          (uint8_t)rax_7 = !arg1[1];
140009755          var_9_1 = (uint8_t)rax_7;
140009745      }
140009745      
140009764      if (var_9_1 == 1)
140009764      {
14000976a          int64_t var_58_2 = 0x24;
140009784          *(uint64_t*)arg1 &= 0xfffffffffffffffc;
140009787          int64_t var_58_3 = 0x127;
1400097a5          add__system_u3238(&arg4[3], arg1, arg2);
1400097aa          int64_t var_58_4 = 0x128;
1400097c4          trace__system_u2913(arg1, arg2, arg4);
1400097c4          
1400097d5          if (!(uint32_t)*(uint8_t*)rax)
1400097d5          {
1400097db              int64_t var_58_5 = 0x129;
1400097db              
1400097ed              while (*(uint64_t*)arg4 > 0)
1400097ed              {
1400097f3                  int64_t var_58_6 = 0x12a;
140009806                  int64_t* var_78;
140009806                  pop__system_u3128(&var_78, arg4);
14000980b                  int64_t* rax_22 = var_78;
14000981b                  int64_t var_58_7 = 0x12b;
140009823                  int64_t var_58_8 = 0x3a;
140009832                  char const* const var_50_1 =
140009832                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
140009836                  int64_t var_30_1 = 0;
14000984d                  int64_t* rax_26 = minuspercent___system_u813(*(uint64_t*)rax_22, 0x10);
14000985e                  int64_t var_58_9 = 0x12c;
14000986d                  char const* const var_50_2 =
14000986d                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009875                  *(uint64_t*)rax_22 = 0;
14000987c                  int64_t var_58_10 = 0x12d;
140009884                  char var_a_1 = 0;
140009896                  uint64_t rax_31;
140009896                  (uint8_t)rax_31 = arg3 == ((uint64_t)(uint32_t)*(uint64_t*)rax_26 & 3);
140009899                  char var_a_2 = (uint8_t)rax_31;
140009899                  
1400098a5                  if (var_a_2 == 1)
1400098a5                  {
1400098b2                      int64_t rax_35;
1400098b2                      (uint8_t)rax_35 = !rax_26[1];
1400098b5                      var_a_2 = (uint8_t)rax_35;
1400098a5                  }
1400098a5                  
1400098c4                  if (var_a_2 == 1)
1400098c4                  {
1400098c6                      int64_t var_58_11 = 0x12e;
1400098e4                      void* var_70;
1400098e4                      add__system_u3238(&arg4[3], rax_26, var_70);
1400098e9                      int64_t var_58_12 = 0x24;
140009903                      *(uint64_t*)rax_26 &= 0xfffffffffffffffc;
140009906                      int64_t var_58_13 = 0x130;
140009920                      trace__system_u2913(rax_26, var_70, arg4);
140009920                      
140009931                      if ((uint32_t)*(uint8_t*)rax)
140009931                          break;
1400098c4                  }
1400097ed              }
1400097d5          }
140009764      }
140009764      
140009953      return popFrame();
1400096c8  }


140009954    int64_t* deallocImpl__system_u1751(int64_t* arg1)

140009954  {
140009984      return dealloc__system_u7209(__emutls_get_address(&_.data), arg1);
140009954  }


140009985    int64_t* deallocSharedImpl__system_u1764(int64_t* arg1)

140009985  {
1400099a3      return deallocImpl__system_u1751(arg1);
140009985  }


1400099a4    int64_t* deallocShared(int64_t arg1)

1400099a4  {
1400099c2      return deallocSharedImpl__system_u1764(arg1);
1400099a4  }


1400099c3    int64_t* alignedDealloc(int64_t arg1, int64_t arg2)

1400099c3  {
1400099d8      if (arg2 <= 0x10)
1400099e1          return deallocShared(arg1);
1400099e1      
1400099e9      int64_t var_10_1 = 0;
140009a11      int64_t var_20_1 = 0;
140009a34      return deallocShared(minuspercent___system_u813(arg1, 
140009a34          (uint64_t)*(uint16_t*)minuspercent___system_u813(arg1, 2)));
1400099c3  }


140009a41    int64_t* nimRawDispose(int64_t arg1, int64_t arg2)

140009a41  {
140009a58      char const* const var_40 = "nimRawDispose";
140009a63      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
140009a67      int64_t var_38 = 0;
140009a6f      int16_t var_28 = 0;
140009a7c      void* var_48;
140009a7c      nimFrame(&var_48);
140009a81      int64_t var_38_1 = 0xbe;
140009a90      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
140009aa9      int64_t var_38_2 = 0xbf;
140009ab1      int64_t var_38_3 = 0x40;
140009ac0      char const* const var_30_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\seqs_v2.nim";
140009ac4      int64_t var_18 = 0;
140009ae0      int64_t var_38_4 = 0xbf;
140009aef      char const* const var_30_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
140009afe      alignedDealloc(minuspercent___system_u813(arg1, align__system_u1634(0x10, arg2)), 
140009afe          arg2);
140009b0e      return popFrame();
140009a41  }


140009b0f    int64_t* free__system_u2961(int64_t arg1, int64_t* arg2)

140009b0f  {
140009b26      char const* const var_50 = "free";
140009b31      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009b35      int64_t var_48 = 0;
140009b3d      int16_t var_38 = 0;
140009b4a      void* var_58;
140009b4a      nimFrame(&var_58);
140009b4f      char* rax = nimErrorFlag();
140009b58      int64_t var_48_1 = 0x60;
140009b67      char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009b6b      int64_t var_48_2 = 0x3d;
140009b7a      char const* const var_40_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\seqs_v2.nim";
140009b7e      int64_t var_18 = 0;
140009b92      int64_t rax_2 = pluspercent___system_u793(arg1, 0x10);
140009ba3      int64_t var_48_3 = 0x64;
140009bb2      char const* const var_40_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009bb2      
140009bc0      if (*(uint64_t*)arg2)
140009bc0      {
140009bc2          int64_t var_48_4 = 0x65;
140009bdb          (*(uint64_t*)arg2)(rax_2);
140009bc0      }
140009bc0      
140009be9      if (!*(uint64_t*)arg2 || !(uint32_t)*(uint8_t*)rax)
140009be9      {
140009bee          int64_t var_48_5 = 0x73;
140009c09          nimRawDispose(rax_2, (int64_t)arg2[2]);
140009be9      }
140009be9      
140009c1c      return popFrame();
140009b0f  }


140009c1d    int64_t* deinit__system_u3369(int64_t* arg1)

140009c1d  {
140009c30      char const* const var_30 = "deinit";
140009c3b      char const* const var_20 =
140009c3b          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140009c3f      int64_t var_28 = 0;
140009c47      int16_t var_18 = 0;
140009c54      void* var_38;
140009c54      nimFrame(&var_38);
140009c59      int64_t var_28_1 = 0x2a;
140009c68      char const* const var_20_1 =
140009c68          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
140009c68      
140009c77      if (arg1[2])
140009c77      {
140009c79          int64_t var_28_2 = 0x2c;
140009c8c          deallocShared(arg1[2]);
140009c91          int64_t var_28_3 = 0x2f;
140009c9d          arg1[2] = 0;
140009c77      }
140009c77      
140009ca8      int64_t var_28_4 = 0x30;
140009cb4      *(uint64_t*)arg1 = 0;
140009cbb      int64_t var_28_5 = 0x31;
140009cc7      arg1[1] = 0;
140009cda      return popFrame();
140009c1d  }


140009cdb    int64_t* collectCyclesBacon__system_u3302(int64_t* arg1, int64_t arg2)

140009cdb  {
140009cf5      char const* const var_b0 = "collectCyclesBacon";
140009d03      char const* const var_a0 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009d0a      int64_t var_a8 = 0;
140009d15      int16_t var_98 = 0;
140009d28      void* var_b8;
140009d28      nimFrame(&var_b8);
140009d2d      char* rax = nimErrorFlag();
140009d36      int64_t var_a8_1 = 0x148;
140009d48      char const* const var_a0_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009d5e      int64_t rax_2 = *(uint64_t*)__emutls_get_address(&__emutls_v.roots__system_u3091);
140009d61      char rdx = 0;
140009d61      
140009d6a      if (rax_2 - 1)
140009d6c          rdx = 1;
140009d6c      
140009d83      if (!(rdx & 1))
140009d83      {
140009d97          int64_t var_48_1 = 0;
140009d9f          int64_t var_a8_2 = 0x21;
140009db1          char const* const var_a0_2 =
140009db1              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
140009dbc          int64_t var_18_1 = rax_2 - 1;
140009dc0          int64_t var_a8_3 = 0x22;
140009dc0          
140009dd3          while (true)
140009dd3          {
140009dd3              if (arg2 > var_18_1)
140009dd3              {
140009eb9                  int64_t var_a8_7 = 0x150;
140009ecb                  char const* const var_a0_5 =
140009ecb                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009ed2                  int64_t var_10_1 = 2;
140009eda                  int64_t var_a8_8 = 0x151;
140009eda                  
140009ef8                  if (arg1[9] != arg1[8])
140009ef8                  {
140009f26                      int64_t var_50_1 = 0;
140009f2e                      int64_t var_a8_11 = 0x21;
140009f40                      char const* const var_a0_6 =
140009f40                          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
140009f4b                      int64_t i = rax_2 - 1;
140009f4f                      int64_t var_a8_12 = 0x22;
140009f4f                      
140009f62                      for (; arg2 <= i; i -= 1)
140009f62                      {
140009f68                          int64_t var_a8_13 = 0x157;
140009f7a                          char const* const var_a0_7 =
140009f7a                              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009f89                          int64_t var_a8_14 = 0x158;
140009f9e                          void* rax_30 =
140009f9e                              __emutls_get_address(&__emutls_v.roots__system_u3091);
140009fd2                          scan__system_u3205(
140009fd2                              *(uint64_t*)((i << 4) + *(uint64_t*)((char*)rax_30 + 0x10)), 
140009fd2                              *(uint64_t*)((i << 4) + *(uint64_t*)((char*)rax_30 + 0x10)
140009fd2                                  + 8), 
140009fd2                              arg1);
140009fd2                          
140009fe3                          if ((uint32_t)*(uint8_t*)rax)
14000a3f7                              return popFrame();
14000a3f7                          
140009fe9                          int64_t var_a8_15 = 0x27;
140009ffb                          char const* const var_a0_8 =
140009ffb                              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
14000a002                          char rdx_11 = 0;
14000a002                          
14000a00f                          if (i - 1)
14000a011                              rdx_11 = 1;
14000a011                          
14000a02b                          if (rdx_11 & 1)
14000a02b                          {
14000a02d                              raiseOverflow();
14000a3f7                              return popFrame();
14000a02b                          }
140009f62                      }
140009ef8                  }
140009ef8                  else
140009ef8                  {
140009efa                      int64_t var_a8_9 = 0x153;
140009f05                      var_10_1 = 1;
140009f0d                      int64_t var_a8_10 = 0x155;
140009f1c                      arg1[0xa] = 1;
140009ef8                  }
140009ef8                  
14000a048                  int64_t var_a8_16 = 0x15a;
14000a05a                  char const* const var_a0_9 =
14000a05a                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000a071                  init__system_u3330(&arg1[3], 0x400);
14000a076                  int64_t var_58_1 = 0;
14000a07e                  int64_t var_a8_17 = 0x80;
14000a090                  char const* const var_a0_10 =
14000a090                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
14000a097                  int64_t var_28_1 = 0;
14000a09f                  int64_t var_a8_18 = 0x81;
14000a09f                  
14000a0b9                  while (true)
14000a0b9                  {
14000a0c0                      if (var_28_1 >= *
14000a0c0                          (uint64_t*)__emutls_get_address(&__emutls_v.roots__system_u3091))
14000a0c0                      {
14000a1d7                          int64_t var_a8_24 = 0x165;
14000a1e9                          char const* const var_a0_13 =
14000a1e9                              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000a1fa                          int64_t* rax_61 = __emutls_get_address(
14000a1fa                              &__emutls_v.rootsThreshold__system_u3301);
14000a1ff                          int64_t rdx_20 = *(uint64_t*)rax_61;
14000a206                          int64_t var_a8_25 = 0x166;
14000a21b                          *(uint64_t*)rax_61 = 0x7fffffffffffffff;
14000a21e                          int64_t var_a8_26 = 0x167;
14000a238                          *(uint64_t*)__emutls_get_address(
14000a238                              &__emutls_v.roots__system_u3091) = 0;
14000a23f                          int64_t var_70_1 = 0;
14000a247                          int64_t var_a8_27 = 0x80;
14000a259                          char const* const var_a0_14 =
14000a259                              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
14000a260                          int64_t var_30_1 = 0;
14000a268                          int64_t var_a8_28 = 0x81;
14000a268                          
14000a27f                          while (true)
14000a27f                          {
14000a27f                              if (var_30_1 >= arg1[3])
14000a27f                              {
14000a345                                  int64_t var_a8_32 = 0x16f;
14000a357                                  char const* const var_a0_17 =
14000a357                                      "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000a371                                  *(uint64_t*)__emutls_get_address(
14000a371                                      &__emutls_v.rootsThreshold__system_u3301) = rdx_20;
14000a374                                  int64_t var_a8_33 = 0x171;
14000a383                                  int64_t rdx_25 = arg1[6];
14000a38b                                  int64_t rax_83 = arg1[3];
14000a38f                                  char rcx_20 = 0;
14000a38f                                  
14000a397                                  if (rax_83 + rdx_25)
14000a399                                      rcx_20 = 1;
14000a399                                  
14000a3b0                                  if (!(rcx_20 & 1))
14000a3b0                                  {
14000a3c1                                      arg1[6] = rax_83 + rdx_25;
14000a3c5                                      int64_t var_a8_34 = 0x172;
14000a3db                                      deinit__system_u3369(&arg1[3]);
14000a3b0                                  }
14000a3b0                                  else
14000a3b2                                      raiseOverflow();
14000a3b2                                  
14000a3b0                                  break;
14000a27f                              }
14000a27f                              
14000a285                              int64_t var_a8_29 = 0x169;
14000a297                              char const* const var_a0_15 =
14000a297                                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000a2a6                              int64_t var_a8_30 = 0x16c;
14000a2e1                              free__system_u2961(*(uint64_t*)((var_30_1 << 4) + arg1[5]), 
14000a2e1                                  *(uint64_t*)((var_30_1 << 4) + arg1[5] + 8));
14000a2e6                              int64_t var_a8_31 = 0x83;
14000a2f8                              char const* const var_a0_16 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
14000a2ff                              char rdx_23 = 0;
14000a2ff                              
14000a30c                              if (var_30_1 + 1)
14000a30e                                  rdx_23 = 1;
14000a30e                              
14000a328                              if (rdx_23 & 1)
14000a328                              {
14000a32a                                  raiseOverflow();
14000a32f                                  break;
14000a328                              }
14000a328                              
14000a33b                              var_30_1 += 1;
14000a27f                          }
14000a27f                          
14000a27f                          break;
14000a0c0                      }
14000a0c0                      
14000a0c6                      int64_t var_a8_19 = 0x15b;
14000a0d8                      char const* const var_a0_11 =
14000a0d8                          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000a0e7                      int64_t var_a8_20 = 0x15c;
14000a0fc                      void* rax_48 = __emutls_get_address(&__emutls_v.roots__system_u3091);
14000a110                      int64_t* rdx_15 = *(uint64_t*)((var_28_1 << 4)
14000a110                          + *(uint64_t*)((char*)rax_48 + 0x10));
14000a117                      int64_t var_a8_21 = 0x15d;
14000a126                      rdx_15[1] = 0;
14000a12e                      int64_t var_a8_22 = 0x15e;
14000a161                      collectColor__system_u3230(rdx_15, 
14000a161                          *(uint64_t*)((var_28_1 << 4) + *(uint64_t*)((char*)rax_48 + 0x10)
14000a161                              + 8), 
14000a161                          var_10_1, arg1);
14000a161                      
14000a172                      if ((uint32_t)*(uint8_t*)rax)
14000a172                          break;
14000a172                      
14000a178                      int64_t var_a8_23 = 0x83;
14000a18a                      char const* const var_a0_12 =
14000a18a                          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
14000a191                      char rdx_19 = 0;
14000a191                      
14000a19e                      if (var_28_1 + 1)
14000a1a0                          rdx_19 = 1;
14000a1a0                      
14000a1ba                      if (rdx_19 & 1)
14000a1ba                      {
14000a1bc                          raiseOverflow();
14000a1c1                          break;
14000a1ba                      }
14000a1ba                      
14000a1cd                      var_28_1 += 1;
14000a0b9                  }
14000a0b9                  
14000a09f                  break;
140009dd3              }
140009dd3              
140009dd9              int64_t var_a8_4 = 0x14d;
140009deb              char const* const var_a0_3 =
140009deb                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
140009dfa              int64_t var_a8_5 = 0x14e;
140009e0f              void* rax_10 = __emutls_get_address(&__emutls_v.roots__system_u3091);
140009e43              markGray__system_u3149(
140009e43                  *(uint64_t*)((var_18_1 << 4) + *(uint64_t*)((char*)rax_10 + 0x10)), 
140009e43                  *(uint64_t*)((var_18_1 << 4) + *(uint64_t*)((char*)rax_10 + 0x10) + 8), 
140009e43                  arg1);
140009e43              
140009e54              if ((uint32_t)*(uint8_t*)rax)
140009e54                  break;
140009e54              
140009e5a              int64_t var_a8_6 = 0x27;
140009e6c              char const* const var_a0_4 =
140009e6c                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
140009e73              char rdx_5 = 0;
140009e73              
140009e80              if (var_18_1 - 1)
140009e82                  rdx_5 = 1;
140009e82              
140009e9c              if (rdx_5 & 1)
140009e9c              {
140009e9e                  raiseOverflow();
140009ea3                  break;
140009e9c              }
140009e9c              
140009eaf              var_18_1 -= 1;
140009dd3          }
140009d83      }
140009d83      else
140009d85          raiseOverflow();
140009d85      
14000a3f7      return popFrame();
140009cdb  }


14000a3f8    int64_t* deinit__system_u3394(int64_t* arg1)

14000a3f8  {
14000a40b      char const* const var_30 = "deinit";
14000a416      char const* const var_20 =
14000a416          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
14000a41a      int64_t var_28 = 0;
14000a422      int16_t var_18 = 0;
14000a42f      void* var_38;
14000a42f      nimFrame(&var_38);
14000a434      int64_t var_28_1 = 0x2a;
14000a443      char const* const var_20_1 =
14000a443          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
14000a443      
14000a452      if (arg1[2])
14000a452      {
14000a454          int64_t var_28_2 = 0x2c;
14000a467          deallocShared(arg1[2]);
14000a46c          int64_t var_28_3 = 0x2f;
14000a478          arg1[2] = 0;
14000a452      }
14000a452      
14000a483      int64_t var_28_4 = 0x30;
14000a48f      *(uint64_t*)arg1 = 0;
14000a496      int64_t var_28_5 = 0x31;
14000a4a2      arg1[1] = 0;
14000a4b5      return popFrame();
14000a3f8  }


14000a4b6    int64_t* collectCycles__system_u3430()

14000a4b6  {
14000a4ce      char const* const var_b0 = "collectCycles";
14000a4dc      char const* const var_a0 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000a4e3      int64_t var_a8 = 0;
14000a4ee      int16_t var_98 = 0;
14000a4fe      void* var_b8;
14000a4fe      nimFrame(&var_b8);
14000a503      char* rax = nimErrorFlag();
14000a518      void var_88;
14000a518      nimZeroMem(&var_88, 0x58);
14000a51d      int64_t var_a8_1 = 0x18d;
14000a52f      char const* const var_a0_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000a542      init__system_u3382(&var_88, 0x400);
14000a547      int64_t var_a8_2 = 0x197;
14000a55e      collectCyclesBacon__system_u3302(&var_88, 0);
14000a55e      
14000a56f      if (!(uint32_t)*(uint8_t*)rax)
14000a56f      {
14000a575          int64_t var_a8_3 = 0x199;
14000a587          deinit__system_u3394(&var_88);
14000a58c          int64_t var_a8_4 = 0x19a;
14000a58c          
14000a5ac          if (!*(uint64_t*)__emutls_get_address(&__emutls_v.roots__system_u3091))
14000a5ac          {
14000a5ae              int64_t var_a8_5 = 0x19b;
14000a5cb              deinit__system_u3369(__emutls_get_address(&__emutls_v.roots__system_u3091));
14000a5ac          }
14000a5ac          
14000a5d3          int64_t var_a8_6 = 0x1a2;
14000a5e7          char var_38;
14000a5e7          
14000a5e7          if (var_38 != 1)
14000a5e7          {
14000a5ee              int64_t var_a8_7 = 0x1a4;
14000a5fd              char rdx_1 = 0;
14000a602              bool o_1 = /* bool o_1 = unimplemented  {imul rax, rax, 0x2} */;
14000a602              
14000a606              if (o_1)
14000a608                  rdx_1 = 1;
14000a608              
14000a622              int64_t var_58;
14000a622              int64_t var_50;
14000a622              
14000a622              if (rdx_1 & 1)
14000a624                  raiseOverflow();
14000a622              else if (var_50 > var_58 * 2)
14000a63c              {
14000a6de                  int64_t var_a8_9 = 0x1aa;
14000a6de                  
14000a708                  if (*(uint64_t*)__emutls_get_address(
14000a708                      &__emutls_v.rootsThreshold__system_u3301) <= 0x1ffffffffffffffe)
14000a708                  {
14000a70e                      int64_t var_28_1 = 0;
14000a716                      int64_t var_30_1 = 0;
14000a71e                      int64_t var_a8_10 = 0x1ab;
14000a71e                      
14000a73e                      if (*(uint64_t*)__emutls_get_address(
14000a73e                          &__emutls_v.rootsThreshold__system_u3301) > 0)
14000a73e                      {
14000a76b                          int64_t* rax_28 = __emutls_get_address(
14000a76b                              &__emutls_v.rootsThreshold__system_u3301);
14000a77b                          *(uint64_t*)rax_28 = *(uint64_t*)rax_28;
14000a73e                      }
14000a73e                      else
14000a75b                          *(uint64_t*)__emutls_get_address(
14000a75b                              &__emutls_v.rootsThreshold__system_u3301) = 0x80;
14000a75b                      
14000a77e                      int64_t var_a8_11 = 0x1ac;
14000a793                      int64_t* rax_29 =
14000a793                          __emutls_get_address(&__emutls_v.rootsThreshold__system_u3301);
14000a798                      int64_t rdx_10 = *(uint64_t*)rax_29;
14000a7a5                      int64_t rdx_12 = (rdx_10 + (rdx_10 >> 0x3f)) >> 1;
14000a7ab                      int64_t rax_30 = *(uint64_t*)rax_29;
14000a7ae                      char rdx_13 = 0;
14000a7ae                      
14000a7b6                      if (rax_30 + rdx_12)
14000a7b8                          rdx_13 = 1;
14000a7b8                      
14000a7d2                      if (!(rdx_13 & 1))
14000a7f1                          *(uint64_t*)__emutls_get_address(
14000a7f1                              &__emutls_v.rootsThreshold__system_u3301) = rax_30 + rdx_12;
14000a7d2                      else
14000a7d4                          raiseOverflow();
14000a708                  }
14000a63c              }
14000a63c              else
14000a63c              {
14000a642                  int64_t var_a8_8 = 0x1a6;
14000a67f                  char rdx_5 = 0;
14000a684                  int64_t rax_19 = *(uint64_t*)__emutls_get_address(
14000a684                      &__emutls_v.rootsThreshold__system_u3301) / 3 * 2;
14000a684                  bool o_2 = /* bool o_2 = unimplemented  {imul rax, rax, 0x2} */;
14000a684                  
14000a688                  if (o_2)
14000a68a                      rdx_5 = 1;
14000a68a                  
14000a6a4                  if (!(rdx_5 & 1))
14000a6a4                  {
14000a6bf                      int64_t rbx_1 = 0x10;
14000a6bf                      
14000a6c2                      if (rax_19 >= 0x10)
14000a6c2                          rbx_1 = rax_19;
14000a6c2                      
14000a6d5                      *(uint64_t*)__emutls_get_address(
14000a6d5                          &__emutls_v.rootsThreshold__system_u3301) = rbx_1;
14000a6a4                  }
14000a6a4                  else
14000a6a6                      raiseOverflow();
14000a63c              }
14000a5e7          }
14000a56f      }
14000a56f      
14000a80c      return popFrame();
14000a4b6  }


14000a80d    int64_t* registerCycle__system_u3455(void* arg1, int64_t arg2)

14000a80d  {
14000a827      char const* const var_50 = "registerCycle";
14000a832      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000a836      int64_t var_48 = 0;
14000a83e      int16_t var_38 = 0;
14000a84b      void* var_58;
14000a84b      nimFrame(&var_58);
14000a855      char* var_20 = nimErrorFlag();
14000a859      int64_t var_48_1 = 0x1bc;
14000a870      int64_t rax_2 = *(uint64_t*)__emutls_get_address(&__emutls_v.roots__system_u3091);
14000a873      char rdx = 0;
14000a873      
14000a87c      if (rax_2 + 1)
14000a87e          rdx = 1;
14000a87e      
14000a895      if (!(rdx & 1))
14000a895      {
14000a8a9          *(uint64_t*)((char*)arg1 + 8) = rax_2 + 1;
14000a8ad          int64_t var_48_2 = 0x1bd;
14000a8ad          
14000a8cb          if (!*(uint64_t*)(__emutls_get_address(&__emutls_v.roots__system_u3091) + 0x10))
14000a8e4              init__system_u3330(__emutls_get_address(&__emutls_v.roots__system_u3091), 
14000a8e4                  0x400);
14000a8e4          
14000a8ec          int64_t var_48_3 = 0x1be;
14000a8fe          int64_t* rax_10 = __emutls_get_address(&__emutls_v.roots__system_u3091);
14000a917          add__system_u3238(rax_10, arg1, arg2);
14000a91c          int64_t var_48_4 = 0x1c0;
14000a924          int64_t rax_12 = *(uint64_t*)rax_10;
14000a927          char rdx_4 = 0;
14000a927          
14000a932          if (rax_12 - 0x80)
14000a934              rdx_4 = 1;
14000a934          
14000a94b          if (!(rdx_4 & 1))
14000a94b          {
14000a96d              if (*
14000a96d                  (uint64_t*)__emutls_get_address(&__emutls_v.rootsThreshold__system_u3301)
14000a96d                  <= rax_12 - 0x80)
14000a96d              {
14000a96f                  int64_t var_48_5 = 0x1c1;
14000a977                  collectCycles__system_u3430();
14000a96d              }
14000a94b          }
14000a94b          else
14000a94d              raiseOverflow();
14000a895      }
14000a895      else
14000a897          raiseOverflow();
14000a897      
14000a997      return popFrame();
14000a80d  }


14000a998    int64_t* rememberCycle__system_u3495(char arg1, int64_t* arg2, void* arg3)

14000a998  {
14000a9b4      char const* const var_40 = "rememberCycle";
14000a9bf      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000a9c3      int64_t var_38 = 0;
14000a9cb      int16_t var_28 = 0;
14000a9d8      void* var_48;
14000a9d8      nimFrame(&var_48);
14000a9e2      char* var_18 = nimErrorFlag();
14000a9e6      int64_t var_38_1 = 0x1f5;
14000a9e6      
14000a9f7      if (arg1 != 1)
14000a9f7      {
14000aa2e          int64_t var_38_4 = 0x1fb;
14000aa36          char var_9_1 = 0;
14000aa45          int64_t rax_8;
14000aa45          (uint8_t)rax_8 = !arg2[1];
14000aa48          char var_9_2 = (uint8_t)rax_8;
14000aa48          
14000aa54          if (var_9_2 == 1)
14000aa54          {
14000aa56              int64_t var_38_5 = 0x1f2;
14000aa6c              uint64_t rax_13;
14000aa6c              (uint8_t)rax_13 =
14000aa6c                  !((uint64_t)(uint32_t)*(uint64_t*)((char*)arg3 + 0x30) & 1);
14000aa6f              var_9_2 = (uint8_t)rax_13;
14000aa54          }
14000aa54          
14000aa7e          if (var_9_2 == 1)
14000aa7e          {
14000aa80              int64_t var_38_6 = 0x24;
14000aa9a              *(uint64_t*)arg2 &= 0xfffffffffffffffc;
14000aa9d              int64_t var_38_7 = 0x1fd;
14000aab0              registerCycle__system_u3455(arg2, arg3);
14000aa7e          }
14000a9f7      }
14000a9f7      else
14000a9f7      {
14000a9f9          int64_t var_38_2 = 0x1f6;
14000a9f9          
14000aa0c          if (arg2[1] > 0)
14000aa0c          {
14000aa0e              int64_t var_38_3 = 0x1f7;
14000aa1d              unregisterCycle__system_u3092(arg2);
14000aa0c          }
14000a9f7      }
14000a9f7      
14000aacf      return popFrame();
14000a998  }


14000aad0    int64_t* nimDestroyAndDispose(int64_t* arg1)

14000aad0  {
14000aae3      char const* const var_40 = "nimDestroyAndDispose";
14000aaee      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000aaf2      int64_t var_38 = 0;
14000aafa      int16_t var_28 = 0;
14000ab07      void* var_48;
14000ab07      nimFrame(&var_48);
14000ab0c      int64_t var_38_1 = 0xc5;
14000ab1b      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000ab27      int64_t var_38_2 = 0xc6;
14000ab27      
14000ab3c      if (**(uint64_t**)arg1)
14000ab3c      {
14000ab3e          int64_t var_38_3 = 0xc7;
14000ab5a          (**(uint64_t**)arg1)(arg1);
14000ab3c      }
14000ab3c      
14000ab5f      int64_t var_38_4 = 0xcf;
14000ab7d      nimRawDispose(arg1, (int64_t)*(uint16_t*)(*(uint64_t*)arg1 + 0x10));
14000ab8d      return popFrame();
14000aad0  }


14000ab8e    int64_t* eqdestroy___stdZassertions_u74(int64_t* arg1)

14000ab8e  {
14000ab9f      int64_t* result_1 = arg1[1];
14000aba3      int64_t var_28 = *(uint64_t*)arg1;
14000abab      int64_t* result = result_1;
14000abab      
14000abb2      if (result)
14000abb2      {
14000abc8          result = 0x4000000000000000 & *(uint64_t*)result_1;
14000abc8          
14000abce          if (!result)
14000abdc              return alignedDealloc(result_1, 8);
14000abb2      }
14000abb2      
14000abe8      return result;
14000ab8e  }


14000abe9    int64_t* resize__system_u2986(void* arg1)

14000abe9  {
14000abfc      char const* const var_50 = "resize";
14000ac07      char const* const var_40 =
14000ac07          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
14000ac0b      int64_t var_48 = 0;
14000ac13      int16_t var_38 = 0;
14000ac20      void* var_58;
14000ac20      nimFrame(&var_58);
14000ac25      int64_t var_48_1 = 0x14;
14000ac34      char const* const var_40_1 =
14000ac34          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\cellseqs_v2.nim";
14000ac3c      int64_t rax_1 = *(uint64_t*)((char*)arg1 + 8);
14000ac4a      int64_t rax_3 = (rax_1 + (rax_1 >> 0x3f)) >> 1;
14000ac54      int64_t rax_5 = *(uint64_t*)((char*)arg1 + 8);
14000ac58      char rdx_2 = 0;
14000ac58      
14000ac60      if (rax_5 + rax_3)
14000ac62          rdx_2 = 1;
14000ac62      
14000ac79      if (!(rdx_2 & 1))
14000ac79      {
14000ac8d          *(uint64_t*)((char*)arg1 + 8) = rax_5 + rax_3;
14000ac91          int64_t var_48_2 = 0x15;
14000aca1          char rdx_4 = 0;
14000aca6          uint64_t rax_12 = *(uint64_t*)((char*)arg1 + 8) * 0x10;
14000aca6          bool o_1 = /* bool o_1 = unimplemented  {imul rax, rax, 0x10} */;
14000aca6          
14000acaa          if (o_1)
14000acac              rdx_4 = 1;
14000acac          
14000acc3          if (!(rdx_4 & 1))
14000acc3          {
14000acd4              int64_t var_48_3 = 0x17;
14000acd4              
14000ace1              if (rax_12 >= 0)
14000ace1              {
14000ad00                  int64_t var_18_1 = 0;
14000ad28                  *(uint64_t*)((char*)arg1 + 0x10) = reallocSharedImpl__system_u1766(
14000ad28                      *(uint64_t*)((char*)arg1 + 0x10), rax_12);
14000ace1              }
14000ace1              else
14000acf9                  raiseRangeErrorI(rax_12, 0, 0x7fffffffffffffff);
14000acc3          }
14000acc3          else
14000acc5              raiseOverflow();
14000ac79      }
14000ac79      else
14000ac7b          raiseOverflow();
14000ac7b      
14000ad37      return popFrame();
14000abe9  }


14000ad38    uint64_t nimAsgnStrV2(int64_t* arg1, int64_t* arg2)

14000ad38  {
14000ad4a      int64_t rax = *(uint64_t*)arg2;
14000ad4d      int64_t* rdx = arg2[1];
14000ad59      char var_19 = 0;
14000ad6c      int64_t* rax_2;
14000ad6c      (uint8_t)rax_2 = arg1[1] == rdx;
14000ad6f      char var_19_1 = (uint8_t)rax_2;
14000ad6f      
14000ad7b      if (var_19_1 == 1)
14000ad7b      {
14000ad8b          int64_t rax_6;
14000ad8b          (uint8_t)rax_6 = *(uint64_t*)arg1 == rax;
14000ad8e          var_19_1 = (uint8_t)rax_6;
14000ad7b      }
14000ad7b      
14000ad98      uint64_t result = (uint64_t)var_19_1 ^ 1;
14000ad98      
14000ad9d      if ((uint8_t)result)
14000ad9d      {
14000ada4          char var_1a_1 = 0;
14000adaf          int64_t* rax_8;
14000adaf          (uint8_t)rax_8 = !rdx;
14000adb2          char var_1a_2 = (uint8_t)rax_8;
14000adb2          
14000adb9          if (!var_1a_2)
14000adb9          {
14000add2              int64_t rax_10;
14000add2              (uint8_t)rax_10 = 0x4000000000000000 & *(uint64_t*)rdx;
14000add5              var_1a_2 = (uint8_t)rax_10;
14000adb9          }
14000adb9          
14000ade4          if (var_1a_2 != 1)
14000ade4          {
14000ae5b              char var_1c_1 = 0;
14000ae5f              char var_1d_1 = 0;
14000ae6e              int64_t rax_22;
14000ae6e              (uint8_t)rax_22 = !arg1[1];
14000ae71              char var_1d_2 = (uint8_t)rax_22;
14000ae71              
14000ae78              if (!var_1d_2)
14000ae78              {
14000ae95                  int64_t rax_25;
14000ae95                  (uint8_t)rax_25 = 0x4000000000000000 & *(uint64_t*)arg1[1];
14000ae98                  var_1d_2 = (uint8_t)rax_25;
14000ae78              }
14000ae78              
14000aea2              char var_1c_2 = var_1d_2;
14000aea2              
14000aea9              if (!var_1c_2)
14000aea9              {
14000aeca                  int64_t rax_29;
14000aeca                  (uint8_t)rax_29 = (*(uint64_t*)arg1[1] & 0xbfffffffffffffff) < rax;
14000aecd                  var_1c_2 = (uint8_t)rax_29;
14000aea9              }
14000aea9              
14000aedc              if (var_1c_2 == 1)
14000aedc              {
14000aee2                  char var_1e_1 = 0;
14000aef1                  int64_t rax_33;
14000aef1                  (uint8_t)rax_33 = !arg1[1];
14000aef4                  char var_1e_2 = (uint8_t)rax_33;
14000aef4                  
14000aefb                  if (!var_1e_2)
14000aefb                  {
14000af18                      int64_t rax_36;
14000af18                      (uint8_t)rax_36 = 0x4000000000000000 & *(uint64_t*)arg1[1];
14000af1b                      var_1e_2 = (uint8_t)rax_36;
14000aefb                  }
14000aefb                  
14000af25                  if (!var_1e_2)
14000af32                      deallocShared(arg1[1]);
14000af32                  
14000af3e                  char rdx_11 = 0;
14000af3e                  
14000af47                  if (rax + 1)
14000af49                      rdx_11 = 1;
14000af49                  
14000af60                  if (rdx_11 & 1)
14000af62                      return raiseOverflow();
14000af62                  
14000af70                  char rdx_12 = 0;
14000af70                  
14000af79                  if (rax + 1 + 8)
14000af7b                      rdx_12 = 1;
14000af7b                  
14000af92                  if (rdx_12 & 1)
14000af94                      return raiseOverflow();
14000af94                  
14000afa2                  if (rax + 9 < 0)
14000afba                      return raiseRangeErrorI(rax + 9, 0, 0x7fffffffffffffff);
14000afba                  
14000afc1                  int64_t var_28_1 = 0;
14000afe1                  arg1[1] = allocSharedImpl(rax + 9);
14000aff1                  *(uint64_t*)arg1[1] = rax;
14000aedc              }
14000aedc              
14000b004              *(uint64_t*)arg1 = rax;
14000b00b              char rdx_16 = 0;
14000b00b              
14000b014              if (rax + 1)
14000b016                  rdx_16 = 1;
14000b016              
14000b02d              if (rdx_16 & 1)
14000b02f                  return raiseOverflow();
14000b02f              
14000b03d              if (rax + 1 >= 0)
14000b07a                  return copyMem__system_u1731(arg1[1] + 8, &rdx[1], rax + 1);
14000b07a              
14000b055              return raiseRangeErrorI(rax + 1, 0, 0x7fffffffffffffff);
14000ade4          }
14000ade4          
14000ade6          char var_1b_1 = 0;
14000adf5          int64_t rax_14;
14000adf5          (uint8_t)rax_14 = !arg1[1];
14000adf8          char var_1b_2 = (uint8_t)rax_14;
14000adf8          
14000adff          if (!var_1b_2)
14000adff          {
14000ae1c              int64_t rax_17;
14000ae1c              (uint8_t)rax_17 = 0x4000000000000000 & *(uint64_t*)arg1[1];
14000ae1f              var_1b_2 = (uint8_t)rax_17;
14000adff          }
14000adff          
14000ae29          if (!var_1b_2)
14000ae36              deallocShared(arg1[1]);
14000ae36          
14000ae46          *(uint64_t*)arg1 = rax;
14000ae4d          result = arg1;
14000ae51          *(uint64_t*)(result + 8) = rdx;
14000ad9d      }
14000ad9d      
14000b089      return result;
14000ad38  }


14000b08a    int64_t* eqdup___system_u2662(int64_t* arg1, int64_t* arg2)

14000b08a  {
14000b09c      int64_t rax = *(uint64_t*)arg2;
14000b09f      int64_t rdx = arg2[1];
14000b0ab      int64_t var_28 = 0;
14000b0b3      int64_t var_20 = 0;
14000b0c3      int64_t var_48 = rax;
14000b0c7      int64_t var_40 = rdx;
14000b0d6      nimAsgnStrV2(&var_28, &var_48);
14000b0e7      *(uint64_t*)arg1 = var_28;
14000b0ea      arg1[1] = var_20;
14000b0f8      return arg1;
14000b08a  }


14000b0f9    int64_t* eqsink___stdZassertions_u83(int64_t* arg1, int64_t* arg2)

14000b0f9  {
14000b10b      int64_t rax = *(uint64_t*)arg2;
14000b10e      int64_t rdx = arg2[1];
14000b10e      
14000b129      if (arg1[1] != rdx)
14000b129      {
14000b12f          int64_t rdx_2 = arg1[1];
14000b136          int64_t var_38 = *(uint64_t*)arg1;
14000b13a          int64_t var_30_1 = rdx_2;
14000b145          eqdestroy___stdZassertions_u74(&var_38);
14000b129      }
14000b129      
14000b152      *(uint64_t*)arg1 = rax;
14000b15d      arg1[1] = rdx;
14000b168      return arg1;
14000b0f9  }


14000b169    int64_t* shrink__stdZassertions_u102(int64_t* arg1, int64_t arg2)

14000b169  {
14000b17d      *(uint64_t*)arg1 = arg2;
14000b182      return arg1;
14000b169  }


14000b183    void* alignedAlloc__system_u1912(int64_t arg1, int64_t arg2)

14000b183  {
14000b1a0      if (arg2 <= 0x10)
14000b1ae          return allocSharedImpl(arg1);
14000b1ae      
14000b1b8      char rcx_1 = 0;
14000b1c5      int64_t rax_3 = arg2 + arg1;
14000b1c5      
14000b1c8      if (arg2 + arg1)
14000b1ca          rcx_1 = 1;
14000b1ca      
14000b1e1      if (!(rcx_1 & 1))
14000b1e1      {
14000b1f1          char rdx_2 = 0;
14000b1f1          
14000b1fa          if (rax_3 - 1)
14000b1fc              rdx_2 = 1;
14000b1fc          
14000b213          if (!(rdx_2 & 1))
14000b213          {
14000b223              char rdx_3 = 0;
14000b223              
14000b22c              if (rax_3 - 1 + 2)
14000b22e                  rdx_3 = 1;
14000b22e              
14000b245              if (rdx_3 & 1)
14000b247                  raiseOverflow();
14000b245              else if (rax_3 + 1 >= 0)
14000b258              {
14000b281                  void* rax_17 = allocSharedImpl(rax_3 + 1);
14000b28a                  char rdx_4 = 0;
14000b28a                  
14000b297                  if (arg2 - 1)
14000b299                      rdx_4 = 1;
14000b299                  
14000b2b0                  if (!(rdx_4 & 1))
14000b2b0                  {
14000b2c4                      void* rdx_6 = rax_17 & (arg2 - 1);
14000b2c7                      char rcx_7 = 0;
14000b2d0                      void* rax_24 = arg2 - rdx_6;
14000b2d0                      
14000b2d3                      if (arg2 + -(rdx_6))
14000b2d5                          rcx_7 = 1;
14000b2d5                      
14000b2ec                      if (!(rcx_7 & 1))
14000b2ec                      {
14000b300                          char rdx_8 = 0;
14000b300                          
14000b30d                          if ((char*)rax_24 - 2)
14000b30f                              rdx_8 = 1;
14000b30f                          
14000b326                          if (!(rdx_8 & 1))
14000b326                          {
14000b32f                              int64_t var_28_1 = 0;
14000b353                              *(uint16_t*)pluspercent___system_u793(rax_17, 
14000b353                                  (char*)rax_24 - 2) = (uint16_t)rax_24;
14000b356                              int64_t var_30_1 = 0;
14000b376                              return pluspercent___system_u793(rax_17, rax_24);
14000b326                          }
14000b326                          
14000b328                          raiseOverflow();
14000b2ec                      }
14000b2ec                      else
14000b2ee                          raiseOverflow();
14000b2b0                  }
14000b2b0                  else
14000b2b2                      raiseOverflow();
14000b258              }
14000b258              else
14000b270                  raiseRangeErrorI(rax_3 + 1, 0, 0x7fffffffffffffff);
14000b213          }
14000b213          else
14000b215              raiseOverflow();
14000b1e1      }
14000b1e1      else
14000b1e3          raiseOverflow();
14000b1e3      
14000b383      return nullptr;
14000b183  }


14000b384    void* newSeqPayloadUninit(int64_t arg1, int64_t arg2, uint64_t arg3)

14000b384  {
14000b3a5      if (arg1 <= 0)
14000b4b4          return nullptr;
14000b4b4      
14000b3ab      int64_t var_18_1 = 0;
14000b3bf      int64_t rax_2 = align__system_u1634(8, arg3);
14000b3c8      char rdx_1 = 0;
14000b3d1      int64_t rax_4 = arg1 * arg2;
14000b3d1      bool o_1 = /* bool o_1 = unimplemented  {imul rax, qword [rbp+0x18]} */;
14000b3d1      
14000b3d6      if (o_1)
14000b3d8          rdx_1 = 1;
14000b3d8      
14000b3ef      if (!(rdx_1 & 1))
14000b3ef      {
14000b3ff          char rcx_1 = 0;
14000b408          uint64_t rax_8 = rax_2 + rax_4;
14000b408          
14000b40b          if (rax_2 + rax_4)
14000b40d              rcx_1 = 1;
14000b40d          
14000b424          if (rcx_1 & 1)
14000b426              raiseOverflow();
14000b424          else if (rax_8 >= 0)
14000b437          {
14000b45b              if (arg3 >= 0)
14000b45b              {
14000b47a                  int64_t var_20_1 = 0;
14000b48d                  void* result = alignedAlloc__system_u1912(rax_8, arg3);
14000b4a6                  *(uint64_t*)result = arg1;
14000b4ad                  return result;
14000b45b              }
14000b45b              
14000b473              raiseRangeErrorI(arg3, 0, 0x7fffffffffffffff);
14000b437          }
14000b437          else
14000b44f              raiseRangeErrorI(rax_8, 0, 0x7fffffffffffffff);
14000b3ef      }
14000b3ef      else
14000b3f1          raiseOverflow();
14000b3f1      
14000b4c5      return nullptr;
14000b384  }


14000b4c6    int64_t resize__system_u2227(int64_t arg1)

14000b4c6  {
14000b4d7      if (arg1 <= 0)
14000b4d9          return 4;
14000b4d9      
14000b4ef      if (arg1 > 0x7fff)
14000b4ef      {
14000b539          int64_t rax_8 = (arg1 + (arg1 >> 0x3f)) >> 1;
14000b53f          char rdx_4 = 0;
14000b53f          
14000b54b          if (arg1 + rax_8)
14000b54d              rdx_4 = 1;
14000b54d          
14000b564          if (!(rdx_4 & 1))
14000b571              return arg1 + rax_8;
14000b571          
14000b566          raiseOverflow();
14000b4ef      }
14000b4ef      else
14000b4ef      {
14000b4f1          char rdx_1 = 0;
14000b4fa          bool o_1 = /* bool o_1 = unimplemented  {imul rax, rax, 0x2} */;
14000b4fa          
14000b4fe          if (o_1)
14000b500              rdx_1 = 1;
14000b500          
14000b517          if (!(rdx_1 & 1))
14000b524              return arg1 * 2;
14000b524          
14000b519          raiseOverflow();
14000b4ef      }
14000b4ef      
14000b57e      int64_t result;
14000b57e      return result;
14000b4c6  }


14000b57f    void* alignedRealloc__system_u1972(int64_t* arg1, uint64_t arg2, uint64_t arg3, int64_t arg4)

14000b57f  {
14000b59c      if (arg4 <= 0x10)
14000b5ae          return reallocSharedImpl__system_u1766(arg1, arg3);
14000b5ae      
14000b5c5      void* result = alignedAlloc__system_u1912(arg3, arg4);
14000b5db      copyMem__system_u1731(result, arg1, arg2);
14000b5eb      alignedDealloc(arg1, arg4);
14000b5f9      return result;
14000b57f  }


14000b5fa    void* prepareSeqAddUninit(int64_t arg1, int64_t* arg2, int64_t arg3, int64_t arg4, uint64_t arg5)

14000b5fa  {
14000b629      int64_t rax_1 = align__system_u1634(8, arg5);
14000b629      
14000b637      if (arg3 <= 0)
14000b63d          return arg2;
14000b63d      
14000b64c      if (arg2)
14000b64c      {
14000b6bd          int64_t rax_11 = -0x4000000000000001 & *(uint64_t*)arg2;
14000b6c4          int64_t var_30_1 = 0;
14000b6d3          int64_t rax_13 = resize__system_u2227(rax_11);
14000b6dc          char rcx_4 = 0;
14000b6dc          
14000b6ec          if (arg3 + arg1)
14000b6ee              rcx_4 = 1;
14000b6ee          
14000b705          if (!(rcx_4 & 1))
14000b705          {
14000b711              int64_t rax_18 = arg3 + arg1;
14000b711              
14000b71c              if (rax_13 >= rax_18)
14000b71c                  rax_18 = rax_13;
14000b71c              
14000b73b              if (!(0x4000000000000000 & *(uint64_t*)arg2))
14000b73b              {
14000b8f9                  char rdx_18 = 0;
14000b902                  int64_t rax_49 = arg4 * rax_11;
14000b902                  bool o_6 = /* bool o_6 = unimplemented  {imul rax, qword [rbp-0x20]} */;
14000b902                  
14000b907                  if (o_6)
14000b910                      rdx_18 = 1;
14000b910                  
14000b92a                  if (!(rdx_18 & 1))
14000b92a                  {
14000b93d                      char rcx_17 = 0;
14000b946                      uint64_t rax_53 = rax_1 + rax_49;
14000b946                      
14000b949                      if (rax_1 + rax_49)
14000b94b                          rcx_17 = 1;
14000b94b                      
14000b965                      if (!(rcx_17 & 1))
14000b965                      {
14000b97c                          char rdx_21 = 0;
14000b985                          int64_t rax_58 = arg4 * rax_18;
14000b985                          bool o_8 = /* bool o_8 =
14000b985                              unimplemented  {imul rax, qword [rbp-0x30]} */;
14000b985                          
14000b98a                          if (o_8)
14000b98c                              rdx_21 = 1;
14000b98c                          
14000b9a6                          if (!(rdx_21 & 1))
14000b9a6                          {
14000b9b9                              char rcx_19 = 0;
14000b9c2                              uint64_t rax_62 = rax_1 + rax_58;
14000b9c2                              
14000b9c5                              if (rax_1 + rax_58)
14000b9c7                                  rcx_19 = 1;
14000b9c7                              
14000b9e1                              if (rcx_19 & 1)
14000b9e3                                  raiseOverflow();
14000b9e1                              else if (rax_53 < 0)
14000ba15                                  raiseRangeErrorI(rax_53, 0, 0x7fffffffffffffff);
14000b9fd                              else if (rax_62 >= 0)
14000ba24                              {
14000ba48                                  if (arg5 >= 0)
14000ba48                                  {
14000ba67                                      int64_t var_70_1 = 0;
14000ba88                                      void* rax_70 = alignedRealloc__system_u1972(arg2, 
14000ba88                                          rax_53, rax_62, arg5);
14000baa1                                      *(uint64_t*)rax_70 = rax_18;
14000baa8                                      return rax_70;
14000ba48                                  }
14000ba48                                  
14000ba60                                  raiseRangeErrorI(arg5, 0, 0x7fffffffffffffff);
14000ba24                              }
14000ba24                              else
14000ba3c                                  raiseRangeErrorI(rax_62, 0, 0x7fffffffffffffff);
14000b9a6                          }
14000b9a6                          else
14000b9a8                              raiseOverflow();
14000b965                      }
14000b965                      else
14000b967                          raiseOverflow();
14000b92a                  }
14000b92a                  else
14000b92c                      raiseOverflow();
14000b73b              }
14000b73b              else
14000b73b              {
14000b741                  char rdx_9 = 0;
14000b74a                  int64_t rax_22 = arg4 * rax_18;
14000b74a                  bool o_3 = /* bool o_3 = unimplemented  {imul rax, qword [rbp-0x30]} */;
14000b74a                  
14000b74f                  if (o_3)
14000b751                      rdx_9 = 1;
14000b751                  
14000b76b                  if (!(rdx_9 & 1))
14000b76b                  {
14000b77e                      char rcx_6 = 0;
14000b787                      uint64_t rax_26 = rax_1 + rax_22;
14000b787                      
14000b78a                      if (rax_1 + rax_22)
14000b78c                          rcx_6 = 1;
14000b78c                      
14000b7a6                      if (rcx_6 & 1)
14000b7a8                          raiseOverflow();
14000b7a6                      else if (rax_26 < 0)
14000b7d7                          raiseRangeErrorI(rax_26, 0, 0x7fffffffffffffff);
14000b7bc                      else if (arg5 >= 0)
14000b7e6                      {
14000b808                          int64_t var_40_1 = 0;
14000b81e                          void* rax_33 = alignedAlloc__system_u1912(rax_26, arg5);
14000b82f                          int64_t var_50_1 = 0;
14000b842                          int64_t rax_36 = pluspercent___system_u793(rax_33, rax_1);
14000b84b                          int64_t var_58_1 = 0;
14000b85e                          int64_t rax_38 = pluspercent___system_u793(arg2, rax_1);
14000b867                          char rdx_15 = 0;
14000b870                          uint64_t rax_40 = arg1 * arg4;
14000b870                          bool o_5 = /* bool o_5 =
14000b870                              unimplemented  {imul rax, qword [rbp+0x28]} */;
14000b870                          
14000b875                          if (o_5)
14000b877                              rdx_15 = 1;
14000b877                          
14000b891                          if (!(rdx_15 & 1))
14000b891                          {
14000b8a4                              if (rax_40 >= 0)
14000b8a4                              {
14000b8db                                  copyMem__system_u1731(rax_36, rax_38, rax_40);
14000b8e8                                  *(uint64_t*)rax_33 = rax_18;
14000b8ef                                  return rax_33;
14000b8a4                              }
14000b8a4                              
14000b8bf                              raiseRangeErrorI(rax_40, 0, 0x7fffffffffffffff);
14000b891                          }
14000b891                          else
14000b893                              raiseOverflow();
14000b7e6                      }
14000b7e6                      else
14000b7fe                          raiseRangeErrorI(arg5, 0, 0x7fffffffffffffff);
14000b76b                  }
14000b76b                  else
14000b76d                      raiseOverflow();
14000b73b              }
14000b705          }
14000b705          else
14000b707              raiseOverflow();
14000b64c      }
14000b64c      else
14000b64c      {
14000b64e          char rcx = 0;
14000b64e          
14000b65e          if (arg3 + arg1)
14000b660              rcx = 1;
14000b660          
14000b677          if (!(rcx & 1))
14000b69a              return newSeqPayloadUninit(arg3 + arg1, arg4, arg5);
14000b69a          
14000b679          raiseOverflow();
14000b64c      }
14000b64c      
14000babb      return nullptr;
14000b5fa  }


14000babc    int64_t* setLen__stdZassertions_u94(int64_t* arg1, int64_t* arg2)

14000babc  {
14000bae2      if (arg2 < *(uint64_t*)arg1)
14000baef          return shrink__stdZassertions_u102(arg1, arg2);
14000baef      
14000bafe      int64_t* result_2 = *(uint64_t*)arg1;
14000bb0d      int64_t* result = arg2;
14000bb0d      
14000bb15      if (result > result_2)
14000bb15      {
14000bb24          char var_9_1 = 0;
14000bb33          int64_t rax_8;
14000bb33          (uint8_t)rax_8 = !arg1[1];
14000bb36          char var_9_2 = (uint8_t)rax_8;
14000bb36          
14000bb3d          if (!var_9_2)
14000bb3d          {
14000bb5b              int64_t rax_11;
14000bb5b              (uint8_t)rax_11 = arg2 > (-0x4000000000000001 & *(uint64_t*)arg1[1]);
14000bb5e              var_9_2 = (uint8_t)rax_11;
14000bb3d          }
14000bb3d          
14000bb6d          if (var_9_2 == 1)
14000bb6d          {
14000bb6f              char rdx_2 = 0;
14000bb6f              
14000bb7c              if ((char*)arg2 + -(result_2))
14000bb7e                  rdx_2 = 1;
14000bb7e              
14000bb95              if (rdx_2 & 1)
14000bb97                  return raiseOverflow();
14000bb97              
14000bba1              int64_t var_40_1 = 0;
14000bbdf              arg1[1] =
14000bbdf                  prepareSeqAddUninit(result_2, arg1[1], (char*)arg2 - result_2, 0x18, 8);
14000bb6d          }
14000bb6d          
14000bbee          *(uint64_t*)arg1 = arg2;
14000bbf1          int64_t var_48_1 = 0;
14000bbf9          int64_t var_50_1 = 0;
14000bc0d          int64_t* result_1 = result_2;
14000bc0d          
14000bc11          while (true)
14000bc11          {
14000bc11              result = result_1;
14000bc11              
14000bc19              if (result >= arg2)
14000bc19                  break;
14000bc19              
14000bc4b              nimZeroMem(result_1 * 0x18 + arg1[1] + 8, 0x18);
14000bc50              char rdx_7 = 0;
14000bc50              
14000bc5d              if ((char*)result_1 + 1)
14000bc5f                  rdx_7 = 1;
14000bc5f              
14000bc76              if (rdx_7 & 1)
14000bc78                  return raiseOverflow();
14000bc78              
14000bc83              result_1 += 1;
14000bc11          }
14000bb15      }
14000bb15      
14000bc96      return result;
14000babc  }


14000bc97    int64_t* newSeq__system_u4212(int64_t* arg1, int64_t* arg2)

14000bc97  {
14000bcb3      shrink__stdZassertions_u102(arg1, 0);
14000bcce      return setLen__stdZassertions_u94(arg1, arg2);
14000bc97  }


14000bccf    int64_t* newSeq__system_u4207(int64_t* arg1, int64_t* arg2)

14000bccf  {
14000bce6      char const* const var_40 = "newSeq";
14000bcf1      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000bcf5      int64_t var_38 = 0;
14000bcfd      int16_t var_28 = 0;
14000bd0a      void* var_48;
14000bd0a      nimFrame(&var_48);
14000bd0f      int64_t var_18 = 0;
14000bd17      int64_t var_10 = 0;
14000bd1f      int64_t var_38_1 = 0x28b;
14000bd2e      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000bd3d      newSeq__system_u4212(&var_18, arg2);
14000bd42      popFrame();
14000bd53      *(uint64_t*)arg1 = var_18;
14000bd56      arg1[1] = var_10;
14000bd63      return arg1;
14000bccf  }


14000bd64    int64_t* auxWriteStackTrace__system_u4173(int64_t* arg1, int64_t* arg2)

14000bd64  {
14000bd7b      int64_t* i = arg1;
14000bd7f      int64_t* var_18 = nullptr;
14000bd7f      
14000bd8c      for (; i; i = *(uint64_t*)i)
14000bd8e          var_18 += 1;
14000bd8e      
14000bda9      void* var_20 = (char*)var_18 - 1;
14000bda9      
14000bdbd      if (*(uint64_t*)arg2)
14000bdbd      {
14000be1c          var_20 = (char*)var_18 + *(uint64_t*)arg2 - 1;
14000be2f          setLen__stdZassertions_u94(arg2, (char*)var_20 + 1);
14000bdbd      }
14000bdbd      else
14000bdbd      {
14000bdbf          int64_t var_58 = 0;
14000bdc7          int64_t var_50_1 = 0;
14000bdda          newSeq__system_u4207(&var_58, var_18);
14000bde7          int64_t var_88 = var_58;
14000bdeb          int64_t var_80_1 = var_50_1;
14000bdfa          eqsink___stdZassertions_u83(arg2, &var_88);
14000bdbd      }
14000bdbd      
14000be34      int64_t* result = arg1;
14000be38      int64_t* i_1 = result;
14000be38      
14000be41      while (i_1)
14000be41      {
14000be57          int64_t var_48_1;
14000be57          __builtin_memset(&var_48_1, 0, 0x18);
14000be77          int64_t rax_19 = i_1[2];
14000be8b          int64_t rax_22 = i_1[3];
14000beb4          void* rax_29 = var_20 * 0x18 + arg2[1];
14000bebb          *(uint64_t*)((char*)rax_29 + 8) = i_1[1];
14000bec3          *(uint64_t*)((char*)rax_29 + 0x10) = rax_19;
14000becb          *(uint64_t*)((char*)rax_29 + 0x18) = rax_22;
14000bed3          result = *(uint64_t*)i_1;
14000bed6          i_1 = result;
14000beda          var_20 -= 1;
14000be41      }
14000be41      
14000beee      return result;
14000bd64  }


14000beef    int64_t* rawWriteStackTrace__system_u4432(int64_t* arg1)

14000beef  {
14000bf1f      return auxWriteStackTrace__system_u4173(
14000bf1f          *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692), arg1);
14000beef  }


14000bf20    int64_t* add__system_u4515(int64_t* arg1, int64_t* arg2)

14000bf20  {
14000bf36      int64_t rax_1 = *(uint64_t*)arg1;
14000bf4d      char var_19 = 0;
14000bf5c      int64_t rax_5;
14000bf5c      (uint8_t)rax_5 = !arg1[1];
14000bf5f      char var_19_1 = (uint8_t)rax_5;
14000bf5f      
14000bf66      if (!var_19_1)
14000bf66      {
14000bf68          char rdx = 0;
14000bf68          
14000bf75          if (rax_1 + 1)
14000bf77              rdx = 1;
14000bf77          
14000bf8e          if (rdx & 1)
14000bf90              return raiseOverflow();
14000bf90          
14000bfb9          int64_t rax_12;
14000bfb9          (uint8_t)rax_12 = (*(uint64_t*)arg1[1] & 0xbfffffffffffffff) < rax_1 + 1;
14000bfbc          var_19_1 = (uint8_t)rax_12;
14000bf66      }
14000bf66      
14000bfcb      if (var_19_1 == 1)
14000bfcb      {
14000bfcd          int64_t var_40_1 = 0;
14000c00a          arg1[1] = prepareSeqAddUninit(rax_1, arg1[1], 1, 0x18, 8);
14000bfcb      }
14000bfcb      
14000c011      char rdx_5 = 0;
14000c011      
14000c01e      if (rax_1 + 1)
14000c020          rdx_5 = 1;
14000c020      
14000c037      if (rdx_5 & 1)
14000c039          return raiseOverflow();
14000c039      
14000c049      *(uint64_t*)arg1 = rax_1 + 1;
14000c065      int64_t* result = rax_1 * 0x18 + arg1[1];
14000c06b      result[1] = *(uint64_t*)arg2;
14000c073      result[2] = arg2[1];
14000c07b      result[3] = arg2[2];
14000c086      return result;
14000bf20  }


14000c087    int64_t* nimIncRefCyclic(int64_t arg1)

14000c087  {
14000c095      char rdx;
14000c095      char arg_10 = rdx;
14000c09f      char const* const var_50 = "nimIncRefCyclic";
14000c0aa      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000c0ae      int64_t var_48 = 0;
14000c0b6      int16_t var_38 = 0;
14000c0c3      void* var_58;
14000c0c3      nimFrame(&var_58);
14000c0c8      int64_t var_48_1 = 0x2d;
14000c0d7      char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000c0db      int64_t var_48_2 = 0x3a;
14000c0ea      char const* const var_40_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000c0ee      int64_t var_10 = 0;
14000c102      int64_t* rax_2 = minuspercent___system_u813(arg1, 0x10);
14000c113      int64_t var_48_3 = 0x2e;
14000c122      char const* const var_40_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000c12a      int64_t rax_5 = *(uint64_t*)rax_2;
14000c12d      char rdx_1 = 0;
14000c12d      
14000c136      if (rax_5 + 0x10)
14000c138          rdx_1 = 1;
14000c138      
14000c14f      if (!(rdx_1 & 1))
14000c160          *(uint64_t*)rax_2 = rax_5 + 0x10;
14000c14f      else
14000c151          raiseOverflow();
14000c151      
14000c16e      return popFrame();
14000c087  }


14000c16f    uint64_t nimDecRefIsLastCyclicDyn(void** arg1)

14000c16f  {
14000c182      char const* const var_50 = "nimDecRefIsLastCyclicDyn";
14000c18d      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000c191      int64_t var_48 = 0;
14000c199      int16_t var_38 = 0;
14000c1a6      void* var_58;
14000c1a6      nimFrame(&var_58);
14000c1b0      char* var_18 = nimErrorFlag();
14000c1b4      int64_t var_48_1 = 0x200;
14000c1bc      char var_9 = 0;
14000c1c0      int64_t var_48_2 = 0x201;
14000c1c0      
14000c1cd      if (arg1)
14000c1cd      {
14000c1d3          int64_t var_48_3 = 0x202;
14000c1db          int64_t var_48_4 = 0x3a;
14000c1ea          char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000c1ee          int64_t var_20_1 = 0;
14000c202          int64_t* rax_2 = minuspercent___system_u813(arg1, 0x10);
14000c213          int64_t var_48_5 = 0x203;
14000c222          char const* const var_40_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\orc.nim";
14000c231          int64_t var_48_8;
14000c231          
14000c231          if (*(uint64_t*)rax_2 > 0xf)
14000c231          {
14000c242              int64_t var_48_7 = 0x207;
14000c24e              int64_t rax_7 = *(uint64_t*)rax_2;
14000c251              char rdx_1 = 0;
14000c251              
14000c25a              if (rax_7 - 0x10)
14000c25c                  rdx_1 = 1;
14000c25c              
14000c273              if (!(rdx_1 & 1))
14000c273              {
14000c284                  *(uint64_t*)rax_2 = rax_7 - 0x10;
14000c287                  var_48_8 = 0x209;
14000c2a3                  rememberCycle__system_u3495(var_9, rax_2, *(uint64_t*)arg1);
14000c273              }
14000c273              else
14000c275                  raiseOverflow();
14000c231          }
14000c231          else
14000c231          {
14000c233              int64_t var_48_6 = 0x204;
14000c23b              var_9 = 1;
14000c287              var_48_8 = 0x209;
14000c2a3              rememberCycle__system_u3495(var_9, rax_2, *(uint64_t*)arg1);
14000c231          }
14000c1cd      }
14000c1cd      
14000c2b7      popFrame();
14000c2c5      return (uint64_t)var_9;
14000c16f  }


14000c2c6    int64_t eqcopy___stdZtypedthreads_u187(int64_t* arg1, int64_t arg2, char arg3)

14000c2c6  {
14000c2e0      void** rax_2 = *(uint64_t*)arg1;
14000c2e0      
14000c2ec      if (arg2)
14000c2f8          nimIncRefCyclic(arg2);
14000c2f8      
14000c308      *(uint64_t*)arg1 = arg2;
14000c30b      char var_11 = 0;
14000c322      char result = nimDecRefIsLastCyclicDyn(rax_2) ^ 1;
14000c322      
14000c327      if (result)
14000c33e          return result;
14000c33e      
14000c330      return nimDestroyAndDispose(rax_2);
14000c2c6  }


14000c33f    int64_t eqsink___stdZtypedthreads_u195(int64_t* arg1, int64_t arg2)

14000c33f  {
14000c353      void** rax_1 = *(uint64_t*)arg1;
14000c362      *(uint64_t*)arg1 = arg2;
14000c365      char var_11 = 0;
14000c37c      char result = nimDecRefIsLastCyclicDyn(rax_1) ^ 1;
14000c37c      
14000c381      if (result)
14000c398          return result;
14000c398      
14000c38a      return nimDestroyAndDispose(rax_1);
14000c33f  }


14000c399    int64_t pushCurrentException(void* arg1)

14000c399  {
14000c3b2      int64_t* rax = __emutls_get_address(&__emutls_v.currException__system_u4105);
14000c3ce      eqcopy___stdZtypedthreads_u187((char*)arg1 + 0x38, *(uint64_t*)rax, 1);
14000c3e9      return eqsink___stdZtypedthreads_u195(rax, arg1);
14000c399  }


14000c3ea    char* raiseExceptionAux__system_u4487(void* arg1)

14000c3ea  {
14000c405      int64_t rax_1 =
14000c405          *(uint64_t*)__emutls_get_address(&__emutls_v.localRaiseHook__system_u3633);
14000c40b      char* result;
14000c40b      
14000c40b      if (rax_1)
14000c40b      {
14000c40d          char var_9_1 = 0;
14000c42a          result = (
14000c42a              *(uint64_t*)__emutls_get_address(&__emutls_v.localRaiseHook__system_u3633))(
14000c42a              arg1);
14000c40b      }
14000c40b      
14000c433      if (!rax_1 || (uint8_t)result)
14000c433      {
14000c442          if (globalRaiseHook__system_u3630)
14000c442          {
14000c444              char var_a_1 = 0;
14000c456              result = globalRaiseHook__system_u3630(arg1);
14000c442          }
14000c442          
14000c45f          if (!globalRaiseHook__system_u3630 || (uint8_t)result)
14000c45f          {
14000c46b              pushCurrentException(arg1);
14000c47a              result = __emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
14000c48c              int64_t rdx_5;
14000c48c              (uint8_t)rdx_5 = (uint64_t)*(uint8_t*)result != -1;
14000c48f              *(uint8_t*)result = (uint8_t)rdx_5;
14000c45f          }
14000c433      }
14000c433      
14000c49d      return result;
14000c3ea  }


14000c49e    char* raiseExceptionEx(void* arg1, int64_t arg2)

14000c49e  {
14000c4b7      int64_t r8;
14000c4b7      int64_t arg_18 = r8;
14000c4bb      int64_t r9;
14000c4bb      int64_t arg_20 = r9;
14000c4bb      
14000c4ca      if (!*(uint64_t*)((char*)arg1 + 0x10))
14000c4d4          *(uint64_t*)((char*)arg1 + 0x10) = arg2;
14000c4d4      
14000c4ec      if (*(uint64_t*)((char*)arg1 + 0x28))
14000c4ec      {
14000c519          if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
14000c519          {
14000c527              int64_t var_30_1 = -0xa;
14000c52f              int64_t var_28_1 = 0;
14000c543              int64_t var_78 = 0;
14000c54b              int64_t var_70_1 = var_30_1;
14000c553              int64_t var_68_1 = var_28_1;
14000c55e              add__system_u4515((char*)arg1 + 0x28, &var_78);
14000c583              auxWriteStackTrace__system_u4173(
14000c583                  *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692), 
14000c583                  (char*)arg1 + 0x28);
14000c590              int64_t var_50_1 = -0x64;
14000c598              int64_t var_48_1 = 0;
14000c5ac              var_78 = 0;
14000c5b4              int64_t var_70_2 = var_50_1;
14000c5bc              int64_t var_68_2 = var_48_1;
14000c5c7              add__system_u4515((char*)arg1 + 0x28, &var_78);
14000c519          }
14000c4ec      }
14000c4ec      else
14000c4f9          rawWriteStackTrace__system_u4432((char*)arg1 + 0x28);
14000c4f9      
14000c5e5      return raiseExceptionAux__system_u4487(arg1);
14000c49e  }


14000c5e6    int64_t* sysFatal__system_u5210(int64_t* arg1)

14000c5e6  {
14000c5fa      int64_t rax = *(uint64_t*)arg1;
14000c5fd      int64_t rdx = arg1[1];
14000c610      char const* const var_60 = "sysFatal";
14000c61b      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000c61f      int64_t var_58 = 0;
14000c627      int16_t var_48 = 0;
14000c634      void* var_68;
14000c634      nimFrame(&var_68);
14000c639      int64_t var_38 = 0;
14000c641      int64_t var_30 = 0;
14000c649      int64_t var_20 = 0;
14000c65b      void*** rax_1 = nimNewObj(0x40, 8);
14000c66f      *(uint64_t*)rax_1 = &NTIv2__1DmnNWJVVT9bplfmaalVeUA_;
14000c67d      rax_1[2] = "OverflowDefect";
14000c681      int64_t var_58_1 = 0x35;
14000c690      char const* const var_50_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000c694      int64_t var_58_2 = 0x69e;
14000c6a3      char const* const var_50_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000c6b3      int64_t var_88 = rax;
14000c6b7      int64_t var_80 = rdx;
14000c6c2      eqdup___system_u2662(&var_38, &var_88);
14000c6d3      rax_1[3] = var_38;
14000c6d7      rax_1[4] = var_30;
14000c6db      int64_t var_58_3 = 0x35;
14000c6ea      char const* const var_50_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000c6f2      int64_t var_98 = 0x35;
14000c713      raiseExceptionEx(rax_1, "OverflowDefect");
14000c728      return popFrame();
14000c5e6  }


14000c729    int64_t* raiseOverflow()

14000c729  {
14000c73f      int64_t var_18 = 0x12;
14000c743      void* const var_10 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_70;
14000c759      return sysFatal__system_u5210(&var_18);
14000c729  }


14000c75a    int64_t align__system_u1634(int64_t arg1, int64_t arg2)

14000c75a  {
14000c771      char const* const var_40 = "align";
14000c77c      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000c780      int64_t var_38 = 0;
14000c788      int16_t var_28 = 0;
14000c795      void* var_48;
14000c795      nimFrame(&var_48);
14000c79a      int64_t var_38_1 = 0x460;
14000c7a9      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000c7b2      int64_t result;
14000c7b2      
14000c7b2      if (arg2)
14000c7b2      {
14000c7ca          int64_t var_38_3 = 0x464;
14000c7d2          char rdx = 0;
14000c7d2          
14000c7df          if (arg2 - 1)
14000c7e1              rdx = 1;
14000c7e1          
14000c7f8          if (!(rdx & 1))
14000c7f8          {
14000c805              char rcx_2 = 0;
14000c805              
14000c811              if (arg1 + arg2 - 1)
14000c813                  rcx_2 = 1;
14000c813              
14000c82a              if (!(rcx_2 & 1))
14000c82a              {
14000c833                  char rdx_3 = 0;
14000c833                  
14000c840                  if (arg2 - 1)
14000c842                      rdx_3 = 1;
14000c842                  
14000c859                  if (!(rdx_3 & 1))
14000c873                      result = (arg1 + arg2 - 1) & ~(arg2 - 1);
14000c859                  else
14000c85b                      raiseOverflow();
14000c82a              }
14000c82a              else
14000c82c                  raiseOverflow();
14000c7f8          }
14000c7f8          else
14000c7fa              raiseOverflow();
14000c7b2      }
14000c7b2      else
14000c7b2      {
14000c7b4          int64_t var_38_2 = 0x462;
14000c7c0          result = arg1;
14000c7b2      }
14000c7b2      
14000c877      popFrame();
14000c885      return result;
14000c75a  }


14000c886    void* allocShared0Impl__system_u1762(uint64_t arg1)

14000c886  {
14000c899      void* result = allocSharedImpl(arg1);
14000c8ad      zeroMem__system_u1728(result, arg1);
14000c8bb      return result;
14000c886  }


14000c8bc    void* alignedAlloc0__system_u1958(uint64_t arg1, int64_t arg2)

14000c8bc  {
14000c8d9      if (arg2 <= 0x10)
14000c8e7          return allocShared0Impl__system_u1762(arg1);
14000c8e7      
14000c8f1      char rcx_1 = 0;
14000c8fe      int64_t rax_3 = arg2 + arg1;
14000c8fe      
14000c901      if (arg2 + arg1)
14000c903          rcx_1 = 1;
14000c903      
14000c91a      if (!(rcx_1 & 1))
14000c91a      {
14000c92a          char rdx_2 = 0;
14000c92a          
14000c933          if (rax_3 - 1)
14000c935              rdx_2 = 1;
14000c935          
14000c94c          if (!(rdx_2 & 1))
14000c94c          {
14000c95c              char rdx_3 = 0;
14000c95c              
14000c965              if (rax_3 - 1 + 2)
14000c967                  rdx_3 = 1;
14000c967              
14000c97e              if (rdx_3 & 1)
14000c980                  raiseOverflow();
14000c97e              else if (rax_3 + 1 >= 0)
14000c991              {
14000c9ba                  void* rax_17 = allocShared0Impl__system_u1762(rax_3 + 1);
14000c9c3                  char rdx_4 = 0;
14000c9c3                  
14000c9d0                  if (arg2 - 1)
14000c9d2                      rdx_4 = 1;
14000c9d2                  
14000c9e9                  if (!(rdx_4 & 1))
14000c9e9                  {
14000c9fd                      void* rdx_6 = rax_17 & (arg2 - 1);
14000ca00                      char rcx_7 = 0;
14000ca09                      void* rax_24 = arg2 - rdx_6;
14000ca09                      
14000ca0c                      if (arg2 + -(rdx_6))
14000ca0e                          rcx_7 = 1;
14000ca0e                      
14000ca25                      if (!(rcx_7 & 1))
14000ca25                      {
14000ca39                          char rdx_8 = 0;
14000ca39                          
14000ca46                          if ((char*)rax_24 - 2)
14000ca48                              rdx_8 = 1;
14000ca48                          
14000ca5f                          if (!(rdx_8 & 1))
14000ca5f                          {
14000ca68                              int64_t var_28_1 = 0;
14000ca8c                              *(uint16_t*)pluspercent___system_u793(rax_17, 
14000ca8c                                  (char*)rax_24 - 2) = (uint16_t)rax_24;
14000ca8f                              int64_t var_30_1 = 0;
14000caaf                              return pluspercent___system_u793(rax_17, rax_24);
14000ca5f                          }
14000ca5f                          
14000ca61                          raiseOverflow();
14000ca25                      }
14000ca25                      else
14000ca27                          raiseOverflow();
14000c9e9                  }
14000c9e9                  else
14000c9eb                      raiseOverflow();
14000c991              }
14000c991              else
14000c9a9                  raiseRangeErrorI(rax_3 + 1, 0, 0x7fffffffffffffff);
14000c94c          }
14000c94c          else
14000c94e              raiseOverflow();
14000c91a      }
14000c91a      else
14000c91c          raiseOverflow();
14000c91c      
14000cabc      return nullptr;
14000c8bc  }


14000cabd    int64_t nimNewObj(int64_t arg1, uint64_t arg2)

14000cabd  {
14000cad4      char const* const var_60 = "nimNewObj";
14000cadf      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000cae3      int64_t var_58 = 0;
14000caeb      int16_t var_48 = 0;
14000caf8      void* var_68;
14000caf8      nimFrame(&var_68);
14000cafd      int64_t result = 0;
14000cb05      int64_t var_58_1 = 0x5e;
14000cb14      char const* const var_50_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000cb24      int64_t rax_1 = align__system_u1634(0x10, arg2);
14000cb2d      int64_t var_58_2 = 0x5f;
14000cb35      char rcx_1 = 0;
14000cb42      uint64_t rax_3 = rax_1 + arg1;
14000cb42      
14000cb45      if (rax_1 + arg1)
14000cb47          rcx_1 = 1;
14000cb47      
14000cb5e      if (!(rcx_1 & 1))
14000cb5e      {
14000cb72          int64_t var_58_3 = 0x63;
14000cb7a          int64_t var_58_4 = 0x3d;
14000cb89          char const* const var_50_2 =
14000cb89              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\seqs_v2.nim";
14000cb8d          int64_t var_58_5 = 0x63;
14000cb9c          char const* const var_50_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000cb9c          
14000cba5          if (rax_3 < 0)
14000cbbd              raiseRangeErrorI(rax_3, 0, 0x7fffffffffffffff);
14000cba5          else if (arg2 >= 0)
14000cbc9          {
14000cbe8              int64_t var_28_1 = 0;
14000cc04              int64_t var_58_6 = 0x3d;
14000cc13              char const* const var_50_4 =
14000cc13                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\seqs_v2.nim";
14000cc17              int64_t var_30_1 = 0;
14000cc37              result = pluspercent___system_u793(alignedAlloc0__system_u1958(rax_3, arg2), 
14000cc37                  rax_1);
14000cbc9          }
14000cbc9          else
14000cbe1              raiseRangeErrorI(arg2, 0, 0x7fffffffffffffff);
14000cb5e      }
14000cb5e      else
14000cb60          raiseOverflow();
14000cb60      
14000cc3b      popFrame();
14000cc49      return result;
14000cabd  }


14000cc4a    int64_t* sysFatal__system_u4979(int64_t* arg1)

14000cc4a  {
14000cc5e      int64_t rax = *(uint64_t*)arg1;
14000cc61      int64_t rdx = arg1[1];
14000cc74      char const* const var_60 = "sysFatal";
14000cc7f      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000cc83      int64_t var_58 = 0;
14000cc8b      int16_t var_48 = 0;
14000cc98      void* var_68;
14000cc98      nimFrame(&var_68);
14000cc9d      int64_t var_38 = 0;
14000cca5      int64_t var_30 = 0;
14000ccad      int64_t var_20 = 0;
14000ccbf      void*** rax_1 = nimNewObj(0x40, 8);
14000ccd3      *(uint64_t*)rax_1 = &NTIv2__RKHXYNwSRXz825VbZValEQ_;
14000cce1      rax_1[2] = "RangeDefect";
14000cce5      int64_t var_58_1 = 0x35;
14000ccf4      char const* const var_50_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000ccf8      int64_t var_58_2 = 0x69e;
14000cd07      char const* const var_50_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000cd17      int64_t var_88 = rax;
14000cd1b      int64_t var_80 = rdx;
14000cd26      eqdup___system_u2662(&var_38, &var_88);
14000cd37      rax_1[3] = var_38;
14000cd3b      rax_1[4] = var_30;
14000cd3f      int64_t var_58_3 = 0x35;
14000cd4e      char const* const var_50_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000cd56      int64_t var_98 = 0x35;
14000cd77      raiseExceptionEx(rax_1, "RangeDefect");
14000cd8c      return popFrame();
14000cc4a  }


14000cd8d    int64_t* prepareAdd(int64_t* arg1, int64_t arg2)

14000cd8d  {
14000cda4      int64_t rdx = *(uint64_t*)arg1;
14000cda7      char rcx = 0;
14000cdb0      uint64_t result_1 = arg2 + rdx;
14000cdb0      
14000cdb3      if (arg2 + rdx)
14000cdb5          rcx = 1;
14000cdb5      
14000cdcc      if (rcx & 1)
14000cdce          return raiseOverflow();
14000cdce      
14000cde0      char var_9_1 = 0;
14000cdef      int64_t rax_6;
14000cdef      (uint8_t)rax_6 = !arg1[1];
14000cdf2      char var_9_2 = (uint8_t)rax_6;
14000cdf2      
14000cdf9      if (!var_9_2)
14000cdf9      {
14000ce16          int64_t rax_9;
14000ce16          (uint8_t)rax_9 = 0x4000000000000000 & *(uint64_t*)arg1[1];
14000ce19          var_9_2 = (uint8_t)rax_9;
14000cdf9      }
14000cdf9      
14000ce28      int64_t* result;
14000ce28      
14000ce28      if (var_9_2 != 1)
14000ce28      {
14000cfb0          int64_t* result_2 = -0x4000000000000001 & *(uint64_t*)arg1[1];
14000cfb7          result = result_2;
14000cfb7          
14000cfbf          if (result < result_1)
14000cfbf          {
14000cfcb              int64_t var_38_1 = 0;
14000cfe7              uint64_t result_6 = resize__system_u2227(result_2);
14000cfe7              
14000cfee              if (result_1 >= result_6)
14000cfee                  result_6 = result_1;
14000cfee              
14000cff6              char rdx_10 = 0;
14000cff6              
14000d003              if (result_6 + 1)
14000d005                  rdx_10 = 1;
14000d005              
14000d01c              if (rdx_10 & 1)
14000d01e                  return raiseOverflow();
14000d01e              
14000d02c              char rdx_11 = 0;
14000d02c              
14000d035              if (result_6 + 1 + 8)
14000d037                  rdx_11 = 1;
14000d037              
14000d04e              if (rdx_11 & 1)
14000d050                  return raiseOverflow();
14000d050              
14000d061              if (result_6 + 9 < 0)
14000d079                  return raiseRangeErrorI(result_6 + 9, 0, 0x7fffffffffffffff);
14000d079              
14000d083              int64_t var_48_1 = 0;
14000d0ab              arg1[1] = reallocSharedImpl__system_u1766(arg1[1], result_6 + 9);
14000d0bb              *(uint64_t*)arg1[1] = result_6;
14000d0be              result = result_1;
14000d0be              
14000d0c6              if (result < result_6)
14000d0c6              {
14000d0cc                  char rdx_15 = 0;
14000d0cc                  
14000d0d9                  if (result_1 + 1)
14000d0db                      rdx_15 = 1;
14000d0db                  
14000d0f2                  if (rdx_15 & 1)
14000d0f4                      return raiseOverflow();
14000d0f4                  
14000d0fb                  char rdx_16 = 0;
14000d104                  uint64_t rax_63 = result_6 - result_1;
14000d104                  
14000d108                  if (result_6 + -(result_1))
14000d10a                      rdx_16 = 1;
14000d10a                  
14000d121                  if (rdx_16 & 1)
14000d123                      return raiseOverflow();
14000d123                  
14000d131                  if (rax_63 >= 0)
14000d16a                      return zeroMem__system_u1728(result_1 + 1 + arg1[1] + 8, rax_63);
14000d16a                  
14000d149                  return raiseRangeErrorI(rax_63, 0, 0x7fffffffffffffff);
14000d0c6              }
14000cfbf          }
14000ce28      }
14000ce28      else
14000ce28      {
14000ce32          int64_t rax_13 = arg1[1];
14000ce3a          char rdx_3 = 0;
14000ce3a          
14000ce47          if (result_1 + 1)
14000ce49              rdx_3 = 1;
14000ce49          
14000ce60          if (rdx_3 & 1)
14000ce62              return raiseOverflow();
14000ce62          
14000ce70          char rdx_4 = 0;
14000ce70          
14000ce79          if (result_1 + 1 + 8)
14000ce7b              rdx_4 = 1;
14000ce7b          
14000ce92          if (rdx_4 & 1)
14000ce94              return raiseOverflow();
14000ce94          
14000cea5          if (result_1 + 9 < 0)
14000cebd              return raiseRangeErrorI(result_1 + 9, 0, 0x7fffffffffffffff);
14000cebd          
14000cec7          int64_t var_28_1 = 0;
14000cee7          arg1[1] = allocSharedImpl(result_1 + 9);
14000cef7          *(uint64_t*)arg1[1] = result_1;
14000cefe          result = *(uint64_t*)arg1;
14000cefe          
14000cf04          if (result > 0)
14000cf04          {
14000cf0a              uint64_t result_7 = *(uint64_t*)arg1;
14000cf0d              uint64_t result_3 = result_1;
14000cf0d              
14000cf14              if (result_7 <= result_3)
14000cf14                  result_3 = result_7;
14000cf14              
14000cf1b              if (result_3 >= 0)
14000cf1b              {
14000cf4c                  uint64_t result_9 = *(uint64_t*)arg1;
14000cf4f                  uint64_t result_5 = result_1;
14000cf4f                  
14000cf56                  if (result_9 <= result_5)
14000cf56                      result_5 = result_9;
14000cf56                  
14000cf77                  return copyMem__system_u1731(arg1[1] + 8, rax_13 + 8, result_5);
14000cf1b              }
14000cf1b              
14000cf21              uint64_t result_8 = *(uint64_t*)arg1;
14000cf24              uint64_t result_4 = result_1;
14000cf24              
14000cf2b              if (result_8 <= result_4)
14000cf2b                  result_4 = result_8;
14000cf2b              
14000cf41              return raiseRangeErrorI(result_4, 0, 0x7fffffffffffffff);
14000cf04          }
14000cf04          
14000cf84          if (!rax_13)
14000cf84          {
14000cf8a              result = arg1[1];
14000cf8e              result[1] = 0;
14000cf84          }
14000ce28      }
14000ce28      
14000d183      return result;
14000cd8d  }


14000d184    int64_t* sysFatal__system_u4806(int64_t* arg1)

14000d184  {
14000d198      int64_t rax = *(uint64_t*)arg1;
14000d19b      int64_t rdx = arg1[1];
14000d1ae      char const* const var_60 = "sysFatal";
14000d1b9      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000d1bd      int64_t var_58 = 0;
14000d1c5      int16_t var_48 = 0;
14000d1d2      void* var_68;
14000d1d2      nimFrame(&var_68);
14000d1d7      int64_t var_38 = 0;
14000d1df      int64_t var_30 = 0;
14000d1e7      int64_t var_20 = 0;
14000d1f9      void*** rax_1 = nimNewObj(0x40, 8);
14000d20d      *(uint64_t*)rax_1 = &NTIv2__xTnzBHckcPoKiwygsku9csg_;
14000d21b      rax_1[2] = "IndexDefect";
14000d21f      int64_t var_58_1 = 0x35;
14000d227      int64_t var_58_2 = 0x69e;
14000d236      char const* const var_50_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000d246      int64_t var_88 = rax;
14000d24a      int64_t var_80 = rdx;
14000d255      eqdup___system_u2662(&var_38, &var_88);
14000d266      rax_1[3] = var_38;
14000d26a      rax_1[4] = var_30;
14000d26e      int64_t var_58_3 = 0x35;
14000d27d      char const* const var_50_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000d285      int64_t var_98 = 0x35;
14000d2a6      raiseExceptionEx(rax_1, "IndexDefect");
14000d2bb      return popFrame();
14000d184  }


14000d2bc    int64_t* rawNewString(int64_t* arg1, int64_t arg2)

14000d2bc  {
14000d2d8      int64_t var_28;
14000d2d8      nimZeroMem(&var_28, 0x10);
14000d2e2      void* var_20;
14000d2e2      
14000d2e2      if (arg2 > 0)
14000d2e2      {
14000d2fa          char rdx = 0;
14000d2fa          
14000d307          if (arg2 + 1)
14000d309              rdx = 1;
14000d309          
14000d320          if (!(rdx & 1))
14000d320          {
14000d330              char rdx_1 = 0;
14000d330              
14000d339              if (arg2 + 1 + 8)
14000d33b                  rdx_1 = 1;
14000d33b              
14000d352              if (rdx_1 & 1)
14000d354                  raiseOverflow();
14000d352              else if (arg2 + 9 >= 0)
14000d362              {
14000d381                  int64_t var_10_1 = 0;
14000d390                  void* rax_12 = allocSharedImpl(arg2 + 9);
14000d3a9                  *(uint64_t*)rax_12 = arg2;
14000d3b0                  *(uint8_t*)((char*)rax_12 + 8) = 0;
14000d3b4                  var_28 = 0;
14000d3c0                  var_20 = rax_12;
14000d362              }
14000d362              else
14000d37a                  raiseRangeErrorI(arg2 + 9, 0, 0x7fffffffffffffff);
14000d320          }
14000d320          else
14000d322              raiseOverflow();
14000d2e2      }
14000d2e2      else
14000d2e2      {
14000d2e4          var_28 = 0;
14000d2ec          var_20 = nullptr;
14000d2e2      }
14000d2e2      
14000d3d0      *(uint64_t*)arg1 = var_28;
14000d3d3      arg1[1] = var_20;
14000d3e0      return arg1;
14000d2bc  }


14000d3e1    void* const raiseIndexError2(int64_t arg1, int64_t arg2)

14000d3e1  {
14000d3f4      char* rax = nimErrorFlag();
14000d41d      int64_t var_48_1;
14000d41d      __builtin_memset(&var_48_1, 0, 0x30);
14000d432      void* const result;
14000d432      uint64_t var_88;
14000d432      uint64_t var_48_2;
14000d432      void* const var_40_1;
14000d432      void* var_30_1;
14000d432      
14000d432      if (arg2 >= 0)
14000d432      {
14000d47d          uint64_t var_78 = 0;
14000d485          int64_t var_70_1;
14000d485          __builtin_memset(&var_70_1, 0, 0x28);
14000d498          uint64_t var_58;
14000d498          dollar___systemZdollars_u14(&var_58, arg1);
14000d4a4          result = (uint64_t)*(uint8_t*)rax;
14000d4a4          
14000d4a9          if (!(uint32_t)result)
14000d4a9          {
14000d4ba              uint64_t var_68;
14000d4ba              dollar___systemZdollars_u14(&var_68, arg2);
14000d4c6              result = (uint64_t)*(uint8_t*)rax;
14000d4c6              
14000d4cb              if (!(uint32_t)result)
14000d4cb              {
14000d4e7                  rawNewString(&var_88, var_68 + var_58 + 0x13);
14000d4f4                  var_78 = var_88;
14000d50a                  var_88 = 6;
14000d50e                  void* const var_80_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_92;
14000d51d                  appendString(&var_78, &var_88);
14000d52a                  var_88 = var_58;
14000d52e                  int64_t* var_50;
14000d52e                  int64_t* var_80_2 = var_50;
14000d53d                  appendString(&var_78, &var_88);
14000d550                  var_88 = 0xd;
14000d554                  void* const var_80_3 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_94;
14000d563                  appendString(&var_78, &var_88);
14000d570                  var_88 = var_68;
14000d574                  int64_t* var_60;
14000d574                  int64_t* var_80_4 = var_60;
14000d583                  appendString(&var_78, &var_88);
14000d588                  uint64_t rax_10 = var_78;
14000d594                  void* var_80;
14000d594                  var_30_1 = var_80;
14000d594                  
14000d5bb                  if (var_60 && !(0x4000000000000000 & *(uint64_t*)var_60))
14000d5c4                      deallocShared(var_60);
14000d5c4                  
14000d5ec                  if (var_50 && !(0x4000000000000000 & *(uint64_t*)var_50))
14000d5f5                      deallocShared(var_50);
14000d5f5                  
14000d602                  var_48_2 = rax_10;
14000d606                  var_40_1 = var_30_1;
14000d5ec                  goto label_14000d620;
14000d4cb              }
14000d4a9          }
14000d432      }
14000d432      else
14000d432      {
14000d443          void* const result_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_90;
14000d44f          var_48_2 = 0x2b;
14000d453          var_40_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_90;
14000d620      label_14000d620:
14000d620          var_88 = var_48_2;
14000d624          void* const var_80_5 = var_40_1;
14000d62f          sysFatal__system_u4806(&var_88);
14000d62f          
14000d657          if (var_30_1 && !(0x4000000000000000 & *(uint64_t*)var_30_1))
14000d660              deallocShared(var_30_1);
14000d660          
14000d665          result = result_1;
14000d665          
14000d66c          if (result)
14000d66c          {
14000d682              result = 0x4000000000000000 & *(uint64_t*)result_1;
14000d682              
14000d688              if (!result)
14000d691                  return deallocShared(result_1);
14000d66c          }
14000d432      }
14000d6a2      return result;
14000d3e1  }


14000d6a3    void* realloc0Impl__system_u1756(int64_t* arg1, void* arg2, uint64_t arg3)

14000d6a3  {
14000d6d7      void* result = realloc__system_u7212(__emutls_get_address(&_.data), arg1, arg3);
14000d6d7      
14000d6e8      if (arg2 < arg3)
14000d703          zeroMem__system_u1728((char*)arg2 + result, arg3 - arg2);
14000d703      
14000d714      return result;
14000d6a3  }


14000d715    void* reallocShared0Impl__system_u1769(int64_t* arg1, void* arg2, uint64_t arg3)

14000d715  {
14000d74d      return realloc0Impl__system_u1756(arg1, arg2, arg3);
14000d715  }


14000d74e    int64_t* setLengthStrV2(int64_t* arg1, uint64_t arg2)

14000d74e  {
14000d766      if (arg2)
14000d766      {
14000d76d          char var_9_1 = 0;
14000d77c          int64_t rax_2;
14000d77c          (uint8_t)rax_2 = !arg1[1];
14000d77f          char var_9_2 = (uint8_t)rax_2;
14000d77f          
14000d786          if (!var_9_2)
14000d786          {
14000d7a3              int64_t rax_5;
14000d7a3              (uint8_t)rax_5 = 0x4000000000000000 & *(uint64_t*)arg1[1];
14000d7a6              var_9_2 = (uint8_t)rax_5;
14000d786          }
14000d786          
14000d7b5          if (var_9_2 == 1)
14000d7b5          {
14000d7bf              int64_t rax_9 = arg1[1];
14000d7c7              char rdx_1 = 0;
14000d7c7              
14000d7d4              if (arg2 + 1)
14000d7d6                  rdx_1 = 1;
14000d7d6              
14000d7ed              if (rdx_1 & 1)
14000d7ef                  return raiseOverflow();
14000d7ef              
14000d7fd              char rdx_2 = 0;
14000d7fd              
14000d806              if (arg2 + 1 + 8)
14000d808                  rdx_2 = 1;
14000d808              
14000d81f              if (rdx_2 & 1)
14000d821                  return raiseOverflow();
14000d821              
14000d832              if (arg2 + 9 < 0)
14000d84a                  return raiseRangeErrorI(arg2 + 9, 0, 0x7fffffffffffffff);
14000d84a              
14000d854              int64_t var_20_1 = 0;
14000d874              arg1[1] = allocSharedImpl(arg2 + 9);
14000d884              *(uint64_t*)arg1[1] = arg2;
14000d884              
14000d891              if (*(uint64_t*)arg1 <= 0)
14000d891              {
14000d9f8                  char rdx_14 = 0;
14000d9f8                  
14000da05                  if (arg2 + 1)
14000da07                      rdx_14 = 1;
14000da07                  
14000da1e                  if (rdx_14 & 1)
14000da20                      return raiseOverflow();
14000da20                  
14000da2e                  if (arg2 + 1 < 0)
14000da46                      return raiseRangeErrorI(arg2 + 1, 0, 0x7fffffffffffffff);
14000da46                  
14000da60                  zeroMem__system_u1728(arg1[1] + 8, arg2 + 1);
14000d891              }
14000d891              else
14000d891              {
14000d89b                  uint64_t rdx_5 = *(uint64_t*)arg1;
14000d89e                  uint64_t rax_29 = arg2;
14000d89e                  
14000d8a5                  if (rdx_5 <= rax_29)
14000d8a5                      rax_29 = rdx_5;
14000d8a5                  
14000d8ac                  if (rax_29 < 0)
14000d8ac                  {
14000d8b2                      uint64_t rdx_6 = *(uint64_t*)arg1;
14000d8b5                      uint64_t rax_31 = arg2;
14000d8b5                      
14000d8bc                      if (rdx_6 <= rax_31)
14000d8bc                          rax_31 = rdx_6;
14000d8bc                      
14000d8d2                      return raiseRangeErrorI(rax_31, 0, 0x7fffffffffffffff);
14000d8ac                  }
14000d8ac                  
14000d8e0                  uint64_t rdx_7 = *(uint64_t*)arg1;
14000d8e3                  uint64_t rax_33 = arg2;
14000d8e3                  
14000d8ea                  if (rdx_7 <= rax_33)
14000d8ea                      rax_33 = rdx_7;
14000d8ea                  
14000d90b                  copyMem__system_u1731(arg1[1] + 8, rax_9 + 8, rax_33);
14000d90b                  
14000d91b                  if (arg2 <= *(uint64_t*)arg1)
14000d9ea                      *(uint8_t*)(arg2 + arg1[1] + 8) = 0;
14000d91b                  else
14000d91b                  {
14000d925                      int64_t rdx_9 = *(uint64_t*)arg1;
14000d928                      char rcx_7 = 0;
14000d931                      int64_t rax_42 = arg2 - rdx_9;
14000d931                      
14000d934                      if (arg2 + -(rdx_9))
14000d936                          rcx_7 = 1;
14000d936                      
14000d94d                      if (rcx_7 & 1)
14000d94f                          return raiseOverflow();
14000d94f                      
14000d95d                      char rdx_11 = 0;
14000d95d                      
14000d966                      if (rax_42 + 1)
14000d968                          rdx_11 = 1;
14000d968                      
14000d97f                      if (rdx_11 & 1)
14000d981                          return raiseOverflow();
14000d981                      
14000d98f                      if (rax_42 + 1 < 0)
14000d9a7                          return raiseRangeErrorI(rax_42 + 1, 0, 0x7fffffffffffffff);
14000d9a7                      
14000d9cb                      zeroMem__system_u1728(*(uint64_t*)arg1 + arg1[1] + 8, rax_42 + 1);
14000d91b                  }
14000d891              }
14000d7b5          }
14000d7b5          else if (arg2 > *(uint64_t*)arg1)
14000da7b          {
14000daa1              int64_t rax_73 = -0x4000000000000001 & *(uint64_t*)arg1[1];
14000daa1              
14000dab0              if (rax_73 < arg2)
14000dab0              {
14000dab6                  int64_t var_30_1 = 0;
14000dad2                  uint64_t rax_77 = resize__system_u2227(rax_73);
14000dad2                  
14000dad9                  if (arg2 >= rax_77)
14000dad9                      rax_77 = arg2;
14000dad9                  
14000dae1                  char rdx_18 = 0;
14000dae1                  
14000daee                  if (rax_73 + 1)
14000daf0                      rdx_18 = 1;
14000daf0                  
14000db07                  if (rdx_18 & 1)
14000db09                      return raiseOverflow();
14000db09                  
14000db17                  char rdx_19 = 0;
14000db17                  
14000db20                  if (rax_73 + 1 + 8)
14000db22                      rdx_19 = 1;
14000db22                  
14000db39                  if (rdx_19 & 1)
14000db3b                      return raiseOverflow();
14000db3b                  
14000db4c                  if (rax_73 + 9 < 0)
14000db64                      return raiseRangeErrorI(rax_73 + 9, 0, 0x7fffffffffffffff);
14000db64                  
14000db6e                  char rdx_20 = 0;
14000db6e                  
14000db7b                  if (rax_77 + 1)
14000db7d                      rdx_20 = 1;
14000db7d                  
14000db94                  if (rdx_20 & 1)
14000db96                      return raiseOverflow();
14000db96                  
14000dba4                  char rdx_21 = 0;
14000dba4                  
14000dbad                  if (rax_77 + 1 + 8)
14000dbaf                      rdx_21 = 1;
14000dbaf                  
14000dbc6                  if (rdx_21 & 1)
14000dbc8                      return raiseOverflow();
14000dbc8                  
14000dbd6                  if (rax_77 + 9 < 0)
14000dbee                      return raiseRangeErrorI(rax_77 + 9, 0, 0x7fffffffffffffff);
14000dbee                  
14000dbf5                  int64_t var_40_1 = 0;
14000dc24                  arg1[1] =
14000dc24                      reallocShared0Impl__system_u1769(arg1[1], rax_73 + 9, rax_77 + 9);
14000dc34                  *(uint64_t*)arg1[1] = rax_77;
14000dab0              }
14000da7b          }
14000da7b          
14000dc51          *(uint8_t*)(arg2 + arg1[1] + 8) = 0;
14000d766      }
14000d766      
14000dc5f      *(uint64_t*)arg1 = arg2;
14000dc6d      return arg1;
14000d74e  }


14000dc6e    uint64_t raiseRangeErrorI(uint64_t arg1, uint64_t arg2, uint64_t arg3)

14000dc6e  {
14000dc85      char* rax = nimErrorFlag();
14000dcce      uint64_t var_68 = 0;
14000dcd6      int64_t var_60_1;
14000dcd6      __builtin_memset(&var_60_1, 0, 0x48);
14000dce9      uint64_t var_28;
14000dce9      dollar___systemZdollars_u34(&var_28, arg1);
14000dcf5      uint64_t result = (uint64_t)*(uint8_t*)rax;
14000dcf5      
14000dcfa      if (!(uint32_t)result)
14000dcfa      {
14000dd0b          uint64_t var_38;
14000dd0b          dollar___systemZdollars_u34(&var_38, arg2);
14000dd17          result = (uint64_t)*(uint8_t*)rax;
14000dd17          
14000dd1c          if (!(uint32_t)result)
14000dd1c          {
14000dd2d              uint64_t var_48;
14000dd2d              dollar___systemZdollars_u34(&var_48, arg3);
14000dd39              result = (uint64_t)*(uint8_t*)rax;
14000dd39              
14000dd3e              if (!(uint32_t)result)
14000dd3e              {
14000dd61                  uint64_t var_78;
14000dd61                  rawNewString(&var_78, var_48 + var_28 + var_38 + 0x1f);
14000dd6e                  var_68 = var_78;
14000dd84                  var_78 = 0x14;
14000dd88                  void* const var_70_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_81;
14000dd97                  appendString(&var_68, &var_78);
14000dda4                  var_78 = var_28;
14000dda8                  uint64_t result_1;
14000dda8                  uint64_t result_2 = result_1;
14000ddb7                  appendString(&var_68, &var_78);
14000ddca                  var_78 = 7;
14000ddce                  void* const var_70_2 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_107;
14000dddd                  appendString(&var_68, &var_78);
14000ddea                  var_78 = var_38;
14000ddee                  int64_t* var_30;
14000ddee                  int64_t* var_70_3 = var_30;
14000ddfd                  appendString(&var_68, &var_78);
14000de10                  var_78 = 4;
14000de14                  void* const var_70_4 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_109;
14000de23                  appendString(&var_68, &var_78);
14000de30                  var_78 = var_48;
14000de34                  int64_t* var_40;
14000de34                  int64_t* var_70_5 = var_40;
14000de43                  appendString(&var_68, &var_78);
14000de60                  var_78 = var_68;
14000de64                  int64_t* var_70;
14000de64                  int64_t* var_70_6 = var_70;
14000de6f                  sysFatal__system_u4979(&var_78);
14000de6f                  
14000de97                  if (var_70 && !(0x4000000000000000 & *(uint64_t*)var_70))
14000dea0                      deallocShared(var_70);
14000dea0                  
14000dec8                  if (var_40 && !(0x4000000000000000 & *(uint64_t*)var_40))
14000ded1                      deallocShared(var_40);
14000ded1                  
14000def9                  if (var_30 && !(0x4000000000000000 & *(uint64_t*)var_30))
14000df02                      deallocShared(var_30);
14000df02                  
14000df07                  result = result_1;
14000df07                  
14000df0e                  if (result)
14000df0e                  {
14000df24                      result = 0x4000000000000000 & *(uint64_t*)result_1;
14000df24                      
14000df2a                      if (!result)
14000df33                          return deallocShared(result_1);
14000df0e                  }
14000dd3e              }
14000dd1c          }
14000dcfa      }
14000dcfa      
14000df4d      return result;
14000dc6e  }


14000df4e    uint64_t appendString(uint64_t* arg1, int64_t* arg2)

14000df4e  {
14000df60      uint64_t result_1 = *(uint64_t*)arg2;
14000df6f      uint64_t result = result_1;
14000df6f      
14000df76      if (result > 0)
14000df76      {
14000df83          if (result_1 < 0)
14000df9b              return raiseRangeErrorI(result_1, 0, 0x7fffffffffffffff);
14000df9b          
14000dfca          copyMem__system_u1731(*(uint64_t*)arg1 + arg1[1] + 8, arg2[1] + 8, result_1);
14000dfd3          uint64_t rdx_2 = *(uint64_t*)arg1;
14000dfda          char rcx_3 = 0;
14000dfda          
14000dfe2          if (result_1 + rdx_2)
14000dfe4              rcx_3 = 1;
14000dfe4          
14000dffb          if (rcx_3 & 1)
14000dffd              return raiseOverflow();
14000dffd          
14000e00c          *(uint64_t*)arg1 = result_1 + rdx_2;
14000e01b          result = *(uint64_t*)arg1;
14000e01e          *(uint8_t*)(arg1[1] + result + 8) = 0;
14000df76      }
14000df76      
14000e02f      return result;
14000df4e  }


14000e030    int64_t* nimAddCharV1(int64_t* arg1, char arg2)

14000e030  {
14000e04d      prepareAdd(arg1, 1);
14000e065      *(uint8_t*)(arg1[1] + *(uint64_t*)arg1 + 8) = arg2;
14000e06d      int64_t rax_6 = *(uint64_t*)arg1;
14000e070      char rdx_1 = 0;
14000e070      
14000e079      if (rax_6 + 1)
14000e07b          rdx_1 = 1;
14000e07b      
14000e092      if (rdx_1 & 1)
14000e094          return raiseOverflow();
14000e094      
14000e0a3      *(uint64_t*)arg1 = rax_6 + 1;
14000e0b2      int64_t* result = *(uint64_t*)arg1;
14000e0b5      *(uint8_t*)(arg1[1] + result + 8) = 0;
14000e0c1      return result;
14000e030  }


14000e0c2    void add__system_u3639(int64_t* arg1, void* arg2)

14000e0c2  {
14000e0d2      int64_t var_10 = 0;
14000e0d2      
14000e0df      if (!arg2)
14000e0df          return;
14000e0df      
14000e0f1      while (*(uint8_t*)((char*)arg2 + var_10))
14000e0f1      {
14000e10a          nimAddCharV1(arg1, *(uint8_t*)((char*)arg2 + var_10));
14000e10f          var_10 += 1;
14000e0f1      }
14000e0c2  }


14000e121    int64_t* addInt__stdZprivateZdigitsutils_u204(int64_t* arg1, uint64_t arg2)

14000e121  {
14000e138      char const* const var_30 = "addInt";
14000e143      char const* const var_20 =
14000e143          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\private\digitsutils.nim";
14000e147      int64_t var_28 = 0;
14000e14f      int16_t var_18 = 0;
14000e15c      void* var_38;
14000e15c      nimFrame(&var_38);
14000e161      int64_t var_28_1 = 0x74;
14000e170      char const* const var_20_1 =
14000e170          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\private\digitsutils.nim";
14000e17f      addInt__stdZprivateZdigitsutils_u187(arg1, arg2);
14000e18f      return popFrame();
14000e121  }


14000e190    void* auxWriteStackTrace__system_u4293(int64_t* arg1, uint64_t* arg2)

14000e190  {
14000e1ae      char* rax = nimErrorFlag();
14000e1c6      int64_t var_498[0x8];
14000e1c6      nimZeroMem(&var_498, 0x400);
14000e1d2      int64_t* i = arg1;
14000e1d9      int64_t* var_18 = nullptr;
14000e1e4      int64_t var_20 = 0;
14000e1e4      
14000e1ef      while (true)
14000e1ef      {
14000e1ef          char var_31_1 = 0;
14000e1fe          int64_t* rax_1;
14000e1fe          (uint8_t)rax_1 = i;
14000e201          bool var_31_2 = (uint8_t)rax_1;
14000e201          
14000e213          if (var_31_2 == 1)
14000e220              var_31_2 = var_18 <= 0x5f;
14000e220          
14000e235          if (var_31_2 != 1)
14000e235              break;
14000e235          
14000e245          var_498[var_18] = i;
14000e24a          var_18 += 1;
14000e252          var_20 += 1;
14000e264          i = *(uint64_t*)i;
14000e1ef      }
14000e1ef      
14000e275      int64_t* i_4 = i;
14000e275      
14000e284      for (; i; i = *(uint64_t*)i)
14000e286          var_20 += 1;
14000e286      
14000e2a2      int64_t var_30 = 0;
14000e2a2      
14000e2b8      if (var_20 > 0x80)
14000e2b8      {
14000e2d0          var_30 = var_20 - var_18 - 0x1f;
14000e2d7          int64_t var_68_1 = 0;
14000e2d7          
14000e2fb          for (int64_t i_1 = 1; i_1 <= var_30; i_1 += 1)
14000e2fb          {
14000e304              int64_t i_3 = i_1;
14000e304              
14000e313              if (i_4)
14000e31f                  i_4 = *(uint64_t*)i_4;
14000e2fb          }
14000e2fb          
14000e33b          var_498[var_18] = 0;
14000e344          var_18 += 1;
14000e2b8      }
14000e2b8      
14000e34f      while (true)
14000e34f      {
14000e34f          char var_41_1 = 0;
14000e35e          int64_t* rax_8;
14000e35e          (uint8_t)rax_8 = i_4;
14000e361          bool var_41_2 = (uint8_t)rax_8;
14000e361          
14000e373          if (var_41_2 == 1)
14000e380              var_41_2 = var_18 <= 0x7f;
14000e380          
14000e395          if (var_41_2 != 1)
14000e395              break;
14000e395          
14000e3a5          var_498[var_18] = i_4;
14000e3aa          var_18 += 1;
14000e3bc          i_4 = *(uint64_t*)i_4;
14000e34f      }
14000e34f      
14000e3c6      int64_t var_70 = 0;
14000e3d1      int64_t var_78 = 0;
14000e3ee      void* result = (char*)var_18 - 1;
14000e3ee      
14000e404      for (void* i_2 = result; i_2 >= 0; i_2 -= 1)
14000e404      {
14000e427          int64_t var_4b8;
14000e427          
14000e427          if (var_498[i_2])
14000e427          {
14000e55b              uint64_t rax_38 = *(uint64_t*)arg2;
14000e57f              add__system_u3639(arg2, *(uint64_t*)(var_498[i_2] + 0x18));
14000e57f              
14000e597              if (*(uint64_t*)(var_498[i_2] + 0x10) > 0)
14000e597              {
14000e5b3                  prepareAdd(arg2, 1);
14000e5c6                  var_4b8 = 1;
14000e5ca                  void* const var_4b0_3 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_114;
14000e5dc                  appendString(arg2, &var_4b8);
14000e5fb                  addInt__stdZprivateZdigitsutils_u204(arg2, 
14000e5fb                      *(uint64_t*)(var_498[i_2] + 0x10));
14000e610                  prepareAdd(arg2, 1);
14000e623                  var_4b8 = 1;
14000e627                  void* const var_4b0_4 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_122;
14000e639                  appendString(arg2, &var_4b8);
14000e597              }
14000e597              
14000e63e              int64_t var_88_1 = 0;
14000e649              int64_t var_90_1 = 0;
14000e66d              int64_t rax_53 = 0x19 - (*(uint64_t*)arg2 - rax_38);
14000e66d              
14000e678              if (rax_53 <= 0)
14000e678                  rax_53 = 1;
14000e678              
14000e69c              for (int64_t j = 1; j <= rax_53; j += 1)
14000e69c              {
14000e6a5                  int64_t j_1 = j;
14000e6bb                  nimAddCharV1(arg2, 0x20);
14000e69c              }
14000e69c              
14000e6e5              add__system_u3639(arg2, *(uint64_t*)(var_498[i_2] + 8));
14000e6f9              prepareAdd(arg2, 1);
14000e70c              var_4b8 = 1;
14000e710              void* const var_4b0_5 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_124;
14000e722              result = appendString(arg2, &var_4b8);
14000e427          }
14000e427          else
14000e427          {
14000e42d              int64_t var_4a8 = 0;
14000e435              void* result_1 = nullptr;
14000e44c              prepareAdd(arg2, 1);
14000e45f              var_4b8 = 1;
14000e463              void* const var_4b0_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_114;
14000e475              appendString(arg2, &var_4b8);
14000e488              dollar___systemZdollars_u14(&var_4a8, var_30);
14000e497              result = (uint64_t)*(uint8_t*)rax;
14000e497              
14000e49c              if ((uint32_t)result)
14000e49c                  break;
14000e49c              
14000e4b0              prepareAdd(arg2, var_4a8);
14000e4bd              var_4b8 = var_4a8;
14000e4c1              void* result_2 = result_1;
14000e4d3              appendString(arg2, &var_4b8);
14000e4e7              prepareAdd(arg2, 0x14);
14000e4fa              var_4b8 = 0x14;
14000e4fe              void* const var_4b0_2 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_116;
14000e510              appendString(arg2, &var_4b8);
14000e515              result = result_1;
14000e515              
14000e51c              if (result)
14000e51c              {
14000e536                  result = 0x4000000000000000 & *(uint64_t*)result_1;
14000e536                  
14000e53c                  if (!result)
14000e549                      result = deallocShared(result_1);
14000e51c              }
14000e427          }
14000e404      }
14000e404      
14000e741      return result;
14000e190  }


14000e742    uint64_t rawWriteStackTrace__system_u4426(uint64_t* arg1)

14000e742  {
14000e763      int64_t var_18;
14000e763      
14000e763      if (!*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
14000e763      {
14000e771          prepareAdd(arg1, 0x1d);
14000e784          var_18 = 0x1d;
14000e788          void* const var_10 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_4;
14000e797          return appendString(arg1, &var_18);
14000e763      }
14000e763      
14000e7ab      prepareAdd(arg1, 0x22);
14000e7be      var_18 = 0x22;
14000e7c2      void* const var_10_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_112;
14000e7d1      appendString(arg1, &var_18);
14000e7ef      return auxWriteStackTrace__system_u4293(
14000e7ef          *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692), arg1);
14000e742  }


14000e7fc    int64_t* toNimStr(int64_t* arg1, int64_t arg2, int64_t arg3)

14000e7fc  {
14000e81c      int64_t var_38;
14000e81c      nimZeroMem(&var_38, 0x10);
14000e826      void* var_30;
14000e826      
14000e826      if (arg3 > 0)
14000e826      {
14000e83e          int64_t var_10_1 = 0;
14000e846          char rdx = 0;
14000e846          
14000e853          if (arg3 + 1)
14000e855              rdx = 1;
14000e855          
14000e86c          if (!(rdx & 1))
14000e86c          {
14000e87c              char rdx_1 = 0;
14000e87c              
14000e885              if (arg3 + 1 + 8)
14000e887                  rdx_1 = 1;
14000e887              
14000e89e              if (rdx_1 & 1)
14000e8a0                  raiseOverflow();
14000e89e              else if (arg3 + 9 >= 0)
14000e8b1              {
14000e8d3                  int64_t var_18_1 = 0;
14000e8e2                  void* rax_12 = allocSharedImpl(arg3 + 9);
14000e8fb                  *(uint64_t*)rax_12 = arg3;
14000e8fe                  char rdx_3 = 0;
14000e8fe                  
14000e90b                  if (arg3 + 1)
14000e90d                      rdx_3 = 1;
14000e90d                  
14000e924                  if (rdx_3 & 1)
14000e926                      raiseOverflow();
14000e924                  else if (arg3 + 1 >= 0)
14000e934                  {
14000e969                      copyMem__system_u1731((char*)rax_12 + 8, arg2, arg3 + 1);
14000e97a                      var_38 = arg3;
14000e982                      var_30 = rax_12;
14000e934                  }
14000e934                  else
14000e94c                      raiseRangeErrorI(arg3 + 1, 0, 0x7fffffffffffffff);
14000e8b1              }
14000e8b1              else
14000e8c9                  raiseRangeErrorI(arg3 + 9, 0, 0x7fffffffffffffff);
14000e86c          }
14000e86c          else
14000e86e              raiseOverflow();
14000e826      }
14000e826      else
14000e826      {
14000e828          var_38 = 0;
14000e830          var_30 = nullptr;
14000e826      }
14000e826      
14000e992      *(uint64_t*)arg1 = var_38;
14000e995      arg1[1] = var_30;
14000e9a2      return arg1;
14000e7fc  }


14000e9a3    uint64_t nimCStrLen(char* arg1)

14000e9a3  {
14000e9af      int64_t var_10 = 0;
14000e9af      
14000e9bc      if (!arg1)
14000e9be          return 0;
14000e9be      
14000e9c9      int64_t var_18_1 = 0;
14000e9e5      return strlen(arg1);
14000e9a3  }


14000e9f3    int64_t* cstrToNimstr(int64_t* arg1, char* arg2)

14000e9f3  {
14000ea0f      int64_t var_28;
14000ea0f      nimZeroMem(&var_28, 0x10);
14000ea20      int64_t var_38;
14000ea20      nimZeroMem(&var_38, 0x10);
14000ea2a      int64_t var_18;
14000ea2a      int64_t var_10;
14000ea2a      int64_t var_48;
14000ea2a      int64_t var_40;
14000ea2a      
14000ea2a      if (arg2)
14000ea2a      {
14000ea82          toNimStr(&var_48, arg2, nimCStrLen(arg2));
14000ea8f          var_38 = var_48;
14000ea9f          var_18 = var_38;
14000eaa3          var_10 = var_40;
14000ea2a      }
14000ea2a      else
14000ea2a      {
14000ea3d          toNimStr(&var_48, arg2, 0);
14000ea4a          var_28 = var_48;
14000ea5a          var_18 = var_28;
14000ea5e          var_10 = var_40;
14000ea2a      }
14000eab3      *(uint64_t*)arg1 = var_18;
14000eab6      arg1[1] = var_10;
14000eac3      return arg1;
14000e9f3  }


14000eac4    int64_t getCurrentException()

14000eac4  {
14000ead3      char const* const var_40 = "getCurrentException";
14000eade      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000eae2      int64_t var_38 = 0;
14000eaea      int16_t var_28 = 0;
14000eaf7      void* var_48;
14000eaf7      nimFrame(&var_48);
14000eafc      int64_t result = 0;
14000eb04      int64_t var_38_1 = 0xe3;
14000eb13      char const* const var_30_1 =
14000eb13          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\typedthreads.nim";
14000eb36      eqcopy___stdZtypedthreads_u187(&result, 
14000eb36          *(uint64_t*)__emutls_get_address(&__emutls_v.currException__system_u4105), 0);
14000eb3b      popFrame();
14000eb49      return result;
14000eac4  }


14000eb4a    uint64_t isObjDisplayCheck(void* arg1, int16_t arg2, int32_t arg3)

14000eb4a  {
14000eb67      char const* const var_40 = "isObjDisplayCheck";
14000eb72      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000eb76      int64_t var_38 = 0;
14000eb7e      int16_t var_28 = 0;
14000eb8b      void* var_48;
14000eb8b      nimFrame(&var_48);
14000eb90      int64_t var_38_1 = 0x10a;
14000eb9f      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arc.nim";
14000eba3      char var_9 = 0;
14000ebb3      int16_t rax_2;
14000ebb3      (uint8_t)rax_2 = arg2 <= *(uint16_t*)((char*)arg1 + 0x12);
14000ebb6      char var_9_1 = (uint8_t)rax_2;
14000ebb6      
14000ebc2      if (var_9_1 == 1)
14000ebc2      {
14000ebdd          int32_t rax_9;
14000ebdd          (uint8_t)rax_9 = arg3
14000ebdd              == *(uint32_t*)(((int64_t)arg2 << 2) + *(uint64_t*)((char*)arg1 + 0x18));
14000ebe0          var_9_1 = (uint8_t)rax_9;
14000ebc2      }
14000ebc2      
14000ebed      popFrame();
14000ebfb      return (uint64_t)var_9_1;
14000eb4a  }


14000ebfc    uint64_t* dollar___system_u4269(uint64_t* arg1, int64_t* arg2)

14000ebfc  {
14000ec14      int64_t rax = *(uint64_t*)arg2;
14000ec17      int64_t rdx = arg2[1];
14000ec23      int64_t var_78 = 0;
14000ec2b      int64_t var_70 = 0;
14000ec4f      uint64_t var_98;
14000ec4f      rawNewString(&var_98, 0x7d0);
14000ec5c      uint64_t var_68 = var_98;
14000ec64      int64_t var_30 = 0;
14000ec6c      int64_t var_38 = 0;
14000ec6c      
14000ec98      for (int64_t i = 0; i <= rax - 1; i += 1)
14000ec98      {
14000ecc9          if (*(uint64_t*)(i * 0x18 + rdx + 0x10) == -0xa)
14000ecc9          {
14000ecd7              prepareAdd(&var_68, 0x11);
14000ecea              var_98 = 0x11;
14000ecee              void* const var_90_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_129;
14000ecfd              appendString(&var_68, &var_98);
14000ecc9          }
14000ecc9          else if (*(uint64_t*)(i * 0x18 + rdx + 0x10) != -0x64)
14000ed2b          {
14000ed6a              uint64_t rax_22 = var_68;
14000ed98              add__system_u3639(&var_68, *(uint64_t*)(i * 0x18 + rdx + 0x18));
14000ed98              
14000edbf              if (*(uint64_t*)(i * 0x18 + rdx + 0x10) > 0)
14000edbf              {
14000edd1                  prepareAdd(&var_68, 1);
14000ede4                  var_98 = 1;
14000ede8                  void* const var_90_3 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_114;
14000edf7                  appendString(&var_68, &var_98);
14000ee22                  addInt__stdZprivateZdigitsutils_u204(&var_68, 
14000ee22                      *(uint64_t*)(i * 0x18 + rdx + 0x10));
14000ee34                  prepareAdd(&var_68, 1);
14000ee47                  var_98 = 1;
14000ee4b                  void* const var_90_4 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_122;
14000ee5a                  appendString(&var_68, &var_98);
14000edbf              }
14000edbf              
14000ee62              int64_t var_50_1 = 0;
14000ee6a              int64_t var_58_1 = 0;
14000ee82              int64_t rax_44 = 0x19 - (var_68 - rax_22);
14000ee82              
14000ee8d              if (rax_44 <= 0)
14000ee8d                  rax_44 = 1;
14000ee8d              
14000eea5              for (int64_t j = 1; j <= rax_44; j += 1)
14000eea5              {
14000eeab                  int64_t j_1 = j;
14000eebb                  nimAddCharV1(&var_68, 0x20);
14000eea5              }
14000eea5              
14000eeee              add__system_u3639(&var_68, *(uint64_t*)(i * 0x18 + rdx + 8));
14000eeff              prepareAdd(&var_68, 1);
14000ef12              var_98 = 1;
14000ef16              void* const var_90_5 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_124;
14000ef25              appendString(&var_68, &var_98);
14000ed2b          }
14000ed2b          else
14000ed2b          {
14000ed39              prepareAdd(&var_68, 3);
14000ed4c              var_98 = 3;
14000ed50              void* const var_90_2 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_131;
14000ed5f              appendString(&var_68, &var_98);
14000ed2b          }
14000ec98      }
14000ec98      
14000ef41      *(uint64_t*)arg1 = var_68;
14000ef44      int64_t var_90;
14000ef44      arg1[1] = var_90;
14000ef55      return arg1;
14000ebfc  }


14000ef56    int64_t* reportUnhandledErrorAux__system_u4443(void* arg1)

14000ef56  {
14000ef6e      uint64_t var_58;
14000ef6e      rawNewString(&var_58, 0x7d0);
14000ef7b      uint64_t var_28 = var_58;
14000ef7b      
14000ef94      if (*(uint64_t*)((char*)arg1 + 0x28))
14000ef94      {
14000efb0          int64_t rdx_1 = *(uint64_t*)((char*)arg1 + 0x30);
14000efb8          var_58 = *(uint64_t*)((char*)arg1 + 0x28);
14000efbc          int64_t var_50 = rdx_1;
14000efc7          uint64_t var_48;
14000efc7          dollar___system_u4269(&var_48, &var_58);
14000efd7          prepareAdd(&var_28, var_48);
14000efe4          var_58 = var_48;
14000efe8          int64_t* var_40;
14000efe8          int64_t* var_50_1 = var_40;
14000eff7          appendString(&var_28, &var_58);
14000eff7          
14000f01f          if (var_40 && !(0x4000000000000000 & *(uint64_t*)var_40))
14000f028              deallocShared(var_40);
14000ef94      }
14000ef94      else
14000ef9d          rawWriteStackTrace__system_u4426(&var_28);
14000ef9d      
14000f039      prepareAdd(&var_28, 0x1c);
14000f04c      var_58 = 0x1c;
14000f050      void* const var_50_2 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_137;
14000f05f      appendString(&var_28, &var_58);
14000f073      prepareAdd(&var_28, *(uint64_t*)((char*)arg1 + 0x18));
14000f07c      int64_t rdx_9 = *(uint64_t*)((char*)arg1 + 0x20);
14000f084      var_58 = *(uint64_t*)((char*)arg1 + 0x18);
14000f088      int64_t var_50_3 = rdx_9;
14000f097      appendString(&var_28, &var_58);
14000f0a8      prepareAdd(&var_28, 2);
14000f0bb      var_58 = 2;
14000f0bf      void* const var_50_4 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_139;
14000f0ce      appendString(&var_28, &var_58);
14000f0d3      uint64_t var_38 = 0;
14000f0db      int64_t var_30 = 0;
14000f0f2      cstrToNimstr(&var_38, *(uint64_t*)((char*)arg1 + 0x10));
14000f102      prepareAdd(&var_28, var_38);
14000f10f      var_58 = var_38;
14000f113      int64_t var_50_5 = var_30;
14000f122      appendString(&var_28, &var_58);
14000f133      prepareAdd(&var_28, 2);
14000f146      var_58 = 2;
14000f14a      void* const var_50_6 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_141;
14000f159      appendString(&var_28, &var_58);
14000f168      int64_t* result_1;
14000f168      
14000f168      if (!onUnhandledException__system_u4442)
14000f168      {
14000f196          var_58 = var_28;
14000f19a          int64_t* result_3 = result_1;
14000f1a5          showErrorMessage2__system_u4085(&var_58);
14000f168      }
14000f168      else
14000f168      {
14000f16a          int64_t onUnhandledException__system_u4442_1 =
14000f16a              onUnhandledException__system_u4442;
14000f179          var_58 = var_28;
14000f17d          int64_t* result_2 = result_1;
14000f188          onUnhandledException__system_u4442_1(&var_58);
14000f168      }
14000f168      
14000f1aa      int64_t* result = result_1;
14000f1aa      
14000f1b1      if (result)
14000f1b1      {
14000f1c7          result = 0x4000000000000000 & *(uint64_t*)result_1;
14000f1c7          
14000f1cd          if (!result)
14000f1d6              return deallocShared(result_1);
14000f1b1      }
14000f1b1      
14000f1e1      return result;
14000ef56  }


14000f1e2    int64_t* reportUnhandledError__system_u4454(void* arg1)

14000f1e2  {
14000f1f8      if (unhandledExceptionHook__system_u3638)
14000f208          unhandledExceptionHook__system_u3638(arg1);
14000f208      
14000f21f      return reportUnhandledErrorAux__system_u4443(arg1);
14000f1e2  }


14000f220    int64_t eqdestroy___stdZtypedthreads_u184(void** arg1)

14000f220  {
14000f22c      char var_9 = 0;
14000f243      char result = nimDecRefIsLastCyclicDyn(arg1) ^ 1;
14000f243      
14000f248      if (result)
14000f25f          return result;
14000f25f      
14000f251      return nimDestroyAndDispose(arg1);
14000f220  }


14000f260    int64_t* raiseDefect()

14000f260  {
14000f26f      char const* const var_40 = "raiseDefect";
14000f27a      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000f27e      int64_t var_38 = 0;
14000f286      int16_t var_28 = 0;
14000f293      void* var_48;
14000f293      nimFrame(&var_48);
14000f298      int64_t var_10 = 0;
14000f2a0      int64_t var_38_1 = 0x90b;
14000f2af      char const* const var_30_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000f2b3      int64_t* rax = getCurrentException();
14000f2bc      int64_t var_38_2 = 0x90c;
14000f2bc      
14000f2c9      if (rax && isObjDisplayCheck(*(uint64_t*)rax, 2, 0x783b6000) == 1)
14000f2c9      {
14000f2ec          int64_t var_38_3 = 0x90d;
14000f2fb          reportUnhandledError__system_u4454(rax);
14000f300          int64_t var_38_4 = 0x90e;
14000f30d          exit(1);
14000f30d          /* no return */
14000f2c9      }
14000f2c9      
14000f313      int64_t var_38_5 = 0xe3;
14000f322      char const* const var_30_2 =
14000f322          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\std\typedthreads.nim";
14000f32d      eqdestroy___stdZtypedthreads_u184(rax);
14000f33d      return popFrame();
14000f260  }


14000f33e    int64_t popCurrentException()

14000f33e  {
14000f350      int64_t* rax = __emutls_get_address(&__emutls_v.currException__system_u4105);
14000f370      return eqcopy___stdZtypedthreads_u187(rax, *(uint64_t*)(*(uint64_t*)rax + 0x38), 0);
14000f33e  }


14000f371    int32_t rawWriteString(FILE* arg1, int64_t arg2, uint64_t arg3)

14000f371  {
14000f385      int64_t var_10 = 0;
14000f3ac      uint64_t var_10_1 = fwrite(arg2, 1, arg3, arg1);
14000f3b0      int32_t var_14 = 0;
14000f3be      int32_t result = fflush(arg1);
14000f3c3      int32_t result_1 = result;
14000f3cc      return result;
14000f371  }


14000f3cd    int64_t writeToStdErr__system_u4072(int64_t arg1, uint64_t arg2)

14000f3cd  {
14000f407      return rawWriteString(__acrt_iob_func(2), arg1, arg2);
14000f3cd  }


14000f408    uint32_t showErrorMessage__system_u4077(char* arg1, uint64_t arg2)

14000f408  {
14000f418      char* rax = nimErrorFlag();
14000f421      char var_9 = 1;
14000f42f      uint32_t result;
14000f42f      
14000f42f      if (errorMessageWriter__system_u4067)
14000f42f      {
14000f435          int64_t var_28 = 0;
14000f43d          int64_t* var_20_1 = nullptr;
14000f450          cstrToNimstr(&var_28, arg1);
14000f455          int64_t errorMessageWriter__system_u4067_1 = errorMessageWriter__system_u4067;
14000f464          int64_t var_38 = var_28;
14000f468          int64_t* var_30_1 = var_20_1;
14000f473          errorMessageWriter__system_u4067_1(&var_38);
14000f476          var_9 = 0;
14000f476          
14000f49d          if (var_20_1 && !(0x4000000000000000 & *(uint64_t*)var_20_1))
14000f4a6              deallocShared(var_20_1);
14000f4a6          
14000f4b7          if ((uint32_t)*(uint8_t*)rax)
14000f4b7          {
14000f4be              *(uint8_t*)rax = 0;
14000f4c1              raiseDefect();
14000f4c6              popCurrentException();
14000f4b7          }
14000f4b7          
14000f4d2          result = (uint32_t)*(uint8_t*)rax;
14000f42f      }
14000f42f      
14000f4d7      if (!errorMessageWriter__system_u4067 || !result)
14000f4d7      {
14000f4e1          result = (uint32_t)var_9 ^ 1;
14000f4e1          
14000f4e6          if (!(uint8_t)result)
14000f4f3              return writeToStdErr__system_u4072(arg1, arg2);
14000f4d7      }
14000f4d7      
14000f501      return result;
14000f408  }


14000f502    int64_t showErrorMessage2__system_u4085(int64_t* arg1)

14000f502  {
14000f510      uint64_t rax = *(uint64_t*)arg1;
14000f513      int64_t rdx = arg1[1];
14000f52b      uint64_t var_38 = rax;
14000f52f      int64_t var_30 = rdx;
14000f551      return showErrorMessage__system_u4077(nimToCStringConv(&var_38), rax);
14000f502  }


14000f552    uint64_t writeStackTrace__system_u2672()

14000f552  {
14000f55a      char* rax = nimErrorFlag();
14000f563      uint64_t var_28 = 0;
14000f56b      int64_t var_20 = 0;
14000f573      var_28 = 0;
14000f582      void* const result_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_2;
14000f58d      rawWriteStackTrace__system_u4426(&var_28);
14000f59a      uint64_t var_38 = var_28;
14000f59e      void* const result_2 = result_1;
14000f5a9      showErrorMessage2__system_u4085(&var_38);
14000f5b5      uint64_t result = (uint64_t)*(uint8_t*)rax;
14000f5b5      
14000f5ba      if (!(uint32_t)result)
14000f5ba      {
14000f5bc          result = result_1;
14000f5bc          
14000f5c3          if (result)
14000f5c3          {
14000f5d9              result = 0x4000000000000000 & *(uint64_t*)result_1;
14000f5d9              
14000f5df              if (!result)
14000f5e8                  return deallocShared(result_1);
14000f5c3          }
14000f5ba      }
14000f5ba      
14000f5f9      return result;
14000f552  }


14000f5fa    uint32_t callDepthLimitReached__system_u4678()

14000f5fa  {
14000f602      char* rax = nimErrorFlag();
14000f61b      uint64_t var_38;
14000f61b      __builtin_memset(&var_38, 0, 0x20);
14000f62b      writeStackTrace__system_u2672();
14000f630      uint64_t var_48 = 0;
14000f638      int64_t var_40 = 0;
14000f64c      dollar___systemZdollars_u14(&var_38, 0x7d0);
14000f658      uint32_t result = (uint32_t)*(uint8_t*)rax;
14000f658      
14000f65d      if (result)
14000f733          return result;
14000f733      
14000f675      uint64_t var_58;
14000f675      rawNewString(&var_58, var_38 + 0xa7);
14000f682      var_48 = var_58;
14000f698      var_58 = 0x32;
14000f69c      void* const var_50_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_143;
14000f6ab      appendString(&var_48, &var_58);
14000f6b8      var_58 = var_38;
14000f6bc      int64_t var_30;
14000f6bc      int64_t var_50_2 = var_30;
14000f6cb      appendString(&var_48, &var_58);
14000f6de      var_58 = 0x75;
14000f6e2      void* const var_50_3 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_145;
14000f6f1      appendString(&var_48, &var_58);
14000f70e      var_58 = var_48;
14000f712      int64_t var_50;
14000f712      int64_t var_50_4 = var_50;
14000f71d      showErrorMessage2__system_u4085(&var_58);
14000f727      exit(1);
14000f727      /* no return */
14000f5fa  }


14000f734    int64_t nimFrame(void** arg1)

14000f734  {
14000f755      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
14000f783          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
14000f783              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
14000f755      else
14000f75b          *(uint16_t*)((char*)arg1 + 0x22) = 0;
14000f75b      
14000f791      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
14000f79d      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
14000f7a4      *(uint64_t*)rax_8 = arg1;
14000f7ab      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
14000f7ab      
14000f7b3      if (result != 0x7d0)
14000f7c3          return result;
14000f7c3      
14000f7b5      return callDepthLimitReached__system_u4678();
14000f734  }


14000f7c4    uint64_t percentpercent___system_u873(int64_t arg1, int64_t arg2)

14000f7c4  {
14000f7db      void* const var_40 = &data_14002186e;
14000f7e6      char const* const var_30 =
14000f7e6          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
14000f7ea      int64_t var_38 = 0;
14000f7f2      int16_t var_28 = 0;
14000f7ff      void* var_48;
14000f7ff      nimFrame(&var_48);
14000f804      int64_t var_38_1 = 0x18d;
14000f813      char const* const var_30_1 =
14000f813          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\arithmetics.nim";
14000f817      int64_t var_38_2 = 0x191;
14000f836      popFrame();
14000f844      return COMBINE(0, arg1) % arg2;
14000f7c4  }


14000f845    void procAddrError(char* arg1) __noreturn

14000f845  {
14000f86c      rawWrite(__acrt_iob_func(2), "could not import: ");
14000f889      rawWrite(__acrt_iob_func(2), arg1);
14000f8a9      rawWrite(__acrt_iob_func(2), "\n");
14000f8b3      exit(1);
14000f8b3      /* no return */
14000f845  }

14000f8b8                                                                          90                                               .

14000f8b9    int64_t nimGetProcAddr(HMODULE arg1, PSTR arg2)

14000f8b9  {
14000f8f1      int64_t result = GetProcAddress(arg1, arg2);
14000f8f1      
14000f900      if (!result)
14000f900      {
14000f913          char procName[0x60];
14000f913          nimZeroMem(&procName, 0xfa);
14000f918          procName[0] = 0x5f;
14000f932          int64_t i;
14000f932          
14000f932          for (i = 1; i <= 0xf4; i += 1)
14000f932          {
14000f94e              if (!arg2[i - 1])
14000f94e                  break;
14000f94e              
14000f977              procName[i] = arg2[i - 1];
14000f932          }
14000f932          
14000f995          procName[i] = 0x40;
14000f998          int64_t var_30_1 = 0;
14000f9a3          int64_t var_20_1 = 0;
14000f9a3          
14000f9b6          while (true)
14000f9b6          {
14000f9b6              if (var_20_1 > 0x32)
14000f9b6              {
14000fafa                  procAddrError(arg2);
14000fafa                  /* no return */
14000f9b6              }
14000f9b6              
14000f9d5              int64_t i_1 = var_20_1 << 2;
14000f9d5              
14000f9ed              if (i_1 + 0x63 > 0xc6)
14000fa17                  i += 3;
14000f9ed              else if (i_1 + 9 > 0x12)
14000fa0c                  i += 2;
14000f9fe              else
14000fa00                  i += 1;
14000fa00              
14000fa2a              procName[i + 1] = 0;
14000fa2a              
14000fab0              do
14000fab0              {
14000fa2f                  int64_t var_38_1 = 0;
14000fa6f                  procName[i] = percentpercent___system_u873(i_1, 0xa) + 0x30;
14000fa71                  i -= 1;
14000faa1                  i_1 s/= 0xa;
14000fab0              } while (i_1);
14000fab0              
14000fad0              result = GetProcAddress(arg1, &procName);
14000fad0              
14000fadf              if (result)
14000fadf                  break;
14000fadf              
14000fae2              var_20_1 += 1;
14000f9b6          }
14000f900      }
14000f900      
14000fb14      return result;
14000f8b9  }

14000faff                                                                                               eb                                 .
14000fb00  04                                                                                               .

14000fb15    int64_t* sysFatal__system_u4896(int64_t* arg1)

14000fb15  {
14000fb29      int64_t rax = *(uint64_t*)arg1;
14000fb2c      int64_t rdx = arg1[1];
14000fb3f      char const* const var_60 = "sysFatal";
14000fb4a      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000fb4e      int64_t var_58 = 0;
14000fb56      int16_t var_48 = 0;
14000fb63      void* var_68;
14000fb63      nimFrame(&var_68);
14000fb68      int64_t var_38 = 0;
14000fb70      int64_t var_30 = 0;
14000fb78      int64_t var_20 = 0;
14000fb8a      void*** rax_1 = nimNewObj(0x40, 8);
14000fb9e      *(uint64_t*)rax_1 = &NTIv2__lVI5mUyBp9bAT9cco7UvZP8Q_;
14000fbac      rax_1[2] = "FieldDefect";
14000fbb0      int64_t var_58_1 = 0x35;
14000fbbf      char const* const var_50_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000fbc3      int64_t var_58_2 = 0x69e;
14000fbd2      char const* const var_50_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000fbe2      int64_t var_88 = rax;
14000fbe6      int64_t var_80 = rdx;
14000fbf1      eqdup___system_u2662(&var_38, &var_88);
14000fc02      rax_1[3] = var_38;
14000fc06      rax_1[4] = var_30;
14000fc0a      int64_t var_58_3 = 0x35;
14000fc19      char const* const var_50_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14000fc21      int64_t var_98 = 0x35;
14000fc42      raiseExceptionEx(rax_1, "FieldDefect");
14000fc57      return popFrame();
14000fb15  }


14000fc58    int64_t* raiseFieldErrorStr(int64_t* arg1, int64_t* arg2)

14000fc58  {
14000fc66      uint64_t rcx = *(uint64_t*)arg1;
14000fc69      int64_t rbx_1 = arg1[1];
14000fc78      uint64_t rax = *(uint64_t*)arg2;
14000fc7b      int64_t rdx = arg2[1];
14000fc97      uint64_t var_38 = 0;
14000fc9f      int64_t var_30;
14000fc9f      __builtin_memset(&var_30, 0, 0x18);
14000fcbd      uint64_t var_68;
14000fcbd      rawNewString(&var_68, rax + rcx + 1);
14000fcca      var_38 = var_68;
14000fcda      var_68 = rcx;
14000fcde      int64_t var_60 = rbx_1;
14000fced      appendString(&var_38, &var_68);
14000fcfa      var_68 = rax;
14000fcfe      int64_t var_60_1 = rdx;
14000fd0d      appendString(&var_38, &var_68);
14000fd20      var_68 = 1;
14000fd24      void* const var_60_2 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_147;
14000fd33      appendString(&var_38, &var_68);
14000fd50      var_68 = var_38;
14000fd54      int64_t* result_1;
14000fd54      int64_t* result_2 = result_1;
14000fd5f      sysFatal__system_u4896(&var_68);
14000fd64      int64_t* result = result_1;
14000fd64      
14000fd6b      if (result)
14000fd6b      {
14000fd81          result = 0x4000000000000000 & *(uint64_t*)result_1;
14000fd81          
14000fd87          if (!result)
14000fd90              return deallocShared(result_1);
14000fd6b      }
14000fd6b      
14000fd9c      return result;
14000fc58  }


14000fd9d    int64_t* reset__stdZexitprocs_u58(char* arg1)

14000fd9d  {
14000fdb0      char const* const var_30 = "reset";
14000fdbb      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000fdbf      int64_t var_28 = 0;
14000fdc7      int16_t var_18 = 0;
14000fdd4      void* var_38;
14000fdd4      nimFrame(&var_38);
14000fdd9      int64_t var_28_1 = 0x3aa;
14000fde8      char const* const var_20_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
14000fdf3      eqdestroy___stdZexitprocs_u94(arg1);
14000fdf8      int64_t var_28_2 = 0x3ab;
14000fe07      eqwasMoved___stdZexitprocs_u91(arg1);
14000fe17      return popFrame();
14000fd9d  }


14000fe18    int64_t* shrink__stdZexitprocs_u38(int64_t* arg1, int64_t arg2)

14000fe18  {
14000fe38      int64_t var_28_1;
14000fe38      __builtin_memset(&var_28_1, 0, 0x18);
14000fe44      int64_t rax_1 = *(uint64_t*)arg1;
14000fe4b      char rdx = 0;
14000fe4b      
14000fe58      if (rax_1 - 1)
14000fe5a          rdx = 1;
14000fe5a      
14000fe71      if (rdx & 1)
14000fe73          return raiseOverflow();
14000fe73      
14000fe9e      for (int64_t i = rax_1 - 1; arg2 <= i; i -= 1)
14000fe9e      {
14000febe          if (i < 0 || i >= *(uint64_t*)arg1)
14000fed2              return raiseIndexError2(i, *(uint64_t*)arg1 - 1);
14000fed2          
14000fefc          reset__stdZexitprocs_u58(i * 0x18 + arg1[1] + 8);
14000ff01          char rdx_3 = 0;
14000ff01          
14000ff0e          if (i - 1)
14000ff10              rdx_3 = 1;
14000ff10          
14000ff27          if (rdx_3 & 1)
14000ff29              return raiseOverflow();
14000fe9e      }
14000fe9e      
14000ff46      *(uint64_t*)arg1 = arg2;
14000ff51      return arg1;
14000fe18  }


14000ff52    int64_t* setLen__stdZexitprocs_u31(int64_t* arg1, int64_t* arg2)

14000ff52  {
14000ff78      if (arg2 < *(uint64_t*)arg1)
14000ff85          return shrink__stdZexitprocs_u38(arg1, arg2);
14000ff85      
14000ff94      int64_t* result_2 = *(uint64_t*)arg1;
14000ffa3      int64_t* result = arg2;
14000ffa3      
14000ffab      if (result > result_2)
14000ffab      {
14000ffba          char var_9_1 = 0;
14000ffc9          int64_t rax_8;
14000ffc9          (uint8_t)rax_8 = !arg1[1];
14000ffcc          char var_9_2 = (uint8_t)rax_8;
14000ffcc          
14000ffd3          if (!var_9_2)
14000ffd3          {
14000fff1              int64_t rax_11;
14000fff1              (uint8_t)rax_11 = arg2 > (-0x4000000000000001 & *(uint64_t*)arg1[1]);
14000fff4              var_9_2 = (uint8_t)rax_11;
14000ffd3          }
14000ffd3          
140010003          if (var_9_2 == 1)
140010003          {
140010005              char rdx_2 = 0;
140010005              
140010012              if ((char*)arg2 + -(result_2))
140010014                  rdx_2 = 1;
140010014              
14001002b              if (rdx_2 & 1)
14001002d                  return raiseOverflow();
14001002d              
140010037              int64_t var_40_1 = 0;
140010075              arg1[1] =
140010075                  prepareSeqAddUninit(result_2, arg1[1], (char*)arg2 - result_2, 0x18, 8);
140010003          }
140010003          
140010084          *(uint64_t*)arg1 = arg2;
140010087          int64_t var_48_1 = 0;
14001008f          int64_t var_50_1 = 0;
1400100a3          int64_t* result_1 = result_2;
1400100a3          
1400100a7          while (true)
1400100a7          {
1400100a7              result = result_1;
1400100a7              
1400100af              if (result >= arg2)
1400100af                  break;
1400100af              
1400100c9              char var_78;
1400100c9              nimZeroMem(&var_78, 0x18);
1400100da              nimZeroMem(&var_78, 0x18);
1400100df              var_78 = 0;
1400100f3              int64_t var_70;
1400100f3              nimZeroMem(&var_70, 0x10);
140010111              void* rax_31 = result_1 * 0x18 + arg1[1];
140010118              *(uint64_t*)((char*)rax_31 + 8) = var_78;
140010120              *(uint64_t*)((char*)rax_31 + 0x10) = var_70;
140010128              int64_t var_68;
140010128              *(uint64_t*)((char*)rax_31 + 0x18) = var_68;
14001012c              char rdx_10 = 0;
14001012c              
140010139              if ((char*)result_1 + 1)
14001013b                  rdx_10 = 1;
14001013b              
140010152              if (rdx_10 & 1)
140010154                  return raiseOverflow();
140010154              
14001015f              result_1 += 1;
1400100a7          }
14000ffab      }
14000ffab      
140010175      return result;
14000ff52  }


140010176    int64_t* add__stdZexitprocs_u190(int64_t* arg1, int64_t* arg2)

140010176  {
14001018c      int64_t rax_1 = *(uint64_t*)arg1;
1400101a3      char var_19 = 0;
1400101b2      int64_t rax_5;
1400101b2      (uint8_t)rax_5 = !arg1[1];
1400101b5      char var_19_1 = (uint8_t)rax_5;
1400101b5      
1400101bc      if (!var_19_1)
1400101bc      {
1400101be          char rdx = 0;
1400101be          
1400101cb          if (rax_1 + 1)
1400101cd              rdx = 1;
1400101cd          
1400101e4          if (rdx & 1)
1400101e6              return raiseOverflow();
1400101e6          
14001020f          int64_t rax_12;
14001020f          (uint8_t)rax_12 = (*(uint64_t*)arg1[1] & 0xbfffffffffffffff) < rax_1 + 1;
140010212          var_19_1 = (uint8_t)rax_12;
1400101bc      }
1400101bc      
140010221      if (var_19_1 == 1)
140010221      {
140010223          int64_t var_40_1 = 0;
140010260          arg1[1] = prepareSeqAddUninit(rax_1, arg1[1], 1, 0x18, 8);
140010221      }
140010221      
140010267      char rdx_5 = 0;
140010267      
140010274      if (rax_1 + 1)
140010276          rdx_5 = 1;
140010276      
14001028d      if (rdx_5 & 1)
14001028f          return raiseOverflow();
14001028f      
14001029f      *(uint64_t*)arg1 = rax_1 + 1;
1400102bb      int64_t* result = rax_1 * 0x18 + arg1[1];
1400102c1      result[1] = *(uint64_t*)arg2;
1400102c9      result[2] = arg2[1];
1400102d1      result[3] = arg2[2];
1400102dc      return result;
140010176  }


1400102dd    int64_t* eqdup___system_u4017(int64_t* arg1, char arg2, int64_t* arg3)

1400102dd  {
1400102eb      int64_t rcx = *(uint64_t*)arg1;
1400102ee      int64_t* result = arg1[1];
14001030f      nimZeroMem(arg3, 0x10);
14001031c      int64_t var_20 = arg3[1];
140010328      arg3[1] = result;
140010334      *(uint64_t*)arg3 = rcx;
140010334      
14001033e      if (!result)
140010359          return result;
140010359      
14001034a      return nimIncRefCyclic(result);
1400102dd  }


14001035a    void signalHandler(int32_t arg1) __noreturn

14001035a  {
140010365      uint64_t var_18 = 0;
14001036d      int64_t var_10 = 0;
140010381      uint64_t var_28;
140010381      rawNewString(&var_28, 0x7d0);
14001038e      var_18 = var_28;
14001039d      rawWriteStackTrace__system_u4426(&var_18);
14001039d      
1400103a6      if (arg1 == 2)
1400103a6      {
1400103b4          prepareAdd(&var_18, 0x1f);
1400103c7          var_28 = 0x1f;
1400103cb          void* const var_20_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_155;
1400103da          appendString(&var_18, &var_28);
1400103a6      }
1400103a6      else if (arg1 == 0xb)
1400103e9      {
1400103f7          prepareAdd(&var_18, 0x3d);
14001040a          var_28 = 0x3d;
14001040e          void* const var_20_2 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_157;
14001041d          appendString(&var_18, &var_28);
1400103e9      }
1400103e9      else if (arg1 == 0x16)
14001042c      {
14001043a          prepareAdd(&var_18, 0x1f);
14001044d          var_28 = 0x1f;
140010451          void* const var_20_3 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_159;
140010460          appendString(&var_18, &var_28);
14001042c      }
14001042c      else if (arg1 == 8)
14001046f      {
14001047d          prepareAdd(&var_18, 0x1a);
140010490          var_28 = 0x1a;
140010494          void* const var_20_4 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_161;
1400104a3          appendString(&var_18, &var_28);
14001046f      }
14001046f      else if (arg1 != 4)
1400104af      {
1400104f8          prepareAdd(&var_18, 0xf);
14001050b          var_28 = 0xf;
14001050f          void* const var_20_6 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_167;
14001051e          appendString(&var_18, &var_28);
1400104af      }
1400104af      else
1400104af      {
1400104bd          prepareAdd(&var_18, 0x1b);
1400104d0          var_28 = 0x1b;
1400104d4          void* const var_20_5 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_163;
1400104e3          appendString(&var_18, &var_28);
1400104af      }
1400104af      
14001052b      var_28 = var_18;
14001052f      int64_t var_20;
14001052f      int64_t var_20_7 = var_20;
14001053a      showErrorMessage2__system_u4085(&var_28);
140010544      exit(1);
140010544      /* no return */
14001035a  }

140010549                             90                                                                             .

14001054a    _crt_signal_t registerSignalHandler__system_u4698()

14001054a  {
140010552      int64_t var_10 = 0;
14001056e      _crt_signal_t var_10_1 = signal(2, signalHandler);
140010572      int64_t var_18 = 0;
14001058e      _crt_signal_t var_18_1 = signal(0xb, signalHandler);
140010592      int64_t var_20 = 0;
1400105ae      _crt_signal_t var_20_1 = signal(0x16, signalHandler);
1400105b2      int64_t var_28 = 0;
1400105ce      _crt_signal_t var_28_1 = signal(8, signalHandler);
1400105d2      int64_t var_30 = 0;
1400105e9      _crt_signal_t result = signal(4, signalHandler);
1400105ee      _crt_signal_t result_1 = result;
1400105f8      return result;
14001054a  }


1400105f9    int64_t* colonanonymous___system_u9048()

1400105f9  {
140010608      char const* const var_30 = ":anonymous";
140010613      char const* const var_20 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
140010617      int64_t var_28 = 0;
14001061f      int16_t var_18 = 0;
14001062c      void* var_38;
14001062c      nimFrame(&var_38);
140010642      DeleteCriticalSection(&echoLock__system_u9047);
14001064f      return popFrame();
1400105f9  }


140010650    int64_t* mnewString(int64_t* arg1, int64_t arg2)

140010650  {
14001066c      int64_t var_38;
14001066c      nimZeroMem(&var_38, 0x10);
140010676      void* var_30;
140010676      
140010676      if (arg2 > 0)
140010676      {
14001068e          int64_t var_10_1 = 0;
140010696          char rdx = 0;
140010696          
1400106a3          if (arg2 + 1)
1400106a5              rdx = 1;
1400106a5          
1400106bc          if (!(rdx & 1))
1400106bc          {
1400106cc              char rdx_1 = 0;
1400106cc              
1400106d5              if (arg2 + 1 + 8)
1400106d7                  rdx_1 = 1;
1400106d7              
1400106ee              if (rdx_1 & 1)
1400106f0                  raiseOverflow();
1400106ee              else if (arg2 + 9 >= 0)
1400106fe              {
14001071d                  int64_t var_18_1 = 0;
14001072c                  void* rax_12 = allocShared0Impl__system_u1762(arg2 + 9);
140010745                  *(uint64_t*)rax_12 = arg2;
140010754                  var_38 = arg2;
14001075c                  var_30 = rax_12;
1400106fe              }
1400106fe              else
140010716                  raiseRangeErrorI(arg2 + 9, 0, 0x7fffffffffffffff);
1400106bc          }
1400106bc          else
1400106be              raiseOverflow();
140010676      }
140010676      else
140010676      {
140010678          var_38 = 0;
140010680          var_30 = nullptr;
140010676      }
140010676      
14001076c      *(uint64_t*)arg1 = var_38;
14001076f      arg1[1] = var_30;
14001077c      return arg1;
140010650  }


14001077d    int64_t* nimPrepareStrMutationImpl__system_u2410(int64_t* arg1)

14001077d  {
14001078d      int64_t rax_1 = arg1[1];
140010799      int64_t rax_3 = *(uint64_t*)arg1;
14001079c      char rdx = 0;
14001079c      
1400107a5      if (rax_3 + 1)
1400107a7          rdx = 1;
1400107a7      
1400107be      if (rdx & 1)
1400107c0          return raiseOverflow();
1400107c0      
1400107ce      char rdx_1 = 0;
1400107ce      
1400107d7      if (rax_3 + 1 + 8)
1400107d9          rdx_1 = 1;
1400107d9      
1400107f0      if (rdx_1 & 1)
1400107f2          return raiseOverflow();
1400107f2      
140010803      if (rax_3 + 9 < 0)
14001081b          return raiseRangeErrorI(rax_3 + 9, 0, 0x7fffffffffffffff);
14001081b      
140010825      int64_t var_18_1 = 0;
140010845      arg1[1] = allocSharedImpl(rax_3 + 9);
140010858      *(uint64_t*)arg1[1] = *(uint64_t*)arg1;
14001085f      int64_t rax_20 = *(uint64_t*)arg1;
140010862      char rdx_5 = 0;
140010862      
14001086b      if (rax_20 + 1)
14001086d          rdx_5 = 1;
14001086d      
140010884      if (rdx_5 & 1)
140010886          return raiseOverflow();
140010886      
140010894      if (rax_20 + 1 >= 0)
1400108d1          return copyMem__system_u1731(arg1[1] + 8, rax_1 + 8, rax_20 + 1);
1400108d1      
1400108ac      return raiseRangeErrorI(rax_20 + 1, 0, 0x7fffffffffffffff);
14001077d  }


1400108de    int64_t* sysFatal__system_u5276(int64_t* arg1)

1400108de  {
1400108f2      int64_t rax = *(uint64_t*)arg1;
1400108f5      int64_t rdx = arg1[1];
140010908      char const* const var_60 = "sysFatal";
140010913      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
140010917      int64_t var_58 = 0;
14001091f      int16_t var_48 = 0;
14001092c      void* var_68;
14001092c      nimFrame(&var_68);
140010931      int64_t var_38 = 0;
140010939      int64_t var_30 = 0;
140010941      int64_t var_20 = 0;
140010953      void*** rax_1 = nimNewObj(0x40, 8);
140010967      *(uint64_t*)rax_1 = &NTIv2__k6VacnfEHcFyOMal5EruvA_;
140010975      rax_1[2] = "DivByZeroDefect";
140010979      int64_t var_58_1 = 0x35;
140010988      char const* const var_50_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
14001098c      int64_t var_58_2 = 0x69e;
14001099b      char const* const var_50_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
1400109ab      int64_t var_88 = rax;
1400109af      int64_t var_80 = rdx;
1400109ba      eqdup___system_u2662(&var_38, &var_88);
1400109cb      rax_1[3] = var_38;
1400109cf      rax_1[4] = var_30;
1400109d3      int64_t var_58_3 = 0x35;
1400109e2      char const* const var_50_3 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\fatal.nim";
1400109ea      int64_t var_98 = 0x35;
140010a0b      raiseExceptionEx(rax_1, "DivByZeroDefect");
140010a20      return popFrame();
1400108de  }


140010a21    int64_t* raiseDivByZero()

140010a21  {
140010a37      int64_t var_18 = 0x10;
140010a3b      void* const var_10 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_174;
140010a51      return sysFatal__system_u5276(&var_18);
140010a21  }


140010a52    int64_t* raiseRangeErrorU()

140010a52  {
140010a5a      int64_t rcx;
140010a5a      int64_t arg_8 = rcx;
140010a5e      int64_t rdx;
140010a5e      int64_t arg_10 = rdx;
140010a62      int64_t r8;
140010a62      int64_t arg_18 = r8;
140010a74      int64_t var_18 = 0x12;
140010a78      void* const var_10 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_13;
140010a8e      return sysFatal__system_u4979(&var_18);
140010a52  }


140010a8f    int64_t* raiseEIO__system_u9050(int64_t* arg1)

140010a8f  {
140010aa3      int64_t rax = *(uint64_t*)arg1;
140010aa6      int64_t rdx = arg1[1];
140010ab9      char const* const var_60 = "raiseEIO";
140010ac4      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
140010ac8      int64_t var_58 = 0;
140010ad0      int16_t var_48 = 0;
140010add      void* var_68;
140010add      nimFrame(&var_68);
140010ae2      int64_t var_38 = 0;
140010aea      int64_t var_30 = 0;
140010af2      int64_t var_20 = 0;
140010b04      void*** rax_1 = nimNewObj(0x40, 8);
140010b18      *(uint64_t*)rax_1 = &NTIv2__txzrG6zQAbHR6Hap9b2RC7g_;
140010b26      rax_1[2] = "IOError";
140010b2a      int64_t var_58_1 = 0xb82;
140010b39      char const* const var_50_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
140010b3d      int64_t var_58_2 = 0x69e;
140010b51      int64_t var_88 = rax;
140010b55      int64_t var_80 = rdx;
140010b60      eqdup___system_u2662(&var_38, &var_88);
140010b71      rax_1[3] = var_38;
140010b75      rax_1[4] = var_30;
140010b7d      rax_1[1] = 0;
140010b85      int64_t var_58_3 = 0xb82;
140010b91      int64_t var_98 = 0xb82;
140010bb2      raiseExceptionEx(rax_1, "IOError");
140010bc7      return popFrame();
140010a8f  }


140010bc8    int64_t* writeWindows__system_u9129(FILE* arg1, int64_t* arg2, char arg3)

140010bc8  {
140010be0      int64_t rax = *(uint64_t*)arg2;
140010be3      int64_t rdx = arg2[1];
140010bfc      char const* const var_60 = "writeWindows";
140010c07      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
140010c0b      int64_t var_58 = 0;
140010c13      int16_t var_48 = 0;
140010c20      void* var_68;
140010c20      nimFrame(&var_68);
140010c25      char* rax_2 = nimErrorFlag();
140010c2e      int64_t var_58_1 = 0xba0;
140010c36      int32_t var_2c = 0;
140010c45      int64_t var_98 = rax;
140010c49      int64_t var_90 = rdx;
140010c7a      int64_t var_20 = (int64_t)fprintf(arg1, "%s", nimToCStringConv(&var_98));
140010c7e      int64_t var_58_2 = 0xba1;
140010c7e      
140010c8e      while (var_20 < rax)
140010c8e      {
140010c94          int64_t var_58_3 = 0xba2;
140010c94          
140010cab          if (var_20 < 0 || var_20 >= rax)
140010cab          {
140010cbc              raiseIndexError2(var_20, rax - 1);
140010cc1              break;
140010cab          }
140010cab          
140010cda          if (!*(uint8_t*)(var_20 + rdx + 8))
140010cda          {
140010ce0              int64_t var_58_4 = 0xba3;
140010cfc              int64_t var_58_5 = 0xba4;
140010cfc              
140010d08              if (fputc(0, arg1))
140010d08              {
140010d0a                  int64_t var_58_6 = 0xba5;
140010d0a                  
140010d1b                  if (arg3 == 1)
140010d1b                  {
140010d2b                      var_98 = 0x1b;
140010d2f                      void* const var_90_1 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_177;
140010d3a                      raiseEIO__system_u9050(&var_98);
140010d1b                  }
140010d1b                  
140010d4b                  if (arg3 != 1 || !(uint32_t)*(uint8_t*)rax_2)
140010d54                      int64_t var_58_7 = 0xba6;
140010d54                  
140010d4b                  break;
140010d08              }
140010d08              
140010d62              int64_t var_58_8 = 0xba7;
140010d6a              char rdx_6 = 0;
140010d6a              
140010d77              if (var_20 + 1)
140010d79                  rdx_6 = 1;
140010d79              
140010d90              if (rdx_6 & 1)
140010d90              {
140010d92                  raiseOverflow();
140010d97                  break;
140010d90              }
140010d90              
140010da0              var_20 += 1;
140010da4              continue;
140010cda          }
140010cda          
140010daa          int64_t var_58_9 = 0xba9;
140010daa          
140010dc1          if (var_20 < 0 || var_20 >= rax)
140010dc1          {
140010dd2              raiseIndexError2(var_20, rax - 1);
140010dd7              break;
140010dc1          }
140010dc1          
140010dfc          int32_t rax_35 = fprintf(arg1, "%s", var_20 + rdx + 8);
140010e04          int64_t var_58_10 = 0xbaa;
140010e04          
140010e10          if (rax_35 <= 0)
140010e10          {
140010e12              int64_t var_58_11 = 0xbab;
140010e12              
140010e23              if (arg3 == 1)
140010e23              {
140010e33                  var_98 = 0x1b;
140010e37                  void* const var_90_2 = &TM__Q5wkpxktOdTGvlSRo9bzt9aw_177;
140010e42                  raiseEIO__system_u9050(&var_98);
140010e23              }
140010e23              
140010e53              if (arg3 != 1 || !(uint32_t)*(uint8_t*)rax_2)
140010e58                  int64_t var_58_12 = 0xbac;
140010e58              
140010e53              break;
140010e10          }
140010e10          
140010e63          int64_t var_58_13 = 0xbad;
140010e6e          int64_t rax_42 = (int64_t)rax_35;
140010e70          char rcx_9 = 0;
140010e70          
140010e7c          if (rax_42 + var_20)
140010e7e              rcx_9 = 1;
140010e7e          
140010e95          if (rcx_9 & 1)
140010e95          {
140010e97              raiseOverflow();
140010e9c              break;
140010e95          }
140010e95          
140010ea2          var_20 += rax_42;
140010ea2          continue;
140010c8e      }
140010c8e      
140010ec1      return popFrame();
140010bc8  }


140010ec2    int64_t* echoBinSafe(void* arg1, int64_t arg2)

140010ec2  {
140010edc      char const* const var_60 = "echoBinSafe";
140010ee7      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
140010eeb      int64_t var_58 = 0;
140010ef3      int16_t var_48 = 0;
140010f00      void* var_68;
140010f00      nimFrame(&var_68);
140010f05      char* rax = nimErrorFlag();
140010f0e      int64_t var_58_1 = 0xb96;
140010f27      EnterCriticalSection(&echoLock__system_u9047);
140010f29      int64_t var_20 = 0;
140010f31      int64_t var_58_2 = 0x12;
140010f40      char const* const var_50_1 =
140010f40          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators.nim";
140010f44      int64_t var_10 = 0;
140010f4c      int64_t var_58_3 = 0x13;
140010f4c      
140010f5c      while (true)
140010f5c      {
140010f5c          if (var_10 >= arg2)
140010f5c          {
140011023              int64_t var_58_7 = 0xbb2;
140011032              char const* const var_50_4 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
140011036              int64_t var_28_1 = 0;
140011069              uint64_t var_28_2 = fwrite(&data_140021159, 1, 1, __acrt_iob_func(1));
14001106d              int64_t var_58_8 = 0xbb3;
140011075              int32_t var_2c_1 = 0;
140011092              int32_t var_2c_2 = fflush(__acrt_iob_func(1));
140011095              int64_t var_58_9 = 0xbb7;
1400110ae              LeaveCriticalSection(&echoLock__system_u9047);
1400110b0              break;
140010f5c          }
140010f5c          
140010f62          int64_t var_58_4 = 0xb97;
140010f71          char const* const var_50_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
140010f71          
140010f84          if (var_10 < 0 || var_10 >= arg2)
140010f84          {
140010f95              raiseIndexError2(var_10, arg2 - 1);
140010f9a              break;
140010f84          }
140010f84          
140010fae          int64_t* rax_8 = (char*)arg1 + (var_10 << 4);
140010fb5          int64_t var_58_5 = 0xbae;
140010fc9          FILE* rax_9 = __acrt_iob_func(1);
140010fd2          int64_t rdx_2 = rax_8[1];
140010fd9          int64_t var_78 = *(uint64_t*)rax_8;
140010fdd          int64_t var_70_1 = rdx_2;
140010fee          writeWindows__system_u9129(rax_9, &var_78, 0);
140010fee          
140010fff          if ((uint32_t)*(uint8_t*)rax)
140010fff              break;
140010fff          
140011005          int64_t var_58_6 = 0xd;
140011014          char const* const var_50_3 =
140011014              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators.nim";
140011018          var_10 += 1;
14001101d          continue;
140010f5c      }
140010f5c      
1400110c1      return popFrame();
140010ec2  }


1400110c2    int64_t nimTestErrorFlag()

1400110c2  {
1400110cd      char var_19 = 0;
1400110e3      char var_19_1 =
1400110e3          *(uint8_t*)__emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
1400110e3      
1400110ef      if (var_19_1 == 1)
1400110ef      {
140011106          int64_t rax_5;
140011106          (uint8_t)rax_5 =
140011106              *(uint64_t*)__emutls_get_address(&__emutls_v.currException__system_u4105);
140011109          var_19_1 = (uint8_t)rax_5;
1400110ef      }
1400110ef      
140011113      char result = var_19_1 ^ 1;
140011113      
140011118      if (result)
140011156          return result;
140011156      
140011124      int64_t* rax_7 = __emutls_get_address(&__emutls_v.currException__system_u4105);
140011132      reportUnhandledError__system_u4454(*(uint64_t*)rax_7);
14001113f      eqsink___stdZtypedthreads_u195(rax_7, 0);
140011149      exit(1);
140011149      /* no return */
1400110c2  }


140011157    int64_t atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatssystemdotnim_Init000()

140011157  {
14001115f      registerSignalHandler__system_u4698();
140011175      InitializeCriticalSection(&echoLock__system_u9047);
140011181      atexit(colonanonymous___system_u9048);
140011191      return nimTestErrorFlag();
140011157  }

140011192                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

1400111a0    int64_t floorMod__pureZtimes_u1259(int64_t arg1, int64_t arg2) __pure

1400111a0  {
1400111ba      int64_t result = (int128_t)arg1 % arg2;
1400111be      char var_11 = 0;
1400111c2      char var_12 = 0;
1400111ce      char var_12_1 = result > 0;
1400111ce      
1400111da      if (var_12_1 == 1)
1400111e4          var_12_1 = (char)(arg2 >> 0x3f);
1400111e4      
1400111ee      char var_11_1 = var_12_1;
1400111ee      
1400111f5      if (!var_11_1)
1400111f5      {
1400111f7          char var_13_1 = 0;
140011203          uint8_t var_13_2 = (char)(result >> 0x3f);
140011203          
14001120f          if (var_13_2 == 1)
140011219              var_13_2 = arg2 > 0;
140011219          
140011223          var_11_1 = var_13_2;
1400111f5      }
1400111f5      
140011232      if (var_11_1 != 1)
140011248          return result;
140011248      
140011238      return result + arg2;
1400111a0  }


140011249    int64_t floorDiv__pureZtimes_u317(int64_t arg1, int64_t arg2) __pure

140011249  {
140011263      int64_t result = (int128_t)arg1 / arg2;
14001126d      int64_t temp1 = (int128_t)arg1 % arg2;
140011275      char var_11 = 0;
140011279      char var_12 = 0;
140011285      char var_12_1 = temp1 > 0;
140011285      
140011291      if (var_12_1 == 1)
14001129b          var_12_1 = (char)(arg2 >> 0x3f);
14001129b      
1400112a5      uint8_t var_11_1 = var_12_1;
1400112a5      
1400112ac      if (!var_11_1)
1400112ac      {
1400112ae          char var_13_1 = 0;
1400112ba          uint8_t var_13_2 = (char)(temp1 >> 0x3f);
1400112ba          
1400112c6          if (var_13_2 == 1)
1400112d0              var_13_2 = arg2 > 0;
1400112d0          
1400112da          var_11_1 = var_13_2;
1400112ac      }
1400112ac      
1400112e9      if (var_11_1 != 1)
1400112fc          return result;
1400112fc      
1400112eb      return result - 1;
140011249  }

1400112fd                                                                                         90 90 90                               ...

140011300    void* const nimToCStringConv(int64_t* arg1)

140011300  {
140011324      if (*(uint64_t*)arg1)
14001133c          return arg1[1] + 8;
14001133c      
14001132d      return &_.rdata;
140011300  }


14001134b    int64_t nimFrame(void** arg1)

14001134b  {
14001136c      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
14001139a          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
14001139a              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
14001136c      else
140011372          *(uint16_t*)((char*)arg1 + 0x22) = 0;
140011372      
1400113a8      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
1400113b4      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
1400113bb      *(uint64_t*)rax_8 = arg1;
1400113c2      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
1400113c2      
1400113ca      if (result != 0x7d0)
1400113da          return result;
1400113da      
1400113cc      return callDepthLimitReached__system_u4678();
14001134b  }


1400113db    int64_t* popFrame()

1400113db  {
1400113ed      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
1400113f8      *(uint64_t*)result = **(uint64_t**)result;
140011401      return result;
1400113db  }


140011402    HMODULE loadLib__pureZdynlib_u3(int64_t* arg1)

140011402  {
140011416      int64_t rcx = *(uint64_t*)arg1;
140011419      int64_t rbx_1 = arg1[1];
140011427      char rdx;
140011427      char arg_10 = rdx;
140011431      char const* const var_50 = "loadLib";
14001143c      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\pure\dynlib.nim";
140011440      int64_t var_48 = 0;
140011448      int16_t var_38 = 0;
140011455      void* var_58;
140011455      nimFrame(&var_58);
14001145a      int64_t var_48_1 = 0xbb;
140011469      char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\pure\dynlib.nim";
14001146d      int64_t var_20 = 0;
14001147d      int64_t var_78 = rcx;
140011481      int64_t var_70 = rbx_1;
14001149b      HMODULE result = LoadLibraryA(nimToCStringConv(&var_78));
1400114a9      popFrame();
1400114bb      return result;
140011402  }


1400114bc    int64_t symAddr__pureZdynlib_u74(HMODULE arg1, PSTR arg2)

1400114bc  {
1400114d3      char const* const var_40 = "symAddr";
1400114de      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\pure\dynlib.nim";
1400114e2      int64_t var_38 = 0;
1400114ea      int16_t var_28 = 0;
1400114f7      void* var_48;
1400114f7      nimFrame(&var_48);
1400114fc      int64_t var_38_1 = 0xc1;
140011504      int64_t var_10 = 0;
14001151e      int64_t result = GetProcAddress(arg1, arg2);
14001152c      popFrame();
14001153a      return result;
1400114bc  }

14001153b                                                                                   90 90 90 90 90                             .....

140011540    int64_t nimErrorFlag()

140011540  {
140011564      return __emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
140011540  }


140011565    int64_t nimFrame(void** arg1)

140011565  {
140011586      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
1400115b4          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
1400115b4              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
140011586      else
14001158c          *(uint16_t*)((char*)arg1 + 0x22) = 0;
14001158c      
1400115c2      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
1400115ce      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
1400115d5      *(uint64_t*)rax_8 = arg1;
1400115dc      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
1400115dc      
1400115e4      if (result != 0x7d0)
1400115f4          return result;
1400115f4      
1400115e6      return callDepthLimitReached__system_u4678();
140011565  }


1400115f5    int64_t* popFrame()

1400115f5  {
140011607      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140011612      *(uint64_t*)result = **(uint64_t**)result;
14001161b      return result;
1400115f5  }


14001161c    uint64_t rdFileTime__windowsZwinlean_u282(int64_t arg1)

14001161c  {
14001162f      char const* const var_40 = "rdFileTime";
14001163a      char const* const var_30 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\windows\winlean.nim";
14001163e      int64_t var_38 = 0;
140011646      int16_t var_28 = 0;
140011653      void* var_48;
140011653      nimFrame(&var_48);
140011658      int64_t var_38_1 = 0x153;
140011667      char const* const var_30_1 =
140011667          "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\windows\winlean.nim";
140011680      popFrame();
14001168e      return (uint64_t)*(uint32_t*)((char*)arg1)[4] << 0x20 | (uint64_t)(uint32_t)arg1;
14001161c  }


14001168f    int64_t* atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatswindowsatswinleandotnim_Init000()

14001168f  {
14001169e      char const* const var_50 = "winlean";
1400116a9      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\windows\winlean.nim";
1400116ad      int64_t var_48 = 0;
1400116b5      int16_t var_38 = 0;
1400116c2      void* var_58;
1400116c2      nimFrame(&var_58);
1400116c7      char* rax = nimErrorFlag();
1400116d0      int64_t var_48_1 = 0x345;
1400116d8      int64_t var_18 = 0;
1400116ee      int64_t var_68 = 0xa;
1400116f2      void* const var_60 = &TM__k6kyf4Co79a84IkK9blFuQVA_2;
140011702      HMODULE rax_1 = loadLib__pureZdynlib_u3(&var_68);
140011702      
140011717      if (!(uint32_t)*(uint8_t*)rax)
140011717      {
14001171d          ws2__windowsZwinlean_u797 = rax_1;
140011724          int64_t var_48_2 = 0x346;
140011724          
140011736          if (ws2__windowsZwinlean_u797)
140011736          {
140011738              int64_t var_48_3 = 0x347;
140011740              int64_t var_20_1 = 0;
140011759              int64_t rax_8 =
140011759                  symAddr__pureZdynlib_u74(ws2__windowsZwinlean_u797, "inet_ntop");
140011759              
14001176e              if (!(uint32_t)*(uint8_t*)rax)
140011774                  _.bss = rax_8;
140011736          }
140011717      }
140011717      
140011784      nimTestErrorFlag();
140011794      return popFrame();
14001168f  }


140011795    int64_t atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatswindowsatswinleandotnim_DatInit000()

140011795  {
1400117ab      int64_t var_18 = 8;
1400117af      void* const var_10 = &TM__k6kyf4Co79a84IkK9blFuQVA_6;
1400117bf      TM__k6kyf4Co79a84IkK9blFuQVA_4 = nimLoadLibrary(&var_18);
1400117bf      
1400117d0      if (TM__k6kyf4Co79a84IkK9blFuQVA_4)
1400117d0      {
140011805          int64_t result =
140011805              nimGetProcAddr(TM__k6kyf4Co79a84IkK9blFuQVA_4, "GetSystemTimeAsFileTime");
14001180a          Dl_1426063656_ = result;
140011817          return result;
1400117d0      }
1400117d0      
1400117e0      var_18 = 8;
1400117e4      void* const var_10_1 = &TM__k6kyf4Co79a84IkK9blFuQVA_8;
1400117ef      nimLoadLibraryError(&var_18);
1400117ef      /* no return */
140011795  }

140011818                                                                          90 90 90 90 90 90 90 90                          ........

140011820    int64_t nimFrame(void** arg1)

140011820  {
140011841      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
14001186f          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
14001186f              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
140011841      else
140011847          *(uint16_t*)((char*)arg1 + 0x22) = 0;
140011847      
14001187d      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140011889      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
140011890      *(uint64_t*)rax_8 = arg1;
140011897      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
140011897      
14001189f      if (result != 0x7d0)
1400118af          return result;
1400118af      
1400118a1      return callDepthLimitReached__system_u4678();
140011820  }


1400118b0    int64_t* popFrame()

1400118b0  {
1400118c2      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
1400118cd      *(uint64_t*)result = **(uint64_t**)result;
1400118d6      return result;
1400118b0  }


1400118d7    int64_t toUnix__pureZtimes_u1230(int64_t* arg1)

1400118d7  {
1400118e5      int64_t result = *(uint64_t*)arg1;
1400118f0      int64_t var_60 = arg1[1];
1400118fb      char const* const var_50 = "toUnix";
140011906      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\pure\times.nim";
14001190a      int64_t var_48 = 0;
140011912      int16_t var_38 = 0;
14001191f      void* var_58;
14001191f      nimFrame(&var_58);
140011924      int64_t var_48_1 = 0x3a5;
140011933      char const* const var_40_1 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\pure\times.nim";
14001193f      popFrame();
14001194e      return result;
1400118d7  }


14001194f    int64_t nimSetMem__systemZmemory_u7(int64_t arg1, int32_t arg2, uint64_t arg3)

14001194f  {
140011962      int64_t var_10 = 0;
14001197b      int64_t result = memset(arg1, arg2, arg3);
140011980      int64_t result_1 = result;
14001198a      return result;
14001194f  }


14001198b    int64_t nimErrorFlag()

14001198b  {
1400119af      return __emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
14001198b  }


1400119b0    uint64_t nimZeroMem(int64_t arg1, uint64_t arg2)

1400119b0  {
1400119c0      char* rax = nimErrorFlag();
1400119dc      nimSetMem__systemZmemory_u7(arg1, 0, arg2);
1400119f4      return (uint64_t)*(uint8_t*)rax;
1400119b0  }


1400119f5    int64_t* initTime__pureZtimes_u1200(int64_t* arg1, int64_t arg2, int64_t arg3)

1400119f5  {
140011a10      char const* const var_50 = "initTime";
140011a1b      char const* const var_40 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\pure\times.nim";
140011a1f      int64_t var_48 = 0;
140011a27      int16_t var_38 = 0;
140011a34      void* var_58;
140011a34      nimFrame(&var_58);
140011a39      int64_t var_10 = 0;
140011a41      int64_t var_18 = 0;
140011a49      int64_t var_48_1 = 0x395;
140011a71      popFrame();
140011a82      *(uint64_t*)arg1 = arg2;
140011a85      arg1[1] = arg3;
140011a92      return arg1;
1400119f5  }


140011a93    int64_t* fromWinTime__pureZtimes_u1250(int64_t* arg1, int64_t arg2)

140011a93  {
140011aad      char const* const var_70 = "fromWinTime";
140011ab8      char const* const var_60 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\pure\times.nim";
140011abc      int64_t var_68 = 0;
140011ac4      int16_t var_58 = 0;
140011ad1      void* var_78;
140011ad1      nimFrame(&var_78);
140011ad6      char* rax = nimErrorFlag();
140011aeb      int64_t var_38;
140011aeb      nimZeroMem(&var_38, 0x10);
140011af0      int64_t var_68_1 = 0x3c6;
140011af8      int64_t var_18 = 0;
140011b0c      int64_t rax_2 = floorMod__pureZtimes_u1259(arg2, 0x989680);
140011b21      int64_t var_30;
140011b21      
140011b21      if (!(uint32_t)*(uint8_t*)rax)
140011b21      {
140011b27          char rdx = 0;
140011b30          uint64_t rax_7 = rax_2 * 0x64;
140011b30          bool o_1 = /* bool o_1 = unimplemented  {imul rax, rax, 0x64} */;
140011b30          
140011b34          if (o_1)
140011b36              rdx = 1;
140011b36          
140011b4d          if (!(rdx & 1))
140011b4d          {
140011b61              int64_t var_68_2 = 0x3c7;
140011b69              char rcx_4 = 0;
140011b69              
140011b7f              if (arg2 - 0x19db1ded53e8000)
140011b81                  rcx_4 = 1;
140011b81              
140011b98              if (!(rcx_4 & 1))
140011b98              {
140011bb0                  int64_t rax_16 =
140011bb0                      floorDiv__pureZtimes_u317(arg2 - 0x19db1ded53e8000, 0x989680);
140011bb0                  
140011bc5                  if (!(uint32_t)*(uint8_t*)rax)
140011bc5                  {
140011bc7                      int64_t var_68_3 = 0x3c8;
140011bc7                      
140011bde                      if (rax_7 < 0 || rax_7 > 0x3b9ac9ff)
140011bf2                          raiseRangeErrorI(rax_7, 0, 0x3b9ac9ff);
140011bde                      else
140011bde                      {
140011c0b                          int64_t var_88;
140011c0b                          initTime__pureZtimes_u1200(&var_88, rax_16, rax_7);
140011c18                          var_38 = var_88;
140011c1c                          int64_t var_80;
140011c1c                          var_30 = var_80;
140011bde                      }
140011bc5                  }
140011b98              }
140011b98              else
140011b9a                  raiseOverflow();
140011b4d          }
140011b4d          else
140011b4f              raiseOverflow();
140011b21      }
140011b21      
140011c32      popFrame();
140011c43      *(uint64_t*)arg1 = var_38;
140011c46      arg1[1] = var_30;
140011c56      return arg1;
140011a93  }


140011c57    int64_t* getTime__pureZtimes_u1281(int64_t* arg1)

140011c57  {
140011c6d      char const* const var_60 = "getTime";
140011c78      char const* const var_50 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\pure\times.nim";
140011c7c      int64_t var_58 = 0;
140011c84      int16_t var_48 = 0;
140011c91      void* var_68;
140011c91      nimFrame(&var_68);
140011c96      char* rax = nimErrorFlag();
140011cab      int64_t var_28;
140011cab      nimZeroMem(&var_28, 0x10);
140011cb0      int64_t var_58_1 = 0x3e8;
140011cc9      int64_t var_30;
140011cc9      Dl_1426063656_(&var_30);
140011ccb      int64_t var_58_2 = 0x3e9;
140011cd3      int64_t var_18 = 0;
140011ce2      uint64_t rax_2 = rdFileTime__windowsZwinlean_u282(var_30);
140011cf7      int64_t var_20;
140011cf7      
140011cf7      if (!(uint32_t)*(uint8_t*)rax)
140011cf7      {
140011d04          int64_t var_78;
140011d04          fromWinTime__pureZtimes_u1250(&var_78, rax_2);
140011d11          var_28 = var_78;
140011d15          int64_t var_70;
140011d15          var_20 = var_70;
140011cf7      }
140011cf7      
140011d28      popFrame();
140011d39      *(uint64_t*)arg1 = var_28;
140011d3c      arg1[1] = var_20;
140011d4c      return arg1;
140011c57  }

140011d4d                                         90 90 90                                                               ...

140011d50    int64_t nimPrepareStrMutationV2(int64_t* arg1)

140011d50  {
140011d5c      char var_9 = 0;
140011d6b      int64_t rax_1;
140011d6b      (uint8_t)rax_1 = arg1[1];
140011d6e      char var_9_1 = (uint8_t)rax_1;
140011d6e      
140011d7a      if (var_9_1 == 1)
140011d7a      {
140011d97          int64_t rax_6;
140011d97          (uint8_t)rax_6 = 0x4000000000000000 & *(uint64_t*)arg1[1];
140011d9a          var_9_1 = (uint8_t)rax_6;
140011d7a      }
140011d7a      
140011da4      char result = var_9_1 ^ 1;
140011da4      
140011da9      if (result)
140011dc0          return result;
140011dc0      
140011db2      return nimPrepareStrMutationImpl__system_u2410(arg1);
140011d50  }


140011dc1    int64_t nimFrame(void** arg1)

140011dc1  {
140011de2      if (*(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692))
140011e10          *(uint16_t*)((char*)arg1 + 0x22) = *(uint16_t*)(
140011e10              *(uint64_t*)__emutls_get_address(&__emutls_v.framePtr__system_u2692) + 0x22) + 1;
140011de2      else
140011de8          *(uint16_t*)((char*)arg1 + 0x22) = 0;
140011de8      
140011e1e      void** rax_8 = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140011e2a      *(uint64_t*)arg1 = *(uint64_t*)rax_8;
140011e31      *(uint64_t*)rax_8 = arg1;
140011e38      int16_t result = *(uint16_t*)((char*)arg1 + 0x22);
140011e38      
140011e40      if (result != 0x7d0)
140011e50          return result;
140011e50      
140011e42      return callDepthLimitReached__system_u4678();
140011dc1  }


140011e51    int64_t* popFrame()

140011e51  {
140011e63      int64_t* result = __emutls_get_address(&__emutls_v.framePtr__system_u2692);
140011e6e      *(uint64_t*)result = **(uint64_t**)result;
140011e77      return result;
140011e51  }


140011e78    int64_t* buildEncodedFlag__crackme_u18(int64_t* arg1)

140011e78  {
140011e8b      char const* const var_40 = "buildEncodedFlag";
140011e96      char const* const var_30 = "C:\CTF\nimcrackme1\crackme.nim";
140011e9a      int64_t var_38 = 0;
140011ea2      int16_t var_28 = 0;
140011eaf      void* var_48;
140011eaf      nimFrame(&var_48);
140011eb4      int64_t var_38_1 = 0xd;
140011ec3      char const* const var_30_1 = "C:\CTF\nimcrackme1\crackme.nim";
140011ed3      int64_t var_58;
140011ed3      mnewString(&var_58, 0x26);
140011ee0      int64_t var_18 = var_58;
140011ee8      int64_t var_38_2 = 0xe;
140011ef7      void* var_50;
140011ef7      
140011ef7      if (var_18 > 0)
140011ef7      {
140011f1a          nimPrepareStrMutationV2(&var_18);
140011f23          *(uint8_t*)((char*)var_50 + 8) = 0x28;
140011f27          int64_t var_38_3 = 0xf;
140011f27          
140011f37          if (var_18 > 1)
140011f37          {
140011f5a              nimPrepareStrMutationV2(&var_18);
140011f63              *(uint8_t*)((char*)var_50 + 9) = 5;
140011f67              int64_t var_38_4 = 0x10;
140011f67              
140011f77              if (var_18 > 2)
140011f77              {
140011f9a                  nimPrepareStrMutationV2(&var_18);
140011fa3                  *(uint8_t*)((char*)var_50 + 0xa) = 0xc;
140011fa7                  int64_t var_38_5 = 0x11;
140011fa7                  
140011fb7                  if (var_18 > 3)
140011fb7                  {
140011fda                      nimPrepareStrMutationV2(&var_18);
140011fe3                      *(uint8_t*)((char*)var_50 + 0xb) = 0x47;
140011fe7                      int64_t var_38_6 = 0x12;
140011fe7                      
140011ff7                      if (var_18 > 4)
140011ff7                      {
14001201a                          nimPrepareStrMutationV2(&var_18);
140012023                          *(uint8_t*)((char*)var_50 + 0xc) = 0x12;
140012027                          int64_t var_38_7 = 0x13;
140012027                          
140012037                          if (var_18 > 5)
140012037                          {
14001205a                              nimPrepareStrMutationV2(&var_18);
140012063                              *(uint8_t*)((char*)var_50 + 0xd) = 0x4b;
140012067                              int64_t var_38_8 = 0x14;
140012067                              
140012077                              if (var_18 > 6)
140012077                              {
14001209a                                  nimPrepareStrMutationV2(&var_18);
1400120a3                                  *(uint8_t*)((char*)var_50 + 0xe) = 0x15;
1400120a7                                  int64_t var_38_9 = 0x15;
1400120a7                                  
1400120b7                                  if (var_18 > 7)
1400120b7                                  {
1400120da                                      nimPrepareStrMutationV2(&var_18);
1400120e3                                      *(uint8_t*)((char*)var_50 + 0xf) = 0x5c;
1400120e7                                      int64_t var_38_10 = 0x16;
1400120e7                                      
1400120f7                                      if (var_18 > 8)
1400120f7                                      {
14001211a                                          nimPrepareStrMutationV2(&var_18);
140012123                                          *(uint8_t*)((char*)var_50 + 0x10) = 9;
140012127                                          int64_t var_38_11 = 0x17;
140012127                                          
140012137                                          if (var_18 > 9)
140012137                                          {
14001215a                                              nimPrepareStrMutationV2(&var_18);
140012163                                              *(uint8_t*)((char*)var_50 + 0x11) = 0x12;
140012167                                              int64_t var_38_12 = 0x18;
140012167                                              
140012177                                              if (var_18 > 0xa)
140012177                                              {
14001219a                                                  nimPrepareStrMutationV2(&var_18);
1400121a3                                                  *(uint8_t*)((char*)var_50 + 0x12) = 0x17;
1400121a7                                                  int64_t var_38_13 = 0x19;
1400121a7                                                  
1400121b7                                                  if (var_18 > 0xb)
1400121b7                                                  {
1400121da                                                      nimPrepareStrMutationV2(&var_18);
1400121e3                                                      *(uint8_t*)((char*)var_50 + 0x13) =
1400121e3                                                          0x55;
1400121e7                                                      int64_t var_38_14 = 0x1a;
1400121e7                                                      
1400121f7                                                      if (var_18 > 0xc)
1400121f7                                                      {
14001221a                                                          nimPrepareStrMutationV2(&var_18);
140012223                                                          *(uint8_t*)((char*)var_50 + 0x14) = 9;
140012227                                                          int64_t var_38_15 = 0x1b;
140012227                                                          
140012237                                                          if (var_18 > 0xd)
140012237                                                          {
14001225a                                                              nimPrepareStrMutationV2(&var_18);
140012263                                                              *(uint8_t*)((char*)var_50 + 0x15) =
140012263                                                                  0x4b;
140012267                                                              int64_t var_38_16 = 0x1c;
140012267                                                              
140012277                                                              if (var_18 > 0xe)
140012277                                                              {
14001229a                                                                  nimPrepareStrMutationV2(&var_18);
1400122a3                                                                  *(uint8_t*)((char*)var_50 + 0x16) =
1400122a3                                                                      0x42;
1400122a7                                                                  int64_t var_38_17 = 0x1d;
1400122a7                                                                  
1400122b7                                                                  if (var_18 > 0xf)
1400122b7                                                                  {
1400122da                                                                      nimPrepareStrMutationV2(&var_18);
1400122e3                                                                      *(uint8_t*)((char*)var_50 + 0x17) = 8;
1400122e7                                                                      int64_t var_38_18 = 0x1e;
1400122e7                                                                      
1400122f7                                                                      if (var_18 > 0x10)
1400122f7                                                                      {
14001231a                                                                          nimPrepareStrMutationV2(&var_18);
140012323                                                                          *(uint8_t*)((char*)var_50 + 0x18) =
140012323                                                                              0x55;
140012327                                                                          int64_t var_38_19 = 0x1f;
140012327                                                                          
140012337                                                                          if (var_18 > 0x11)
140012337                                                                          {
14001235a                                                                              nimPrepareStrMutationV2(&var_18);
140012363                                                                              *(uint8_t*)((char*)var_50 + 0x19) =
140012363                                                                                  0x5a;
140012367                                                                              int64_t var_38_20 = 0x20;
140012367                                                                              
140012377                                                                              if (var_18 > 0x12)
140012377                                                                              {
14001239a                                                                                  nimPrepareStrMutationV2(&var_18);
1400123a3                                                                                  *(uint8_t*)((char*)var_50 + 0x1a) =
1400123a3                                                                                      0x45;
1400123a7                                                                                  int64_t var_38_21 = 0x21;
1400123a7                                                                                  
1400123b7                                                                                  if (var_18 > 0x13)
1400123b7                                                                                  {
1400123da                                                                                      nimPrepareStrMutationV2(&var_18);
1400123e3                                                                                      *(uint8_t*)((char*)var_50 + 0x1b) =
1400123e3                                                                                          0x58;
1400123e7                                                                                      int64_t var_38_22 = 0x22;
1400123e7                                                                                      
1400123f7                                                                                      if (var_18 > 0x14)
1400123f7                                                                                      {
14001241a                                                                                          nimPrepareStrMutationV2(&var_18);
140012423                                                                                          *(uint8_t*)((char*)var_50 + 0x1c) =
140012423                                                                                              0x44;
140012427                                                                                          int64_t var_38_23 = 0x23;
140012427                                                                                          
140012437                                                                                          if (var_18 > 0x15)
140012437                                                                                          {
14001245a                                                                                              nimPrepareStrMutationV2(&var_18);
140012463                                                                                              *(uint8_t*)((char*)var_50 + 0x1d) =
140012463                                                                                                  0x57;
140012467                                                                                              int64_t var_38_24 = 0x24;
140012467                                                                                              
140012477                                                                                              if (var_18 > 0x16)
140012477                                                                                              {
14001249a                                                                                                  nimPrepareStrMutationV2(&var_18);
1400124a3                                                                                                  *(uint8_t*)((char*)var_50 + 0x1e) =
1400124a3                                                                                                      0x45;
1400124a7                                                                                                  int64_t var_38_25 = 0x25;
1400124a7                                                                                                  
1400124b7                                                                                                  if (var_18 > 0x17)
1400124b7                                                                                                  {
1400124da                                                                                                      nimPrepareStrMutationV2(&var_18);
1400124e3                                                                                                      *(uint8_t*)((char*)var_50 + 0x1f) =
1400124e3                                                                                                          0x77;
1400124e7                                                                                                      int64_t var_38_26 = 0x26;
1400124e7                                                                                                      
1400124f7                                                                                                      if (var_18 > 0x18)
1400124f7                                                                                                      {
14001251a                                                                                                          nimPrepareStrMutationV2(&var_18);
140012523                                                                                                          *(uint8_t*)((char*)var_50 + 0x20) =
140012523                                                                                                              0x5d;
140012527                                                                                                          int64_t var_38_27 = 0x27;
140012527                                                                                                          
140012537                                                                                                          if (var_18 > 0x19)
140012537                                                                                                          {
14001255a                                                                                                              nimPrepareStrMutationV2(&var_18);
140012563                                                                                                              *(uint8_t*)((char*)var_50 + 0x21) =
140012563                                                                                                                  0x54;
140012567                                                                                                              int64_t var_38_28 = 0x28;
140012567                                                                                                              
140012577                                                                                                              if (var_18 > 0x1a)
140012577                                                                                                              {
14001259a                                                                                                                  nimPrepareStrMutationV2(&var_18);
1400125a3                                                                                                                  *(uint8_t*)((char*)var_50 + 0x22) =
1400125a3                                                                                                                      0x44;
1400125a7                                                                                                                  int64_t var_38_29 = 0x29;
1400125a7                                                                                                                  
1400125b7                                                                                                                  if (var_18 > 0x1b)
1400125b7                                                                                                                  {
1400125da                                                                                                                      nimPrepareStrMutationV2(&var_18);
1400125e3                                                                                                                      *(uint8_t*)((char*)var_50 + 0x23) =
1400125e3                                                                                                                          0x5c;
1400125e7                                                                                                                      int64_t var_38_30 = 0x2a;
1400125e7                                                                                                                      
1400125f7                                                                                                                      if (var_18 > 0x1c)
1400125f7                                                                                                                      {
14001261a                                                                                                                          nimPrepareStrMutationV2(&var_18);
140012623                                                                                                                          *(uint8_t*)((char*)var_50 + 0x24) =
140012623                                                                                                                              0x45;
140012627                                                                                                                          int64_t var_38_31 = 0x2b;
140012627                                                                                                                          
140012637                                                                                                                          if (var_18 > 0x1d)
140012637                                                                                                                          {
14001265a                                                                                                                              nimPrepareStrMutationV2(&var_18);
140012663                                                                                                                              *(uint8_t*)((char*)var_50 + 0x25) =
140012663                                                                                                                                  0x13;
140012667                                                                                                                              int64_t var_38_32 = 0x2c;
140012667                                                                                                                              
140012677                                                                                                                              if (var_18 > 0x1e)
140012677                                                                                                                              {
14001269a                                                                                                                                  nimPrepareStrMutationV2(&var_18);
1400126a3                                                                                                                                  *(uint8_t*)((char*)var_50 + 0x26) =
1400126a3                                                                                                                                      0x59;
1400126a7                                                                                                                                  int64_t var_38_33 = 0x2d;
1400126a7                                                                                                                                  
1400126b7                                                                                                                                  if (var_18 > 0x1f)
1400126b7                                                                                                                                  {
1400126da                                                                                                                                      nimPrepareStrMutationV2(&var_18);
1400126e3                                                                                                                                      *(uint8_t*)((char*)var_50 + 0x27) =
1400126e3                                                                                                                                          0x5b;
1400126e7                                                                                                                                      int64_t var_38_34 = 0x2e;
1400126e7                                                                                                                                      
1400126f7                                                                                                                                      if (var_18 > 0x20)
1400126f7                                                                                                                                      {
14001271a                                                                                                                                          nimPrepareStrMutationV2(&var_18);
140012723                                                                                                                                          *(uint8_t*)((char*)var_50 + 0x28) =
140012723                                                                                                                                              0x47;
140012727                                                                                                                                          int64_t var_38_35 = 0x2f;
140012727                                                                                                                                          
140012737                                                                                                                                          if (var_18 > 0x21)
140012737                                                                                                                                          {
14001275a                                                                                                                                              nimPrepareStrMutationV2(&var_18);
140012763                                                                                                                                              *(uint8_t*)((char*)var_50 + 0x29) =
140012763                                                                                                                                                  0x42;
140012767                                                                                                                                              int64_t var_38_36 = 0x30;
140012767                                                                                                                                              
140012777                                                                                                                                              if (var_18 > 0x22)
140012777                                                                                                                                              {
14001279a                                                                                                                                                  nimPrepareStrMutationV2(&var_18);
1400127a3                                                                                                                                                  *(uint8_t*)((char*)var_50 + 0x2a) =
1400127a3                                                                                                                                                      0x5e;
1400127a7                                                                                                                                                  int64_t var_38_37 = 0x31;
1400127a7                                                                                                                                                  
1400127b7                                                                                                                                                  if (var_18 > 0x23)
1400127b7                                                                                                                                                  {
1400127da                                                                                                                                                      nimPrepareStrMutationV2(&var_18);
1400127e3                                                                                                                                                      *(uint8_t*)((char*)var_50 + 0x2b) =
1400127e3                                                                                                                                                          0x59;
1400127e7                                                                                                                                                      int64_t var_38_38 = 0x32;
1400127e7                                                                                                                                                      
1400127f7                                                                                                                                                      if (var_18 > 0x24)
1400127f7                                                                                                                                                      {
140012817                                                                                                                                                          nimPrepareStrMutationV2(&var_18);
140012820                                                                                                                                                          *(uint8_t*)((char*)var_50 + 0x2c) =
140012820                                                                                                                                                              0x16;
140012824                                                                                                                                                          int64_t var_38_39 = 0x33;
140012824                                                                                                                                                          
140012834                                                                                                                                                          if (var_18 > 0x25)
140012834                                                                                                                                                          {
140012854                                                                                                                                                              nimPrepareStrMutationV2(&var_18);
14001285d                                                                                                                                                              *(uint8_t*)((char*)var_50 + 0x2d) =
14001285d                                                                                                                                                                  0x5d;
140012834                                                                                                                                                          }
140012834                                                                                                                                                          else
140012846                                                                                                                                                              raiseIndexError2(0x25, var_18 - 1);
1400127f7                                                                                                                                                      }
1400127f7                                                                                                                                                      else
140012809                                                                                                                                                          raiseIndexError2(0x24, var_18 - 1);
1400127b7                                                                                                                                                  }
1400127b7                                                                                                                                                  else
1400127c9                                                                                                                                                      raiseIndexError2(0x23, var_18 - 1);
140012777                                                                                                                                              }
140012777                                                                                                                                              else
140012789                                                                                                                                                  raiseIndexError2(0x22, var_18 - 1);
140012737                                                                                                                                          }
140012737                                                                                                                                          else
140012749                                                                                                                                              raiseIndexError2(0x21, var_18 - 1);
1400126f7                                                                                                                                      }
1400126f7                                                                                                                                      else
140012709                                                                                                                                          raiseIndexError2(0x20, var_18 - 1);
1400126b7                                                                                                                                  }
1400126b7                                                                                                                                  else
1400126c9                                                                                                                                      raiseIndexError2(0x1f, var_18 - 1);
140012677                                                                                                                              }
140012677                                                                                                                              else
140012689                                                                                                                                  raiseIndexError2(0x1e, var_18 - 1);
140012637                                                                                                                          }
140012637                                                                                                                          else
140012649                                                                                                                              raiseIndexError2(0x1d, var_18 - 1);
1400125f7                                                                                                                      }
1400125f7                                                                                                                      else
140012609                                                                                                                          raiseIndexError2(0x1c, var_18 - 1);
1400125b7                                                                                                                  }
1400125b7                                                                                                                  else
1400125c9                                                                                                                      raiseIndexError2(0x1b, var_18 - 1);
140012577                                                                                                              }
140012577                                                                                                              else
140012589                                                                                                                  raiseIndexError2(0x1a, var_18 - 1);
140012537                                                                                                          }
140012537                                                                                                          else
140012549                                                                                                              raiseIndexError2(0x19, var_18 - 1);
1400124f7                                                                                                      }
1400124f7                                                                                                      else
140012509                                                                                                          raiseIndexError2(0x18, var_18 - 1);
1400124b7                                                                                                  }
1400124b7                                                                                                  else
1400124c9                                                                                                      raiseIndexError2(0x17, var_18 - 1);
140012477                                                                                              }
140012477                                                                                              else
140012489                                                                                                  raiseIndexError2(0x16, var_18 - 1);
140012437                                                                                          }
140012437                                                                                          else
140012449                                                                                              raiseIndexError2(0x15, var_18 - 1);
1400123f7                                                                                      }
1400123f7                                                                                      else
140012409                                                                                          raiseIndexError2(0x14, var_18 - 1);
1400123b7                                                                                  }
1400123b7                                                                                  else
1400123c9                                                                                      raiseIndexError2(0x13, var_18 - 1);
140012377                                                                              }
140012377                                                                              else
140012389                                                                                  raiseIndexError2(0x12, var_18 - 1);
140012337                                                                          }
140012337                                                                          else
140012349                                                                              raiseIndexError2(0x11, var_18 - 1);
1400122f7                                                                      }
1400122f7                                                                      else
140012309                                                                          raiseIndexError2(0x10, var_18 - 1);
1400122b7                                                                  }
1400122b7                                                                  else
1400122c9                                                                      raiseIndexError2(0xf, var_18 - 1);
140012277                                                              }
140012277                                                              else
140012289                                                                  raiseIndexError2(0xe, var_18 - 1);
140012237                                                          }
140012237                                                          else
140012249                                                              raiseIndexError2(0xd, var_18 - 1);
1400121f7                                                      }
1400121f7                                                      else
140012209                                                          raiseIndexError2(0xc, var_18 - 1);
1400121b7                                                  }
1400121b7                                                  else
1400121c9                                                      raiseIndexError2(0xb, var_18 - 1);
140012177                                              }
140012177                                              else
140012189                                                  raiseIndexError2(0xa, var_18 - 1);
140012137                                          }
140012137                                          else
140012149                                              raiseIndexError2(9, var_18 - 1);
1400120f7                                      }
1400120f7                                      else
140012109                                          raiseIndexError2(8, var_18 - 1);
1400120b7                                  }
1400120b7                                  else
1400120c9                                      raiseIndexError2(7, var_18 - 1);
140012077                              }
140012077                              else
140012089                                  raiseIndexError2(6, var_18 - 1);
140012037                          }
140012037                          else
140012049                              raiseIndexError2(5, var_18 - 1);
140011ff7                      }
140011ff7                      else
140012009                          raiseIndexError2(4, var_18 - 1);
140011fb7                  }
140011fb7                  else
140011fc9                      raiseIndexError2(3, var_18 - 1);
140011f77              }
140011f77              else
140011f89                  raiseIndexError2(2, var_18 - 1);
140011f37          }
140011f37          else
140011f49              raiseIndexError2(1, var_18 - 1);
140011ef7      }
140011ef7      else
140011f09          raiseIndexError2(0, var_18 - 1);
140011f09      
140012861      popFrame();
140012872      *(uint64_t*)arg1 = var_18;
140012875      arg1[1] = var_50;
140012882      return arg1;
140011e78  }


140012883    int64_t* xorStrings__crackme_u3(int64_t* arg1, int64_t* arg2, int64_t* arg3)

140012883  {
14001289b      uint64_t rax = *(uint64_t*)arg2;
14001289e      int64_t rdx = arg2[1];
1400128ad      int64_t rax_1 = *(uint64_t*)arg3;
1400128b0      int64_t rdx_1 = arg3[1];
1400128c9      char const* const var_70 = "xorStrings";
1400128d4      char const* const var_60 = "C:\CTF\nimcrackme1\crackme.nim";
1400128d8      int64_t var_68 = 0;
1400128e0      int16_t var_58 = 0;
1400128ed      void* var_78;
1400128ed      nimFrame(&var_78);
1400128f2      int64_t var_48 = 0;
1400128fa      int64_t var_40 = 0;
140012902      int64_t var_68_1 = 6;
140012902      
140012911      if (rax >= 0)
140012911      {
140012941          int64_t var_b8;
140012941          mnewString(&var_b8, rax);
140012954          var_48 = var_b8;
140012958          int64_t var_b0;
140012958          var_40 = var_b0;
14001295c          int64_t var_28_1 = 0;
140012964          int64_t var_30_1 = 0;
14001296c          int64_t var_68_2 = 0x7e;
14001297b          char const* const var_60_1 =
14001297b              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
14001297f          int64_t var_68_3 = 7;
14001298e          char const* const var_60_2 = "C:\CTF\nimcrackme1\crackme.nim";
14001299a          int64_t var_68_4 = 0x80;
1400129a9          char const* const var_60_3 =
1400129a9              "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
1400129ad          int64_t var_20_1 = 0;
1400129b5          int64_t var_68_5 = 0x81;
1400129b5          
1400129c5          while (var_20_1 < rax)
1400129c5          {
1400129cb              int64_t var_68_6 = 7;
1400129da              char const* const var_60_4 = "C:\CTF\nimcrackme1\crackme.nim";
1400129e6              int64_t var_68_7 = 8;
1400129e6              
1400129fd              if (var_20_1 < 0 || var_20_1 >= var_48)
1400129fd              {
140012a0e                  raiseIndexError2(var_20_1, var_48 - 1);
140012a13                  break;
1400129fd              }
1400129fd              
140012a1f              nimPrepareStrMutationV2(&var_48);
140012a1f              
140012a33              if (var_20_1 < 0 || var_20_1 >= rax)
140012a33              {
140012a44                  raiseIndexError2(var_20_1, rax - 1);
140012a49                  break;
140012a33              }
140012a33              
140012a58              if (!rax_1)
140012a58              {
140012a5a                  raiseDivByZero();
140012a5f                  break;
140012a58              }
140012a58              
140012a71              int64_t temp1_1 = (int128_t)var_20_1 % rax_1;
140012a71              
140012a92              if (temp1_1 < 0 || rax_1 <= temp1_1)
140012a92              {
140012aa6                  raiseIndexError2(temp1_1, rax_1 - 1);
140012aab                  break;
140012a92              }
140012a92              
140012ae7              *(uint8_t*)(var_20_1 + var_40 + 8) =
140012ae7                  *(uint8_t*)(rdx_1 + temp1_1 + 8) ^ *(uint8_t*)(var_20_1 + rdx + 8);
140012ae9              int64_t var_68_8 = 0x83;
140012af8              char const* const var_60_5 =
140012af8                  "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system\iterators_1.nim";
140012afc              char rdx_13 = 0;
140012afc              
140012b09              if (var_20_1 + 1)
140012b0b                  rdx_13 = 1;
140012b0b              
140012b22              if (rdx_13 & 1)
140012b22              {
140012b24                  raiseOverflow();
140012b29                  break;
140012b22              }
140012b22              
140012b2f              var_20_1 += 1;
140012b33              continue;
1400129c5          }
140012911      }
140012911      else
140012929          raiseRangeErrorI(rax, 0, 0x7fffffffffffffff);
140012929      
140012b39      popFrame();
140012b4a      *(uint64_t*)arg1 = var_48;
140012b4d      arg1[1] = var_40;
140012b5e      return arg1;
140012883  }


140012b5f    int64_t nimErrorFlag()

140012b5f  {
140012b83      return __emutls_get_address(&__emutls_v.nimInErrorMode__system_u4460);
140012b5f  }


140012b84    int64_t* main__crackme_u20()

140012b84  {
140012b96      char const* const var_60 = "main";
140012ba1      char const* const var_50 = "C:\CTF\nimcrackme1\crackme.nim";
140012ba5      int64_t var_58 = 0;
140012bad      int16_t var_48 = 0;
140012bba      void* var_68;
140012bba      nimFrame(&var_68);
140012bbf      char* rax = nimErrorFlag();
140012bd8      int64_t var_38;
140012bd8      __builtin_memset(&var_38, 0, 0x20);
140012be8      int64_t var_58_1 = 0x36;
140012bf7      char const* const var_50_1 = "C:\CTF\nimcrackme1\crackme.nim";
140012c02      int64_t var_28;
140012c02      buildEncodedFlag__crackme_u18(&var_28);
140012c13      int64_t* var_30;
140012c13      int64_t* var_20;
140012c13      
140012c13      if (!(uint32_t)*(uint8_t*)rax)
140012c13      {
140012c19          int64_t var_58_2 = 0x37;
140012c2d          int64_t var_98 = var_28;
140012c34          int64_t* var_90_1 = var_20;
140012c49          int64_t var_a8 = 0x17;
140012c50          void* const var_a0_1 = &TM__cGo7QGde1ZstH4i7xlaOag_4;
140012c6b          xorStrings__crackme_u3(&var_38, &var_98, &var_a8);
140012c6b          
140012c7c          if (!(uint32_t)*(uint8_t*)rax)
140012c7c          {
140012c82              int64_t var_58_3 = 0x3a;
140012c91              int64_t var_78;
140012c91              getTime__pureZtimes_u1281(&var_78);
140012c91              
140012ca2              if (!(uint32_t)*(uint8_t*)rax)
140012ca2              {
140012ca8                  int64_t var_18_1 = 0;
140012cb8                  var_98 = var_78;
140012cbf                  int64_t var_70;
140012cbf                  int64_t var_90_2 = var_70;
140012cd0                  int64_t rax_12 = toUnix__pureZtimes_u1230(&var_98);
140012cd0                  
140012ce5                  if (!(uint32_t)*(uint8_t*)rax)
140012ce5                  {
140012cec                      if (rax_12)
140012cec                      {
140012d1a                          int64_t var_58_5 = 0x3d;
140012d31                          echoBinSafe(&TM__cGo7QGde1ZstH4i7xlaOag_6, 1);
140012cec                      }
140012cec                      else
140012cec                      {
140012cee                          int64_t var_58_4 = 0x3b;
140012cfe                          int64_t var_88 = var_38;
140012d02                          int64_t* var_80_1 = var_30;
140012d12                          echoBinSafe(&var_88, 1);
140012cec                      }
140012ce5                  }
140012ca2              }
140012c7c          }
140012c13      }
140012c13      
140012d42      int64_t var_58_6 = 0x18a;
140012d51      char const* const var_50_2 = "C:\CTF\nim-2.2.4_x64\nim-2.2.4\lib\system.nim";
140012d51      
140012d78      if (var_30 && !(0x4000000000000000 & *(uint64_t*)var_30))
140012d81          deallocShared(var_30);
140012d81      
140012da9      if (var_20 && !(0x4000000000000000 & *(uint64_t*)var_20))
140012db2          deallocShared(var_20);
140012db2      
140012dd2      return popFrame();
140012b84  }


140012dd3    int64_t* PreMainInner()

140012dd3  {
140012ddb      atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatsstdatsexitprocsdotnim_Init000();
140012de0      atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatsstdatssynciodotnim_Init000();
140012df0      return atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatswindowsatswinleandotnim_Init000();
140012dd3  }


140012df1    int64_t* PreMain()

140012df1  {
140012df9      atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatsstdatssynciodotnim_DatInit000();
140012dfe      atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatssystemdotnim_Init000();
140012e03      atmdotdotatsnimminus2dot2dot4_x64atsnimminus2dot2dot4atslibatswindowsatswinleandotnim_DatInit000();
140012e13      return PreMainInner();
140012df1  }


140012e14    int64_t* NimMainInner()

140012e14  {
140012e27      return NimMainModule();
140012e14  }


140012e28    int64_t* NimMain()

140012e28  {
140012e30      PreMain();
140012e40      return NimMainInner();
140012e28  }


140012e41    int64_t main(int32_t arg1, int64_t arg2, int64_t arg3)

140012e41  {
140012e54      __main();
140012e5d      cmdLine = arg2;
140012e67      _.bss = arg1;
140012e71      gEnv = arg3;
140012e78      NimMain();
140012e8c      return _.bss;
140012e41  }


140012e8d    int64_t* NimMainModule()

140012e8d  {
140012e9c      char const* const var_40 = "crackme";
140012ea7      char const* const var_30 = "C:\CTF\nimcrackme1\crackme.nim";
140012eab      int64_t var_38 = 0;
140012eb3      int16_t var_28 = 0;
140012ec0      void* var_48;
140012ec0      nimFrame(&var_48);
140012eca      char* var_10 = nimErrorFlag();
140012ece      int64_t var_38_1 = 0x3f;
140012edd      char const* const var_30_1 = "C:\CTF\nimcrackme1\crackme.nim";
140012ee1      main__crackme_u20();
140012ef3      nimTestErrorFlag();
140012f03      return popFrame();
140012e8d  }

140012f04              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

140012f10    int64_t __do_global_dtors()

140012f10  {
140012f1b      int64_t i = **(uint64_t**)&_.data;
140012f1b      
140012f21      while (i)
140012f21      {
140012f28          i();
140012f2a          void* _.data_1 = _.data;
140012f35          i = *(uint64_t*)((char*)_.data_1 + 8);
140012f39          _.data = (char*)_.data_1 + 8;
140012f21      }
140012f21      
140012f49      return i;
140012f10  }

140012f4a                                66 0f 1f 44 00 00                                                            f..D..

140012f50    int64_t __do_global_ctors()

140012f50  {
140012fa0      int32_t rax_4 = 0;
140012fb6      int32_t rcx;
140012fb6      uint64_t r8_2;
140012fb6      
140012fb6      do
140012fb6      {
140012fa8          r8_2 = (uint64_t)(rax_4 + 1);
140012fac          rcx = rax_4;
140012fb3          rax_4 = (uint32_t)r8_2;
140012fb6      } while (*(uint64_t*)(&__CTOR_LIST__ + (r8_2 << 3)));
140012fb6      
140012f69      if (rcx)
140012f69      {
140012f6b          uint64_t rax_1 = (uint64_t)rcx;
140012f70          void* i = &__CTOR_LIST__ + (rax_1 << 3);
140012f70          
140012f89          do
140012f89          {
140012f80              (*(uint64_t*)i)();
140012f82              i -= 8;
140012f89          } while (i != ((rax_1 - (uint64_t)(rcx - 1)) << 3) + 0x14001ee08);
140012f69      }
140012f69      
140012f98      /* tailcall */
140012f98      return atexit(__do_global_dtors);
140012f50  }

140012f9d                                                                                         0f 1f 00                               ...
140012fba                                                                                66 0f 1f 44 00 00                            f..D..

140012fc0    int64_t __main()

140012fc0  {
140012fc0      int32_t _.bss_1 = _.bss;
140012fc0      
140012fc8      if (_.bss_1)
140012fca          return _.bss_1;
140012fca      
140012fd0      _.bss = 1;
140012fda      /* tailcall */
140012fda      return __do_global_ctors();
140012fc0  }

140012fcb                                   0f 1f 44 00 00                                                             ..D..
140012fdf                                                                                               90                                 .

140012fe0    int64_t _setargv() __pure

140012fe0  {
140012fe2      return 0;
140012fe0  }

140012fe3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

140012ff0    int64_t _TLS_Entry_1(int64_t arg1, int32_t arg2)

140012ff0  {
140012ffb      if (arg2 != 3 && arg2)
140013006          return 1;
140013006      
140013010      __mingw_TLScallback(arg1, arg2);
14001301e      return 1;
140012ff0  }

140013007                       66 0f 1f 84 00 00 00 00 00                                                         f........
14001301f                                                                                               90                                 .

140013020    int64_t _TLS_Entry_0(int64_t arg1, int32_t arg2)

140013020  {
140013030      if (_.data != 2)
140013032          _.data = 2;
140013032      
14001303b      if (arg2 != 2 && arg2 == 1)
140013090          __mingw_TLScallback(arg1, arg2);
140013090      
14001304d      return 1;
140013020  }

14001304e                                            66 90                                                                f.
140013087                       66 0f 1f 84 00 00 00 00 00                                                         f........
1400130a1     66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00                                                   ff...........@.

1400130b0    int64_t __tlregdtor() __pure

1400130b0  {
1400130b2      return 0;
1400130b0  }

1400130b3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

1400130c0    int64_t _matherr(int32_t* arg1)

1400130c0  {
1400130d9      void* const rbx;
1400130d9      
1400130d9      if (*(uint32_t*)arg1 > 6)
1400131ac          rbx = "Unknown error";
1400130d9      else
1400130ef          switch (*(uint32_t*)arg1)
1400130ef          {
1400131ac              case 0:
1400131ac              {
1400131ac                  rbx = "Unknown error";
1400131ac                  break;
1400131ac              }
140013160              case 1:
140013160              {
140013160                  rbx = "Argument domain error (DOMAIN)";
140013160                  break;
140013160              }
1400130f8              case 2:
1400130f8              {
1400130f8                  rbx = "Argument singularity (SIGN)";
1400130f8                  break;
1400130f8              }
140013180              case 3:
140013180              {
140013180                  rbx = "Overflow range error (OVERFLOW)";
140013180                  break;
140013180              }
140013190              case 4:
140013190              {
140013190                  rbx = "The result is too small to be represented (UNDERFLOW)";
140013190                  break;
140013190              }
1400131a0              case 5:
1400131a0              {
1400131a0                  rbx = "Total loss of significance (TLOSS)";
1400131a0                  break;
1400131a0              }
140013170              case 6:
140013170              {
140013170                  rbx = "Partial loss of significance (PLOSS)";
140013170                  break;
140013170              }
1400130ef          }
1400130ef      
1400130ff      *(uint64_t*)((char*)arg1 + 8);
14001311d      uint64_t var_58 = *(uint64_t*)((char*)arg1 + 0x20);
14001312a      uint64_t var_60 = *(uint64_t*)((char*)arg1 + 0x18);
140013133      uint64_t var_68 = *(uint64_t*)((char*)arg1 + 0x10);
140013140      fprintf(__acrt_iob_func(2), "_matherr(): %s in %s(%g, %g)  (retval=%g)\n", rbx);
14001315e      return 0;
1400130c0  }

1400130f1                                                     0f 1f 80 00 00 00 00                                           .......
14001315f                                                                                               90                                 .
140013169                             0f 1f 80 00 00 00 00                                                           .......
140013179                                                                             0f 1f 80 00 00 00 00                           .......
14001318c                                      0f 1f 40 00                                                              ..@.
14001319c                                                                                      0f 1f 40 00                              ..@.
1400131b8                                                                          90 90 90 90 90 90 90 90                          ........

1400131c0    int64_t _fpreset() __pure

1400131c0  {
1400131c2      return;
1400131c0  }

1400131c3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

1400131d0    void __report_error(char* arg1, int64_t arg2) __noreturn

1400131d0  {
1400131e3      int64_t arg_10 = arg2;
1400131e8      int64_t r8;
1400131e8      int64_t arg_18 = r8;
1400131ed      int64_t r9;
1400131ed      int64_t arg_20 = r9;
140013211      fwrite("Mingw-w64 runtime failure:\n", 1, 0x1b, __acrt_iob_func(2));
14001322e      vfprintf(__acrt_iob_func(2), arg1, &arg_10);
140013233      abort();
140013233      /* no return */
1400131d0  }

140013238                                                                          90 0f 1f 80 00 00 00 00                          ........

140013240    int64_t* mark_section_writable(int64_t arg1)

140013240  {
140013247      int64_t maxSections_1 = (int64_t)maxSections;
140013253      int64_t* Protect;
140013253      
140013253      if ((uint32_t)maxSections_1 <= 0)
140013370          maxSections_1 = 0;
140013253      else
140013253      {
140013260          int32_t i = 0;
140013263          Protect = the_secs + 0x18;
140013263          
140013296          do
140013296          {
140013270              int64_t r8_1 = *(uint64_t*)Protect;
140013270              
140013285              if (arg1 >= r8_1 && arg1 < r8_1 + (uint64_t)*(uint32_t*)(Protect[1] + 8))
14001331c                  return Protect;
14001331c              
14001328b              i += 1;
14001328f              Protect = &Protect[5];
140013296          } while (i != (uint32_t)maxSections_1);
140013253      }
140013253      
14001329b      struct Section_Header* rax_2 = __mingw_GetSectionForAddress(arg1);
14001329b      
1400132a6      if (!rax_2)
1400132a6      {
14001339c          __report_error("Address %p has no image-section", arg1);
14001339c          /* no return */
1400132a6      }
1400132a6      
1400132b7      int64_t rbx_2 = maxSections_1 * 0x28;
1400132bb      int32_t* rax_4 = the_secs + rbx_2;
1400132be      *(uint64_t*)((char*)rax_4 + 0x20) = rax_2;
1400132c2      *(uint32_t*)rax_4 = 0;
1400132d6      void* lpAddress = &_GetPEImageBase()->e_magic[(uint64_t)rax_2->virtualAddress];
1400132e6      *(uint64_t*)(the_secs + rbx_2 + 0x18) = lpAddress;
1400132f4      MEMORY_BASIC_INFORMATION buffer;
1400132f4      
1400132f4      if (!VirtualQuery(lpAddress, &buffer, 0x30))
1400132f4      {
140013388          *(uint64_t*)(the_secs + rbx_2 + 0x18);
14001338d          __report_error("  VirtualQuery failed for %d bytes at address %p", 
14001338d              (uint64_t)rax_2->virtualSize);
14001338d          /* no return */
1400132f4      }
1400132f4      
1400132fa      Protect = (uint64_t)buffer.Protect;
1400132fa      
14001330c      if ((int32_t)&Protect[-8] & 0xffffffbf && (int32_t)((char*)Protect - 4) & 0xfffffffb)
14001330c      {
140013323          enum PAGE_PROTECTION_FLAGS flNewProtect = PAGE_EXECUTE_READWRITE;
14001332e          void* BaseAddress = buffer.BaseAddress;
14001332e          
140013333          if ((uint32_t)Protect == 2)
140013333              flNewProtect = PAGE_READWRITE;
140013333          
140013337          uint64_t RegionSize = buffer.RegionSize;
14001333c          enum PAGE_PROTECTION_FLAGS* lpflOldProtect = rbx_2 + the_secs;
140013346          *(uint64_t*)((char*)lpflOldProtect + 8) = BaseAddress;
14001334a          *(uint64_t*)((char*)lpflOldProtect + 0x10) = RegionSize;
14001334e          Protect = VirtualProtect(BaseAddress, RegionSize, flNewProtect, lpflOldProtect);
14001334e          
140013356          if (!(uint32_t)Protect)
140013356          {
140013367              __report_error("  VirtualProtect failed with code 0x%x", 
140013367                  (uint64_t)GetLastError());
140013367              /* no return */
140013356          }
14001330c      }
14001330c      
14001330e      maxSections += 1;
14001331c      return Protect;
140013240  }

14001331d                                                                                         0f 1f 00                               ...
14001336c                                      0f 1f 40 00                                                              ..@.
1400133a1     90 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                                                   .ff............

1400133b0    void _pei386_runtime_relocator()

1400133b0  {
1400133cd      if (_.bss)
1400133cd          return;
1400133cd      
1400133e0      _.bss = 1;
1400133fd      void* rax_5 = ((int64_t)__mingw_GetSectionCount() * 0x28 + 0xf) & 0xfffffffffffffff0;
140013401      _.text(rax_5);
14001340d      maxSections = 0;
140013426      void var_88;
140013426      the_secs = &var_88 - rax_5 + 0x30;
1400133b0  }

140013486                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
1400135c3           0f 1f 44 00 00                                                                             ..D..
1400135e7                       66 0f 1f 84 00 00 00 00 00                                                         f........
140013623           0f 1f 44 00 00                                                                             ..D..
14001366b                                   0f 1f 44 00 00                                                             ..D..
14001368c                                      0f 1f 40 00                                                              ..@.
1400136a3           0f 1f 44 00 00                                                                             ..D..
1400136bb                                                                                   0f 1f 44 00 00                             ..D..
14001370e                                            90 90                                                                ..

140013710    int64_t __mingw_raise_matherr(int32_t arg1, int64_t arg2, double arg3[0x2] @ zmm2, int64_t arg4 @ zmm3, int64_t arg5)

140013710  {
140013714      int64_t _.bss_1 = _.bss;
14001371e      double temp0[0x2] = _mm_unpacklo_pd(arg3, arg4);
14001371e      
140013722      if (!_.bss_1)
14001374d          return _.bss_1;
14001374d      
14001372d      int32_t var_38 = arg1;
140013736      int64_t var_30_1 = arg2;
14001373b      double var_28_1[0x2] = temp0;
140013740      int64_t var_18_1 = arg5;
140013746      return _.bss_1(&var_38);
140013710  }

14001374e                                            66 90                                                                f.

140013750    int64_t __mingw_setusermatherr(_UserMathErrorFunctionPointer arg1)

140013750  {
140013750      _.bss = arg1;
140013757      /* tailcall */
140013757      return __setusermatherr(arg1);
140013750  }

14001375c                                                                                      90 90 90 90                              ....

140013760    int64_t _gnu_exception_handler(int64_t* arg1)

140013760  {
140013765      int32_t* rdx = *(uint64_t*)arg1;
140013768      int32_t rax = *(uint32_t*)rdx;
140013768      
140013824      if ((rax & 0x20ffffff) == 0x20474343 && !(rdx[1] & 1))
1400137f7          return 0xffffffff;
1400137f7      
140013786      if (rax <= 0xc0000096)
140013786      {
14001378d          if (rax > 0xc000008b)
14001378d          {
14001378f              uint64_t rax_1 = (uint64_t)(rax + 0x3fffff73);
14001378f              
140013797              if ((uint32_t)rax_1 > 9)
1400137f7                  return 0xffffffff;
1400137f7              
1400137a7              _crt_signal_t rax_8;
1400137a7              
1400137a7              switch (rax_1)
1400137a7              {
140013847                  case 0:
140013847                  case 1:
140013847                  case 2:
140013847                  case 3:
140013847                  case 4:
140013847                  case 6:
140013847                  {
140013847                      rax_8 = signal(8, nullptr);
140013847                      
140013850                      if (rax_8 == 1)
140013850                      {
1400138e9                          signal(8, 1);
1400137f7                          return 0xffffffff;
140013850                      }
140013850                      
140013856                  label_140013856:
140013856                      
140013859                      if (rax_8)
140013859                      {
140013860                          rax_8(8);
1400137f7                          return 0xffffffff;
140013859                      }
140013847                      break;
140013847                  }
1400137f7                  case 5:
1400137f7                  case 8:
1400137f7                  {
1400137f7                      return 0xffffffff;
1400137f7                      break;
1400137f7                  }
14001386f                  case 7:
14001386f                  {
14001386f                      rax_8 = signal(8, nullptr);
14001386f                      
140013878                      if (rax_8 != 1)
140013878                          goto label_140013856;
140013878                      
140013884                      signal(8, 1);
1400137f7                      return 0xffffffff;
14001386f                      break;
14001386f                  }
1400137d2                  case 9:
1400137d2                  {
1400137d2                  label_1400137d2:
1400137d2                      _crt_signal_t rax_4 = signal(4, nullptr);
1400137d2                      
1400137db                      if (rax_4 == 1)
1400137db                      {
1400138c1                          signal(4, 1);
1400137f7                          return 0xffffffff;
1400137db                      }
1400137db                      
1400137e4                      if (rax_4)
1400137e4                      {
1400137eb                          rax_4(4);
1400137f7                          return 0xffffffff;
1400137e4                      }
1400137d2                      break;
1400137d2                  }
1400137a7              }
14001378d          }
14001378d          else if (rax == 0xc0000005)
1400137b5          {
140013897              _crt_signal_t rax_9 = signal(0xb, nullptr);
140013897              
1400138a0              if (rax_9 == 1)
1400138a0              {
1400138d5                  signal(0xb, 1);
1400137f7                  return 0xffffffff;
1400138a0              }
1400138a0              
1400138a5              if (rax_9)
1400138a5              {
1400138b0                  rax_9(0xb);
1400137f7                  return 0xffffffff;
1400138a5              }
1400137b5          }
1400137b5          else
1400137b5          {
1400137c2              if (rax == 0xc0000008)
1400137f7                  return 0xffffffff;
1400137f7              
1400137c9              if (rax == 0xc000001d)
1400137c9                  goto label_1400137d2;
1400137c9              
1400137fd              if (rax == 0x80000002)
1400137f7                  return 0xffffffff;
1400137b5          }
140013786      }
140013786      
1400137ff      int64_t _.bss_1 = _.bss;
1400137ff      
140013809      if (!_.bss_1)
140013837          return 0;
140013837      
140013813      /* tailcall */
140013813      return _.bss_1(arg1);
140013760  }

1400137a9                             0f 1f 80 00 00 00 00                                                           .......
140013816                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
14001382c                                      0f 1f 40 00                                                              ..@.
140013838                                                                          0f 1f 84 00 00 00 00 00                          ........
140013864              0f 1f 40 00                                                                              ..@.
14001388e                                            66 90                                                                f.
1400138f8                                                                          90 90 90 90 90 90 90 90                          ........

140013900    int64_t __mingwthr_run_key_dtors.part.0()

140013900  {
140013914      EnterCriticalSection(&__mingwthr_cs);
140013914      
140013924      for (int32_t* _.bss_1 = _.bss; _.bss_1; 
140013924          _.bss_1 = *(uint64_t*)((char*)_.bss_1 + 0x10))
140013924      {
14001393a          int64_t rax_1 = TlsGetValue(*(uint32_t*)_.bss_1);
14001393a          
140013948          if (!GetLastError() && rax_1)
140013951              (*(uint64_t*)((char*)_.bss_1 + 8))(rax_1);
140013924      }
140013924      
140013969      /* tailcall */
140013969      return LeaveCriticalSection(&__mingwthr_cs);
140013900  }


140013970    int64_t ___w64_mingwthr_add_key_dtor(int32_t arg1, int64_t arg2)

140013970  {
140013984      if (__mingwthr_cs_init)
140013984      {
14001399a          int32_t* rax_2 = calloc(1, 0x18);
14001399a          
1400139a5          if (!rax_2)
1400139da              return 0xffffffff;
1400139da          
1400139a7          *(uint64_t*)((char*)rax_2 + 8) = arg2;
1400139b2          *(uint32_t*)rax_2 = arg1;
1400139b7          EnterCriticalSection(&__mingwthr_cs);
1400139bd          int64_t _.bss_1 = _.bss;
1400139c7          _.bss = rax_2;
1400139ce          *(uint64_t*)((char*)rax_2 + 0x10) = _.bss_1;
1400139d2          LeaveCriticalSection(&__mingwthr_cs);
140013984      }
140013984      
140013986      return 0;
140013970  }

1400139df                                                                                               90                                 .

1400139e0    int64_t ___w64_mingwthr_remove_key_dtor(int32_t arg1)

1400139e0  {
1400139f0      if (!__mingwthr_cs_init)
1400139fa          return 0;
1400139fa      
140013a0a      EnterCriticalSection(&__mingwthr_cs);
140013a10      int32_t* _.bss_1 = _.bss;
140013a10      
140013a1a      if (_.bss_1)
140013a1a      {
140013a1c          int32_t* _.bss_3 = nullptr;
140013a1c          
140013a2f          while (true)
140013a2f          {
140013a2f              int32_t* _.bss_2 = *(uint64_t*)((char*)_.bss_1 + 0x10);
140013a2f              
140013a33              if (*(uint32_t*)_.bss_1 == arg1)
140013a33              {
140013a38                  if (!_.bss_3)
140013a58                      _.bss = _.bss_2;
140013a38                  else
140013a3a                      *(uint64_t*)((char*)_.bss_3 + 0x10) = _.bss_2;
140013a3a                  
140013a3e                  free(_.bss_1);
140013a3e                  break;
140013a33              }
140013a33              
140013a23              _.bss_3 = _.bss_1;
140013a23              
140013a26              if (!_.bss_2)
140013a26                  break;
140013a26              
140013a28              _.bss_1 = _.bss_2;
140013a2f          }
140013a1a      }
140013a1a      
140013a46      LeaveCriticalSection(&__mingwthr_cs);
140013a54      return 0;
1400139e0  }

1400139fb                                                                                   0f 1f 44 00 00                             ..D..
140013a55                                                                 0f 1f 00                                               ...
140013a61     66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00                                                   ff...........@.

140013a70    int64_t __mingw_TLScallback(int64_t arg1, int32_t arg2)

140013a70  {
140013a78      if (arg2 == 2)
140013b3f          return 1;
140013b3f      
140013a7e      if (arg2 > 2)
140013a7e      {
140013abd          if (arg2 == 3 && __mingwthr_cs_init)
140013abf              __mingwthr_run_key_dtors.part.0();
140013a7e      }
140013a7e      else if (!arg2)
140013a82      {
140013ad8          if (__mingwthr_cs_init)
140013b40              __mingwthr_run_key_dtors.part.0();
140013b40          
140013ae3          if (__mingwthr_cs_init == 1)
140013ae3          {
140013ae5              void* _.bss_1 = _.bss;
140013ae5              
140013aef              while (_.bss_1)
140013aef              {
140013af8                  void* _.bss_2 = _.bss_1;
140013afb                  _.bss_1 = *(uint64_t*)((char*)_.bss_1 + 0x10);
140013aff                  free(_.bss_2);
140013aef              }
140013aef              
140013b10              _.bss = 0;
140013b1b              __mingwthr_cs_init = 0;
140013b25              DeleteCriticalSection(&__mingwthr_cs);
140013ae3          }
140013a82      }
140013a82      else
140013a82      {
140013a8c          if (!__mingwthr_cs_init)
140013b57              InitializeCriticalSection(&__mingwthr_cs);
140013b57          
140013a92          __mingwthr_cs_init = 1;
140013a82      }
140013a82      
140013aa6      return 1;
140013a70  }

140013aa7                       66 0f 1f 84 00 00 00 00 00                                                         f........
140013ac6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
140013b47                       66 0f 1f 84 00 00 00 00 00                                                         f........
140013b62        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

140013b70    void exit(int32_t arg1) __noreturn

140013b70  {
140013b7b      exit(arg1);
140013b7b      /* no return */
140013b70  }

140013b7d                                                                                         90 66 90                               .f.

140013b80    void _exit(int32_t arg1) __noreturn

140013b80  {
140013b8b      _exit(arg1);
140013b8b      /* no return */
140013b80  }

140013b8d                                         90 90 90                                                               ...

140013b90    int64_t _ValidateImageBase(int16_t* arg1)

140013b90  {
140013b97      if (*(uint16_t*)arg1 == 0x5a4d)
140013b97      {
140013b9d          void* rcx = (char*)arg1 + (int64_t)*(uint32_t*)((char*)arg1 + 0x3c);
140013b9d          
140013ba6          if (*(uint32_t*)rcx == 0x4550)
140013ba6          {
140013bb8              int64_t result;
140013bb8              (uint8_t)result = *(uint16_t*)((char*)rcx + 0x18) == 0x20b;
140013bbb              return result;
140013ba6          }
140013b97      }
140013b97      
140013ba8      return 0;
140013b90  }

140013ba9                             0f 1f 80 00 00 00 00                                                           .......
140013bbc                                                                                      0f 1f 40 00                              ..@.

140013bc0    void* _FindPESection(void* arg1, int64_t arg2)

140013bc0  {
140013bc4      void* rcx = (char*)arg1 + (int64_t)*(uint32_t*)((char*)arg1 + 0x3c);
140013bc7      uint32_t r8 = (uint32_t)*(uint16_t*)((char*)rcx + 6);
140013bd4      void* result = (char*)rcx + (uint64_t)*(uint16_t*)((char*)rcx + 0x14) + 0x18;
140013bd4      
140013bd9      if ((uint16_t)r8)
140013bd9      {
140013be3          void* r9_1 = (char*)result + (uint64_t)(r8 - 1) * 0x28 + 0x28;
140013be3          
140013c0b          do
140013c0b          {
140013bf0              uint64_t r8_1 = (uint64_t)*(uint32_t*)((char*)result + 0xc);
140013bf0              
140013c02              if (arg2 >= r8_1 && arg2
140013c02                      < (uint64_t)((uint32_t)r8_1 + *(uint32_t*)((char*)result + 8)))
140013c0f                  return result;
140013c0f              
140013c04              result += 0x28;
140013c0b          } while (result != r9_1);
140013bd9      }
140013bd9      
140013c0d      return nullptr;
140013bc0  }


140013c10    struct Section_Header* const _FindPESectionByName(char* arg1)

140013c10  {
140013c23      if (strlen(arg1) <= 8)
140013c23      {
140013c77          for (struct Section_Header* const _Str1 = &__section_headers; 
140013c77              _Str1 != 0x140000480; _Str1 = &_Str1[1])
140013c77          {
140013c8c              if (!strncmp(_Str1, arg1, 8))
140013c98                  return _Str1;
140013c77          }
140013c23      }
140013c23      
140013cac      return 0;
140013c10  }

140013c6c                                      0f 1f 40 00                                                              ..@.
140013c99                                                                             0f 1f 80 00 00 00 00                           .......
140013cad                                         0f 1f 00                                                               ...

140013cb0    struct Section_Header* const __mingw_GetSectionForAddress(int64_t arg1)

140013cb0  {
140013d2b      for (struct Section_Header* const i = &__section_headers; i != 0x140000480; 
140013d2b          i = &i[1])
140013d2b      {
140013d10          uint64_t virtualAddress = (uint64_t)i->virtualAddress;
140013d10          
140013d22          if (arg1 - &__dos_header >= virtualAddress && arg1 -
140013d22                  &__dos_header < (uint64_t)((uint32_t)virtualAddress + i->virtualSize))
140013cd0              return i;
140013d2b      }
140013d2b      
140013d2f      return 0;
140013cb0  }

140013cd1                                                     0f 1f 80 00 00 00 00                                           .......

140013d30    int64_t __mingw_GetSectionCount() __pure

140013d30  {
140013d66      return 0x13;
140013d30  }

140013d52                                                        66 0f 1f 44 00 00                                            f..D..
140013d67                       66 0f 1f 84 00 00 00 00 00                                                         f........

140013d70    struct Section_Header* const _FindPESectionExec(int64_t arg1)

140013d70  {
140013dde      for (struct Section_Header* const i = &__section_headers; i != 0x140000480; 
140013dde          i = &i[1])
140013dde      {
140013dcc          if (*(uint8_t*)((char*)i->characteristics)[3] & 0x20)
140013dcc          {
140013dd1              if (!arg1)
140013d90                  return i;
140013d90              
140013dd3              arg1 -= 1;
140013dcc          }
140013dde      }
140013dde      
140013de2      return 0;
140013d70  }

140013d91                                                     0f 1f 80 00 00 00 00                                           .......
140013de3           66 66 2e 0f 1f 84 00 00 00 00 00 66 90                                                     ff.........f.

140013df0    struct DOS_Header* const _GetPEImageBase() __pure

140013e1e  {
140013e1e      return &__dos_header;
140013e1e  }

140013e13                                                           0f 1f 44 00 00                                             ..D..
140013e26                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

140013e30    uint64_t _IsNonwritableInCurrentImage(int64_t arg1)

140013e30  {
140013e72      struct Section_Header* const i = &__section_headers;
140013e72      
140013eab      do
140013eab      {
140013e90          uint64_t virtualAddress = (uint64_t)i->virtualAddress;
140013e90          
140013ea2          if (arg1 - &__dos_header >= virtualAddress && arg1 -
140013ea2                  &__dos_header < (uint64_t)((uint32_t)virtualAddress + i->virtualSize))
140013eb8              return (uint64_t)(~i->characteristics >> 0x1f);
140013eb8          
140013ea4          i = &i[1];
140013eab      } while (0x140000480 != i);
140013eab      
140013eaf      return 0;
140013e30  }

140013e51                                                     0f 1f 80 00 00 00 00                                           .......
140013eb9                                                                             0f 1f 80 00 00 00 00                           .......

140013ec0    void* __mingw_enum_import_library_names(int32_t arg1)

140013ec0  {
140013f4c      for (struct Section_Header* const i = &__section_headers; i != 0x140000480; 
140013f4c          i = &i[1])
140013f4c      {
140013f30          uint64_t virtualAddress = (uint64_t)i->virtualAddress;
140013f30          
140013f43          if (0x28000 >= virtualAddress
140013f43              && 0x28000 < (uint64_t)((uint32_t)virtualAddress + i->virtualSize))
140013f43          {
140013f58              void* rax_3 = &_.idata$2;
140013f58              
140013f75              while (*(uint32_t*)((char*)rax_3 + 4) || *(uint32_t*)((char*)rax_3 + 0xc))
140013f75              {
140013f79                  if (arg1 <= 0)
140013f85                      return &
140013f85                          __dos_header.e_magic[(uint64_t)*(uint32_t*)((char*)rax_3 + 0xc)];
140013f85                  
140013f60                  arg1 -= 1;
140013f63                  rax_3 += 0x14;
140013f75              }
140013f75              
140013f79              break;
140013f43          }
140013f4c      }
140013f4c      
140013f54      return 0;
140013ec0  }

140013ee6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
140013f55                                                                 0f 1f 00                                               ...
140013f5d                                                                                         0f 1f 00                               ...
140013f86                    90 90 90 90 90 90 90 90 90 90                                                        ..........

140013f90    int64_t _.text(int64_t arg1 @ rax)

140013f90  {
140013f91      int64_t result = arg1;
140013f98      void arg_8;
140013f98      void* rcx = &arg_8;
140013f98      
140013f9d      if (arg1 >= 0x1000)
140013f9d      {
140013fb6          do
140013fb6          {
140013f9f              rcx -= 0x1000;
140013fa6              *(uint64_t*)rcx = *(uint64_t*)rcx;
140013faa              arg1 -= 0x1000;
140013fb6          } while (arg1 > 0x1000);
140013f9d      }
140013f9d      
140013fb8      void* rcx_1 = (char*)rcx - arg1;
140013fbb      *(uint64_t*)rcx_1 = *(uint64_t*)rcx_1;
140013fc1      return result;
140013f90  }

140013fc2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

140013fd0    int64_t emutls_destroy(int64_t* arg1)

140013fd0  {
140013fd7      int64_t rdi = *(uint64_t*)arg1;
140013fd7      
140013fe0      if (rdi)
140013fe0      {
140013fe2          int64_t rbx_1 = 0;
140013fe2          
140014002          do
140014002          {
140013fe8              void* rax_1 = arg1[rbx_1 + 1];
140013fe8              
140013ff0              if (rax_1)
140013ff6                  free(*(uint64_t*)((char*)rax_1 - 8));
140013ff6              
140013ffb              rbx_1 += 1;
140014002          } while (rdi != rbx_1);
140013fe0      }
140013fe0      
14001400e      /* tailcall */
14001400e      return free(arg1);
140013fd0  }

140014013                                                           66 66 2e 0f 1f 84 00 00 00 00 00 66 90                     ff.........f.

140014020    int64_t emutls_init()

140014020  {
14001402d      pthread_mutex_init(&emutls_mutex, nullptr);
140014040      int32_t result = pthread_key_create(&emutls_key, emutls_destroy);
140014040      
140014047      if (!result)
14001404d          return result;
14001404d      
14001404e      abort();
14001404e      /* no return */
140014020  }

140014053                                                           90 66 66 2e 0f 1f 84 00 00 00 00 00 90                     .ff..........

140014060    int64_t __emutls_get_address(int64_t* arg1)

140014060  {
14001406a      int64_t rsi = arg1[2];
14001406a      
140014074      if (!rsi)
140014074      {
1400140c6          pthread_once(&_.bss, emutls_init);
1400140d5          pthread_mutex_lock(&emutls_mutex);
1400140da          rsi = arg1[2];
1400140da          
1400140e1          if (!rsi)
1400140e1          {
14001422f              rsi = emutls_size + 1;
140014233              emutls_size = rsi;
14001423a              arg1[2] = rsi;
1400140e1          }
1400140e1          
1400140ea          pthread_mutex_unlock(&emutls_mutex);
140014074      }
140014074      
14001407c      int64_t* rax_1 = pthread_getspecific(emutls_key);
140014084      int64_t* rbx = rax_1;
140014087      int64_t rcx_1;
140014087      int64_t rsi_1;
140014087      
140014087      if (!rax_1)
140014087      {
140014101          int64_t* rax_3 = calloc(rsi + 0x21, 8);
14001410d          rbx = rax_3;
14001410d          
140014110          if (rax_3)
140014110          {
140014116              int32_t emutls_key_1 = emutls_key;
14001411c              rsi_1 = rsi - 1;
140014120              *(uint64_t*)rax_3 = rsi + 0x20;
140014126              pthread_setspecific(emutls_key_1, rax_3);
14001412b              rcx_1 = rbx[rsi_1 + 1];
14001412b              
140014133              if (rcx_1)
1400140b4                  return rcx_1;
1400140b4              
140014140          label_140014140:
140014140              int64_t rbp_2 = arg1[1];
140014144              uint64_t _Size = *(uint64_t*)arg1;
14001414b              void* rcx_4;
14001414b              
14001414b              if (rbp_2 > 8)
14001414b              {
140014205                  int64_t rax_9 = malloc(_Size + rbp_2 + 7);
140014205                  
14001420d                  if (rax_9)
14001420d                  {
140014217                      rcx_4 = (rax_9 + rbp_2 + 7) & -(rbp_2);
14001421a                      *(uint64_t*)((char*)rcx_4 - 8) = rax_9;
14001416b                  label_14001416b:
14001416b                      int64_t rdx_2 = arg1[3];
140014175                      int64_t rcx_5;
140014175                      
140014175                      if (!rdx_2)
14001424f                          rcx_5 = memset(rcx_4, 0, _Size);
140014175                      else
140014180                          rcx_5 = memcpy(rcx_4, rdx_2, _Size);
140014180                      
140014186                      rbx[rsi_1 + 1] = rcx_5;
140014195                      return rcx_5;
14001420d                  }
14001414b              }
14001414b              else
14001414b              {
140014156                  int64_t* rax_4 = malloc(_Size + 8);
140014156                  
14001415e                  if (rax_4)
14001415e                  {
140014164                      *(uint64_t*)rax_4 = rax_4;
140014167                      rcx_4 = &rax_4[1];
140014167                      goto label_14001416b;
14001415e                  }
14001414b              }
140014110          }
140014087      }
140014087      else
140014087      {
140014089          int64_t rbp = *(uint64_t*)rax_1;
140014089          
14001408f          if (rbp >= rsi)
14001408f              goto label_140014095;
14001408f          
1400141a0          int64_t r12_1 = rbp * 2;
1400141a0          
1400141af          if (r12_1 < rsi)
1400141af              r12_1 = rsi + 0x20;
1400141af          
1400141bb          int64_t* rax_8 = realloc(rbx, (r12_1 << 3) + 8);
1400141c3          rbx = rax_8;
1400141c3          
1400141c6          if (rax_8)
1400141c6          {
1400141cc              *(uint64_t*)rax_8 = r12_1;
1400141e1              memset(&rax_8[rbp + 1], 0, (r12_1 - rbp) << 3);
1400141ef              pthread_setspecific(emutls_key, rbx);
140014095          label_140014095:
140014095              rsi_1 = rsi - 1;
140014099              rcx_1 = rbx[rsi_1 + 1];
140014099              
1400140a1              if (!rcx_1)
1400140a1                  goto label_140014140;
1400140a1              
1400140b4              return rcx_1;
1400141c6          }
140014087      }
140014257      abort();
140014257      /* no return */
140014060  }

1400140b5                                                                 0f 1f 00                                               ...
1400140f1                                                     0f 1f 80 00 00 00 00                                           .......
140014196                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
1400141f9                                                                             0f 1f 80 00 00 00 00                           .......
140014223           0f 1f 44 00 00                                                                             ..D..
140014243           0f 1f 44 00 00                                                                             ..D..
14001425c                                                                                      90 0f 1f 00                              ....

140014260    int64_t __emutls_register_common(int64_t* arg1, int64_t arg2, int64_t arg3, int64_t arg4)

140014260  {
140014263      if (*(uint64_t*)arg1 < arg2)
140014263      {
140014265          *(uint64_t*)arg1 = arg2;
140014268          arg1[3] = 0;
140014263      }
140014263      
140014274      if (arg1[1] < arg3)
140014276          arg1[1] = arg3;
140014276      
140014282      if (!arg4 || *(uint64_t*)arg1 != arg2)
140014284          return;
140014284      
140014288      arg1[3] = arg4;
140014260  }

140014285                 0f 1f 00                                                                               ...
14001428d                                         90 90 90                                                               ...

140014290    uint64_t __mingw_vfprintf(FILE* arg1, char* arg2, int64_t* arg3)

140014290  {
1400142a0      _lock_file(arg1);
1400142b8      int32_t rax = __mingw_pformat(0x6000, arg1, 0, arg2, arg3);
1400142c2      _unlock_file(arg1);
1400142d0      return (uint64_t)rax;
140014290  }

1400142d1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

1400142e0    void* __pformat_cvt(int32_t arg1, int64_t* arg2, int32_t arg3, int32_t* arg4, int32_t* arg5)

1400142e0  {
1400142e4      int64_t rax = *(uint64_t*)arg2;
1400142e7      int32_t rdx = arg2[1];
1400142ed      int64_t var_18 = rax;
1400142f5      int32_t var_10 = rdx;
1400142fc      int16_t r10 = (uint16_t)rdx & 0x7fff;
140014302      int32_t var_24;
140014302      int32_t rcx_1;
140014302      int32_t rdx_4;
140014302      
140014302      if (!r10)
140014302      {
140014307          uint32_t rdx_2 = (int32_t)(rax >> 0x20);
140014307          
14001430d          if (!((uint32_t)rax | rdx_2))
14001430d          {
1400143a2              rdx_4 = 0;
14001432a              var_24 = 0;
14001432e              rcx_1 = rdx & 0x8000;
14001430d          }
14001430d          else
14001430d          {
140014315              if (rdx_2 < 0)
140014315                  goto label_140014322;
140014315              
1400143b5              rdx_4 = -0x403d;
14001432a              var_24 = 2;
14001432e              rcx_1 = rdx & 0x8000;
14001430d          }
140014302      }
140014302      else if (r10 != 0x7fff)
14001437e      {
140014322      label_140014322:
140014327          rdx_4 = (int32_t)(r10 - 0x403e);
14001432a          var_24 = 1;
14001432e          rcx_1 = rdx & 0x8000;
14001437e      }
14001437e      else if (!(((int32_t)(rax >> 0x20) & 0x7fffffff) | (uint32_t)rax))
14001438f      {
1400143c5          rdx_4 = 0;
14001432a          var_24 = 3;
14001432e          rcx_1 = rdx & 0x8000;
14001438f      }
14001438f      else
14001438f      {
140014391          var_24 = 4;
140014399          rdx_4 = 0;
14001439b          rcx_1 = 0;
14001438f      }
14001438f      
14001433c      *(uint32_t*)arg5 = rcx_1;
140014371      void* var_20;
140014371      return __gdtoa(&_.data, rdx_4, &var_18, &var_24, arg1, arg3, arg4, &var_20);
1400142e0  }

140014372                                                        66 0f 1f 44 00 00                                            f..D..
14001439f                                                                                               90                                 .
1400143a6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
1400143bf                                                                                               90                                 .
1400143cc                                      0f 1f 40 00                                                              ..@.

1400143d0    int64_t __pformat_putc(int32_t arg1, char** arg2)

1400143d0  {
1400143d8      int16_t rdx = (int16_t)arg2[1];
1400143de      int32_t rax_1;
1400143de      
1400143de      if (!(*(uint8_t*)((char*)rdx)[1] & 0x40))
1400143e0          rax_1 = *(uint32_t*)((char*)arg2 + 0x24);
1400143e0      
1400143e6      if (*(uint8_t*)((char*)rdx)[1] & 0x40 || arg2[5] > rax_1)
1400143e6      {
1400143e8          *(uint8_t*)((char*)rdx)[1] &= 0x20;
1400143eb          char* _Stream = *(uint64_t*)arg2;
1400143eb          
1400143ee          if (*(uint8_t*)((char*)rdx)[1])
1400143ee          {
140014413              fputc(arg1, _Stream);
14001441b              int32_t result = *(uint32_t*)((char*)arg2 + 0x24) + 1;
14001441e              *(uint32_t*)((char*)arg2 + 0x24) = result;
140014426              return result;
1400143ee          }
1400143ee          
1400143f4          _Stream[(int64_t)*(uint32_t*)((char*)arg2 + 0x24)] = (uint8_t)arg1;
1400143f7          rax_1 = *(uint32_t*)((char*)arg2 + 0x24);
1400143e6      }
1400143e6      
1400143fd      *(uint32_t*)((char*)arg2 + 0x24) = rax_1 + 1;
140014405      return rax_1 + 1;
1400143d0  }

140014406                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
140014427                       66 0f 1f 84 00 00 00 00 00                                                         f........

140014430    int64_t __pformat_wputchars(int64_t arg1, int32_t arg2, char** arg3)

140014430  {
140014445      int32_t rsi = arg2;
14001445a      mbstate_t _State;
14001445a      char var_58[0x18];
14001445a      wcrtomb(&var_58, 0, &_State);
14001445f      int32_t rax = arg3[2];
140014464      int32_t rdx = rax;
140014464      
140014466      if (rsi <= rax)
140014466          rdx = rsi;
140014466      
14001446b      int32_t i_1 = *(uint32_t*)((char*)arg3 + 0xc);
14001446b      
14001446e      if (rax >= 0)
14001446e          rsi = rdx;
14001446e      
140014473      int32_t r12;
140014473      
140014473      if (i_1 > rsi)
140014473      {
14001455b          int32_t rax_9 = i_1 - rsi;
14001455d          bool cond:2_1 = *(uint8_t*)((char*)arg3 + 9) & 4;
140014561          *(uint32_t*)((char*)arg3 + 0xc) = rax_9;
140014561          
140014564          if (!cond:2_1)
140014564          {
140014569              *(uint32_t*)((char*)arg3 + 0xc) = rax_9 - 1;
140014588              int32_t i;
140014588              
140014588              do
140014588              {
140014578                  __pformat_putc(0x20, arg3);
14001457d                  i = *(uint32_t*)((char*)arg3 + 0xc);
140014585                  *(uint32_t*)((char*)arg3 + 0xc) = i - 1;
140014588              } while (i);
14001458a              r12 = rsi - 1;
14001458a              
140014590              if (rsi <= 0)
140014590                  goto label_14001453d;
140014590              
140014590              goto label_14001448c;
140014564          }
140014564          
1400145a0          r12 = rsi - 1;
1400145a0          
1400145a6          if (rsi > 0)
1400145a6              goto label_14001448c;
1400145a6          
1400145ac          *(uint32_t*)((char*)arg3 + 0xc) -= 1;
140014548      label_140014548:
140014548          
140014548          do
140014548          {
140014538              __pformat_putc(0x20, arg3);
14001453d          label_14001453d:
14001453d              i_1 = *(uint32_t*)((char*)arg3 + 0xc);
140014545              *(uint32_t*)((char*)arg3 + 0xc) = i_1 - 1;
140014548          } while (i_1 > 0);
140014548          
14001455a          return i_1;
140014473      }
140014473      
140014479      *(uint32_t*)((char*)arg3 + 0xc) = 0xffffffff;
140014480      r12 = rsi - 1;
140014480      
140014486      if (rsi <= 0)
1400145b5          *(uint32_t*)((char*)arg3 + 0xc) = 0xfffffffe;
140014486      else
140014486      {
14001448c      label_14001448c:
14001448c          int64_t rsi_1 = 0;
14001448c          
1400144a3          while (true)
1400144a3          {
1400144a3              int32_t rax_1 = wcrtomb(&var_58, *(uint16_t*)(arg1 + (rsi_1 << 1)), &_State);
1400144a3              
1400144aa              if (rax_1 <= 0)
1400144aa                  goto label_14001453d;
1400144aa              
1400144b3              void* r14_1 = &var_58;
1400144b3              
1400144d5              while (true)
1400144d5              {
1400144d5                  int16_t rdx_3 = (int16_t)arg3[1];
1400144d8                  r14_1 += 1;
1400144df                  int32_t rax_3;
1400144df                  
1400144df                  if (!(*(uint8_t*)((char*)rdx_3)[1] & 0x40))
1400144e1                      rax_3 = *(uint32_t*)((char*)arg3 + 0x24);
1400144e1                  
1400144e7                  if (*(uint8_t*)((char*)rdx_3)[1] & 0x40 || arg3[5] > rax_3)
1400144e7                  {
1400144e9                      *(uint8_t*)((char*)rdx_3)[1] &= 0x20;
1400144ec                      int32_t _Character = (int32_t)*(uint8_t*)((char*)r14_1 - 1);
1400144f1                      char* _Stream = *(uint64_t*)arg3;
1400144f1                      
1400144f4                      if (!*(uint8_t*)((char*)rdx_3)[1])
1400144f4                      {
1400144c4                          _Stream[(int64_t)*(uint32_t*)((char*)arg3 + 0x24)] =
1400144c4                              (uint8_t)_Character;
1400144c7                          rax_3 = *(uint32_t*)((char*)arg3 + 0x24);
1400144f4                      }
1400144f4                      else
1400144f4                      {
1400144f9                          fputc(_Character, _Stream);
140014507                          *(uint32_t*)((char*)arg3 + 0x24) += 1;
140014507                          
14001450a                          if (r14_1 == &var_58[(uint64_t)(rax_1 - 1) + 1])
14001450a                              break;
14001450a                          
14001450a                          continue;
1400144f4                      }
1400144e7                  }
1400144e7                  
1400144d0                  *(uint32_t*)((char*)arg3 + 0x24) = rax_3 + 1;
1400144d0                  
1400144d3                  if (r14_1 == &var_58[(uint64_t)(rax_1 - 1) + 1])
1400144d3                      break;
1400144d5              }
1400144d5              
14001450c              rsi_1 += 1;
14001450c              
140014517              if (r12 + 1 - (uint32_t)rsi_1 <= 0)
140014517                  break;
1400144a3          }
1400144a3          
14001451d          i_1 = *(uint32_t*)((char*)arg3 + 0xc);
140014525          *(uint32_t*)((char*)arg3 + 0xc) = i_1 - 1;
140014525          
140014528          if (i_1 > 0)
140014528              goto label_140014548;
140014486      }
140014486      
14001455a      return i_1;
140014430  }

1400144bd                                                                                         0f 1f 00                               ...
140014598                                                                          0f 1f 84 00 00 00 00 00                          ........
1400145be                                                                                            66 90                                f.

1400145c0    int64_t __pformat_putchars(void* arg1, int32_t arg2, char** arg3)

1400145c0  {
1400145c7      int32_t rax = arg3[2];
1400145cb      int32_t rdi = arg2;
1400145cf      int32_t rdx = rax;
1400145cf      
1400145d1      if (arg2 <= rax)
1400145d1          rdx = rdi;
1400145d1      
1400145d6      int32_t result = *(uint32_t*)((char*)arg3 + 0xc);
1400145da      void* rsi = arg1;
1400145da      
1400145e0      if (rax >= 0)
1400145e0          rdi = rdx;
1400145e0      
1400145e5      int32_t rdx_1;
1400145e5      
1400145e5      if (result <= rdi)
1400145e5      {
1400145eb          *(uint32_t*)((char*)arg3 + 0xc) = 0xffffffff;
1400145f3          rdx_1 = rdi - 1;
1400145f3          
1400145f8          if (rdi)
1400145f8              goto label_1400145fe;
1400145f8          
140014695          *(uint32_t*)((char*)arg3 + 0xc) = 0xfffffffe;
1400146a3          return result;
1400145e5      }
1400145e5      
1400146a8      int32_t rax_4 = result - rdi;
1400146ac      *(uint32_t*)((char*)arg3 + 0xc) = rax_4;
1400146b0      int16_t rax_1 = (int16_t)arg3[1];
1400146b0      
1400146b7      if (*(uint8_t*)((char*)rax_1)[1] & 4)
1400146b7      {
1400146f0          rdx_1 = rdi - 1;
1400146f0          
1400146f5          if (rdi)
1400146f5              goto label_140014604;
1400146f5          
1400146fb          *(uint32_t*)((char*)arg3 + 0xc) -= 1;
1400146ff          goto label_140014671;
1400146b7      }
1400146b7      
1400146bc      *(uint32_t*)((char*)arg3 + 0xc) = rax_4 - 1;
1400146d8      int32_t i;
1400146d8      
1400146d8      do
1400146d8      {
1400146c8          __pformat_putc(0x20, arg3);
1400146cd          i = *(uint32_t*)((char*)arg3 + 0xc);
1400146d5          *(uint32_t*)((char*)arg3 + 0xc) = i - 1;
1400146d8      } while (i);
1400146da      rdx_1 = rdi - 1;
1400146da      
1400146df      if (rdi)
1400146df      {
1400145fe      label_1400145fe:
1400145fe          rax_1 = (int16_t)arg3[1];
140014604      label_140014604:
140014604          void* rdi_2 = (uint64_t)(rdx_1 + 1) + rsi;
140014604          
140014628          while (true)
140014628          {
140014628              rsi += 1;
14001462f              int32_t rdx_2;
14001462f              
14001462f              if (!(*(uint8_t*)((char*)rax_1)[1] & 0x40))
140014631                  rdx_2 = *(uint32_t*)((char*)arg3 + 0x24);
140014631              
140014637              if (*(uint8_t*)((char*)rax_1)[1] & 0x40 || arg3[5] > rdx_2)
140014637              {
14001463c                  int32_t _Character = (int32_t)*(uint8_t*)((char*)rsi - 1);
140014640                  char* _Stream = *(uint64_t*)arg3;
140014640                  
140014643                  if (!(*(uint8_t*)((char*)rax_1)[1] & 0x20))
140014643                  {
140014614                      _Stream[(int64_t)*(uint32_t*)((char*)arg3 + 0x24)] =
140014614                          (uint8_t)_Character;
140014617                      rdx_2 = *(uint32_t*)((char*)arg3 + 0x24);
140014643                  }
140014643                  else
140014643                  {
140014645                      fputc(_Character, _Stream);
14001464a                      rdx_2 = *(uint32_t*)((char*)arg3 + 0x24);
140014643                  }
140014637              }
140014637              
140014620              *(uint32_t*)((char*)arg3 + 0x24) = rdx_2 + 1;
140014620              
140014623              if (rsi == rdi_2)
140014623                  break;
140014623              
140014625              rax_1 = (int16_t)arg3[1];
140014628          }
1400146df      }
1400146df      
140014661      while (true)
140014661      {
140014661          result = *(uint32_t*)((char*)arg3 + 0xc);
140014669          *(uint32_t*)((char*)arg3 + 0xc) = result - 1;
140014669          
14001466c          if (result <= 0)
1400146a3              return result;
1400146a3          
14001466e          rax_1 = (int16_t)arg3[1];
140014671      label_140014671:
140014674          int32_t rdx_4;
140014674          
140014674          if (!(*(uint8_t*)((char*)rax_1)[1] & 0x40))
140014676              rdx_4 = *(uint32_t*)((char*)arg3 + 0x24);
140014676          
14001467c          if (*(uint8_t*)((char*)rax_1)[1] & 0x40 || arg3[5] > rdx_4)
14001467c          {
140014681              char* _Stream_1 = *(uint64_t*)arg3;
140014681              
140014684              if (!(*(uint8_t*)((char*)rax_1)[1] & 0x20))
140014684              {
140014654                  _Stream_1[(int64_t)*(uint32_t*)((char*)arg3 + 0x24)] = 0x20;
140014658                  rdx_4 = *(uint32_t*)((char*)arg3 + 0x24);
140014684              }
140014684              else
140014684              {
14001468b                  fputc(0x20, _Stream_1);
140014690                  rdx_4 = *(uint32_t*)((char*)arg3 + 0x24);
140014684              }
14001467c          }
14001467c          
14001465e          *(uint32_t*)((char*)arg3 + 0x24) = rdx_4 + 1;
140014661      }
1400145c0  }

140014609                             0f 1f 80 00 00 00 00                                                           .......
14001464f                                               90                                                                 .
1400146a4              0f 1f 40 00                                                                              ..@.
1400146ea                                66 0f 1f 44 00 00                                                            f..D..
140014704              66 66 2e 0f 1f 84 00 00 00 00 00 90                                                      ff..........

140014710    int64_t __pformat_puts(char* arg1, char** arg2)

140014710  {
140014720      int64_t rdx = (int64_t)arg2[2];
140014727      char* _Str = arg1;
140014727      
14001472a      if (!arg1)
14001472a          _Str = "(null)";
14001472a      
140014733      int32_t rax;
140014733      
140014733      if ((uint32_t)rdx < 0)
140014750          rax = strlen(_Str);
140014733      else
140014735          rax = strnlen(_Str, rdx);
140014735      
140014748      /* tailcall */
140014748      return __pformat_putchars(_Str, rax, arg2);
140014710  }

14001474d                                         0f 1f 00                                                               ...
140014757                                                                       66 0f 1f 84 00 00 00 00 00                         f........

140014760    int64_t __pformat_emit_inf_or_nan(int32_t arg1, char* arg2, char** arg3)

140014760  {
140014764      int32_t r10 = arg3[1];
14001476a      arg3[2] = 0xffffffff;
140014772      char var_c;
140014772      void* r9;
140014772      void var_b;
140014772      
140014772      if (arg1)
140014772      {
1400147d5          var_c = 0x2d;
1400147d9          r9 = &var_b;
140014772      }
140014772      else if (r10 & 0x100)
140014780      {
1400147d5          var_c = 0x2b;
1400147d9          r9 = &var_b;
140014780      }
140014780      else if (!((uint8_t)r10 & 0x40))
1400147ed          r9 = &var_c;
140014786      else
140014786      {
140014788          r9 = &var_b;
140014792          var_c = 0x20;
140014786      }
140014786      
1400147b7      for (int64_t i = 0; i != 3; i += 1)
1400147ab          *(uint8_t*)((char*)r9 + i) = (arg2[i] & 0xdf) | ((uint8_t)r10 & 0x20);
1400147ab      
1400147cd      return __pformat_putchars(&var_c, (uint32_t)r9 + 3 - &var_c, arg3);
140014760  }

1400147ce                                            66 90                                                                f.
1400147e5                 0f 1f 00                                                                               ...
1400147f2                                                        66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                    ff............

140014800    int64_t __pformat_xint.isra.0(int32_t arg1, uint64_t arg2, char** arg3)

140014800  {
14001481e      void var_68;
14001481e      int32_t rax_1;
14001481e      char rcx;
14001481e      int32_t rdi;
14001481e      char r8_4;
14001481e      int32_t r12;
14001481e      void* r13;
14001481e      int32_t r15;
14001481e      
14001481e      if (arg1 != 0x6f)
14001481e      {
140014824          r15 = arg3[2];
140014828          int32_t rax = 0;
14001482a          rdi = arg3[1];
14001482a          
140014831          if (r15 >= 0)
140014831              rax = r15;
140014831          
140014835          rax_1 = rax + 0x12;
140014835          
14001483e          if (rdi & 0x1000)
14001483e          {
140014844              rcx = 4;
140014844              goto label_14001484e;
14001483e          }
14001483e          
1400148e0          r12 = *(uint32_t*)((char*)arg3 + 0xc);
1400148e0          
1400148e7          if (r12 >= rax_1)
1400148e7              rax_1 = r12;
1400148e7          
1400148f1          int64_t rax_7 = ((int64_t)rax_1 + 0xf) & 0xfffffffffffffff0;
1400148f5          _.text(rax_7);
1400148fa          rcx = 4;
1400148ff          r8_4 = 0xf;
140014908          r13 = &var_68 - rax_7 + 0x20;
140014908          goto label_140014910;
14001481e      }
14001481e      
140014b20      r15 = arg3[2];
140014b24      int32_t rax_20 = 0;
140014b26      rdi = arg3[1];
140014b26      
140014b2d      if (r15 >= 0)
140014b2d          rax_20 = r15;
140014b2d      
140014b31      rax_1 = rax_20 + 0x18;
140014b3a      void* rsi;
140014b3a      
140014b3a      if (rdi & 0x1000)
140014b3a      {
140014b3c          rcx = 3;
14001484e      label_14001484e:
14001484e          
14001484e          if (arg3[4])
140014861              rax_1 += rax_1 / 3;
140014861          
140014864          r12 = *(uint32_t*)((char*)arg3 + 0xc);
140014864          
14001486b          if (r12 >= rax_1)
14001486b              rax_1 = r12;
14001486b          
140014875          int64_t rax_4 = ((int64_t)rax_1 + 0xf) & 0xfffffffffffffff0;
140014879          _.text(rax_4);
140014888          r13 = &var_68 - rax_4 + 0x20;
14001488d          int64_t r8_3;
14001488d          (uint8_t)r8_3 = arg1 != 0x6f;
140014894          r8_4 = (char)((r8_3 << 3) + 7);
14001489c          rsi = r13;
14001489c          
14001489f          if (arg2)
14001489f              goto label_140014947;
14001489f          
14001489f          goto label_1400148b1;
140014b3a      }
140014b3a      
140014ba0      r12 = *(uint32_t*)((char*)arg3 + 0xc);
140014ba0      
140014ba7      if (r12 >= rax_1)
140014ba7          rax_1 = r12;
140014ba7      
140014bb1      int64_t rax_23 = ((int64_t)rax_1 + 0xf) & 0xfffffffffffffff0;
140014bb5      _.text(rax_23);
140014bba      rcx = 3;
140014bbf      r8_4 = 7;
140014bc8      r13 = &var_68 - rax_23 + 0x20;
140014910  label_140014910:
140014910      rsi = r13;
140014910      
140014913      if (arg2)
140014913      {
140014947      label_140014947:
140014947          
140014947          do
140014947          {
140014923              rsi += 1;
140014927              char rax_9 = r8_4 & (uint8_t)arg2;
140014930              char rax_11 = (rax_9 + 0x37) | ((uint8_t)arg1 & 0x20);
140014930              
14001493a              if (rax_9 + 0x30 <= 0x39)
14001493a                  rax_11 = rax_9 + 0x30;
14001493a              
14001493e              arg2 u>>= rcx;
140014944              *(uint8_t*)((char*)rsi - 1) = rax_11;
140014947          } while (arg2);
140014947          
14001494c          if (rsi == r13)
14001494c              goto label_1400148b1;
14001494c          
140014955          if (r15 <= 0)
140014955              goto label_1400148ba;
140014955          
140014955          goto label_140014961;
140014913      }
140014913      
1400148b1  label_1400148b1:
1400148b1      arg3[1] = rdi & 0xfffff7ff;
1400148b1      
1400148b4      if (r15 <= 0)
1400148b4      {
1400148ba      label_1400148ba:
1400148ba          
1400148c8          if (arg1 != 0x6f || !(*(uint8_t*)((char*)arg3 + 9) & 8))
1400148be              goto label_140014986;
1400148be          
1400148ce      label_1400148ce:
1400148ce          *(uint8_t*)rsi = 0x30;
1400148d1          rsi += 1;
1400148d5          goto label_140014986;
1400148b4      }
1400148b4      
140014961  label_140014961:
140014961      int32_t result = (uint32_t)rsi - (uint32_t)r13;
140014964      int32_t _Size_3 = r15 - result;
140014964      
14001496a      if (_Size_3 > 0)
14001496a      {
140014970          uint64_t _Size = (int64_t)_Size_3;
140014973          void* rcx_1 = rsi;
14001497e          rsi += _Size;
140014981          memset(rcx_1, 0x30, _Size);
140014986      label_140014986:
140014986          
14001498e          if (rsi == r13 && r15)
140014989              goto label_140014c2c;
140014989          
140014997          result = (uint32_t)rsi - (uint32_t)r13;
140014997          goto label_14001499a;
14001496a      }
14001496a      
140014b64      if (arg1 == 0x6f)
140014b64      {
1400148c8          if (!(*(uint8_t*)((char*)arg3 + 9) & 8))
1400148c8              goto label_140014986;
1400148c8          
1400148c8          goto label_1400148ce;
140014b64      }
140014b64      
140014b6d      int32_t rdi_2;
140014b6d      int32_t r12_1;
140014b6d      int32_t result_1;
140014b6d      
140014b6d      if (rsi == r13)
140014b6d      {
140014c2c      label_140014c2c:
140014c2c          *(uint8_t*)rsi = 0x30;
140014c2f          int32_t rax_26 = ((char*)rsi + 1);
140014c32          rsi += 1;
140014c35          result = rax_26 - (uint32_t)r13;
14001499a      label_14001499a:
14001499a          
14001499d          if (result < r12)
14001499d          {
1400149f8              r12_1 = r12 - result;
1400149ff              rdi_2 = arg3[1];
140014a02              *(uint32_t*)((char*)arg3 + 0xc) = r12_1;
140014a02              
140014a0e              if (arg1 != 0x6f && rdi_2 & 0x800)
140014a06                  goto label_140014a10;
140014a06              
140014be4              if (r15 >= 0 || (rdi_2 & 0x600) != 0x200)
140014a33                  goto label_140014a39;
140014a33              
140014bea              uint64_t _Size_1 = (int64_t)r12_1;
140014bed              void* rcx_2 = rsi;
140014bf8              rsi += _Size_1;
140014bfb              result = memset(rcx_2, 0x30, _Size_1);
140014bfb              
140014c04              if (arg1 == 0x6f)
140014c04                  goto label_1400149c1;
140014c04              
140014c04              goto label_140014c10;
14001499d          }
14001499d          
1400149a3          *(uint32_t*)((char*)arg3 + 0xc) = 0xffffffff;
1400149a3          
1400149aa          if (arg1 != 0x6f)
1400149aa              goto label_1400149b0;
1400149aa          
140014c43          if (r13 < rsi)
140014c43          {
140014c49              rdi_2 = arg3[1];
140014c4c              result_1 = -2;
140014c52              r12_1 = -1;
140014a90          label_140014a90:
140014a90              
140014a90              while (true)
140014a90              {
140014a90                  rsi -= 1;
140014a9a                  int32_t rax_15;
140014a9a                  
140014a9a                  if (!(rdi_2 & 0x4000))
140014a9c                      rax_15 = *(uint32_t*)((char*)arg3 + 0x24);
140014a9c                  
140014aa2                  if (!(rdi_2 & 0x4000) && arg3[5] <= rax_15)
140014aa2                      goto label_140014a82;
140014aa2                  
140014aaa                  int32_t _Character = (int32_t)*(uint8_t*)rsi;
140014aad                  FILE* _Stream = *(uint64_t*)arg3;
140014aad                  
140014ab0                  if (!(rdi_2 & 0x2000))
140014ab0                  {
140014a7c                      *(uint8_t*)((char*)_Stream
140014a7c                          + (int64_t)*(uint32_t*)((char*)arg3 + 0x24)) = (uint8_t)_Character;
140014a7f                      rax_15 = *(uint32_t*)((char*)arg3 + 0x24);
140014a82                  label_140014a82:
140014a82                      result = rax_15 + 1;
140014a88                      *(uint32_t*)((char*)arg3 + 0x24) = result;
140014a88                      
140014a8b                      if (r13 >= rsi)
140014a8b                          break;
140014ab0                  }
140014ab0                  else
140014ab0                  {
140014ab2                      fputc(_Character, _Stream);
140014aba                      result = *(uint32_t*)((char*)arg3 + 0x24) + 1;
140014ac0                      *(uint32_t*)((char*)arg3 + 0x24) = result;
140014ac0                      
140014ac3                      if (r13 >= rsi)
140014ac3                          break;
140014ab0                  }
140014ab0                  
140014a8d              label_140014a8d:
140014a8d                  rdi_2 = arg3[1];
140014a90              }
140014a90              
140014ac8              if (r12_1 > 0)
140014ac8              {
140014af1                  while (true)
140014af1                  {
140014af1                      rdi_2 = arg3[1];
140014af4                  label_140014af4:
140014afa                      int32_t rax_18;
140014afa                      
140014afa                      if (!(rdi_2 & 0x4000))
140014afc                          rax_18 = *(uint32_t*)((char*)arg3 + 0x24);
140014afc                      
140014b02                      if (rdi_2 & 0x4000 || arg3[5] > rax_18)
140014b02                      {
140014b0a                          char* _Stream_1 = *(uint64_t*)arg3;
140014b0a                          
140014b0d                          if (!(rdi_2 & 0x2000))
140014b0d                          {
140014ad4                              _Stream_1[(int64_t)*(uint32_t*)((char*)arg3 + 0x24)] = 0x20;
140014ad8                              rax_18 = *(uint32_t*)((char*)arg3 + 0x24);
140014b0d                          }
140014b0d                          else
140014b0d                          {
140014b14                              fputc(0x20, _Stream_1);
140014b19                              rax_18 = *(uint32_t*)((char*)arg3 + 0x24);
140014b0d                          }
140014b02                      }
140014b02                      
140014ae1                      *(uint32_t*)((char*)arg3 + 0x24) = rax_18 + 1;
140014ae4                      result = result_1 - 1;
140014ae4                      
140014ae8                      if (result_1 <= 0)
1400149f0                          return result;
1400149f0                      
140014aee                      result_1 = result;
140014af1                  }
140014ac8              }
140014c43          }
140014b6d      }
140014b6d      else if (result >= r12)
140014b76      {
140014c5d          *(uint32_t*)((char*)arg3 + 0xc) = 0xffffffff;
1400149b0      label_1400149b0:
1400149b0          
1400149b4          if (!(*(uint8_t*)((char*)arg3 + 9) & 8))
1400149b4              goto label_1400149c1;
1400149b4          
1400149b6          *(uint8_t*)rsi = (uint8_t)arg1;
1400149b9          rsi += 2;
1400149bd          *(uint8_t*)((char*)rsi - 1) = 0x30;
1400149c1      label_1400149c1:
1400149c1          r12_1 = -1;
1400149c7      label_1400149c7:
1400149c7          
1400149ca          if (r13 < rsi)
1400149ca          {
1400149cc              rdi_2 = arg3[1];
1400149cf              result_1 = r12_1 - 1;
1400149d4              goto label_140014a90;
1400149ca          }
140014b76      }
140014b76      else
140014b76      {
140014b7c          rdi_2 = arg3[1];
140014b7f          r12_1 = r12 - result;
140014b82          *(uint32_t*)((char*)arg3 + 0xc) = r12_1;
140014b82          
140014b8c          if (!(rdi_2 & 0x800))
140014b8c              goto label_140014a39;
140014b8c          
140014a10      label_140014a10:
140014a10          r12_1 -= 2;
140014a10          
140014a17          if (r12_1 <= 0)
140014a17          {
140014a1d          label_140014a1d:
140014a1d              *(uint8_t*)rsi = (uint8_t)arg1;
140014a20              rsi += 2;
140014a24              *(uint8_t*)((char*)rsi - 1) = 0x30;
140014a28              goto label_1400149c7;
140014a17          }
140014a17          
140014c8a          if (r15 < 0 && (rdi_2 & 0x600) == 0x200)
140014c8a          {
140014c8c              uint64_t _Size_2 = (int64_t)r12_1;
140014c8f              void* rcx_3 = rsi;
140014c9a              rsi += _Size_2;
140014c9d              result = memset(rcx_3, 0x30, _Size_2);
140014c10          label_140014c10:
140014c10              r12_1 = -1;
140014c10              
140014c16              if (!(rdi_2 & 0x800))
140014c16                  goto label_1400149c7;
140014c16              
140014c16              goto label_140014a1d;
140014c8a          }
140014c8a          
140014c6e          *(uint8_t*)rsi = (uint8_t)arg1;
140014c71          rsi += 2;
140014c75          *(uint8_t*)((char*)rsi - 1) = 0x30;
140014a39      label_140014a39:
140014a39          result_1 = r12_1 - 1;
140014a39          
140014a44          if (rdi_2 & 0x400)
140014a44          {
140014b53              if (r13 >= rsi)
140014b53                  goto label_140014af4;
140014b53              
140014b53              goto label_140014a90;
140014a44          }
140014a44          
140014a4a          r12_1 = result_1;
140014a61          int32_t i;
140014a61          
140014a61          do
140014a61          {
140014a58              result = __pformat_putc(0x20, arg3);
140014a5d              i = r12_1;
140014a5d              r12_1 -= 1;
140014a61          } while (i >= 1);
140014a66          result_1 = -2;
140014a66          
140014a6c          if (r13 < rsi)
140014a6c              goto label_140014a8d;
140014b76      }
1400149f0      return result;
140014800  }

1400148da                                                                                66 0f 1f 44 00 00                            f..D..
1400149d9                                                                             0f 1f 80 00 00 00 00                           .......
1400149f1                                                     0f 1f 80 00 00 00 00                                           .......
140014a2a                                66 0f 1f 44 00 00                                                            f..D..
140014a73                                                           0f 1f 44 00 00                                             ..D..
140014acf                                               90                                                                 .
140014b1e                                                                                            66 90                                f.
140014b46                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
140014b5b                                                                                   0f 1f 44 00 00                             ..D..
140014b97                                                                       66 0f 1f 84 00 00 00 00 00                         f........
140014bd2                                                        66 0f 1f 44 00 00                                            f..D..
140014c21     0f 1f 80 00 00 00 00                                                                           .......
140014c3d                                                                                         0f 1f 00                               ...
140014ca7                       66 0f 1f 84 00 00 00 00 00                                                         f........

140014cb0    int64_t __pformat_int.isra.0(uint64_t arg1, char** arg2)

140014cb0  {
140014cc5      int32_t rax = 0;
140014cc7      int32_t r14 = arg2[2];
140014ccb      int32_t r12 = arg2[1];
140014ccb      
140014cd5      if (r14 >= 0)
140014cd5          rax = r14;
140014cd5      
140014cd9      int32_t rax_1 = rax + 0x17;
140014cd9      
140014cea      if (r12 & 0x1000 && arg2[4])
140014f48          rax_1 += rax_1 / 3;
140014f48      
140014cf0      int32_t rsi = *(uint32_t*)((char*)arg2 + 0xc);
140014cf0      
140014cf5      if (rsi >= rax_1)
140014cf5          rax_1 = rsi;
140014cf5      
140014cfe      int64_t rax_4 = ((int64_t)rax_1 + 0xf) & 0xfffffffffffffff0;
140014d02      _.text(rax_4);
140014d02      
140014d13      if (!((uint8_t)r12 & 0x80))
140014d13          goto label_140014d29;
140014d13      
140014d18      void var_68;
140014d18      void* rdi_1;
140014d18      
140014d18      if (arg1 < 0)
140014d18      {
140014f90          arg1 = -(arg1);
140014d3f      label_140014d3f:
140014d3f          void* r8_1 = &var_68 - rax_4 + 0x20;
140014d3f          
140014d58          while (true)
140014d58          {
140014d58              rdi_1 = (char*)r8_1 + 1;
140014d65              uint64_t rdx_1 = arg1 / 0xa;
140014d7a              *(uint8_t*)r8_1 =
140014d7a                  (uint8_t)arg1 - ((uint8_t)rdx_1 + (char)(rdx_1 << 2)) * 2 + 0x30;
140014d7a              
140014d7d              if (arg1 <= 9)
140014d7d                  break;
140014d7d              
140014d9d              if (&var_68 - rax_4 + 0x20 != rdi_1 && r12 & 0x1000 && arg2[4]
140014d9d                  && (((char*)rdi_1 - (&var_68 - rax_4 + 0x20)) & 0x8000000000000003)
140014d9d                  == 3)
140014d9d              {
140014d9f                  *(uint8_t*)rdi_1 = 0x2c;
140014da2                  rdi_1 = (char*)r8_1 + 2;
140014d9d              }
140014d9d              
140014db0              arg1 = rdx_1;
140014db3              r8_1 = rdi_1;
140014d58          }
140014d18      }
140014d18      else
140014d18      {
140014d1e          (uint8_t)r12 &= 0x7f;
140014d22          arg2[1] = r12;
140014d29      label_140014d29:
140014d29          rdi_1 = &var_68 - rax_4 + 0x20;
140014d29          
140014d2c          if (arg1)
140014d2c              goto label_140014d3f;
140014d18      }
140014d18      
140014dc3      if (r14 <= 0)
140014dc3          goto label_140014df0;
140014dc3      
140014dce      int32_t _Size_3 = r14 - ((uint32_t)rdi_1 - (&var_68 - rax_4 + 0x20));
140014dd4      void* rax_15;
140014dd4      
140014dd4      if (_Size_3 > 0)
140014dd4      {
140014dda          int64_t _Size_1 = (int64_t)_Size_3;
140014ddd          void* rcx = rdi_1;
140014de8          rdi_1 += _Size_1;
140014deb          memset(rcx, 0x30, _Size_1);
140014df0      label_140014df0:
140014df0          
140014df3          if (&var_68 - rax_4 + 0x20 == rdi_1)
140014df3          {
140014df8              rax_15 = rdi_1;
140014df8              
140014dfb              if (r14)
140014dfb              {
140014f7c                  rdi_1 = (char*)rax_15 + 1;
140014f80                  *(uint8_t*)rax_15 = 0x30;
140014dfb              }
140014df3          }
140014dd4      }
140014dd4      else if (&var_68 - rax_4 + 0x20 == rdi_1)
140014f73      {
140014f79          rax_15 = &var_68 - rax_4 + 0x20;
140014f7c          rdi_1 = (char*)rax_15 + 1;
140014f80          *(uint8_t*)rax_15 = 0x30;
140014f73      }
140014f73      
140014e03      if (rsi > 0)
140014e03      {
140014e0b          int32_t rsi_1 = rsi - ((uint32_t)rdi_1 - (&var_68 - rax_4 + 0x20));
140014e0f          *(uint32_t*)((char*)arg2 + 0xc) = rsi_1;
140014e0f          
140014e12          if (rsi_1 > 0)
140014e12          {
140014e1b              if (!(r12 & 0x1c0))
140014e1b              {
140014fbc                  if (r14 < 0 && (r12 & 0x600) == 0x200)
140014e24                      goto label_140014fc2;
140014e24                  
140014e24                  goto label_140014e2a;
140014e1b              }
140014e1b              
140014fa6              *(uint32_t*)((char*)arg2 + 0xc) = rsi_1 - 1;
140014fa6              
140014fbc              if (r14 >= 0 || (r12 & 0x600) != 0x200)
140014fbc              {
140014e2a              label_140014e2a:
140014e2a                  
140014e31                  if (!(r12 & 0x400))
140014e31                  {
140014ff8                      int32_t rax_26 = *(uint32_t*)((char*)arg2 + 0xc);
140015000                      *(uint32_t*)((char*)arg2 + 0xc) = rax_26 - 1;
140015000                      
140015003                      if (rax_26 > 0)
140015003                      {
140015028                          int32_t i;
140015028                          
140015028                          do
140015028                          {
140015018                              __pformat_putc(0x20, arg2);
14001501d                              i = *(uint32_t*)((char*)arg2 + 0xc);
140015025                              *(uint32_t*)((char*)arg2 + 0xc) = i - 1;
140015028                          } while (i > 0);
14001502a                          r12 = arg2[1];
140015003                      }
140014e31                  }
140014fbc              }
140014fbc              else
140014fbc              {
140014fc2              label_140014fc2:
140014fc2                  int32_t _Size_2 = *(uint32_t*)((char*)arg2 + 0xc);
140014fca                  *(uint32_t*)((char*)arg2 + 0xc) = _Size_2 - 1;
140014fca                  
140014fcd                  if (_Size_2 > 0)
140014fcd                  {
140014fd3                      uint64_t _Size = (int64_t)_Size_2;
140014fd6                      void* rcx_2 = rdi_1;
140014fe1                      rdi_1 += _Size;
140014fe4                      memset(rcx_2, 0x30, _Size);
140014fe9                      *(uint32_t*)((char*)arg2 + 0xc) = 0xffffffff;
140014fcd                  }
140014fbc              }
140014e12          }
140014e03      }
140014e03      
140014e44      void* rsi_2;
140014e44      
140014e44      if ((uint8_t)r12 & 0x80)
140014e44      {
140014e4a          rsi_2 = (char*)rdi_1 + 1;
140014e4e          *(uint8_t*)rdi_1 = 0x2d;
140014e44      }
140014e44      else if (!(r12 & 0x100))
140014f27      {
140014f54          rsi_2 = rdi_1;
140014f54          
140014f57          if ((uint8_t)r12 & 0x40)
140014f57          {
140014f5d              rsi_2 += 1;
140014f61              *(uint8_t*)rdi_1 = 0x20;
140014f57          }
140014f27      }
140014f27      else
140014f27      {
140014f29          rsi_2 = (char*)rdi_1 + 1;
140014f2d          *(uint8_t*)rdi_1 = 0x2b;
140014f27      }
140014f27      
140014e54      if (&var_68 - rax_4 + 0x20 < rsi_2)
140014e54      {
140014e79          while (true)
140014e79          {
140014e79              rsi_2 -= 1;
140014e84              int32_t rax_19;
140014e84              
140014e84              if (!(r12 & 0x4000))
140014e86                  rax_19 = *(uint32_t*)((char*)arg2 + 0x24);
140014e86              
140014e8c              if (!(r12 & 0x4000) && arg2[5] <= rax_19)
140014e8c                  goto label_140014e70;
140014e8c              
140014e95              int32_t _Character = (int32_t)*(uint8_t*)rsi_2;
140014e98              FILE* _Stream = *(uint64_t*)arg2;
140014e98              
140014e9b              if (!(r12 & 0x2000))
140014e9b              {
140014e64                  *(uint8_t*)((char*)_Stream
140014e64                      + (int64_t)*(uint32_t*)((char*)arg2 + 0x24)) = (uint8_t)_Character;
140014e67                  rax_19 = *(uint32_t*)((char*)arg2 + 0x24);
140014e70              label_140014e70:
140014e70                  *(uint32_t*)((char*)arg2 + 0x24) = rax_19 + 1;
140014e70                  
140014e73                  if (&var_68 - rax_4 + 0x20 == rsi_2)
140014e73                      break;
140014e9b              }
140014e9b              else
140014e9b              {
140014e9d                  fputc(_Character, _Stream);
140014eab                  *(uint32_t*)((char*)arg2 + 0x24) += 1;
140014eab                  
140014eae                  if (&var_68 - rax_4 + 0x20 == rsi_2)
140014eae                      break;
140014e9b              }
140014e9b              
140014e75              r12 = arg2[1];
140014e79          }
140014e54      }
140014e54      
140014eb0      int32_t result = *(uint32_t*)((char*)arg2 + 0xc);
140014eb0      
140014ecc      while (true)
140014ecc      {
140014ecc          int32_t result_1 = result;
140014ece          result -= 1;
140014ed3          *(uint32_t*)((char*)arg2 + 0xc) = result;
140014ed3          
140014ed6          if (result_1 <= 0)
140014ed6              break;
140014ed6          
140014ed8          int16_t rcx_1 = (int16_t)arg2[1];
140014ede          int32_t rdx_2;
140014ede          
140014ede          if (!(*(uint8_t*)((char*)rcx_1)[1] & 0x40))
140014ee0              rdx_2 = *(uint32_t*)((char*)arg2 + 0x24);
140014ee0          
140014ee6          if (*(uint8_t*)((char*)rcx_1)[1] & 0x40 || arg2[5] > rdx_2)
140014ee6          {
140014ee8              *(uint8_t*)((char*)rcx_1)[1] &= 0x20;
140014eeb              char* _Stream_1 = *(uint64_t*)arg2;
140014eeb              
140014eee              if (!*(uint8_t*)((char*)rcx_1)[1])
140014eee              {
140014ebc                  _Stream_1[(int64_t)*(uint32_t*)((char*)arg2 + 0x24)] = 0x20;
140014ec0                  rdx_2 = *(uint32_t*)((char*)arg2 + 0x24);
140014ec3                  result = *(uint32_t*)((char*)arg2 + 0xc);
140014eee              }
140014eee              else
140014eee              {
140014ef5                  fputc(0x20, _Stream_1);
140014efa                  rdx_2 = *(uint32_t*)((char*)arg2 + 0x24);
140014efd                  result = *(uint32_t*)((char*)arg2 + 0xc);
140014eee              }
140014ee6          }
140014ee6          
140014ec9          *(uint32_t*)((char*)arg2 + 0x24) = rdx_2 + 1;
140014ecc      }
140014ecc      
140014f18      return result;
140014cb0  }

140014db8                                                                          0f 1f 84 00 00 00 00 00                          ........
140014e58                                                                          0f 1f 84 00 00 00 00 00                          ........
140014eb5                                                                 0f 1f 00                                               ...
140014f02        66 0f 1f 44 00 00                                                                            f..D..
140014f19                                                                             0f 1f 80 00 00 00 00                           .......
140014f35                                                                 0f 1f 00                                               ...
140014f4f                                               90                                                                 .
140014f69                             0f 1f 80 00 00 00 00                                                           .......
140014f88                          0f 1f 84 00 00 00 00 00                                                          ........
140014f98                                                                          0f 1f 84 00 00 00 00 00                          ........
140014ff5                                                                 0f 1f 00                                               ...
140015033                                                           66 66 2e 0f 1f 84 00 00 00 00 00 66 90                     ff.........f.

140015040    int64_t __pformat_emit_radix_point(char** arg1)

140015040  {
140015056      mbstate_t _State;
140015056      wchar16 _Source;
140015056      
140015056      if (*(uint32_t*)((char*)arg1 + 0x14) == 0xfffffffd)
140015056      {
140015130          __builtin_memset(&_State, 0, 8);
140015151          wchar16 _DstCh;
140015151          int32_t rax_10 = mbrtowc(&_DstCh, localeconv()->decimal_point, 0x10, &_State);
140015151          
140015158          if (rax_10 <= 0)
140015188              _Source = arg1[3];
140015158          else
140015158          {
14001515a              _Source = _DstCh;
14001515e              arg1[3] = _Source;
140015158          }
140015158          
140015162          *(uint32_t*)((char*)arg1 + 0x14) = rax_10;
140015056      }
140015056      else
14001505c          _Source = arg1[3];
14001505c      
140015063      if (!_Source)
140015127          return __pformat_putc(0x2e, arg1);
140015127      
140015074      int64_t rax_3 =
140015074          ((int64_t)*(uint32_t*)((char*)arg1 + 0x14) + 0xf) & 0xfffffffffffffff0;
140015078      _.text(rax_3);
14001507d      __builtin_memset(&_State, 0, 8);
14001508c      void var_58;
14001508c      void* rsi = &var_58 - rax_3 + 0x20;
140015094      int32_t rax_4 = wcrtomb(rsi, _Source, &_State);
140015094      
14001509b      if (rax_4 <= 0)
140015178          return __pformat_putc(0x2e, arg1);
140015178      
1400150a4      void* r12_1 = (char*)rsi + (uint64_t)(rax_4 - 1) + 1;
1400150c5      int32_t result;
1400150c5      
1400150c5      while (true)
1400150c5      {
1400150c5          int16_t rdx_1 = (int16_t)arg1[1];
1400150c8          rsi += 1;
1400150cf          int32_t rax_6;
1400150cf          
1400150cf          if (!(*(uint8_t*)((char*)rdx_1)[1] & 0x40))
1400150d1              rax_6 = *(uint32_t*)((char*)arg1 + 0x24);
1400150d1          
1400150d7          if (*(uint8_t*)((char*)rdx_1)[1] & 0x40 || arg1[5] > rax_6)
1400150d7          {
1400150d9              *(uint8_t*)((char*)rdx_1)[1] &= 0x20;
1400150dc              int32_t _Character = (int32_t)*(uint8_t*)((char*)rsi - 1);
1400150e0              char* _Stream = *(uint64_t*)arg1;
1400150e0              
1400150e3              if (!*(uint8_t*)((char*)rdx_1)[1])
1400150e3              {
1400150b4                  _Stream[(int64_t)*(uint32_t*)((char*)arg1 + 0x24)] = (uint8_t)_Character;
1400150b7                  rax_6 = *(uint32_t*)((char*)arg1 + 0x24);
1400150e3              }
1400150e3              else
1400150e3              {
1400150e8                  fputc(_Character, _Stream);
1400150f0                  result = *(uint32_t*)((char*)arg1 + 0x24) + 1;
1400150f6                  *(uint32_t*)((char*)arg1 + 0x24) = result;
1400150f6                  
1400150f9                  if (r12_1 == rsi)
1400150f9                      break;
1400150f9                  
1400150f9                  continue;
1400150e3              }
1400150d7          }
1400150d7          
1400150ba          result = rax_6 + 1;
1400150c0          *(uint32_t*)((char*)arg1 + 0x24) = result;
1400150c0          
1400150c3          if (r12_1 == rsi)
1400150c3              break;
1400150c5      }
1400150c5      
140015107      return result;
140015040  }

1400150ab                                   0f 1f 44 00 00                                                             ..D..
140015108                          0f 1f 84 00 00 00 00 00                                                          ........
140015128                          0f 1f 84 00 00 00 00 00                                                          ........
14001516a                                66 0f 1f 44 00 00                                                            f..D..
140015185                 0f 1f 00                                                                               ...
14001518e                                            66 90                                                                f.

140015190    int64_t __pformat_emit_float(int32_t arg1, char* arg2, int32_t arg3, char** arg4)

140015190  {
14001519d      char* rdi = arg2;
1400151a0      int32_t rcx = *(uint32_t*)((char*)arg4 + 0xc);
1400151a4      int32_t i_4 = arg3;
1400151aa      int32_t rax_1;
1400151aa      int32_t rcx_1;
1400151aa      int32_t rcx_2;
1400151aa      
1400151aa      if (arg3 <= 0)
1400151aa      {
1400152e2          if (rcx > 0)
1400152e2          {
1400152e8              rax_1 = arg4[2];
1400152ec              rcx_1 = rcx - 1;
1400152ec              
1400152f1              if (rcx_1 <= rax_1)
1400152f1                  goto label_1400152f9;
1400152f1              
1400151c4          label_1400151c4:
1400151c4              rcx_2 = rcx_1 - rax_1;
1400151c8              *(uint32_t*)((char*)arg4 + 0xc) = rcx_2;
1400151c8              
1400151cb              if (rax_1 <= 0)
1400151cb                  goto label_140015418;
1400151cb              
1400151d1          label_1400151d1:
1400151d1              rcx_2 -= 1;
1400151d6              *(uint32_t*)((char*)arg4 + 0xc) = rcx_2;
1400151d6              
14001543a              if (i_4 > 0 && *(uint8_t*)((char*)arg4 + 9) & 0x10 && arg4[4])
1400151d9                  goto label_14001552b;
1400151d9              
1400151e5          label_1400151e5:
1400151e5              
1400151e7              if (rcx_2 <= 0)
1400151e7                  goto label_14001522b;
1400151e7              
1400151e7              goto label_1400151e9;
1400152e2          }
1400152e2          
140015400          int32_t rax_2;
140015400          
140015400          if (rcx)
140015400          {
1400152f9          label_1400152f9:
1400152f9              *(uint32_t*)((char*)arg4 + 0xc) = 0xffffffff;
1400152f9              
140015300              if (!arg1)
140015300              {
140015233              label_140015233:
140015233                  rax_2 = arg4[1];
140015236              label_140015236:
140015236                  
140015239                  if (*(uint8_t*)((char*)rax_2)[1] & 1)
140015450                      __pformat_putc(0x2b, arg4);
140015239                  else if ((uint8_t)rax_2 & 0x40)
140015548                      __pformat_putc(0x20, arg4);
140015300              }
140015300              else
140015318                  __pformat_putc(0x2d, arg4);
140015400          }
140015400          else
140015400          {
140015406              int32_t rcx_9 = arg4[2];
140015406              
14001540c              if (rcx_9 >= 0)
14001540c                  goto label_1400152f9;
14001540c              
140015412              rcx_2 = -(rcx_9);
140015414              *(uint32_t*)((char*)arg4 + 0xc) = rcx_2;
140015418          label_140015418:
140015418              int16_t rax_11 = (int16_t)arg4[1];
140015418              
14001541e              if (*(uint8_t*)((char*)rax_11)[1] & 8)
14001541e                  goto label_1400151d1;
14001541e              
14001542f              if (i_4 > 0 && *(uint8_t*)((char*)rax_11)[1] & 0x10)
14001542f              {
14001543a                  if (!arg4[4])
14001543a                      goto label_1400151e5;
14001543a                  
14001543a                  goto label_14001552b;
14001542f              }
14001542f              
1400151e9          label_1400151e9:
1400151eb              int32_t rcx_8;
1400151eb              
1400151eb              if (!arg1)
1400151eb              {
1400151f1                  rax_2 = arg4[1];
1400151f1                  
1400151f9                  if (!(rax_2 & 0x1c0))
1400151f9                  {
1400154e8                      rcx_8 = rcx_2 - 1;
1400154e8                      
1400154ee                      if (!(*(uint8_t*)((char*)rax_2)[1] & 6))
1400154ee                          goto label_1400153d6;
1400154ee                      
1400154ee                      goto label_140015236;
1400151f9                  }
1400151f9                  
140015204                  *(uint32_t*)((char*)arg4 + 0xc) = rcx_2 - 1;
140015204                  
14001520c                  if (rcx_2 == 1 || *(uint8_t*)((char*)rax_2)[1] & 6)
140015207                      goto label_140015236;
140015207                  
140015207                  goto label_1400153d3;
1400151eb              }
1400151eb              
1400153bd              *(uint32_t*)((char*)arg4 + 0xc) = rcx_2 - 1;
1400153bd              
1400153cd              if (rcx_2 != 1 && !(arg4[1] & 0x600))
1400153cd              {
1400153d3              label_1400153d3:
1400153d3                  rcx_8 = rcx_2 - 2;
1400153d6              label_1400153d6:
1400153d6                  *(uint32_t*)((char*)arg4 + 0xc) = rcx_8;
1400153f8                  int32_t i;
1400153f8                  
1400153f8                  do
1400153f8                  {
1400153e8                      __pformat_putc(0x20, arg4);
1400153ed                      i = *(uint32_t*)((char*)arg4 + 0xc);
1400153f5                      *(uint32_t*)((char*)arg4 + 0xc) = i - 1;
1400153f8                  } while (i > 0);
1400153f8                  goto label_14001522b;
1400153cd              }
1400153cd              
140015318              __pformat_putc(0x2d, arg4);
140015400          }
1400151aa      }
1400151aa      else
1400151aa      {
1400151b3          int32_t rax_15;
1400151b3          
1400151b3          if (arg3 <= rcx)
1400151b3          {
1400151b5              rax_1 = arg4[2];
1400151b9              rcx_1 = rcx - arg3;
1400151b9              
1400151be              if (rcx_1 > rax_1)
1400151be                  goto label_1400151c4;
1400151be              
140015500              bool cond:5_1 = !(*(uint8_t*)((char*)arg4 + 9) & 0x10);
140015505              *(uint32_t*)((char*)arg4 + 0xc) = 0xffffffff;
140015505              
140015519              if (cond:5_1 || !arg4[4])
14001550d                  goto label_14001522b;
14001550d              
14001551f              rcx_2 = -1;
14001552b          label_14001552b:
14001552c              rax_15 = (int64_t)(i_4 + 2) / 3;
14001552c              
140015532              if (rax_15 != 1)
140015532                  goto label_1400154be;
140015532              
140015532              goto label_1400151e5;
1400151b3          }
1400151b3          
140015218          bool cond:2_1 = *(uint8_t*)((char*)arg4 + 9) & 0x10;
14001521d          *(uint32_t*)((char*)arg4 + 0xc) = 0xffffffff;
14001521d          
140015496          if (cond:2_1 && arg4[4])
140015496          {
1400154a5              rcx_2 = -1;
1400154ae              rax_15 = (arg3 + 2) / 3;
1400154ae              
1400154b5              if (rax_15 == 1)
1400154b5                  goto label_14001522b;
1400154b5              
1400154be          label_1400154be:
1400154be              int32_t i_1 = rax_15 - 1 - rcx_2;
1400154be              
1400154d2              do
1400154d2              {
1400154da                  if (rcx_2 <= 0)
1400154da                      goto label_14001522b;
1400154da                  
1400154c8                  rcx_2 -= 1;
1400154cf                  *(uint32_t*)((char*)arg4 + 0xc) = rcx_2;
1400154d2              } while (i_1 != -(rcx_2));
1400154d2              
1400154da              goto label_1400151e5;
140015496          }
140015496          
14001522b      label_14001522b:
14001522b          
14001522d          if (!arg1)
14001522d              goto label_140015233;
14001522d          
140015318          __pformat_putc(0x2d, arg4);
1400151aa      }
140015247      int32_t rax_3 = *(uint32_t*)((char*)arg4 + 0xc);
140015247      
14001525d      if (rax_3 > 0 && (arg4[1] & 0x600) == 0x200)
14001525d      {
140015463          *(uint32_t*)((char*)arg4 + 0xc) = rax_3 - 1;
140015488          int32_t i_2;
140015488          
140015488          do
140015488          {
140015478              __pformat_putc(0x30, arg4);
14001547d              i_2 = *(uint32_t*)((char*)arg4 + 0xc);
140015485              *(uint32_t*)((char*)arg4 + 0xc) = i_2 - 1;
140015488          } while (i_2 > 0);
14001525d      }
14001525d      
140015265      int32_t rax_6;
140015265      
140015265      if (i_4 <= 0)
140015265      {
140015378          __pformat_putc(0x30, arg4);
14001537d          rax_6 = arg4[2];
14001537d          
140015556          if (rax_6 <= 0 && !(*(uint8_t*)((char*)arg4 + 9) & 8))
140015556          {
14001555e              if (i_4)
14001555e                  goto label_140015399;
14001555e              
1400152d4              arg4[2] = rax_6 - 1;
1400152df              return rax_6 - 1;
140015556          }
140015556          
14001538b      label_14001538b:
14001538b          __pformat_emit_radix_point(arg4);
14001538b          
140015392          if (i_4)
140015392          {
140015394              rax_6 = arg4[2];
140015399          label_140015399:
140015399              arg4[2] = rax_6 + i_4;
1400153b0              int32_t i_3;
1400153b0              
1400153b0              do
1400153b0              {
1400153a8                  __pformat_putc(0x30, arg4);
1400153ad                  i_3 = i_4;
1400153ad                  i_4 += 1;
1400153b0              } while (i_3 != 0xffffffff);
140015392          }
140015265      }
140015265      else
140015265      {
140015270          while (true)
140015270          {
140015270              char rax_4 = *(uint8_t*)rdi;
140015273              int32_t rcx_3 = 0x30;
140015273              
14001527a              if (rax_4)
14001527a              {
14001527c                  rdi = &rdi[1];
140015280                  rcx_3 = (int32_t)rax_4;
14001527a              }
14001527a              
140015286              __pformat_putc(rcx_3, arg4);
14001528b              int32_t i_5 = i_4;
14001528b              i_4 -= 1;
14001528b              
14001528e              if (i_5 == 1)
14001528e                  break;
14001528e              
140015294              if (*(uint8_t*)((char*)arg4 + 9) & 0x10 && arg4[4]
140015294                      && i_4 * 0xaaaaaaab <= 0x55555555)
1400152b6                  __pformat_wputchars(&arg4[4], 1, arg4);
140015270          }
140015270          
1400152c0          rax_6 = arg4[2];
1400152c0          
1400152c5          if (rax_6 <= 0)
1400152c5          {
1400152cb              if (*(uint8_t*)((char*)arg4 + 9) & 8)
1400152cb                  goto label_14001538b;
1400152cb              
1400152d4              arg4[2] = rax_6 - 1;
1400152df              return rax_6 - 1;
1400152c5          }
1400152c5          
14001532b          __pformat_emit_radix_point(arg4);
140015265      }
140015353      int32_t result;
140015353      
140015353      while (true)
140015353      {
140015353          result = arg4[2];
14001535b          arg4[2] = result - 1;
14001535b          
14001535e          if (result <= 0)
14001535e              break;
14001535e          
140015338          char rax_8 = *(uint8_t*)rdi;
14001533b          int32_t rcx_6 = 0x30;
14001533b          
140015342          if (rax_8)
140015342          {
140015344              rdi = &rdi[1];
140015348              rcx_6 = (int32_t)rax_8;
140015342          }
140015342          
14001534e          __pformat_putc(rcx_6, arg4);
140015353      }
140015353      
140015368      return result;
140015190  }

140015213                                                           0f 1f 44 00 00                                             ..D..
1400152bd                                                                                         0f 1f 00                               ...
140015322        66 0f 1f 44 00 00                                                                            f..D..
140015332                                                        66 0f 1f 44 00 00                                            f..D..
140015369                             0f 1f 80 00 00 00 00                                                           .......
1400153b4                                                              0f 1f 40 00                                              ..@.
1400153ff                                                                                               90                                 .
140015445                 0f 1f 00                                                                               ...
14001545a                                                                                66 0f 1f 44 00 00                            f..D..
14001548f                                               90                                                                 .
1400154c2        66 0f 1f 44 00 00                                                                            f..D..
1400154e1     0f 1f 80 00 00 00 00                                                                           .......
1400154f9                                                                             0f 1f 80 00 00 00 00                           .......
140015539                                                                             0f 1f 80 00 00 00 00                           .......
140015569                             0f 1f 80 00 00 00 00                                                           .......

140015570    int64_t __pformat_emit_efloat(int32_t arg1, char* arg2, int32_t arg3, char** arg4)

140015570  {
140015577      int32_t r10 = 1;
140015587      int64_t rsi = (int64_t)(arg3 - 1);
14001558a      int32_t r8_1 = (arg3 - 1) >> 0x1f;
140015595      int32_t rcx_1 = (int32_t)((rsi * 0x66666667) >> 0x22);
140015599      int32_t rcx_2 = rcx_1 - r8_1;
140015599      
14001559c      if (rcx_1 != r8_1)
14001559c      {
1400155b9          int32_t rax_3;
1400155b9          int32_t rcx_3;
1400155b9          
1400155b9          do
1400155b9          {
1400155a3              rcx_3 = rcx_2 >> 0x1f;
1400155a6              r10 += 1;
1400155b1              rax_3 = (int32_t)(((int64_t)rcx_2 * 0x66666667) >> 0x22);
1400155b7              rcx_2 s/= 0xa;
1400155b9          } while (rax_3 != rcx_3);
14001559c      }
14001559c      
1400155bb      int32_t rax_5 = *(uint32_t*)((char*)arg4 + 0x2c);
1400155bb      
1400155c1      if (rax_5 == 0xffffffff)
1400155c1      {
1400155c3          *(uint32_t*)((char*)arg4 + 0x2c) = 2;
1400155ca          rax_5 = 2;
1400155c1      }
1400155c1      
1400155cf      int32_t r8_2 = *(uint32_t*)((char*)arg4 + 0xc);
1400155d6      int32_t rdi = r10;
1400155d6      
1400155dc      if (rax_5 >= r10)
1400155dc          rdi = rax_5;
1400155dc      
1400155e5      int32_t rax_7 = r8_2 - (rdi + 2);
1400155e5      
1400155ef      if (r8_2 <= rdi + 2)
1400155ef          rax_7 = -1;
1400155ef      
1400155fb      *(uint32_t*)((char*)arg4 + 0xc) = rax_7;
1400155fe      __pformat_emit_float(arg1, arg2, 1, arg4);
140015603      int32_t rcx_6 = arg4[1];
14001560c      arg4[2] = *(uint32_t*)((char*)arg4 + 0x2c);
14001561c      arg4[1] = rcx_6 | 0x1c0;
14001561f      __pformat_putc((rcx_6 & 0x20) | 0x45, arg4);
14001562d      *(uint32_t*)((char*)arg4 + 0xc) += rdi + 1;
140015637      /* tailcall */
140015637      return __pformat_int.isra.0(rsi, arg4);
140015570  }

14001563c                                                                                      0f 1f 40 00                              ..@.

140015640    int64_t __pformat_efloat(int80_t* arg1, char** arg2)

140015640  {
140015646      int32_t r8 = arg2[2];
140015652      int32_t r8_1;
140015652      
140015652      if (r8 < 0)
140015652      {
1400156b0          arg2[2] = 6;
1400156b7          r8_1 = 7;
140015652      }
140015652      else
140015654          r8_1 = r8 + 1;
140015654      
14001566c      int80_t var_38 = *(uint80_t*)arg1;
140015675      int32_t var_20;
140015675      int32_t var_1c;
140015675      void* rax = __pformat_cvt(2, &var_38, r8_1, &var_1c, &var_20);
14001567a      int32_t r8_2 = var_1c;
14001567a      
140015689      if (r8_2 == 0xffff8000)
140015689      {
1400156ca          __pformat_emit_inf_or_nan(var_20, rax, arg2);
1400156de          return __freedtoa(rax);
140015689      }
140015689      
140015695      __pformat_emit_efloat(var_20, rax, r8_2, arg2);
1400156a9      return __freedtoa(rax);
140015640  }

1400156aa                                66 0f 1f 44 00 00                                                            f..D..
1400156bf                                                                                               90                                 .
1400156df                                                                                               90                                 .

1400156e0    int64_t __pformat_float(int80_t* arg1, char** arg2)

1400156e0  {
1400156e6      int32_t r8 = arg2[2];
1400156e6      
1400156f2      if (r8 < 0)
1400156f2      {
1400156f4          arg2[2] = 6;
1400156fb          r8 = 6;
1400156f2      }
1400156f2      
140015715      int80_t var_38 = *(uint80_t*)arg1;
14001571e      int32_t var_20;
14001571e      int32_t var_1c;
14001571e      void* rax = __pformat_cvt(3, &var_38, r8, &var_1c, &var_20);
140015723      int32_t r8_1 = var_1c;
140015723      
140015732      if (r8_1 == 0xffff8000)
1400157aa          __pformat_emit_inf_or_nan(var_20, rax, arg2);
140015732      else
140015732      {
14001573e          __pformat_emit_float(var_20, rax, r8_1, arg2);
140015743          int32_t rax_1 = *(uint32_t*)((char*)arg2 + 0xc);
140015743          
140015764          while (true)
140015764          {
140015764              int32_t rdx_4 = rax_1;
140015766              rax_1 -= 1;
14001576b              *(uint32_t*)((char*)arg2 + 0xc) = rax_1;
14001576b              
14001576e              if (rdx_4 <= 0)
14001576e                  break;
14001576e              
140015770              int16_t rcx_1 = (int16_t)arg2[1];
140015776              int32_t rdx_2;
140015776              
140015776              if (!(*(uint8_t*)((char*)rcx_1)[1] & 0x40))
140015778                  rdx_2 = *(uint32_t*)((char*)arg2 + 0x24);
140015778              
14001577e              if (*(uint8_t*)((char*)rcx_1)[1] & 0x40 || arg2[5] > rdx_2)
14001577e              {
140015780                  *(uint8_t*)((char*)rcx_1)[1] &= 0x20;
140015783                  char* _Stream = *(uint64_t*)arg2;
140015783                  
140015786                  if (!*(uint8_t*)((char*)rcx_1)[1])
140015786                  {
140015754                      _Stream[(int64_t)*(uint32_t*)((char*)arg2 + 0x24)] = 0x20;
140015758                      rdx_2 = *(uint32_t*)((char*)arg2 + 0x24);
14001575b                      rax_1 = *(uint32_t*)((char*)arg2 + 0xc);
140015786                  }
140015786                  else
140015786                  {
14001578d                      fputc(0x20, _Stream);
140015792                      rdx_2 = *(uint32_t*)((char*)arg2 + 0x24);
140015795                      rax_1 = *(uint32_t*)((char*)arg2 + 0xc);
140015786                  }
14001577e              }
14001577e              
140015761              *(uint32_t*)((char*)arg2 + 0x24) = rdx_2 + 1;
140015764          }
140015732      }
140015732      
1400157be      return __freedtoa(rax);
1400156e0  }

140015748                          0f 1f 84 00 00 00 00 00                                                          ........
14001579a                                                                                66 0f 1f 44 00 00                            f..D..
1400157bf                                                                                               90                                 .

1400157c0    int64_t __pformat_gfloat(int80_t* arg1, char** arg2)

1400157c0  {
1400157c7      int32_t r8 = arg2[2];
1400157c7      
1400157d3      if (r8 < 0)
1400157d3      {
1400158d8          arg2[2] = 6;
1400158df          r8 = 6;
1400157d3      }
1400157d3      else if (!r8)
1400157d9      {
1400158c0          arg2[2] = 1;
1400158c7          r8 = 1;
1400157d9      }
1400157d9      
1400157f3      int80_t var_38 = *(uint80_t*)arg1;
1400157fc      int32_t var_20;
1400157fc      int32_t var_1c;
1400157fc      void* _Str = __pformat_cvt(2, &var_38, r8, &var_1c, &var_20);
140015801      int32_t rdi = var_1c;
140015801      
14001580e      if (rdi == 0xffff8000)
14001580e      {
1400158fa          __pformat_emit_inf_or_nan(var_20, _Str, arg2);
14001590f          return __freedtoa(_Str);
14001580e      }
14001580e      
140015817      int32_t rax_1 = arg2[1] & 0x800;
140015817      
14001581f      if (rdi >= 0xfffffffd)
14001581f      {
140015821          int32_t rdx_1 = arg2[2];
140015821          
140015826          if (rdi <= rdx_1)
140015826          {
14001582a              if (!rax_1)
14001582a              {
140015913                  int32_t rax_9 = strlen(_Str);
140015918                  int32_t rax_10 = rax_9 - rdi;
14001591a                  arg2[2] = rax_10;
14001591a                  
14001591d                  if (rax_9 - rdi < 0)
14001591d                  {
140015923                      int32_t rdx_8 = *(uint32_t*)((char*)arg2 + 0xc);
140015923                      
140015928                      if (rdx_8 > 0)
140015930                          *(uint32_t*)((char*)arg2 + 0xc) = rax_10 + rdx_8;
14001591d                  }
14001582a              }
14001582a              else
140015832                  arg2[2] = rdx_1 - rdi;
140015832              
140015842              __pformat_emit_float(var_20, _Str, rdi, arg2);
140015842              
14001585d              while (true)
14001585d              {
14001585d                  int32_t rax_2 = *(uint32_t*)((char*)arg2 + 0xc);
140015865                  *(uint32_t*)((char*)arg2 + 0xc) = rax_2 - 1;
140015865                  
140015868                  if (rax_2 <= 0)
140015868                      break;
140015868                  
140015858                  __pformat_putc(0x20, arg2);
14001585d              }
14001585d              
14001587a              return __freedtoa(_Str);
140015826          }
14001581f      }
14001581f      
140015882      int32_t rax_5;
140015882      
140015882      if (rax_1)
1400158bb          rax_5 = arg2[2] - 1;
140015882      else
14001588c          rax_5 = strlen(_Str) - 1;
14001588c      
140015893      arg2[2] = rax_5;
14001589f      __pformat_emit_efloat(var_20, _Str, rdi, arg2);
1400158b4      return __freedtoa(_Str);
1400157c0  }

140015849                             0f 1f 80 00 00 00 00                                                           .......
14001587b                                                                                   0f 1f 44 00 00                             ..D..
1400158b5                                                                 0f 1f 00                                               ...
1400158d2                                                        66 0f 1f 44 00 00                                            f..D..
1400158ea                                66 0f 1f 44 00 00                                                            f..D..
140015938                                                                          0f 1f 84 00 00 00 00 00                          ........

140015940    int64_t __pformat_emit_xfloat.isra.0(uint64_t arg1, int32_t arg2, char** arg3)

140015940  {
14001594c      int32_t r10 = arg3[2];
140015953      uint64_t r9 = arg1;
14001595e      int32_t rcx_4;
14001595e      int32_t i_4;
14001595e      int64_t rbp;
14001595e      int32_t r8;
14001595e      
14001595e      if ((uint16_t)arg2 || arg1)
14001595e      {
140015964          r8 = arg2 - 3;
140015964          
14001596c          if (r10 <= 0xe)
14001596c              goto label_140015a1f;
14001596c          
140015975          rbp = (int64_t)(uint16_t)r8;
140015979          i_4 = 0x10;
140015979          
140015d83          if (r9 || r10 > 0)
14001597e              goto label_140015984;
14001597e          
140015d89          rcx_4 = arg3[1];
140015d91          goto label_140015a69;
14001595e      }
14001595e      
140015a0c      if (r10 <= 0xe)
140015a0c      {
140015a12          r8 = 0;
140015a1f      label_140015a1f:
140015a1f          uint64_t r9_1 = r9 >> 1;
140015a28          int64_t rax_5 = 4 << (char)((0xe - r10) << 2);
140015a33          char rcx_3 = (char)((0xf - r10) << 2);
140015a36          int64_t rax_6 = rax_5 + r9_1;
140015a36          
140015a39          if (rax_5 + r9_1 < 0)
140015a39          {
140015b54              r8 += 4;
140015b5b              r9 = rax_6 >> 3 >> rcx_3;
140015a39          }
140015a39          else
140015a39          {
140015a42              uint64_t rax_8 = (rax_6 * 2) >> rcx_3;
140015a48              r9 = rax_8;
140015a48              
140015a54              if (!rax_8 && !r10)
140015a54              {
140015a5a                  rcx_4 = arg3[1];
140015a62                  rbp = (int64_t)(uint16_t)r8;
140015a62                  goto label_140015a69;
140015a54              }
140015a39          }
140015a39          
140015b5e          i_4 = r10 + 1;
140015b62          rbp = (int64_t)(uint16_t)r8;
140015b66          goto label_140015984;
140015a0c      }
140015a0c      
140015d6b      char var_58;
140015d6b      char* i_3;
140015d6b      int32_t r10_4;
140015d6b      int32_t r12_3;
140015d6b      
140015d6b      if (r10 > 0)
140015d6b      {
140015d6d          rbp = 0;
140015d6f          r8 = 0;
140015d72          i_4 = 0x10;
140015d77          r9 = 0;
140015984      label_140015984:
140015984          rcx_4 = arg3[1];
14001598c          i_3 = &var_58;
1400159c9          int32_t i;
1400159c9          
1400159c9          do
1400159c9          {
1400159d2              int32_t rax_3 = (uint32_t)r9 & 0xf;
1400159d8              char* i_5;
1400159d8              
1400159d8              if (i_4 != 1)
1400159d8              {
1400159de                  int32_t r10_1 = arg3[2];
1400159de                  
1400159e5                  if (r10_1 > 0)
1400159eb                      arg3[2] = r10_1 - 1;
1400159eb                  
1400159ef                  i_5 = i_3;
1400159ef                  goto label_1400159f2;
1400159d8              }
1400159d8              
140015b78              int32_t r10_3;
140015b78              
140015b78              if (&var_58 >= i_3 && !(rcx_4 & 0x800))
140015b7a                  r10_3 = arg3[2];
140015b7a              
140015b81              if (&var_58 >= i_3 && !(rcx_4 & 0x800) && r10_3 <= 0)
140015b81              {
140015b9a                  if (rax_3)
140015b9a                  {
140015dd0                      i_5 = i_3;
140015b9a                      goto label_1400159f6;
140015b9a                  }
140015b9a                  
140015ba3                  if (!r10_3)
140015ba3                  {
140015ba5                      *(uint8_t*)i_3 = 0x30;
140015ba8                      i_3 = &i_3[1];
140015ba3                  }
140015ba3                  
140015ba3                  break;
140015b81              }
140015b81              
140015b88              i_5 = &i_3[1];
140015b8c              *(uint8_t*)i_3 = 0x2e;
1400159f2          label_1400159f2:
1400159f2              
1400159f4              if (rax_3)
1400159f4              {
1400159f6              label_1400159f6:
1400159f6                  
1400159f9                  if (rax_3 <= 9)
1400159f9                      goto label_1400159b8;
1400159f9                  
1400159bb                  i_3 = &i_5[1];
1400159bf                  *(uint8_t*)i_5 = ((uint8_t)rax_3 + 0x37) | ((uint8_t)rcx_4 & 0x20);
1400159f4              }
1400159f4              else if (&var_58 < i_5 || arg3[2] >= 0)
1400159b2              {
1400159b8              label_1400159b8:
1400159bb                  i_3 = &i_5[1];
1400159bf                  *(uint8_t*)i_5 = (uint8_t)rax_3 + 0x30;
1400159b2              }
1400159b2              else
140015d38                  i_3 = i_5;
140015d38              
1400159c2              r9 u>>= 4;
1400159c6              i = i_4;
1400159c6              i_4 -= 1;
1400159c9          } while (i != 1);
1400159c9          
140015bb3          if (i_3 == &var_58)
140015bb3          {
140015dbd              if (arg3[2] > 0)
140015dbd                  goto label_140015a6e;
140015dbd              
140015dbd              goto label_140015a69;
140015bb3          }
140015bb3          
140015bb9          r10_4 = *(uint32_t*)((char*)arg3 + 0xc);
140015bbd          r12_3 = 2;
140015bbd          
140015bc6          if (r10_4 <= 0)
140015bc6              goto label_140015a92;
140015bc6          
140015bc6          goto label_140015bcc;
140015d6b      }
140015d6b      
140015dd8      rcx_4 = arg3[1];
140015de1      rbp = 0;
140015de3      r8 = 0;
140015a69  label_140015a69:
140015a69      char* rax_9 = &var_58;
140015a69      
140015a6c      if (!(*(uint8_t*)((char*)rcx_4)[1] & 8))
140015a6c          goto label_140015a78;
140015a6c      
140015a6e  label_140015a6e:
140015a6e      var_58 = 0x2e;
140015a73      void var_57;
140015a73      rax_9 = &var_57;
140015a78  label_140015a78:
140015a78      r10_4 = *(uint32_t*)((char*)arg3 + 0xc);
140015a7c      i_3 = &rax_9[1];
140015a80      *(uint8_t*)rax_9 = 0x30;
140015a83      r12_3 = 2;
140015a83      
140015a8c      if (r10_4 <= 0)
140015a8c          goto label_140015a92;
140015a8c      
140015bcc  label_140015bcc:
140015bcc      int32_t rdx_5 = arg3[2];
140015bd6      int32_t r9_3 = (uint32_t)i_3 - &var_58;
140015bd6      
140015be1      if (rdx_5 > 0)
140015be1          r9_3 += rdx_5;
140015be1      
140015bf2      int32_t r9_4 = r9_3 + 6;
140015bf6      int32_t rax_16 = (int32_t)(uint16_t)r8 >> 0x1f;
140015c00      int32_t r11_4 = r9_4;
140015c03      int32_t rdx_10 = (int32_t)(((int64_t)(uint16_t)r8 * 0x66666667) >> 0x22);
140015c07      int32_t rdx_11 = rdx_10 - rax_16;
140015c07      
140015c09      if (rdx_10 != rax_16)
140015c09      {
140015c29          int32_t rax_19;
140015c29          int32_t rdx_12;
140015c29          
140015c29          do
140015c29          {
140015c13              rdx_12 = rdx_11 >> 0x1f;
140015c16              r11_4 += 1;
140015c21              rax_19 = (int32_t)(((int64_t)rdx_11 * 0x66666667) >> 0x22);
140015c27              rdx_11 s/= 0xa;
140015c29          } while (rax_19 != rdx_12);
140015c35          r12_3 = (int32_t)((uint16_t)r11_4 - (uint16_t)r9_4 + 2);
140015c09      }
140015c09      
140015c3c      int32_t r10_5;
140015c3c      
140015c3c      if (r10_4 <= r11_4)
140015c3c      {
140015d40          r10_5 = -1;
140015d46      label_140015d46:
140015d46          *(uint32_t*)((char*)arg3 + 0xc) = r10_5;
140015a92      label_140015a92:
140015a92          
140015a95          if ((uint8_t)rcx_4 & 0x80)
140015c98              __pformat_putc(0x2d, arg3);
140015a95          else
140015a95          {
140015a9b          label_140015a9b:
140015a9b              
140015a9e              if (*(uint8_t*)((char*)rcx_4)[1] & 1)
140015d58                  __pformat_putc(0x2b, arg3);
140015a9e              else if (rcx_4 & 0x40)
140015da8                  __pformat_putc(0x20, arg3);
140015a95          }
140015c3c      }
140015c3c      else
140015c3c      {
140015c42          r10_5 = r10_4 - r11_4;
140015c42          
140015c48          if (*(uint8_t*)((char*)rcx_4)[1] & 6)
140015c48              goto label_140015d46;
140015c48          
140015c52          *(uint32_t*)((char*)arg3 + 0xc) = r10_5 - 1;
140015c78          int32_t i_1;
140015c78          
140015c78          do
140015c78          {
140015c68              __pformat_putc(0x20, arg3);
140015c6d              i_1 = *(uint32_t*)((char*)arg3 + 0xc);
140015c75              *(uint32_t*)((char*)arg3 + 0xc) = i_1 - 1;
140015c78          } while (i_1 > 0);
140015c7a          rcx_4 = arg3[1];
140015c7a          
140015c80          if (!((uint8_t)rcx_4 & 0x80))
140015c80              goto label_140015a9b;
140015c80          
140015c98          __pformat_putc(0x2d, arg3);
140015c3c      }
140015ab5      __pformat_putc(0x30, arg3);
140015ac6      __pformat_putc((arg3[1] & 0x20) | 0x58, arg3);
140015acb      int32_t rax_10 = *(uint32_t*)((char*)arg3 + 0xc);
140015acb      
140015ad6      if (rax_10 > 0 && *(uint8_t*)((char*)arg3 + 9) & 2)
140015ad6      {
140015adb          *(uint32_t*)((char*)arg3 + 0xc) = rax_10 - 1;
140015af8          int32_t i_2;
140015af8          
140015af8          do
140015af8          {
140015ae8              __pformat_putc(0x30, arg3);
140015aed              i_2 = *(uint32_t*)((char*)arg3 + 0xc);
140015af5              *(uint32_t*)((char*)arg3 + 0xc) = i_2 - 1;
140015af8          } while (i_2 > 0);
140015ad6      }
140015ad6      
140015b02      if (&var_58 < i_3)
140015b02      {
140015b25          do
140015b25          {
140015b2b              int32_t rcx_9 = (int32_t)i_3[-1];
140015b2f              i_3 -= 1;
140015b2f              
140015b36              if (rcx_9 == 0x2e)
140015d13                  __pformat_emit_radix_point(arg3);
140015b36              else if (rcx_9 == 0x2c)
140015b3f              {
140015b10                  int16_t rax_12 = arg3[4];
140015b17                  int16_t var_5a = rax_12;
140015b17                  
140015b1c                  if (rax_12)
140015d2b                      __pformat_wputchars(&var_5a, 1, arg3);
140015b3f              }
140015b3f              else
140015b44                  __pformat_putc(rcx_9, arg3);
140015b25          } while (i_3 != &var_58);
140015b02      }
140015b02      
140015cb5      while (true)
140015cb5      {
140015cb5          int32_t rax_21 = arg3[2];
140015cbd          arg3[2] = rax_21 - 1;
140015cbd          
140015cc0          if (rax_21 <= 0)
140015cc0              break;
140015cc0          
140015cb0          __pformat_putc(0x30, arg3);
140015cb5      }
140015cb5      
140015cce      __pformat_putc((arg3[1] & 0x20) | 0x50, arg3);
140015cf2      arg3[1] = _mm_unpacklo_epi32((uint128_t)arg3[1] | 0x1c0, 
140015cf2          (uint64_t)(r12_3 + *(uint32_t*)((char*)arg3 + 0xc)));
140015d03      /* tailcall */
140015d03      return __pformat_int.isra.0(rbp, arg3);
140015940  }

1400159a2        66 0f 1f 44 00 00                                                                            f..D..
140015a03           0f 1f 44 00 00                                                                             ..D..
140015b09                             0f 1f 80 00 00 00 00                                                           .......
140015b4b                                   0f 1f 44 00 00                                                             ..D..
140015b6b                                   0f 1f 44 00 00                                                             ..D..
140015b94                                                              0f 1f 40 00                                              ..@.
140015ca2        66 0f 1f 44 00 00                                                                            f..D..
140015d08                          0f 1f 84 00 00 00 00 00                                                          ........
140015d1d                                                                                         0f 1f 00                               ...
140015d35                                                                 0f 1f 00                                               ...
140015d4f                                               90                                                                 .
140015d62        66 0f 1f 44 00 00                                                                            f..D..
140015d7f                                                                                               90                                 .
140015d96                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
140015db2                                                        66 0f 1f 44 00 00                                            f..D..
140015dc8                          0f 1f 84 00 00 00 00 00                                                          ........
140015deb                                   0f 1f 44 00 00                                                             ..D..

140015df0    uint64_t __mingw_pformat(int32_t arg1, char* arg2, int32_t arg3, char* arg4, int64_t* arg5)

140015df0  {
140015e03      int64_t* r13 = arg5;
140015e16      int32_t rdi_1 = arg1 & 0x6000;
140015e1c      int32_t* rax = _errno();
140015e21      int32_t _Character = (int32_t)*(uint8_t*)arg4;
140015e26      char* _Stream_1 = arg2;
140015e2b      int32_t rax_1 = *(uint32_t*)rax;
140015e34      void* rbx_1 = &arg4[1];
140015e38      int32_t var_70 = rdi_1;
140015e3c      int32_t var_6c = 0xffffffff;
140015e44      int32_t var_5c = 0;
140015e5d      int64_t var_68 = -0x200000001;
140015e69      int16_t var_60 = 0;
140015e71      char _Character_2 = (uint8_t)_Character;
140015e73      int16_t var_58 = 0;
140015e7b      int32_t _Character_1 = 0;
140015e86      int32_t var_4c = 0xffffffff;
140015e86      
140015e91      if (_Character)
140015e91      {
140015ee8          do
140015ee8          {
140015ef1              if (_Character != 0x25)
140015ef1              {
140015ea8                  int16_t rdx = (uint16_t)var_70;
140015ea8                  
140015ebf                  if (*(uint8_t*)((char*)rdx)[1] & 0x40 || arg3 > _Character_1)
140015ebf                  {
140015ec1                      *(uint8_t*)((char*)rdx)[1] &= 0x20;
140015ec4                      char* _Stream = _Stream_1;
140015ec4                      
140015ec9                      if (*(uint8_t*)((char*)rdx)[1])
140015f3b                          fputc(_Character, _Stream);
140015ec9                      else
140015ece                          _Stream[(int64_t)_Character_1] = _Character_2;
140015ebf                  }
140015ebf                  
140015ed5                  _Character_1 += 1;
140015ef1              }
140015ef1              else
140015ef1              {
140015ef3                  char rax_2 = *(uint8_t*)rbx_1;
140015ef6                  var_70 = rdi_1;
140015efa                  var_6c = -1;
140015efa                  
140015f05                  if (!rax_2)
140015f05                      break;
140015f05                  
140015f0b                  void* rsi_3 = rbx_1;
140015f0e                  int32_t* r11_1 = &var_6c;
140015f11                  int32_t r10_1 = 0;
140015f14                  int32_t r14_1 = 0;
140015f14                  
140015f1a                  while (true)
140015f1a                  {
140015f1a                      int32_t rcx = (int32_t)rax_2;
140015f24                      long double var_a8;
140015f24                      int16_t _State;
140015f24                      int32_t rax_13;
140015f24                      uint64_t* rcx_4;
140015f24                      int80_t* rdx_16;
140015f24                      long double* rdx_18;
140015f24                      long double* rdx_20;
140015f24                      void* rbx_5;
140015f24                      int64_t* rbx_6;
140015f24                      
140015f24                      if (rax_2 - 0x20 > 0x5a)
140015f24                      {
140015f4b                      label_140015f4b:
140015f4b                          
140015f57                          if (rax_2 - 0x30 > 9 || r14_1 > 3)
140015f57                          {
140016171                          label_140016171:
140016171                              __pformat_putc(0x25, &_Stream_1);
140016176                              break;
140016176                              break;
140015f57                          }
140015f57                          
140015f60                          if (r14_1)
140015f60                              goto label_1400166b9;
140015f60                          
140015f66                          r14_1 = 1;
140015f6c                      label_140015f6c:
140015f6c                          
140015f6f                          if (!r11_1)
140015f6f                          {
140015f90                              rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140015f94                              rsi_3 += 1;
140015f6f                          }
140015f6f                          else
140015f6f                          {
140015f71                              uint64_t rax_4 = (uint64_t)*(uint32_t*)r11_1;
140015f71                              
140015f76                              if ((uint32_t)rax_4 < 0)
140015f76                              {
140016775                                  rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140016779                                  rsi_3 += 1;
14001677c                                  *(uint32_t*)r11_1 = rcx - 0x30;
140015f76                              }
140015f76                              else
140015f76                              {
140015f83                                  *(uint32_t*)r11_1 =
140015f83                                      rcx + ((int32_t)(rax_4 * 5) << 1) - 0x30;
140015f90                                  rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140015f94                                  rsi_3 += 1;
140015f76                              }
140015f6f                          }
140015f24                      }
140015f24                      else
140015f24                          switch (rax_2)
140015f24                          {
140016333                              case 0x20:
140016333                              {
140016333                                  if (r14_1)
140016333                                  {
140015f90                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140015f94                                      rsi_3 += 1;
140016333                                  }
140016333                                  else
140016333                                  {
140016339                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
14001633d                                      rsi_3 += 1;
140016340                                      var_70 |= 0x40;
140016333                                  }
140016333                                  break;
140016333                              }
140015f30                              case 0x21:
140015f30                              case 0x22:
140015f30                              case 0x24:
140015f30                              case 0x26:
140015f30                              case 0x28:
140015f30                              case 0x29:
140015f30                              case 0x2c:
140015f30                              case 0x2f:
140015f30                              case 0x31:
140015f30                              case 0x32:
140015f30                              case 0x33:
140015f30                              case 0x34:
140015f30                              case 0x35:
140015f30                              case 0x36:
140015f30                              case 0x37:
140015f30                              case 0x38:
140015f30                              case 0x39:
140015f30                              case 0x3a:
140015f30                              case 0x3b:
140015f30                              case 0x3c:
140015f30                              case 0x3d:
140015f30                              case 0x3e:
140015f30                              case 0x3f:
140015f30                              case 0x40:
140015f30                              case 0x42:
140015f30                              case 0x44:
140015f30                              case 0x48:
140015f30                              case 0x4a:
140015f30                              case 0x4b:
140015f30                              case 0x4d:
140015f30                              case 0x4e:
140015f30                              case 0x4f:
140015f30                              case 0x50:
140015f30                              case 0x51:
140015f30                              case 0x52:
140015f30                              case 0x54:
140015f30                              case 0x55:
140015f30                              case 0x56:
140015f30                              case 0x57:
140015f30                              case 0x59:
140015f30                              case 0x5a:
140015f30                              case 0x5b:
140015f30                              case 0x5c:
140015f30                              case 0x5d:
140015f30                              case 0x5e:
140015f30                              case 0x5f:
140015f30                              case 0x60:
140015f30                              case 0x62:
140015f30                              case 0x6b:
140015f30                              case 0x71:
140015f30                              case 0x72:
140015f30                              case 0x76:
140015f30                              case 0x77:
140015f30                              case 0x79:
140015f30                              {
140015f30                                  goto label_140015f4b;
140015f30                              }
140016605                              case 0x23:
140016605                              {
140016605                                  if (r14_1)
140016605                                  {
140015f90                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140015f94                                      rsi_3 += 1;
140016605                                  }
140016605                                  else
140016605                                  {
14001660b                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
14001660f                                      rsi_3 += 1;
140016612                                      var_70 |= 0x800;
140016605                                  }
140016605                                  break;
140016605                              }
140016524                              case 0x25:
140016524                              {
140016524                                  rbx_1 = (char*)rsi_3 + 1;
140016527                                  __pformat_putc(0x25, &_Stream_1);
14001652c                                  break;
14001652c                                  break;
140016524                                  break;
140016524                              }
140016534                              case 0x27:
140016534                              {
140016534                                  if (r14_1)
140016534                                  {
140015f90                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140015f94                                      rsi_3 += 1;
140016534                                  }
140016534                                  else
140016534                                  {
140016544                                      var_70 |= 0x1000;
140016556                                      _State = 0;
140016577                                      wchar16 _DstCh;
140016577                                      int32_t rax_29 = mbrtowc(&_DstCh, 
140016577                                          localeconv()->thousands_sep, 0x10, &_State);
140016577                                      
140016588                                      if (rax_29 > 0)
14001658f                                          wchar16 _DstCh_1 = _DstCh;
14001658f                                      
140016597                                      int32_t var_5c_1 = rax_29;
14001659e                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
1400165a2                                      rsi_3 += 1;
140016534                                  }
140016534                                  break;
140016534                              }
1400165ad                              case 0x2a:
1400165ad                              {
1400165ad                                  if (!r11_1)
1400165ad                                      goto label_140016371;
1400165ad                                  
1400165ba                                  if (r14_1 & 0xfffffffd)
1400165ba                                  {
1400166e3                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
1400166e7                                      r11_1 = nullptr;
1400166ea                                      rsi_3 += 1;
1400166ed                                      r14_1 = 4;
1400165ba                                  }
1400165ba                                  else
1400165ba                                  {
1400165c0                                      int32_t rax_30 = *(uint32_t*)r13;
1400165ca                                      *(uint32_t*)r11_1 = rax_30;
1400165ca                                      
1400165cd                                      if (rax_30 >= 0)
1400165cd                                          goto label_1400165d3;
1400165cd                                      
140016859                                      if (r14_1)
140016859                                      {
140016898                                          rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
14001689c                                          r13 = &r13[1];
14001689f                                          rsi_3 += 1;
1400168a2                                          r11_1 = nullptr;
1400168a5                                          (uint32_t)var_68 = 0xffffffff;
1400168b0                                          r14_1 = 2;
140016859                                      }
140016859                                      else
140016859                                      {
14001685f                                          int32_t rax_37;
14001685f                                          *(uint8_t*)((char*)rax_37)[1] =
14001685f                                              *(uint8_t*)((char*)var_70)[1] | 4;
140016874                                          var_70 = _mm_unpacklo_epi32((uint128_t)rax_37, 
140016874                                              (uint64_t)-(var_6c));
1400165d3                                      label_1400165d3:
1400165d3                                          rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
1400165d7                                          r13 = &r13[1];
1400165da                                          rsi_3 += 1;
1400165dd                                          r11_1 = nullptr;
140016859                                      }
1400165ba                                  }
1400165ad                                  break;
1400165ad                              }
1400165e8                              case 0x2b:
1400165e8                              {
1400165e8                                  if (r14_1)
1400165e8                                  {
140015f90                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140015f94                                      rsi_3 += 1;
1400165e8                                  }
1400165e8                                  else
1400165e8                                  {
1400165ee                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
1400165f2                                      rsi_3 += 1;
1400165f5                                      var_70 |= 0x100;
1400165e8                                  }
1400165e8                                  break;
1400165e8                              }
14001634d                              case 0x2d:
14001634d                              {
14001634d                                  if (r14_1)
14001634d                                  {
140015f90                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140015f94                                      rsi_3 += 1;
14001634d                                  }
14001634d                                  else
14001634d                                  {
140016353                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140016357                                      rsi_3 += 1;
14001635a                                      var_70 |= 0x400;
14001634d                                  }
14001634d                                  break;
14001634d                              }
14001636b                              case 0x2e:
14001636b                              {
14001636b                                  if (r14_1 <= 1)
14001636b                                  {
140016784                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140016788                                      r14_1 = 2;
14001678e                                      rsi_3 += 1;
140016791                                      (uint32_t)var_68 = 0;
14001679c                                      r11_1 = &var_68;
14001636b                                  }
14001636b                                  else
14001636b                                  {
140016371                                  label_140016371:
140016371                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140016375                                      r14_1 = 4;
14001637b                                      rsi_3 += 1;
14001636b                                  }
14001636b                                  break;
14001636b                              }
140016386                              case 0x30:
140016386                              {
140016386                                  if (r14_1)
140016386                                  {
1400166ae                                      if (r14_1 == 4)
1400166ae                                          goto label_140016171;
1400166ae                                      
1400166b4                                      rcx = 0x30;
1400166b9                                  label_1400166b9:
1400166b9                                      
1400166c2                                      if (r14_1 != 2)
1400166c2                                          goto label_140015f6c;
1400166c2                                      
1400166c2                                      r14_1 = 3;
1400166c2                                      goto label_140015f6c;
140016386                                  }
140016386                                  
14001638c                                  rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140016390                                  rsi_3 += 1;
140016393                                  var_70 |= 0x200;
140016386                                  break;
140016386                              }
1400163a0                              case 0x41:
1400163a0                              {
1400163a0                                  rax_13 = var_70;
1400163a4                                  rcx_4 = *(uint64_t*)r13;
1400163a4                                  
1400163aa                                  if ((uint8_t)rax_13 & 4)
1400163aa                                      goto label_1400161ae;
1400163aa                                  
1400163aa                                  goto label_1400163b5;
1400163a0                              }
140016450                              case 0x43:
140016450                              {
140016450                                  (uint32_t)var_68 = 0xffffffff;
14001645b                                  rbx_5 = &r13[1];
14001645f                              label_14001645f:
14001645f                                  int16_t _State_1 = (int16_t)*(uint32_t*)r13;
14001646d                                  r13 = rbx_5;
140016475                                  rbx_1 = (char*)rsi_3 + 1;
140016478                                  _State = _State_1;
14001647d                                  __pformat_wputchars(&_State, 1, &_Stream_1);
140016482                                  break;
140016482                                  break;
140016450                                  break;
140016450                              }
14001648b                              case 0x45:
14001648b                              {
14001648b                                  rdx_20 = *(uint64_t*)r13;
14001648b                                  
140016491                                  if ((uint8_t)var_70 & 4)
140016491                                      goto label_140016320;
140016491                                  
140016491                                  goto label_1400164a5;
14001648b                              }
1400164bc                              case 0x46:
1400164bc                              {
1400164bc                                  rdx_18 = *(uint64_t*)r13;
1400164bc                                  
1400164c2                                  if ((uint8_t)var_70 & 4)
1400164c2                                      goto label_1400162f2;
1400164c2                                  
1400164c2                                  goto label_1400164d6;
1400164bc                              }
1400164ed                              case 0x47:
1400164ed                              {
1400164ed                                  rdx_16 = *(uint64_t*)r13;
1400164ed                                  
1400164f3                                  if ((uint8_t)var_70 & 4)
1400164f3                                      goto label_1400162b5;
1400164f3                                  
1400164f3                                  goto label_140016507;
1400164ed                              }
140016149                              case 0x49:
140016149                              {
140016149                                  rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140016149                                  
14001614f                                  if (rax_2 == 0x36)
14001614f                                  {
1400167db                                      if (*(uint8_t*)((char*)rsi_3 + 2) != 0x34)
1400167db                                          goto label_140016171;
1400167db                                      
1400167e1                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 3);
1400167e5                                      r10_1 = 3;
1400167eb                                      rsi_3 += 3;
1400167ef                                      r14_1 = 4;
14001614f                                  }
14001614f                                  else if (rax_2 != 0x33)
140016157                                  {
140016708                                      rsi_3 += 1;
14001670b                                      r10_1 = 3;
140016711                                      r14_1 = 4;
140016157                                  }
140016157                                  else
140016157                                  {
140016161                                      if (*(uint8_t*)((char*)rsi_3 + 2) != 0x32)
140016161                                          goto label_140016171;
140016161                                      
14001687f                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 3);
140016883                                      r10_1 = 2;
140016889                                      rsi_3 += 3;
14001688d                                      r14_1 = 4;
140016157                                  }
140016149                                  break;
140016149                              }
140016180                              case 0x4c:
140016180                              {
140016180                                  rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140016184                                  r14_1 = 4;
14001618a                                  rsi_3 += 1;
14001618d                                  var_70 |= 4;
140016180                                  break;
140016180                              }
140016666                              case 0x53:
140016666                              {
140016666                                  rbx_6 = &r13[1];
14001666a                              label_14001666a:
14001666a                                  wchar16* _String = *(uint64_t*)r13;
14001666a                                  
140016678                                  if (!_String)
140016678                                      _String = u"(null)";
140016678                                  
14001667c                                  int32_t rax_33 = (uint32_t)var_68;
14001667c                                  
140016685                                  if (rax_33 < 0)
1400167cd                                      __pformat_wputchars(_String, wcslen(_String), 
1400167cd                                          &_Stream_1);
140016685                                  else
1400166a0                                      __pformat_wputchars(_String, 
1400166a0                                          wcsnlen(_String, (int64_t)rax_33), &_Stream_1);
1400166a0                                  
140016685                                  goto label_14001628c;
140016666                              }
140015fc0                              case 0x58:
140015fc0                              case 0x6f:
140015fc0                              case 0x75:
140015fc0                              case 0x78:
140015fc0                              {
140015fc0                                  var_70 &= 0xfffffeff;
140015fcc                                  uint64_t rax_9;
140015fcc                                  
140015fcc                                  if (r10_1 == 3)
1400167b2                                      rax_9 = *(uint64_t*)r13;
140015fcc                                  else if (r10_1 == 2)
140016845                                      rax_9 = (uint64_t)*(uint32_t*)r13;
140015fd6                                  else
140015fd6                                  {
140015fe0                                      int32_t rax_8 = *(uint32_t*)r13;
140015fe0                                      
140015fe4                                      if (r10_1 == 1)
140016762                                          rax_9 = (uint64_t)(uint16_t)rax_8;
140015fe4                                      else
140015fe4                                      {
140015ff0                                          rax_9 = (uint64_t)(uint8_t)rax_8;
140015ff0                                          
140015ff3                                          if (r10_1 != 5)
140015ff3                                              rax_9 = (uint64_t)rax_8;
140015fe4                                      }
140015fd6                                  }
140015fd6                                  
140015ffa                                  _State = rax_9;
140015ffa                                  
140015fff                                  if (rcx == 0x75)
14001683b                                      __pformat_int.isra.0(rax_9, &_Stream_1);
140015fff                                  else
14001600d                                      __pformat_xint.isra.0(rcx, rax_9, &_Stream_1);
14001600d                                  
140015fff                                  goto label_1400162c8;
140015fc0                              }
14001619b                              case 0x61:
14001619b                              {
14001619b                                  rcx_4 = *(uint64_t*)r13;
14001619f                                  rax_13 = var_70 | 0x20;
1400161a4                                  var_70 = rax_13;
1400161a8                                  int32_t rdx_14;
1400161a8                                  
1400161a8                                  if ((uint8_t)rax_13 & 4)
1400161a8                                  {
1400161ae                                  label_1400161ae:
1400161ae                                      int32_t rbx_4 = rcx_4[1];
1400161b1                                      uint64_t rcx_5 = *(uint64_t*)rcx_4;
1400161b4                                      int32_t r10_2 = (int32_t)(uint16_t)rbx_4;
1400161d1                                      int32_t r9_3 = ((int32_t)(rcx_5 >> 0x20)
1400161d1                                          & 0x7fffffff) | (uint32_t)rcx_5;
1400161d1                                      
1400161f4                                      if ((0xfffe - ((-(r9_3) | r9_3) >> 0x1f
1400161f4                                          | (uint32_t)((uint16_t)r10_2 * 2))) >> 0x10)
1400161f4                                      {
1400166d9                                          __pformat_emit_inf_or_nan(0, "NaN", &_Stream_1);
1400166de                                          goto label_1400162c8;
1400161f4                                      }
1400161f4                                      
1400161fd                                      if ((uint16_t)rbx_4 < 0)
1400161fd                                      {
14001671c                                          (uint8_t)rax_13 |= 0x80;
14001671e                                          var_70 = rax_13;
1400161fd                                      }
1400161fd                                      
140016203                                      (uint16_t)rdx_14 = (uint16_t)rbx_4 & 0x7fff;
140016203                                      
140016208                                      if (!(uint16_t)rdx_14)
140016208                                      {
140016700                                          if (rcx_5)
140016700                                              rdx_14 = -0x3ffe;
140016700                                          
14001665c                                          __pformat_emit_xfloat.isra.0(rcx_5, rdx_14, 
14001665c                                              &_Stream_1);
140016661                                          goto label_1400162c8;
140016208                                      }
140016208                                      
140016218                                      if ((uint16_t)rdx_14 != 0x7fff || r9_3)
140016218                                      {
14001621e                                          (uint16_t)rdx_14 -= 0x3fff;
14001665c                                          __pformat_emit_xfloat.isra.0(rcx_5, rdx_14, 
14001665c                                              &_Stream_1);
140016661                                          goto label_1400162c8;
140016218                                      }
140016218                                      
1400168d0                                      __pformat_emit_inf_or_nan(r10_2 & 0x8000, "Inf", 
1400168d0                                          &_Stream_1);
1400168d5                                      goto label_1400162c8;
1400161a8                                  }
1400161a8                                  
1400163b5                              label_1400163b5:
1400163b5                                  uint32_t r8_9 = (int32_t)(rcx_4 >> 0x20);
1400163b5                                  
1400163d6                                  if (0x7ff00000 - (
1400163d6                                      (-((uint32_t)rcx_4) | (uint32_t)rcx_4) >> 0x1f
1400163d6                                      | (r8_9 & 0x7fffffff)) < 0)
1400163d6                                  {
1400166d9                                      __pformat_emit_inf_or_nan(0, "NaN", &_Stream_1);
1400166de                                      goto label_1400162c8;
1400163d6                                  }
1400163d6                                  
1400163e5                                  uint64_t* var_c8_1;
1400163e5                                  var_c8_1 = (long double)rcx_4;
1400163f1                                  int32_t var_c0;
1400163f1                                  
1400163f1                                  if ((uint16_t)var_c0 < 0)
1400163f1                                  {
1400163f3                                      (uint8_t)rax_13 |= 0x80;
1400163f5                                      var_70 = rax_13;
1400163f1                                  }
1400163f1                                  
1400163fc                                  int32_t r8_10 = r8_9 & 0x7ff00000;
140016408                                  int32_t rax_23 = (r8_9 & 0xfffff) | (uint32_t)rcx_4;
14001640a                                  (uint8_t)rcx_4 = rax_23;
140016418                                  (uint8_t)rcx_4 |= r8_10 != 0x7ff00000;
140016418                                  
140016424                                  if (!(uint8_t)rcx_4 && rax_23 | r8_10)
140016424                                  {
14001643e                                      __pformat_emit_inf_or_nan(var_c0 & 0x8000, "Inf", 
14001643e                                          &_Stream_1);
140016443                                      goto label_1400162c8;
140016424                                  }
140016424                                  
14001661f                                  (uint16_t)rdx_14 = (uint16_t)var_c0 & 0x7fff;
140016624                                  uint64_t* rax_31 = var_c8_1;
140016624                                  
140016629                                  if (!(uint16_t)rdx_14)
140016629                                  {
140016749                                  label_140016749:
140016749                                      
140016751                                      if (rax_31)
140016751                                          rdx_14 = -0x3fb;
140016629                                  }
140016629                                  else if ((uint16_t)rdx_14 > 0x3c00)
140016634                                  {
140016743                                      if (!(uint16_t)rdx_14)
140016743                                          goto label_140016749;
140016743                                      
14001664b                                      (uint16_t)rdx_14 -= 0x3ffc;
140016634                                  }
140016634                                  else
140016634                                  {
140016646                                      rax_31 u>>= (0x3c01 - (int32_t)(uint16_t)rdx_14);
14001664b                                      (uint16_t)rdx_14 = (rdx_14 + 0x3c01
14001664b                                          - (int32_t)(uint16_t)rdx_14) - 0x3ffc;
140016634                                  }
140016634                                  
14001665c                                  __pformat_emit_xfloat.isra.0(rax_31 >> 3, rdx_14, 
14001665c                                      &_Stream_1);
140016661                                  goto label_1400162c8;
14001619b                              }
14001622c                              case 0x63:
14001622c                              {
14001622c                                  rbx_5 = &r13[1];
140016234                                  (uint32_t)var_68 = 0xffffffff;
140016234                                  
140016243                                  if (r10_1 - 2 <= 1)
140016243                                      goto label_14001645f;
140016243                                  
140016253                                  (uint8_t)_State = (char)*(uint32_t*)r13;
140016257                                  r13 = rbx_5;
14001625f                                  rbx_1 = (char*)rsi_3 + 1;
140016262                                  __pformat_putchars(&_State, 1, &_Stream_1);
140016267                                  break;
14001622c                                  break;
14001622c                              }
140016038                              case 0x64:
140016038                              case 0x69:
140016038                              {
140016038                                  var_70 |= 0x80;
140016048                                  int64_t rcx_1;
140016048                                  
140016048                                  if (r10_1 == 3)
1400167a9                                      rcx_1 = *(uint64_t*)r13;
140016048                                  else
140016048                                  {
140016052                                      rcx_1 = (int64_t)*(uint32_t*)r13;
140016052                                      
140016056                                      if (r10_1 != 2)
140016056                                      {
14001605c                                          if (r10_1 == 1)
140016759                                              rcx_1 = (int64_t)(uint16_t)rcx_1;
14001605c                                          else if (r10_1 == 5)
14001606a                                              rcx_1 = (int64_t)(uint8_t)rcx_1;
140016056                                      }
140016048                                  }
140016048                                  
14001606e                                  r13 = &r13[1];
140016071                                  rbx_1 = (char*)rsi_3 + 1;
140016079                                  __pformat_int.isra.0(rcx_1, &_Stream_1);
14001607e                                  break;
14001607e                                  break;
140016038                                  break;
140016038                              }
140016306                              case 0x65:
140016306                              {
140016306                                  rdx_20 = *(uint64_t*)r13;
14001630a                                  int32_t rax_20 = var_70 | 0x20;
14001630f                                  var_70 = rax_20;
14001630f                                  
140016313                                  if (!((uint8_t)rax_20 & 4))
140016313                                  {
1400164a5                                  label_1400164a5:
1400164a5                                      var_a8 = (long double)rdx_20;
1400164ae                                      __pformat_efloat(&var_a8, &_Stream_1);
1400164b3                                      goto label_1400162c8;
140016313                                  }
140016313                                  
140016320                              label_140016320:
140016320                                  var_a8 = *(uint80_t*)rdx_20;
140016329                                  __pformat_efloat(&var_a8, &_Stream_1);
14001632e                                  goto label_1400162c8;
140016306                              }
1400162d8                              case 0x66:
1400162d8                              {
1400162d8                                  rdx_18 = *(uint64_t*)r13;
1400162dc                                  int32_t rax_18 = var_70 | 0x20;
1400162e1                                  var_70 = rax_18;
1400162e1                                  
1400162e5                                  if (!((uint8_t)rax_18 & 4))
1400162e5                                  {
1400164d6                                  label_1400164d6:
1400164d6                                      var_a8 = (long double)rdx_18;
1400164df                                      __pformat_float(&var_a8, &_Stream_1);
1400164e4                                      goto label_1400162c8;
1400162e5                                  }
1400162e5                                  
1400162f2                              label_1400162f2:
1400162f2                                  var_a8 = *(uint80_t*)rdx_18;
1400162fb                                  __pformat_float(&var_a8, &_Stream_1);
140016300                                  goto label_1400162c8;
1400162d8                              }
14001629b                              case 0x67:
14001629b                              {
14001629b                                  rdx_16 = *(uint64_t*)r13;
14001629f                                  int32_t rax_16 = var_70 | 0x20;
1400162a4                                  var_70 = rax_16;
1400162a4                                  
1400162a8                                  if ((uint8_t)rax_16 & 4)
1400162a8                                  {
1400162b5                                  label_1400162b5:
1400162b5                                      var_a8 = *(uint80_t*)rdx_16;
1400162be                                      __pformat_gfloat(&var_a8, &_Stream_1);
1400162c3                                      goto label_1400162c8;
1400162a8                                  }
1400162a8                                  
140016507                              label_140016507:
140016507                                  var_a8 = (long double)rdx_16;
140016510                                  __pformat_gfloat(&var_a8, &_Stream_1);
1400162c8                              label_1400162c8:
1400162c8                                  r13 = &r13[1];
1400162cc                                  rbx_1 = (char*)rsi_3 + 1;
1400162cf                                  break;
1400162cf                                  break;
14001629b                                  break;
14001629b                              }
1400160b4                              case 0x68:
1400160b4                              {
1400160b4                                  rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
1400160b4                                  
1400160ba                                  if (rax_2 == 0x68)
1400160ba                                  {
140016801                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 2);
140016805                                      r10_1 = 5;
14001680b                                      rsi_3 += 2;
14001680f                                      r14_1 = 4;
1400160ba                                  }
1400160ba                                  else
1400160ba                                  {
1400160c0                                      rsi_3 += 1;
1400160c3                                      r10_1 = 1;
1400160c9                                      r14_1 = 4;
1400160ba                                  }
1400160b4                                  break;
1400160b4                              }
140016020                              case 0x6a:
140016020                              case 0x74:
140016020                              case 0x7a:
140016020                              {
140016020                                  rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140016024                                  r10_1 = 3;
14001602a                                  rsi_3 += 1;
14001602d                                  r14_1 = 4;
140016020                                  break;
140016020                              }
140016129                              case 0x6c:
140016129                              {
140016129                                  rax_2 = *(uint8_t*)((char*)rsi_3 + 1);
140016129                                  
14001612f                                  if (rax_2 == 0x6c)
14001612f                                  {
14001681a                                      rax_2 = *(uint8_t*)((char*)rsi_3 + 2);
14001681e                                      r10_1 = 3;
140016824                                      rsi_3 += 2;
140016828                                      r14_1 = 4;
14001612f                                  }
14001612f                                  else
14001612f                                  {
140016135                                      rsi_3 += 1;
140016138                                      r10_1 = 2;
14001613e                                      r14_1 = 4;
14001612f                                  }
140016129                                  break;
140016129                              }
1400160d8                              case 0x6d:
1400160d8                              {
1400160d8                                  rbx_1 = (char*)rsi_3 + 1;
1400160e8                                  __pformat_puts(strerror((uint64_t)rax_1), &_Stream_1);
1400160ed                                  break;
1400160ed                                  break;
1400160d8                                  break;
1400160d8                              }
1400160f6                              case 0x6e:
1400160f6                              {
1400160f6                                  int64_t* rdx_12 = *(uint64_t*)r13;
1400160fa                                  int64_t _Character_3 = (int64_t)_Character_1;
1400160fa                                  
140016102                                  if (r10_1 == 5)
1400167fa                                      *(uint8_t*)rdx_12 = (uint8_t)_Character_3;
140016102                                  else if (r10_1 == 1)
14001684e                                      *(uint16_t*)rdx_12 = (uint16_t)_Character_3;
14001610c                                  else if (r10_1 == 2 || r10_1 != 3)
140016122                                      *(uint32_t*)rdx_12 = (uint32_t)_Character_3;
14001611c                                  else
14001676a                                      *(uint64_t*)rdx_12 = _Character_3;
14001676a                                  
140016102                                  goto label_1400162c8;
1400160f6                              }
14001608c                              case 0x70:
14001608c                              {
14001608c                                  if (!r14_1 && var_70 == rdi_1)
14001608c                                  {
140016727                                      (uint32_t)var_68 = 0x10;
140016734                                      int32_t rax_35;
140016734                                      *(uint8_t*)((char*)rax_35)[1] =
140016734                                          *(uint8_t*)((char*)rdi_1)[1] | 2;
140016737                                      var_70 = rax_35;
14001608c                                  }
14001608c                                  
140016092                                  uint64_t rdx_10 = *(uint64_t*)r13;
1400160a4                                  r13 = &r13[1];
1400160a7                                  rbx_1 = (char*)rsi_3 + 1;
1400160aa                                  __pformat_xint.isra.0(0x78, rdx_10, &_Stream_1);
1400160af                                  break;
1400160af                                  break;
14001608c                                  break;
14001608c                              }
140016270                              case 0x73:
140016270                              {
140016270                                  rbx_6 = &r13[1];
140016270                                  
14001627c                                  if (r10_1 - 2 <= 1)
14001627c                                      goto label_14001666a;
14001627c                                  
140016287                                  __pformat_puts(*(uint64_t*)r13, &_Stream_1);
14001628c                              label_14001628c:
14001628c                                  r13 = rbx_6;
14001628f                                  rbx_1 = (char*)rsi_3 + 1;
140016292                                  break;
140016292                                  break;
140016270                                  break;
140016270                              }
140015f24                          }
140015f24                      
140015f99                      if (!rax_2)
140015f99                          goto label_140015fa0;
140015f1a                  }
140015ef1              }
140015ef1              
140015edc              _Character_2 = *(uint8_t*)rbx_1;
140015edf              rbx_1 += 1;
140015ee3              _Character = (int32_t)_Character_2;
140015ee8          } while (_Character);
140015ee8          
140015fa0      label_140015fa0:
140015fa0          _Character = _Character_1;
140015e91      }
140015e91      
140015fbc      return (uint64_t)_Character;
140015df0  }

140015ea5                 0f 1f 00                                                                               ...
140015f32                                                        66 0f 1f 44 00 00                                            f..D..
140015f42        66 0f 1f 44 00 00                                                                            f..D..
140015fbd                                                                                         0f 1f 00                               ...
140016017                                                                       66 0f 1f 84 00 00 00 00 00                         f........
14001617b                                                                                   0f 1f 44 00 00                             ..D..
140016448                          0f 1f 84 00 00 00 00 00                                                          ........
1400168da                                                                                90 90 90 90 90 90                            ......

1400168e0    void* __rv_alloc_D2A(int32_t arg1)

1400168e0  {
1400168e5      int32_t rbx = 0;
1400168e5      
1400168ea      if (arg1 > 0x1b)
1400168ea      {
1400168ec          int32_t rax_1 = 4;
1400168ec          
140016902          do
140016902          {
1400168f8              rax_1 *= 2;
1400168fa              rbx += 1;
140016902          } while (rax_1 + 0x17 < arg1);
1400168ea      }
1400168ea      
140016906      int64_t* rax_2 = __Balloc_D2A(rbx);
14001690b      *(uint32_t*)rax_2 = rbx;
140016916      return (char*)rax_2 + 4;
1400168e0  }

140016917                                                                       66 0f 1f 84 00 00 00 00 00                         f........

140016920    void* __nrv_alloc_D2A(char* arg1, void** arg2, int32_t arg3)

140016920  {
140016931      int32_t rbx;
140016931      
140016931      if (arg3 <= 0x1b)
140016998          rbx = 0;
140016931      else
140016931      {
140016933          int32_t rax_1 = 4;
140016938          rbx = 0;
140016938          
14001694b          do
14001694b          {
140016940              rax_1 *= 2;
140016942              rbx += 1;
14001694b          } while (arg3 > rax_1 + 0x17);
140016931      }
140016931      
14001694f      int64_t* rax_2 = __Balloc_D2A(rbx);
140016954      void* rdx_1 = &arg1[1];
140016958      *(uint32_t*)rax_2 = rbx;
14001695a      char rcx_1 = *(uint8_t*)arg1;
140016963      *(uint8_t*)((char*)rax_2 + 4) = rcx_1;
140016966      void* rax_3 = (char*)rax_2 + 4;
140016966      
140016969      if (rcx_1)
140016969      {
14001697f          char i;
14001697f          
14001697f          do
14001697f          {
140016970              i = *(uint8_t*)rdx_1;
140016973              rax_3 += 1;
140016977              rdx_1 += 1;
14001697d              *(uint8_t*)rax_3 = i;
14001697f          } while (i);
140016969      }
140016969      
140016984      if (arg2)
140016986          *(uint64_t*)arg2 = rax_3;
140016986      
140016993      return (char*)rax_2 + 4;
140016920  }

140016994                                                              0f 1f 40 00                                              ..@.
14001699c                                                                                      0f 1f 40 00                              ..@.

1400169a0    int64_t __freedtoa(void* arg1)

1400169a0  {
1400169a8      int32_t rcx = *(uint32_t*)((char*)arg1 - 4);
1400169bd      *(uint64_t*)((char*)arg1 + 4) =
1400169bd          _mm_unpacklo_epi32((uint128_t)rcx, (uint64_t)(1 << (uint8_t)rcx));
1400169c2      /* tailcall */
1400169c2      return __Bfree_D2A((char*)arg1 - 4);
1400169a0  }

1400169c7                       66 0f 1f 84 00 00 00 00 00                                                         f........

1400169d0    uint64_t __quorem_D2A(void* arg1, void* arg2)

1400169d0  {
1400169e2      int32_t rdi = *(uint32_t*)((char*)arg2 + 0x14);
1400169e2      
1400169ee      if (*(uint32_t*)((char*)arg1 + 0x14) < rdi)
140016af2          return 0;
140016af2      
1400169f4      void* rbx_1 = (char*)arg2 + 0x18;
1400169f8      int32_t rdi_1 = rdi - 1;
140016a08      void* rbp_1 = (char*)rbx_1 + ((int64_t)rdi_1 << 2);
140016a0c      int32_t* r11_3 = &((char*)arg1 + 0x18)[(int64_t)rdi_1];
140016a0f      int32_t r8_1 = *(uint32_t*)r11_3;
140016a15      int32_t rcx = *(uint32_t*)rbp_1 + 1;
140016a1b      uint32_t temp0_1 = COMBINE(0, r8_1) / rcx;
140016a24      uint32_t rsi_1 = temp0_1;
140016a24      
140016a26      if (r8_1 >= rcx)
140016a26      {
140016a2b          void* r10_1 = rbx_1;
140016a2e          void* r9_1 = (char*)arg1 + 0x18;
140016a31          uint64_t rax_4 = 0;
140016a33          uint64_t r8_2 = 0;
140016a33          
140016a77          do
140016a77          {
140016a40              uint64_t rdx_1 = (uint64_t)*(uint32_t*)r10_1;
140016a43              r10_1 += 4;
140016a47              r9_1 += 4;
140016a53              int64_t rdx_3 = rdx_1 * (uint64_t)temp0_1 + rax_4;
140016a5e              rax_4 = rdx_3 >> 0x20;
140016a62              uint64_t rcx_3 = (uint64_t)*(uint32_t*)((char*)r9_1 - 4)
140016a62                  - (uint64_t)(uint32_t)rdx_3 - r8_2;
140016a68              *(uint32_t*)((char*)r9_1 - 4) = (uint32_t)rcx_3;
140016a70              r8_2 = (uint64_t)(uint32_t)(rcx_3 >> 0x20) & 1;
140016a77          } while (rbp_1 >= r10_1);
140016a26      }
140016a26      
140016a7f      if (r8_1 >= rcx && !*(uint32_t*)r11_3)
140016a7f      {
140016b2b          while (true)
140016b2b          {
140016b2b              r11_3 -= 4;
140016b2b              
140016b32              if ((char*)arg1 + 0x18 >= r11_3)
140016b32                  break;
140016b32              
140016b26              if (*(uint32_t*)r11_3)
140016b26                  break;
140016b26              
140016b28              rdi_1 -= 1;
140016b2b          }
140016b2b          
140016b34          *(uint32_t*)((char*)arg1 + 0x14) = rdi_1;
140016b34          
140016b45          if (__cmp_D2A(arg1, arg2) >= 0)
140016b45              goto label_140016a94;
140016a7f      }
140016a7f      else if (__cmp_D2A(arg1, arg2) >= 0)
140016a92      {
140016a94      label_140016a94:
140016a94          int32_t* rcx_5 = (char*)arg1 + 0x18;
140016a97          uint64_t rdx_6 = 0;
140016a97          
140016ac4          do
140016ac4          {
140016aa0              uint64_t rax_7 = (uint64_t)*(uint32_t*)rcx_5;
140016aa2              rbx_1 += 4;
140016aa6              rcx_5 = &rcx_5[1];
140016ab1              uint64_t rax_9 = rax_7 - (uint64_t)*(uint32_t*)((char*)rbx_1 - 4) - rdx_6;
140016ab7              rcx_5[-1] = (uint32_t)rax_9;
140016abe              rdx_6 = (uint64_t)(uint32_t)(rax_9 >> 0x20) & 1;
140016ac4          } while (rbp_1 >= rbx_1);
140016ac4          
140016ac9          int32_t* rax_11 = &((char*)arg1 + 0x18)[(int64_t)rdi_1];
140016ac9          
140016ad1          if (!*(uint32_t*)rax_11)
140016ad1          {
140016b01              while (true)
140016b01              {
140016b01                  rax_11 -= 4;
140016b01                  
140016b08                  if ((char*)arg1 + 0x18 >= rax_11)
140016b08                      break;
140016b08                  
140016afc                  if (*(uint32_t*)rax_11)
140016afc                      break;
140016afc                  
140016afe                  rdi_1 -= 1;
140016b01              }
140016b01              
140016b0e              *(uint32_t*)((char*)arg1 + 0x14) = rdi_1;
140016b12              rsi_1 = temp0_1 + 1;
140016ad1          }
140016ad1          else
140016ad7              rsi_1 = temp0_1 + 1;
140016a92      }
140016a92      
140016ae0      return (uint64_t)rsi_1;
1400169d0  }

140016af3                                                           0f 1f 44 00 00                                             ..D..
140016b17                                                                       66 0f 1f 84 00 00 00 00 00                         f........
140016b4d                                         90 90 90                                                               ...

140016b50    void* __gdtoa(int32_t* arg1, int32_t arg2, int32_t* arg3, int32_t* arg4, int32_t arg5, int32_t arg6, int32_t* arg7, void** arg8)

140016b50  {
140016b6b      int32_t rdi = *(uint32_t*)arg4;
140016b6e      int32_t r15 = arg5;
140016b76      int32_t r14 = arg6;
140016b8e      int32_t* rbx = arg4;
140016ba4      *(uint32_t*)arg4 = rdi & 0xffffffcf;
140016ba9      int32_t rax_5 = rdi & 7;
140016baf      char* rcx_8;
140016baf      void** rdx_16;
140016baf      int32_t r8_4;
140016baf      
140016baf      if (rax_5 == 3)
140016baf      {
140016e8d          r8_4 = 8;
140016e93          rdx_16 = arg8;
140016e98          rcx_8 = "Infinity";
140016e9f          *(uint32_t*)arg7 = 0xffff8000;
140016baf      }
140016baf      else
140016baf      {
140016bb7          int32_t rsi_2 = rdi & 4;
140016bba          int32_t var_b4_1 = rsi_2;
140016bba          
140016bbe          if (!rsi_2)
140016bbe          {
140016bc6              if (!rax_5)
140016bc6              {
140016e5f                  *(uint32_t*)arg7 = 1;
140016e6a                  return __nrv_alloc_D2A(U"0", arg8, 1);
140016bc6              }
140016bc6              
140016bcc              int32_t rbp_1 = *(uint32_t*)arg1;
140016bce              int32_t rcx = 0;
140016bd0              int32_t rax_6 = 0x20;
140016bd0              
140016bd8              if (rbp_1 > 0x20)
140016bd8              {
140016be1                  do
140016be1                  {
140016bda                      rax_6 *= 2;
140016bdc                      rcx += 1;
140016be1                  } while (rbp_1 > rax_6);
140016bd8              }
140016bd8              
140016bec              int64_t* rsi_3 = __Balloc_D2A(rcx);
140016bef              int32_t* rax_8 = arg3;
140016bf8              void* rdx = &rsi_3[3];
140016bfc              int64_t r8_2 = (int64_t)((rbp_1 - 1) >> 5);
140016bff              void* rcx_1 = &rax_8[r8_2];
140016bff              
140016c1a              do
140016c1a              {
140016c08                  int32_t r9 = *(uint32_t*)rax_8;
140016c0b                  rax_8 = &rax_8[1];
140016c0f                  rdx += 4;
140016c16                  *(uint32_t*)((char*)rdx - 4) = r9;
140016c1a              } while (rcx_1 >= rax_8);
140016c1a              
140016c25              void* rax_9 = (r8_2 << 2) + 4;
140016c25              
140016c39              if ((char*)rcx_1 + 1 < (char*)arg3 + 1)
140016c39                  rax_9 = 4;
140016c39              
140016c3d              int64_t rax_10 = rax_9 >> 2;
140016c41              int32_t r13_1 = (uint32_t)rax_10;
140016c44              void* rax_11 = (char*)rsi_3 + (rax_10 << 2);
140016c44              
140016c60              while (true)
140016c60              {
140016c60                  int32_t rdx_3 = r13_1;
140016c63                  r13_1 -= 1;
140016c63                  
140016c69                  if (*(uint32_t*)((char*)rax_11 + 0x14))
140016c69                  {
140016c6e                      *(uint32_t*)((char*)rsi_3 + 0x14) = rdx_3;
140016c74                      uint64_t rflags_1;
140016c74                      int32_t temp0_1;
140016c74                      temp0_1 = __bsr_gprv_memv(
140016c74                          *(uint32_t*)((char*)rsi_3 + ((int64_t)r13_1 << 2) + 0x18));
140016c7f                      r13_1 = (rdx_3 << 5) - (temp0_1 ^ 0x1f);
140016c7f                      break;
140016c69                  }
140016c69                  
140016c50                  rax_11 -= 4;
140016c50                  
140016c57                  if (!r13_1)
140016c57                  {
140016eb0                      *(uint32_t*)((char*)rsi_3 + 0x14) = 0;
140016eb7                      break;
140016c57                  }
140016c60              }
140016c60              
140016c85              int32_t rax_14 = __trailz_D2A(rsi_3);
140016c90              int32_t var_4c = rax_14;
140016c97              int32_t var_a8_1 = arg2;
140016c97              
140016c9b              if (rax_14)
140016c9b              {
140016ec5                  __rshift_D2A(rsi_3, rax_14);
140016eca                  int32_t rax_30 = var_4c;
140016ed5                  r13_1 -= rax_30;
140016edb                  var_a8_1 = rax_30 + arg2;
140016c9b              }
140016c9b              
140016ca6              if (!*(uint32_t*)((char*)rsi_3 + 0x14))
140016ca6              {
140016e43                  __Bfree_D2A(rsi_3);
140016e5f                  *(uint32_t*)arg7 = 1;
140016e6a                  return __nrv_alloc_D2A(U"0", arg8, 1);
140016ca6              }
140016ca6              
140016cb7              double zmm0_1 = __b2d_D2A(rsi_3, &var_4c);
140016cd0              int32_t r8_3 = var_a8_1 + r13_1;
140016ce1              uint64_t rdx_10 =
140016ce1                  ((uint64_t)(uint32_t)(zmm0_1 >> 0x20) & 0xfffff) | 0x3ff00000;
140016cfa              uint64_t rax_18 = (uint64_t)(uint32_t)zmm0_1 | rdx_10 << 0x20;
140016d03              int32_t r9_3 = 1 - r8_3;
140016d03              
140016d0d              if (r8_3 - 1 >= 0)
140016d0d                  r9_3 = r8_3 - 1;
140016d0d              
140016d33              zmm0_1 = (rax_18 - 1,5.0) * 0,28952965460216801.0 + 0,1760912590558.0
140016d33                  + (double)(r8_3 - 1) * 0,30102999566398098.0;
140016d33              
140016d37              if (r9_3 - 0x435 > 0)
140016d4a                  zmm0_1 = zmm0_1 + (double)(r9_3 - 0x435) * 7,0000000000000003e-17;
140016d4a              
140016d4e              int32_t r10_2 = (int32_t)zmm0_1;
140016d5b              int32_t var_ac_1 = r10_2;
140016d5b              
140016d60              if (0.0 > zmm0_1)
140016d60              {
140017254                  int64_t zmm1_1 = (double)r10_2;
140017259                  zmm1_1 - zmm0_1;
140017259                  
14001725f                  if (FCMP_UO(zmm1_1, zmm0_1) || !(zmm1_1 == zmm0_1))
140017265                      var_ac_1 -= 1;
140016d60              }
140016d60              
140016d78              uint64_t rax_20 = (uint64_t)(uint32_t)rax_18
140016d78                  | (uint64_t)((uint32_t)rdx_10 + ((r8_3 - 1) << 0x14)) << 0x20;
140016d7b              int64_t rdx_14 = (int64_t)var_ac_1;
140016d91              int32_t rax_22 = r13_1 - (r8_3 - 1);
140016d93              int32_t r9_7 = rax_22 - 1;
140016d9a              int32_t var_98_1;
140016d9a              int32_t var_78_1;
140016d9a              
140016d9a              if ((uint32_t)rdx_14 > 0x16)
140016ee8                  var_78_1 = 1;
140016d9a              else
140016d9a              {
140016db5                  if (!(*(uint64_t*)(&__tens_D2A + (rdx_14 << 3)) > rax_20))
140016db5                  {
140016dbd                      var_98_1 = 0;
140016dc5                      var_78_1 = 0;
140016dc5                      
140016dd0                      if (rax_22 <= 0)
140016dd0                      {
140016dd7                          r9_7 = 0;
140016ddc                          var_98_1 = 1 - rax_22;
140016dd0                      }
140016dd0                      
140016dd0                      goto label_140016de4;
140016db5                  }
140016db5                  
1400172e0                  var_ac_1 -= 1;
1400172e5                  var_78_1 = 0;
140016d9a              }
140016d9a              
140016ef6              var_98_1 = 0;
140016ef6              
140016efe              if (r9_7 < 0)
140016efe              {
140016f05                  r9_7 = 0;
140016f0a                  var_98_1 = 1 - rax_22;
140016efe              }
140016efe              
140016f16              int32_t var_90_1;
140016f16              int32_t var_7c_1;
140016f16              
140016f16              if (var_ac_1 >= 0)
140016f16              {
140016de4              label_140016de4:
140016de4                  var_7c_1 = 0;
140016dec                  r9_7 += var_ac_1;
140016def                  var_90_1 = var_ac_1;
140016f16              }
140016f16              else
140016f16              {
140016f1c                  int32_t rax_31 = var_ac_1;
140016f20                  var_ac_1 = 0;
140016f28                  var_98_1 -= rax_31;
140016f2e                  var_90_1 = rax_31;
140016f34                  var_7c_1 = -(rax_31);
140016f16              }
140016f16              
140016f3c              int32_t var_b0_1;
140016f3c              void* result_1;
140016f3c              uint64_t var_88;
140016f3c              int32_t var_80_1;
140016f3c              char var_60_1;
140016f3c              int32_t var_5c_1;
140016f3c              int32_t r9_9;
140016f3c              uint64_t r10_5;
140016f3c              
140016f3c              if (r15 <= 9)
140016f3c              {
140016f46                  if (r15 <= 5)
140016f46                  {
140016f63                      var_60_1 = (char)(r8_3 + 0x3fd <= 0x7f7);
140016f63                      
140016f6a                      if (r15 == 4)
140016f6a                          goto label_140017c8c;
140016f6a                      
140016f74                      if (r15 == 5)
140016f74                          goto label_140017b08;
140016f74                      
140016f7e                      if (r15 == 2)
140016f7e                      {
140016f84                          (uint32_t)var_88 = 0;
140016f84                          goto label_140016f8f;
140016f7e                      }
140016f7e                      
140017654                      if (r15 != 3)
140017654                          goto label_1400171fe;
140017654                      
14001765a                      (uint32_t)var_88 = 0;
140017662                      goto label_1400172b4;
140016f46                  }
140016f46                  
140017270                  var_60_1 = 0;
14001727b                  r15 -= 4;
140017283                  int32_t rax_33;
140017283                  int32_t rcx_15;
140017283                  
140017283                  if (r15 == 4)
140017283                  {
140017c8c                  label_140017c8c:
140017c8c                      (uint32_t)var_88 = 1;
140016f8f                  label_140016f8f:
140016f8f                      rcx_15 = 1;
140016f8f                      
140016f94                      if (r14 > 0)
140016f94                          rcx_15 = r14;
140016f94                      
140016f98                      rax_33 = rcx_15;
140016f9a                      var_5c_1 = rcx_15;
140016fa1                      r14 = rcx_15;
140016fa4                      var_b0_1 = rcx_15;
140017283                  }
140017283                  else
140017283                  {
14001728d                      if (r15 != 5)
14001728d                      {
140017297                          (uint32_t)var_88 = 0;
140017297                          
14001729f                          if (r15 == 2)
14001729f                              goto label_140016f8f;
14001729f                          
1400172a5                          r15 = 3;
1400172ab                          goto label_1400172b4;
14001728d                      }
14001728d                      
140017b08                  label_140017b08:
140017b08                      (uint32_t)var_88 = 1;
1400172b4                  label_1400172b4:
1400172b4                      int32_t rax_52 = var_90_1 + r14;
1400172ba                      var_5c_1 = rax_52;
1400172c1                      rax_33 = 1;
1400172c8                      var_b0_1 = rax_52 + 1;
1400172c8                      
1400172cc                      if (rax_52 + 1 > 0)
1400172cc                          rax_33 = rax_52 + 1;
1400172cc                      
1400172cf                      rcx_15 = rax_33;
140017283                  }
140017283                  
140016fb8                  var_4c = rax_33;
140016fc4                  r9_9 = r9_7;
140016fcc                  result_1 = __rv_alloc_D2A(rcx_15);
140016fd1                  int32_t rax_35 = arg1[3];
140016fd6                  r10_5 = rax_20;
140016fe1                  var_80_1 = rax_35 - 1;
140016fe1                  
140016fe5                  if (rax_35 == 1)
140016fe5                      goto label_14001701a;
140016fe5                  
140016fe5                  goto label_140016feb;
140016f3c              }
140016f3c              
1400171d3              r15 = 0;
1400171d6              var_60_1 = (char)(r8_3 + 0x3fd <= 0x7f7);
1400171fe          label_1400171fe:
1400171fe              var_4c = (int32_t)((double)rbp_1 * 0,30103000000000002.0) + 3;
14001720a              r9_9 = r9_7;
14001720f              result_1 =
14001720f                  __rv_alloc_D2A((int32_t)((double)rbp_1 * 0,30103000000000002.0) + 3);
140017214              int32_t rax_49 = arg1[3];
140017219              r10_5 = rax_20;
140017221              var_80_1 = rax_49 - 1;
140017225              int32_t var_a8_2;
140017225              void* result;
140017225              int32_t var_74_2;
140017225              void* result_3;
140017225              void* result_4;
140017225              char rdx_33;
140017225              int32_t rbp_3;
140017225              int32_t rdi_4;
140017225              int64_t* rdi_7;
140017225              int64_t* r11_5;
140017225              uint128_t zmm0_3;
140017225              uint128_t zmm1_3;
140017225              uint128_t zmm2;
140017225              double zmm3;
140017225              
140017225              if (rax_49 == 1)
140017225              {
1400172f9                  r14 = 0;
1400172fc                  var_b0_1 = 0xffffffff;
1400172fc                  
140017306                  if (var_a8_1 < 0)
140017306                  {
140018077                      var_5c_1 = 0xffffffff;
140017460                  label_140017460:
140017460                      int32_t rbp_2 = rbp_1 - r13_1;
140017463                      int32_t rdx_39 = arg1[1];
140017468                      int32_t rax_61 = rbp_2 + 1;
14001746b                      var_4c = rax_61;
140017478                      int32_t rax_122;
140017478                      
140017478                      if (var_a8_1 - rbp_2 < rdx_39)
140017478                      {
140017485                          if (!((r15 - 3) & 0xfffffffd))
140017485                              goto label_140017b62;
140017485                          
140017493                          rax_61 = var_a8_1 - rdx_39 + 1;
14001749a                          int32_t rcx_27;
14001749a                          (uint8_t)rcx_27 = r15 > 1;
14001749d                          var_4c = rax_61;
1400174a6                          (uint8_t)rdx_39 = var_b0_1 > 0;
1400174a6                          
1400174af                          if (!((uint8_t)rcx_27 & (uint8_t)rdx_39) || rax_61 <= var_b0_1)
1400174ab                              goto label_1400174b9;
1400174ab                          
1400181f6                          rax_122 = var_b0_1 - 1;
1400181f6                          
1400181fb                          if (var_7c_1 < rax_122)
1400181fb                              goto label_140017cda;
1400181fb                          
140018203                          r9_9 += var_b0_1;
140018208                          var_4c = var_b0_1;
140018213                          rbp_3 = var_7c_1 - rax_122;
140018217                          var_74_2 = var_98_1;
14001821e                          var_98_1 += var_b0_1;
140017478                      }
140017478                      else if (r15 <= 1)
140017b54                      {
1400174b9                      label_1400174b9:
1400174b9                          r9_9 += rax_61;
1400174bc                          rbp_3 = var_7c_1;
1400174c2                          var_74_2 = var_98_1;
1400174c9                          var_98_1 += rax_61;
140017b54                      }
140017b54                      else
140017b54                      {
140017b62                      label_140017b62:
140017b62                          rax_122 = var_b0_1 - 1;
140017b62                          
140017b67                          if (var_7c_1 < rax_122)
140017b67                          {
140017cda                          label_140017cda:
140017cda                              int32_t rdi_19 = var_7c_1;
140017ce0                              rbp_3 = 0;
140017ce2                              var_7c_1 = rax_122;
140017cf0                              var_ac_1 += rax_122 - rdi_19;
140017cf4                              var_74_2 = var_98_1;
140017cfb                              var_4c = var_b0_1;
140017d02                              r9_9 += var_b0_1;
140017d07                              var_98_1 += var_b0_1;
140017b67                          }
140017b67                          else
140017b67                          {
140017b6f                              rbp_3 = var_7c_1 - rax_122;
140017b6f                              
140017b73                              if (var_b0_1 >= 0)
140017b73                              {
14001813c                                  var_4c = var_b0_1;
140018143                                  r9_9 += var_b0_1;
140018148                                  var_74_2 = var_98_1;
14001814f                                  var_98_1 += var_b0_1;
140017b73                              }
140017b73                              else
140017b73                              {
140017b79                                  var_4c = 0;
140017b8e                                  var_74_2 = var_98_1 - var_b0_1;
140017b73                              }
140017b67                          }
140017b54                      }
1400174e1                      (uint32_t)var_88 = 1;
1400174e9                      rdi_7 = __i2b_D2A(1);
1400174e9                      goto label_1400174fa;
140017306                  }
140017306                  
14001730c                  (uint32_t)var_88 = 1;
140017314                  var_5c_1 = 0xffffffff;
140017314                  
140017329                  if (var_90_1 > arg1[5])
140017329                  {
140017453                  label_140017453:
140017453                      
140017456                      if ((uint32_t)var_88)
140017456                          goto label_140017460;
140017456                      
140017754                  label_140017754:
140017754                      rdi_7 = nullptr;
140017756                      rbp_3 = var_7c_1;
14001775a                      var_74_2 = var_98_1;
1400174fa                  label_1400174fa:
1400174fa                      
1400174fa                      if (var_74_2 > 0 && r9_9 > 0)
1400174fa                      {
1400174ff                          int32_t rax_68 = var_74_2;
1400174ff                          
140017501                          if (var_74_2 > r9_9)
140017501                              rax_68 = r9_9;
140017501                          
140017505                          var_98_1 -= rax_68;
14001750b                          var_4c = rax_68;
140017512                          r9_9 -= rax_68;
140017515                          var_74_2 -= rax_68;
1400174fa                      }
1400174fa                      
140017522                      if (var_7c_1)
140017522                      {
14001752e                          if (!(uint32_t)var_88 || !rbp_3)
14001754a                              rsi_3 = __pow5mult_D2A(rsi_3, var_7c_1);
14001752e                          else
14001752e                          {
140017d67                              uint64_t var_70;
140017d67                              (uint32_t)var_70 = r9_9;
140017d6f                              int64_t* rax_130 = __pow5mult_D2A(rdi_7, rbp_3);
140017d7a                              rdi_7 = rax_130;
140017d85                              var_a8_1 = __mult_D2A(rax_130, rsi_3);
140017d8a                              __Bfree_D2A(rsi_3);
140017d8f                              rsi_3 = var_a8_1;
140017d98                              r9_9 = (uint32_t)var_70;
140017d98                              
140017da0                              if (var_7c_1 != rbp_3)
14001754a                                  rsi_3 = __pow5mult_D2A(rsi_3, var_7c_1 - rbp_3);
14001752e                          }
140017522                      }
140017522                      
14001755c                      int32_t r9_10 = r9_9;
140017561                      r11_5 = __i2b_D2A(1);
14001756a                      int32_t rbp_4;
14001756a                      
14001756a                      if (var_ac_1)
14001756a                      {
140017ad8                          r9_10 = r9_9;
140017add                          r11_5 = __pow5mult_D2A(r11_5, var_ac_1);
140017add                          
140017d26                          if (r15 <= 1 && r13_1 == 1 && arg2 > arg1[1] + 1)
140017d26                          {
140017d2c                              var_98_1 += 1;
140017d31                              r9_10 += 1;
140017d35                              var_ac_1 = 1;
140017d26                          }
140017d26                          else
140017ae6                              var_ac_1 = 0;
140017ae6                          
140017af7                          uint64_t rflags_2;
140017af7                          int32_t temp0_4;
140017af7                          temp0_4 = __bsr_gprv_memv(*(uint32_t*)((char*)r11_5
140017af7                              + ((int64_t)(*(uint32_t*)((char*)r11_5 + 0x14) - 1) << 2)
140017af7                              + 0x18));
140017afd                          rbp_4 = temp0_4 ^ 0x1f;
14001756a                      }
14001756a                      else
14001756a                      {
140017b2e                          if (r15 <= 1 && r13_1 == 1 && arg2 > arg1[1] + 1)
140017b2e                          {
140017b34                              var_98_1 += 1;
140017b39                              r9_10 += 1;
140017b3d                              var_ac_1 = 1;
140017b2e                          }
140017b2e                          
14001757a                          rbp_4 = 0x1f;
14001756a                      }
14001756a                      
140017589                      int32_t rbp_7 = (rbp_4 - r9_10 - 4) & 0x1f;
14001758c                      var_4c = rbp_7;
140017593                      int32_t rdx_42 = rbp_7;
140017595                      int32_t rax_73 = var_98_1 + rbp_7;
140017595                      
140017599                      if (rax_73 > 0)
140017599                      {
1400175a0                          int32_t var_a8_4;
1400175a0                          var_a8_4 = r11_5;
1400175aa                          int64_t* rax_74 = __lshift_D2A(rsi_3, rax_73);
1400175af                          rdx_42 = var_4c;
1400175b6                          r11_5 = var_a8_4;
1400175bb                          rsi_3 = rax_74;
140017599                      }
140017599                      
1400175c3                      int32_t rdx_44 = rdx_42 + r9_10;
1400175c3                      
1400175c8                      if (rdx_44 > 0)
1400175d2                          r11_5 = __lshift_D2A(r11_5, rdx_44);
1400175d2                      
1400175e0                      int32_t* r12;
1400175e0                      (uint8_t)r12 = r15 > 2;
1400175e0                      
1400175e6                      if (!var_78_1)
1400175e6                      {
1400175f0                      label_1400175f0:
1400175f0                          
1400175fb                          if (var_b0_1 <= 0 && (uint8_t)r12)
1400175f2                              goto label_140017606;
1400175f2                          
14001777f                          var_a8_2 = var_90_1 + 1;
14001777f                          
140017783                          if (!(uint32_t)var_88)
140017783                              goto label_140017a08;
140017783                          
140017783                          goto label_140017790;
1400175e6                      }
1400175e6                      
140017996                      int32_t var_c0;
140017996                      var_c0 = r11_5;
14001799b                      int32_t rax_101 = __cmp_D2A(rsi_3, r11_5);
1400179a0                      r11_5 = var_c0;
1400179a0                      
1400179a7                      if (rax_101 >= 0)
1400179a7                          goto label_1400175f0;
1400179a7                      
1400179c5                      r11_5 = var_c0;
1400179ca                      rsi_3 = __multadd_D2A(rsi_3, 0xa, 0);
1400179d6                      int32_t rax_104;
1400179d6                      (uint8_t)rax_104 = var_5c_1 <= 0;
1400179d9                      char r12_3 = (uint8_t)r12 & (uint8_t)rax_104;
1400179e2                      void* result_5;
1400179e2                      void* result_8;
1400179e2                      int64_t* r11_7;
1400179e2                      int32_t r13_4;
1400179e2                      void* result_10;
1400179e2                      int64_t* r15_2;
1400179e2                      
1400179e2                      if ((uint32_t)var_88)
1400179e2                      {
14001816b                          r11_5 = var_c0;
140018170                          rdi_7 = __multadd_D2A(rdi_7, 0xa, 0);
140018170                          
140018173                          if (r12_3)
140018173                          {
14001808e                          label_14001808e:
14001808e                              var_90_1 -= 1;
140018093                              var_b0_1 = var_5c_1;
140017606                          label_140017606:
140017606                              
140017609                              if (var_b0_1)
140017609                                  goto label_14001766f;
140017609                              
140017616                              int64_t* rax_78 = __multadd_D2A(r11_5, 5, 0);
14001762b                              r11_5 = rax_78;
14001762b                              
140017632                              if (__cmp_D2A(rsi_3, rax_78) <= 0)
140017632                                  goto label_14001766f;
140017632                              
140017638                              result = result_1;
140017640                              var_a8_2 = var_90_1 + 2;
140017644                              goto label_140017386;
140018173                          }
140018173                          
14001817d                          var_a8_2 = var_90_1;
140018188                          var_b0_1 = var_5c_1;
140017790                      label_140017790:
140017790                          int32_t rdx_49 = var_74_2 + rbp_7;
140017790                          
140017794                          if (rdx_49 > 0)
140017794                          {
140017799                              var_c0 = r11_5;
1400177a3                              r11_5 = var_c0;
1400177a8                              rdi_7 = __lshift_D2A(rdi_7, rdx_49);
140017794                          }
140017794                          
1400177b0                          int64_t* r12_2 = rdi_7;
1400177b0                          
1400177b6                          if (var_ac_1)
1400177b6                          {
140017f3d                              var_c0 = r11_5;
140017f42                              int64_t* rax_140 = __Balloc_D2A(rdi_7[1]);
140017f5e                              memcpy(&rax_140[2], &rdi_7[2], 
140017f5e                                  ((int64_t)*(uint32_t*)((char*)rdi_7 + 0x14) << 2) + 8);
140017f70                              r11_5 = var_c0;
140017f75                              r12_2 = __lshift_D2A(rax_140, 1);
1400177b6                          }
1400177b6                          
1400177c1                          var_90_1 = rbx;
1400177c6                          int32_t rax_86 = 1;
1400177d5                          var_c0 = r11_5;
1400177da                          void* result_7 = result_1;
1400177da                          
14001788f                          while (true)
14001788f                          {
14001788f                              var_4c = rax_86;
140017896                              int32_t rax_92 = __quorem_D2A(rsi_3, var_c0);
1400178a1                              r13_4 = rax_92 + 0x30;
1400178a8                              int32_t rax_93 = __cmp_D2A(rsi_3, rdi_7);
1400178b7                              int64_t* rax_94 = __diff_D2A(var_c0, r12_2);
1400178c6                              int32_t rdx_50;
1400178c6                              void* result_11;
1400178c6                              
1400178c6                              if (rax_94[2])
1400178c6                              {
1400177eb                                  __Bfree_D2A(rax_94);
1400177f0                                  rdx_50 = 1;
1400178c6                              }
1400178c6                              else
1400178c6                              {
1400178cf                                  var_98_1 = rax_94;
1400178de                                  int32_t* var_c8;
1400178de                                  (uint32_t)var_c8 = __cmp_D2A(rsi_3, rax_94);
1400178e2                                  __Bfree_D2A(var_98_1);
1400178ef                                  rdx_50 = (uint32_t)var_c8 | r15;
1400178ef                                  
1400178f1                                  if (rdx_50)
140017c83                                      rdx_50 = (uint32_t)var_c8;
1400178f1                                  else if (!((*(uint32_t*)arg3 & 1) | var_80_1))
140017901                                  {
14001790b                                      result_11 = result_7;
14001790e                                      r11_7 = var_c0;
140017913                                      rbx = var_90_1;
140017913                                      
140017918                                      if (r13_4 == 0x39)
140017918                                          goto label_14001805c;
140017918                                      
140017920                                      if (rax_93 <= 0)
140017920                                      {
140018295                                          var_b4_1 = 0x10;
140018295                                          
14001829d                                          if (*(uint32_t*)((char*)rsi_3 + 0x14) <= 1)
14001829d                                          {
1400182a9                                              int32_t rax_156;
1400182a9                                              (uint8_t)rax_156 = rsi_3[3];
1400182af                                              var_b4_1 = rax_156 << 4;
14001829d                                          }
140017920                                      }
140017920                                      else
140017920                                      {
140017926                                          r13_4 = rax_92 + 0x31;
14001792a                                          var_b4_1 = 0x20;
140017920                                      }
140017920                                      
140017932                                      result_8 = (char*)result_11 + 1;
140017936                                      r15_2 = rdi_7;
140017939                                      *(uint8_t*)result_11 = (uint8_t)r13_4;
14001793c                                      rdi_7 = r12_2;
14001793f                                      goto label_140017943;
140017901                                  }
1400178c6                              }
1400178c6                              
140017807                              if (rax_93 < 0
140017807                                  || (!(rax_93 | r15) && !(*(uint8_t*)arg3 & 1)))
140017807                              {
140017e15                                  result_11 = result_7;
140017e18                                  r11_7 = var_c0;
140017e1d                                  rbx = var_90_1;
140017e1d                                  
140017e25                                  if (!var_80_1)
140017e25                                  {
140017fee                                      if (rdx_50 <= 0)
140017fee                                          goto label_14001803f;
140017fee                                      
140017ffd                                  label_140017ffd:
140017ffd                                      var_c0 = result_11;
140018002                                      int64_t* rax_143 = __lshift_D2A(rsi_3, 1);
14001800f                                      rsi_3 = rax_143;
140018012                                      int32_t rax_144 = __cmp_D2A(rax_143, r11_7);
14001801e                                      result_11 = var_c0;
14001801e                                      
14001827e                                      if (rax_144 <= 0
14001827e                                          && (rax_144 || !((uint8_t)r13_4 & 1)))
14001827e                                      {
140018284                                          var_80_1 = 0x20;
14001803f                                      label_14001803f:
14001803f                                          
14001803f                                          if (*(uint32_t*)((char*)rsi_3 + 0x14) <= 1)
14001803f                                          {
140018259                                              r15_2 = rdi_7;
14001825c                                              rdi_7 = r12_2;
14001825c                                              
140018261                                              if (!rsi_3[3])
140018261                                              {
14001826b                                                  result_8 = (char*)result_11 + 1;
14001826f                                                  var_b4_1 = var_80_1;
140017ed3                                                  *(uint8_t*)result_11 = (uint8_t)r13_4;
140017ed6                                                  goto label_140017943;
140018261                                              }
14001803f                                          }
14001803f                                          else
14001803f                                          {
140018045                                          label_140018045:
140018045                                              r15_2 = rdi_7;
140018048                                              rdi_7 = r12_2;
14001803f                                          }
14001803f                                          
14001804b                                          var_b4_1 = 0x10;
140018053                                          result_8 = (char*)result_11 + 1;
140017ed3                                          *(uint8_t*)result_11 = (uint8_t)r13_4;
140017ed6                                          goto label_140017943;
14001827e                                      }
14001827e                                      
14001802d                                      if (r13_4 != 0x39)
14001802d                                      {
14001802f                                          r13_4 = rax_92 + 0x31;
140018033                                          var_80_1 = 0x20;
140018033                                          goto label_14001803f;
14001802d                                      }
14001802d                                      
14001805c                                  label_14001805c:
14001805c                                      result_8 = (char*)result_11 + 1;
140017e25                                  }
140017e25                                  else
140017e25                                  {
1400181d1                                      if (*(uint32_t*)((char*)rsi_3 + 0x14) <= 1
1400181d1                                          && !rsi_3[3])
1400181d1                                      {
1400181d9                                          if (rdx_50 > 0)
1400181d9                                              goto label_140017ffd;
1400181d9                                          
1400181df                                          result_8 = (char*)result_11 + 1;
1400181e3                                          r15_2 = rdi_7;
1400181e6                                          rdi_7 = r12_2;
140017ed3                                          *(uint8_t*)result_11 = (uint8_t)r13_4;
140017ed6                                          goto label_140017943;
1400181d1                                      }
1400181d1                                      
140017e3a                                      if (var_80_1 == 2)
140017e3a                                          goto label_140018045;
140017e3a                                      
140017e40                                      void* result_12 = result_11;
140017e40                                      
140017ea0                                      while (__cmp_D2A(r11_7, r12_2) > 0)
140017ea0                                      {
140017e56                                          *(uint8_t*)result_12 = (uint8_t)r13_4;
140017e5f                                          int64_t* rax_134 = __multadd_D2A(r12_2, 0xa, 0);
140017e5f                                          
140017e6f                                          if (rdi_7 == r12_2)
140017e6f                                              rdi_7 = rax_134;
140017e6f                                          
140017e79                                          int64_t* rax_135 = __multadd_D2A(rsi_3, 0xa, 0);
140017e81                                          result_12 += 1;
140017e87                                          rsi_3 = rax_135;
140017e8a                                          r12_2 = rax_134;
140017e92                                          r13_4 = __quorem_D2A(rax_135, r11_7) + 0x30;
140017ea0                                      }
140017ea0                                      
140017ead                                      result_11 = result_12;
140017eb3                                      result_8 = (char*)result_12 + 1;
140017eb3                                      
140017ebb                                      if (r13_4 != 0x39)
140017ebb                                      {
140017ec1                                          r15_2 = rdi_7;
140017ec8                                          rdi_7 = r12_2;
140017ecb                                          var_b4_1 = 0x20;
140017ed3                                          *(uint8_t*)result_11 = (r13_4 + 1);
140017ed6                                          goto label_140017943;
140017ebb                                      }
140017e25                                  }
140017807                              }
140017807                              else
140017807                              {
14001780d                                  result_8 = (char*)result_7 + 1;
140017813                                  result_10 = result_8;
140017813                                  
14001781d                                  if (rdx_50 <= 0 || var_80_1 == 2)
14001781d                                  {
140017827                                      *(uint8_t*)((char*)result_8 - 1) = (uint8_t)r13_4;
140017827                                      
140017832                                      if (var_4c == var_b0_1)
140017832                                      {
140017fc5                                          r15_2 = rdi_7;
140017fc8                                          r11_7 = var_c0;
140017fcd                                          rdi_7 = r12_2;
140017fd0                                          rbx = var_90_1;
140017fd5                                          break;
140017832                                      }
140017832                                      
140017853                                      rsi_3 = __multadd_D2A(rsi_3, 0xa, 0);
140017853                                      
140017859                                      if (rdi_7 == r12_2)
140017859                                      {
140017978                                          int64_t* rax_100 = __multadd_D2A(rdi_7, 0xa, 0);
14001797d                                          rdi_7 = rax_100;
140017980                                          r12_2 = rax_100;
140017859                                      }
140017859                                      else
140017859                                      {
14001786f                                          rdi_7 = __multadd_D2A(rdi_7, 0xa, 0);
140017877                                          r12_2 = __multadd_D2A(r12_2, 0xa, 0);
140017859                                      }
140017859                                      
140017881                                      result_7 = result_8;
140017884                                      rax_86 = var_4c + 1;
140017884                                      continue;
14001781d                                  }
14001781d                                  else
14001781d                                  {
140017f98                                      result_11 = result_7;
140017f9b                                      r11_7 = var_c0;
140017fa0                                      rbx = var_90_1;
140017fa0                                      
140017fa5                                      if (r13_4 != 0x39)
140017fa5                                      {
140017faf                                          r15_2 = rdi_7;
140017fb2                                          var_b4_1 = 0x20;
140017fba                                          rdi_7 = r12_2;
140017fbd                                          *(uint8_t*)result_11 = (uint8_t)r13_4 + 1;
140017fc0                                          goto label_140017943;
140017fa5                                      }
14001781d                                  }
140017807                              }
140017807                              
140018060                              r15_2 = rdi_7;
140018063                              result_5 = result_1;
140018068                              result_10 = result_8;
14001806b                              *(uint8_t*)result_11 = 0x39;
14001806f                              rdi_7 = r12_2;
140018072                              goto label_140017ca9;
14001788f                          }
1400179e2                      }
1400179e2                      else
1400179e2                      {
1400179eb                          if (r12_3)
1400179eb                              goto label_14001808e;
1400179eb                          
1400179f5                          var_a8_2 = var_90_1;
140017a00                          var_b0_1 = var_5c_1;
140017a08                      label_140017a08:
140017a08                          result_10 = result_1;
140017a0d                          int32_t rax_108 = 1;
140017a0d                          
140017a43                          while (true)
140017a43                          {
140017a43                              var_4c = rax_108;
140017a4a                              result_10 += 1;
140017a53                              r13_4 = __quorem_D2A(rsi_3, r11_5) + 0x30;
140017a57                              *(uint8_t*)((char*)result_10 - 1) = (uint8_t)r13_4;
140017a57                              
140017a63                              if (var_4c >= var_b0_1)
140017a63                                  break;
140017a63                              
140017a30                              rsi_3 = __multadd_D2A(rsi_3, 0xa, 0);
140017a3a                              rax_108 = var_4c + 1;
140017a43                          }
140017a43                          
140017a65                          r11_7 = r11_5;
140017a68                          r15_2 = nullptr;
1400179e2                      }
1400179e2                      
140017a71                      int32_t rax_113;
140017a71                      
140017a71                      if (var_80_1)
140017a71                      {
140017a7d                          if (var_80_1 == 2)
140017a7d                              goto label_140017df9;
140017a7d                          
140017a86                          if (*(uint32_t*)((char*)rsi_3 + 0x14) > 1)
140017a86                              goto label_140017c99;
140017a86                          
140017a8c                          rax_113 = rsi_3[3];
140017a8c                          
140017a91                          if (rax_113)
140017a91                              goto label_140017c99;
140017a91                          
140017a91                          goto label_140017a99;
140017a71                      }
140017a71                      
140017dc7                      int64_t* rax_132 = __lshift_D2A(rsi_3, 1);
140017dd4                      rsi_3 = rax_132;
140017dd7                      int32_t rax_133 = __cmp_D2A(rax_132, r11_7);
140017dd7                      
140017def                      if (rax_133 > 0 || (!rax_133 && r13_4 & 1))
140017def                      {
140017c99                      label_140017c99:
140017c99                          result_5 = result_1;
140017ca9                      label_140017ca9:
140017ca9                          
140017ca9                          while (true)
140017ca9                          {
140017ca9                              result_8 = result_10;
140017cac                              char rax_125 = *(uint8_t*)((char*)result_8 - 1);
140017cb0                              result_10 -= 1;
140017cb0                              
140017cb6                              if (rax_125 != 0x39)
140017cb6                              {
140017cbb                                  var_b4_1 = 0x20;
140017cc3                                  *(uint8_t*)result_10 = rax_125 + 1;
140017cc6                                  break;
140017cb6                              }
140017cb6                              
140017ca3                              if (result_5 == result_10)
140017ca3                              {
140017d4d                                  var_b4_1 = 0x20;
140017d55                                  var_a8_2 += 1;
140017d5a                                  *(uint8_t*)result_1 = 0x31;
140017d5d                                  break;
140017ca3                              }
140017ca9                          }
140017def                      }
140017def                      else
140017def                      {
140017df9                      label_140017df9:
140017df9                          var_b4_1 = 0x10;
140017df9                          
140017e01                          if (*(uint32_t*)((char*)rsi_3 + 0x14) <= 1)
140017e01                          {
140017e07                              rax_113 = rsi_3[3];
140017a99                          label_140017a99:
140017a99                              (uint8_t)rax_113 = rax_113;
140017aa2                              var_b4_1 = (uint32_t)(uint8_t)rax_113 << 4;
140017e01                          }
140017e01                          
140017abb                          do
140017abb                          {
140017ab0                              result_8 = result_10;
140017ab3                              result_10 -= 1;
140017abb                          } while (*(uint8_t*)result_10 == 0x30);
140017def                      }
140017def                      
140017943                  label_140017943:
140017943                      __Bfree_D2A(r11_7);
140017943                      
14001794b                      if (!rdi_7)
14001794b                      {
140017ccb                          result = result_1;
140017cd0                          result_1 = result_8;
14001794b                      }
14001794b                      else
14001794b                      {
140017959                          if (r15_2 && r15_2 != rdi_7)
14001795e                              __Bfree_D2A(r15_2);
14001795e                          
140017963                          result = result_1;
140017968                          result_1 = result_8;
1400173a9                          __Bfree_D2A(rdi_7);
14001794b                      }
140017329                  }
140017329                  else
140017329                  {
140017336                  label_140017336:
140017336                      int64_t rax_55 = (int64_t)var_90_1;
14001733e                      zmm2 = (uint128_t)*(uint64_t*)(&__tens_D2A + (rax_55 << 3));
14001733e                      
140017352                      if (r14 >= 0 || var_b0_1 > 0)
140017352                      {
140017b9a                          var_4c = 1;
140017ba5                          char* result_9 = result_1;
140017baa                          zmm0_3 = (uint128_t)rax_20;
140017bb7                          (uint64_t)zmm1_3 = (uint64_t)zmm0_3 / (uint64_t)zmm2;
140017bbb                          result_3 = &result_9[1];
140017bbf                          int32_t rcx_54 = (int32_t)(uint64_t)zmm1_3;
140017bc7                          (uint64_t)zmm1_3 = (double)rcx_54;
140017bce                          *(uint8_t*)result_9 = (uint8_t)rcx_54 + 0x30;
140017bd4                          (uint64_t)zmm1_3 = (uint64_t)zmm1_3 * (uint64_t)zmm2;
140017bdb                          var_a8_2 = var_90_1 + 1;
140017bdf                          (uint64_t)zmm0_3 = (uint64_t)zmm0_3 - (uint64_t)zmm1_3;
140017be3                          zmm1_3 = {0};
140017be7                          (uint64_t)zmm0_3 - (uint64_t)zmm1_3;
140017be7                          
140017bed                          if (FCMP_UO((uint64_t)zmm0_3, (uint64_t)zmm1_3)
140017bed                              || !((uint64_t)zmm0_3 == (uint64_t)zmm1_3))
140017bed                          {
140017bfb                              zmm3 = (int64_t){0};
140017bfb                              
140017c48                              while (true)
140017c48                              {
140017c48                                  int32_t rdx_63 = var_4c;
140017c48                                  
140017c55                                  if (rdx_63 == var_b0_1)
140017c55                                      break;
140017c55                                  
140017c08                                  (uint64_t)zmm0_3 = (uint64_t)zmm0_3 * 0x4024000000000000;
140017c0f                                  result_3 += 1;
140017c13                                  var_4c = rdx_63 + 1;
140017c1e                                  (uint64_t)zmm1_3 = (uint64_t)zmm0_3 / (uint64_t)zmm2;
140017c22                                  rcx_54 = (int32_t)(uint64_t)zmm1_3;
140017c2a                                  (uint64_t)zmm1_3 = (double)rcx_54;
140017c31                                  *(uint8_t*)((char*)result_3 - 1) =
140017c31                                      (uint8_t)rcx_54 + 0x30;
140017c34                                  (uint64_t)zmm1_3 = (uint64_t)zmm1_3 * (uint64_t)zmm2;
140017c38                                  (uint64_t)zmm0_3 = (uint64_t)zmm0_3 - (uint64_t)zmm1_3;
140017c3c                                  (uint64_t)zmm0_3 - zmm3;
140017c3c                                  
140017c40                                  if (!FCMP_UO((uint64_t)zmm0_3, zmm3))
140017c40                                  {
140017c42                                      if ((uint64_t)zmm0_3 == zmm3)
140017c42                                          goto label_140017dab;
140017c40                                  }
140017c48                              }
140017c48                              
140017c5d                              if (!var_80_1)
140017c5d                              {
14001809c                                  (uint64_t)zmm0_3 = (uint64_t)zmm0_3 + (uint64_t)zmm0_3;
1400180a0                                  rdx_33 = *(uint8_t*)((char*)result_3 - 1);
1400180a0                                  
1400180a8                                  if ((uint64_t)zmm0_3 > (uint64_t)zmm2)
1400180a8                                  {
140018245                                      result = result_1;
14001824a                                      result_4 = result_3;
14001824d                                      rdi_4 = var_90_1;
140017190                                  label_140017190:
140017190                                      char rdx_34;
140017190                                      
140017190                                      while (true)
140017190                                      {
140017190                                          result_3 = (char*)result_4 - 1;
140017190                                          
140017197                                          if (rdx_33 != 0x39)
140017197                                          {
140017199                                              result_1 = result_4;
14001719e                                              rdx_34 = rdx_33 + 1;
14001719e                                              break;
140017197                                          }
140017197                                          
140017183                                          if (result == result_3)
140017183                                          {
140017fda                                              result_1 = result_4;
140017fdf                                              rdi_4 += 1;
140017fe2                                              rdx_34 = 0x31;
140017fe7                                              break;
140017183                                          }
140017183                                          
140017189                                          rdx_33 = *(uint8_t*)((char*)result_3 - 1);
14001718d                                      label_14001718d:
14001718d                                          result_4 = result_3;
140017190                                      }
140017190                                      
1400171a1                                      *(uint8_t*)result_3 = rdx_34;
1400171a6                                      var_a8_2 = rdi_4 + 1;
1400171aa                                      var_b4_1 = 0x20;
1400180a8                                  }
1400180a8                                  else
1400180a8                                  {
1400180ae                                      (uint64_t)zmm0_3 - (uint64_t)zmm2;
1400180b2                                      result = result_1;
1400180b7                                      rdi_4 = var_90_1;
1400180b7                                      
1400180bd                                      if (!FCMP_UO((uint64_t)zmm0_3, (uint64_t)zmm2)
1400180bd                                          && !((uint64_t)zmm0_3 != (uint64_t)zmm2))
1400180bd                                      {
1400180bf                                          (uint8_t)rcx_54 &= 1;
1400180bf                                          
1400180c2                                          if ((uint8_t)rcx_54)
1400180c2                                              goto label_14001718d;
1400180bd                                      }
1400180bd                                      
1400180c8                                      var_b4_1 = 0x10;
1400180db                                  label_1400180db:
1400180db                                      void* result_6;
1400180db                                      
1400180db                                      do
1400180db                                      {
1400180d0                                          result_6 = result_3;
1400180d7                                          result_3 -= 1;
1400180db                                      } while (*(uint8_t*)((char*)result_6 - 1) == 0x30);
1400180db                                      
1400180e0                                      result_1 = result_6;
1400180e5                                      var_a8_2 = rdi_4 + 1;
1400180a8                                  }
140017c5d                              }
140017c5d                              else
140017c5d                              {
140017c66                                  if (var_80_1 == 1)
140017c66                                  {
1400181b7                                      rdx_33 = *(uint8_t*)((char*)result_3 - 1);
1400181bb                                      result_4 = result_3;
1400181be                                      result = result_1;
1400181c3                                      rdi_4 = var_90_1;
1400181c7                                      goto label_140017190;
140017c66                                  }
140017c66                                  
140017c6c                                  result = result_1;
140017c71                                  var_b4_1 = 0x10;
140017c79                                  result_1 = result_3;
140017c5d                              }
140017bed                          }
140017bed                          else
140017bed                          {
140017dab                          label_140017dab:
140017dab                              result = result_1;
140017db0                              result_1 = result_3;
140017bed                          }
140017352                      }
140017352                      else
140017352                      {
140017358                          if (var_b0_1)
140017358                          {
140017667                          label_140017667:
140017667                              r11_5 = nullptr;
14001766a                              rdi_7 = nullptr;
14001766f                          label_14001766f:
14001766f                              result = result_1;
140017674                              var_b4_1 = 0x10;
14001767c                              var_a8_2 = -(r14);
140017358                          }
140017358                          else
140017358                          {
14001735e                              (uint64_t)zmm2 = (uint64_t)zmm2 * 5.0;
14001735e                              
14001736f                              if ((uint64_t)zmm2 >= rax_20)
14001736f                                  goto label_140017667;
14001736f                              
140017375                              result = result_1;
14001737d                              r11_5 = nullptr;
140017380                              var_a8_2 = (uint32_t)rax_55 + 2;
140017384                              rdi_7 = nullptr;
140017386                          label_140017386:
140017386                              result_1 += 1;
14001738c                              *(uint8_t*)result = 0x31;
140017391                              var_b4_1 = 0x20;
140017358                          }
140017358                          
14001739c                          __Bfree_D2A(r11_5);
14001739c                          
1400173a4                          if (rdi_7)
1400173a9                              __Bfree_D2A(rdi_7);
140017352                      }
140017329                  }
140017225              }
140017225              else
140017225              {
14001722b                  r14 = 0;
14001722e                  (uint32_t)var_88 = 1;
140017236                  var_5c_1 = 0xffffffff;
140017241                  var_b0_1 = 0xffffffff;
140016feb              label_140016feb:
140016feb                  int32_t rax_37 = 2;
140016feb                  
140016ff2                  if (var_80_1 >= 0)
140016ff2                      rax_37 = var_80_1;
140016ff2                  
140016ffa                  var_80_1 = rax_37;
140016ffa                  
140016ffe                  if (!(rdi & 8))
140016ffe                      goto label_140017445;
140016ffe                  
14001700b                  var_80_1 = 3 - rax_37;
14001701a              label_14001701a:
14001701a                  bool r8_7 = var_b0_1 <= 0xe & var_60_1;
14001701a                  
140017030                  if (!r8_7 || var_90_1 | var_80_1)
140017022                      goto label_140017445;
140017022                  
14001703d                  var_4c = 0;
140017048                  zmm0_3 = (uint128_t)rax_20;
140017061                  uint64_t rax_42;
140017061                  int32_t r11_4;
140017061                  
140017061                  if (var_78_1 && 0x3ff0000000000000 > (uint64_t)zmm0_3)
140017061                  {
140017edd                      if (!var_b0_1)
140017edd                      {
1400173e5                          (uint64_t)zmm1_3 = (uint64_t)zmm0_3 + (uint64_t)zmm0_3;
1400173e9                          (uint64_t)zmm1_3 = (uint64_t)zmm1_3 + 7.0;
1400173f1                          int64_t rax_59 = (uint64_t)zmm1_3;
140017409                          rax_42 = (uint64_t)(uint32_t)rax_59
140017409                              | (uint64_t)((int32_t)(rax_59 >> 0x20) - 0x3400000) << 0x20;
14001740c                      label_14001740c:
14001740c                          (uint64_t)zmm0_3 = (uint64_t)zmm0_3 - 5.0;
140017414                          zmm1_3 = (uint128_t)rax_42;
140017414                          
14001741d                          if ((uint64_t)zmm0_3 > (uint64_t)zmm1_3)
14001741d                          {
140017f7d                              result = result_1;
140017f82                              var_a8_2 = 2;
140017f8a                              r11_5 = nullptr;
140017f8d                              rdi_7 = nullptr;
140017f8f                              goto label_140017386;
14001741d                          }
14001741d                          
14001742f                          if (__xorpd_xmmxuq_memxuq(zmm1_3, data_140022150)
14001742f                                  > (uint64_t)zmm0_3)
14001742f                              goto label_140017667;
140017edd                      }
140017edd                      else
140017edd                      {
140017ee3                          r11_4 = var_5c_1;
140017ee3                          
140017eee                          if (r11_4 > 0)
140017eee                          {
140017ef4                              (uint64_t)zmm0_3 = (uint64_t)zmm0_3 * 10.0;
140017efc                              rdi_4 = -1;
140017f09                              (uint64_t)zmm1_3 = 0x4008000000000000 * (uint64_t)zmm0_3;
140017f0d                              r10_5 = (uint64_t)zmm0_3;
140017f12                              (uint64_t)zmm1_3 = (uint64_t)zmm1_3 + 7.0;
140017f1a                              int64_t rax_138 = (uint64_t)zmm1_3;
140017f32                              rax_42 = (uint64_t)(uint32_t)rax_138
140017f32                                  | (uint64_t)((int32_t)(rax_138 >> 0x20) - 0x3400000)
140017f32                                  << 0x20;
140017f35                              goto label_1400170ac;
140017eee                          }
140017edd                      }
140017edd                      
140017435                  label_140017435:
140017435                      var_80_1 = 0;
140017445                  label_140017445:
140017445                      
140017448                      if (var_a8_1 >= 0 && var_90_1 <= arg1[5])
140017448                          goto label_140017336;
140017448                      
140017448                      goto label_140017453;
140017061                  }
140017061                  
14001706b                  (uint64_t)zmm1_3 = (uint64_t)zmm0_3 + (uint64_t)zmm0_3;
14001706f                  (uint64_t)zmm1_3 = (uint64_t)zmm1_3 + 7.0;
140017077                  int64_t rax_40 = (uint64_t)zmm1_3;
14001708f                  rax_42 = (uint64_t)(uint32_t)rax_40
14001708f                      | (uint64_t)((int32_t)(rax_40 >> 0x20) - 0x3400000) << 0x20;
14001708f                  
140017098                  if (!var_b0_1)
140017098                      goto label_14001740c;
140017098                  
14001709e                  r11_4 = var_b0_1;
1400170a3                  rdi_4 = 0;
1400170ac              label_1400170ac:
1400170ac                  zmm2 = (uint128_t)rax_42;
1400170b7                  zmm3 = *(uint64_t*)(&__tens_D2A + ((int64_t)(r11_4 - 1) << 3));
1400170b7                  
1400170c2                  if (!(uint32_t)var_88)
1400170c2                  {
14001768a                      zmm0_3 = (uint128_t)r10_5;
14001768f                      result_3 = result_1;
140017694                      var_4c = 1;
14001769f                      uint128_t zmm4_2;
14001769f                      (uint64_t)zmm4_2 = (uint64_t)zmm2 * zmm3;
1400176ab                      zmm1_3 = zmm0_3;
1400176af                      bool r10_7 = false;
1400176af                      
1400176c9                      while (true)
1400176c9                      {
1400176c9                          int32_t rdx_47 = (int32_t)(uint64_t)zmm1_3;
1400176c9                          
1400176cf                          if (rdx_47)
1400176cf                          {
1400176d9                              r10_7 = r8_7;
1400176dc                              (uint64_t)zmm1_3 = (uint64_t)zmm1_3 - (double)rdx_47;
1400176cf                          }
1400176cf                          
1400176e0                          result_3 += 1;
1400176e4                          rdx_33 = (uint8_t)rdx_47 + 0x30;
1400176e7                          *(uint8_t*)((char*)result_3 - 1) = rdx_33;
1400176ea                          int32_t rbp_8 = var_4c;
1400176ea                          
1400176f4                          if (rbp_8 == r11_4)
1400176f4                              break;
1400176f4                          
1400176b8                          (uint64_t)zmm1_3 = (uint64_t)zmm1_3 * 0x4024000000000000;
1400176bc                          r10_7 = r8_7;
1400176c2                          var_4c = rbp_8 + 1;
1400176c9                      }
1400176c9                      
1400176f9                      if (!r10_7)
14001812d                          zmm1_3 = zmm0_3;
14001812d                      
1400176ff                      zmm0_3 = 0x3fe0000000000000;
14001770b                      (uint64_t)zmm2 = (uint64_t)zmm4_2 + (uint64_t)zmm0_3;
14001770b                      
140017713                      if ((uint64_t)zmm1_3 > (uint64_t)zmm2)
140017713                      {
140018120                          result = result_1;
140018125                          result_4 = result_3;
140018128                          goto label_140017190;
140017713                      }
140017713                      
140017719                      (uint64_t)zmm0_3 = (uint64_t)zmm0_3 - (uint64_t)zmm4_2;
140017719                      
140017721                      if ((uint64_t)zmm0_3 > (uint64_t)zmm1_3)
140017721                      {
140018197                          (uint64_t)zmm1_3 - 0.0;
1400181a0                          result = result_1;
1400181a5                          int32_t rdx_79;
1400181a5                          (uint8_t)rdx_79 = FCMP_UO((uint64_t)zmm1_3, 0.0);
1400181a5                          
1400181a8                          if ((uint64_t)zmm1_3 != 0.0)
1400181a8                              rdx_79 = 1;
1400181a8                          
1400181ae                          var_b4_1 = rdx_79 << 4;
1400181b2                          goto label_1400180db;
140017721                      }
140017721                      
14001772d                      if (var_a8_1 < 0)
14001772d                      {
14001822b                          var_80_1 = 0;
140018233                          rdi_7 = nullptr;
140018235                          rbp_3 = var_7c_1;
140018239                          var_74_2 = var_98_1;
140018240                          goto label_1400174fa;
14001772d                      }
14001772d                      
140017738                      var_80_1 = 0;
140017738                      
140017743                      if (arg1[5] >= 0)
140017743                          goto label_140017336;
140017743                      
140017743                      goto label_140017754;
1400170c2                  }
1400170c2                  
1400170c8                  int32_t rdx_27 = (int32_t)(uint64_t)zmm0_3;
1400170d9                  (uint64_t)zmm1_3 = 0x3fe0000000000000 / zmm3;
1400170dd                  void* result_2 = (char*)result_1 + 1;
1400170e1                  (uint64_t)zmm1_3 = (uint64_t)zmm1_3 - (uint64_t)zmm2;
1400170e9                  (uint64_t)zmm2 = (double)rdx_27;
1400170f0                  *(uint8_t*)result_1 = (uint8_t)rdx_27 + 0x30;
1400170f2                  (uint64_t)zmm0_3 = (uint64_t)zmm0_3 - (uint64_t)zmm2;
1400170f2                  
1400170fa                  if (!((uint64_t)zmm1_3 > (uint64_t)zmm0_3))
1400170fa                  {
140017108                      zmm3 = 10.0;
140017108                      
140017162                      while (true)
140017162                      {
140017162                          (uint64_t)zmm2 = 0x3ff0000000000000 - (uint64_t)zmm0_3;
140017162                          
14001716a                          if (!((uint64_t)zmm1_3 <= (uint64_t)zmm2))
14001716a                          {
14001716c                              rdx_33 = *(uint8_t*)((char*)result_2 - 1);
140017170                              result_4 = result_2;
140017173                              result = result_1;
140017178                              break;
14001716a                          }
14001716a                          
140017122                          bool cond:28_1 = var_4c + 1 >= r11_4;
140017125                          var_4c += 1;
140017125                          
14001712c                          if (cond:28_1)
14001712c                              goto label_140017435;
14001712c                          
140017132                          (uint64_t)zmm0_3 = (uint64_t)zmm0_3 * zmm3;
14001713a                          result_2 += 1;
14001713e                          (uint64_t)zmm1_3 = (uint64_t)zmm1_3 * zmm3;
140017142                          int32_t rdx_31 = (int32_t)(uint64_t)zmm0_3;
140017146                          (uint64_t)zmm2 = (double)rdx_31;
14001714d                          *(uint8_t*)((char*)result_2 - 1) = (uint8_t)rdx_31 + 0x30;
140017150                          (uint64_t)zmm0_3 = (uint64_t)zmm0_3 - (uint64_t)zmm2;
140017150                          
140017158                          if ((uint64_t)zmm1_3 > (uint64_t)zmm0_3)
140017158                              goto label_1400180f4;
140017162                      }
140017162                      
14001716a                      goto label_140017190;
1400170fa                  }
1400170fa                  
1400180f4              label_1400180f4:
1400180f4                  (uint64_t)zmm0_3 - 0.0;
1400180fd                  result = result_1;
140018102                  result_1 = result_2;
140018107                  int32_t rdx_77;
140018107                  (uint8_t)rdx_77 = FCMP_UO((uint64_t)zmm0_3, 0.0);
140018107                  
14001810a                  if ((uint64_t)zmm0_3 != 0.0)
14001810a                      rdx_77 = 1;
14001810a                  
140018110                  var_a8_2 = rdi_4 + 1;
140018117                  var_b4_1 = rdx_77 << 4;
140017225              }
1400173b1              __Bfree_D2A(rsi_3);
1400173c4              *(uint8_t*)result_1 = 0;
1400173c7              *(uint32_t*)arg7 = var_a8_2;
1400173c7              
1400173d1              if (arg8)
1400173d3                  *(uint64_t*)arg8 = result_1;
1400173d3              
1400173da              *(uint32_t*)rbx |= var_b4_1;
140016e83              return result;
140016bbe          }
140016bbe          
140016e06          if (rax_5 != 4)
140016e83              return nullptr;
140016e83          
140016e0d          r8_4 = 3;
140016e13          rdx_16 = arg8;
140016e18          rcx_8 = &data_1400220e9;
140016e1f          *(uint32_t*)arg7 = 0xffff8000;
140016baf      }
140016baf      
140016e38      /* tailcall */
140016e38      return __nrv_alloc_D2A(rcx_8, rdx_16, r8_4);
140016b50  }

140016c4a                                66 0f 1f 44 00 00                                                            f..D..
140016df8                                                                          0f 1f 84 00 00 00 00 00                          ........
140016e3d                                                                                         0f 1f 00                               ...
140016e84              0f 1f 40 00                                                                              ..@.
140016eaa                                66 0f 1f 44 00 00                                                            f..D..
140016ebc                                                                                      0f 1f 40 00                              ..@.
140016ee4              0f 1f 40 00                                                                              ..@.
140017112                                                        66 0f 1f 44 00 00                                            f..D..
14001717a                                                                                66 0f 1f 44 00 00                            f..D..
1400171b7                                                                       66 0f 1f 84 00 00 00 00 00                         f........
14001724e                                            66 90                                                                f.
14001726f                                               90                                                                 .
1400172d6                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
140017649                             0f 1f 80 00 00 00 00                                                           .......
1400176b4                                                              0f 1f 40 00                                              ..@.
140017766                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
1400177e2        66 0f 1f 44 00 00                                                                            f..D..
140017972                                                        66 0f 1f 44 00 00                                            f..D..
140017988                          0f 1f 84 00 00 00 00 00                                                          ........
140017a1c                                                                                      0f 1f 40 00                              ..@.
140017ac2        66 0f 1f 44 00 00                                                                            f..D..
140017b05                 0f 1f 00                                                                               ...
140017b15                                                                 0f 1f 00                                               ...
140017b4a                                66 0f 1f 44 00 00                                                            f..D..
140017c01     0f 1f 80 00 00 00 00                                                                           .......
140017d42        66 0f 1f 44 00 00                                                                            f..D..
140017e0f                                               90                                                                 .
140017e4d                                         0f 1f 00                                                               ...
1400182b8                                                                          90 90 90 90 90 90 90 90                          ........

1400182c0    void __rshift_D2A(void* arg1, int32_t arg2)

1400182c0  {
1400182c6      int64_t rbx = (int64_t)*(uint32_t*)((char*)arg1 + 0x14);
1400182cf      int32_t rbp_1 = arg2 >> 5;
1400182cf      
1400182d4      if ((uint32_t)rbx > rbp_1)
1400182d4      {
1400182f4          int64_t rbp_2 = (int64_t)rbp_1;
1400182f7          int32_t rdx = arg2 & 0x1f;
1400182fa          void* r11_1 = (char*)arg1 + 0x18 + (rbx << 2);
1400182fe          void* rsi_1 = (char*)arg1 + 0x18 + (rbp_2 << 2);
140018302          void* rax_4;
140018302          
140018302          if (!rdx)
140018302          {
14001836b              int32_t* rdi_2 = (char*)arg1 + 0x18;
14001836b              
14001836e              if (rsi_1 < r11_1)
14001836e              {
14001837c                  do
14001837c                  {
140018378                      *(uint32_t*)rdi_2 = *(uint32_t*)rsi_1;
140018378                      rdi_2 = &rdi_2[1];
140018378                      rsi_1 += 4;
14001837c                  } while (rsi_1 < r11_1);
14001837c                  
140018381                  rax_4 = (char*)arg1 + 0x18 + ((rbx - rbp_2) << 2);
140018381                  goto label_140018388;
14001836e              }
14001836e              
1400182d6              *(uint32_t*)((char*)arg1 + 0x14) = 0;
140018302          }
140018302          else
140018302          {
140018307              void* r8_1 = (char*)rsi_1 + 4;
140018314              uint32_t r9_2 = *(uint32_t*)rsi_1 >> (uint8_t)rdx;
140018314              
14001831a              if (r8_1 < r11_1)
14001831a              {
140018320                  void* rsi_2 = (char*)arg1 + 0x18;
140018320                  
140018349                  do
140018349                  {
140018328                      int32_t rax_1 = *(uint32_t*)r8_1;
14001832d                      rsi_2 += 4;
140018331                      r8_1 += 4;
14001833c                      *(uint32_t*)((char*)rsi_2 - 4) =
14001833c                          rax_1 << (0x20 - (uint8_t)rdx) | r9_2;
140018343                      r9_2 = *(uint32_t*)((char*)r8_1 - 4) >> (uint8_t)rdx;
140018349                  } while (r8_1 < r11_1);
140018349                  
140018351                  rax_4 = (char*)arg1 + 0x18 + ((rbx - rbp_2) << 2) - 4;
140018356                  *(uint32_t*)rax_4 = r9_2;
140018356                  
140018359                  if (!r9_2)
140018359                      goto label_140018388;
140018359                  
140018359                  goto label_14001835b;
14001831a              }
14001831a              
1400183a3              *(uint32_t*)((char*)arg1 + 0x18) = r9_2;
1400183a3              
1400183a7              if (!r9_2)
1400182d6                  *(uint32_t*)((char*)arg1 + 0x14) = 0;
1400183a7              else
1400183a7              {
1400183ad                  rax_4 = (char*)arg1 + 0x18;
14001835b              label_14001835b:
14001835b                  rax_4 += 4;
140018388              label_140018388:
140018388                  int32_t rax = (int32_t)(((char*)rax_4 - ((char*)arg1 + 0x18)) >> 2);
14001838e                  *(uint32_t*)((char*)arg1 + 0x14) = rax;
14001838e                  
140018392                  if (rax)
14001839e                      return;
1400183a7              }
140018302          }
1400182d4      }
1400182d4      else
1400182d6          *(uint32_t*)((char*)arg1 + 0x14) = 0;
1400182d6      
1400182de      *(uint32_t*)((char*)arg1 + 0x18) = 0;
1400182c0  }

1400182ed                                         0f 1f 00                                                               ...
140018361     0f 1f 80 00 00 00 00                                                                           .......
14001839f                                                                                               90                                 .
1400183b2                                                        66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                    ff............

1400183c0    uint64_t __trailz_D2A(void* arg1)

1400183c0  {
1400183c4      void* rax = (char*)arg1 + 0x18;
1400183c8      void* rcx = (char*)rax + ((int64_t)*(uint32_t*)((char*)arg1 + 0x14) << 2);
1400183cc      int32_t rdx = 0;
1400183cc      
1400183d1      if (rax < rcx)
1400183d1      {
1400183e2          do
1400183e2          {
1400183ea              if (*(uint32_t*)rax)
1400183ea              {
1400183ef                  if (rax < rcx)
1400183ef                  {
1400183f1                      uint64_t rflags_1;
1400183f1                      int32_t temp0_1;
1400183f1                      temp0_1 = __bsf_gprv_memv(*(uint32_t*)rax);
1400183f4                      rdx += temp0_1;
1400183ef                  }
1400183ef                  
1400183ef                  break;
1400183ea              }
1400183ea              
1400183d8              rax += 4;
1400183dc              rdx += 0x20;
1400183e2          } while (rax < rcx);
1400183d1      }
1400183d1      
1400183f8      return (uint64_t)rdx;
1400183c0  }

1400183d5                                                                 0f 1f 00                                               ...
1400183f9                                                                             90 90 90 90 90 90 90                           .......

140018400    int64_t dtoa_lock(int32_t arg1)

140018400  {
140018407      int32_t dtoa_CS_init_1 = dtoa_CS_init;
140018407      
140018412      if (dtoa_CS_init_1 != 2)
140018412      {
14001841a          if (dtoa_CS_init_1)
14001841a          {
14001841f              if (dtoa_CS_init_1 != 1)
140018452                  return dtoa_CS_init_1;
140018452              
140018440          label_140018440:
140018440              
140018440              do
140018440              {
140018435                  Sleep(1);
140018437                  dtoa_CS_init_1 = dtoa_CS_init;
140018440              } while (dtoa_CS_init_1 == 1);
140018440              
140018440              goto label_140018442;
14001841a          }
14001841a          
14001845d          int32_t dtoa_CS_init_2 = dtoa_CS_init;
14001845d          dtoa_CS_init = 1;
14001845d          
140018465          if (!dtoa_CS_init_2)
140018465          {
140018478              InitializeCriticalSection(&dtoa_CritSec);
14001847e              InitializeCriticalSection(&data_140027ca8);
140018487              atexit(dtoa_lock_cleanup);
14001848c              dtoa_CS_init = 2;
140018465          }
140018465          else if (dtoa_CS_init_2 == 2)
14001848c              dtoa_CS_init = 2;
1400184ba          else
1400184ba          {
1400184bc              dtoa_CS_init_1 = dtoa_CS_init;
1400184bc              
1400184c5              if (dtoa_CS_init_1 == 1)
1400184c5                  goto label_140018440;
1400184c5              
140018442          label_140018442:
140018442              
140018445              if (dtoa_CS_init_1 != 2)
140018452                  return dtoa_CS_init_1;
1400184ba          }
140018412      }
140018412      
1400184a8      /* tailcall */
1400184a8      return EnterCriticalSection(&dtoa_CritSec + (int64_t)arg1 * 0x28);
140018400  }

140018453                                                           0f 1f 44 00 00                                             ..D..
1400184af                                               90                                                                 .
1400184d9                                                                             0f 1f 80 00 00 00 00                           .......

1400184e0    int64_t dtoa_lock_cleanup()

1400184e0  {
1400184ea      int32_t dtoa_CS_init_1 = dtoa_CS_init;
1400184ea      dtoa_CS_init = 3;
1400184ea      
1400184f3      if (dtoa_CS_init_1 != 2)
1400184fa          return dtoa_CS_init_1;
1400184fa      
14001850e      DeleteCriticalSection(&dtoa_CritSec);
14001851f      /* tailcall */
14001851f      return DeleteCriticalSection(&data_140027ca8);
1400184e0  }

1400184fb                                                                                   0f 1f 44 00 00                             ..D..
140018522        66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                                                    ff............

140018530    int64_t* __Balloc_D2A(int32_t arg1)

140018530  {
14001853a      dtoa_lock(0);
140018542      int64_t* _.data_1;
140018542      uint64_t rcx_4;
140018542      int32_t rsi_1;
140018542      
140018542      if (arg1 > 9)
140018542      {
14001858f          rsi_1 = 1 << (uint8_t)arg1;
1400185a0          rcx_4 = (uint64_t)(uint32_t)((((int64_t)rsi_1 << 2) + 0x23) >> 3);
1400185a6      label_1400185a6:
1400185a6          _.data_1 = malloc(rcx_4 << 3);
1400185a6          
1400185ae          if (_.data_1)
1400185ae              goto label_1400185b0;
140018542      }
140018542      else
140018542      {
14001854b          int64_t rcx = (int64_t)arg1;
14001854e          _.data_1 = *(uint64_t*)(&freelist + (rcx << 3));
14001854e          
140018555          if (!_.data_1)
140018555          {
1400185ee              rsi_1 = 1 << (uint8_t)arg1;
1400185fd              _.data_1 = _.data;
140018604              rcx_4 = (((int64_t)(rsi_1 + 9) << 2) + -ffffffffffffffff) >> 3;
140018604              
14001861c              if ((((char*)_.data_1 - &private_mem) >> 3) + rcx_4 > 0x120)
14001861c                  goto label_1400185a6;
14001861c              
140018622              _.data = &_.data_1[rcx_4];
1400185b0          label_1400185b0:
1400185b0              bool cond:0_1 = dtoa_CS_init == 2;
1400185c3              _.data_1[1] = _mm_unpacklo_epi32((uint128_t)arg1, (uint64_t)rsi_1)[0];
1400185c3              
1400185c8              if (cond:0_1)
1400185c8              {
140018577                  LeaveCriticalSection(&dtoa_CritSec);
1400185ca                  _.data_1[2] = 0;
1400185c8              }
1400185c8              else
1400185ca                  _.data_1[2] = 0;
140018555          }
140018555          else
140018555          {
14001855e              bool cond:1_1 = dtoa_CS_init != 2;
140018565              *(uint64_t*)(&freelist + (rcx << 3)) = *(uint64_t*)_.data_1;
140018565              
140018569              if (cond:1_1)
1400185ca                  _.data_1[2] = 0;
140018569              else
140018569              {
140018577                  LeaveCriticalSection(&dtoa_CritSec);
1400185ca                  _.data_1[2] = 0;
140018569              }
140018555          }
140018542      }
1400185d8      return _.data_1;
140018530  }

140018584              0f 1f 40 00                                                                              ..@.
1400185d9                                                                             0f 1f 80 00 00 00 00                           .......
14001862b                                   0f 1f 44 00 00                                                             ..D..

140018630    void __Bfree_D2A(int64_t* arg1)

140018630  {
14001863b      if (!arg1)
14001863b          return;
14001863b      
140018641      if (arg1[1] > 9)
140018648          /* tailcall */
140018648          return free(arg1);
140018648      
140018652      dtoa_lock(0);
140018657      int64_t rdx_2 = (int64_t)arg1[1];
140018662      bool cond:1_1 = dtoa_CS_init == 2;
140018669      int64_t rcx_1 = *(uint64_t*)(&freelist + (rdx_2 << 3));
14001866d      *(uint64_t*)(&freelist + (rdx_2 << 3)) = arg1;
140018671      *(uint64_t*)arg1 = rcx_1;
140018671      
140018674      if (cond:1_1)
14001868c          /* tailcall */
14001868c          return LeaveCriticalSection(&dtoa_CritSec);
140018630  }

14001864d                                         0f 1f 00                                                               ...
14001867c                                                                                      0f 1f 40 00                              ..@.
140018693                                                           66 66 2e 0f 1f 84 00 00 00 00 00 66 90                     ff.........f.

1400186a0    int64_t* __multadd_D2A(int64_t* arg1, int32_t arg2, int32_t arg3)

1400186a0  {
1400186a8      int32_t i = *(uint32_t*)((char*)arg1 + 0x14);
1400186ae      int64_t rsi = (int64_t)arg3;
1400186b4      int64_t rcx = 0;
1400186b4      
1400186dc      do
1400186dc      {
1400186c8          int64_t rax_3 =
1400186c8              (uint64_t)*(uint32_t*)((char*)arg1 + (rcx << 2) + 0x18) * (int64_t)arg2
1400186c8              + rsi;
1400186ce          *(uint32_t*)((char*)arg1 + (rcx << 2) + 0x18) = (uint32_t)rax_3;
1400186d2          rcx += 1;
1400186d6          rsi = rax_3 >> 0x20;
1400186dc      } while (i > (uint32_t)rcx);
1400186dc      
1400186e1      int64_t* result = arg1;
1400186e1      
1400186e4      if (rsi)
1400186e4      {
1400186e9          if (*(uint32_t*)((char*)arg1 + 0xc) <= i)
1400186e9          {
140018716              int64_t* result_1 = __Balloc_D2A(arg1[1] + 1);
14001871e              result = result_1;
14001871e              
140018721              if (result_1)
140018721              {
140018737                  memcpy(&result_1[2], &arg1[2], 
140018737                      ((int64_t)*(uint32_t*)((char*)arg1 + 0x14) << 2) + 8);
14001873f                  int64_t* result_2 = result;
140018742                  __Bfree_D2A(arg1);
14001874d                  result = result_2;
140018750                  *(uint32_t*)((char*)result_2 + ((int64_t)i << 2) + 0x18) = (uint32_t)rsi;
140018754                  *(uint32_t*)((char*)result_2 + 0x14) = i + 1;
140018721              }
1400186e9          }
1400186e9          else
1400186e9          {
1400186f1              result = arg1;
1400186f4              *(uint32_t*)((char*)arg1 + ((int64_t)i << 2) + 0x18) = (uint32_t)rsi;
1400186f8              *(uint32_t*)((char*)arg1 + 0x14) = i + 1;
1400186e9          }
1400186e4      }
1400186e4      
140018706      return result;
1400186a0  }

140018707                       66 0f 1f 84 00 00 00 00 00                                                         f........
140018759                                                                             0f 1f 80 00 00 00 00                           .......

140018760    int64_t* __i2b_D2A(int32_t arg1)

140018760  {
140018769      dtoa_lock(0);
14001876e      int64_t* _.data_1 = data_140027c28;
14001876e      
140018778      if (!_.data_1)
140018778      {
1400187a8          _.data_1 = _.data;
1400187a8          
1400187cb          if ((((char*)_.data_1 - &private_mem) >> 3) + 5 <= 0x120)
1400187cb          {
140018814              _.data = &_.data_1[5];
1400187e3          label_1400187e3:
1400187e3              bool cond:1_1 = dtoa_CS_init != 2;
1400187ea              _.data_1[1] = 0x200000001;
1400187ea              
1400187ee              if (!cond:1_1)
1400187ee                  goto label_1400187fc;
1400187ee              
140018794              _.data_1[3] = arg1;
140018797              _.data_1[2] = 0x100000000;
1400187cb          }
1400187cb          else
1400187cb          {
1400187d2              _.data_1 = malloc(0x28);
1400187d2              
1400187da              if (_.data_1)
1400187da                  goto label_1400187e3;
1400187cb          }
140018778      }
140018778      else
140018778      {
14001877d          bool cond:0_1 = dtoa_CS_init == 2;
140018784          data_140027c28 = *(uint64_t*)_.data_1;
140018784          
14001878b          if (cond:0_1)
14001878b          {
1400187fc          label_1400187fc:
1400187fc              LeaveCriticalSection(&dtoa_CritSec);
140018794              _.data_1[3] = arg1;
140018797              _.data_1[2] = 0x100000000;
14001878b          }
14001878b          else
14001878b          {
140018794              _.data_1[3] = arg1;
140018797              _.data_1[2] = 0x100000000;
14001878b          }
140018778      }
140018778      
1400187a0      return _.data_1;
140018760  }

1400187a1     0f 1f 80 00 00 00 00                                                                           .......
140018809                             0f 1f 80 00 00 00 00                                                           .......
14001881d                                                                                         0f 1f 00                               ...

140018820    int64_t* __mult_D2A(void* arg1, void* arg2)

140018820  {
140018830      int64_t r13 = (int64_t)*(uint32_t*)((char*)arg1 + 0x14);
140018834      int64_t rbp = (int64_t)*(uint32_t*)((char*)arg2 + 0x14);
140018838      void* r12 = arg1;
14001883b      void* r15 = arg2;
14001883b      
140018841      if ((uint32_t)r13 >= (uint32_t)rbp)
140018841      {
140018843          int32_t rax_1 = (uint32_t)rbp;
140018845          r15 = arg1;
140018848          rbp = (int64_t)(uint32_t)r13;
14001884b          r12 = arg2;
14001884e          r13 = (int64_t)rax_1;
140018841      }
140018841      
140018851      int32_t i_1 = (int32_t)(rbp + r13);
14001885a      int32_t rcx = *(uint32_t*)((char*)r15 + 8);
14001885a      
14001885e      if (*(uint32_t*)((char*)r15 + 0xc) < i_1)
140018860          rcx += 1;
140018860      
140018863      int64_t* result = __Balloc_D2A(rcx);
140018863      
14001886e      if (result)
14001886e      {
140018874          void* r11_1 = &result[3];
14001887b          void* rsi_1 = (char*)r11_1 + ((int64_t)i_1 << 2);
14001887b          
140018882          if (r11_1 < rsi_1)
1400188a4              r11_1 = memset(r11_1, 0, (((char*)rsi_1 - result - 0x19) >> 2 << 2) + 4);
1400188a4          
1400188a7          void* r9_1 = (char*)r12 + 0x18;
1400188ac          void* r12_1 = (char*)r9_1 + (r13 << 2);
1400188b7          void* rbp_1 = (char*)r15 + 0x18 + (rbp << 2);
1400188b7          
1400188bb          if (r9_1 < r12_1)
1400188bb          {
1400188d6              void* r13_1 = (((char*)rbp_1 - r15 - 0x19) >> 2 << 2) + 4;
1400188d6              
1400188e3              if (rbp_1 < (char*)r15 + 0x19)
1400188e3                  r13_1 = 4;
1400188e3              
1400188f9              while (true)
1400188f9              {
1400188f9                  uint64_t r10_1 = (uint64_t)*(uint32_t*)r9_1;
1400188fc                  r9_1 += 4;
1400188fc                  
140018903                  if (!(uint32_t)r10_1)
140018903                  {
1400188f0                      r11_1 += 4;
1400188f0                      
1400188f7                      if (r9_1 >= r12_1)
1400188f7                          break;
140018903                  }
140018903                  else
140018903                  {
140018905                      void* rcx_2 = r11_1;
140018908                      void* rdx = (char*)r15 + 0x18;
14001890b                      uint64_t r8_2 = 0;
14001890b                      
140018935                      do
140018935                      {
140018910                          uint64_t rax_12 = (uint64_t)*(uint32_t*)rdx;
140018912                          rdx += 4;
140018916                          rcx_2 += 4;
140018925                          int64_t rax_15 = rax_12 * r10_1
140018925                              + (uint64_t)*(uint32_t*)((char*)rcx_2 - 4) + r8_2;
14001892b                          *(uint32_t*)((char*)rcx_2 - 4) = (uint32_t)rax_15;
14001892e                          r8_2 = rax_15 >> 0x20;
140018935                      } while (rdx < rbp_1);
140018935                      
140018937                      *(uint32_t*)((char*)r11_1 + r13_1) = (uint32_t)r8_2;
14001893b                      r11_1 += 4;
14001893b                      
140018942                      if (r9_1 >= r12_1)
140018942                          break;
140018903                  }
1400188f9              }
1400188bb          }
1400188bb          
140018946          if (i_1 > 0)
140018946          {
140018953              int32_t i;
140018953              
140018953              do
140018953              {
140018955                  int32_t rax_16 = *(uint32_t*)((char*)rsi_1 - 4);
140018958                  rsi_1 -= 4;
140018958                  
14001895e                  if (rax_16)
14001895e                      break;
14001895e                  
140018950                  i = i_1;
140018950                  i_1 -= 1;
140018953              } while (i != 1);
140018946          }
140018946          
140018960          *(uint32_t*)((char*)result + 0x14) = i_1;
14001886e      }
14001886e      
140018976      return result;
140018820  }

1400188e9                             0f 1f 80 00 00 00 00                                                           .......
14001894a                                66 0f 1f 44 00 00                                                            f..D..
140018977                                                                       66 0f 1f 84 00 00 00 00 00                         f........

140018980    int64_t* __pow5mult_D2A(int64_t* arg1, int32_t arg2)

140018980  {
14001898a      int64_t* rsi = arg1;
14001898f      int32_t rax_1 = arg2 & 3;
14001898f      
140018992      if (rax_1)
140018992      {
140018a72          int64_t* rax_6 =
140018a72              __multadd_D2A(arg1, *(uint32_t*)(&_.rdata + ((int64_t)(rax_1 - 1) << 2)), 0);
140018a7a          rsi = rax_6;
140018a7a          
140018a7d          if (!rax_6)
140018a83              return nullptr;
140018992      }
140018992      
140018998      int32_t rbx_1 = arg2 >> 2;
140018998      
1400189a0      if (!rbx_1)
140018a05          return rsi;
140018a05      
1400189a2      int64_t* _.bss_1 = _.bss;
1400189a2      
1400189ac      if (!_.bss_1)
1400189ac      {
140018a95          dtoa_lock(1);
140018a9a          _.bss_1 = _.bss;
140018a9a          
140018aa4          if (!_.bss_1)
140018aa4          {
140018aca              int64_t* _.bss_2 = __Balloc_D2A(1);
140018ad2              _.bss_1 = _.bss_2;
140018ad2              
140018ad5              if (!_.bss_2)
140018ad5              {
140018af5                  _.bss = 0;
140018b00                  return nullptr;
140018ad5              }
140018ad5              
140018ae1              _.bss = _.bss_1;
140018ae8              *(uint64_t*)((char*)_.bss_1 + 0x14) = 0x27100000001;
140018aec              *(uint64_t*)_.bss_1 = 0;
140018aa4          }
140018aa4          
140018aad          if (dtoa_CS_init == 2)
140018aba              LeaveCriticalSection(&data_140027ca8);
1400189ac      }
1400189ac      
1400189b2      int64_t* rbp_1 = rsi;
1400189b2      
1400189d2      while (true)
1400189d2      {
1400189d2          if (!((uint8_t)rbx_1 & 1))
1400189d2          {
1400189c0              rbx_1 s>>= 1;
1400189c0              
1400189c2              if (!rbx_1)
140018a05                  return rbp_1;
1400189d2          }
1400189d2          else
1400189d2          {
1400189da              int64_t* rax_2 = __mult_D2A(rbp_1, _.bss_1);
1400189da              
1400189e5              if (!rax_2)
140018a83                  return nullptr;
140018a83              
1400189eb              int64_t* rcx_1 = rbp_1;
1400189ee              rbp_1 = rax_2;
1400189f1              __Bfree_D2A(rcx_1);
1400189f6              rbx_1 s>>= 1;
1400189f6              
1400189f8              if (!rbx_1)
140018a05                  return rbp_1;
1400189d2          }
1400189d2          
1400189c4          int64_t* _.bss_3 = *(uint64_t*)_.bss_1;
1400189c4          
1400189ca          if (!_.bss_3)
1400189ca          {
140018a15              dtoa_lock(1);
140018a1a              _.bss_3 = *(uint64_t*)_.bss_1;
140018a1a              
140018a20              if (!_.bss_3)
140018a20              {
140018a46                  int64_t* _.bss_4 = __mult_D2A(_.bss_1, _.bss_1);
140018a4e                  _.bss_3 = _.bss_4;
140018a51                  *(uint64_t*)_.bss_1 = _.bss_4;
140018a51                  
140018a54                  if (!_.bss_4)
140018a83                      return nullptr;
140018a83                  
140018a56                  *(uint64_t*)_.bss_4 = 0;
140018a20              }
140018a20              
140018a29              if (dtoa_CS_init == 2)
140018a32                  LeaveCriticalSection(&data_140027ca8);
1400189ca          }
1400189ca          
1400189cc          _.bss_1 = _.bss_3;
1400189d2      }
140018980  }

1400189b7                                                                       66 0f 1f 84 00 00 00 00 00                         f........
140018a06                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
140018a3a                                                                                66 0f 1f 44 00 00                            f..D..
140018a5f                                                                                               90                                 .
140018a8a                                66 0f 1f 44 00 00                                                            f..D..
140018b07                       66 0f 1f 84 00 00 00 00 00                                                         f........

140018b10    int64_t* __lshift_D2A(int64_t* arg1, int32_t arg2)

140018b10  {
140018b23      int32_t rcx = arg1[1];
140018b2d      uint64_t rsi_1 = (uint64_t)(arg2 >> 5);
140018b30      int32_t rax = *(uint32_t*)((char*)arg1 + 0xc);
140018b35      int32_t rbx_1 = *(uint32_t*)((char*)arg1 + 0x14) + (uint32_t)rsi_1;
140018b37      int32_t r13 = rbx_1 + 1;
140018b37      
140018b3e      while (r13 > rax)
140018b3e      {
140018b40          rax *= 2;
140018b42          rcx += 1;
140018b3e      }
140018b3e      
140018b4a      int64_t* result = __Balloc_D2A(rcx);
140018b4a      
140018b55      if (result)
140018b55      {
140018b5b          void* rdi_1 = &result[3];
140018b5b          
140018b61          if ((uint32_t)rsi_1 > 0)
140018b61          {
140018b63              uint64_t _Size = rsi_1 << 2;
140018b67              void* rcx_1 = rdi_1;
140018b6f              rdi_1 += _Size;
140018b72              memset(rcx_1, 0, _Size);
140018b61          }
140018b61          
140018b7c          void* rsi_2 = &arg1[3];
140018b81          int32_t rbp_1 = arg2 & 0x1f;
140018b84          void* r9_1 = (char*)rsi_2 + ((int64_t)*(uint32_t*)((char*)arg1 + 0x14) << 2);
140018b84          
140018b88          if (!rbp_1)
140018b88          {
140018c1a              do
140018c1a              {
140018c10                  *(uint32_t*)rdi_1 = *(uint32_t*)rsi_2;
140018c10                  void* rdi_2 = (char*)rdi_1 + 4;
140018c10                  void* rsi_3 = (char*)rsi_2 + 4;
140018c10                  
140018c14                  if (rsi_3 >= r9_1)
140018c14                      break;
140018c14                  
140018c16                  *(uint32_t*)rdi_2 = *(uint32_t*)rsi_3;
140018c16                  rdi_1 = (char*)rdi_2 + 4;
140018c16                  rsi_2 = (char*)rsi_3 + 4;
140018c1a              } while (rsi_2 < r9_1);
140018c1a              
140018bef              r13 = rbx_1;
140018b88          }
140018b88          else
140018b88          {
140018b94              void* r8_2 = rdi_1;
140018b97              uint32_t rdx = 0;
140018b97              
140018bbf              do
140018bbf              {
140018ba0                  int32_t rax_2 = *(uint32_t*)rsi_2;
140018ba4                  r8_2 += 4;
140018ba8                  rsi_2 += 4;
140018bb3                  *(uint32_t*)((char*)r8_2 - 4) = rax_2 << (uint8_t)rbp_1 | rdx;
140018bba                  rdx = *(uint32_t*)((char*)rsi_2 - 4) >> (0x20 - (uint8_t)rbp_1);
140018bbf              } while (rsi_2 < r9_1);
140018bbf              
140018bdc              void* rax_9 = (((char*)r9_1 - arg1 - 0x19) >> 2 << 2) + 4;
140018bdc              
140018be4              if (r9_1 < (char*)arg1 + 0x19)
140018be4                  rax_9 = 4;
140018be4              
140018bea              *(uint32_t*)((char*)rdi_1 + rax_9) = rdx;
140018bea              
140018bed              if (!rdx)
140018bef                  r13 = rbx_1;
140018b88          }
140018b88          
140018bf2          *(uint32_t*)((char*)result + 0x14) = r13;
140018bf9          __Bfree_D2A(arg1);
140018b55      }
140018b55      
140018c0f      return result;
140018b10  }

140018c1e                                                                                            66 90                                f.

140018c20    uint64_t __cmp_D2A(void* arg1, void* arg2)

140018c20  {
140018c20      int64_t rax_1 = (int64_t)*(uint32_t*)((char*)arg2 + 0x14);
140018c24      int32_t r9 = *(uint32_t*)((char*)arg1 + 0x14);
140018c28      int32_t r9_1 = r9 - (uint32_t)rax_1;
140018c28      
140018c2b      if (r9 == (uint32_t)rax_1)
140018c2b      {
140018c2d          int64_t r8_1 = rax_1 << 2;
140018c39          void* i = (char*)arg1 + 0x18 + r8_1;
140018c3d          void* rdx = (char*)arg2 + r8_1 + 0x18;
140018c3d          
140018c4b          do
140018c4b          {
140018c4d              i -= 4;
140018c51              rdx -= 4;
140018c55              int32_t r10_1 = *(uint32_t*)rdx;
140018c58              int32_t temp1_1 = *(uint32_t*)i;
140018c58              
140018c5b              if (temp1_1 != r10_1)
140018c5b              {
140018c60                  r9_1 = (r9_1 - r9_1) | 1;
140018c60                  break;
140018c5b              }
140018c4b          } while ((char*)arg1 + 0x18 < i);
140018c2b      }
140018c2b      
140018c67      return (uint64_t)r9_1;
140018c20  }

140018c44              0f 1f 40 00                                                                              ..@.
140018c68                          0f 1f 84 00 00 00 00 00                                                          ........

140018c70    int64_t* __diff_D2A(void* arg1, void* arg2)

140018c70  {
140018c7e      int64_t rax = (int64_t)*(uint32_t*)((char*)arg2 + 0x14);
140018c82      int32_t rdi = *(uint32_t*)((char*)arg1 + 0x14);
140018c85      void* rsi = arg1;
140018c88      void* rbx = arg2;
140018c8b      int32_t rdi_1 = rdi - (uint32_t)rax;
140018c8d      int64_t* result;
140018c8d      
140018c8d      if (rdi != (uint32_t)rax)
140018c8d      {
140018de8          rdi_1 = 0;
140018de8          
140018ded          if (rdi - (uint32_t)rax < 0)
140018ded          {
140018df3          label_140018df3:
140018df3              void* rax_15 = rsi;
140018df6              rdi_1 = 1;
140018dfb              rsi = rbx;
140018dfe              rbx = rax_15;
140018ded          }
140018c8d      }
140018c8d      else
140018c8d      {
140018c93          int64_t rdx = rax << 2;
140018c9f          void* rax_1 = (char*)arg1 + 0x18 + rdx;
140018ca3          void* rdx_1 = (char*)rbx + rdx + 0x18;
140018cb9          int32_t r14_1;
140018cb9          int32_t temp1_1;
140018cb9          
140018cb9          while (true)
140018cb9          {
140018cb9              rax_1 -= 4;
140018cbd              rdx_1 -= 4;
140018cc1              r14_1 = *(uint32_t*)rdx_1;
140018cc4              temp1_1 = *(uint32_t*)rax_1;
140018cc4              
140018cc7              if (temp1_1 != r14_1)
140018cc7                  break;
140018cc7              
140018cb3              if ((char*)arg1 + 0x18 >= rax_1)
140018cb3              {
140018e12                  int64_t* result_2 = __Balloc_D2A(0);
140018e1a                  result = result_2;
140018e1a                  
140018e1d                  if (result_2)
140018e1f                      *(uint64_t*)((char*)result_2 + 0x14) = 1;
140018e1f                  
140018e1d                  goto label_140018de4;
140018cb3              }
140018cb9          }
140018cb9          
140018cc9          if (temp1_1 < r14_1)
140018cc9              goto label_140018df3;
140018c8d      }
140018c8d      
140018cd3      int64_t* result_1 = __Balloc_D2A(*(uint32_t*)((char*)rsi + 8));
140018cdb      result = result_1;
140018cdb      
140018cde      if (result_1)
140018cde      {
140018ce4          result_1[2] = rdi_1;
140018ce7          int64_t rax_2 = (int64_t)*(uint32_t*)((char*)rsi + 0x14);
140018cef          void* rcx_2 = 0x18;
140018cf8          uint64_t rdx_2 = 0;
140018cfa          void* rdi_2 = (char*)rsi + 0x18 + (rax_2 << 2);
140018cff          int32_t r10_1 = (uint32_t)rax_2;
140018d06          void* i = (char*)rbx + ((int64_t)*(uint32_t*)((char*)rbx + 0x14) << 2) + 0x18;
140018d39          int32_t r11_1;
140018d39          
140018d39          do
140018d39          {
140018d1a              uint64_t rax_6 = (uint64_t)*(uint32_t*)((char*)rsi + rcx_2)
140018d1a                  - (uint64_t)*(uint32_t*)((char*)rbx + rcx_2) - rdx_2;
140018d20              *(uint32_t*)((char*)result + rcx_2) = (uint32_t)rax_6;
140018d24              rcx_2 += 4;
140018d28              r11_1 = (uint32_t)rax_6;
140018d33              rdx_2 = (uint64_t)(uint32_t)(rax_6 >> 0x20) & 1;
140018d39          } while ((char*)rcx_2 + rbx < i);
140018d39          
140018d4e          uint64_t r14_3 = ((char*)i - rbx - 0x19) >> 2;
140018d55          void* rax_10 = (r14_3 << 2) + 4;
140018d55          
140018d5d          if (i < (char*)rbx + 0x19)
140018d5d              rax_10 = 4;
140018d5d          
140018d61          void* r8_2 = &result[3] + rax_10;
140018d65          void* r13_2 = (char*)rsi + 0x18 + rax_10;
140018d6b          void* rbx_1 = r8_2;
140018d6e          void* rcx_3 = r13_2;
140018d71          void* rax_13;
140018d71          
140018d71          if (r13_2 >= rdi_2)
140018d71          {
140018e32              uint64_t r14_4 = r14_3 << 2;
140018e32              
140018e39              if (i < (char*)rbx + 0x19)
140018e39                  r14_4 = 0;
140018e39              
140018e3d              rax_13 = &result[3] + r14_4;
140018d71          }
140018d71          else
140018d71          {
140018da0              do
140018da0              {
140018d80                  uint64_t rax_11 = (uint64_t)*(uint32_t*)rcx_3;
140018d82                  rcx_3 += 4;
140018d86                  rbx_1 += 4;
140018d8a                  uint64_t rax_12 = rax_11 - rdx_2;
140018d90                  r11_1 = (uint32_t)rax_12;
140018d93                  *(uint32_t*)((char*)rbx_1 - 4) = (uint32_t)rax_12;
140018d9a                  rdx_2 = (uint64_t)(uint32_t)(rax_12 >> 0x20) & 1;
140018da0              } while (rcx_3 < rdi_2);
140018da0              
140018dad              rax_13 = (char*)r8_2 + (((char*)rdi_2 - 1 - r13_2) & 0xfffffffffffffffc);
140018d71          }
140018d71          
140018db4          if (!r11_1)
140018db4          {
140018dcd              int32_t i_1;
140018dcd              
140018dcd              do
140018dcd              {
140018dc0                  i_1 = *(uint32_t*)((char*)rax_13 - 4);
140018dc3                  rax_13 -= 4;
140018dc7                  r10_1 -= 1;
140018dcd              } while (!i_1);
140018db4          }
140018db4          
140018dcf          *(uint32_t*)((char*)result + 0x14) = r10_1;
140018cde      }
140018cde      
140018de4  label_140018de4:
140018de4      return result;
140018c70  }

140018caa                                66 0f 1f 44 00 00                                                            f..D..
140018de5                 0f 1f 00                                                                               ...
140018e06                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
140018e29                             0f 1f 80 00 00 00 00                                                           .......
140018e46                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

140018e50    int512_t __b2d_D2A(void* arg1, int32_t* arg2)

140018e50  {
140018e5b      void* rbx = (char*)arg1 + 0x18 + ((int64_t)*(uint32_t*)((char*)arg1 + 0x14) << 2);
140018e5f      int32_t r11 = *(uint32_t*)((char*)rbx - 4);
140018e67      uint64_t rflags;
140018e67      int32_t temp0;
140018e67      temp0 = _bit_scan_reverse(r11);
140018e72      int32_t rdi_1 = temp0 ^ 0x1f;
140018e7e      *(uint32_t*)arg2 = 0x20 - rdi_1;
140018e81      int512_t result;
140018e81      
140018e81      if (rdi_1 <= 0xa)
140018e81      {
140018f08          uint32_t r8_2 = 0;
140018f08          
140018f1b          if ((char*)arg1 + 0x18 < (char*)rbx - 4)
140018f21              r8_2 = *(uint32_t*)((char*)rbx - 8) >> (0xb - (uint8_t)rdi_1);
140018f21          
140018f32          (uint128_t)result =
140018f32              (uint128_t)(((uint64_t)(r11 >> (0xb - (uint8_t)rdi_1)) | 0x3ff00000) << 0x20)
140018f32              | (uint128_t)(r11 << ((uint8_t)rdi_1 + 0x15)) | (uint128_t)r8_2;
140018f3a          return result;
140018e81      }
140018e81      
140018e8a      uint64_t rax_5;
140018e8a      uint64_t rdx;
140018e8a      
140018e8a      if ((char*)arg1 + 0x18 >= (char*)rbx - 4)
140018e8a      {
140018ee0          rdx = 0;
140018ee0          
140018ee5          if (rdi_1 != 0xb)
140018ee5          {
140018f56              (uint128_t)result =
140018f56                  (uint128_t)(((uint64_t)(r11 << (rdi_1 - 0xb)) | 0x3ff00000) << 0x20);
140018f5e              return result;
140018ee5          }
140018ee5          
140018eef          rax_5 = ((uint64_t)r11 | 0x3ff00000) << 0x20;
140018e8a      }
140018e8a      else
140018e8a      {
140018e8f          rdx = (uint64_t)*(uint32_t*)((char*)rbx - 8);
140018e8f          
140018e92          if (rdi_1 == 0xb)
140018eef              rax_5 = ((uint64_t)r11 | 0x3ff00000) << 0x20;
140018e92          else
140018e92          {
140018eac              int32_t rax_3 =
140018eac                  r11 << (rdi_1 - 0xb) | (uint32_t)rdx >> (0x20 - (rdi_1 - 0xb));
140018eae              rdx = (uint64_t)((uint32_t)rdx << (rdi_1 - 0xb));
140018eb9              rax_5 = ((uint64_t)rax_3 | 0x3ff00000) << 0x20;
140018eb9              
140018ec0              if ((char*)arg1 + 0x18 < (char*)rbx - 8)
140018ec0              {
140018ed2                  (uint128_t)result = (uint128_t)rax_5 | (uint128_t)(uint32_t)rdx | (
140018ed2                      uint128_t)(*(uint32_t*)((char*)rbx - 0xc) >> (0x20 - (rdi_1 - 0xb)));
140018eda                  return result;
140018ec0              }
140018e92          }
140018e8a      }
140018e8a      
140018ef6      (uint128_t)result = (uint128_t)rax_5 | (uint128_t)rdx;
140018efe      return result;
140018e50  }

140018edb                                                                                   0f 1f 44 00 00                             ..D..
140018eff                                                                                               90                                 .
140018f3b                                                                                   0f 1f 44 00 00                             ..D..
140018f5f                                                                                               90                                 .

140018f60    int64_t* __d2b_D2A(int64_t arg1 @ zmm0, int32_t* arg2, int32_t* arg3)

140018f60  {
140018f77      int64_t* result = __Balloc_D2A(1);
140018f77      
140018f82      if (result)
140018f82      {
140018f8e          uint32_t rcx_2 = (int32_t)(arg1 >> 0x20);
140018f98          uint32_t r9_2 = rcx_2 & 0xfffff;
140018fa9          int32_t rcx_4 = rcx_2 >> 0x14 & 0x7ff;
140018fa9          
140018faf          if (rcx_4)
140018faf              r9_2 |= 0x100000;
140018faf          
140018fb8          int32_t rax_2;
140018fb8          int32_t r8_2;
140018fb8          
140018fb8          if (!(uint32_t)arg1)
140018fb8          {
140019030              uint64_t rflags_3;
140019030              int32_t temp0_4;
140019030              temp0_4 = _bit_scan_forward(r9_2);
140019034              rax_2 = 1;
140019039              r8_2 = temp0_4 + 0x20;
140019043              *(uint32_t*)((char*)result + 0x14) = 1;
140019046              result[3] = r9_2 >> (uint8_t)temp0_4;
140019046              
14001904a              if (!rcx_4)
14001904a              {
14001900d              label_14001900d:
14001900d                  uint64_t rflags_2;
14001900d                  int32_t temp0_3;
14001900d                  temp0_3 = __bsr_gprv_memv(
14001900d                      *(uint32_t*)((char*)result + ((int64_t)rax_2 << 2) + 0x14));
140019015                  *(uint32_t*)arg2 = r8_2 - 0x432;
14001901d                  *(uint32_t*)arg3 = (rax_2 << 5) - (temp0_3 ^ 0x1f);
14001904a              }
14001904a              else
14001904a              {
140019054                  *(uint32_t*)arg2 = rcx_4 + r8_2 - 0x433;
14001905e                  *(uint32_t*)arg3 = 0x35 - r8_2;
14001904a              }
140018fb8          }
140018fb8          else
140018fb8          {
140018fba              uint64_t rflags_1;
140018fba              int32_t temp0_1;
140018fba              temp0_1 = _bit_scan_forward((uint32_t)arg1);
140018fba              r8_2 = temp0_1;
140018fc1              uint32_t rax_1 = (uint32_t)arg1 >> (uint8_t)r8_2;
140018fc1              
140018fc6              if (r8_2)
140018fc6              {
140018fd8                  rax_1 |= r9_2 << (0x20 - (uint8_t)r8_2);
140018fda                  r9_2 u>>= (uint8_t)r8_2;
140018fc6              }
140018fc6              
140018fea              rax_2 = 1 + 1;
140018ff5              uint128_t zmm0 = _mm_unpacklo_epi32((uint128_t)rax_1, (uint64_t)r9_2);
140018ff9              *(uint32_t*)((char*)result + 0x14) = rax_2;
140018ffc              result[3] = (uint64_t)zmm0;
140018ffc              
140019001              if (!rcx_4)
140019001                  goto label_14001900d;
140019001              
140019054              *(uint32_t*)arg2 = rcx_4 + r8_2 - 0x433;
14001905e              *(uint32_t*)arg3 = 0x35 - r8_2;
140018fb8          }
140018f82      }
140018f82      
140019029      return result;
140018f60  }

14001902a                                66 0f 1f 44 00 00                                                            f..D..
140019062        66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                                                    ff............

140019070    char* __strcp_D2A(char* arg1, char* arg2)

140019070  {
140019070      char* result = arg1;
140019073      void* rcx = &arg2[1];
140019077      char rdx = *(uint8_t*)arg2;
14001907c      *(uint8_t*)result = rdx;
14001907c      
14001907e      if (rdx)
14001907e      {
14001908f          char i;
14001908f          
14001908f          do
14001908f          {
140019080              i = *(uint8_t*)rcx;
140019083              result = &result[1];
140019087              rcx += 1;
14001908d              *(uint8_t*)result = i;
14001908f          } while (i);
14001907e      }
14001907e      
140019091      return result;
140019070  }

140019092                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

1400190a0    void* strnlen(char* arg1, int64_t arg2)

1400190a0  {
1400190a0      void* result = nullptr;
1400190a6      char* rax = arg1;
1400190a6      
1400190a9      if (arg2)
1400190a9      {
1400190c2          while (*(uint8_t*)rax)
1400190c2          {
1400190b0              rax = &rax[1];
1400190b7              result = rax - arg1;
1400190b7              
1400190bd              if (result >= arg2)
1400190bd                  break;
1400190c2          }
1400190a9      }
1400190a9      
1400190c7      return result;
1400190a0  }

1400190ad                                         0f 1f 00                                                               ...
1400190c8                          90 90 90 90 90 90 90 90                                                          ........

1400190d0    int64_t wcsnlen(int64_t arg1, int64_t arg2)

1400190d0  {
1400190d0      int64_t r8 = 0;
1400190d0      
1400190d9      if (arg2)
1400190d9      {
1400190e7          do
1400190e7          {
1400190ef              if (!*(uint16_t*)(arg1 + (r8 << 1)))
1400190f1                  return r8;
1400190f1              
1400190e0              r8 += 1;
1400190e7          } while (arg2 != r8);
1400190d9      }
1400190d9      
1400190f4      return arg2;
1400190d0  }

1400190dd                                                                                         0f 1f 00                               ...
1400190f5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

140019100    int64_t vfprintf(FILE* arg1, char* arg2, va_list arg3)

140019100  {
14001911d      return __stdio_common_vfprintf(0, arg1, arg2, nullptr, arg3);
140019100  }

14001911e                                                                                            90 90                                ..

140019120    int64_t fprintf(FILE* arg1, char* arg2, int64_t arg3)

140019120  {
140019129      int64_t _ArgList = arg3;
140019134      int64_t r9;
140019134      int64_t arg_20 = r9;
140019143      int64_t* var_10 = &_ArgList;
140019151      return __stdio_common_vfprintf(0, arg1, arg2, nullptr, &_ArgList);
140019120  }

140019152                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

140019160    int64_t _get_output_format() __pure

140019160  {
140019162      return 0;
140019160  }

140019163           66 66 2e 0f 1f 84 00 00 00 00 00 66 90                                                     ff.........f.

140019170    int64_t __getmainargs(int32_t* arg1, char*** arg2, char*** arg3, int32_t arg4, int32_t* arg5)

140019170  {
14001918b      _initialize_narrow_environment();
14001919b      _configure_narrow_argv(1 + 1);
1400191a7      *(uint32_t*)arg1 = *(uint32_t*)__p___argc();
1400191b1      *(uint64_t*)arg2 = *(uint64_t*)__p___argv();
1400191bf      *(uint64_t*)arg3 = *(uint64_t*)__p__environ();
1400191bf      
1400191c2      if (arg5)
1400191c8          _set_new_mode(*(uint32_t*)arg5);
1400191c8      
1400191d9      return 0;
140019170  }

1400191da                                                                                66 0f 1f 44 00 00                            f..D..

1400191e0    int64_t __wgetmainargs(int32_t* arg1, wchar16*** arg2, wchar16*** arg3, int32_t arg4, int32_t* arg5)

1400191e0  {
1400191fb      _initialize_wide_environment();
14001920b      _configure_wide_argv(1 + 1);
140019217      *(uint32_t*)arg1 = *(uint32_t*)__p___argc();
140019221      *(uint64_t*)arg2 = *(uint64_t*)__p___wargv();
14001922f      *(uint64_t*)arg3 = *(uint64_t*)__p__wenviron();
14001922f      
140019232      if (arg5)
140019238          _set_new_mode(*(uint32_t*)arg5);
140019238      
140019249      return 0;
1400191e0  }

14001924a                                66 0f 1f 44 00 00                                                            f..D..

140019250    _PVFV _onexit(_PVFV arg1)

140019250  {
140019264      if (!_crt_atexit(arg1))
140019264          return arg1;
140019264      
14001926d      return nullptr;
140019250  }

14001926e                                            66 90                                                                f.

140019270    int64_t at_quick_exit(_PVFV arg1)

140019270  {
14001927a      if (!_.bss)
140019280          /* tailcall */
140019280          return _crt_at_quick_exit(arg1);
140019280      
14001927e      return 0;
140019270  }

14001927f                                                                                               90                                 .
140019285                 66 66 2e 0f 1f 84 00 00 00 00 00                                                       ff.........

140019290    void _amsg_exit(int32_t arg1) __noreturn

140019290  {
1400192ae      fprintf(__acrt_iob_func(2), "runtime error %d\n", (uint64_t)arg1);
1400192bf      _exit(0xff);
1400192bf      /* no return */
140019290  }

1400192c1     90 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                                                   .ff............

1400192d0    int64_t __ms_fwprintf(FILE* arg1, wchar16* arg2, int64_t arg3)

1400192d0  {
1400192d9      int64_t _ArgList = arg3;
1400192e4      int64_t r9;
1400192e4      int64_t arg_20 = r9;
1400192f6      int64_t* var_10 = &_ArgList;
140019304      return __stdio_common_vfwprintf(4, arg1, arg2, nullptr, &_ArgList);
1400192d0  }

140019305                 66 66 2e 0f 1f 84 00 00 00 00 00                                                       ff.........

140019310    int32_t* tzset()

140019310  {
14001931b      _tzset();
140019322      __imp_tzname = __tzname();
14001932e      __imp_timezone = __timezone();
140019335      int32_t* result = __daylight();
14001933a      __imp_daylight = result;
140019345      return result;
140019310  }

140019346                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

140019350    int32_t* _tzset()

140019350  {
14001935b      _tzset();
140019362      __imp_tzname = __tzname();
14001936e      __imp_timezone = __timezone();
140019375      int32_t* result = __daylight();
14001937a      __imp_daylight = result;
140019385      return result;
140019350  }

140019386                    90 90 90 90 90 90 90 90 90 90                                                        ..........

140019390    int32_t* __daylight()

140019390  {
140019390      /* tailcall */
140019390      return __daylight();
140019390  }

140019396                                                                    90 90                                                ..

140019398    int32_t* __timezone()

140019398  {
140019398      /* tailcall */
140019398      return __timezone();
140019398  }

14001939e                                                                                            90 90                                ..

1400193a0    char** __tzname()

1400193a0  {
1400193a0      /* tailcall */
1400193a0      return __tzname();
1400193a0  }

1400193a6                    90 90                                                                                ..
1400193a8  _.text:
1400193a8                          0f 1f 84 00 00 00 00 00                                                          ........

1400193b0    int64_t memset(void* _Dst, int32_t _Val, uint64_t _Size)

1400193b0  {
1400193b0      /* tailcall */
1400193b0      return memset(_Dst, _Val, _Size);
1400193b0  }

1400193b6                                                                    90 90                                                ..

1400193b8    uint64_t strlen(char const* _Str)

1400193b8  {
1400193b8      /* tailcall */
1400193b8      return strlen(_Str);
1400193b8  }

1400193be                                                                                            90 90                                ..

1400193c0    int32_t strncmp(char const* _Str1, char const* _Str2, uint64_t _MaxCount)

1400193c0  {
1400193c0      /* tailcall */
1400193c0      return strncmp(_Str1, _Str2, _MaxCount);
1400193c0  }

1400193c6                    90 90                                                                                ..

1400193c8    uint64_t wcslen(wchar16 const* _String)

1400193c8  {
1400193c8      /* tailcall */
1400193c8      return wcslen(_String);
1400193c8  }

1400193ce                                            90 90                                                                ..

1400193d0    FILE* __acrt_iob_func(uint32_t _Ix)

1400193d0  {
1400193d0      /* tailcall */
1400193d0      return __acrt_iob_func(_Ix);
1400193d0  }

1400193d6                                                                    90 90                                                ..

1400193d8    int32_t* __p__commode()

1400193d8  {
1400193d8      /* tailcall */
1400193d8      return __p__commode();
1400193d8  }

1400193de                                                                                            90 90                                ..

1400193e0    int32_t* __p__fmode()

1400193e0  {
1400193e0      /* tailcall */
1400193e0      return __p__fmode();
1400193e0  }

1400193e6                    90 90                                                                                ..

1400193e8    int32_t __stdio_common_vfprintf(uint64_t _Options, FILE* _Stream, char const* _Format, _locale_t _Locale, va_list _ArgList)

1400193e8  {
1400193e8      /* tailcall */
1400193e8      return __stdio_common_vfprintf(_Options, _Stream, _Format, _Locale, _ArgList);
1400193e8  }

1400193ee                                            90 90                                                                ..

1400193f0    int32_t __stdio_common_vfwprintf(uint64_t _Options, FILE* _Stream, wchar16 const* _Format, _locale_t _Locale, va_list _ArgList)

1400193f0  {
1400193f0      /* tailcall */
1400193f0      return __stdio_common_vfwprintf(_Options, _Stream, _Format, _Locale, _ArgList);
1400193f0  }

1400193f6                                                                    90 90                                                ..

1400193f8    int32_t _.text(FILE* _Stream)

1400193f8  {
1400193f8      /* tailcall */
1400193f8      return _fileno(_Stream);
1400193f8  }

1400193fe                                                                                            90 90                                ..

140019400    int32_t _.text(int32_t _FileHandleSrc, int32_t _FileHandleDst)

140019400  {
140019400      /* tailcall */
140019400      return _setmode(_FileHandleSrc, _FileHandleDst);
140019400  }

140019406                    90 90                                                                                ..

140019408    int32_t fflush(FILE* _Stream)

140019408  {
140019408      /* tailcall */
140019408      return fflush(_Stream);
140019408  }

14001940e                                            90 90                                                                ..

140019410    int32_t fputc(int32_t _Character, FILE* _Stream)

140019410  {
140019410      /* tailcall */
140019410      return fputc(_Character, _Stream);
140019410  }

140019416                                                                    90 90                                                ..

140019418    uint64_t fwrite(void const* _Buffer, uint64_t _ElementSize, uint64_t _ElementCount, FILE* _Stream)

140019418  {
140019418      /* tailcall */
140019418      return fwrite(_Buffer, _ElementSize, _ElementCount, _Stream);
140019418  }

14001941e                                                                                            90 90                                ..

140019420    int32_t* __p___argc()

140019420  {
140019420      /* tailcall */
140019420      return __p___argc();
140019420  }

140019426                    90 90                                                                                ..

140019428    char*** __p___argv()

140019428  {
140019428      /* tailcall */
140019428      return __p___argv();
140019428  }

14001942e                                            90 90                                                                ..

140019430    wchar16*** __p___wargv()

140019430  {
140019430      /* tailcall */
140019430      return __p___wargv();
140019430  }

140019436                                                                    90 90                                                ..

140019438    void _cexit()

140019438  {
140019438      /* tailcall */
140019438      return _cexit();
140019438  }

14001943e                                                                                            90 90                                ..

140019440    errno_t _configure_narrow_argv(enum _crt_argv_mode mode)

140019440  {
140019440      /* tailcall */
140019440      return _configure_narrow_argv(mode);
140019440  }

140019446                    90 90                                                                                ..

140019448    errno_t _configure_wide_argv(enum _crt_argv_mode mode)

140019448  {
140019448      /* tailcall */
140019448      return _configure_wide_argv(mode);
140019448  }

14001944e                                            90 90                                                                ..

140019450    int32_t _crt_at_quick_exit(_PVFV _Function)

140019450  {
140019450      /* tailcall */
140019450      return _crt_at_quick_exit(_Function);
140019450  }

140019456                                                                    90 90                                                ..

140019458    int32_t _crt_atexit(_PVFV _Function)

140019458  {
140019458      /* tailcall */
140019458      return _crt_atexit(_Function);
140019458  }

14001945e                                                                                            90 90                                ..

140019460    int32_t* _errno()

140019460  {
140019460      /* tailcall */
140019460      return _errno();
140019460  }

140019466                    90 90                                                                                ..

140019468    int32_t _initialize_narrow_environment()

140019468  {
140019468      /* tailcall */
140019468      return _initialize_narrow_environment();
140019468  }

14001946e                                            90 90                                                                ..

140019470    int32_t _initialize_wide_environment()

140019470  {
140019470      /* tailcall */
140019470      return _initialize_wide_environment();
140019470  }

140019476                                                                    90 90                                                ..

140019478    void _initterm(_PVFV* _First, _PVFV* _Last)

140019478  {
140019478      /* tailcall */
140019478      return _initterm(_First, _Last);
140019478  }

14001947e                                                                                            90 90                                ..

140019480    void _set_app_type(enum _crt_app_type _Type)

140019480  {
140019480      /* tailcall */
140019480      return _set_app_type(_Type);
140019480  }

140019486                    90 90                                                                                ..

140019488    _invalid_parameter_handler_1 _set_invalid_parameter_handler(_invalid_parameter_handler_1 _Handler)

140019488  {
140019488      /* tailcall */
140019488      return _set_invalid_parameter_handler(_Handler);
140019488  }

14001948e                                            90 90                                                                ..

140019490    void abort() __noreturn

140019490  {
140019490      /* tailcall */
140019490      return abort();
140019490  }

140019496                                                                    90 90                                                ..

140019498    _crt_signal_t signal(int32_t _Signal, _crt_signal_t _Function)

140019498  {
140019498      /* tailcall */
140019498      return signal(_Signal, _Function);
140019498  }

14001949e                                                                                            90 90                                ..

1400194a0    char* strerror(char const* _Source)

1400194a0  {
1400194a0      /* tailcall */
1400194a0      return strerror(_Source);
1400194a0  }

1400194a6                    90 90 0f 1f 84 00 00 00 00 00                                                        ..........

1400194b0    int64_t _.text()

1400194b0  {
1400194b0      /* tailcall */
1400194b0      return __C_specific_handler();
1400194b0  }

1400194b6                                                                    90 90                                                ..

1400194b8    int64_t memcpy(void* _Dst, void const* _Src, uint64_t _Size)

1400194b8  {
1400194b8      /* tailcall */
1400194b8      return memcpy(_Dst, _Src, _Size);
1400194b8  }

1400194be                                                                                            90 90                                ..

1400194c0    void __setusermatherr(_UserMathErrorFunctionPointer _UserMathErrorFunction)

1400194c0  {
1400194c0      /* tailcall */
1400194c0      return __setusermatherr(_UserMathErrorFunction);
1400194c0  }

1400194c6                    90 90 0f 1f 84 00 00 00 00 00                                                        ..........

1400194d0    struct lconv* localeconv()

1400194d0  {
1400194d0      /* tailcall */
1400194d0      return localeconv();
1400194d0  }

1400194d6                                                                    90 90 0f 1f 84 00 00 00 00 00                        ..........

1400194e0    int32_t _set_new_mode(int32_t _NewMode)

1400194e0  {
1400194e0      /* tailcall */
1400194e0      return _set_new_mode(_NewMode);
1400194e0  }

1400194e6                    90 90                                                                                ..

1400194e8    int64_t calloc(uint64_t _Count, uint64_t _Size)

1400194e8  {
1400194e8      /* tailcall */
1400194e8      return calloc(_Count, _Size);
1400194e8  }

1400194ee                                            90 90                                                                ..

1400194f0    void free(void* _Block)

1400194f0  {
1400194f0      /* tailcall */
1400194f0      return free(_Block);
1400194f0  }

1400194f6                                                                    90 90                                                ..

1400194f8    int64_t malloc(uint64_t _Size)

1400194f8  {
1400194f8      /* tailcall */
1400194f8      return malloc(_Size);
1400194f8  }

1400194fe                                                                                            90 90                                ..

140019500    int64_t realloc(void* _Block, uint64_t _Size)

140019500  {
140019500      /* tailcall */
140019500      return realloc(_Block, _Size);
140019500  }

140019506                    90 90 0f 1f 84 00 00 00 00 00                                                        ..........

140019510    void _lock_file(FILE* _Stream)

140019510  {
140019510      /* tailcall */
140019510      return _lock_file(_Stream);
140019510  }

140019516                                                                    90 90                                                ..

140019518    void _unlock_file(FILE* _Stream)

140019518  {
140019518      /* tailcall */
140019518      return _unlock_file(_Stream);
140019518  }

14001951e                                                                                            90 90                                ..

140019520    char*** __p__environ()

140019520  {
140019520      /* tailcall */
140019520      return __p__environ();
140019520  }

140019526                    90 90                                                                                ..

140019528    wchar16*** __p__wenviron()

140019528  {
140019528      /* tailcall */
140019528      return __p__wenviron();
140019528  }

14001952e                                            90 90                                                                ..

140019530    uint64_t mbrtowc(wchar16* _DstCh, char const* _SrcCh, uint64_t _SizeInBytes, mbstate_t* _State)

140019530  {
140019530      /* tailcall */
140019530      return mbrtowc(_DstCh, _SrcCh, _SizeInBytes, _State);
140019530  }

140019536                                                                    90 90                                                ..

140019538    uint64_t wcrtomb(char* _Dest, wchar16 _Source, mbstate_t* _State)

140019538  {
140019538      /* tailcall */
140019538      return wcrtomb(_Dest, _Source, _State);
140019538  }

14001953e                                                                                            90 90                                ..

140019540    uint64_t VirtualQuery(void* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, uint64_t dwLength)

140019540  {
140019540      /* tailcall */
140019540      return VirtualQuery(lpAddress, lpBuffer, dwLength);
140019540  }

140019546                    90 90                                                                                ..

140019548    BOOL VirtualProtect(void* lpAddress, uint64_t dwSize, enum PAGE_PROTECTION_FLAGS flNewProtect, enum PAGE_PROTECTION_FLAGS* lpflOldProtect)

140019548  {
140019548      /* tailcall */
140019548      return VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
140019548  }

14001954e                                            90 90                                                                ..

140019550    BOOL VirtualFree(void* lpAddress, uint64_t dwSize, enum VIRTUAL_FREE_TYPE dwFreeType)

140019550  {
140019550      /* tailcall */
140019550      return VirtualFree(lpAddress, dwSize, dwFreeType);
140019550  }

140019556                                                                    90 90                                                ..

140019558    int64_t VirtualAlloc(void* lpAddress, uint64_t dwSize, enum VIRTUAL_ALLOCATION_TYPE flAllocationType, enum PAGE_PROTECTION_FLAGS flProtect)

140019558  {
140019558      /* tailcall */
140019558      return VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
140019558  }

14001955e                                                                                            90 90                                ..

140019560    int64_t TlsGetValue(uint32_t dwTlsIndex)

140019560  {
140019560      /* tailcall */
140019560      return TlsGetValue(dwTlsIndex);
140019560  }

140019566                    90 90                                                                                ..

140019568    void Sleep(uint32_t dwMilliseconds)

140019568  {
140019568      /* tailcall */
140019568      return Sleep(dwMilliseconds);
140019568  }

14001956e                                            90 90                                                                ..

140019570    LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)

140019570  {
140019570      /* tailcall */
140019570      return SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
140019570  }

140019576                                                                    90 90                                                ..

140019578    HMODULE LoadLibraryA(PSTR lpLibFileName)

140019578  {
140019578      /* tailcall */
140019578      return LoadLibraryA(lpLibFileName);
140019578  }

14001957e                                                                                            90 90                                ..

140019580    void LeaveCriticalSection(CRITICAL_SECTION* lpCriticalSection)

140019580  {
140019580      /* tailcall */
140019580      return LeaveCriticalSection(lpCriticalSection);
140019580  }

140019586                    90 90                                                                                ..

140019588    void InitializeCriticalSection(CRITICAL_SECTION* lpCriticalSection)

140019588  {
140019588      /* tailcall */
140019588      return InitializeCriticalSection(lpCriticalSection);
140019588  }

14001958e                                            90 90                                                                ..

140019590    int64_t GetProcAddress(HMODULE hModule, PSTR lpProcName)

140019590  {
140019590      /* tailcall */
140019590      return GetProcAddress(hModule, lpProcName);
140019590  }

140019596                                                                    90 90                                                ..

140019598    enum WIN32_ERROR GetLastError()

140019598  {
140019598      /* tailcall */
140019598      return GetLastError();
140019598  }

14001959e                                                                                            90 90                                ..

1400195a0    void EnterCriticalSection(CRITICAL_SECTION* lpCriticalSection)

1400195a0  {
1400195a0      /* tailcall */
1400195a0      return EnterCriticalSection(lpCriticalSection);
1400195a0  }

1400195a6                    90 90                                                                                ..

1400195a8    void DeleteCriticalSection(CRITICAL_SECTION* lpCriticalSection)

1400195a8  {
1400195a8      /* tailcall */
1400195a8      return DeleteCriticalSection(lpCriticalSection);
1400195a8  }

1400195ae                                            90 90                                                                ..

1400195b0    int32_t* mutex_impl_init(int32_t** arg1, int64_t arg2)

1400195b0  {
1400195c1      int32_t* result = malloc(0x18);
1400195c1      
1400195cc      if (result)
1400195cc      {
1400195d2          *(uint32_t*)result = 0;
1400195d8          int32_t rax = 2;
1400195d8          
1400195dd          if (arg2 != -3)
1400195e5              (uint8_t)rax = arg2 == -2;
1400195e5          
1400195e8          result[1] = rax;
1400195ee          *(uint64_t*)((char*)result + 8) = 0;
1400195f6          result[4] = 0;
1400195fd          result[5] = 0xffffffff;
140019604          bool z_1;
140019604          
140019604          if (arg2 == *(uint64_t*)arg1)
140019604          {
140019604              *(uint64_t*)arg1 = result;
140019604              z_1 = true;
140019604          }
140019604          else
140019604          {
140019604              *(uint64_t*)arg1;
140019604              z_1 = false;
140019604          }
140019604          
140019609          if (!z_1)
140019609          {
140019615              free(result);
14001961a              return *(uint64_t*)arg1;
140019609          }
1400195cc      }
1400195cc      
140019614      return result;
1400195b0  }

14001961f                                                                                               90                                 .

140019620    int64_t pthread_mutex_lock(int64_t* arg1)

140019620  {
140019628      int32_t* rbx = *(uint64_t*)arg1;
140019628      
140019633      if ((char*)rbx + 3 <= 3)
140019633      {
140019678          rbx = mutex_impl_init(arg1, rbx);
140019678          
14001967e          if (rbx)
14001967e          {
140019641          label_140019641:
140019641              int32_t temp0_1 = *(uint32_t*)rbx;
140019641              *(uint32_t*)rbx = 1;
140019641              
140019645              if (!temp0_1)
140019645              {
14001964a              label_14001964a:
14001964a                  
14001964c                  if (!rbx[1])
14001964e                      return 0;
14001964e                  
140019666                  rbx[5] = GetCurrentThreadId();
14001964e                  return 0;
140019645              }
140019645              
140019695              uint32_t rax_9;
140019695              int32_t rbp_1;
140019695              
140019695              if (rbx[1])
140019695              {
1400196e0                  rbp_1 = rbx[5];
1400196e3                  rax_9 = GetCurrentThreadId();
140019695              }
140019695              
1400196eb              if (rbx[1] && rbp_1 == rax_9)
1400196eb              {
1400196ef                  if (1 == *(uint32_t*)rbx)
1400196ef                      *(uint32_t*)rbx = temp0_1;
1400196ef                  else
1400196ef                      *(uint32_t*)rbx;
1400196ef                  
1400196fc                  if (rbx[1] != 2)
140019658                      return 0x24;
140019658                  
140019702                  rbx[4] += 1;
14001964e                  return 0;
1400196eb              }
1400196eb              
14001969c              if (*(uint64_t*)((char*)rbx + 8))
14001969c              {
1400196a5              label_1400196a5:
1400196a5                  
1400196a5                  while (true)
1400196a5                  {
1400196a5                      int32_t temp0_2 = *(uint32_t*)rbx;
1400196a5                      *(uint32_t*)rbx = 2;
1400196a5                      
1400196a9                      if (!temp0_2)
1400196a9                          break;
1400196a9                      
1400196b4                      int32_t rax_7 = _pthread_wait_for_single_object(
1400196b4                          *(uint64_t*)((char*)rbx + 8), 0xffffffff);
1400196b4                      
1400196bb                      if (rax_7)
1400196bb                      {
1400196cc                          if (rax_7 != 0x102)
1400196cc                              return 0x16;
1400196cc                          
1400196d7                          return 0x8a;
1400196bb                      }
1400196a5                  }
1400196a5                  
1400196a9                  goto label_14001964a;
14001969c              }
14001969c              
14001971a              HANDLE hObject = CreateEventA(nullptr, 0, 0, nullptr);
14001971a              
140019726              if (hObject)
140019726              {
14001972a                  bool z_1;
14001972a                  
14001972a                  if (0 == *(uint64_t*)((char*)rbx + 8))
14001972a                  {
14001972a                      *(uint64_t*)((char*)rbx + 8) = hObject;
14001972a                      z_1 = true;
14001972a                  }
14001972a                  else
14001972a                  {
14001972a                      *(uint64_t*)((char*)rbx + 8);
14001972a                      z_1 = false;
14001972a                  }
14001972a                  
140019730                  if (!z_1)
140019736                      CloseHandle(hObject);
140019736                  
140019730                  goto label_1400196a5;
140019726              }
140019726              
140019758              if (GetLastError() == ERROR_ACCESS_DENIED)
140019658                  return 1;
14001967e          }
140019633      }
140019633      else if (rbx)
140019638          goto label_140019641;
140019638      
14001968d      return 0xc;
140019620  }

140019659                                                                             0f 1f 80 00 00 00 00                           .......
14001966b                                   0f 1f 44 00 00                                                             ..D..
14001968e                                            66 90                                                                f.
1400196d8                                                                          0f 1f 84 00 00 00 00 00                          ........
14001970b                                   0f 1f 44 00 00                                                             ..D..
140019741     0f 1f 80 00 00 00 00                                                                           .......
140019763           66 66 2e 0f 1f 84 00 00 00 00 00 66 90                                                     ff.........f.

140019770    int64_t pthread_mutex_timedlock(int64_t* arg1, int64_t* arg2)

140019770  {
14001977a      uint32_t rbp = -1;
140019785      int64_t rax_1;
140019785      uint64_t rax_2;
140019785      
140019785      if (arg2)
140019785      {
14001978a          rbp = 0;
14001978c          rax_1 = _pthread_time_in_ms_from_timespec(arg2);
140019794          rax_2 = _pthread_time_in_ms();
140019785      }
140019785      
14001979c      int32_t* rbx_2;
14001979c      
14001979c      if (arg2 && rax_2 < rax_1)
14001979c      {
1400197d8          int64_t rbx_3 = rax_1 - rax_2;
1400197db          uint32_t rax_5 = -1;
1400197db          
1400197e3          if (rbx_3 <= 0xffffffff)
1400197e3              rax_5 = (uint32_t)rbx_3;
1400197e3          
1400197e7          rbx_2 = *(uint64_t*)arg1;
1400197ea          rbp = rax_5;
1400197ea          
1400197f5          if ((char*)rbx_2 + 3 > 3)
1400197f5              goto label_1400197ab;
1400197f5          
1400197f5          goto label_140019802;
14001979c      }
14001979c      
14001979e      rbx_2 = *(uint64_t*)arg1;
14001979e      
1400197a9      if ((char*)rbx_2 + 3 <= 3)
1400197a9      {
140019802      label_140019802:
140019802          rbx_2 = mutex_impl_init(arg1, rbx_2);
140019802          
140019808          if (rbx_2)
140019808          {
1400197b7          label_1400197b7:
1400197b7              int32_t temp0_1 = *(uint32_t*)rbx_2;
1400197b7              *(uint32_t*)rbx_2 = 1;
1400197b7              
1400197bb              if (!temp0_1)
1400197bb              {
1400197c0              label_1400197c0:
1400197c0                  
1400197c2                  if (!rbx_2[1])
1400197c4                      return 0;
1400197c4                  
140019826                  rbx_2[5] = GetCurrentThreadId();
1400197c4                  return 0;
1400197bb              }
1400197bb              
140019835              uint32_t rax_14;
140019835              int32_t r12_1;
140019835              
140019835              if (rbx_2[1])
140019835              {
140019880                  r12_1 = rbx_2[5];
140019884                  rax_14 = GetCurrentThreadId();
140019835              }
140019835              
14001988d              if (rbx_2[1] && r12_1 == rax_14)
14001988d              {
140019891                  if (1 == *(uint32_t*)rbx_2)
140019891                      *(uint32_t*)rbx_2 = temp0_1;
140019891                  else
140019891                      *(uint32_t*)rbx_2;
140019891                  
14001989e                  if (rbx_2[1] != 2)
1400197d0                      return 0x24;
1400197d0                  
1400198a4                  rbx_2[4] += 1;
1400197c4                  return 0;
14001988d              }
14001988d              
14001983c              if (*(uint64_t*)((char*)rbx_2 + 8))
14001983c              {
140019845              label_140019845:
140019845                  
140019845                  while (true)
140019845                  {
140019845                      int32_t temp0_2 = *(uint32_t*)rbx_2;
140019845                      *(uint32_t*)rbx_2 = 2;
140019845                      
140019849                      if (!temp0_2)
140019849                          break;
140019849                      
140019855                      int32_t rax_12 = _pthread_wait_for_single_object(
140019855                          *(uint64_t*)((char*)rbx_2 + 8), rbp);
140019855                      
14001985c                      if (rax_12)
14001985c                      {
14001986d                          if (rax_12 != 0x102)
14001986d                              return 0x16;
14001986d                          
14001987a                          return 0x8a;
14001985c                      }
140019845                  }
140019845                  
140019849                  goto label_1400197c0;
14001983c              }
14001983c              
1400198ba              HANDLE hObject = CreateEventA(nullptr, 0, 0, nullptr);
1400198ba              
1400198c6              if (hObject)
1400198c6              {
1400198ca                  bool z_1;
1400198ca                  
1400198ca                  if (0 == *(uint64_t*)((char*)rbx_2 + 8))
1400198ca                  {
1400198ca                      *(uint64_t*)((char*)rbx_2 + 8) = hObject;
1400198ca                      z_1 = true;
1400198ca                  }
1400198ca                  else
1400198ca                  {
1400198ca                      *(uint64_t*)((char*)rbx_2 + 8);
1400198ca                      z_1 = false;
1400198ca                  }
1400198ca                  
1400198d0                  if (!z_1)
1400198d6                      CloseHandle(hObject);
1400198d6                  
1400198d0                  goto label_140019845;
1400198c6              }
1400198c6              
1400198f8              if (GetLastError() == ERROR_ACCESS_DENIED)
1400197d0                  return 1;
140019808          }
1400197a9      }
1400197a9      else
1400197a9      {
1400197ab      label_1400197ab:
1400197ab          
1400197ae          if (rbx_2)
1400197ae              goto label_1400197b7;
1400197a9      }
1400197a9      
140019819      return 0xc;
140019770  }

1400197d1                                                     0f 1f 80 00 00 00 00                                           .......
14001981a                                                                                66 0f 1f 44 00 00                            f..D..
14001982b                                   0f 1f 44 00 00                                                             ..D..
14001987b                                                                                   0f 1f 44 00 00                             ..D..
1400198ad                                         0f 1f 00                                                               ...
1400198e1     0f 1f 80 00 00 00 00                                                                           .......
140019903           66 66 2e 0f 1f 84 00 00 00 00 00 66 90                                                     ff.........f.

140019910    uint64_t pthread_mutex_unlock(int64_t* arg1)

140019910  {
140019915      int32_t* rdx = *(uint64_t*)arg1;
140019915      
140019920      if ((char*)rdx + 3 <= 3)
140019920      {
140019945          rdx = mutex_impl_init(arg1, rdx);
140019945          
14001994b          if (!rdx)
140019957              return 0xc;
140019920      }
140019920      else if (!rdx)
140019957          return 0xc;
140019957      
14001992e      if (rdx[1])
14001992e      {
140019982          uint64_t result = 0x16;
140019989          uint32_t rax_5;
140019989          int32_t rbx_1;
140019989          
140019989          if (*(uint32_t*)rdx)
140019989          {
14001998b              rbx_1 = rdx[5];
140019993              rax_5 = GetCurrentThreadId();
14001999b              result = 1;
140019989          }
140019989          
1400199a2          if (!*(uint32_t*)rdx || rbx_1 != rax_5)
140019977              return result;
140019977          
1400199a9          int32_t rax_6 = rdx[4];
1400199a9          
1400199ae          if (rax_6)
1400199ae          {
1400199bf              rdx[4] = rax_6 - 1;
1400199c2              return 0;
1400199ae          }
1400199ae          
1400199b0          rdx[5] = 0xffffffff;
14001992e      }
14001992e      
140019932      int32_t temp0_1 = *(uint32_t*)rdx;
140019932      *(uint32_t*)rdx = 0;
140019932      
140019937      if (temp0_1 != 2)
140019939          return 0;
140019939      
14001996c      BOOL rax_4;
14001996c      (uint8_t)rax_4 = !SetEvent(*(uint64_t*)((char*)rdx + 8));
14001996f      return (uint64_t)(uint8_t)rax_4;
140019910  }

14001993d                                                                                         0f 1f 00                               ...
140019958                                                                          0f 1f 84 00 00 00 00 00                          ........
140019978                                                                          0f 1f 84 00 00 00 00 00                          ........
1400199c6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

1400199d0    int64_t pthread_mutex_trylock(int64_t* arg1)

1400199d0  {
1400199d6      int32_t* rbx = *(uint64_t*)arg1;
1400199d6      
1400199e1      if ((char*)rbx + 3 <= 3)
1400199e1      {
140019a18          rbx = mutex_impl_init(arg1, rbx);
140019a18          
140019a1e          if (!rbx)
140019a20              return 0xc;
1400199e1      }
1400199e1      else if (!rbx)
140019a20          return 0xc;
140019a20      
1400199ef      bool z_1;
1400199ef      
1400199ef      if (0 == *(uint32_t*)rbx)
1400199ef      {
1400199ef          *(uint32_t*)rbx = 1;
1400199ef          z_1 = true;
1400199ef      }
1400199ef      else
1400199ef      {
1400199ef          *(uint32_t*)rbx;
1400199ef          z_1 = false;
1400199ef      }
1400199ef      
1400199f3      if (z_1)
1400199f3      {
1400199fa          if (rbx[1])
140019a06              rbx[5] = GetCurrentThreadId();
140019a06          
1400199fc          return 0;
1400199f3      }
1400199f3      
140019a30      if (rbx[1] == 2 && rbx[5] == GetCurrentThreadId())
140019a30      {
140019a3f          rbx[4] += 1;
140019a43          return 0;
140019a30      }
140019a30      
140019a47      return 0x10;
1400199d0  }

140019a0d                                         0f 1f 00                                                               ...
140019a4e                                            66 90                                                                f.

140019a50    int64_t pthread_mutex_init(int64_t* arg1, int32_t* arg2)

140019a50  {
140019a53      int64_t rdx;
140019a53      
140019a53      if (!arg2)
140019a80          rdx = -1;
140019a53      else
140019a53      {
140019a55          int32_t rax_1 = *(uint32_t*)arg2;
140019a55          
140019a59          if ((uint8_t)rax_1 & 4)
140019a95              return 0x28;
140019a95          
140019a5b          int32_t rax_2 = rax_1 & 3;
140019a5e          rdx = -2;
140019a5e          
140019a68          if (rax_2 != 1)
140019a68          {
140019a6f              int64_t rdx_1;
140019a6f              (uint8_t)rdx_1 = rax_2 != 2;
140019a72              rdx = rdx_1 * 2 - 3;
140019a68          }
140019a53      }
140019a53      
140019a79      *(uint64_t*)arg1 = rdx;
140019a7c      return 0;
140019a50  }

140019a7d                                                                                         0f 1f 00                               ...
140019a89                             0f 1f 80 00 00 00 00                                                           .......
140019a96                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........

140019aa0    int64_t pthread_mutex_destroy(int64_t* arg1)

140019aa0  {
140019aa6      void* rsi = *(uint64_t*)arg1;
140019aa6      
140019ab4      if ((char*)rsi + 3 > 3)
140019ab4      {
140019ab6          HANDLE hObject = *(uint64_t*)((char*)rsi + 8);
140019ab6          
140019abd          if (hObject)
140019abf              CloseHandle(hObject);
140019abf          
140019ac8          free(rsi);
140019acd          *(uint64_t*)arg1 = 0;
140019ab4      }
140019ab4      
140019adc      return 0;
140019aa0  }

140019add                                                                                         0f 1f 00                               ...

140019ae0    int64_t pthread_mutexattr_init(int32_t* arg1)

140019ae0  {
140019ae2      *(uint32_t*)arg1 = 0;
140019ae8      return 0;
140019ae0  }

140019ae9                             0f 1f 80 00 00 00 00                                                           .......

140019af0    uint64_t pthread_mutexattr_destroy(int64_t arg1, int32_t arg2 @ rax) __pure

140019af0  {
140019af9      return (uint64_t)(arg2 - arg2) & 0x16;
140019af0  }

140019afa                                                                                66 0f 1f 44 00 00                            f..D..

140019b00    int64_t pthread_mutexattr_gettype(int32_t* arg1, int32_t* arg2)

140019b00  {
140019b08      if (!arg1 || !arg2)
140019b1d          return 0x16;
140019b1d      
140019b0f      *(uint32_t*)arg2 = *(uint32_t*)arg1 & 3;
140019b13      return 0;
140019b00  }

140019b14                                                              0f 1f 40 00                                              ..@.
140019b1e                                                                                            66 90                                f.

140019b20    int64_t pthread_mutexattr_settype(int32_t* arg1, int32_t arg2)

140019b20  {
140019b28      if (!arg1 || arg2 > 2)
140019b45          return 0x16;
140019b45      
140019b31      *(uint32_t*)arg1 = (*(uint32_t*)arg1 & 0xfffffffc) | arg2;
140019b35      return 0;
140019b20  }

140019b36                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
140019b46                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

140019b50    int64_t pthread_mutexattr_getpshared(int32_t* arg1, int32_t* arg2)

140019b50  {
140019b58      if (!arg1 || !arg2)
140019b75          return 0x16;
140019b75      
140019b62      *(uint32_t*)arg2 = *(uint32_t*)arg1 >> 2 & 1;
140019b66      return 0;
140019b50  }

140019b67                       66 0f 1f 84 00 00 00 00 00                                                         f........
140019b76                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........

140019b80    int64_t pthread_mutexattr_setpshared(int32_t* arg1, int32_t arg2)

140019b80  {
140019b88      if (!arg1 || arg2 > 1)
140019ba5          return 0x16;
140019ba5      
140019b8f      int64_t result = 0x28;
140019b8f      
140019b94      if (arg2 != 1)
140019b94          result = 0;
140019b94      
140019b97      *(uint32_t*)arg1 &= 0xfffffffb;
140019b9a      return result;
140019b80  }

140019b9b                                                                                   0f 1f 44 00 00                             ..D..
140019ba6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

140019bb0    int64_t pthread_mutexattr_getprotocol(int32_t* arg1, int32_t* arg2)

140019bb0  {
140019bb5      *(uint32_t*)arg2 = *(uint32_t*)arg1 & 0x18;
140019bb9      return 0;
140019bb0  }

140019bba                                                                                66 0f 1f 44 00 00                            f..D..

140019bc0    int64_t pthread_mutexattr_setprotocol(int32_t* arg1, int32_t arg2)

140019bc0  {
140019bd0      if ((arg2 & 0x18) != 0x18)
140019bdd          return 0x16;
140019bdd      
140019bd9      *(uint32_t*)arg1 = (*(uint32_t*)arg1 & 0xffffffe7) | arg2;
140019bdb      return 0;
140019bc0  }

140019bde                                                                                            66 90                                f.

140019be0    int64_t pthread_mutexattr_getprioceiling(int32_t* arg1, uint32_t* arg2)

140019be0  {
140019be5      *(uint32_t*)arg2 = *(uint32_t*)arg1 >> 5;
140019be9      return 0;
140019be0  }

140019bea                                66 0f 1f 44 00 00                                                            f..D..

140019bf0    int64_t pthread_mutexattr_setprioceiling(int32_t* arg1, int32_t arg2)

140019bf0  {
140019bfa      *(uint32_t*)arg1 = (*(uint32_t*)arg1 & 0x1f) + (arg2 << 5);
140019bfe      return 0;
140019bf0  }

140019bff                                                                                               90                                 .

140019c00    uint64_t SetThreadName_VEH(int64_t* arg1)

140019c00  {
140019c02      int32_t* rdx = *(uint64_t*)arg1;
140019c02      
140019c08      if (!rdx)
140019c17          return 0;
140019c17      
140019c12      int32_t rax;
140019c12      (uint8_t)rax = *(uint32_t*)rdx == 0x406d1388;
140019c15      return (uint64_t)-(rax);
140019c00  }

140019c18                                                                          0f 1f 84 00 00 00 00 00                          ........

140019c20    int64_t __pthread_get_pointer(int64_t arg1)

140019c20  {
140019c20      int64_t idListCnt_1 = idListCnt;
140019c20      
140019c2a      if (idListCnt_1)
140019c2a      {
140019c2c          int64_t* idList_1 = idList;
140019c33          int64_t r10_1 = idListCnt_1 - 1;
140019c37          int64_t r8_1 = 0;
140019c37          
140019c3e          if (idListCnt_1 != 1)
140019c3e          {
140019c5a              while (true)
140019c5a              {
140019c5a                  uint64_t rax_1 = (r8_1 + r10_1) >> 1;
140019c64                  void* rdx_3 = &idList_1[rax_1 * 2];
140019c67                  int64_t r9_1 = *(uint64_t*)((char*)rdx_3 + 8);
140019c67                  
140019c6e                  if (r9_1 == arg1)
140019c8b                      return *(uint64_t*)rdx_3;
140019c8b                  
140019c73                  if (arg1 < r9_1)
140019c73                  {
140019c4b                      if (rax_1 == r8_1)
140019c4b                          break;
140019c4b                      
140019c4d                      r10_1 = rax_1 - 1;
140019c4d                      
140019c54                      if (r10_1 < r8_1)
140019c54                          break;
140019c73                  }
140019c73                  else
140019c73                  {
140019c75                      r8_1 = rax_1 + 1;
140019c75                      
140019c7c                      if (r10_1 < r8_1)
140019c7c                          break;
140019c73                  }
140019c5a              }
140019c3e          }
140019c3e          else if (idList_1[1] == arg1)
140019c9b              return *(uint64_t*)idList_1;
140019c2a      }
140019c2a      
140019c80      return 0;
140019c20  }

140019c42        66 0f 1f 44 00 00                                                                            f..D..
140019c81     0f 1f 80 00 00 00 00                                                                           .......
140019c8c                                      0f 1f 40 00                                                              ..@.
140019c9c                                                                                      0f 1f 40 00                              ..@.

140019ca0    int64_t* enterOnceObject(int64_t arg1)

140019ca0  {
140019cb4      pthread_spin_lock(&_.data);
140019cb9      int64_t* once_obj_1 = once_obj;
140019cb9      
140019cc3      if (once_obj_1)
140019cc3      {
140019cdf          while (true)
140019cdf          {
140019cdf              if (*(uint64_t*)once_obj_1 == arg1)
140019cdf              {
140019ce1                  once_obj_1[2] += 1;
140019ce1                  goto label_140019ce8;
140019cdf              }
140019cdf              
140019cd0              int64_t* once_obj_2 = once_obj_1[3];
140019cd0              
140019cd7              if (!once_obj_2)
140019cd7              {
140019d0a                  int64_t* once_obj_3 = calloc(1, 0x20);
140019d0f                  *(uint64_t*)once_obj_3 = arg1;
140019d12                  once_obj_3[2] = 1;
140019d19                  once_obj_1[3] = once_obj_3;
140019d1d                  once_obj_1 = once_obj_3;
140019d1d                  break;
140019cd7              }
140019cd7              
140019cd9              once_obj_1 = once_obj_2;
140019cdf          }
140019cc3      }
140019cc3      else
140019cc3      {
140019d37          int64_t* once_obj_4 = calloc(1, 0x20);
140019d3c          once_obj_1 = once_obj_4;
140019d3f          *(uint64_t*)once_obj_4 = arg1;
140019d42          once_obj_4[2] = 1;
140019d49          once_obj = once_obj_4;
140019cc3      }
140019cc3      
140019d26      pthread_mutex_init(&once_obj_1[1], nullptr);
140019ce8  label_140019ce8:
140019ce8      pthread_spin_unlock(&_.data);
140019cf7      return once_obj_1;
140019ca0  }

140019cc7                       66 0f 1f 84 00 00 00 00 00                                                         f........
140019cf8                                                                          0f 1f 84 00 00 00 00 00                          ........
140019d52                                                        66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                    ff............

140019d60    int64_t __pthread_register_pointer(int64_t arg1)

140019d60  {
140019d70      if (arg1)
140019d70      {
140019d76          int64_t idListCnt_1 = idListCnt;
140019d7d          int64_t idListMax_1 = idListMax;
140019d84          int64_t* idList_1 = idList;
140019d84          
140019d8e          if (idListCnt_1 < idListMax_1)
140019d8e              goto label_140019d94;
140019d8e          
140019e63          if (idListCnt_1)
140019e63          {
140019ea2              int64_t* idList_3 = realloc(idList, (idListMax_1 + 0x10) << 4);
140019eaa              idList_1 = idList_3;
140019eaa              
140019ead              if (idList_3)
140019ead              {
140019eaf                  idListMax = idListMax_1 + 0x10;
140019eb6                  idList = idList_3;
140019d94              label_140019d94:
140019d94                  int64_t idListNextId_1 = idListNextId;
140019da8              label_140019da8:
140019da8                  idListNextId_1 += 1;
140019daf                  idListNextId = idListNextId_1;
140019daf                  
140019db6                  if (idListNextId_1 & 0x4000000000000000)
140019db6                  {
140019db8                  label_140019db8:
140019db8                      idListNextId = 1;
140019dc3                      idListNextId_1 = 1;
140019dc3                      goto label_140019dcb;
140019db6                  }
140019db6                  
140019def                  int64_t idListCnt_2;
140019def                  
140019def                  while (true)
140019def                  {
140019def                      if (!idListNextId_1)
140019def                          goto label_140019da8;
140019def                      
140019dcb                  label_140019dcb:
140019dcb                      
140019dd3                      if (!__pthread_get_pointer(idListNextId_1))
140019dd3                      {
140019dfb                          if (!idListCnt_1)
140019dfb                              goto label_140019e3c;
140019dfb                          
140019e00                          idListCnt_2 = idListCnt_1;
140019e07                          break;
140019dd3                      }
140019dd3                      
140019ddc                      idListNextId_1 = idListNextId + 1;
140019de3                      idListNextId = idListNextId_1;
140019de3                      
140019dea                      if (idListNextId_1 & 0x4000000000000000)
140019dea                          goto label_140019db8;
140019def                  }
140019def                  
140019e1e              label_140019e1e:
140019e23                  int64_t* idList_4;
140019e23                  
140019e23                  if (idListNextId_1 >= idList_1[idListCnt_1 * 2 - 1])
140019e23                  {
140019e25                      idList_4 = &idList_1[idListCnt_1 * 2];
140019e25                      
140019e2c                      if (idListCnt_1 != idListCnt_2)
140019e2c                          goto label_140019ee4;
140019e2c                      
140019e2c                      goto label_140019e32;
140019e23                  }
140019e23                  
140019e14                  int64_t idListCnt_3 = idListCnt_2;
140019e14                  idListCnt_2 -= 1;
140019e14                  
140019e18                  if (idListCnt_3 == 1)
140019e18                  {
140019ec8                      idList_4 = idList_1;
140019ee4                  label_140019ee4:
140019ee4                      memmove(&idList_1[(idListCnt_2 + 1) * 2], idList_4, 
140019ee4                          (idListCnt_1 - idListCnt_2) << 4);
140019e32                  label_140019e32:
140019e32                      idList_1 = idList_4;
140019e3c                  label_140019e3c:
140019e3c                      idList_1[1] = idListNextId_1;
140019e41                      *(uint64_t*)idList_1 = arg1;
140019e45                      idListCnt = idListCnt_1 + 1;
140019e56                      return idListNextId_1;
140019e18                  }
140019ead              }
140019e63          }
140019e63          else
140019e63          {
140019e6a              int64_t* idList_2 = malloc(0x100);
140019e72              idList_1 = idList_2;
140019e72              
140019e75              if (idList_2)
140019e75              {
140019e77                  idListMax = 0x10;
140019e82                  idList = idList_2;
140019e89                  goto label_140019d94;
140019e75              }
140019e63          }
140019d70      }
140019d70      
140019eff      return 0;
140019d60  }

140019df3                                                           0f 1f 44 00 00                                             ..D..
140019e09                             0f 1f 80 00 00 00 00                                                           .......
140019e57                                                                       66 0f 1f 84 00 00 00 00 00                         f........
140019e8e                                            66 90                                                                f.
140019ec2        66 0f 1f 44 00 00                                                                            f..D..
140019eee                                            66 90                                                                f.

140019f00    uint32_t pthread_tls_init()

140019f00  {
140019f04      uint32_t result = TlsAlloc();
140019f0d      _pthread_tls = result;
140019f0d      
140019f13      if (result == 0xffffffff)
140019f13          /* tailcall */
140019f13          return pthread_tls_init.cold();
140019f13      
140019f1d      return result;
140019f00  }

140019f1e                                                                                            66 90                                f.

140019f20    void replace_spin_keys.part.0() __noreturn

140019f20  {
140019f31      int64_t var_78;
140019f31      __builtin_strncpy(&var_78, "Error cleaning up spin_keys for thread ", 0x6b);
140019fdb      int64_t var_58;
140019fdb      _ultoa(GetCurrentThreadId(), &*(uint64_t*)((char*)var_58)[7], 0xa);
140019fe6      int64_t* lpOutputString;
140019fe6      
140019fe6      if (!*(uint8_t*)((char*)var_58)[7])
140019fe6      {
14001a02a          lpOutputString = &var_78;
14001a015          *(uint8_t*)(&var_78 + 0x27) = 0xa;
14001a01a          *(uint8_t*)(&var_78 + (int64_t)0x28) = 0;
140019fe6      }
140019fe6      else
140019fe6      {
140019fe8          lpOutputString = &var_78;
140019fed          int64_t rax_1 = 0x28;
140019fed          
14001a006          while (*(uint8_t*)(&var_78 + rax_1))
14001a006          {
140019ff8              rax_1 += 1;
140019ff8              
14001a000              if (rax_1 == 0x6b)
14001a000                  goto label_14001a01f;
14001a006          }
14001a006          
14001a00e          if ((uint32_t)rax_1 != 0x6a)
14001a00e          {
14001a015              *(uint8_t*)(&var_78 + (int64_t)(uint32_t)rax_1) = 0xa;
14001a01a              *(uint8_t*)(&var_78 + (int64_t)((uint32_t)rax_1 + 1)) = 0;
14001a00e          }
140019fe6      }
140019fe6      
14001a01f  label_14001a01f:
14001a01f      OutputDebugStringA(lpOutputString);
14001a025      abort();
14001a025      /* no return */
140019f20  }

140019ff4                                                              0f 1f 40 00                                              ..@.
14001a03b                                                                                   0f 1f 44 00 00                             ..D..

14001a040    int64_t leaveOnceObject.part.0(void* arg1)

14001a040  {
14001a054      pthread_spin_lock(&_.data);
14001a059      void* once_obj_1 = once_obj;
14001a06c      void* const once_obj_2;
14001a06c      
14001a06c      if (!once_obj_1 || once_obj_1 == arg1)
14001a110          once_obj_2 = nullptr;
14001a06c      else
14001a06c      {
14001a087          do
14001a087          {
14001a078              once_obj_2 = once_obj_1;
14001a07b              once_obj_1 = *(uint64_t*)((char*)once_obj_1 + 0x18);
14001a07b              
14001a082              if (!once_obj_1)
14001a082                  goto label_14001a0f8;
14001a087          } while (once_obj_1 != arg1);
14001a06c      }
14001a06c      
14001a08c      if (!once_obj_1)
14001a08c      {
14001a0f8      label_14001a0f8:
14001a0f8          fprintf(__acrt_iob_func(2), "%p not found?!?!\n", arg1);
14001a107          /* tailcall */
14001a107          return pthread_spin_unlock(&_.data);
14001a08c      }
14001a08c      
14001a08e      int32_t temp0 = *(uint32_t*)((char*)arg1 + 0x10);
14001a08e      *(uint32_t*)((char*)arg1 + 0x10) -= 1;
14001a08e      
14001a092      if (temp0 != 1)
14001a09e          /* tailcall */
14001a09e          return pthread_spin_unlock(&_.data);
14001a09e      
14001a0ac      pthread_mutex_destroy((char*)arg1 + 8);
14001a0b4      int64_t rax_1 = *(uint64_t*)((char*)arg1 + 0x18);
14001a0b4      
14001a0b8      if (!once_obj_2)
14001a0d5          once_obj = rax_1;
14001a0b8      else
14001a0ba          *(uint64_t*)((char*)once_obj_2 + 0x18) = rax_1;
14001a0ba      
14001a0c1      free(arg1);
14001a0d0      /* tailcall */
14001a0d0      return pthread_spin_unlock(&_.data);
14001a040  }

14001a0a3           0f 1f 44 00 00                                                                             ..D..
14001a0de                                                                                            66 90                                f.
14001a10c                                      0f 1f 40 00                                                              ..@.
14001a117                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001a120    uint64_t _pthread_once_cleanup(void* arg1)

14001a120  {
14001a12c      uint64_t result = pthread_mutex_unlock((char*)arg1 + 8);
14001a12c      
14001a134      if (!arg1)
14001a14d          return result;
14001a14d      
14001a13e      /* tailcall */
14001a13e      return leaveOnceObject.part.0(arg1);
14001a120  }

14001a143           0f 1f 44 00 00                                                                             ..D..
14001a14e                                            66 90                                                                f.

14001a150    void* const pop_pthread_mem()

14001a150  {
14001a161      pthread_mutex_lock(&mtx_pthr_locked);
14001a166      void* const pthr_root_1 = pthr_root;
14001a166      
14001a170      if (!pthr_root_1)
14001a170      {
14001a1d2          void* pthr_root_2 = calloc(1, 0x1e0);
14001a1d2          
14001a1dd          if (pthr_root_2)
14001a1dd          {
14001a1e2              int64_t rax_3 = __pthread_register_pointer(pthr_root_2);
14001a1e2              
14001a1ea              if (!rax_3)
14001a213                  free(pthr_root_2);
14001a1ea              else
14001a1ea              {
14001a1ec                  *(uint64_t*)((char*)pthr_root_2 + 0x1d8) = rax_3;
14001a1f3                  pthr_root_1 = pthr_root_2;
14001a1ea              }
14001a1dd          }
14001a170      }
14001a170      else
14001a170      {
14001a175          int64_t rax = __pthread_register_pointer(pthr_root_1);
14001a17d          *(uint64_t*)((char*)pthr_root_1 + 0x1d8) = rax;
14001a17d          
14001a184          if (!rax)
14001a1c0              pthr_root_1 = nullptr;
14001a184          else
14001a184          {
14001a186              int64_t rax_1 = *(uint64_t*)((char*)pthr_root_1 + 0x1d0);
14001a190              pthr_root = rax_1;
14001a190              
14001a197              if (!rax_1)
14001a200                  pthr_last = 0;
14001a200              
14001a199              *(uint64_t*)((char*)pthr_root_1 + 0x1d0) = 0;
14001a184          }
14001a170      }
14001a170      
14001a1a7      pthread_mutex_unlock(&mtx_pthr_locked);
14001a1b6      return pthr_root_1;
14001a150  }

14001a1b7                                                                       66 0f 1f 84 00 00 00 00 00                         f........
14001a1c4              0f 1f 40 00                                                                              ..@.
14001a1f8                                                                          0f 1f 84 00 00 00 00 00                          ........
14001a20d                                         0f 1f 00                                                               ...
14001a21a                                                                                66 0f 1f 44 00 00                            f..D..

14001a220    int64_t push_pthread_mem.part.0(void* arg1)

14001a220  {
14001a235      pthread_mutex_lock(&mtx_pthr_locked);
14001a23a      int64_t r11 = *(uint64_t*)((char*)arg1 + 0x1d8);
14001a23a      
14001a244      if (r11)
14001a244      {
14001a2b0          int64_t idListCnt_1 = idListCnt;
14001a2b0          
14001a2ba          if (idListCnt_1)
14001a2ba          {
14001a2c0              int64_t idList_1 = idList;
14001a2c7              int64_t rdx_2 = 0;
14001a2c9              int64_t rcx_4 = idListCnt_1 - 1;
14001a2c9              
14001a2e0              do
14001a2e0              {
14001a2ea                  uint64_t rax_3 = (rcx_4 + rdx_2) >> 1;
14001a2f0                  uint64_t r10_3 = rax_3 << 4;
14001a2f4                  void* r9_2 = idList_1 + r10_3;
14001a2f9                  int64_t temp0_1 = *(uint64_t*)((char*)r9_2 + 8);
14001a2f9                  
14001a2fd                  if (r11 == temp0_1)
14001a2fd                  {
14001a327                      if (rax_3 + 1 < idListCnt_1)
14001a327                      {
14001a36f                          memmove(r9_2, idList_1 + r10_3 + 0x10, 
14001a36f                              (idListCnt_1 - (rax_3 + 1)) << 4);
14001a374                          idListCnt = idListCnt_1 - 1;
14001a327                      }
14001a327                      else
14001a327                      {
14001a32c                          idListCnt = idListCnt_1 - 1;
14001a32c                          
14001a333                          if (idListCnt_1 == 1)
14001a333                          {
14001a33c                              free(idList_1);
14001a341                              idListMax = 0;
14001a34c                              idListCnt = 0;
14001a333                          }
14001a327                      }
14001a327                      
14001a327                      break;
14001a2fd                  }
14001a2fd                  
14001a2ff                  if (r11 < temp0_1)
14001a2ff                  {
14001a2d3                      if (rax_3 == rdx_2)
14001a2d3                          break;
14001a2d3                      
14001a2d9                      rcx_4 = rax_3 - 1;
14001a2ff                  }
14001a2ff                  else
14001a301                      rdx_2 = rax_3 + 1;
14001a2e0              } while (rcx_4 >= rdx_2);
14001a2ba          }
14001a244      }
14001a244      
14001a246      int64_t rcx = *(uint64_t*)((char*)arg1 + 0x50);
14001a246      
14001a24d      if (rcx)
14001a24f          free(rcx);
14001a24f      
14001a254      int64_t rcx_1 = *(uint64_t*)((char*)arg1 + 0x58);
14001a254      
14001a25b      if (rcx_1)
14001a25d          free(rcx_1);
14001a25d      
14001a262      int64_t rcx_2 = *(uint64_t*)((char*)arg1 + 0x60);
14001a262      
14001a269      if (rcx_2)
14001a26b          free(rcx_2);
14001a26b      
14001a27a      __builtin_memset(arg1, 0, 0x1e0);
14001a27d      void* pthr_last_1 = pthr_last;
14001a27d      
14001a287      if (!pthr_last_1)
14001a310          pthr_root = arg1;
14001a287      else
14001a28d          *(uint64_t*)((char*)pthr_last_1 + 0x1d0) = arg1;
14001a28d      
14001a297      pthr_last = arg1;
14001a2a6      /* tailcall */
14001a2a6      return pthread_mutex_unlock(&mtx_pthr_locked);
14001a220  }

14001a2ab                                   0f 1f 44 00 00                                                             ..D..
14001a2ce                                            66 90                                                                f.
14001a307                       66 0f 1f 84 00 00 00 00 00                                                         f........
14001a31c                                                                                      0f 1f 40 00                              ..@.
14001a35c                                                                                      0f 1f 40 00                              ..@.

14001a380    void push_pthread_mem(void* arg1)

14001a380  {
14001a38d      if (arg1 && !*(uint64_t*)((char*)arg1 + 0x1d0))
14001a390          /* tailcall */
14001a390          return push_pthread_mem.part.0(arg1);
14001a380  }

14001a395                                                                 66 66 2e 0f 1f 84 00 00 00 00 00                       ff.........

14001a3a0    void _pthread_once_raw.constprop.0.isra.0()

14001a3a0  {
14001a3af      if (_pthread_tls_once == 1)
14001a3af          return;
14001a3af      
14001a3bb      int64_t* rax_1 = enterOnceObject(&_pthread_tls_once);
14001a3ca      pthread_mutex_lock(&rax_1[1]);
14001a3cf      int32_t _pthread_tls_once_1 = _pthread_tls_once;
14001a3cf      
14001a3d7      if (!_pthread_tls_once_1)
14001a3d7      {
14001a3d9          uint32_t rax_2 = TlsAlloc();
14001a3e2          _pthread_tls = rax_2;
14001a3e2          
14001a3e8          if (rax_2 == 0xffffffff)
14001a3e8              /* tailcall */
14001a3e8              return _pthread_once_raw.constprop.0.isra.0.cold();
14001a3e8          
14001a3ee          _pthread_tls_once = 1;
14001a3d7      }
14001a3d7      else if (_pthread_tls_once_1 != 1)
14001a448          fprintf(__acrt_iob_func(2), " once %p is %d\n", &_pthread_tls_once);
14001a448      
14001a3fb      pthread_mutex_unlock(&rax_1[1]);
14001a3fb      
14001a403      if (rax_1)
14001a410          /* tailcall */
14001a410          return leaveOnceObject.part.0(rax_1);
14001a3a0  }

14001a415                                                                 0f 1f 00                                               ...
14001a421     0f 1f 80 00 00 00 00                                                                           .......
14001a44f                                               90                                                                 .

14001a450    void* __pthread_self_lite.part.0()

14001a450  {
14001a458      void* lpTlsValue = pop_pthread_mem();
14001a458      
14001a471      if (!_.CRT$XLF || !lpTlsValue)
14001a575          return 0;
14001a575      
14001a477      *(uint32_t*)((char*)lpTlsValue + 0x44) = 1;
14001a491      *(uint32_t*)((char*)lpTlsValue + 0x70) = GetCurrentThreadId();
14001a494      HANDLE rax_1 = CreateEventA(nullptr, 1, 0, nullptr);
14001a49a      *(uint64_t*)((char*)lpTlsValue + 0x38) = -1;
14001a4a6      *(uint64_t*)((char*)lpTlsValue + 0x30) = rax_1;
14001a4bf      *(uint64_t*)((char*)lpTlsValue + 0x68) = -1;
14001a4c7      *(uint32_t*)((char*)lpTlsValue + 0xb8) = 0;
14001a4d1      *(uint64_t*)((char*)lpTlsValue + 0x28) = 0;
14001a4d9      HANDLE hTargetProcessHandle = GetCurrentProcess();
14001a4de      HANDLE hSourceHandle = GetCurrentThread();
14001a4de      
14001a516      if (!DuplicateHandle(GetCurrentProcess(), hSourceHandle, hTargetProcessHandle, 
14001a516              (char*)lpTlsValue + 0x28, 0, 0, DUPLICATE_SAME_ACCESS))
14001a516          /* tailcall */
14001a516          return __pthread_self_lite.part.0.cold();
14001a516      
14001a520      int32_t rax_4 = GetThreadPriority(*(uint64_t*)((char*)lpTlsValue + 0x28));
14001a526      uint32_t _pthread_tls_1 = _pthread_tls;
14001a52f      *(uint32_t*)((char*)lpTlsValue + 0xbc) = 0;
14001a539      *(uint32_t*)((char*)lpTlsValue + 0xc0) = rax_4;
14001a549      *(uint8_t*)((char*)lpTlsValue + 0x40) =
14001a549          (*(uint8_t*)((char*)lpTlsValue + 0x40) & 0xcf) | 0x10;
14001a549      
14001a554      if (!TlsSetValue(_pthread_tls_1, lpTlsValue))
14001a57c          /* tailcall */
14001a57c          return __pthread_self_lite.part.0.cold();
14001a57c      
14001a561      return lpTlsValue;
14001a450  }

14001a562        66 0f 1f 44 00 00                                                                            f..D..
14001a57b                                                                                   90                                         .
14001a581     66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00                                                   ff...........@.

14001a590    int64_t __pthread_self_lite()

14001a590  {
14001a594      _pthread_once_raw.constprop.0.isra.0();
14001a59f      int64_t result = TlsGetValue(_pthread_tls);
14001a59f      
14001a5a8      if (!result)
14001a5b4          /* tailcall */
14001a5b4          return __pthread_self_lite.part.0();
14001a5b4      
14001a5ae      return result;
14001a590  }

14001a5af                                               90                                                                 .
14001a5b9                                                                             0f 1f 80 00 00 00 00                           .......

14001a5c0    void _pthread_cleanup_dest.part.0(int64_t arg1)

14001a5c0  {
14001a5d6      if (!arg1)
14001a5d6          return;
14001a5d6      
14001a5e6      pthread_mutex_lock(&mtx_pthr_locked);
14001a5ee      void* rax_1 = __pthread_get_pointer(arg1);
14001a5f9      pthread_mutex_unlock(&mtx_pthr_locked);
14001a5f9      
14001a601      if (!rax_1)
14001a601          return;
14001a601      
14001a60b      int32_t i_1 = 0x100;
14001a6ca      int32_t i;
14001a6ca      
14001a6ca      do
14001a6ca      {
14001a623          pthread_spin_lock((char*)rax_1 + 0x68);
14001a623          
14001a62d          if (!*(uint32_t*)((char*)rax_1 + 0x48))
14001a6fb              /* tailcall */
14001a6fb              return pthread_spin_unlock((char*)rax_1 + 0x68);
14001a6fb          
14001a633          int32_t r14_1 = 0;
14001a636          int32_t rbx_1 = 0;
14001a636          
14001a64c          while (true)
14001a64c          {
14001a64c              uint64_t rsi_1 = (uint64_t)rbx_1;
14001a64c              
14001a652              if (!*(uint8_t*)(*(uint64_t*)((char*)rax_1 + 0x58) + rsi_1))
14001a652              {
14001a640                  rbx_1 += 1;
14001a640                  
14001a646                  if (rbx_1 >= *(uint32_t*)((char*)rax_1 + 0x48))
14001a646                      break;
14001a652              }
14001a652              else
14001a652              {
14001a65b                  int64_t r15_1 =
14001a65b                      *(uint64_t*)(*(uint64_t*)((char*)rax_1 + 0x50) + (rsi_1 << 3));
14001a65f                  pthread_rwlock_rdlock(&_pthread_key_lock);
14001a66b                  bool cond:1_1 = *(uint64_t*)(_.bss + (rsi_1 << 3)) <= 1;
14001a674                  *(uint64_t*)(*(uint64_t*)((char*)rax_1 + 0x50) + (rsi_1 << 3)) = 0;
14001a680                  *(uint8_t*)(*(uint64_t*)((char*)rax_1 + 0x58) + rsi_1) = 0;
14001a680                  
14001a684                  if (!cond:1_1)
14001a684                  {
14001a689                      r14_1 = 1;
14001a68f                      pthread_spin_unlock((char*)rax_1 + 0x68);
14001a69e                      (*(uint64_t*)(_.bss + (rsi_1 << 3)))(r15_1);
14001a6a4                      pthread_spin_lock((char*)rax_1 + 0x68);
14001a684                  }
14001a684                  
14001a6ac                  rbx_1 += 1;
14001a6af                  pthread_rwlock_unlock(&_pthread_key_lock);
14001a6af                  
14001a6b7                  if (rbx_1 >= *(uint32_t*)((char*)rax_1 + 0x48))
14001a6b7                      break;
14001a652              }
14001a64c          }
14001a64c          
14001a6bc          pthread_spin_unlock((char*)rax_1 + 0x68);
14001a6bc          
14001a6c4          if (!r14_1)
14001a6c4              break;
14001a6c4          
14001a6c6          i = i_1;
14001a6c6          i_1 -= 1;
14001a6ca      } while (i != 1);
14001a5c0  }

14001a63a                                                                                66 0f 1f 44 00 00                            f..D..
14001a6e1     0f 1f 80 00 00 00 00                                                                           .......

14001a700    void pthread_create_wrapper(int32_t* arg1) __noreturn

14001a700  {
14001a71a      pthread_mutex_lock(&mtx_pthr_locked);
14001a72a      pthread_mutex_lock(&arg1[0xe]);
14001a72f      _pthread_once_raw.constprop.0.isra.0();
14001a73e      TlsSetValue(_pthread_tls, arg1);
14001a751      arg1[0x1c] = GetCurrentThreadId();
14001a754      pthread_mutex_unlock(&arg1[0xe]);
14001a754      
14001a76e      if (__intrinsic_setjmpex(&arg1[0x34]))
14001a847          pthread_mutex_lock(&mtx_pthr_locked);
14001a76e      else
14001a76e      {
14001a77b          pthread_mutex_unlock(&mtx_pthr_locked);
14001a784          int64_t rax_5 = *(uint64_t*)((char*)arg1 + 0x10);
14001a78b          int64_t rbx_1;
14001a78b          
14001a78b          if (!rax_5)
14001a851              rbx_1 = 0x80;
14001a78b          else
14001a79b              rbx_1 = rax_5(*(uint64_t*)((char*)arg1 + 8), arg1);
14001a79b          
14001a7a7          pthread_mutex_lock(&mtx_pthr_locked);
14001a7b0          int64_t rcx_5 = *(uint64_t*)((char*)arg1 + 0x1d8);
14001a7b7          *(uint64_t*)((char*)arg1 + 8) = rbx_1;
14001a7b7          
14001a7be          if (rcx_5)
14001a7c0              _pthread_cleanup_dest.part.0(rcx_5);
14001a76e      }
14001a76e      
14001a7c9      void* rbx_2 = &arg1[0xe];
14001a7d0      pthread_mutex_lock(rbx_2);
14001a7d9      HANDLE hObject = *(uint64_t*)((char*)arg1 + 0x30);
14001a7dd      int32_t _ReturnCode = (int32_t)*(uint64_t*)((char*)arg1 + 8);
14001a7dd      
14001a7e4      if (hObject)
14001a7e6          CloseHandle(hObject);
14001a7e6      
14001a7f2      bool cond:0 = !*(uint64_t*)((char*)arg1 + 0x28);
14001a7f7      *(uint64_t*)((char*)arg1 + 0x30) = 0;
14001a7f7      
14001a7fb      if (!cond:0)
14001a7fb      {
14001a800          pthread_mutex_unlock(rbx_2);
14001a808          pthread_mutex_destroy(rbx_2);
14001a811          *(uint64_t*)((char*)arg1 + 0x38) = -1;
14001a819          arg1[0x2f] = 1;
14001a819          goto label_14001a823;
14001a7fb      }
14001a7fb      
14001a86a      while (true)
14001a86a      {
14001a86a          *(uint32_t*)arg1 = 0xdeadbeef;
14001a870          pthread_mutex_unlock(rbx_2);
14001a878          pthread_mutex_destroy(rbx_2);
14001a881          push_pthread_mem(arg1);
14001a88e          TlsSetValue(_pthread_tls, nullptr);
14001a823      label_14001a823:
14001a823          rbx_2 = &mtx_pthr_locked;
14001a82d      label_14001a82d:
14001a82d          
14001a834          if (!pthread_mutex_unlock(&mtx_pthr_locked))
14001a834              break;
14001a834          
14001a85d          _endthreadex(_ReturnCode);
14001a86a      }
14001a86a      
14001a838      Sleep(0);
14001a83e      goto label_14001a82d;
14001a700  }

14001a896                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........

14001a8a0    int64_t _TLS_Entry_2(int64_t arg1, int32_t arg2, int64_t arg3)

14001a8a0  {
14001a8aa      if (arg2)
14001a8aa      {
14001a8cb          if (arg2 == 1)
14001a8cb          {
14001a9c2              SetThreadName_VEH_handle = AddVectoredExceptionHandler(1, SetThreadName_VEH);
14001a9d6              return 1;
14001a8cb          }
14001a8cb          
14001a8d4          if (arg2 == 3)
14001a8d4          {
14001a8d6              uint32_t _pthread_tls_1 = _pthread_tls;
14001a8d6              
14001a8df              if (_pthread_tls_1 != 0xffffffff)
14001a8df              {
14001a8e1                  int32_t* rax_2 = TlsGetValue(_pthread_tls_1);
14001a8e1                  
14001a8ed                  if (rax_2)
14001a8ed                  {
14001a8fb                      if (rax_2[0x10] & 0x30)
14001a8fb                      {
14001a901                          int64_t rcx = *(uint64_t*)((char*)rax_2 + 0x1d8);
14001a901                          
14001a90b                          if (rcx)
14001a90d                              _pthread_cleanup_dest.part.0(rcx);
14001a90d                          
14001a912                          HANDLE hObject = *(uint64_t*)((char*)rax_2 + 0x28);
14001a912                          
14001a919                          if (hObject)
14001a919                          {
14001a922                              CloseHandle(hObject);
14001a924                              HANDLE hObject_1 = *(uint64_t*)((char*)rax_2 + 0x30);
14001a924                              
14001a92b                              if (hObject_1)
14001a92d                                  CloseHandle(hObject_1);
14001a92d                              
14001a933                              *(uint128_t*)((char*)rax_2 + 0x28) = {0};
14001a919                          }
14001a919                          
14001a919                          goto label_14001a93a;
14001a8fb                      }
14001a8fb                      
14001a9e0                      HANDLE hObject_2 = *(uint64_t*)((char*)rax_2 + 0x30);
14001a9e0                      
14001a9ec                      if (!rax_2[0x2f])
14001a9ec                      {
14001a9f1                          if (hObject_2)
14001a9f3                              CloseHandle(hObject_2);
14001a9f3                          
14001a9f9                          int64_t rcx_4 = *(uint64_t*)((char*)rax_2 + 0x1d8);
14001aa00                          *(uint64_t*)((char*)rax_2 + 0x30) = 0;
14001aa08                          rax_2[0x2f] = 1;
14001aa08                          
14001aa15                          if (rcx_4)
14001aa17                              _pthread_cleanup_dest.part.0(rcx_4);
14001aa17                          
14001aa20                          if (!(rax_2[0x11] & 4))
14001aa20                          {
14001aa8b                              pthread_mutex_destroy(&rax_2[0xe]);
14001aa78                              *(uint64_t*)((char*)rax_2 + 0x68) = -1;
14001aa20                          }
14001aa20                          else
14001aa20                          {
14001aa22                              HANDLE hObject_3 = *(uint64_t*)((char*)rax_2 + 0x28);
14001aa26                              *(uint32_t*)rax_2 = 0xdeadbeef;
14001aa26                              
14001aa2f                              if (!hObject_3)
14001aa2f                              {
14001a93a                              label_14001a93a:
14001a93a                                  pthread_mutex_destroy(&rax_2[0xe]);
14001aa2f                              }
14001aa2f                              else
14001aa2f                              {
14001aa35                                  CloseHandle(hObject_3);
14001aa3b                                  *(uint64_t*)((char*)rax_2 + 0x28) = 0;
14001aa46                                  pthread_mutex_destroy(&rax_2[0xe]);
14001aa2f                              }
14001aa2f                              
14001a950                              bool cond:2_1 = !*(uint64_t*)((char*)rax_2 + 0x1d0);
14001a958                              *(uint64_t*)((char*)rax_2 + 0x68) = -1;
14001a958                              
14001a960                              if (cond:2_1)
14001aa95                                  push_pthread_mem.part.0(rax_2);
14001aa95                              
14001a96e                              TlsSetValue(_pthread_tls, nullptr);
14001aa20                          }
14001a9ec                      }
14001a9ec                      else if (!hObject_2)
14001aa53                      {
14001aa8b                          pthread_mutex_destroy(&rax_2[0xe]);
14001aa78                          *(uint64_t*)((char*)rax_2 + 0x68) = -1;
14001aa53                      }
14001aa53                      else
14001aa53                      {
14001aa55                          CloseHandle(hObject_2);
14001aa5b                          *(uint64_t*)((char*)rax_2 + 0x30) = 0;
14001aa66                          pthread_mutex_destroy(&rax_2[0xe]);
14001aa78                          *(uint64_t*)((char*)rax_2 + 0x68) = -1;
14001aa53                      }
14001a8ed                  }
14001a8df              }
14001a8d4          }
14001a8aa      }
14001a8aa      else if (!arg3)
14001a8af      {
14001a980          int64_t SetThreadName_VEH_handle_1 = SetThreadName_VEH_handle;
14001a980          
14001a98a          if (SetThreadName_VEH_handle_1)
14001a98a          {
14001a990              RemoveVectoredExceptionHandler(SetThreadName_VEH_handle_1);
14001a996              SetThreadName_VEH_handle = 0;
14001a98a          }
14001a8af      }
14001a8af      
14001a8c2      return 1;
14001a8a0  }

14001a8c3           0f 1f 44 00 00                                                                             ..D..
14001a979                                                                             0f 1f 80 00 00 00 00                           .......
14001a9a6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
14001a9d7                                                                       66 0f 1f 84 00 00 00 00 00                         f........
14001aa85                 0f 1f 00                                                                               ...
14001aaa4              90 66 66 2e 0f 1f 84 00 00 00 00 00                                                      .ff.........

14001aab0    int64_t __pth_gpointer_locked(int64_t arg1)

14001aab0  {
14001aab7      int64_t result = 0;
14001aab7      
14001aabf      if (arg1)
14001aabf      {
14001aacb          pthread_mutex_lock(&mtx_pthr_locked);
14001aadb          result = __pthread_get_pointer(arg1);
14001aade          pthread_mutex_unlock(&mtx_pthr_locked);
14001aabf      }
14001aabf      
14001aaed      return result;
14001aab0  }

14001aaee                                            66 90                                                                f.

14001aaf0    int64_t thread_print_set(int32_t arg1)

14001aaf0  {
14001aaf0      print_state = arg1;
14001aaf0  }

14001aaf7                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001ab00    int64_t thread_print(int64_t arg1)

14001ab00  {
14001ab0e      int32_t print_state_1 = print_state;
14001ab0e      
14001ab1e      if (!print_state_1)
14001abef          return print_state_1;
14001abef      
14001ab2c      if (!arg1)
14001ab2c      {
14001abf0          GetCurrentThreadId();
14001ac13          /* tailcall */
14001ac13          return printf("T%p %d %s\n", 0);
14001ab2c      }
14001ab2c      
14001ab3a      if (!arg1)
14001ab3a          /* tailcall */
14001ab3a          return thread_print.cold();
14001ab3a      
14001ab4a      pthread_mutex_lock(&mtx_pthr_locked);
14001ab52      void* rax_1 = __pthread_get_pointer(arg1);
14001ab5d      pthread_mutex_unlock(&mtx_pthr_locked);
14001ab62      int64_t r12_1 = *(uint64_t*)((char*)rax_1 + 0x28);
14001ab62      
14001ab6e      if (!arg1)
14001ab6e      {
14001edcc          *(uint32_t*)0;
14001edd3          trap(6);
14001ab6e      }
14001ab6e      
14001ab77      pthread_mutex_lock(&mtx_pthr_locked);
14001ab7f      int32_t* rax_2 = __pthread_get_pointer(arg1);
14001ab8a      pthread_mutex_unlock(&mtx_pthr_locked);
14001ab8f      *(uint32_t*)rax_2;
14001ab92      int64_t rdi_5 = 0;
14001ab94      GetCurrentThreadId();
14001ab94      
14001aba4      if (arg1)
14001aba4      {
14001aba9          pthread_mutex_lock(&mtx_pthr_locked);
14001abb9          rdi_5 = __pthread_get_pointer(arg1);
14001abbc          pthread_mutex_unlock(&mtx_pthr_locked);
14001aba4      }
14001aba4      
14001abc1      int64_t rdx;
14001abc1      int64_t var_40_1 = rdx;
14001abcf      int64_t var_48_1 = r12_1;
14001abdb      return printf("T%p %d V=%0X H=%p %s\n", rdi_5);
14001ab00  }

14001ac18                                                                          90 0f 1f 80 00 00 00 00                          ........

14001ac20    int64_t pthread_timechange_handler_np() __pure

14001ac20  {
14001ac22      return 0;
14001ac20  }

14001ac23           66 66 2e 0f 1f 84 00 00 00 00 00 66 90                                                     ff.........f.

14001ac30    uint64_t pthread_num_processors_np()

14001ac30  {
14001ac4d      int32_t rdx_1 = 1;
14001ac54      uint64_t processAffinityMask;
14001ac54      uint64_t systemAffinityMask[0x2];
14001ac54      
14001ac54      if (GetProcessAffinityMask(GetCurrentProcess(), &processAffinityMask, 
14001ac54          &systemAffinityMask))
14001ac54      {
14001ac56          uint64_t i = processAffinityMask;
14001ac56          
14001ac5e          if (i)
14001ac5e          {
14001ac60              rdx_1 = 0;
14001ac60              
14001ac72              do
14001ac72              {
14001ac6d                  rdx_1 += (uint32_t)i & 1;
14001ac6f                  i u>>= 1;
14001ac72              } while (i);
14001ac72              
14001ac7b              if (!rdx_1)
14001ac7b                  rdx_1 = 1;
14001ac5e          }
14001ac54      }
14001ac54      
14001ac84      return (uint64_t)rdx_1;
14001ac30  }

14001ac85                 66 66 2e 0f 1f 84 00 00 00 00 00                                                       ff.........

14001ac90    uint64_t pthread_set_num_processors_np(int32_t arg1)

14001ac90  {
14001aca6      int32_t rdi = arg1;
14001aca6      
14001aca8      if (!arg1)
14001aca8          rdi = 1;
14001aca8      
14001acba      uint64_t processAffinityMask;
14001acba      uint64_t systemAffinityMask[0x2];
14001acba      BOOL rax_1 = GetProcessAffinityMask(GetCurrentProcess(), &processAffinityMask, 
14001acba          &systemAffinityMask);
14001acc2      BOOL rbx = rax_1;
14001acc2      
14001acc4      if (rax_1)
14001acc4      {
14001acc6          uint64_t i = processAffinityMask;
14001acce          uint64_t dwProcessAffinityMask;
14001acce          
14001acce          if (!i)
14001acce          {
14001ad18              dwProcessAffinityMask = 0;
14001ad1a              rbx = 0;
14001acce          }
14001acce          else
14001acce          {
14001acd0              rbx = 0;
14001acd2              dwProcessAffinityMask = 0;
14001acd2              
14001aced              do
14001aced              {
14001acd8                  dwProcessAffinityMask *= 2;
14001acd8                  
14001ace1                  if (rdi > rbx && (uint8_t)i & 1)
14001ace1                  {
14001ace3                      dwProcessAffinityMask |= 1;
14001ace7                      rbx += 1;
14001ace1                  }
14001ace1                  
14001acea                  i u>>= 1;
14001aced              } while (i);
14001aced              
14001acef              processAffinityMask = 0;
14001acce          }
14001acce          
14001ad00          SetProcessAffinityMask(GetCurrentProcess(), dwProcessAffinityMask);
14001acc4      }
14001acc4      
14001ad10      return (uint64_t)rbx;
14001ac90  }

14001ad11                                                     0f 1f 80 00 00 00 00                                           .......
14001ad1e                                                                                            66 90                                f.

14001ad20    int64_t pthread_once(int32_t* arg1, int64_t arg2)

14001ad20  {
14001ad35      if (!arg2)
14001ae57          return 0x16;
14001ae57      
14001ad3e      if (*(uint32_t*)arg1 != 1)
14001ad3e      {
14001ad40          int64_t* rax_1 = enterOnceObject(arg1);
14001ad4f          pthread_mutex_lock(&rax_1[1]);
14001ad54          int32_t r12_1 = *(uint32_t*)arg1;
14001ad54          
14001ad5a          if (!r12_1)
14001ad5a          {
14001ad97              int64_t* var_40_1 = rax_1;
14001ad9c              uint64_t (* var_48)(void* arg1) = _pthread_once_cleanup;
14001ada1              _pthread_once_raw.constprop.0.isra.0();
14001adb3              void* rax_3 = TlsGetValue(_pthread_tls);
14001adb3              
14001adb9              if (!rax_3)
14001adb9              {
14001ae88                  rax_3 = __pthread_self_lite.part.0();
14001ae88                  
14001ae90                  if (!rax_3)
14001ae90                  {
14001ede4                      *(uint64_t*)0;
14001edec                      trap(6);
14001ae90                  }
14001adb9              }
14001adb9              
14001adbf              int64_t rax_4 = *(uint64_t*)((char*)rax_3 + 0x18);
14001adce              _pthread_once_raw.constprop.0.isra.0();
14001add9              void* rax_5 = TlsGetValue(_pthread_tls);
14001add9              
14001addf              if (!rax_5)
14001addf              {
14001ae70                  rax_5 = __pthread_self_lite.part.0();
14001ae70                  
14001ae78                  if (!rax_5)
14001ae78                  {
14001edf3                      *(uint64_t*)0 = &var_48;
14001edfb                      trap(6);
14001ae78                  }
14001addf              }
14001addf              
14001adea              *(uint64_t*)((char*)rax_5 + 0x18) = &var_48;
14001adee              int64_t var_68;
14001adee              int64_t var_68_2 = var_68;
14001adf4              arg2();
14001adf6              _pthread_once_raw.constprop.0.isra.0();
14001ae01              void* rax_6 = TlsGetValue(_pthread_tls);
14001ae01              
14001ae07              if (!rax_6)
14001ae07              {
14001ae60                  int64_t rcx_7;
14001ae60                  rax_6 = __pthread_self_lite.part.0();
14001ae60                  
14001ae68                  if (!rax_6)
14001ae6a                      /* tailcall */
14001ae6a                      return pthread_once.cold(rcx_7);
14001ae07              }
14001ae07              
14001ae0e              *(uint64_t*)((char*)rax_6 + 0x18) = rax_4;
14001ae12              *(uint32_t*)arg1 = 1;
14001ad5a          }
14001ad5a          else if (r12_1 != 1)
14001ae3b              fprintf(__acrt_iob_func(2), " once %p is %d\n", arg1);
14001ae3b          
14001ad69          pthread_mutex_unlock(&rax_1[1]);
14001ad69          
14001ad71          if (rax_1)
14001ad76              leaveOnceObject.part.0(rax_1);
14001ad3e      }
14001ad3e      
14001ad87      return 0;
14001ad20  }

14001ad88                          0f 1f 84 00 00 00 00 00                                                          ........
14001ae1d                                                                                         0f 1f 00                               ...
14001ae45                 0f 1f 00                                                                               ...
14001ae58                                                                          0f 1f 84 00 00 00 00 00                          ........
14001ae6f                                               90                                                                 .
14001ae83           0f 1f 44 00 00                                                                             ..D..
14001ae9b                                                                                   0f 1f 44 00 00                             ..D..

14001aea0    int64_t pthread_key_create(int32_t* arg1, int64_t arg2)

14001aea0  {
14001aeb4      int64_t rsi = arg2;
14001aeb4      
14001aeb7      if (!arg1)
14001b003          return 0x16;
14001b003      
14001aec7      pthread_rwlock_wrlock(&_pthread_key_lock);
14001aecc      int32_t _pthread_key_sch_1 = _pthread_key_sch;
14001aed2      int32_t _pthread_key_max_1 = _pthread_key_max;
14001aeda      int64_t* _.bss_1;
14001aeda      int32_t _pthread_key_sch_2;
14001aeda      
14001aeda      if (_pthread_key_sch_1 < _pthread_key_max_1)
14001aeda      {
14001aee5          _.bss_1 = _.bss + ((uint64_t)_pthread_key_sch_1 << 3);
14001aee9          _pthread_key_sch_2 = _pthread_key_sch_1;
14001aee9          
14001aef9          do
14001aef9          {
14001aeff              if (!*(uint64_t*)_.bss_1)
14001aeff              {
14001af01              label_14001af01:
14001af01                  *(uint32_t*)arg1 = _pthread_key_sch_2;
14001af01                  
14001af0f                  if (!rsi)
14001af0f                      rsi = 1;
14001af0f                  
14001af13                  *(uint64_t*)_.bss_1 = rsi;
14001af16                  pthread_rwlock_unlock(&_pthread_key_lock);
14001af16                  goto label_14001af1b;
14001aeff              }
14001aeff              
14001aef0              _pthread_key_sch_2 += 1;
14001aef3              _.bss_1 = &_.bss_1[1];
14001aef9          } while (_pthread_key_max_1 != _pthread_key_sch_2);
14001aeda      }
14001aeda      
14001af32      if (_pthread_key_sch_1)
14001af32      {
14001af34          _.bss_1 = _.bss;
14001af3b          _pthread_key_sch_2 = 0;
14001af3b          
14001af49          do
14001af49          {
14001af4f              if (!*(uint64_t*)_.bss_1)
14001af4f                  goto label_14001af01;
14001af4f              
14001af40              _pthread_key_sch_2 += 1;
14001af43              _.bss_1 = &_.bss_1[1];
14001af49          } while (_pthread_key_sch_1 != _pthread_key_sch_2);
14001af32      }
14001af32      
14001af5e      int64_t rax_5;
14001af5e      int32_t rdx_1;
14001af5e      
14001af5e      if (_pthread_key_max_1 != 0x100000)
14001af5e      {
14001af66          rdx_1 = 0x100000;
14001af76          int32_t rax_4 = _pthread_key_max_1 * 2;
14001af76          
14001af78          if (_pthread_key_max_1 == -(_pthread_key_max_1))
14001af78              rax_4 = _pthread_key_max_1 + 1;
14001af78          
14001af7e          if (rax_4 <= 0x100000)
14001af7e              rdx_1 = rax_4;
14001af7e          
14001af8b          rax_5 = realloc(_.bss, (int64_t)rdx_1 << 3);
14001af5e      }
14001af5e      
14001af96      if (_pthread_key_max_1 == 0x100000 || !rax_5)
14001af96      {
14001b007          pthread_rwlock_unlock(&_pthread_key_lock);
14001b00c          return 0xc;
14001af96      }
14001af96      
14001afaa      int64_t* rax_7 = memset(rax_5 + ((uint64_t)_pthread_key_max_1 << 3), 0, 
14001afaa          (uint64_t)(rdx_1 - _pthread_key_max_1) << 3);
14001afb2      _.bss = rax_5;
14001afc1      *(uint32_t*)arg1 = _pthread_key_max_1;
14001afc1      
14001afc4      if (!rsi)
14001afc4          rsi = 1;
14001afc4      
14001afc8      _pthread_key_sch = _pthread_key_max_1 + 1;
14001afcf      _pthread_key_max = rdx_1;
14001afd6      *(uint64_t*)rax_7 = rsi;
14001afdc      pthread_rwlock_unlock(&_pthread_key_lock);
14001af1b  label_14001af1b:
14001af1b      return 0;
14001aea0  }

14001aeed                                         0f 1f 00                                                               ...
14001af2c                                      0f 1f 40 00                                                              ..@.
14001af3f                                                                                               90                                 .
14001af53                                                           0f 1f 44 00 00                                             ..D..
14001afe6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
14001b016                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........

14001b020    int64_t pthread_key_delete(int32_t arg1)

14001b020  {
14001b045      if (arg1 >= _pthread_key_max || !_.bss)
14001b0fe          return 0x16;
14001b0fe      
14001b052      uint64_t rdi_1 = (uint64_t)arg1;
14001b05f      pthread_rwlock_wrlock(&_pthread_key_lock);
14001b06b      bool cond:1_1 = arg1 < _pthread_key_sch;
14001b071      *(uint64_t*)(_.bss + (rdi_1 << 3)) = 0;
14001b071      
14001b079      if (cond:1_1)
14001b100          _pthread_key_sch = arg1;
14001b100      
14001b089      pthread_mutex_lock(&mtx_pthr_locked);
14001b08e      int64_t idListCnt_1 = idListCnt;
14001b08e      
14001b098      if (idListCnt_1)
14001b098      {
14001b09a          int64_t* idList_1 = idList;
14001b09a          
14001b0e0          do
14001b0e0          {
14001b0b0              void* rdx_1 = *(uint64_t*)idList_1;
14001b0b0              
14001b0b6              if (rdx_1)
14001b0b6              {
14001b0b8                  int64_t r8_1 = *(uint64_t*)((char*)rdx_1 + 0x50);
14001b0b8                  
14001b0c4                  if (r8_1 && arg1 < *(uint32_t*)((char*)rdx_1 + 0x48))
14001b0c4                  {
14001b0c6                      *(uint64_t*)(r8_1 + (rdi_1 << 3)) = 0;
14001b0d5                      *(uint8_t*)(*(uint64_t*)(*(uint64_t*)idList_1 + 0x58) + rdi_1) = 0;
14001b0c4                  }
14001b0b6              }
14001b0b6              
14001b0d9              idList_1 = &idList_1[2];
14001b0e0          } while (&idList_1[idListCnt_1 * 2] != idList_1);
14001b098      }
14001b098      
14001b0e5      pthread_mutex_unlock(&mtx_pthr_locked);
14001b0ed      pthread_rwlock_unlock(&_pthread_key_lock);
14001b0f2      return 0;
14001b020  }

14001b0ff                                                                                               90                                 .
14001b10b                                   0f 1f 44 00 00                                                             ..D..

14001b110    int64_t pthread_getspecific(int32_t arg1)

14001b110  {
14001b11a      uint64_t rsi = (uint64_t)arg1;
14001b11c      enum WIN32_ERROR dwErrCode = GetLastError();
14001b124      _pthread_once_raw.constprop.0.isra.0();
14001b12f      void* rax = TlsGetValue(_pthread_tls);
14001b138      void* rbx = rax;
14001b138      
14001b13b      if (!rax)
14001b18d          rbx = __pthread_self_lite.part.0();
14001b18d      
14001b141      int64_t result = 0;
14001b147      pthread_spin_lock((char*)rbx + 0x68);
14001b147      
14001b159      if ((uint32_t)rsi < *(uint32_t*)((char*)rbx + 0x48)
14001b159              && *(uint8_t*)(*(uint64_t*)((char*)rbx + 0x58) + rsi))
14001b15f          result = *(uint64_t*)(*(uint64_t*)((char*)rbx + 0x50) + (rsi << 3));
14001b15f      
14001b166      pthread_spin_unlock((char*)rbx + 0x68);
14001b16d      SetLastError(dwErrCode);
14001b180      return result;
14001b110  }

14001b181     0f 1f 80 00 00 00 00                                                                           .......
14001b192                                                        66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                    ff............

14001b1a0    int64_t pthread_setspecific(int32_t arg1, int64_t arg2)

14001b1a0  {
14001b1b0      uint128_t zmm6;
14001b1b0      uint128_t var_58 = zmm6;
14001b1b5      uint64_t rsi = (uint64_t)arg1;
14001b1ba      enum WIN32_ERROR dwErrCode = GetLastError();
14001b1c2      _pthread_once_raw.constprop.0.isra.0();
14001b1cd      void* rax = TlsGetValue(_pthread_tls);
14001b1d6      void* rbx = rax;
14001b1d6      
14001b1d9      if (!rax)
14001b2b5          rbx = __pthread_self_lite.part.0();
14001b2b5      
14001b1e6      pthread_spin_lock((char*)rbx + 0x68);
14001b1ee      int64_t rdi;
14001b1ee      
14001b1ee      if ((uint32_t)rsi >= *(uint32_t*)((char*)rbx + 0x48))
14001b1ee      {
14001b234          int32_t _Size_1 = (int32_t)(rsi + 1);
14001b238          int64_t _Size = (int64_t)_Size_1;
14001b243          int64_t rax_3 = realloc(*(uint64_t*)((char*)rbx + 0x50), _Size << 3);
14001b24b          rdi = rax_3;
14001b24e          int64_t rax_4;
14001b24e          
14001b24e          if (rax_3)
14001b24e          {
14001b25c              rax_4 = realloc(*(uint64_t*)((char*)rbx + 0x58), _Size);
14001b26c              zmm6 = _mm_unpacklo_epi64((uint128_t)rdi, rax_4);
14001b24e          }
14001b24e          
14001b270          if (!rax_3 || !rax_4)
14001b270          {
14001b2c0              pthread_spin_unlock((char*)rbx + 0x68);
14001b2c5              return 0xc;
14001b270          }
14001b270          
14001b272          uint64_t rax_5 = (uint64_t)*(uint32_t*)((char*)rbx + 0x48);
14001b288          memset(rdi + (rax_5 << 3), 0, (uint64_t)(_Size_1 - (uint32_t)rax_5) << 3);
14001b28d          uint64_t rdx_4 = (uint64_t)*(uint32_t*)((char*)rbx + 0x48);
14001b29d          memset(rax_4 + rdx_4, 0, (uint64_t)(_Size_1 - (uint32_t)rdx_4));
14001b2a2          *(uint128_t*)((char*)rbx + 0x50) = zmm6;
14001b2a6          *(uint32_t*)((char*)rbx + 0x48) = _Size_1;
14001b1ee      }
14001b1ee      else
14001b1f0          rdi = *(uint64_t*)((char*)rbx + 0x50);
14001b1f0      
14001b1f4      *(uint64_t*)(rdi + (rsi << 3)) = arg2;
14001b1ff      *(uint8_t*)(*(uint64_t*)((char*)rbx + 0x58) + rsi) = 1;
14001b203      pthread_spin_unlock((char*)rbx + 0x68);
14001b20a      SetLastError(dwErrCode);
14001b210      return 0;
14001b1a0  }

14001b228                          0f 1f 84 00 00 00 00 00                                                          ........
14001b2af                                               90                                                                 .
14001b2cf                                               90                                                                 .

14001b2d0    int64_t pthread_equal(int64_t arg1, int64_t arg2) __pure

14001b2d0  {
14001b2d5      int64_t result;
14001b2d5      (uint8_t)result = arg1 == arg2;
14001b2d8      return result;
14001b2d0  }

14001b2d9                                                                             0f 1f 80 00 00 00 00                           .......

14001b2e0    void _pthread_cleanup_dest(int64_t arg1)

14001b2e0  {
14001b2e3      if (arg1)
14001b2e6          /* tailcall */
14001b2e6          return _pthread_cleanup_dest.part.0(arg1);
14001b2e0  }

14001b2eb                                   0f 1f 44 00 00                                                             ..D..

14001b2f0    int64_t pthread_self()

14001b2f0  {
14001b2f4      _pthread_once_raw.constprop.0.isra.0();
14001b2ff      void* rax = TlsGetValue(_pthread_tls);
14001b2ff      
14001b308      if (!rax)
14001b308      {
14001b320          rax = __pthread_self_lite.part.0();
14001b320          
14001b32a          if (!rax)
14001b333              return 0;
14001b308      }
14001b308      
14001b318      return *(uint64_t*)((char*)rax + 0x1d8);
14001b2f0  }

14001b319                                                                             0f 1f 80 00 00 00 00                           .......
14001b334                                                              66 66 2e 0f 1f 84 00 00 00 00 00 90                      ff..........

14001b340    void* pthread_getevent()

14001b340  {
14001b344      _pthread_once_raw.constprop.0.isra.0();
14001b34f      void* result = TlsGetValue(_pthread_tls);
14001b34f      
14001b358      if (!result)
14001b358      {
14001b368          result = __pthread_self_lite.part.0();
14001b368          
14001b370          if (!result)
14001b376              return result;
14001b358      }
14001b358      
14001b362      return *(uint64_t*)((char*)result + 0x30);
14001b340  }

14001b363           0f 1f 44 00 00                                                                             ..D..
14001b377                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001b380    int64_t pthread_gethandle(int64_t arg1)

14001b380  {
14001b38c      if (arg1)
14001b38c      {
14001b398          pthread_mutex_lock(&mtx_pthr_locked);
14001b3a0          void* rax_1 = __pthread_get_pointer(arg1);
14001b3ab          pthread_mutex_unlock(&mtx_pthr_locked);
14001b3ab          
14001b3b3          if (rax_1)
14001b3bf              return *(uint64_t*)((char*)rax_1 + 0x28);
14001b38c      }
14001b38c      
14001b3c8      return 0;
14001b380  }

14001b3c9                             0f 1f 80 00 00 00 00                                                           .......

14001b3d0    void* pthread_getclean()

14001b3d0  {
14001b3d4      _pthread_once_raw.constprop.0.isra.0();
14001b3df      void* result = TlsGetValue(_pthread_tls);
14001b3df      
14001b3e8      if (!result)
14001b3e8      {
14001b3f8          result = __pthread_self_lite.part.0();
14001b3f8          
14001b400          if (!result)
14001b3f2              return result;
14001b3e8      }
14001b3e8      
14001b3ea      return (char*)result + 0x18;
14001b3d0  }

14001b3f3                                                           0f 1f 44 00 00                                             ..D..
14001b404              66 66 2e 0f 1f 84 00 00 00 00 00 90                                                      ff..........

14001b410    int64_t pthread_get_concurrency(int32_t* arg1)

14001b410  {
14001b416      *(uint32_t*)arg1 = _pthread_concur;
14001b41a      return 0;
14001b410  }

14001b41b                                                                                   0f 1f 44 00 00                             ..D..

14001b420    int64_t pthread_set_concurrency(int32_t arg1)

14001b420  {
14001b422      _pthread_concur = arg1;
14001b428      return 0;
14001b420  }

14001b429                             0f 1f 80 00 00 00 00                                                           .......

14001b430    void pthread_exit(uint64_t arg1) __noreturn

14001b430  {
14001b436      uint64_t rsi = arg1;
14001b439      void* rax = __pthread_self_lite();
14001b43e      int64_t rcx = *(uint64_t*)((char*)rax + 0x1d8);
14001b448      *(uint64_t*)((char*)rax + 8) = rsi;
14001b448      
14001b44f      if (rcx)
14001b451          _pthread_cleanup_dest.part.0(rcx);
14001b451      
14001b45a      if (!(*(uint8_t*)((char*)rax + 0x40) & 0x30))
14001b45a      {
14001b468          longjmp((char*)rax + 0xd0, 1);
14001b468          /* no return */
14001b45a      }
14001b45a      
14001b474      int32_t* rax_1 = TlsGetValue(_pthread_tls);
14001b474      
14001b480      if (rax_1)
14001b480      {
14001b487          HANDLE hObject = *(uint64_t*)((char*)rax_1 + 0x30);
14001b487          
14001b48b          if (!*(uint64_t*)((char*)rax_1 + 0x28))
14001b48b          {
14001b4eb              *(uint32_t*)rax_1 = 0xdeadbeef;
14001b4eb              
14001b4f1              if (hObject)
14001b4f3                  CloseHandle(hObject);
14001b4f3              
14001b4fb              rsi = (uint64_t)rax_1[2];
14001b4fe              *(uint64_t*)((char*)rax_1 + 0x30) = 0;
14001b502              goto label_14001b4d3;
14001b48b          }
14001b48b          
14001b490          rsi = *(uint64_t*)((char*)rax_1 + 8);
14001b494          rax_1[0x2f] = 1;
14001b494          
14001b49e          if (hObject)
14001b4a0              CloseHandle(hObject);
14001b4a0          
14001b4a8          bool cond:4_1 = rax_1[0x11] & 4;
14001b4ac          *(uint64_t*)((char*)rax_1 + 0x30) = 0;
14001b4ac          
14001b4b0          if (cond:4_1)
14001b4b0              goto label_14001b4ba;
14001b480      }
14001b480      
14001b4b4      while (true)
14001b4b4      {
14001b4b4          _endthreadex((uint32_t)rsi);
14001b4ba      label_14001b4ba:
14001b4ba          HANDLE hObject_1 = *(uint64_t*)((char*)rax_1 + 0x28);
14001b4be          *(uint32_t*)rax_1 = 0xdeadbeef;
14001b4c4          CloseHandle(hObject_1);
14001b4cc          *(uint64_t*)((char*)rax_1 + 0x28) = 0;
14001b4d3      label_14001b4d3:
14001b4d3          push_pthread_mem(rax_1);
14001b4e0          TlsSetValue(_pthread_tls, nullptr);
14001b4b4      }
14001b430  }

14001b504              66 66 2e 0f 1f 84 00 00 00 00 00 90                                                      ff..........

14001b510    uint64_t __pthread_shallcancel()

14001b510  {
14001b51c      if (_pthread_cancelling)
14001b51c      {
14001b528          _pthread_once_raw.constprop.0.isra.0();
14001b533          void* rax_2 = TlsGetValue(_pthread_tls);
14001b533          
14001b53c          if (!rax_2)
14001b53c          {
14001b558              rax_2 = __pthread_self_lite.part.0();
14001b558              
14001b560              if (rax_2)
14001b560                  goto label_14001b541;
14001b53c          }
14001b53c          else
14001b53c          {
14001b541          label_14001b541:
14001b541              
14001b549              if (*(uint32_t*)((char*)rax_2 + 0x20) <= 0
14001b549                      && *(uint8_t*)((char*)rax_2 + 0x40) & 3)
14001b54e                  return (uint64_t)*(uint32_t*)((char*)rax_2 + 0x44) & 1;
14001b53c          }
14001b51c      }
14001b51c      
14001b51e      return 0;
14001b510  }

14001b525                 0f 1f 00                                                                               ...
14001b553                                                           0f 1f 44 00 00                                             ..D..
14001b564              66 66 2e 0f 1f 84 00 00 00 00 00 90                                                      ff..........

14001b570    void* _pthread_setnobreak(int32_t arg1)

14001b570  {
14001b577      _pthread_once_raw.constprop.0.isra.0();
14001b582      void* result = TlsGetValue(_pthread_tls);
14001b582      
14001b58b      if (!result)
14001b58b      {
14001b5b0          result = __pthread_self_lite.part.0();
14001b5b0          
14001b5b8          if (!result)
14001b5bf              return result;
14001b58b      }
14001b58b      
14001b58f      if (arg1 <= 0)
14001b58f      {
14001b5a0          *(uint32_t*)((char*)result + 0x20) -= 1;
14001b5aa          return result;
14001b58f      }
14001b58f      
14001b591      *(uint32_t*)((char*)result + 0x20) += 1;
14001b59b      return result;
14001b570  }

14001b59c                                                                                      0f 1f 40 00                              ..@.
14001b5ab                                   0f 1f 44 00 00                                                             ..D..

14001b5c0    void _pthread_invoke_cancel() __noreturn

14001b5c0  {
14001b5c5      void* rax = __pthread_self_lite();
14001b5dc      *(uint8_t*)((char*)rax + 0x40) = (*(uint8_t*)((char*)rax + 0x40) & 0xf3) | 4;
14001b5df      _pthread_setnobreak(1);
14001b5e4      _pthread_cancelling -= 1;
14001b5e4      
14001b5f3      for (void* i = *(uint64_t*)((char*)rax + 0x18); i; i = *(uint64_t*)((char*)i + 0x10))
14001b5fc          (*(uint64_t*)i)(*(uint64_t*)((char*)i + 8));
14001b5fc      
14001b609      _pthread_setnobreak(0);
14001b613      pthread_exit(0xdeadbeef);
14001b613      /* no return */
14001b5c0  }

14001b618                                                                          90 0f 1f 80 00 00 00 00                          ........

14001b620    void test_cancel_locked(int64_t arg1)

14001b620  {
14001b62c      if (!arg1)
14001b62c          return;
14001b62c      
14001b638      pthread_mutex_lock(&mtx_pthr_locked);
14001b640      void* rax_1 = __pthread_get_pointer(arg1);
14001b64b      pthread_mutex_unlock(&mtx_pthr_locked);
14001b64b      
14001b66e      if (!rax_1 || *(uint8_t*)((char*)rax_1 + 0x40) & 0xc
14001b66e              || *(uint32_t*)((char*)rax_1 + 0xbc)
14001b66e              || (*(uint32_t*)((char*)rax_1 + 0x44) & 3) != 0x3
14001b66e              || WaitForSingleObject(*(uint64_t*)((char*)rax_1 + 0x30), 0))
14001b694          return;
14001b694      
14001b694      pthread_mutex_unlock((char*)rax_1 + 0x38);
14001b699      _pthread_invoke_cancel();
14001b699      /* no return */
14001b620  }

14001b677                                                                       66 0f 1f 84 00 00 00 00 00                         f........
14001b69e                                                                                            90 90                                ..

14001b6a0    uint64_t pthread_testcancel()

14001b6a0  {
14001b6a6      _pthread_once_raw.constprop.0.isra.0();
14001b6b1      uint64_t _pthread_cancelling_1 = TlsGetValue(_pthread_tls);
14001b6ba      uint64_t _pthread_cancelling_2 = _pthread_cancelling_1;
14001b6ba      
14001b6bd      if (!_pthread_cancelling_1)
14001b6bd      {
14001b718          _pthread_cancelling_1 = __pthread_self_lite.part.0();
14001b720          _pthread_cancelling_2 = _pthread_cancelling_1;
14001b720          
14001b723          if (!_pthread_cancelling_1)
14001b72b              return _pthread_cancelling_1;
14001b6bd      }
14001b6bd      
14001b6c3      if (!(*(uint8_t*)(_pthread_cancelling_2 + 0x40) & 0xc))
14001b6c3      {
14001b6c5          _pthread_cancelling_1 = (uint64_t)_pthread_cancelling;
14001b6c5          
14001b6cd          if ((uint32_t)_pthread_cancelling_1)
14001b6cd          {
14001b6e7              pthread_mutex_lock(_pthread_cancelling_2 + 0x38);
14001b6ec              char rax = *(uint8_t*)(_pthread_cancelling_2 + 0x40);
14001b6ec              
14001b6f2              if (rax & 3)
14001b6f2              {
14001b6f4                  int32_t rdx_1 = *(uint32_t*)(_pthread_cancelling_2 + 0x44);
14001b6f4                  
14001b701                  if ((uint8_t)rdx_1 & 1
14001b701                      && *(uint32_t*)(_pthread_cancelling_2 + 0x20) <= 0)
14001b701                  {
14001b72c                      HANDLE hEvent = *(uint64_t*)(_pthread_cancelling_2 + 0x30);
14001b739                      *(uint32_t*)(_pthread_cancelling_2 + 0x44) = rdx_1 & 0xfffffffe;
14001b73c                      *(uint8_t*)(_pthread_cancelling_2 + 0x40) = (rax & 0xf3) | 4;
14001b73c                      
14001b742                      if (hEvent)
14001b744                          ResetEvent(hEvent);
14001b744                      
14001b74d                      pthread_mutex_unlock(_pthread_cancelling_2 + 0x38);
14001b752                      _pthread_invoke_cancel();
14001b752                      /* no return */
14001b701                  }
14001b6f2              }
14001b6f2              
14001b70c              /* tailcall */
14001b70c              return pthread_mutex_unlock(_pthread_cancelling_2 + 0x38);
14001b6cd          }
14001b6c3      }
14001b6c3      
14001b6d5      return _pthread_cancelling_1;
14001b6a0  }

14001b6d6                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
14001b711                                                     0f 1f 80 00 00 00 00                                           .......
14001b757                                                                       90 0f 1f 84 00 00 00 00 00                         .........

14001b760    int64_t pthread_delay_np(int64_t* arg1)

14001b760  {
14001b76a      if (!arg1)
14001b76a      {
14001b7d0          _pthread_once_raw.constprop.0.isra.0();
14001b7d0          
14001b7e4          if (!TlsGetValue(_pthread_tls))
14001b850              __pthread_self_lite.part.0();
14001b76a      }
14001b76a      else
14001b76a      {
14001b76c          int64_t rax = _pthread_time_in_ms_from_timespec(arg1);
14001b77c          void* rbx_1;
14001b77c          uint32_t dwMilliseconds;
14001b77c          
14001b77c          if (0xfffffffe < rax)
14001b77c          {
14001b808              _pthread_once_raw.constprop.0.isra.0();
14001b813              dwMilliseconds = -1;
14001b818              void* rax_5 = TlsGetValue(_pthread_tls);
14001b821              rbx_1 = rax_5;
14001b821              
14001b824              if (!rax_5)
14001b82f                  rbx_1 = __pthread_self_lite.part.0();
14001b82f              
14001b824              goto label_14001b7a5;
14001b77c          }
14001b77c          
14001b782          _pthread_once_raw.constprop.0.isra.0();
14001b78d          dwMilliseconds = (uint32_t)rax;
14001b78f          void* rax_1 = TlsGetValue(_pthread_tls);
14001b798          rbx_1 = rax_1;
14001b798          
14001b79b          if (!rax_1)
14001b865              rbx_1 = __pthread_self_lite.part.0();
14001b865          
14001b7a3          if ((uint32_t)rax)
14001b7a3          {
14001b7a5          label_14001b7a5:
14001b7a5              pthread_testcancel();
14001b7aa              HANDLE rcx_1 = *(uint64_t*)((char*)rbx_1 + 0x30);
14001b7aa              
14001b7b1              if (!rcx_1)
14001b842                  Sleep(dwMilliseconds);
14001b7b1              else
14001b7b9                  _pthread_wait_for_single_object(rcx_1, dwMilliseconds);
14001b7b9              
14001b7be              pthread_testcancel();
14001b7cc              return 0;
14001b7a3          }
14001b76a      }
14001b76a      
14001b7e6      pthread_testcancel();
14001b7ed      Sleep(0);
14001b7f3      pthread_testcancel();
14001b801      return 0;
14001b760  }

14001b7cd                                         0f 1f 00                                                               ...
14001b802        66 0f 1f 44 00 00                                                                            f..D..
14001b837                                                                       66 0f 1f 84 00 00 00 00 00                         f........
14001b84d                                         0f 1f 00                                                               ...
14001b857                                                                       66 0f 1f 84 00 00 00 00 00                         f........
14001b86d                                         0f 1f 00                                                               ...

14001b870    int64_t pthread_delay_np_ms(uint32_t arg1)

14001b870  {
14001b878      _pthread_once_raw.constprop.0.isra.0();
14001b883      void* rax = TlsGetValue(_pthread_tls);
14001b88c      void* rbx = rax;
14001b88c      
14001b88f      if (!rax)
14001b8e5          rbx = __pthread_self_lite.part.0();
14001b8e5      
14001b893      if (!arg1)
14001b893      {
14001b8c0          pthread_testcancel();
14001b8c7          Sleep(0);
14001b8cd          pthread_testcancel();
14001b8da          return 0;
14001b893      }
14001b893      
14001b895      pthread_testcancel();
14001b89a      HANDLE rcx_1 = *(uint64_t*)((char*)rbx + 0x30);
14001b89a      
14001b8a1      if (!rcx_1)
14001b8f2          Sleep(arg1);
14001b8a1      else
14001b8a5          _pthread_wait_for_single_object(rcx_1, arg1);
14001b8a5      
14001b8aa      pthread_testcancel();
14001b8b7      return 0;
14001b870  }

14001b8b8                                                                          0f 1f 84 00 00 00 00 00                          ........
14001b8db                                                                                   0f 1f 44 00 00                             ..D..
14001b8ea                                66 0f 1f 44 00 00                                                            f..D..
14001b8fa                                                                                66 0f 1f 44 00 00                            f..D..

14001b900    int64_t pthread_cancel(int64_t arg1)

14001b900  {
14001b911      if (arg1)
14001b911      {
14001b921          pthread_mutex_lock(&mtx_pthr_locked);
14001b929          void* rax_1 = __pthread_get_pointer(arg1);
14001b934          pthread_mutex_unlock(&mtx_pthr_locked);
14001b934          
14001b93c          if (rax_1)
14001b93c          {
14001b942              HANDLE hObject = *(uint64_t*)((char*)rax_1 + 0x28);
14001b94e              void var_4f8;
14001b94e              
14001b94e              if (hObject - 1 <= -3 && GetHandleInformation(hObject, &var_4f8))
14001b94e              {
14001b971                  pthread_mutex_lock((char*)rax_1 + 0x38);
14001b976                  _pthread_once_raw.constprop.0.isra.0();
14001b981                  void* rax_4 = TlsGetValue(_pthread_tls);
14001b98a                  uint32_t rdx_2;
14001b98a                  
14001b98a                  if (!rax_4)
14001b98a                  {
14001bb00                      rax_4 = __pthread_self_lite.part.0();
14001bb00                      
14001bb08                      if (rax_4)
14001bb08                          goto label_14001b997;
14001bb08                      
14001bb0e                      rdx_2 = (uint32_t)*(uint8_t*)((char*)rax_1 + 0x40);
14001b9a3                  label_14001b9a3:
14001b9a3                      
14001b9a6                      if ((*(uint32_t*)((char*)rax_1 + 0x44) & 3) != 3)
14001b9a6                      {
14001b9af                          if ((uint8_t)rdx_2 & 3)
14001b9af                              goto label_14001b9e3;
14001b9af                          
14001b9b7                          *(uint8_t*)((char*)rax_1 + 0x40) = ((uint8_t)rdx_2 & 0xfc) | 1;
14001b9ba                          _pthread_cancelling += 1;
14001b9c2                          HANDLE hEvent = *(uint64_t*)((char*)rax_1 + 0x30);
14001b9c2                          
14001b9c9                          if (hEvent)
14001b9cb                              SetEvent(hEvent);
14001b9cb                          
14001b9d4                          pthread_mutex_unlock((char*)rax_1 + 0x38);
14001b9d9                          return 0;
14001b9a6                      }
14001b9a6                      
14001ba63                      if ((uint8_t)rdx_2 & 0xc)
14001ba63                          goto label_14001b9e3;
14001ba63                      
14001ba6c                      if (!(rdx_2 & 0xf))
14001ba6c                      {
14001ba72                          int32_t var_4c8_1 = 0x100001;
14001ba7a                          SuspendThread(*(uint64_t*)((char*)rax_1 + 0x28));
14001ba7a                          
14001ba91                          if (WaitForSingleObject(*(uint64_t*)((char*)rax_1 + 0x28), 0)
14001ba91                              == WAIT_TIMEOUT)
14001ba91                          {
14001ba9e                              GetThreadContext(*(uint64_t*)((char*)rax_1 + 0x28), 
14001ba9e                                  &var_4f8);
14001bab2                              void (* var_400_1)() __noreturn = _pthread_invoke_cancel;
14001baba                              SetThreadContext(*(uint64_t*)((char*)rax_1 + 0x28), 
14001baba                                  &var_4f8);
14001bac0                              char rax_14 = *(uint8_t*)((char*)rax_1 + 0x40);
14001bac4                              *(uint32_t*)((char*)rax_1 + 0x44) &= 0xfffffffe;
14001bace                              *(uint8_t*)((char*)rax_1 + 0x40) = (rax_14 & 0xf0) | 5;
14001bad1                              _pthread_cancelling += 1;
14001bad9                              HANDLE hEvent_2 = *(uint64_t*)((char*)rax_1 + 0x30);
14001bad9                              
14001bae0                              if (hEvent_2)
14001bae2                                  SetEvent(hEvent_2);
14001bae2                              
14001baeb                              pthread_mutex_unlock((char*)rax_1 + 0x38);
14001baf4                              ResumeThread(*(uint64_t*)((char*)rax_1 + 0x28));
14001ba91                          }
14001ba91                          
14001b9d4                          pthread_mutex_unlock((char*)rax_1 + 0x38);
14001b9d9                          return 0;
14001ba6c                      }
14001b98a                  }
14001b98a                  else
14001b98a                  {
14001b997                  label_14001b997:
14001b997                      rdx_2 = (uint32_t)*(uint8_t*)((char*)rax_1 + 0x40);
14001b997                      
14001b99b                      if (arg1 != *(uint64_t*)((char*)rax_4 + 0x1d8))
14001b99b                          goto label_14001b9a3;
14001b99b                      
14001ba0b                      if (!((uint8_t)rdx_2 & 3))
14001ba0b                      {
14001ba13                          *(uint8_t*)((char*)rax_1 + 0x40) = ((uint8_t)rdx_2 & 0xfc) | 1;
14001ba16                          _pthread_cancelling += 1;
14001ba1e                          HANDLE hEvent_1 = *(uint64_t*)((char*)rax_1 + 0x30);
14001ba1e                          
14001ba25                          if (hEvent_1)
14001ba27                              SetEvent(hEvent_1);
14001ba27                          
14001ba2d                          int32_t rax_8 = *(uint32_t*)((char*)rax_1 + 0x44);
14001ba2d                          
14001ba38                          if ((rax_8 & 3) != 3)
14001ba38                          {
14001b9d4                              pthread_mutex_unlock((char*)rax_1 + 0x38);
14001b9d9                              return 0;
14001ba38                          }
14001ba38                          
14001ba40                          *(uint32_t*)((char*)rax_1 + 0x44) = rax_8 & 0xfffffffe;
14001ba4d                          *(uint8_t*)((char*)rax_1 + 0x40) =
14001ba4d                              (*(uint8_t*)((char*)rax_1 + 0x40) & 0xf3) | 4;
14001ba50                          pthread_mutex_unlock((char*)rax_1 + 0x38);
14001ba55                          _pthread_invoke_cancel();
14001ba55                          /* no return */
14001ba0b                      }
14001ba0b                      
14001b9e3                  label_14001b9e3:
14001b9e3                      pthread_mutex_unlock((char*)rax_1 + 0x38);
14001b9e3                      
14001b9ec                      if (!(*(uint8_t*)((char*)rax_1 + 0x40) & 0xc))
14001b9d9                          return 0;
14001b98a                  }
14001b94e              }
14001b93c          }
14001b911      }
14001b911      
14001b9f0      return 3;
14001b900  }

14001b9dd                                                                                         0f 1f 00                               ...
14001ba01     0f 1f 80 00 00 00 00                                                                           .......
14001ba5a                                                                                66 0f 1f 44 00 00                            f..D..
14001baff                                                                                               90                                 .
14001bb17                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001bb20    int64_t pthread_kill(int64_t arg1, int32_t arg2)

14001bb20  {
14001bb36      pthread_mutex_lock(&mtx_pthr_locked);
14001bb3e      void* rax = __pthread_get_pointer(arg1);
14001bb3e      
14001bb6d      if (!rax || *(uint64_t*)((char*)rax + 0x1d8) != arg1
14001bb6d          || *(uint8_t*)((char*)rax + 0x40) & 0xc || *(uint32_t*)((char*)rax + 0xbc)
14001bb6d          || *(uint64_t*)((char*)rax + 0x28) - 1 > -3)
14001bb6d      {
14001bb9b          pthread_mutex_unlock(&mtx_pthr_locked);
14001bba0          return 3;
14001bb6d      }
14001bb6d      
14001bb72      pthread_mutex_unlock(&mtx_pthr_locked);
14001bb72      
14001bb79      if (!arg2)
14001bbb0          return 0;
14001bbb0      
14001bb81      if (arg2 - 2 > 0x15)
14001bbb8          return 0x16;
14001bbb8      
14001bb8d      /* tailcall */
14001bb8d      return pthread_cancel(arg1);
14001bb20  }

14001bb92                                                        66 0f 1f 44 00 00                                            f..D..
14001bbad                                         0f 1f 00                                                               ...
14001bbb4                                                              0f 1f 40 00                                              ..@.
14001bbbf                                                                                               90                                 .

14001bbc0    uint64_t _pthread_get_state(int32_t* arg1, int32_t arg2)

14001bbc0  {
14001bbc4      return (uint64_t)*(uint32_t*)arg1 & (uint64_t)arg2;
14001bbc0  }

14001bbc5                 66 66 2e 0f 1f 84 00 00 00 00 00                                                       ff.........

14001bbd0    int64_t _pthread_set_state(int32_t* arg1, int32_t arg2, int32_t arg3)

14001bbd0  {
14001bbd0      int64_t result = 0x16;
14001bbd5      int32_t rdx = ~arg2;
14001bbd5      
14001bbda      if (!(rdx & arg3))
14001bbda      {
14001bbde          result = 0;
14001bbe3          *(uint32_t*)arg1 = (rdx & *(uint32_t*)arg1) | arg3;
14001bbda      }
14001bbda      
14001bbe5      return result;
14001bbd0  }

14001bbe6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

14001bbf0    int64_t pthread_attr_init(int32_t* arg1)

14001bbf0  {
14001bbf2      __builtin_memset(&arg1[1], 0, 0x1c);
14001bc11      *(uint32_t*)arg1 = 1;
14001bc17      return 0;
14001bbf0  }

14001bc18                                                                          0f 1f 84 00 00 00 00 00                          ........

14001bc20    int64_t pthread_attr_destroy(int64_t arg1)

14001bc20  {
14001bc22      __builtin_memset(arg1, 0, 0x20);
14001bc41      return 0;
14001bc20  }

14001bc42        66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                                                    ff............

14001bc50    uint64_t pthread_attr_setdetachstate(int32_t* arg1, int32_t arg2)

14001bc50  {
14001bc53      int32_t r8 = arg2 & 0xfffffffb;
14001bc53      
14001bc57      if (r8)
14001bc79          return 0x16;
14001bc79      
14001bc60      *(uint32_t*)arg1 = (*(uint32_t*)arg1 & 0xfffffffb) | arg2;
14001bc65      return (uint64_t)r8;
14001bc50  }

14001bc66                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
14001bc7a                                                                                66 0f 1f 44 00 00                            f..D..

14001bc80    int64_t pthread_attr_getdetachstate(int32_t* arg1, int32_t* arg2)

14001bc80  {
14001bc85      *(uint32_t*)arg2 = *(uint32_t*)arg1 & 4;
14001bc89      return 0;
14001bc80  }

14001bc8a                                66 0f 1f 44 00 00                                                            f..D..

14001bc90    uint64_t pthread_attr_setinheritsched(int32_t* arg1, int32_t arg2)

14001bc90  {
14001bc93      if (arg1)
14001bc93      {
14001bc98          int32_t r8_2 = arg2 & 0xfffffff7;
14001bc98          
14001bc9c          if (!r8_2)
14001bc9c          {
14001bca5              *(uint32_t*)arg1 = (*(uint32_t*)arg1 & 0xfffffff7) | arg2;
14001bcaa              return (uint64_t)r8_2;
14001bc9c          }
14001bc93      }
14001bc93      
14001bcb9      return 0x16;
14001bc90  }

14001bcab                                   0f 1f 44 00 00                                                             ..D..
14001bcba                                                                                66 0f 1f 44 00 00                            f..D..

14001bcc0    int64_t pthread_attr_getinheritsched(int32_t* arg1, int32_t* arg2)

14001bcc0  {
14001bcc5      *(uint32_t*)arg2 = *(uint32_t*)arg1 & 8;
14001bcc9      return 0;
14001bcc0  }

14001bcca                                66 0f 1f 44 00 00                                                            f..D..

14001bcd0    uint64_t pthread_attr_setscope(int32_t* arg1, int32_t arg2)

14001bcd0  {
14001bcd3      int32_t r8 = arg2 & 0xffffffef;
14001bcd3      
14001bcd7      if (r8)
14001bcf9          return 0x16;
14001bcf9      
14001bce0      *(uint32_t*)arg1 = (*(uint32_t*)arg1 & 0xffffffef) | arg2;
14001bce5      return (uint64_t)r8;
14001bcd0  }

14001bce6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
14001bcfa                                                                                66 0f 1f 44 00 00                            f..D..

14001bd00    int64_t pthread_attr_getscope(int32_t* arg1, int32_t* arg2)

14001bd00  {
14001bd05      *(uint32_t*)arg2 = *(uint32_t*)arg1 & 0x10;
14001bd09      return 0;
14001bd00  }

14001bd0a                                66 0f 1f 44 00 00                                                            f..D..

14001bd10    int64_t pthread_attr_getstack(void* arg1, int64_t* arg2, int64_t* arg3)

14001bd10  {
14001bd17      int64_t rdx = *(uint64_t*)((char*)arg1 + 0x10);
14001bd1e      *(uint64_t*)arg2 = *(uint64_t*)((char*)arg1 + 8) - rdx;
14001bd23      *(uint64_t*)arg3 = rdx;
14001bd26      return 0;
14001bd10  }

14001bd27                       66 0f 1f 84 00 00 00 00 00                                                         f........

14001bd30    int64_t pthread_attr_setstack(void* arg1, int64_t arg2, int64_t arg3)

14001bd30  {
14001bd35      *(uint64_t*)((char*)arg1 + 0x10) = arg3;
14001bd39      *(uint64_t*)((char*)arg1 + 8) = arg2 + arg3;
14001bd3d      return 0;
14001bd30  }

14001bd3e                                                                                            66 90                                f.

14001bd40    int64_t pthread_attr_getstackaddr(void* arg1, int64_t* arg2)

14001bd40  {
14001bd44      *(uint64_t*)arg2 = *(uint64_t*)((char*)arg1 + 8);
14001bd49      return 0;
14001bd40  }

14001bd4a                                66 0f 1f 44 00 00                                                            f..D..

14001bd50    int64_t pthread_attr_setstackaddr(void* arg1, int64_t arg2)

14001bd50  {
14001bd52      *(uint64_t*)((char*)arg1 + 8) = arg2;
14001bd56      return 0;
14001bd50  }

14001bd57                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001bd60    int64_t pthread_attr_getstacksize(void* arg1, int64_t* arg2)

14001bd60  {
14001bd64      *(uint64_t*)arg2 = *(uint64_t*)((char*)arg1 + 0x10);
14001bd69      return 0;
14001bd60  }

14001bd6a                                66 0f 1f 44 00 00                                                            f..D..

14001bd70    int64_t pthread_attr_setstacksize(void* arg1, int64_t arg2)

14001bd70  {
14001bd72      *(uint64_t*)((char*)arg1 + 0x10) = arg2;
14001bd76      return 0;
14001bd70  }

14001bd77                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001bd80    int64_t pthread_setcancelstate(int32_t arg1, int32_t* arg2)

14001bd80  {
14001bd8d      _pthread_once_raw.constprop.0.isra.0();
14001bd98      void* rax = TlsGetValue(_pthread_tls);
14001bda1      void* rbx = rax;
14001bda4      void* rax_7;
14001bda4      
14001bda4      if (!rax)
14001bda4      {
14001bdf0          rax_7 = __pthread_self_lite.part.0();
14001bdf8          rbx = rax_7;
14001bda4      }
14001bda4      
14001bda9      if ((!rax && !rax_7) || arg1 > 1)
14001be0a          return 0x16;
14001be0a      
14001bdb2      pthread_mutex_lock((char*)rbx + 0x38);
14001bdb2      
14001bdba      if (arg2)
14001bdc2          *(uint32_t*)arg2 = *(uint32_t*)((char*)rbx + 0x44) & 1;
14001bdc2      
14001bdc7      int64_t rcx_2 = *(uint64_t*)((char*)rbx + 0x1d8);
14001bdd3      *(uint32_t*)((char*)rbx + 0x44) =
14001bdd3          (*(uint32_t*)((char*)rbx + 0x44) & 0xfffffffe) | arg1;
14001bdd6      test_cancel_locked(rcx_2);
14001bdde      pthread_mutex_unlock((char*)rbx + 0x38);
14001bded      return 0;
14001bd80  }

14001bdee                                            66 90                                                                f.
14001be0b                                   0f 1f 44 00 00                                                             ..D..

14001be10    uint64_t pthread_setcanceltype(int32_t arg1, int32_t* arg2)

14001be10  {
14001be1f      _pthread_once_raw.constprop.0.isra.0();
14001be2a      void* rax = TlsGetValue(_pthread_tls);
14001be33      void* rbx = rax;
14001be36      void* rax_7;
14001be36      
14001be36      if (!rax)
14001be36      {
14001be88          rax_7 = __pthread_self_lite.part.0();
14001be90          rbx = rax_7;
14001be36      }
14001be36      
14001be93      if (rax || rax_7)
14001be93      {
14001be3a          int32_t rbp_2 = arg1 & 0xfffffffd;
14001be3a          
14001be3d          if (!rbp_2)
14001be3d          {
14001be46              pthread_mutex_lock((char*)rbx + 0x38);
14001be46              
14001be4e              if (arg2)
14001be56                  *(uint32_t*)arg2 = *(uint32_t*)((char*)rbx + 0x44) & 2;
14001be56              
14001be5b              int64_t rcx_2 = *(uint64_t*)((char*)rbx + 0x1d8);
14001be67              *(uint32_t*)((char*)rbx + 0x44) =
14001be67                  (*(uint32_t*)((char*)rbx + 0x44) & 0xfffffffd) | arg1;
14001be6a              test_cancel_locked(rcx_2);
14001be72              pthread_mutex_unlock((char*)rbx + 0x38);
14001be83              return (uint64_t)rbp_2;
14001be3d          }
14001be93      }
14001be93      
14001bea6      return 0x16;
14001be10  }

14001be84              0f 1f 40 00                                                                              ..@.
14001bea7                       66 0f 1f 84 00 00 00 00 00                                                         f........

14001beb0    int64_t pthread_create(int64_t* arg1, int32_t* arg2, int64_t arg3, int64_t arg4)

14001beb0  {
14001beca      void* _ArgList = pop_pthread_mem();
14001beca      
14001bed5      if (_ArgList)
14001bed5      {
14001bede          if (arg1)
14001bee7              *(uint64_t*)arg1 = *(uint64_t*)((char*)_ArgList + 0x1d8);
14001bee7          
14001bef2          *(uint64_t*)((char*)_ArgList + 8) = arg4;
14001befd          *(uint64_t*)((char*)_ArgList + 0x10) = arg3;
14001bf01          int32_t rsi_1 = 0;
14001bf03          *(uint32_t*)((char*)_ArgList + 0xbc) = 0;
14001bf0d          *(uint32_t*)((char*)_ArgList + 0x44) = 1;
14001bf14          *(uint64_t*)((char*)_ArgList + 0x28) = -1;
14001bf14          
14001bf2c          while (true)
14001bf2c          {
14001bf2c              HANDLE rax_1 = CreateEventA(nullptr, 1, 0, nullptr);
14001bf32              *(uint64_t*)((char*)_ArgList + 0x30) = rax_1;
14001bf32              
14001bf36              if (rax_1)
14001bf36                  break;
14001bf36              
14001bf3a              if (rsi_1)
14001bf3a              {
14001bf50                  rsi_1 += 1;
14001bf58                  Sleep(0x14);
14001bf58                  
14001bf5e                  if (rsi_1 == 5)
14001bf5e                      break;
14001bf3a              }
14001bf3a              else
14001bf3a              {
14001bf3e                  rsi_1 = 1;
14001bf43                  Sleep(0);
14001bf3a              }
14001bf2c          }
14001bf2c          
14001bf64          *(uint64_t*)((char*)_ArgList + 0x38) = -1;
14001bf7d          bool cond:1_1 = !*(uint64_t*)((char*)_ArgList + 0x30);
14001bf82          *(uint32_t*)_ArgList = 0xbab1f00d;
14001bf88          *(uint64_t*)((char*)_ArgList + 0x68) = -1;
14001bf90          *(uint32_t*)((char*)_ArgList + 0xc0) = 0;
14001bf9a          *(uint32_t*)((char*)_ArgList + 0xb8) = 0;
14001bf9a          
14001bfa4          if (!cond:1_1)
14001bfa4          {
14001bfaa              uint32_t _StackSize = 0;
14001bfaa              
14001bfaf              if (arg2)
14001bfaf              {
14001bfb1                  int32_t rax_2 = *(uint32_t*)arg2;
14001bfb3                  int32_t _StackSize_1 = (int32_t)*(uint64_t*)((char*)arg2 + 0x10);
14001bfb9                  *(uint32_t*)((char*)_ArgList + 0x44) = rax_2;
14001bfbc                  int32_t rax_3;
14001bfbc                  
14001bfbc                  if ((uint8_t)rax_2 & 8)
14001bfbc                  {
14001c0f8                      _pthread_once_raw.constprop.0.isra.0();
14001c103                      void* rax_7 = TlsGetValue(_pthread_tls);
14001c103                      
14001c10c                      if (!rax_7)
14001c130                          rax_7 = __pthread_self_lite.part.0();
14001c130                      
14001c10e                      rax_3 = *(uint32_t*)((char*)rax_7 + 0xc0);
14001bfbc                  }
14001bfbc                  else
14001bfc2                      rax_3 = arg2[6];
14001bfc2                  
14001bfc5                  _StackSize = _StackSize_1;
14001bfc7                  *(uint32_t*)((char*)_ArgList + 0xc0) = rax_3;
14001bfaf              }
14001bfaf              
14001bfea              uintptr_t rax_4 = _beginthreadex(nullptr, _StackSize, 
14001bfea                  pthread_create_wrapper, _ArgList, 4, nullptr);
14001bfea              
14001bffb              if (rax_4 - 1 <= -3)
14001bffb              {
14001c001                  enum THREAD_PRIORITY nPriority_1 = *(uint32_t*)((char*)_ArgList + 0xc0);
14001c007                  enum THREAD_PRIORITY nPriority = 0xfffffff1;
14001c007                  
14001c00f                  if (nPriority_1 >= 0xfffffff2)
14001c00f                  {
14001c073                      nPriority = ~THREAD_PRIORITY_ABOVE_NORMAL~THREAD_PRIORITY_NORMAL;
14001c073                      
14001c078                      if (nPriority_1 >= ~THREAD_PRIORITY_NORMAL)
14001c078                      {
14001c07a                          nPriority = THREAD_PRIORITY_HIGHEST;
14001c07a                          
14001c081                          if (nPriority_1 <= THREAD_PRIORITY_HIGHEST)
14001c081                              nPriority = nPriority_1;
14001c081                          
14001c08c                          if (nPriority_1 >= THREAD_PRIORITY_TIME_CRITICAL)
14001c08c                              nPriority = THREAD_PRIORITY_TIME_CRITICAL;
14001c078                      }
14001c00f                  }
14001c00f                  
14001c014                  SetThreadPriority(rax_4, nPriority);
14001c01e                  ResetEvent(*(uint64_t*)((char*)_ArgList + 0x30));
14001c01e                  
14001c028                  if (*(uint8_t*)((char*)_ArgList + 0x44) & 4)
14001c028                  {
14001c053                      *(uint64_t*)((char*)_ArgList + 0x28) = 0;
14001c05b                      ResumeThread(rax_4);
14001c064                      CloseHandle(rax_4);
14001c028                  }
14001c028                  else
14001c028                  {
14001c02a                      *(uint64_t*)((char*)_ArgList + 0x28) = rax_4;
14001c031                      ResumeThread(rax_4);
14001c028                  }
14001c028                  
14001c039                  Sleep(0);
14001c03f                  return 0;
14001bffb              }
14001bffb              
14001c098              HANDLE hObject = *(uint64_t*)((char*)_ArgList + 0x30);
14001c098              
14001c0a3              if (hObject)
14001c0a5                  CloseHandle(hObject);
14001c0a5              
14001c0ae              pthread_mutex_destroy((char*)_ArgList + 0x38);
14001c0c4              *(uint64_t*)((char*)_ArgList + 0x68) = -1;
14001c0cc              *(uint128_t*)((char*)_ArgList + 0x28) = {0};
14001bfa4          }
14001bfa4          
14001c0d3          if (arg1)
14001c0d5              *(uint64_t*)arg1 = 0;
14001c0d5          
14001c0e5          if (!*(uint64_t*)((char*)_ArgList + 0x1d0))
14001c123              push_pthread_mem.part.0(_ArgList);
14001bed5      }
14001bed5      
14001c0e7      return 0xb;
14001beb0  }

14001bf48                          0f 1f 84 00 00 00 00 00                                                          ........
14001c06c                                      0f 1f 40 00                                                              ..@.
14001c094                                                              0f 1f 40 00                                              ..@.
14001c0f1                                                     0f 1f 80 00 00 00 00                                           .......
14001c119                                                                             0f 1f 80 00 00 00 00                           .......
14001c12a                                66 0f 1f 44 00 00                                                            f..D..
14001c13c                                                                                      90 0f 1f 00                              ....

14001c140    int64_t pthread_join(int64_t arg1, int64_t* arg2)

14001c140  {
14001c151      if (arg1)
14001c151      {
14001c161          pthread_mutex_lock(&mtx_pthr_locked);
14001c169          void* rax_1 = __pthread_get_pointer(arg1);
14001c174          pthread_mutex_unlock(&mtx_pthr_locked);
14001c174          
14001c17c          if (rax_1)
14001c17c          {
14001c182              HANDLE hObject = *(uint64_t*)((char*)rax_1 + 0x28);
14001c189              uint32_t lpdwFlags;
14001c189              
14001c189              if (hObject && GetHandleInformation(hObject, &lpdwFlags))
14001c189              {
14001c1a6                  if (*(uint8_t*)((char*)rax_1 + 0x44) & 4)
14001c27d                      return 0x16;
14001c27d                  
14001c1ac                  _pthread_once_raw.constprop.0.isra.0();
14001c1b7                  void* rax_3 = TlsGetValue(_pthread_tls);
14001c1b7                  
14001c1c0                  if (!rax_3)
14001c1c0                  {
14001c290                      rax_3 = __pthread_self_lite.part.0();
14001c290                      
14001c298                      if (rax_3)
14001c298                          goto label_14001c1c6;
14001c1c0                  }
14001c1c0                  else
14001c1c0                  {
14001c1c6                  label_14001c1c6:
14001c1c6                      
14001c1cd                      if (arg1 == *(uint64_t*)((char*)rax_3 + 0x1d8))
14001c2b8                          return 0x24;
14001c1c0                  }
14001c1c0                  
14001c1d9                  HANDLE rcx_2 = *(uint64_t*)((char*)rax_1 + 0x28);
14001c1d9                  
14001c1e9                  if (!*(uint32_t*)((char*)rax_1 + 0xbc) || rcx_2 - 1 <= -3)
14001c1e9                  {
14001c1f0                      WaitForSingleObject(rcx_2, 0xffffffff);
14001c1f6                      rcx_2 = *(uint64_t*)((char*)rax_1 + 0x28);
14001c1e9                  }
14001c1e9                  
14001c201                  CloseHandle(rcx_2);
14001c203                  HANDLE hObject_1 = *(uint64_t*)((char*)rax_1 + 0x30);
14001c203                  
14001c20a                  if (hObject_1)
14001c20c                      CloseHandle(hObject_1);
14001c20c                  
14001c20e                  *(uint64_t*)((char*)rax_1 + 0x30) = 0;
14001c20e                  
14001c21d                  if (!arg2)
14001c2a8                      pthread_mutex_destroy((char*)rax_1 + 0x38);
14001c21d                  else
14001c21d                  {
14001c227                      *(uint64_t*)arg2 = *(uint64_t*)((char*)rax_1 + 8);
14001c22b                      pthread_mutex_destroy((char*)rax_1 + 0x38);
14001c21d                  }
14001c21d                  
14001c242                  bool cond:1 = !*(uint64_t*)((char*)rax_1 + 0x1d0);
14001c24a                  *(uint64_t*)((char*)rax_1 + 0x68) = -1;
14001c24a                  
14001c252                  if (cond:1)
14001c283                      push_pthread_mem.part.0(rax_1);
14001c283                  
14001c25e                  return 0;
14001c189              }
14001c17c          }
14001c151      }
14001c151      
14001c260      return 3;
14001c140  }

14001c25f                                                                                               90                                 .
14001c26e                                            66 90                                                                f.
14001c27e                                                                                            66 90                                f.
14001c28c                                      0f 1f 40 00                                                              ..@.
14001c2a3           0f 1f 44 00 00                                                                             ..D..
14001c2b2                                                        66 0f 1f 44 00 00                                            f..D..
14001c2c4              90 66 66 2e 0f 1f 84 00 00 00 00 00                                                      .ff.........

14001c2d0    int64_t _pthread_tryjoin(int64_t arg1, int64_t* arg2)

14001c2d0  {
14001c2e8      pthread_mutex_lock(&mtx_pthr_locked);
14001c2f0      void* rax = __pthread_get_pointer(arg1);
14001c2f0      
14001c2fb      if (rax)
14001c2fb      {
14001c301          HANDLE hObject = *(uint64_t*)((char*)rax + 0x28);
14001c308          uint32_t lpdwFlags;
14001c308          
14001c308          if (hObject && GetHandleInformation(hObject, &lpdwFlags))
14001c308          {
14001c325              if (*(uint8_t*)((char*)rax + 0x44) & 4)
14001c325              {
14001c413                  pthread_mutex_unlock(&mtx_pthr_locked);
14001c425                  return 0x16;
14001c325              }
14001c325              
14001c32b              _pthread_once_raw.constprop.0.isra.0();
14001c336              void* rax_2 = TlsGetValue(_pthread_tls);
14001c33f              int64_t rdx_1;
14001c33f              
14001c33f              if (!rax_2)
14001c33f              {
14001c450                  rax_2 = __pthread_self_lite.part.0();
14001c455                  rdx_1 = 0;
14001c455                  
14001c45a                  if (rax_2)
14001c345                      rdx_1 = *(uint64_t*)((char*)rax_2 + 0x1d8);
14001c33f              }
14001c33f              else
14001c345                  rdx_1 = *(uint64_t*)((char*)rax_2 + 0x1d8);
14001c345              
14001c34f              if (arg1 == rdx_1)
14001c34f              {
14001c48b                  pthread_mutex_unlock(&mtx_pthr_locked);
14001c490                  return 0x24;
14001c34f              }
14001c34f              
14001c35b              HANDLE rcx_2 = *(uint64_t*)((char*)rax + 0x28);
14001c35b              
14001c361              if (!*(uint32_t*)((char*)rax + 0xbc))
14001c361              {
14001c438                  if (WaitForSingleObject(rcx_2, 0) && !*(uint32_t*)((char*)rax + 0xbc))
14001c438                  {
14001c441                      pthread_mutex_unlock(&mtx_pthr_locked);
14001c446                      return 0x10;
14001c438                  }
14001c438                  
14001c373                  rcx_2 = *(uint64_t*)((char*)rax + 0x28);
14001c361              }
14001c361              
14001c37e              CloseHandle(rcx_2);
14001c380              HANDLE hObject_1 = *(uint64_t*)((char*)rax + 0x30);
14001c380              
14001c387              if (hObject_1)
14001c389                  CloseHandle(hObject_1);
14001c389              
14001c38b              *(uint64_t*)((char*)rax + 0x30) = 0;
14001c38b              
14001c39a              if (!arg2)
14001c468                  pthread_mutex_destroy((char*)rax + 0x38);
14001c39a              else
14001c39a              {
14001c3a4                  *(uint64_t*)arg2 = *(uint64_t*)((char*)rax + 8);
14001c3a7                  pthread_mutex_destroy((char*)rax + 0x38);
14001c39a              }
14001c39a              
14001c3be              bool cond:1_1 = !*(uint64_t*)((char*)rax + 0x1d0);
14001c3c6              *(uint64_t*)((char*)rax + 0x68) = -1;
14001c3c6              
14001c3ce              if (cond:1_1)
14001c47b                  push_pthread_mem.part.0(rax);
14001c47b              
14001c3d7              pthread_mutex_unlock(&mtx_pthr_locked);
14001c3dc              return 0;
14001c308          }
14001c2fb      }
14001c2fb      
14001c3f3      pthread_mutex_unlock(&mtx_pthr_locked);
14001c405      return 3;
14001c2d0  }

14001c3e7                       66 0f 1f 84 00 00 00 00 00                                                         f........
14001c406                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
14001c426                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
14001c44d                                         0f 1f 00                                                               ...
14001c465                 0f 1f 00                                                                               ...
14001c472                                                        66 0f 1f 44 00 00                                            f..D..
14001c485                 0f 1f 00                                                                               ...
14001c49f                                                                                               90                                 .

14001c4a0    int64_t pthread_detach(int64_t arg1)

14001c4a0  {
14001c4b8      if (!arg1)
14001c598          pthread_mutex_lock(&mtx_pthr_locked);
14001c4b8      else
14001c4b8      {
14001c4be          pthread_mutex_lock(&mtx_pthr_locked);
14001c4c6          void* rax_1 = __pthread_get_pointer(arg1);
14001c4d1          pthread_mutex_unlock(&mtx_pthr_locked);
14001c4d9          pthread_mutex_lock(&mtx_pthr_locked);
14001c4d9          
14001c4e1          if (rax_1)
14001c4e1          {
14001c4e7              HANDLE hObject = *(uint64_t*)((char*)rax_1 + 0x28);
14001c4ee              uint32_t lpdwFlags;
14001c4ee              
14001c4ee              if (hObject && GetHandleInformation(hObject, &lpdwFlags))
14001c4ee              {
14001c507                  int32_t rax_3 = *(uint32_t*)((char*)rax_1 + 0x44);
14001c507                  
14001c50c                  if ((uint8_t)rax_3 & 4)
14001c50c                  {
14001c5bb                      pthread_mutex_unlock(&mtx_pthr_locked);
14001c5c0                      return 0x16;
14001c50c                  }
14001c50c                  
14001c515                  HANDLE hObject_1 = *(uint64_t*)((char*)rax_1 + 0x28);
14001c519                  *(uint64_t*)((char*)rax_1 + 0x28) = 0;
14001c521                  *(uint32_t*)((char*)rax_1 + 0x44) = rax_3 | 4;
14001c521                  
14001c527                  if (hObject_1)
14001c527                  {
14001c530                      CloseHandle(hObject_1);
14001c530                      
14001c53a                      if (*(uint32_t*)((char*)rax_1 + 0xbc))
14001c53a                      {
14001c53c                          HANDLE hObject_2 = *(uint64_t*)((char*)rax_1 + 0x30);
14001c53c                          
14001c547                          if (!hObject_2)
14001c5d3                              pthread_mutex_destroy((char*)rax_1 + 0x38);
14001c547                          else
14001c547                          {
14001c54d                              CloseHandle(hObject_2);
14001c54f                              *(uint64_t*)((char*)rax_1 + 0x30) = 0;
14001c55a                              pthread_mutex_destroy((char*)rax_1 + 0x38);
14001c547                          }
14001c547                          
14001c56d                          bool cond:0_1 = !*(uint64_t*)((char*)rax_1 + 0x1d0);
14001c575                          *(uint64_t*)((char*)rax_1 + 0x68) = -1;
14001c575                          
14001c57d                          if (cond:0_1)
14001c5e3                              push_pthread_mem.part.0(rax_1);
14001c53a                      }
14001c527                  }
14001c527                  
14001c583                  pthread_mutex_unlock(&mtx_pthr_locked);
14001c588                  return 0;
14001c4ee              }
14001c4e1          }
14001c4b8      }
14001c4b8      
14001c5a0      pthread_mutex_unlock(&mtx_pthr_locked);
14001c5b2      return 3;
14001c4a0  }

14001c593                                                           0f 1f 44 00 00                                             ..D..
14001c5b3                                                           0f 1f 44 00 00                                             ..D..
14001c5c7                       66 0f 1f 84 00 00 00 00 00                                                         f........
14001c5dd                                                                                         0f 1f 00                               ...
14001c5ef                                               90                                                                 .

14001c5f0    uint64_t pthread_getconcurrency()

14001c5f0  {
14001c5f6      return (uint64_t)dummy_concurrency_level;
14001c5f0  }

14001c5f7                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001c600    int64_t pthread_setconcurrency(int32_t arg1)

14001c600  {
14001c602      dummy_concurrency_level = arg1;
14001c608      return 0;
14001c600  }

14001c609                             0f 1f 80 00 00 00 00                                                           .......

14001c610    uint64_t pthread_setname_np(int64_t arg1, char* arg2)

14001c610  {
14001c621      if (!arg2)
14001c72f          return 0x16;
14001c72f      
14001c62a      int32_t rbx_1;
14001c62a      
14001c62a      if (!arg1)
14001c710          rbx_1 = 3;
14001c62a      else
14001c62a      {
14001c63a          pthread_mutex_lock(&mtx_pthr_locked);
14001c642          void* rax_1 = __pthread_get_pointer(arg1);
14001c64d          pthread_mutex_unlock(&mtx_pthr_locked);
14001c64d          
14001c66c          if (!rax_1 || *(uint64_t*)((char*)rax_1 + 0x1d8) != arg1
14001c66c                  || *(uint8_t*)((char*)rax_1 + 0x40) & 0xc)
14001c710              rbx_1 = 3;
14001c66c          else
14001c66c          {
14001c672              rbx_1 = *(uint32_t*)((char*)rax_1 + 0xbc);
14001c672              
14001c68c              if (rbx_1 || *(uint64_t*)((char*)rax_1 + 0x28) - 1 > -3)
14001c710                  rbx_1 = 3;
14001c68c              else
14001c68c              {
14001c695                  char* rax_4 = _strdup(arg2);
14001c695                  
14001c6a0                  if (!rax_4)
14001c730                      rbx_1 = 0xc;
14001c6a0                  else
14001c6a0                  {
14001c6a6                      int64_t rcx_2 = *(uint64_t*)((char*)rax_1 + 0x60);
14001c6a6                      
14001c6ad                      if (rcx_2)
14001c6af                          free(rcx_2);
14001c6af                      
14001c6b4                      int32_t rax_5 = *(uint32_t*)((char*)rax_1 + 0x70);
14001c6b7                      *(uint64_t*)((char*)rax_1 + 0x60) = rax_4;
14001c6bb                      uint64_t arguments;
14001c6bb                      (uint32_t)arguments = 0x1000;
14001c6c3                      char* var_40_1 = arg2;
14001c6c8                      int32_t var_34_1 = 0;
14001c6d0                      int32_t var_38_1 = rax_5;
14001c6d0                      
14001c6e6                      if (IsDebuggerPresent() || SetThreadName_VEH_handle)
14001c6e6                      {
14001c6fa                          RaiseException(0x406d1388, 0, 3, &arguments);
14001c6fa                          /* no return */
14001c6e6                      }
14001c6a0                  }
14001c68c              }
14001c66c          }
14001c62a      }
14001c62a      
14001c71f      return (uint64_t)rbx_1;
14001c610  }

14001c700  89 d8 48 83 c4 48 5b 5e 5f 5d c3 0f 1f 44 00 00                                                  ..H..H[^_]...D..
14001c737                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001c740    uint64_t pthread_getname_np(int64_t arg1, void* arg2, int64_t arg3)

14001c740  {
14001c750      void* rbx = arg2;
14001c753      int64_t i = arg3;
14001c753      
14001c756      if (!arg2)
14001c85b          return 0x16;
14001c85b      
14001c75f      int32_t r12_1;
14001c75f      
14001c75f      if (!arg1)
14001c818          r12_1 = 3;
14001c75f      else
14001c75f      {
14001c76f          pthread_mutex_lock(&mtx_pthr_locked);
14001c777          void* rax_1 = __pthread_get_pointer(arg1);
14001c782          pthread_mutex_unlock(&mtx_pthr_locked);
14001c782          
14001c79d          if (!rax_1 || *(uint64_t*)((char*)rax_1 + 0x1d8) != arg1
14001c79d                  || *(uint8_t*)((char*)rax_1 + 0x40) & 0xc)
14001c818              r12_1 = 3;
14001c79d          else
14001c79d          {
14001c79f              r12_1 = *(uint32_t*)((char*)rax_1 + 0xbc);
14001c79f              
14001c7b7              if (r12_1 || *(uint64_t*)((char*)rax_1 + 0x28) - 1 > -3)
14001c818                  r12_1 = 3;
14001c7b7              else
14001c7b7              {
14001c7bc                  if (!i)
14001c843                      return 0x22;
14001c843                  
14001c7be                  char* _Str = *(uint64_t*)((char*)rax_1 + 0x60);
14001c7be                  
14001c7c5                  if (_Str)
14001c7c5                  {
14001c7de                      if (strlen(_Str) >= i || i - 1 > 0x7ffffffe)
14001c843                          return 0x22;
14001c843                      
14001c7e3                      if (i != 1)
14001c7e3                      {
14001c803                          do
14001c803                          {
14001c805                              char rax_6 = *(uint8_t*)_Str;
14001c805                              
14001c80a                              if (!rax_6)
14001c80a                                  break;
14001c80a                              
14001c7f0                              i -= 1;
14001c7f4                              rbx += 1;
14001c7f8                              _Str = &_Str[1];
14001c7fc                              *(uint8_t*)((char*)rbx - 1) = rax_6;
14001c803                          } while (i > 1);
14001c7e3                      }
14001c7c5                  }
14001c7c5                  
14001c80c                  *(uint8_t*)rbx = 0;
14001c7b7              }
14001c79d          }
14001c75f      }
14001c75f      
14001c82b      return (uint64_t)r12_1;
14001c740  }

14001c7e7                       66 0f 1f 84 00 00 00 00 00                                                         f........
14001c811                                                     0f 1f 80 00 00 00 00                                           .......
14001c82c                                      0f 1f 40 00                                                              ..@.
14001c844              0f 1f 40 00                                                                              ..@.
14001c85c                                                                                      90 90 90 90                              ....

14001c860    uint64_t _pthread_time_in_ms()

14001c860  {
14001c869      FILETIME systemTimeAsFileTime;
14001c869      GetSystemTimeAsFileTime(&systemTimeAsFileTime);
14001c8a3      return (((uint64_t)systemTimeAsFileTime.dwHighDateTime << 0x20)
14001c8a3          + (uint64_t)systemTimeAsFileTime.dwLowDateTime - 0x19db1ded53e8000) / 0x2710;
14001c860  }

14001c8a4              66 66 2e 0f 1f 84 00 00 00 00 00 90                                                      ff..........

14001c8b0    int64_t _pthread_time_in_ms_from_timespec(int64_t* arg1)

14001c8b0  {
14001c8cd      int64_t rax;
14001c8cd      int64_t rdx_3;
14001c8cd      rdx_3 = HIGHQ(0x431bde82d7b634db * (int64_t)(arg1[1] + 0xf423f));
14001c8cd      rax = LOWQ(0x431bde82d7b634db * (int64_t)(arg1[1] + 0xf423f));
14001c8d8      return (rdx_3 >> 0x12) + *(uint64_t*)arg1 * 0x3e8;
14001c8b0  }

14001c8d9                                                                             0f 1f 80 00 00 00 00                           .......

14001c8e0    int64_t _pthread_rel_time_in_ms(int64_t* arg1)

14001c8e0  {
14001c907      int64_t rax;
14001c907      int64_t rdx_3;
14001c907      rdx_3 = HIGHQ(0x431bde82d7b634db * (int64_t)(arg1[1] + 0xf423f));
14001c907      rax = LOWQ(0x431bde82d7b634db * (int64_t)(arg1[1] + 0xf423f));
14001c90e      int64_t rbx = (rdx_3 >> 0x12) + *(uint64_t*)arg1 * 0x3e8;
14001c912      FILETIME systemTimeAsFileTime;
14001c912      GetSystemTimeAsFileTime(&systemTimeAsFileTime);
14001c944      uint64_t rdx_9 = ((uint64_t)systemTimeAsFileTime.dwLowDateTime - 0x19db1ded53e8000
14001c944          + ((uint64_t)systemTimeAsFileTime.dwHighDateTime << 0x20)) / 0x2710;
14001c944      
14001c953      if (rbx < rdx_9)
14001c953          return 0;
14001c953      
14001c95c      return rbx - rdx_9;
14001c8e0  }

14001c95d                                                                                         0f 1f 00                               ...

14001c960    uint64_t _pthread_wait_for_single_object(HANDLE arg1, uint32_t arg2)

14001c960  {
14001c973      if (arg2 - 1 > 0xfffffffd)
14001c9ca          /* tailcall */
14001c9ca          return WaitForSingleObject(arg1, arg2);
14001c9ca      
14001c982      uint64_t rsi = (uint64_t)arg2;
14001c98d      uint32_t dwMilliseconds = (uint32_t)rsi;
14001c990      uint64_t rsi_1 = rsi + GetTickCount64();
14001c990      
14001c9a6      while (true)
14001c9a6      {
14001c9a6          enum WAIT_EVENT rax_3 = WaitForSingleObject(arg1, dwMilliseconds);
14001c9b0          uint64_t rax_2;
14001c9b0          
14001c9b0          if (rax_3 == WAIT_TIMEOUT)
14001c998              rax_2 = GetTickCount64();
14001c998          
14001c99d          if (rax_3 != WAIT_TIMEOUT || rax_2 >= rsi_1)
14001c9be              return (uint64_t)rax_3;
14001c9be          
14001c9a1          dwMilliseconds = (uint32_t)rsi_1 - (uint32_t)rax_2;
14001c9a6      }
14001c960  }

14001c995                                                                 0f 1f 00                                               ...
14001c9bf                                                                                               90                                 .
14001c9d1                                                     66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00                   ff...........@.

14001c9e0    uint64_t _pthread_wait_for_multiple_objects(uint32_t arg1, HANDLE* arg2, BOOL arg3, uint32_t arg4)

14001c9e0  {
14001c9fd      if (arg4 - 1 > 0xfffffffd)
14001ca6e          /* tailcall */
14001ca6e          return WaitForMultipleObjects(arg1, arg2, arg3, arg4);
14001ca6e      
14001ca0e      uint64_t rsi = (uint64_t)arg4;
14001ca19      uint32_t dwMilliseconds = (uint32_t)rsi;
14001ca1c      uint64_t rsi_1 = rsi + GetTickCount64();
14001ca1c      
14001ca3e      while (true)
14001ca3e      {
14001ca3e          enum WAIT_EVENT rax_3 = WaitForMultipleObjects(arg1, arg2, arg3, dwMilliseconds);
14001ca48          uint64_t rax_2;
14001ca48          
14001ca48          if (rax_3 == WAIT_TIMEOUT)
14001ca28              rax_2 = GetTickCount64();
14001ca28          
14001ca2e          if (rax_3 != WAIT_TIMEOUT || rax_2 >= rsi_1)
14001ca5a              return (uint64_t)rax_3;
14001ca5a          
14001ca33          dwMilliseconds = (uint32_t)rsi_1 - (uint32_t)rax_2;
14001ca3e      }
14001c9e0  }

14001ca21     0f 1f 80 00 00 00 00                                                                           .......
14001ca5b                                                                                   0f 1f 44 00 00                             ..D..
14001ca75                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

14001ca80    uint64_t rwl_ref_destroy(int64_t* arg1, int64_t* arg2)

14001ca80  {
14001ca92      *(uint64_t*)arg2 = 0;
14001ca9f      pthread_spin_lock(&rwl_global);
14001caa7      int32_t rbp;
14001caa7      
14001caa7      if (!arg1)
14001cb00          rbp = 0x16;
14001caa7      else
14001caa7      {
14001caa9          int32_t* rax_1 = *(uint64_t*)arg1;
14001caac          rbp = 0x16;
14001caac          
14001cab4          if (rax_1)
14001cab4          {
14001caba              if (rax_1 == -1)
14001caba              {
14001caef                  *(uint64_t*)arg1 = 0;
14001caf6                  rbp = 0;
14001caba              }
14001caba              else if (*(uint32_t*)rax_1 == 0xbab1f0ed)
14001cac2              {
14001cae3                  rbp = 0x10;
14001cae3                  
14001caea                  if (!rax_1[1])
14001caea                  {
14001caec                      *(uint64_t*)arg2 = rax_1;
14001caef                      *(uint64_t*)arg1 = 0;
14001caf6                      rbp = 0;
14001caea                  }
14001cac2              }
14001cab4          }
14001caa7      }
14001caa7      
14001cac7      pthread_spin_unlock(&rwl_global);
14001cad6      return (uint64_t)rbp;
14001ca80  }

14001cad7                                                                       66 0f 1f 84 00 00 00 00 00                         f........
14001cafa                                                                                66 0f 1f 44 00 00                            f..D..
14001cb07                       66 0f 1f 84 00 00 00 00 00                                                         f........

14001cb10    uint64_t rwl_ref_unlock(int64_t* arg1)

14001cb10  {
14001cb23      pthread_spin_lock(&rwl_global);
14001cb2b      int32_t rbx_1;
14001cb2b      
14001cb2b      if (!arg1)
14001cb70          rbx_1 = 0x16;
14001cb2b      else
14001cb2b      {
14001cb2d          int32_t* rax_1 = *(uint64_t*)arg1;
14001cb30          rbx_1 = 0x16;
14001cb30          
14001cb40          if (rax_1 && *(uint32_t*)rax_1 == 0xbab1f0ed)
14001cb40          {
14001cb5c              rbx_1 = 1;
14001cb5c              
14001cb61              if (rax_1 != -1)
14001cb61              {
14001cb63                  rax_1[1] += 1;
14001cb67                  rbx_1 = 0;
14001cb61              }
14001cb40          }
14001cb2b      }
14001cb2b      
14001cb45      pthread_spin_unlock(&rwl_global);
14001cb52      return (uint64_t)rbx_1;
14001cb10  }

14001cb53                                                           0f 1f 44 00 00                                             ..D..
14001cb6b                                   0f 1f 44 00 00                                                             ..D..
14001cb77                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001cb80    uint64_t rwl_unref(int64_t* arg1, int32_t arg2)

14001cb80  {
14001cb96      pthread_spin_lock(&rwl_global);
14001cb96      
14001cbae      if (**(uint32_t**)arg1 == 0xbab1f0ed && *(uint32_t*)(*(uint64_t*)arg1 + 4) > 0)
14001cbae      {
14001cbb0          void* rax_3 = *(uint64_t*)arg1;
14001cbb6          *(uint32_t*)((char*)rax_3 + 4) -= 1;
14001cbba          pthread_spin_unlock(&rwl_global);
14001cbc8          return (uint64_t)arg2;
14001cbae      }
14001cbae      
14001cbd4      int32_t var_28 = 0x28;
14001cbf4      fprintf(__acrt_iob_func(2), "Assertion failed: (%s), file %s, line %d\n", 
14001cbf4          "(((rwlock_t *)*rwl)->valid == LIFE_RWLOCK) && (((rwlock_t *)*rwl)->busy > 0)");
14001cbfe      exit(1);
14001cbfe      /* no return */
14001cb80  }

14001cc03           90 66 66 2e 0f 1f 84 00 00 00 00 00 90                                                     .ff..........

14001cc10    int64_t st_cancelwrite(void* arg1)

14001cc10  {
14001cc18      int32_t rax_1 = -(*(uint32_t*)((char*)arg1 + 0x10));
14001cc1d      *(uint32_t*)((char*)arg1 + 0x10) = 0;
14001cc24      *(uint32_t*)((char*)arg1 + 0xc) = rax_1;
14001cc2b      pthread_mutex_unlock((char*)arg1 + 0x20);
14001cc39      /* tailcall */
14001cc39      return pthread_mutex_unlock((char*)arg1 + 0x18);
14001cc10  }

14001cc3e                                                                                            66 90                                f.

14001cc40    int64_t rwl_print_set(int32_t arg1)

14001cc40  {
14001cc40      _.bss = arg1;
14001cc40  }

14001cc47                       66 0f 1f 84 00 00 00 00 00                                                         f........

14001cc50    int64_t rwl_print(int64_t* arg1)

14001cc50  {
14001cc58      int32_t _.bss_1 = _.bss;
14001cc58      
14001cc66      if (!_.bss_1)
14001cce3          return _.bss_1;
14001cce3      
14001cc68      int32_t* rax = *(uint64_t*)arg1;
14001cc68      
14001cc6e      if (!rax)
14001cc6e      {
14001cc70          GetCurrentThreadId();
14001cc8e          /* tailcall */
14001cc8e          return printf("RWL%p %d %s\n", *(uint64_t*)arg1);
14001cc6e      }
14001cc6e      
14001cc98      int32_t rbp_1 = rax[1];
14001cc9b      *(uint32_t*)rax;
14001cc9d      GetCurrentThreadId();
14001ccad      int64_t rdx;
14001ccad      int64_t var_38_1 = rdx;
14001ccb5      int32_t var_48_1 = 0;
14001ccbd      int64_t var_40_1 = 0;
14001ccc6      int32_t var_50_1 = 0;
14001ccd1      int32_t var_58_1 = rbp_1;
14001ccd5      return printf("RWL%p %d V=%0X B=%d r=%ld w=%ld L=%p %s\n", *(uint64_t*)arg1);
14001cc50  }

14001cc93                                                           0f 1f 44 00 00                                             ..D..
14001cce4              66 66 2e 0f 1f 84 00 00 00 00 00 90                                                      ff..........

14001ccf0    uint64_t pthread_rwlock_init(int64_t* arg1)

14001ccf0  {
14001cd00      if (!arg1)
14001cdc1          return 0x16;
14001cdc1      
14001cd06      *(uint64_t*)arg1 = 0;
14001cd17      int32_t* rax = calloc(1, 0x30);
14001cd22      int32_t rsi_1;
14001cd22      
14001cd22      if (!rax)
14001cde2          rsi_1 = 0xc;
14001cd22      else
14001cd22      {
14001cd2e          *(uint32_t*)rax = 0xdeadb0ef;
14001cd34          rax[4] = 0;
14001cd3e          *(uint64_t*)((char*)rax + 8) = 0;
14001cd46          int32_t rax_1 = pthread_mutex_init(&rax[6], nullptr);
14001cd46          
14001cd4f          if (rax_1)
14001cd4f          {
14001cd9b              free(rax);
14001cdac              return (uint64_t)rax_1;
14001cd4f          }
14001cd4f          
14001cd5a          int32_t rax_2 = pthread_mutex_init(&rax[8], nullptr);
14001cd5a          
14001cd63          if (rax_2)
14001cd63          {
14001cd93              pthread_mutex_destroy(&rax[6]);
14001cd9b              free(rax);
14001cdac              return (uint64_t)rax_2;
14001cd63          }
14001cd63          
14001cd6b          int32_t rax_3 = pthread_cond_init(&rax[0xa], nullptr);
14001cd72          rsi_1 = rax_3;
14001cd72          
14001cd74          if (rax_3)
14001cd74          {
14001cdcb              pthread_mutex_destroy(&rax[6]);
14001cdd3              pthread_mutex_destroy(&rax[8]);
14001cddb              free(rax);
14001cd74          }
14001cd74          else
14001cd74          {
14001cd76              *(uint32_t*)rax = 0xbab1f0ed;
14001cd7c              *(uint64_t*)arg1 = rax;
14001cd74          }
14001cd22      }
14001cd22      
14001cd8b      return (uint64_t)rsi_1;
14001ccf0  }

14001cd8c                                      0f 1f 40 00                                                              ..@.
14001cdad                                         0f 1f 00                                                               ...
14001cdc2        66 0f 1f 44 00 00                                                                            f..D..
14001cde9                             0f 1f 80 00 00 00 00                                                           .......

14001cdf0    uint64_t rwlock_static_init(int64_t* arg1)

14001cdf0  {
14001ce03      pthread_spin_lock(&_.data);
14001ce03      
14001ce0c      if (*(uint64_t*)arg1 != -1)
14001ce0c      {
14001ce38          pthread_spin_unlock(&_.data);
14001ce45          return 0x16;
14001ce0c      }
14001ce0c      
14001ce13      int32_t rax = pthread_rwlock_init(arg1);
14001ce1d      pthread_spin_unlock(&_.data);
14001ce2a      return (uint64_t)rax;
14001cdf0  }

14001ce2b                                   0f 1f 44 00 00                                                             ..D..
14001ce46                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

14001ce50    uint64_t rwl_ref.constprop.0(int64_t* arg1)

14001ce50  {
14001ce5e      int32_t rax_3;
14001ce5e      int32_t rsi_1;
14001ce5e      
14001ce5e      if (*(uint64_t*)arg1 == -1)
14001ce5e      {
14001cea0          rax_3 = rwlock_static_init(arg1);
14001ceaa          rsi_1 = rax_3;
14001ce5e      }
14001ce5e      
14001ceac      if (*(uint64_t*)arg1 != -1 || !(rax_3 & 0xffffffef))
14001ceac      {
14001ce67          rsi_1 = 0x16;
14001ce6f          pthread_spin_lock(&rwl_global);
14001ce74          int32_t* rax_1 = *(uint64_t*)arg1;
14001ce74          
14001ce96          if (rax_1 && *(uint32_t*)rax_1 == 0xbab1f0ed)
14001ce96          {
14001ce98              rax_1[1] += 1;
14001ce9c              rsi_1 = 0;
14001ce96          }
14001ce96          
14001ce7f          pthread_spin_unlock(&rwl_global);
14001ceac      }
14001ceac      
14001ce8d      return (uint64_t)rsi_1;
14001ce50  }

14001ce8e                                            66 90                                                                f.

14001ceb0    uint64_t pthread_rwlock_destroy(int64_t* arg1)

14001ceb0  {
14001cec9      pthread_spin_lock(&_.data);
14001cede      int32_t* var_40;
14001cede      int32_t rbx = rwl_ref_destroy(arg1, &var_40);
14001cee0      pthread_spin_unlock(&_.data);
14001cee0      
14001cee7      if (!rbx)
14001cee7      {
14001cee9          int32_t* rsi_1 = var_40;
14001cee9          
14001cef1          if (rsi_1)
14001cef1          {
14001cf0f              int32_t rax_2 = pthread_mutex_lock(&rsi_1[6]);
14001cf0f              
14001cf18              if (rax_2)
14001cf18              {
14001cf1c                  *(uint64_t*)arg1 = rsi_1;
14001cf2e                  return (uint64_t)rax_2;
14001cf18              }
14001cf18              
14001cf37              int32_t rax_4 = pthread_mutex_lock(&rsi_1[8]);
14001cf37              
14001cf40              if (rax_4)
14001cf40              {
14001cfd3                  pthread_mutex_unlock(&rsi_1[6]);
14001cf1c                  *(uint64_t*)arg1 = rsi_1;
14001cf2e                  return (uint64_t)rax_4;
14001cf40              }
14001cf40              
14001cf53              if (rsi_1[3] > rsi_1[4] || rsi_1[2] > 0)
14001cf53              {
14001cf55                  *(uint64_t*)arg1 = rsi_1;
14001cf5c                  int32_t rax_7 = pthread_mutex_unlock(&rsi_1[8]);
14001cf66                  int32_t rax_8 = pthread_mutex_unlock(&rsi_1[6]);
14001cf6d                  rbx = rax_8;
14001cf6d                  
14001cf6f                  if (!rax_8)
14001cf6f                  {
14001cf73                      rbx = 0x10;
14001cf73                      
14001cf78                      if (rax_7)
14001cf78                          rbx = rax_7;
14001cf6f                  }
14001cf53              }
14001cf53              else
14001cf53              {
14001cf83                  *(uint32_t*)rsi_1 = 0xdeadb0ef;
14001cf91                  int32_t rdi_1 = pthread_mutex_unlock(&rsi_1[8]);
14001cf93                  int32_t rax_10 = pthread_mutex_unlock(&rsi_1[6]);
14001cf93                  
14001cf9a                  if (rdi_1)
14001cf9a                  {
14001cf1c                      *(uint64_t*)arg1 = rsi_1;
14001cf2e                      return (uint64_t)rdi_1;
14001cf9a                  }
14001cf9a                  
14001cfa2                  if (rax_10)
14001cfa2                  {
14001cf1c                      *(uint64_t*)arg1 = rsi_1;
14001cf2e                      return (uint64_t)rax_10;
14001cfa2                  }
14001cfa2                  
14001cfa8                  pthread_cond_destroy(&rsi_1[0xa]);
14001cfb0                  pthread_mutex_destroy(&rsi_1[6]);
14001cfb8                  pthread_mutex_destroy(&rsi_1[8]);
14001cfc0                  free(rsi_1);
14001cf53              }
14001cef1          }
14001cee7      }
14001cee7      
14001cf01      return (uint64_t)rbx;
14001ceb0  }

14001cf02        66 0f 1f 44 00 00                                                                            f..D..
14001cf2f                                               90                                                                 .
14001cfca                                66 0f 1f 44 00 00                                                            f..D..
14001cfe4              66 66 2e 0f 1f 84 00 00 00 00 00 90                                                      ff..........

14001cff0    int64_t pthread_rwlock_rdlock(int64_t* arg1)

14001cff0  {
14001cffd      int32_t result = rwl_ref.constprop.0(arg1);
14001cffd      
14001d004      if (result)
14001d010          return result;
14001d010      
14001d018      void* rsi = *(uint64_t*)arg1;
14001d022      int32_t rax = pthread_mutex_lock((char*)rsi + 0x18);
14001d029      int32_t rdx;
14001d029      
14001d029      if (rax)
14001d041          rdx = rax;
14001d029      else
14001d029      {
14001d02b          *(uint32_t*)((char*)rsi + 0xc) += 1;
14001d02b          
14001d037          if (*(uint32_t*)((char*)rsi + 0xc) == 0x7fffffff)
14001d037          {
14001d05f              int32_t rax_2 = pthread_mutex_lock((char*)rsi + 0x20);
14001d05f              
14001d068              if (!rax_2)
14001d068              {
14001d080                  int32_t rax_3 = *(uint32_t*)((char*)rsi + 0x10);
14001d086                  *(uint32_t*)((char*)rsi + 0x10) = 0;
14001d08d                  *(uint32_t*)((char*)rsi + 0xc) -= rax_3;
14001d098                  int32_t rsi_1 = pthread_mutex_unlock((char*)rsi + 0x20);
14001d09a                  int32_t rax_5 = pthread_mutex_unlock((char*)rsi + 0x18);
14001d09a                  
14001d0a1                  if (!rsi_1)
14001d0a1                      rsi_1 = rax_5;
14001d0a1                  
14001d0a4                  rdx = rsi_1;
14001d068              }
14001d068              else
14001d068              {
14001d06d                  pthread_mutex_unlock((char*)rsi + 0x18);
14001d072                  rdx = rax_2;
14001d068              }
14001d037          }
14001d037          else
14001d041              rdx = pthread_mutex_unlock((char*)rsi + 0x18);
14001d029      }
14001d029      
14001d050      /* tailcall */
14001d050      return rwl_unref(arg1, rdx);
14001cff0  }

14001d011                                                     0f 1f 80 00 00 00 00                                           .......
14001d055                                                                 0f 1f 00                                               ...
14001d076                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
14001d0a8                          0f 1f 84 00 00 00 00 00                                                          ........

14001d0b0    int64_t pthread_rwlock_timedrdlock(int64_t* arg1, int64_t* arg2)

14001d0b0  {
14001d0c0      int32_t result = rwl_ref.constprop.0(arg1);
14001d0c0      
14001d0c7      if (result)
14001d0d3          return result;
14001d0d3      
14001d0d8      void* rsi = *(uint64_t*)arg1;
14001d0e5      int32_t rax = pthread_mutex_timedlock((char*)rsi + 0x18, arg2);
14001d0ec      int32_t rdx_1;
14001d0ec      
14001d0ec      if (rax)
14001d104          rdx_1 = rax;
14001d0ec      else
14001d0ec      {
14001d0ee          *(uint32_t*)((char*)rsi + 0xc) += 1;
14001d0ee          
14001d0fa          if (*(uint32_t*)((char*)rsi + 0xc) == 0x7fffffff)
14001d0fa          {
14001d12a              int32_t rax_2 = pthread_mutex_timedlock((char*)rsi + 0x20, arg2);
14001d12a              
14001d133              if (!rax_2)
14001d133              {
14001d150                  int32_t rax_3 = *(uint32_t*)((char*)rsi + 0x10);
14001d156                  *(uint32_t*)((char*)rsi + 0x10) = 0;
14001d15d                  *(uint32_t*)((char*)rsi + 0xc) -= rax_3;
14001d168                  int32_t rsi_1 = pthread_mutex_unlock((char*)rsi + 0x20);
14001d16a                  int32_t rax_5 = pthread_mutex_unlock((char*)rsi + 0x18);
14001d16a                  
14001d171                  if (!rsi_1)
14001d171                      rsi_1 = rax_5;
14001d171                  
14001d174                  rdx_1 = rsi_1;
14001d133              }
14001d133              else
14001d133              {
14001d13a                  if (rax_2 == 0x8a)
14001d180                      *(uint32_t*)((char*)rsi + 0x10) += 1;
14001d180                  
14001d13f                  pthread_mutex_unlock((char*)rsi + 0x18);
14001d144                  rdx_1 = rax_2;
14001d133              }
14001d0fa          }
14001d0fa          else
14001d104              rdx_1 = pthread_mutex_unlock((char*)rsi + 0x18);
14001d0ec      }
14001d0ec      
14001d113      /* tailcall */
14001d113      return rwl_unref(arg1, rdx_1);
14001d0b0  }

14001d0d4                                                              0f 1f 40 00                                              ..@.
14001d118                                                                          0f 1f 84 00 00 00 00 00                          ........
14001d148                          0f 1f 84 00 00 00 00 00                                                          ........
14001d178                                                                          0f 1f 84 00 00 00 00 00                          ........
14001d187                       66 0f 1f 84 00 00 00 00 00                                                         f........

14001d190    int64_t pthread_rwlock_tryrdlock(int64_t* arg1)

14001d190  {
14001d19d      int32_t result = rwl_ref.constprop.0(arg1);
14001d19d      
14001d1a4      if (result)
14001d1b0          return result;
14001d1b0      
14001d1b8      void* rsi = *(uint64_t*)arg1;
14001d1c2      int32_t rax = pthread_mutex_trylock((char*)rsi + 0x18);
14001d1c9      int32_t rdx;
14001d1c9      
14001d1c9      if (rax)
14001d1e1          rdx = rax;
14001d1c9      else
14001d1c9      {
14001d1cb          *(uint32_t*)((char*)rsi + 0xc) += 1;
14001d1cb          
14001d1d7          if (*(uint32_t*)((char*)rsi + 0xc) == 0x7fffffff)
14001d1d7          {
14001d1ff              int32_t rax_2 = pthread_mutex_lock((char*)rsi + 0x20);
14001d1ff              
14001d208              if (!rax_2)
14001d208              {
14001d220                  int32_t rax_3 = *(uint32_t*)((char*)rsi + 0x10);
14001d226                  *(uint32_t*)((char*)rsi + 0x10) = 0;
14001d22d                  *(uint32_t*)((char*)rsi + 0xc) -= rax_3;
14001d238                  int32_t rsi_1 = pthread_mutex_unlock((char*)rsi + 0x20);
14001d23a                  int32_t rax_5 = pthread_mutex_unlock((char*)rsi + 0x18);
14001d23a                  
14001d241                  if (!rsi_1)
14001d241                      rsi_1 = rax_5;
14001d241                  
14001d244                  rdx = rsi_1;
14001d208              }
14001d208              else
14001d208              {
14001d20d                  pthread_mutex_unlock((char*)rsi + 0x18);
14001d212                  rdx = rax_2;
14001d208              }
14001d1d7          }
14001d1d7          else
14001d1e1              rdx = pthread_mutex_unlock((char*)rsi + 0x18);
14001d1c9      }
14001d1c9      
14001d1f0      /* tailcall */
14001d1f0      return rwl_unref(arg1, rdx);
14001d190  }

14001d1b1                                                     0f 1f 80 00 00 00 00                                           .......
14001d1f5                                                                 0f 1f 00                                               ...
14001d216                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
14001d248                          0f 1f 84 00 00 00 00 00                                                          ........

14001d250    int64_t pthread_rwlock_trywrlock(int64_t* arg1)

14001d250  {
14001d25d      int32_t result = rwl_ref.constprop.0(arg1);
14001d25d      
14001d264      if (result)
14001d270          return result;
14001d270      
14001d278      void* rsi = *(uint64_t*)arg1;
14001d282      int32_t rax = pthread_mutex_trylock((char*)rsi + 0x18);
14001d289      int32_t rdx = rax;
14001d289      
14001d28b      if (!rax)
14001d28b      {
14001d294          int32_t rax_1 = pthread_mutex_trylock((char*)rsi + 0x20);
14001d29b          int32_t rdi_1 = rax_1;
14001d29b          
14001d29d          if (rax_1)
14001d29d          {
14001d30b              int32_t rax_7 = pthread_mutex_unlock((char*)rsi + 0x18);
14001d30b              
14001d312              if (rax_7)
14001d312                  rdi_1 = rax_7;
14001d312              
14001d315              rdx = rdi_1;
14001d29d          }
14001d29d          else
14001d29d          {
14001d2a2              rdx = 0x10;
14001d2a2              
14001d2a9              if (!*(uint32_t*)((char*)rsi + 8))
14001d2a9              {
14001d2ab                  int32_t rdx_1 = *(uint32_t*)((char*)rsi + 0x10);
14001d2ae                  int32_t rax_3 = *(uint32_t*)((char*)rsi + 0xc);
14001d2ae                  
14001d2b3                  if (rdx_1 > 0)
14001d2b3                  {
14001d2b5                      rax_3 -= rdx_1;
14001d2b7                      *(uint32_t*)((char*)rsi + 0x10) = 0;
14001d2be                      *(uint32_t*)((char*)rsi + 0xc) = rax_3;
14001d2b3                  }
14001d2b3                  
14001d2c3                  if (rax_3 > 0)
14001d2c3                  {
14001d2eb                      int32_t rsi_1 = pthread_mutex_unlock((char*)rsi + 0x20);
14001d2ed                      int32_t rax_6 = pthread_mutex_unlock((char*)rsi + 0x18);
14001d2ed                      
14001d2f4                      if (!rsi_1)
14001d2f4                      {
14001d2f8                          rsi_1 = 0x10;
14001d2f8                          
14001d2fd                          if (rax_6)
14001d2fd                              rsi_1 = rax_6;
14001d2f4                      }
14001d2f4                      
14001d300                      rdx = rsi_1;
14001d2c3                  }
14001d2c3                  else
14001d2c3                  {
14001d2c5                      *(uint32_t*)((char*)rsi + 8) = 1;
14001d2cc                      rdx = 0;
14001d2c3                  }
14001d2a9              }
14001d29d          }
14001d28b      }
14001d28b      
14001d2db      /* tailcall */
14001d2db      return rwl_unref(arg1, rdx);
14001d250  }

14001d271                                                     0f 1f 80 00 00 00 00                                           .......
14001d304              0f 1f 40 00                                                                              ..@.
14001d319                                                                             0f 1f 80 00 00 00 00                           .......

14001d320    int64_t pthread_rwlock_unlock(int64_t* arg1)

14001d320  {
14001d32b      int32_t result = rwl_ref_unlock(arg1);
14001d32b      
14001d332      if (result)
14001d3a8          return result;
14001d3a8      
14001d334      void* rdi = *(uint64_t*)arg1;
14001d340      int32_t rsi;
14001d340      
14001d340      if (!*(uint32_t*)((char*)rdi + 8))
14001d340      {
14001d37b          int32_t rax_3 = pthread_mutex_lock((char*)rdi + 0x20);
14001d382          rsi = rax_3;
14001d382          
14001d384          if (!rax_3)
14001d384          {
14001d386              *(uint32_t*)((char*)rdi + 0x10) += 1;
14001d386              
14001d390              if (!*(uint32_t*)((char*)rdi + 0x10))
14001d390              {
14001d3bc                  rsi = pthread_cond_signal((char*)rdi + 0x28);
14001d3be                  int32_t rax_7 = pthread_mutex_unlock((char*)rdi + 0x20);
14001d3be                  
14001d3c5                  if (!rsi)
14001d3c5                      rsi = rax_7;
14001d390              }
14001d390              else
14001d39a                  rsi = pthread_mutex_unlock((char*)rdi + 0x20);
14001d384          }
14001d340      }
14001d340      else
14001d340      {
14001d342          *(uint32_t*)((char*)rdi + 8) -= 1;
14001d353          rsi = pthread_mutex_unlock((char*)rdi + 0x20);
14001d355          int32_t rax_1 = pthread_mutex_unlock((char*)rdi + 0x18);
14001d355          
14001d35c          if (!rsi)
14001d35c              rsi = rax_1;
14001d340      }
14001d340      
14001d36c      /* tailcall */
14001d36c      return rwl_unref(arg1, rsi);
14001d320  }

14001d371                                                     0f 1f 80 00 00 00 00                                           .......
14001d39e                                                                                            66 90                                f.
14001d3a9                             0f 1f 80 00 00 00 00                                                           .......
14001d3ca                                66 0f 1f 44 00 00                                                            f..D..

14001d3d0    int64_t pthread_rwlock_wrlock(int64_t* arg1)

14001d3d0  {
14001d3df      int32_t result = rwl_ref.constprop.0(arg1);
14001d3df      
14001d3e6      if (result)
14001d3f4          return result;
14001d3f4      
14001d3f8      void* rsi = *(uint64_t*)arg1;
14001d402      int32_t rax = pthread_mutex_lock((char*)rsi + 0x18);
14001d409      int32_t rbp = rax;
14001d409      
14001d40b      if (!rax)
14001d40b      {
14001d414          int32_t rax_1 = pthread_mutex_lock((char*)rsi + 0x20);
14001d41b          rbp = rax_1;
14001d41b          
14001d41d          if (rax_1)
14001d4e3              pthread_mutex_unlock((char*)rsi + 0x18);
14001d41d          else
14001d41d          {
14001d428              if (!*(uint32_t*)((char*)rsi + 8))
14001d428              {
14001d42a                  int32_t rdx_2 = *(uint32_t*)((char*)rsi + 0x10);
14001d42d                  int32_t rax_2 = *(uint32_t*)((char*)rsi + 0xc);
14001d42d                  
14001d432                  if (rdx_2 > 0)
14001d432                  {
14001d434                      rax_2 -= rdx_2;
14001d436                      *(uint32_t*)((char*)rsi + 0x10) = 0;
14001d43d                      *(uint32_t*)((char*)rsi + 0xc) = rax_2;
14001d432                  }
14001d432                  
14001d442                  if (rax_2 > 0)
14001d442                  {
14001d46b                      *(uint32_t*)((char*)rsi + 0x10) = -(rax_2);
14001d475                      int64_t (* var_58)(void* arg1) = st_cancelwrite;
14001d47f                      int64_t rax_6 = *(uint64_t*)pthread_getclean();
14001d497                      *(uint64_t*)pthread_getclean() = &var_58;
14001d49a                      int64_t var_78;
14001d49a                      int64_t var_78_2 = var_78;
14001d49a                      
14001d4ad                      do
14001d4ad                      {
14001d4b5                          int32_t rax_9 =
14001d4b5                              pthread_cond_wait((char*)rsi + 0x28, (char*)rsi + 0x20);
14001d4b5                          
14001d4be                          if (rax_9)
14001d4be                          {
14001d4ca                              rbp = rax_9;
14001d4cc                              *(uint64_t*)pthread_getclean() = rax_6;
14001d4d4                              var_58(rsi);
14001d4d8                              goto label_14001d45a;
14001d4be                          }
14001d4ad                      } while (*(uint32_t*)((char*)rsi + 0x10) < 0);
14001d4ad                      
14001d4fa                      *(uint64_t*)pthread_getclean() = rax_6;
14001d4fd                      *(uint32_t*)((char*)rsi + 0xc) = 0;
14001d442                  }
14001d428              }
14001d428              
14001d444              *(uint32_t*)((char*)rsi + 8) += 1;
14001d41d          }
14001d40b      }
14001d40b      
14001d45a  label_14001d45a:
14001d45a      /* tailcall */
14001d45a      return rwl_unref(arg1, rbp);
14001d3d0  }

14001d3f5                                                                 0f 1f 00                                               ...
14001d45f                                                                                               90                                 .
14001d4a2        66 0f 1f 44 00 00                                                                            f..D..
14001d4dd                                                                                         0f 1f 00                               ...
14001d4ed                                         0f 1f 00                                                               ...
14001d509                             0f 1f 80 00 00 00 00                                                           .......

14001d510    int64_t pthread_rwlock_timedwrlock(int64_t* arg1, int64_t* arg2)

14001d510  {
14001d530      if (!arg1 || !arg2)
14001d5d3          return 0x16;
14001d5d3      
14001d536      int32_t result = rwl_ref.constprop.0(arg1);
14001d536      
14001d53d      if (result)
14001d54d          return result;
14001d54d      
14001d550      void* rdi = *(uint64_t*)arg1;
14001d55d      int32_t i_4 = pthread_mutex_timedlock((char*)rdi + 0x18, arg2);
14001d564      int32_t i_3 = i_4;
14001d564      
14001d566      if (!i_4)
14001d566      {
14001d572          int32_t i_2 = pthread_mutex_timedlock((char*)rdi + 0x20, arg2);
14001d579          int32_t i_1 = i_2;
14001d579          
14001d57c          if (i_2)
14001d5db              pthread_mutex_unlock((char*)rdi + 0x18);
14001d57c          else if (*(uint32_t*)((char*)rdi + 8))
14001d59f              *(uint32_t*)((char*)rdi + 8) += 1;
14001d583          else
14001d583          {
14001d585              int32_t rdx_3 = *(uint32_t*)((char*)rdi + 0x10);
14001d588              int32_t rax = *(uint32_t*)((char*)rdi + 0xc);
14001d588              
14001d58d              if (rdx_3 > 0)
14001d58d              {
14001d58f                  rax -= rdx_3;
14001d591                  *(uint32_t*)((char*)rdi + 0x10) = 0;
14001d598                  *(uint32_t*)((char*)rdi + 0xc) = rax;
14001d58d              }
14001d58d              
14001d59d              if (rax > 0)
14001d59d              {
14001d5f3                  *(uint32_t*)((char*)rdi + 0x10) = -(rax);
14001d5fd                  int64_t (* var_58)(void* arg1) = st_cancelwrite;
14001d607                  int64_t rax_5 = *(uint64_t*)pthread_getclean();
14001d61f                  *(uint64_t*)pthread_getclean() = &var_58;
14001d622                  int64_t var_78;
14001d622                  int64_t var_78_2 = var_78;
14001d632                  int32_t i;
14001d632                  
14001d632                  do
14001d632                  {
14001d63d                      i = pthread_cond_timedwait((char*)rdi + 0x28, (char*)rdi + 0x20, 
14001d63d                          arg2);
14001d63d                      
14001d649                      if (*(uint32_t*)((char*)rdi + 0x10) >= 0)
14001d649                          break;
14001d632                  } while (!i);
14001d632                  
14001d657                  *(uint64_t*)pthread_getclean() = rax_5;
14001d657                  
14001d65a                  if (i)
14001d65a                  {
14001d675                      i_1 = i;
14001d678                      var_58(rdi);
14001d65a                  }
14001d65a                  else
14001d65a                  {
14001d65c                      *(uint32_t*)((char*)rdi + 0xc) = 0;
14001d59f                      *(uint32_t*)((char*)rdi + 8) += 1;
14001d65a                  }
14001d59d              }
14001d59d              else
14001d59f                  *(uint32_t*)((char*)rdi + 8) += 1;
14001d583          }
14001d583          
14001d5a4          i_3 = i_1;
14001d566      }
14001d566      
14001d5b8      /* tailcall */
14001d5b8      return rwl_unref(arg1, i_3);
14001d510  }

14001d54e                                            66 90                                                                f.
14001d5bd                                                                                         0f 1f 00                               ...
14001d5d4                                                              0f 1f 40 00                                              ..@.
14001d5e2        66 0f 1f 44 00 00                                                                            f..D..
14001d62a                                66 0f 1f 44 00 00                                                            f..D..
14001d668                          0f 1f 84 00 00 00 00 00                                                          ........
14001d681     66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00                                                   ff...........@.

14001d690    uint64_t pthread_rwlockattr_destroy(int64_t arg1, int32_t arg2 @ rax) __pure

14001d690  {
14001d699      return (uint64_t)(arg2 - arg2) & 0x16;
14001d690  }

14001d69a                                                                                66 0f 1f 44 00 00                            f..D..

14001d6a0    int64_t pthread_rwlockattr_init(int32_t* arg1)

14001d6a0  {
14001d6a3      if (!arg1)
14001d6b5          return 0x16;
14001d6b5      
14001d6a7      *(uint32_t*)arg1 = 0;
14001d6ad      return 0;
14001d6a0  }

14001d6ae                                            66 90                                                                f.
14001d6b6                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........

14001d6c0    int64_t pthread_rwlockattr_getpshared(int32_t* arg1, int32_t* arg2)

14001d6c0  {
14001d6c8      if (!arg1 || !arg2)
14001d6dd          return 0x16;
14001d6dd      
14001d6cc      *(uint32_t*)arg2 = *(uint32_t*)arg1;
14001d6d0      return 0;
14001d6c0  }

14001d6d1                                                     0f 1f 80 00 00 00 00                                           .......
14001d6de                                                                                            66 90                                f.

14001d6e0    int64_t pthread_rwlockattr_setpshared(int32_t* arg1, int32_t arg2)

14001d6e0  {
14001d6e8      if (!arg1 || arg2 > 1)
14001d6f5          return 0x16;
14001d6f5      
14001d6ec      *(uint32_t*)arg1 = arg2;
14001d6ee      return 0;
14001d6e0  }

14001d6ef                                               90                                                                 .
14001d6f6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

14001d700    int64_t pthread_spin_init(int64_t* arg1)

14001d700  {
14001d702      *(uint64_t*)arg1 = -1;
14001d709      return 0;
14001d700  }

14001d70a                                66 0f 1f 44 00 00                                                            f..D..

14001d710    int64_t pthread_spin_destroy() __pure

14001d710  {
14001d712      return 0;
14001d710  }

14001d713                                                           66 66 2e 0f 1f 84 00 00 00 00 00 66 90                     ff.........f.

14001d720    int64_t pthread_spin_lock(int64_t* arg1)

14001d720  {
14001d725      while (true)
14001d725      {
14001d725          int64_t temp0_1 = *(uint64_t*)arg1;
14001d725          *(uint64_t*)arg1 = 0;
14001d725          
14001d72b          if (temp0_1)
14001d72b              break;
14001d72b          
14001d735          while (!*(uint64_t*)arg1)
14001d735              /* nop */
14001d725      }
14001d725      
14001d72f      return 0;
14001d720  }

14001d73c                                                                                      0f 1f 40 00                              ..@.

14001d740    uint64_t pthread_spin_trylock(int64_t* arg1)

14001d740  {
14001d742      int64_t temp0 = *(uint64_t*)arg1;
14001d742      *(uint64_t*)arg1 = 0;
14001d748      int64_t rax;
14001d748      (uint8_t)rax = !temp0;
14001d751      return (uint64_t)((uint32_t)(uint8_t)rax << 4);
14001d740  }

14001d752                                                        66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                    ff............

14001d760    int64_t pthread_spin_unlock(int64_t* arg1)

14001d760  {
14001d762      *(uint64_t*)arg1 = -1;
14001d769      return 0;
14001d760  }

14001d76a                                90 90 90 90 90 90                                                            ......

14001d770    int64_t do_sema_b_release(HANDLE arg1, int32_t arg2, CRITICAL_SECTION* arg3, int32_t* arg4)

14001d770  {
14001d786      EnterCriticalSection(arg3);
14001d78c      int64_t rax = (int64_t)*(uint32_t*)arg4;
14001d792      int32_t rdx = (uint32_t)rax;
14001d792      
14001d79e      if (rax + (int64_t)arg2 > 0x7fffffff)
14001d79e      {
14001d7db          LeaveCriticalSection(arg3);
14001d7ee          return 0x22;
14001d79e      }
14001d79e      
14001d7a0      *(uint32_t*)arg4 += arg2;
14001d7a0      
14001d7a5      if (rdx < 0)
14001d7a5      {
14001d7a7          int32_t lReleaseCount = -(rdx);
14001d7a7          
14001d7ae          if (lReleaseCount > arg2)
14001d7ae              lReleaseCount = arg2;
14001d7ae          
14001d7bc          if (!ReleaseSemaphore(arg1, lReleaseCount, nullptr))
14001d7bc          {
14001d7f2              *(uint32_t*)arg4 += -(arg2);
14001d7f8              LeaveCriticalSection(arg3);
14001d80b              return 0x16;
14001d7bc          }
14001d7a5      }
14001d7a5      
14001d7c1      LeaveCriticalSection(arg3);
14001d7d1      return 0;
14001d770  }

14001d7d2                                                        66 0f 1f 44 00 00                                            f..D..
14001d7ef                                               90                                                                 .
14001d80c                                      0f 1f 40 00                                                              ..@.

14001d810    void cond_print_set(int32_t arg1, int64_t arg2)

14001d810  {
14001d81a      if (arg2)
14001d81c          _.bss = arg2;
14001d81a      else if (!_.bss)
14001d838      {
14001d83f          FILE* rax = __acrt_iob_func(1);
14001d845          print_state = arg1;
14001d84b          _.bss = rax;
14001d857          return;
14001d838      }
14001d838      
14001d823      print_state = arg1;
14001d810  }

14001d82f                                               90                                                                 .
14001d858                                                                          0f 1f 84 00 00 00 00 00                          ........

14001d860    int64_t cond_print(int64_t* arg1, int64_t arg2)

14001d860  {
14001d868      int32_t print_state_1 = print_state;
14001d868      
14001d876      if (!print_state_1)
14001d8ad          return print_state_1;
14001d8ad      
14001d878      int32_t* rax = *(uint64_t*)arg1;
14001d878      
14001d87e      if (!rax)
14001d87e      {
14001d880          GetCurrentThreadId();
14001d890          int32_t var_48;
14001d890          var_48 = arg2;
14001d89f          return fprintf(_.bss, "C%p %d %s\n", *(uint64_t*)arg1);
14001d87e      }
14001d87e      
14001d8b0      int32_t rbp = rax[2];
14001d8b3      int32_t rdi = *(uint32_t*)rax;
14001d8b5      GetCurrentThreadId();
14001d8c5      int64_t var_38 = arg2;
14001d8d4      int32_t var_40 = rbp;
14001d8d8      int32_t var_48_1 = rdi;
14001d8ea      return fprintf(_.bss, "C%p %d V=%0X w=%ld %s\n", *(uint64_t*)arg1);
14001d860  }

14001d8ae                                            66 90                                                                f.
14001d8eb                                   0f 1f 44 00 00                                                             ..D..

14001d8f0    int64_t pthread_condattr_destroy(int32_t* arg1)

14001d8f0  {
14001d8f3      if (!arg1)
14001d905          return 0x16;
14001d905      
14001d8f7      *(uint32_t*)arg1 = 0;
14001d8fd      return 0;
14001d8f0  }

14001d8fe                                                                                            66 90                                f.
14001d906                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

14001d910    int64_t pthread_condattr_init(int32_t* arg1)

14001d910  {
14001d913      if (!arg1)
14001d925          return 0x16;
14001d925      
14001d917      *(uint32_t*)arg1 = 0;
14001d91d      return 0;
14001d910  }

14001d91e                                                                                            66 90                                f.
14001d926                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

14001d930    int64_t pthread_condattr_getpshared(int32_t* arg1, int32_t* arg2)

14001d930  {
14001d938      if (!arg1 || !arg2)
14001d94d          return 0x16;
14001d94d      
14001d93c      *(uint32_t*)arg2 = *(uint32_t*)arg1;
14001d940      return 0;
14001d930  }

14001d941     0f 1f 80 00 00 00 00                                                                           .......
14001d94e                                            66 90                                                                f.

14001d950    int64_t pthread_condattr_getclock(int64_t arg1, int32_t* arg2)

14001d950  {
14001d958      if (!arg1 || !arg2)
14001d96d          return 0x16;
14001d96d      
14001d95c      *(uint32_t*)arg2 = 0;
14001d962      return 0;
14001d950  }

14001d963           0f 1f 44 00 00                                                                             ..D..
14001d96e                                            66 90                                                                f.

14001d970    int64_t pthread_condattr_setclock(int64_t arg1, int32_t arg2) __pure

14001d970  {
14001d977      if (arg1 && !arg2)
14001d97b          return 0;
14001d97b      
14001d985      return 0x16;
14001d970  }

14001d97c                                                                                      0f 1f 40 00                              ..@.
14001d986                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

14001d990    int64_t __pthread_clock_nanosleep(int32_t arg1, int32_t arg2, int64_t* arg3, int64_t* arg4)

14001d990  {
14001d9a9      if (arg1 > 2)
14001da15          return 0x16;
14001da15      
14001d9ae      int64_t i_1;
14001d9ae      
14001d9ae      if (arg2 & 1)
14001da25          i_1 = _pthread_rel_time_in_ms(arg3);
14001d9ae      else
14001d9b5          i_1 = _pthread_time_in_ms_from_timespec(arg3);
14001d9b5      
14001d9ef      uint64_t rbx_2;
14001d9ef      int64_t i;
14001d9ef      
14001d9ef      do
14001d9ef      {
14001d9c0          uint64_t rax_2 = _pthread_time_in_ms();
14001d9c5          uint32_t rcx_1 = 0x1869f;
14001d9c5          
14001d9d0          if (i_1 <= 0x1869f)
14001d9d0              rcx_1 = (uint32_t)i_1;
14001d9d0          
14001d9d4          pthread_delay_np_ms(rcx_1);
14001d9d9          uint64_t rax_3 = _pthread_time_in_ms();
14001d9d9          
14001d9e7          if (rax_3 - rax_2 >= i_1)
14001d9e7              break;
14001d9e7          
14001d9e9          rbx_2 = rax_2 - rax_3;
14001d9ec          i = i_1;
14001d9ec          i_1 += rbx_2;
14001d9ef      } while (i != -(rbx_2));
14001d9ef      
14001d9fb      if (arg4)
14001d9fb      {
14001d9fd          *(uint64_t*)arg4 = 0;
14001da04          arg4[1] = 0;
14001d9fb      }
14001d9fb      
14001da0c      return 0;
14001d990  }

14001da16                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
14001da2a                                66 0f 1f 44 00 00                                                            f..D..

14001da30    int64_t pthread_condattr_setpshared(int32_t* arg1, int32_t arg2)

14001da30  {
14001da38      if (!arg1 || arg2 > 1)
14001da55          return 0x16;
14001da55      
14001da3a      *(uint32_t*)arg1 = 0;
14001da3a      
14001da45      if (arg2 == 1)
14001da49          return 0x28;
14001da49      
14001da47      return 0;
14001da30  }

14001da4a                                66 0f 1f 44 00 00                                                            f..D..
14001da56                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........

14001da60    int64_t pthread_cond_init(void** arg1, int32_t* arg2)

14001da60  {
14001da6d      if (!arg1)
14001db7c          return 0x16;
14001db7c      
14001da7b      if (arg2 && *(uint32_t*)arg2 == 1)
14001db80          return 0x28;
14001db80      
14001da8b      int32_t* rax = calloc(1, 0xb0);
14001da8b      
14001da96      if (!rax)
14001db87          return 0xc;
14001db87      
14001daae      *(uint128_t*)((char*)rax + 4) = {0};
14001dab8      *(uint32_t*)rax = 0xc0deadbf;
14001dac7      *(uint64_t*)((char*)rax + 0xa0) = CreateSemaphoreA(nullptr, 0, 0x7fffffff, nullptr);
14001dad4      HANDLE hObject_2 = CreateSemaphoreA(nullptr, 0, 0x7fffffff, nullptr);
14001dad6      HANDLE hObject_1 = hObject_2;
14001dad9      *(uint64_t*)((char*)rax + 0xa8) = hObject_2;
14001dae0      HANDLE hObject = *(uint64_t*)((char*)rax + 0xa0);
14001dae0      
14001daea      if (hObject)
14001daea      {
14001daef          if (hObject_1)
14001daef          {
14001dafc              InitializeCriticalSection(&rax[6]);
14001db02              InitializeCriticalSection(&rax[0x1c]);
14001db08              InitializeCriticalSection(&rax[0x10]);
14001db0a              rax[0x1a] = 0;
14001db13              rax[0x26] = 1;
14001db1d              *(uint32_t*)rax = 0xc0bab1fd;
14001db23              *(uint64_t*)arg1 = rax;
14001db2d              return 0;
14001daef          }
14001daef          
14001db33          CloseHandle(hObject);
14001db39          hObject_1 = *(uint64_t*)((char*)rax + 0xa8);
14001daea      }
14001daea      
14001db43      if (hObject_1)
14001db45          CloseHandle(hObject_1);
14001db45      
14001db4e      free(rax);
14001db58      *(uint64_t*)arg1 = nullptr;
14001db66      return 0xb;
14001da60  }

14001db2e                                            66 90                                                                f.
14001db67                       66 0f 1f 84 00 00 00 00 00                                                         f........
14001db7d                                                                                         0f 1f 00                               ...
14001db8e                                            66 90                                                                f.

14001db90    uint64_t do_sema_b_wait_intern(HANDLE arg1, int32_t arg2, uint32_t arg3)

14001db90  {
14001dba0      int32_t rbp = arg2;
14001dba2      uint32_t rbx = arg3;
14001dba5      int32_t rsi_1;
14001dba5      
14001dba5      if (arg2 == 1)
14001dba5      {
14001dd63          int32_t rax_12 = _pthread_wait_for_single_object(arg1, arg3);
14001dd63          
14001dd6d          if (rax_12 == 0x80)
14001dd6d              goto label_14001dd9a;
14001dd6d          
14001dd74          if (rax_12 == 0x102)
14001dd74          {
14001dd90              rbp = 0x8a;
14001dd9a          label_14001dd9a:
14001dd9a              rsi_1 = rbp;
14001dd9a              
14001dda4              if (!WaitForSingleObject(arg1, 0))
14001ddaa                  rsi_1 = 0;
14001ddaa              
14001dc3e          label_14001dc3e:
14001dc3e              return (uint64_t)rsi_1;
14001dd74          }
14001dd74          
14001dd78          if (!rax_12)
14001dd78          {
14001dc30          label_14001dc30:
14001dc30              rsi_1 = 0;
14001dc3e          label_14001dc3e_1:
14001dc3e              return (uint64_t)rsi_1;
14001dd78          }
14001dba5      }
14001dba5      else
14001dba5      {
14001dbab          HANDLE hHandle = arg1;
14001dbb0          void* hEvent = pthread_getevent();
14001dbb0          
14001dbbd          if (!hEvent)
14001dbbd          {
14001dc6b              uint32_t rdi_1 = 0x14;
14001dc6b              
14001dc70              if (rbx != 0xffffffff)
14001dc70              {
14001dc74                  while (true)
14001dc74                  {
14001dc74                      uint32_t r12_1 = rdi_1;
14001dc74                      
14001dc7a                      if (rbx <= rdi_1)
14001dc7a                          r12_1 = rbx;
14001dc7a                      
14001dc81                      int32_t rax_5 = _pthread_wait_for_single_object(arg1, r12_1);
14001dc81                      
14001dc8b                      if (rax_5 == 0x80)
14001dc8b                      {
14001dd12                          rsi_1 = 1;
14001dd12                          
14001dd17                          if (rdi_1 < rbx)
14001dd17                          {
14001dd20                          label_14001dd20:
14001dd20                              
14001dd27                              if (__pthread_shallcancel())
14001dc64                                  return 0x16;
14001dd17                          }
14001dc8b                      }
14001dc8b                      else if (rax_5 == 0x102)
14001dc96                      {
14001ddc2                          uint32_t temp0_1 = rbx;
14001ddc2                          rbx -= r12_1;
14001ddc2                          
14001ddc5                          if (temp0_1 == r12_1)
14001ddc5                          {
14001dded                              if (!WaitForSingleObject(arg1, 0))
14001dded                                  break;
14001dded                              
14001ddf3                              rsi_1 = 0x8a;
14001ddc5                          }
14001ddc5                          else
14001ddc5                          {
14001ddce                              if (__pthread_shallcancel())
14001dc64                                  return 0x16;
14001dc64                              
14001ddd4                              rdi_1 = r12_1;
14001ddd7                              continue;
14001ddc5                          }
14001dc96                      }
14001dc96                      else
14001dc96                      {
14001dc9c                          rsi_1 = 0;
14001dc9c                          
14001dca0                          if (!rax_5)
14001dca0                              goto label_14001dc3e_1;
14001dca0                          
14001dca4                          rsi_1 = 0x16;
14001dca4                          
14001dca9                          if (rdi_1 < rbx)
14001dca9                              goto label_14001dd20;
14001dc96                      }
14001dc96                      
14001dcae                      if (rbp == 2)
14001dcae                          goto label_14001dc3e_1;
14001dcae                      
14001dcb0                      pthread_testcancel();
14001dcb5                      goto label_14001dc3e_1;
14001dc74                  }
14001dc74                  
14001dcae                  goto label_14001dc30;
14001dc70              }
14001dc70              
14001dcd1              int32_t rax_7;
14001dcd1              
14001dcd1              while (true)
14001dcd1              {
14001dcd1                  rax_7 = _pthread_wait_for_single_object(arg1, 0x28);
14001dcd1                  
14001dcdb                  if (rax_7 == 0x80)
14001dcdb                  {
14001dd3f                      if (__pthread_shallcancel())
14001dd3f                          goto label_14001dcf9;
14001dd3f                      
14001dd50                      (uint8_t)rsi_1 = WaitForSingleObject(arg1, 0);
14001dd54                      goto label_14001dc3e_1;
14001dcdb                  }
14001dcdb                  
14001dce2                  if (rax_7 != 0x102)
14001dce2                      break;
14001dce2                  
14001dcc7                  if (__pthread_shallcancel())
14001dcc7                      goto label_14001dcf9;
14001dcd1              }
14001dcd1              
14001dce6              if (!rax_7)
14001dce6                  goto label_14001dc30;
14001dce6              
14001dcf3              if (__pthread_shallcancel())
14001dcf3              {
14001dcf9              label_14001dcf9:
14001dcf9                  
14001dcfc                  if (rbp != 2)
14001dd02                      pthread_testcancel();
14001dcf3              }
14001dbbd          }
14001dbbd          else
14001dbbd          {
14001dbd6              while (true)
14001dbd6              {
14001dbd6                  int32_t rax = _pthread_wait_for_multiple_objects(2, &hHandle, 0, rbx);
14001dbd6                  
14001dbe0                  if (rax == 0x80)
14001dbe0                  {
14001ddb8                      rsi_1 = 1;
14001dc23                  label_14001dc23:
14001dc23                      
14001dc2b                      if (!WaitForSingleObject(hHandle, 0))
14001dc2b                          goto label_14001dc30;
14001dbe0                  }
14001dbe0                  else if (rax > 0x80)
14001dbe6                  {
14001dc15                      rsi_1 = 0x8a;
14001dc15                      
14001dc1a                      if (rax == 0x102)
14001dc1a                          goto label_14001dc23;
14001dc1a                      
14001dc40                      rsi_1 = 0x16;
14001dbe6                  }
14001dbe6                  else
14001dbe6                  {
14001dbea                      if (!rax)
14001dbea                          goto label_14001dc30;
14001dbea                      
14001dbef                      if (rax == 1)
14001dbef                      {
14001dbf6                          ResetEvent(hEvent);
14001dbf6                          
14001dbff                          if (rbp != 2)
14001dbff                              break;
14001dbff                          
14001dc05                          pthread_testcancel();
14001dc0a                          continue;
14001dbef                      }
14001dbef                      
14001dc40                      rsi_1 = 0x16;
14001dbe6                  }
14001dbe6                  
14001dc48                  if (rbp == 2)
14001dc48                      goto label_14001dc3e_1;
14001dc48                  
14001dc51                  if (!__pthread_shallcancel())
14001dc51                      goto label_14001dc3e_1;
14001dc51                  
14001dc64                  return 0x16;
14001dbd6              }
14001dbd6              
14001dd02              pthread_testcancel();
14001dbbd          }
14001dba5      }
14001dc64      return 0x16;
14001db90  }

14001dc0c                                      0f 1f 40 00                                                              ..@.
14001dc3f                                                                                               90                                 .
14001dc65                 0f 1f 00                                                                               ...
14001dcba                                                                                66 0f 1f 44 00 00                            f..D..
14001dd0c                                      0f 1f 40 00                                                              ..@.
14001dd32                                                        66 0f 1f 44 00 00                                            f..D..
14001dd59                                                                             0f 1f 80 00 00 00 00                           .......
14001dd88                          0f 1f 84 00 00 00 00 00                                                          ........
14001ddb1                                                     0f 1f 80 00 00 00 00                                           .......
14001dddc                                                                                      0f 1f 40 00                              ..@.
14001ddfd                                                                                         0f 1f 00                               ...

14001de00    uint64_t do_sema_b_wait(HANDLE arg1, int32_t arg2, uint32_t arg3, CRITICAL_SECTION* arg4, int32_t* arg5)

14001de00  {
14001de26      EnterCriticalSection(arg4);
14001de31      *(uint32_t*)arg5 -= 1;
14001de3c      int32_t rdi = 0;
14001de46      int32_t rsi = *(uint32_t*)arg5;
14001de4b      LeaveCriticalSection(arg4);
14001de4b      
14001de50      if (rsi < 0)
14001de50      {
14001de79          rdi = do_sema_b_wait_intern(arg1, arg2, arg3);
14001de7b          EnterCriticalSection(arg4);
14001de7b          
14001de80          if (rdi)
14001de98              *(uint32_t*)arg5 += 1;
14001de98          
14001de85          LeaveCriticalSection(arg4);
14001de50      }
14001de50      
14001de64      return (uint64_t)rdi;
14001de00  }

14001de65                 0f 1f 00                                                                               ...
14001de8a                                66 0f 1f 44 00 00                                                            f..D..
14001de9e                                                                                            66 90                                f.

14001dea0    uint64_t pthread_cond_destroy(int64_t* arg1)

14001dea0  {
14001deb2      if (!arg1)
14001e023          return 0x16;
14001e023      
14001deb8      void* rbx = *(uint64_t*)arg1;
14001debb      int32_t rdi = 0x16;
14001debb      
14001dec3      if (rbx)
14001dec3      {
14001dec9          if (rbx == -1)
14001dec9          {
14001dfd7              int32_t rdi_1 = 0x10;
14001dfdf              pthread_spin_lock(&_.data);
14001dfdf              
14001dfe8              if (*(uint64_t*)arg1 == -1)
14001dfe8              {
14001dfea                  *(uint64_t*)arg1 = 0;
14001dff1                  rdi_1 = 0;
14001dfe8              }
14001dfe8              
14001dff6              pthread_spin_unlock(&_.data);
14001e009              return (uint64_t)rdi_1;
14001dec9          }
14001dec9          
14001def1          int32_t rax_1 = do_sema_b_wait(*(uint64_t*)((char*)rbx + 0xa8), 0, 0xffffffff, 
14001def1              (char*)rbx + 0x70, (char*)rbx + 0x98);
14001def8          rdi = rax_1;
14001def8          
14001defa          if (!rax_1)
14001defa          {
14001df17              BOOL rax_3 = TryEnterCriticalSection((char*)rbx + 0x18);
14001df1d              HANDLE rcx_2 = *(uint64_t*)((char*)rbx + 0xa8);
14001df1d              
14001df26              if (!rax_3)
14001df26              {
14001e033                  do_sema_b_release(rcx_2, 1, (char*)rbx + 0x70, (char*)rbx + 0x98);
14001e038                  rdi = 0x10;
14001df26              }
14001df26              else
14001df26              {
14001df32                  if (*(uint32_t*)((char*)rbx + 8) <= *(uint32_t*)((char*)rbx + 0x10))
14001df32                  {
14001df3f                      *(uint64_t*)arg1 = 0;
14001df46                      do_sema_b_release(rcx_2, 1, (char*)rbx + 0x70, (char*)rbx + 0x98);
14001df59                      CloseHandle(*(uint64_t*)((char*)rbx + 0xa0));
14001df62                      CloseHandle(*(uint64_t*)((char*)rbx + 0xa8));
14001df67                      LeaveCriticalSection((char*)rbx + 0x18);
14001df77                      DeleteCriticalSection((char*)rbx + 0x18);
14001df7c                      DeleteCriticalSection((char*)rbx + 0x70);
14001df82                      DeleteCriticalSection((char*)rbx + 0x40);
14001df87                      free(rbx);
14001df9a                      return (uint64_t)rdi;
14001df32                  }
14001df32                  
14001dfab                  int32_t rax_6 =
14001dfab                      do_sema_b_release(rcx_2, 1, (char*)rbx + 0x70, (char*)rbx + 0x98);
14001dfb5                  rdi = rax_6;
14001dfb5                  
14001dfbc                  if (!rax_6)
14001dfbc                      rdi = 0x10;
14001dfbc                  
14001dfbf                  LeaveCriticalSection((char*)rbx + 0x18);
14001df26              }
14001defa          }
14001dec3      }
14001dec3      
14001df0a      return (uint64_t)rdi;
14001dea0  }

14001df0b                                   0f 1f 44 00 00                                                             ..D..
14001df9b                                                                                   0f 1f 44 00 00                             ..D..
14001dfca                                66 0f 1f 44 00 00                                                            f..D..
14001e00a                                66 0f 1f 44 00 00                                                            f..D..
14001e024              0f 1f 40 00                                                                              ..@.
14001e042        66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00                                                    ff............

14001e050    uint64_t pthread_cond_signal(int64_t* arg1)

14001e050  {
14001e059      if (arg1)
14001e059      {
14001e05f          void* rbx_1 = *(uint64_t*)arg1;
14001e05f          
14001e065          if (rbx_1)
14001e065          {
14001e06f              if (rbx_1 != -1)
14001e06f              {
14001e080                  if (*(uint32_t*)rbx_1 != 0xc0bab1fd)
14001e088                      return 0x16;
14001e088                  
14001e097                  EnterCriticalSection((char*)rbx_1 + 0x18);
14001e09d                  int32_t rax_2 = *(uint32_t*)((char*)rbx_1 + 0xc);
14001e0a2                  int32_t rax_7;
14001e0a2                  int32_t rdx_2;
14001e0a2                  
14001e0a2                  if (rax_2)
14001e0a2                  {
14001e110                      int32_t rcx_2 = *(uint32_t*)((char*)rbx_1 + 8);
14001e113                      rax_7 = rax_2 + 1;
14001e116                      rdx_2 = rcx_2 - 1;
14001e116                      
14001e11b                      if (rcx_2)
14001e11b                      {
14001e11d                      label_14001e11d:
14001e11d                          *(uint32_t*)((char*)rbx_1 + 8) = rdx_2;
14001e123                          *(uint32_t*)((char*)rbx_1 + 0xc) = rax_7;
14001e126                          LeaveCriticalSection((char*)rbx_1 + 0x18);
14001e146                          /* tailcall */
14001e146                          return do_sema_b_release(*(uint64_t*)((char*)rbx_1 + 0xa0), 1, 
14001e146                              (char*)rbx_1 + 0x40, (char*)rbx_1 + 0x68);
14001e11b                      }
14001e0a2                  }
14001e0a2                  else if (*(uint32_t*)((char*)rbx_1 + 8)
14001e0a2                      > *(uint32_t*)((char*)rbx_1 + 0x10))
14001e0aa                  {
14001e0d2                      int32_t rax_5 = do_sema_b_wait(*(uint64_t*)((char*)rbx_1 + 0xa8), 1, 
14001e0d2                          0xffffffff, (char*)rbx_1 + 0x70, (char*)rbx_1 + 0x98);
14001e0d2                      
14001e0d9                      if (rax_5)
14001e0d9                      {
14001e16f                          LeaveCriticalSection((char*)rbx_1 + 0x18);
14001e175                          return (uint64_t)rax_5;
14001e0d9                      }
14001e0d9                      
14001e0df                      int32_t rax_6 = *(uint32_t*)((char*)rbx_1 + 0x10);
14001e0e2                      int32_t rdx_1 = *(uint32_t*)((char*)rbx_1 + 8);
14001e0e2                      
14001e0e7                      if (rax_6)
14001e0e7                      {
14001e0e9                          rdx_1 -= rax_6;
14001e0eb                          *(uint32_t*)((char*)rbx_1 + 0x10) = 0;
14001e0e7                      }
14001e0e7                      
14001e0f2                      rdx_2 = rdx_1 - 1;
14001e0f5                      rax_7 = 1;
14001e0d9                      goto label_14001e11d;
14001e0aa                  }
14001e153                  LeaveCriticalSection((char*)rbx_1 + 0x18);
14001e06f              }
14001e06f              
14001e161              return 0;
14001e065          }
14001e059      }
14001e059      
14001e10b      return 0x16;
14001e050  }

14001e089                             0f 1f 80 00 00 00 00                                                           .......
14001e0fc                                                                                      0f 1f 40 00                              ..@.
14001e10c                                      0f 1f 40 00                                                              ..@.
14001e14b                                   0f 1f 44 00 00                                                             ..D..
14001e162        66 0f 1f 44 00 00                                                                            f..D..
14001e17e                                                                                            66 90                                f.

14001e180    uint64_t pthread_cond_broadcast(int64_t* arg1)

14001e180  {
14001e18a      if (arg1)
14001e18a      {
14001e190          void* rbx_1 = *(uint64_t*)arg1;
14001e190          
14001e196          if (rbx_1)
14001e196          {
14001e1a0              if (rbx_1 != -1)
14001e1a0              {
14001e1b1                  if (*(uint32_t*)rbx_1 != 0xc0bab1fd)
14001e1ba                      return 0x16;
14001e1ba                  
14001e1c7                  EnterCriticalSection((char*)rbx_1 + 0x18);
14001e1cd                  int32_t rax_2 = *(uint32_t*)((char*)rbx_1 + 0xc);
14001e1d2                  int32_t rax_7;
14001e1d2                  int32_t rdi_1;
14001e1d2                  
14001e1d2                  if (rax_2)
14001e1d2                  {
14001e240                      rdi_1 = *(uint32_t*)((char*)rbx_1 + 8);
14001e243                      rax_7 = rax_2 + rdi_1;
14001e243                      
14001e247                      if (rdi_1)
14001e247                      {
14001e24c                      label_14001e24c:
14001e24c                          *(uint32_t*)((char*)rbx_1 + 8) = 0;
14001e253                          *(uint32_t*)((char*)rbx_1 + 0xc) = rax_7;
14001e256                          LeaveCriticalSection((char*)rbx_1 + 0x18);
14001e274                          /* tailcall */
14001e274                          return do_sema_b_release(*(uint64_t*)((char*)rbx_1 + 0xa0), 
14001e274                              rdi_1, (char*)rbx_1 + 0x40, (char*)rbx_1 + 0x68);
14001e247                      }
14001e1d2                  }
14001e1d2                  else if (*(uint32_t*)((char*)rbx_1 + 8)
14001e1d2                      > *(uint32_t*)((char*)rbx_1 + 0x10))
14001e1da                  {
14001e202                      int32_t rax_5 = do_sema_b_wait(*(uint64_t*)((char*)rbx_1 + 0xa8), 1, 
14001e202                          0xffffffff, (char*)rbx_1 + 0x70, (char*)rbx_1 + 0x98);
14001e202                      
14001e209                      if (rax_5)
14001e209                      {
14001e29f                          LeaveCriticalSection((char*)rbx_1 + 0x18);
14001e2a5                          return (uint64_t)rax_5;
14001e209                      }
14001e209                      
14001e20f                      int32_t rax_6 = *(uint32_t*)((char*)rbx_1 + 0x10);
14001e212                      rdi_1 = *(uint32_t*)((char*)rbx_1 + 8);
14001e212                      
14001e217                      if (rax_6)
14001e217                      {
14001e219                          rdi_1 -= rax_6;
14001e21b                          *(uint32_t*)((char*)rbx_1 + 0x10) = 0;
14001e217                      }
14001e217                      
14001e222                      rax_7 = rdi_1;
14001e209                      goto label_14001e24c;
14001e1da                  }
14001e283                  LeaveCriticalSection((char*)rbx_1 + 0x18);
14001e1a0              }
14001e1a0              
14001e292              return 0;
14001e196          }
14001e18a      }
14001e18a      
14001e23c      return 0x16;
14001e180  }

14001e1bb                                                                                   0f 1f 44 00 00                             ..D..
14001e226                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
14001e23d                                                                                         0f 1f 00                               ...
14001e279                                                                             0f 1f 80 00 00 00 00                           .......
14001e293                                                           0f 1f 44 00 00                                             ..D..
14001e2ae                                            66 90                                                                f.

14001e2b0    uint64_t pthread_cond_wait(int64_t* arg1, int64_t arg2)

14001e2b0  {
14001e2c1      int32_t** rdi = arg1;
14001e2c7      int32_t rbx;
14001e2c7      
14001e2c7      if (!arg1)
14001e470          rbx = 0x16;
14001e2c7      else
14001e2c7      {
14001e2cd          int32_t* rsi_1 = *(uint64_t*)arg1;
14001e2d0          rbx = 0x16;
14001e2d0          
14001e2d8          if (rsi_1)
14001e2d8          {
14001e2e2              if (rsi_1 == -1)
14001e2e2              {
14001e44a                  pthread_spin_lock(&_.data);
14001e453                  int32_t var_7c;
14001e453                  
14001e453                  if (*(uint64_t*)rdi == -1)
14001e453                  {
14001e4b1                      rbx = pthread_cond_init(rdi, nullptr);
14001e4b3                      pthread_spin_unlock(&_.data);
14001e4be                      var_7c = rbx;
14001e4be                      
14001e4c2                      if (!(rbx & 0xffffffef))
14001e4c2                          goto label_14001e465;
14001e453                  }
14001e453                  else
14001e453                  {
14001e458                      pthread_spin_unlock(&_.data);
14001e45d                      var_7c = 0;
14001e465                  label_14001e465:
14001e465                      rsi_1 = *(uint64_t*)rdi;
14001e357                  label_14001e357:
14001e357                      
14001e357                      while (true)
14001e357                      {
14001e357                          int32_t rax_3 = do_sema_b_wait(
14001e357                              *(uint64_t*)((char*)rsi_1 + 0xa8), 0, 0xffffffff, 
14001e357                              &rsi_1[0x1c], &rsi_1[0x26]);
14001e35e                          rbx = rax_3;
14001e360                          var_7c = rax_3;
14001e360                          
14001e364                          if (rax_3)
14001e364                              break;
14001e364                          
14001e318                          if (TryEnterCriticalSection(&rsi_1[6]))
14001e318                          {
14001e380                              rsi_1[2] += 1;
14001e387                              LeaveCriticalSection(&rsi_1[6]);
14001e39f                              int32_t rax_5 = do_sema_b_release(
14001e39f                                  *(uint64_t*)((char*)rsi_1 + 0xa8), 1, &rsi_1[0x1c], 
14001e39f                                  &rsi_1[0x26]);
14001e3a6                              rbx = rax_5;
14001e3a8                              var_7c = rax_5;
14001e3a8                              
14001e3ac                              if (!rax_5)
14001e3ac                              {
14001e3bd                                  int32_t* var_68_1 = &var_7c;
14001e3c9                                  uint128_t zmm0_1 =
14001e3c9                                      _mm_unpacklo_epi64((uint128_t)rsi_1, arg2);
14001e3cd                                  int32_t* (* var_58)(int64_t* arg1) = cleanup_wait;
14001e3d7                                  uint128_t var_78 = zmm0_1;
14001e3dc                                  uint128_t* var_50_1 = &var_78;
14001e3e6                                  int64_t rax_7 = *(uint64_t*)pthread_getclean();
14001e401                                  *(uint64_t*)pthread_getclean() = &var_58;
14001e404                                  int64_t var_b8;
14001e404                                  int64_t var_b8_2 = var_b8;
14001e40a                                  int32_t rax_9 = pthread_mutex_unlock(arg2);
14001e411                                  var_7c = rax_9;
14001e411                                  
14001e415                                  if (!rax_9)
14001e49b                                      var_7c = do_sema_b_wait(
14001e49b                                          *(uint64_t*)((char*)rsi_1 + 0xa0), 0, 
14001e49b                                          0xffffffff, &rsi_1[0x10], &rsi_1[0x1a]);
14001e49b                                  
14001e421                                  *(uint64_t*)pthread_getclean() = rax_7;
14001e429                                  var_58(var_50_1);
14001e42d                                  rbx = var_7c;
14001e3ac                              }
14001e3ac                              
14001e3ac                              break;
14001e318                          }
14001e318                          
14001e32c                          int32_t rax_2 = do_sema_b_release(
14001e32c                              *(uint64_t*)((char*)rsi_1 + 0xa8), 1, &rsi_1[0x1c], 
14001e32c                              &rsi_1[0x26]);
14001e333                          rbx = rax_2;
14001e335                          var_7c = rax_2;
14001e335                          
14001e339                          if (rax_2)
14001e339                              break;
14001e339                          
14001e33b                          sched_yield();
14001e357                      }
14001e453                  }
14001e2e2              }
14001e2e2              else if (*(uint32_t*)rsi_1 == 0xc0bab1fd)
14001e2ee                  goto label_14001e357;
14001e2d8          }
14001e2c7      }
14001e2c7      
14001e376      return (uint64_t)rbx;
14001e2b0  }

14001e308                          0f 1f 84 00 00 00 00 00                                                          ........
14001e377                                                                       66 0f 1f 84 00 00 00 00 00                         f........
14001e436                                                                    66 2e 0f 1f 84 00 00 00 00 00                        f.........
14001e46d                                         0f 1f 00                                                               ...
14001e4ca                                66 0f 1f 44 00 00                                                            f..D..

14001e4d0    int32_t* cleanup_wait(int64_t* arg1)

14001e4d0  {
14001e4dc      void* rbx = *(uint64_t*)arg1;
14001e4e9      EnterCriticalSection((char*)rbx + 0x18);
14001e4ef      int32_t rdi = *(uint32_t*)((char*)rbx + 0xc);
14001e4f4      int32_t* result;
14001e4f4      
14001e4f4      if (!rdi)
14001e4f4      {
14001e550          int32_t rax_1 = *(uint32_t*)((char*)rbx + 0x10);
14001e550          
14001e558          if (rax_1 == 0x3ffffffe)
14001e558          {
14001e580              HANDLE rcx_6 = *(uint64_t*)((char*)rbx + 0xa8);
14001e58b              *(uint32_t*)((char*)rbx + 0x10) = 0x3fffffff;
14001e5ac              int32_t rax_3 = do_sema_b_wait(rcx_6, 1, 0xffffffff, (char*)rbx + 0x70, 
14001e5ac                  (char*)rbx + 0x98);
14001e5b3              int32_t rdi_1 = rax_3;
14001e5b5              int32_t rax_5;
14001e5b5              
14001e5b5              if (!rax_3)
14001e5b5              {
14001e5c5                  *(uint32_t*)((char*)rbx + 8) -= *(uint32_t*)((char*)rbx + 0x10);
14001e5cf                  rax_5 = do_sema_b_release(*(uint64_t*)((char*)rbx + 0xa8), 1, 
14001e5cf                      (char*)rbx + 0x70, (char*)rbx + 0x98);
14001e5d6                  rdi_1 = rax_5;
14001e5b5              }
14001e5b5              
14001e5d8              if (rax_3 || rax_5)
14001e5d8              {
14001e5f3                  LeaveCriticalSection((char*)rbx + 0x18);
14001e5f9                  result = arg1[2];
14001e5fd                  *(uint32_t*)result = rdi_1;
14001e5d8              }
14001e5d8              else
14001e5d8              {
14001e5da                  *(uint32_t*)((char*)rbx + 0x10) = 0;
14001e5e4                  LeaveCriticalSection((char*)rbx + 0x18);
14001e52e              label_14001e52e:
14001e52e                  result = pthread_mutex_lock(arg1[1]);
14001e52e                  
14001e535                  if ((uint32_t)result)
14001e53b                      *(uint32_t*)arg1[2] = (uint32_t)result;
14001e5d8              }
14001e558          }
14001e558          else
14001e558          {
14001e560              *(uint32_t*)((char*)rbx + 0x10) = rax_1 + 1;
14001e563              LeaveCriticalSection((char*)rbx + 0x18);
14001e56d              result = pthread_mutex_lock(arg1[1]);
14001e56d              
14001e574              if ((uint32_t)result)
14001e53b                  *(uint32_t*)arg1[2] = (uint32_t)result;
14001e558          }
14001e4f4      }
14001e4f4      else
14001e4f4      {
14001e4fc          *(uint32_t*)((char*)rbx + 0xc) = rdi - 1;
14001e4ff          LeaveCriticalSection((char*)rbx + 0x18);
14001e4ff          
14001e508          if (rdi != 1)
14001e508              goto label_14001e52e;
14001e508          
14001e521          result = do_sema_b_release(*(uint64_t*)((char*)rbx + 0xa8), 1, 
14001e521              (char*)rbx + 0x70, (char*)rbx + 0x98);
14001e521          
14001e528          if (!(uint32_t)result)
14001e528              goto label_14001e52e;
14001e528          
14001e53b          *(uint32_t*)arg1[2] = (uint32_t)result;
14001e4f4      }
14001e4f4      
14001e549      return result;
14001e4d0  }

14001e54a                                66 0f 1f 44 00 00                                                            f..D..
14001e578                                                                          0f 1f 84 00 00 00 00 00                          ........
14001e5ef                                               90                                                                 .
14001e604              66 66 2e 0f 1f 84 00 00 00 00 00 90                                                      ff..........

14001e610    uint64_t pthread_cond_timedwait_impl(int64_t* arg1, int64_t arg2, int64_t* arg3, int32_t arg4)

14001e610  {
14001e632      int32_t rbx;
14001e632      
14001e632      if (!arg1)
14001e820          rbx = 0x16;
14001e632      else
14001e632      {
14001e638          int32_t* rsi_1 = *(uint64_t*)arg1;
14001e63b          rbx = 0x16;
14001e63b          
14001e643          if (rsi_1)
14001e643          {
14001e64d              if (rsi_1 == -1)
14001e64d              {
14001e7fa                  pthread_spin_lock(&_.data);
14001e803                  int32_t var_8c;
14001e803                  
14001e803                  if (*(uint64_t*)arg1 == -1)
14001e803                  {
14001e85e                      rbx = pthread_cond_init(arg1, nullptr);
14001e860                      pthread_spin_unlock(&_.data);
14001e86b                      var_8c = rbx;
14001e86b                      
14001e86f                      if (!(rbx & 0xffffffef))
14001e86f                          goto label_14001e815;
14001e803                  }
14001e803                  else
14001e803                  {
14001e808                      pthread_spin_unlock(&_.data);
14001e80d                      var_8c = 0;
14001e815                  label_14001e815:
14001e815                      rsi_1 = *(uint64_t*)arg1;
14001e664                  label_14001e664:
14001e664                      uint64_t r15_1;
14001e664                      
14001e664                      if (arg4)
14001e664                      {
14001e715                          r15_1 = _pthread_time_in_ms_from_timespec(arg3);
14001e715                          
14001e720                          if (0xfffffffe < r15_1)
14001e726                              r15_1 = 0xffffffff;
14001e664                      }
14001e664                      else
14001e664                      {
14001e66a                          int64_t rax_1 = _pthread_rel_time_in_ms(arg3);
14001e677                          r15_1 = (uint64_t)(uint32_t)rax_1;
14001e677                          
14001e67a                          if (0xfffffffe < rax_1)
14001e726                              r15_1 = 0xffffffff;
14001e664                      }
14001e664                      
14001e6eb                      while (true)
14001e6eb                      {
14001e6eb                          int32_t rax_4 = do_sema_b_wait(
14001e6eb                              *(uint64_t*)((char*)rsi_1 + 0xa8), 0, 0xffffffff, 
14001e6eb                              &rsi_1[0x1c], &rsi_1[0x26]);
14001e6f2                          rbx = rax_4;
14001e6f4                          var_8c = rax_4;
14001e6f4                          
14001e6f8                          if (rax_4)
14001e6f8                              break;
14001e6f8                          
14001e6a8                          if (TryEnterCriticalSection(&rsi_1[6]))
14001e6a8                          {
14001e738                              rsi_1[2] += 1;
14001e73f                              LeaveCriticalSection(&rsi_1[6]);
14001e757                              int32_t rax_7 = do_sema_b_release(
14001e757                                  *(uint64_t*)((char*)rsi_1 + 0xa8), 1, &rsi_1[0x1c], 
14001e757                                  &rsi_1[0x26]);
14001e75e                              rbx = rax_7;
14001e760                              var_8c = rax_7;
14001e760                              
14001e764                              if (!rax_7)
14001e764                              {
14001e775                                  int32_t* var_78_1 = &var_8c;
14001e781                                  uint128_t zmm0_1 =
14001e781                                      _mm_unpacklo_epi64((uint128_t)rsi_1, arg2);
14001e785                                  int32_t* (* var_68)(int64_t* arg1) = cleanup_wait;
14001e78f                                  uint128_t var_88 = zmm0_1;
14001e794                                  uint128_t* var_60_1 = &var_88;
14001e79e                                  int64_t rax_9 = *(uint64_t*)pthread_getclean();
14001e7b9                                  *(uint64_t*)pthread_getclean() = &var_68;
14001e7bc                                  int64_t var_c8;
14001e7bc                                  int64_t var_c8_2 = var_c8;
14001e7c2                                  int32_t rax_11 = pthread_mutex_unlock(arg2);
14001e7c9                                  var_8c = rax_11;
14001e7c9                                  
14001e7cd                                  if (!rax_11)
14001e848                                      var_8c = do_sema_b_wait(
14001e848                                          *(uint64_t*)((char*)rsi_1 + 0xa0), 0, 
14001e848                                          (uint32_t)r15_1, &rsi_1[0x10], &rsi_1[0x1a]);
14001e848                                  
14001e7d9                                  *(uint64_t*)pthread_getclean() = rax_9;
14001e7e1                                  var_68(var_60_1);
14001e7e5                                  rbx = var_8c;
14001e764                              }
14001e764                              
14001e764                              break;
14001e6a8                          }
14001e6a8                          
14001e6c0                          int32_t rax_3 = do_sema_b_release(
14001e6c0                              *(uint64_t*)((char*)rsi_1 + 0xa8), 1, &rsi_1[0x1c], 
14001e6c0                              &rsi_1[0x26]);
14001e6c7                          rbx = rax_3;
14001e6c9                          var_8c = rax_3;
14001e6c9                          
14001e6cd                          if (rax_3)
14001e6cd                              break;
14001e6cd                          
14001e6cf                          sched_yield();
14001e6eb                      }
14001e803                  }
14001e64d              }
14001e64d              else if (*(uint32_t*)rsi_1 == 0xc0bab1fd)
14001e659                  goto label_14001e664;
14001e643          }
14001e632      }
14001e632      
14001e70f      return (uint64_t)rbx;
14001e610  }

14001e698                                                                          0f 1f 84 00 00 00 00 00                          ........
14001e731                                                     0f 1f 80 00 00 00 00                                           .......
14001e7ee                                            66 90                                                                f.
14001e81d                                                                                         0f 1f 00                               ...
14001e877                                                                       66 0f 1f 84 00 00 00 00 00                         f........

14001e880    int64_t pthread_cond_timedwait(int64_t* arg1, int64_t arg2, int64_t* arg3)

14001e880  {
14001e883      /* tailcall */
14001e883      return pthread_cond_timedwait_impl(arg1, arg2, arg3, 0);
14001e880  }

14001e888                          0f 1f 84 00 00 00 00 00                                                          ........

14001e890    int64_t pthread_cond_timedwait_relative_np(int64_t* arg1, int64_t arg2, int64_t* arg3)

14001e890  {
14001e896      /* tailcall */
14001e896      return pthread_cond_timedwait_impl(arg1, arg2, arg3, 1);
14001e890  }

14001e89b                                                                                   90 90 90 90 90                             .....

14001e8a0    int64_t pthread_check(int64_t arg1)

14001e8a0  {
14001e8a7      if (arg1)
14001e8a7      {
14001e8a9          void* rax_1 = __pth_gpointer_locked(arg1);
14001e8a9          
14001e8b6          if (!*(uint32_t*)((char*)rax_1 + 0xbc))
14001e8db              return 0;
14001e8db          
14001e8b8          HANDLE hObject = *(uint64_t*)((char*)rax_1 + 0x28);
14001e8c4          uint32_t lpdwFlags;
14001e8c4          
14001e8c4          if (hObject - 1 <= -3 && GetHandleInformation(hObject, &lpdwFlags))
14001e8db              return 0;
14001e8a7      }
14001e8a7      
14001e8e9      return 3;
14001e8a0  }

14001e8dc                                                                                      0f 1f 40 00                              ..@.
14001e8ea                                66 0f 1f 44 00 00                                                            f..D..

14001e8f0    int64_t sched_get_priority_min(int32_t arg1)

14001e8f0  {
14001e8fc      if (arg1 <= 2)
14001e902          return 0xfffffff1;
14001e902      
14001e90e      *(uint32_t*)_errno() = 0x16;
14001e91d      return 0xffffffff;
14001e8f0  }

14001e903           0f 1f 44 00 00                                                                             ..D..
14001e91e                                                                                            66 90                                f.

14001e920    int64_t sched_get_priority_max(int32_t arg1)

14001e920  {
14001e927      if (arg1 <= 2)
14001e929          return 0xf;
14001e929      
14001e939      *(uint32_t*)_errno() = 0x16;
14001e93f      return 0xffffffff;
14001e920  }

14001e946                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........

14001e950    int64_t pthread_attr_setschedparam(void* arg1, int32_t* arg2)

14001e950  {
14001e958      if (!arg1 || !arg2)
14001e96d          return 0x16;
14001e96d      
14001e95c      *(uint32_t*)((char*)arg1 + 0x18) = *(uint32_t*)arg2;
14001e961      return 0;
14001e950  }

14001e962        66 0f 1f 44 00 00                                                                            f..D..
14001e96e                                            66 90                                                                f.

14001e970    int64_t pthread_attr_getschedparam(void* arg1, int32_t* arg2)

14001e970  {
14001e978      if (!arg1 || !arg2)
14001e98d          return 0x16;
14001e98d      
14001e97d      *(uint32_t*)arg2 = *(uint32_t*)((char*)arg1 + 0x18);
14001e981      return 0;
14001e970  }

14001e982        66 0f 1f 44 00 00                                                                            f..D..
14001e98e                                            66 90                                                                f.

14001e990    uint64_t pthread_attr_setschedpolicy(int64_t arg1, int32_t arg2, int32_t arg3 @ rax) __pure

14001e990  {
14001e998      if (arg1 && arg2 <= 2)
14001e9a3          return (uint64_t)(arg3 - arg3) & 0x81;
14001e9a3      
14001e9ad      return 0x16;
14001e990  }

14001e9a4              0f 1f 40 00                                                                              ..@.
14001e9ae                                            66 90                                                                f.

14001e9b0    int64_t pthread_attr_getschedpolicy(int64_t arg1, int32_t* arg2)

14001e9b0  {
14001e9b8      if (!arg1 || !arg2)
14001e9cd          return 0x16;
14001e9cd      
14001e9bc      *(uint32_t*)arg2 = 0;
14001e9c2      return 0;
14001e9b0  }

14001e9c3           0f 1f 44 00 00                                                                             ..D..
14001e9ce                                            66 90                                                                f.

14001e9d0    uint64_t pthread_getschedparam(int64_t arg1, int32_t* arg2, int32_t* arg3)

14001e9d0  {
14001e9e1      int32_t rax = pthread_check(arg1);
14001e9e1      
14001e9ea      if (!rax)
14001e9ea      {
14001e9f4          if (!arg3 || !arg2)
14001ea37              return 0x16;
14001ea37          
14001ea07          *(uint32_t*)arg2 = *(uint32_t*)(__pth_gpointer_locked(arg1) + 0xb8);
14001ea15          *(uint32_t*)arg3 = *(uint32_t*)(__pth_gpointer_locked(arg1) + 0xc0);
14001e9ea      }
14001e9ea      
14001ea21      return (uint64_t)rax;
14001e9d0  }

14001ea22        66 0f 1f 44 00 00                                                                            f..D..
14001ea38                                                                          0f 1f 84 00 00 00 00 00                          ........

14001ea40    int64_t pthread_setschedparam(int64_t arg1, int32_t arg2, int32_t* arg3)

14001ea40  {
14001ea4f      int32_t result = pthread_check(arg1);
14001ea4f      
14001ea56      if (!result)
14001ea56      {
14001ea60          if (arg2 > 2 || !arg3)
14001eadc              return 0x16;
14001eadc          
14001ea64          result = 0x81;
14001ea64          
14001ea69          if (!arg2)
14001ea69          {
14001ea6b              enum THREAD_PRIORITY nPriority = *(uint32_t*)arg3;
14001ea6b              
14001ea73              if (nPriority + 0xf <= 0x1e)
14001ea73              {
14001ea78                  if (nPriority != 0xfffffff1)
14001ea78                  {
14001ea7d                      if (nPriority < ~THREAD_PRIORITY_NORMAL)
14001eae0                          nPriority = ~THREAD_PRIORITY_ABOVE_NORMAL~THREAD_PRIORITY_NORMAL;
14001ea7d                      else
14001ea7d                      {
14001ea7f                          enum THREAD_PRIORITY nPriority_1 = THREAD_PRIORITY_HIGHEST;
14001ea7f                          
14001ea86                          if (nPriority <= THREAD_PRIORITY_HIGHEST)
14001ea86                              nPriority_1 = nPriority;
14001ea86                          
14001ea8c                          if (nPriority != THREAD_PRIORITY_TIME_CRITICAL)
14001ea8c                              nPriority = nPriority_1;
14001ea7d                      }
14001ea78                  }
14001ea78                  
14001ea92                  void* rax_1 = __pth_gpointer_locked(arg1);
14001ea92                  
14001eaa8                  if (SetThreadPriority(*(uint64_t*)((char*)rax_1 + 0x28), nPriority))
14001eaa8                  {
14001eaaa                      *(uint32_t*)((char*)rax_1 + 0xb8) = 0;
14001eab6                      *(uint32_t*)((char*)rax_1 + 0xc0) = *(uint32_t*)arg3;
14001eabc                      return 0;
14001eaa8                  }
14001ea73              }
14001ea73              
14001eadc              return 0x16;
14001ea69          }
14001ea56      }
14001ea56      
14001eac5      return result;
14001ea40  }

14001eac6                    66 2e 0f 1f 84 00 00 00 00 00                                                        f.........
14001eadd                                                                                         0f 1f 00                               ...
14001eae7                       66 0f 1f 84 00 00 00 00 00                                                         f........

14001eaf0    int64_t sched_getscheduler(int64_t arg1)

14001eaf0  {
14001eafb      if (arg1 && (int64_t)GetCurrentProcessId() != arg1)
14001eafb      {
14001eb1f          HANDLE hObject = OpenProcess(PROCESS_QUERY_INFORMATION, 0, (uint32_t)arg1);
14001eb1f          
14001eb2b          if (!hObject)
14001eb2b          {
14001eb40              int32_t rbx_1;
14001eb40              (uint8_t)rbx_1 = GetLastError() != ERROR_ACCESS_DENIED;
14001eb4d              *(uint32_t*)_errno() = rbx_1 * 2 + 1;
14001eb4f              return 0xffffffff;
14001eb2b          }
14001eb2b          
14001eb2d          CloseHandle(hObject);
14001eafb      }
14001eafb      
14001eafd      return 0;
14001eaf0  }

14001eb05                 0f 1f 00                                                                               ...
14001eb54                                                              66 66 2e 0f 1f 84 00 00 00 00 00 90                      ff..........

14001eb60    uint64_t sched_setscheduler(int64_t arg1, int32_t arg2, int64_t arg3)

14001eb60  {
14001eb6c      int32_t rbx = arg2;
14001eb6c      
14001eb6e      if (!arg3)
14001eb6e      {
14001ebcc          *(uint32_t*)_errno() = 0x16;
14001ebc1          rbx = -1;
14001eb6e      }
14001eb6e      else
14001eb6e      {
14001eb73          if (!arg1)
14001eb73              goto label_14001eb75;
14001eb73          
14001eb93          if ((int64_t)GetCurrentProcessId() == arg1)
14001eb93              goto label_14001eb75;
14001eb93          
14001eb9f          HANDLE hObject = OpenProcess(PROCESS_SET_INFORMATION, 0, (uint32_t)arg1);
14001eb9f          
14001ebab          if (!hObject)
14001ebab          {
14001ebdf              int32_t rbx_1;
14001ebdf              (uint8_t)rbx_1 = GetLastError() != ERROR_ACCESS_DENIED;
14001ebec              *(uint32_t*)_errno() = rbx_1 * 2 + 1;
14001ebc1              rbx = -1;
14001ebab          }
14001ebab          else
14001ebab          {
14001ebad              CloseHandle(hObject);
14001eb75          label_14001eb75:
14001eb75              
14001eb77              if (rbx)
14001eb77              {
14001ebbb                  *(uint32_t*)_errno() = 0x28;
14001ebc1                  rbx = -1;
14001eb77              }
14001ebab          }
14001eb6e      }
14001eb6e      
14001eb81      return (uint64_t)rbx;
14001eb60  }

14001eb82        66 0f 1f 44 00 00                                                                            f..D..

14001ebf0    int64_t sched_yield()

14001ebf0  {
14001ebf6      Sleep(0);
14001ec02      return 0;
14001ebf0  }

14001ec03           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

14001ec10    enum WAIT_EVENT WaitForSingleObject(HANDLE hHandle, uint32_t dwMilliseconds)

14001ec10  {
14001ec10      /* tailcall */
14001ec10      return WaitForSingleObject(hHandle, dwMilliseconds);
14001ec10  }

14001ec16                                                                    90 90                                                ..

14001ec18    enum WAIT_EVENT WaitForMultipleObjects(uint32_t nCount, HANDLE* lpHandles, BOOL bWaitAll, uint32_t dwMilliseconds)

14001ec18  {
14001ec18      /* tailcall */
14001ec18      return WaitForMultipleObjects(nCount, lpHandles, bWaitAll, dwMilliseconds);
14001ec18  }

14001ec1e                                                                                            90 90                                ..

14001ec20    BOOL TryEnterCriticalSection(CRITICAL_SECTION* lpCriticalSection)

14001ec20  {
14001ec20      /* tailcall */
14001ec20      return TryEnterCriticalSection(lpCriticalSection);
14001ec20  }

14001ec26                    90 90                                                                                ..

14001ec28    BOOL TlsSetValue(uint32_t dwTlsIndex, void* lpTlsValue)

14001ec28  {
14001ec28      /* tailcall */
14001ec28      return TlsSetValue(dwTlsIndex, lpTlsValue);
14001ec28  }

14001ec2e                                            90 90                                                                ..

14001ec30    uint32_t TlsAlloc()

14001ec30  {
14001ec30      /* tailcall */
14001ec30      return TlsAlloc();
14001ec30  }

14001ec36                                                                    90 90                                                ..

14001ec38    uint32_t SuspendThread(HANDLE hThread)

14001ec38  {
14001ec38      /* tailcall */
14001ec38      return SuspendThread(hThread);
14001ec38  }

14001ec3e                                                                                            90 90                                ..

14001ec40    BOOL SetThreadPriority(HANDLE hThread, enum THREAD_PRIORITY nPriority)

14001ec40  {
14001ec40      /* tailcall */
14001ec40      return SetThreadPriority(hThread, nPriority);
14001ec40  }

14001ec46                    90 90                                                                                ..

14001ec48    BOOL SetThreadContext(HANDLE hThread, CONTEXT* lpContext)

14001ec48  {
14001ec48      /* tailcall */
14001ec48      return SetThreadContext(hThread, lpContext);
14001ec48  }

14001ec4e                                            90 90                                                                ..

14001ec50    BOOL SetProcessAffinityMask(HANDLE hProcess, uint64_t dwProcessAffinityMask)

14001ec50  {
14001ec50      /* tailcall */
14001ec50      return SetProcessAffinityMask(hProcess, dwProcessAffinityMask);
14001ec50  }

14001ec56                                                                    90 90                                                ..

14001ec58    void SetLastError(enum WIN32_ERROR dwErrCode)

14001ec58  {
14001ec58      /* tailcall */
14001ec58      return SetLastError(dwErrCode);
14001ec58  }

14001ec5e                                                                                            90 90                                ..

14001ec60    BOOL SetEvent(HANDLE hEvent)

14001ec60  {
14001ec60      /* tailcall */
14001ec60      return SetEvent(hEvent);
14001ec60  }

14001ec66                    90 90                                                                                ..

14001ec68    uint32_t ResumeThread(HANDLE hThread)

14001ec68  {
14001ec68      /* tailcall */
14001ec68      return ResumeThread(hThread);
14001ec68  }

14001ec6e                                            90 90                                                                ..

14001ec70    BOOL ResetEvent(HANDLE hEvent)

14001ec70  {
14001ec70      /* tailcall */
14001ec70      return ResetEvent(hEvent);
14001ec70  }

14001ec76                                                                    90 90                                                ..

14001ec78    uint32_t RemoveVectoredExceptionHandler(void* Handle)

14001ec78  {
14001ec78      /* tailcall */
14001ec78      return RemoveVectoredExceptionHandler(Handle);
14001ec78  }

14001ec7e                                                                                            90 90                                ..

14001ec80    BOOL ReleaseSemaphore(HANDLE hSemaphore, int32_t lReleaseCount, int32_t* lpPreviousCount)

14001ec80  {
14001ec80      /* tailcall */
14001ec80      return ReleaseSemaphore(hSemaphore, lReleaseCount, lpPreviousCount);
14001ec80  }

14001ec86                    90 90                                                                                ..

14001ec88    void RaiseException(uint32_t dwExceptionCode, uint32_t dwExceptionFlags, uint32_t nNumberOfArguments, uint64_t* lpArguments) __noreturn

14001ec88  {
14001ec88      /* tailcall */
14001ec88      return RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, 
14001ec88          lpArguments);
14001ec88  }

14001ec8e                                            90 90                                                                ..
14001ec90  OutputDebugStringA:
14001ec90                                                  ff 25 e6 98 00 00 90 90                                          .%......
14001ec98  OpenProcess:
14001ec98                                                                          ff 25 d6 98 00 00 90 90                          .%......
14001eca0  IsDebuggerPresent:
14001eca0  ff 25 b6 98 00 00 90 90                                                                          .%......
14001eca8  GetTickCount64:
14001eca8                          ff 25 9e 98 00 00 90 90                                                          .%......
14001ecb0  GetThreadPriority:
14001ecb0                                                  ff 25 8e 98 00 00 90 90                                          .%......
14001ecb8  GetThreadContext:
14001ecb8                                                                          ff 25 7e 98 00 00 90 90                          .%~.....
14001ecc0  GetSystemTimeAsFileTime:
14001ecc0  ff 25 6e 98 00 00 90 90                                                                          .%n.....
14001ecc8  GetProcessAffinityMask:
14001ecc8                          ff 25 5e 98 00 00 90 90                                                          .%^.....
14001ecd0  GetHandleInformation:
14001ecd0                                                  ff 25 3e 98 00 00 90 90                                          .%>.....
14001ecd8  GetCurrentThreadId:
14001ecd8                                                                          ff 25 2e 98 00 00 90 90                          .%......
14001ece0  GetCurrentThread:
14001ece0  ff 25 1e 98 00 00 90 90                                                                          .%......
14001ece8  GetCurrentProcessId:
14001ece8                          ff 25 0e 98 00 00 90 90                                                          .%......
14001ecf0  GetCurrentProcess:
14001ecf0                                                  ff 25 fe 97 00 00 90 90                                          .%......
14001ecf8  DuplicateHandle:
14001ecf8                                                                          ff 25 e6 97 00 00 90 90                          .%......
14001ed00  CreateSemaphoreA:
14001ed00  ff 25 ce 97 00 00 90 90                                                                          .%......
14001ed08  CreateEventA:
14001ed08                          ff 25 be 97 00 00 90 90                                                          .%......
14001ed10  CloseHandle:
14001ed10                                                  ff 25 ae 97 00 00 90 90                                          .%......
14001ed18  AddVectoredExceptionHandler:
14001ed18                                                                          ff 25 9e 97 00 00 90 90                          .%......

14001ed20    int64_t printf(char* arg1, int64_t arg2)

14001ed20  {
14001ed33      int64_t _ArgList = arg2;
14001ed38      int64_t r8;
14001ed38      int64_t arg_18 = r8;
14001ed3d      int64_t r9;
14001ed3d      int64_t arg_20 = r9;
14001ed42      int64_t* var_20 = &_ArgList;
14001ed67      return __stdio_common_vfprintf(0, __acrt_iob_func(1), arg1, nullptr, &_ArgList);
14001ed20  }

14001ed68                          90 90 90 90 90 90 90 90                                                          ........

14001ed70    char* _strdup(char const* _Source)

14001ed70  {
14001ed70      /* tailcall */
14001ed70      return _strdup(_Source);
14001ed70  }

14001ed76                                                                    90 90                                                ..

14001ed78    uintptr_t _.text(void* _Security, uint32_t _StackSize, _beginthreadex_proc_type _StartAddress, void* _ArgList, uint32_t _InitFlag, uint32_t* _ThrdAddr)

14001ed78  {
14001ed78      /* tailcall */
14001ed78      return _beginthreadex(_Security, _StackSize, _StartAddress, _ArgList, _InitFlag, 
14001ed78          _ThrdAddr);
14001ed78  }

14001ed7e                                                                                            90 90                                ..

14001ed80    void _.text(uint32_t _ReturnCode)

14001ed80  {
14001ed80      /* tailcall */
14001ed80      return _endthreadex(_ReturnCode);
14001ed80  }

14001ed86                    90 90                                                                                ..

14001ed88    int64_t __intrinsic_setjmpex(int64_t* arg1)

14001ed88  {
14001ed88      /* tailcall */
14001ed88      return __intrinsic_setjmpex(arg1);
14001ed88  }

14001ed8e                                            90 90                                                                ..

14001ed90    void _.text(jmp_buf& _Buf, int32_t _Value) __noreturn

14001ed90  {
14001ed90      /* tailcall */
14001ed90      return longjmp(_Buf, _Value);
14001ed90  }

14001ed96                                                                    90 90                                                ..

14001ed98    int64_t memmove(void* _Dst, void const* _Src, uint64_t _Size)

14001ed98  {
14001ed98      /* tailcall */
14001ed98      return memmove(_Dst, _Src, _Size);
14001ed98  }

14001ed9e                                                                                            90 90                                ..

14001eda0    char* _.text(uint32_t _Value, char* _Buffer, int32_t _Radix)

14001eda0  {
14001eda0      /* tailcall */
14001eda0      return _ultoa(_Value, _Buffer, _Radix);
14001eda0  }

14001eda6                    90 90 0f 1f 84 00 00 00 00 00                                                        ..........

14001edb0    void pthread_tls_init.cold() __noreturn

14001edb0  {
14001edb0      abort();
14001edb0      /* no return */
14001edb0  }

14001edb5                                                                 90                                                     .

14001edb6    void _pthread_once_raw.constprop.0.isra.0.cold() __noreturn

14001edb6  {
14001edb6      abort();
14001edb6      /* no return */
14001edb6  }

14001edbb                                                                                   90                                         .

14001edbc    void __pthread_self_lite.part.0.cold() __noreturn

14001edbc  {
14001edbc      abort();
14001edbc      /* no return */
14001edbc  }

14001edc1     90                                                                                             .

14001edc2    void thread_print.cold() __noreturn

14001edc2  {
14001edc2      *(uint64_t*)0x28;
14001edca      trap(6);
14001edc2  }


14001edd5    void pthread_once.cold(int64_t arg1) __noreturn

14001edd5  {
14001edda      *(uint64_t*)0 = arg1;
14001ede2      trap(6);
14001edd5  }

14001edfd                                                                                         90 90 90                               ...

14001ee00    int64_t register_frame_ctor()

14001ee00  {
14001ee00      /* tailcall */
14001ee00      return __gcc_register_frame();
14001ee00  }

14001ee05                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........
14001ee10  __CTOR_LIST__:
14001ee10                                                  ff ff ff ff ff ff ff ff                                          ........

14001ee18  void* _.ctors.65535 = register_frame_ctor

14001ee20  00 00 00 00 00 00 00 00                                                                          ........
14001ee28  __DTOR_LIST__:
14001ee28                          ff ff ff ff ff ff ff ff 00 00 00 00 00 00 00 00                                  ................
.text section ended  {0x140001000-0x14001ee38}

.data section started  {0x14001f000-0x14001f4a0}
14001f000  void* NTIv2__1DmnNWJVVT9bplfmaalVeUA_ = rttiDestroy__systemZexceptions_u56

14001f008                          40 00 00 00 00 00 00 00 08 00 04 00 00 00 00 00                                  @...............

14001f018  void* data_14001f018 = TM__TzI3paKQY09cLjc9cmCvur3A_3
14001f020  void* data_14001f020 = eqtrace___system_u5229

14001f028                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................

14001f040  void* NTIv2__RKHXYNwSRXz825VbZValEQ_ = rttiDestroy__systemZexceptions_u60

14001f048                          40 00 00 00 00 00 00 00 08 00 03 00 00 00 00 00                                  @...............

14001f058  void* data_14001f058 = TM__TzI3paKQY09cLjc9cmCvur3A_5
14001f060  void* data_14001f060 = eqtrace___system_u4756

14001f068                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................

14001f080  void* NTIv2__xTnzBHckcPoKiwygsku9csg_ = rttiDestroy__systemZexceptions_u62

14001f088                          40 00 00 00 00 00 00 00 08 00 03 00 00 00 00 00                                  @...............

14001f098  void* data_14001f098 = TM__TzI3paKQY09cLjc9cmCvur3A_6
14001f0a0  void* data_14001f0a0 = eqtrace___system_u4825

14001f0a8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................

14001f0c0  void* NTIv2__lVI5mUyBp9bAT9cco7UvZP8Q_ = rttiDestroy__systemZexceptions_u64

14001f0c8                          40 00 00 00 00 00 00 00 08 00 03 00 00 00 00 00                                  @...............

14001f0d8  void* data_14001f0d8 = TM__TzI3paKQY09cLjc9cmCvur3A_7
14001f0e0  void* data_14001f0e0 = eqtrace___system_u4915

14001f0e8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................

14001f100  void* NTIv2__k6VacnfEHcFyOMal5EruvA_ = rttiDestroy__systemZexceptions_u66

14001f108                          40 00 00 00 00 00 00 00 08 00 04 00 00 00 00 00                                  @...............

14001f118  void* data_14001f118 = TM__TzI3paKQY09cLjc9cmCvur3A_8
14001f120  void* data_14001f120 = eqtrace___system_u5295

14001f128                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................

14001f140  void* NTIv2__txzrG6zQAbHR6Hap9b2RC7g_ = rttiDestroy__systemZexceptions_u68

14001f148                          40 00 00 00 00 00 00 00 08 00 03 00 00 00 00 00                                  @...............

14001f158  void* data_14001f158 = TM__TzI3paKQY09cLjc9cmCvur3A_9
14001f160  void* data_14001f160 = eqtrace___system_u9068

14001f168                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
14001f180  _.data:
14001f180  a0 32 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .2..............................
14001f1a0  __emutls_v.nimInErrorMode__system_u4460:
14001f1a0  01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
14001f1c0  __emutls_v.localRaiseHook__system_u3633:
14001f1c0  08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
14001f1e0  __emutls_v.rootsThreshold__system_u3301:
14001f1e0  08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
14001f200  __emutls_v.roots__system_u3091:
14001f200  18 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
14001f220  __emutls_v.threadId__system_u2957:
14001f220  08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
14001f240  __emutls_v.framePtr__system_u2692:
14001f240  08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
14001f260  __emutls_v.currException__system_u4105:
14001f260  08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
14001f280  __emutls_v.nimThreadDestructionHandlers__system_u3972:
14001f280  10 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
14001f2a0  WSAID_CONNECTEX__windowsZwinlean_u723:
14001f2a0  b9 07 a2 25 f3 dd 60 46 8e e9 76 e5 8c 74 06 3e                                                  ...%..`F..v..t.>
14001f2b0  WSAID_ACCEPTEX__windowsZwinlean_u724:
14001f2b0                                                  f1 7d 36 b5 ac cb cf 11 95 ca 00 80 5f 48 a1 92                  .}6........._H..
14001f2c0  WSAID_GETACCEPTEXSOCKADDRS__windowsZwinlean_u725:
14001f2c0  f2 7d 36 b5 ac cb cf 11 95 ca 00 80 5f 48 a1 92 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .}6........._H..................
14001f2e0  _.data:
14001f2e0  08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
14001f300  __emutls_v.utcInstance__pureZtimes_u2068:
14001f300  08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

14001f320  void* _.data = 0x14001ee30

14001f328                          00 00 00 00 00 00 00 00                                                          ........
14001f330  _.data:
14001f330                                                  ff ff ff ff                                                      ....
14001f334  __native_dllmain_reason:
14001f334                                                              ff ff ff ff 00 00 00 00 00 00 00 00                      ............

14001f340  int32_t _.data = -0x1

14001f344              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

14001f350  int32_t _.data = 0x2

14001f354                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

14001f360  int32_t _.data = -0x1

14001f364              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............
14001f370  _.data:
14001f370                                                  40 00 00 00 c3 bf ff ff c0 3f 00 00 01 00 00 00                  @........?......
14001f380  00 00 00 00 0e 00 00 00 00 00 00 00 00 00 00 00                                                  ................

14001f390  void* _.data = private_mem

14001f398                                                                          00 00 00 00 00 00 00 00                          ........

14001f3a0  void* _.data = vfprintf

14001f3a8                          00 00 00 00 00 00 00 00                                                          ........

14001f3b0  void* _.data = fprintf

14001f3b8                                                                          00 00 00 00 00 00 00 00                          ........

14001f3c0  void* _.data = _.bss
14001f3c8  void* __imp___initenv = local__initenv
14001f3d0  void* _.data = __ms_fwprintf
14001f3d8  void* __imp_tzset = tzset
14001f3e0  void* __imp__get_output_format = _get_output_format
14001f3e8  void* __imp__amsg_exit = _amsg_exit
14001f3f0  void* __imp___wgetmainargs = __wgetmainargs
14001f3f8  void* __imp___getmainargs = __getmainargs
14001f400  void* __imp_daylight = initial_daylight
14001f408  void* __imp_timezone = initial_timezone
14001f410  void* __imp_tzname = initial_tznames

14001f418  initial_daylight:
14001f418                                                                          01 00 00 00                                      ....
14001f41c  initial_timezone:
14001f41c                                                                                      80 70 00 00                              .p..

14001f420  void* initial_tznames = initial_tzname0
14001f428  void* data_14001f428 = initial_tzname1

14001f430  initial_tzname1:
14001f430                                                  50 44 54 00                                                      PDT.
14001f434  initial_tzname0:
14001f434                                                              50 53 54 00                                              PST.

14001f438  void* __imp_at_quick_exit = at_quick_exit
14001f440  void* __imp__onexit = _onexit

14001f448                          00 00 00 00 00 00 00 00                                                          ........
14001f450  _.data:
14001f450                                                  ff ff ff ff ff ff ff ff                                          ........
14001f458  mtx_pthr_locked:
14001f458                                                                          fd ff ff ff ff ff ff ff                          ........
14001f460  _pthread_key_lock:
14001f460  ff ff ff ff ff ff ff ff                                                                          ........

14001f468  int32_t _pthread_tls = -0x1

14001f46c                                      00 00 00 00                                                              ....
14001f470  _.data:
14001f470                                                  ff ff ff ff ff ff ff ff                                          ........
14001f478  rwl_global:
14001f478                                                                          ff ff ff ff ff ff ff ff                          ........
14001f480  _.data:
14001f480  ff ff ff ff ff ff ff ff 00 00 00 00 00 00 00 00                                                  ................

14001f490  void* _.data = printf

14001f498                                                                          00 00 00 00 00 00 00 00                          ........
.data section ended  {0x14001f000-0x14001f4a0}

.rdata section started  {0x140020000-0x140022a70}
140020000  TM__TzI3paKQY09cLjc9cmCvur3A_3:
140020000  00 08 a2 dc 00 ac 9c 4c 00 60 3b 78 00 2b aa bc 00 35 a7 39 00 00 00 00 00 00 00 00 00 00 00 00  .......L.`;x.+...5.9............
140020020  TM__TzI3paKQY09cLjc9cmCvur3A_5:
140020020  00 08 a2 dc 00 ac 9c 4c 00 60 3b 78 00 60 d7 a1                                                  .......L.`;x.`..
140020030  TM__TzI3paKQY09cLjc9cmCvur3A_6:
140020030                                                  00 08 a2 dc 00 ac 9c 4c 00 60 3b 78 00 04 f3 39                  .......L.`;x...9
140020040  TM__TzI3paKQY09cLjc9cmCvur3A_7:
140020040  00 08 a2 dc 00 ac 9c 4c 00 60 3b 78 00 99 39 52                                                  .......L.`;x..9R
140020050  TM__TzI3paKQY09cLjc9cmCvur3A_8:
140020050                                                  00 08 a2 dc 00 ac 9c 4c 00 60 3b 78 00 2b aa bc                  .......L.`;x.+..
140020060  00 72 5a a5 00 00 00 00 00 00 00 00 00 00 00 00                                                  .rZ.............
140020070  TM__TzI3paKQY09cLjc9cmCvur3A_9:
140020070                                                  00 08 a2 dc 00 ac 9c 4c 00 61 1b d3 00 1b eb 1c                  .......L.a......
140020080  data_140020080:
140020080  2d 25 00 00 00 00 00 00                                                                          -%......

140020088  char const data_140020088[0x3a] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\arithmetics.nim", 0
1400200c2  char const data_1400200c2[0x19] = "nimDecRefIsLastCyclicDyn", 0

1400200db                                                                                   00 00 00 00 00                             .....

1400200e0  char const data_1400200e0[0x32] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\orc.nim", 0

140020112                                                        00 00 00 00 00 00                                            ......

140020118  char const data_140020118[0x32] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\arc.nim", 0

14002014a  data_14002014a:
14002014a                                61 64 64 00 00 00                                                            add...

140020150  char const data_140020150[0x3a] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\cellseqs_v2.nim", 0
14002018a  char const data_14002018a[0xf] = "nimTraceRefDyn", 0

140020199                                                                             00 00 00 00 00 00 00                           .......

1400201a0  char const _.rdata[0xd1] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899addChars", 0

140020271                                                     00 00 00 00 00 00 00                                           .......

140020278  char const data_140020278[0x3f] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\std\\private\\digitsutils.nim", 0
1400202b7  char const data_1400202b7[0xb] = "addIntImpl", 0
1400202c2  char const data_1400202c2[0x7] = "addInt", 0

1400202c9                             00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00           .......................
1400202e0  TM__n49a9aYp5BrbXv9a6OCpJYm0g_2:
1400202e0  00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00                                                  .......@........
1400202f0  TM__n49a9aYp5BrbXv9a6OCpJYm0g_3:
1400202f0                                                  00 00 00 00 00 00 00 00                                          ........

1400202f8  void* data_1400202f8 = TM__n49a9aYp5BrbXv9a6OCpJYm0g_2

140020300  TM__n49a9aYp5BrbXv9a6OCpJYm0g_4:
140020300  00 00 00 00 00 00 00 00                                                                          ........

140020308  void* data_140020308 = TM__n49a9aYp5BrbXv9a6OCpJYm0g_2
140020310  char const data_140020310[0x7] = "addInt", 0

140020317                                                                       00                                                 .

140020318  char const data_140020318[0x3f] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\std\\private\\digitsutils.nim", 0

140020357  data_140020357:
140020357                                                                       24 00 00 00 00 00 00 00 00                         $........

140020360  char const data_140020360[0x36] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\dollars.nim", 0

140020396                                                                    00 00 00 00 00 00 00 00 00 00                        ..........
1400203a0  TM__JXL39bfraktrl3ZkJ5EQGjw_5:
1400203a0  3c 00 00 00 00 00 00 40 66 69 65 6c 64 20 27 66 75 6e 31 27 20 69 73 20 6e 6f 74 20 61 63 63 65  <......@field 'fun1' is not acce
1400203c0  73 73 69 62 6c 65 20 66 6f 72 20 74 79 70 65 20 27 46 75 6e 27 20 75 73 69 6e 67 20 27 6b 69 6e  ssible for type 'Fun' using 'kin
1400203e0  64 20 3d 20 00 00 00 00 00 00 00 00 00 00 00 00                                                  d = ............

1400203f0  int64_t TM__JXL39bfraktrl3ZkJ5EQGjw_6 = 0x3c
1400203f8  void* data_1400203f8 = TM__JXL39bfraktrl3ZkJ5EQGjw_5

140020400  TM__JXL39bfraktrl3ZkJ5EQGjw_7:
140020400  08 00 00 00 00 00 00 40 6b 43 6c 6f 73 75 72 65 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .......@kClosure................
140020420  TM__JXL39bfraktrl3ZkJ5EQGjw_8:
140020420  08 00 00 00 00 00 00 00                                                                          ........

140020428  void* data_140020428 = TM__JXL39bfraktrl3ZkJ5EQGjw_7

140020430  TM__JXL39bfraktrl3ZkJ5EQGjw_9:
140020430                                                  07 00 00 00 00 00 00 40 6b 4e 6f 63 6f 6e 76 00                  .......@kNoconv.
140020440  TM__JXL39bfraktrl3ZkJ5EQGjw_10:
140020440  07 00 00 00 00 00 00 00                                                                          ........

140020448  void* data_140020448 = TM__JXL39bfraktrl3ZkJ5EQGjw_9

140020450  TM__JXL39bfraktrl3ZkJ5EQGjw_11:
140020450                                                  00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00                  .......@........
140020460  TM__JXL39bfraktrl3ZkJ5EQGjw_12:
140020460  00 00 00 00 00 00 00 00                                                                          ........

140020468  void* data_140020468 = TM__JXL39bfraktrl3ZkJ5EQGjw_11

140020470                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140020480  TM__JXL39bfraktrl3ZkJ5EQGjw_14:
140020480  3c 00 00 00 00 00 00 40 66 69 65 6c 64 20 27 66 75 6e 32 27 20 69 73 20 6e 6f 74 20 61 63 63 65  <......@field 'fun2' is not acce
1400204a0  73 73 69 62 6c 65 20 66 6f 72 20 74 79 70 65 20 27 46 75 6e 27 20 75 73 69 6e 67 20 27 6b 69 6e  ssible for type 'Fun' using 'kin
1400204c0  64 20 3d 20 00 00 00 00 00 00 00 00 00 00 00 00                                                  d = ............

1400204d0  int64_t TM__JXL39bfraktrl3ZkJ5EQGjw_15 = 0x3c
1400204d8  void* data_1400204d8 = TM__JXL39bfraktrl3ZkJ5EQGjw_14

1400204e0  data_1400204e0:
1400204e0  2d 25 00 00 00 00 00 00                                                                          -%......

1400204e8  char const data_1400204e8[0x3a] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\arithmetics.nim", 0
140020522  char const data_140020522[0x10] = "nimIncRefCyclic", 0

140020532                                                        00 00 00 00 00 00                                            ......

140020538  char const data_140020538[0x32] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\orc.nim", 0

14002056a                                00 00 00 00 00 00                                                            ......

140020570  char const data_140020570[0x32] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\arc.nim", 0
1400205a2  char const data_1400205a2[0x19] = "nimDecRefIsLastCyclicDyn", 0
1400205bb  char const data_1400205bb[0xd] = "callClosures", 0
1400205c8  char const data_1400205c8[0x35] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\std\\exitprocs.nim", 0

1400205fd                                                                                         00 00 00                               ...

140020600  char const data_140020600[0x32] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\core\\locks.nim", 0

140020632                                                        00 00 00 00 00 00                                            ......

140020638  char const data_140020638[0x3a] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\iterators_1.nim", 0

140020672                                                        00 00 00 00 00 00                                            ......

140020678  char const data_140020678[0x2e] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system.nim", 0
1400206a6  char const data_1400206a6[0xc] = "addExitProc", 0

1400206b2                                                        00 00 00 00 00 00                                            ......

1400206b8  char const data_1400206b8[0x39] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\threadimpl.nim", 0
1400206f1  char const data_1400206f1[0xa] = "exitprocs", 0

1400206fb                                                                                   00 00 00 00 00                             .....
140020700  TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_4:
140020700  08 00 00 00 00 00 00 40 6b 65 72 6e 65 6c 33 32 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .......@kernel32................

140020720  int64_t TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_5 = 0x8
140020728  void* data_140020728 = TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_4

140020730  TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_6:
140020730                                                  08 00 00 00 00 00 00 40 6b 65 72 6e 65 6c 33 32                  .......@kernel32
140020740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

140020750  int64_t TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_7 = 0x8
140020758  void* data_140020758 = TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_6
140020760  char const data_140020760[0x17] = "restoreConsoleOutputCP", 0

140020777                                                                       00                                                 .

140020778  char const data_140020778[0x32] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\std\\syncio.nim", 0
1400207aa  char const data_1400207aa[0x11] = "restoreConsoleCP", 0
1400207bb  char const data_1400207bb[0x7] = "syncio", 0
1400207c2  char const data_1400207c2[0x13] = "GetConsoleOutputCP", 0
1400207d5  char const data_1400207d5[0xd] = "GetConsoleCP", 0
1400207e2  char const data_1400207e2[0x13] = "SetConsoleOutputCP", 0
1400207f5  char const data_1400207f5[0xd] = "SetConsoleCP", 0

140020802        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ..............................
140020820  TM__Q5wkpxktOdTGvlSRo9bzt9aw_2:
140020820  00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00                                                  .......@........
140020830  TM__Q5wkpxktOdTGvlSRo9bzt9aw_3:
140020830                                                  00 00 00 00 00 00 00 00                                          ........

140020838  void* data_140020838 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_2

140020840  TM__Q5wkpxktOdTGvlSRo9bzt9aw_4:
140020840  1d 00 00 00 00 00 00 40 4e 6f 20 73 74 61 63 6b 20 74 72 61 63 65 62 61 63 6b 20 61 76 61 69 6c  .......@No stack traceback avail
140020860  61 62 6c 65 0a 00 00 00 00 00 00 00 00 00 00 00                                                  able............

140020870  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_5 = 0x1d
140020878  void* data_140020878 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_4

140020880  TM__Q5wkpxktOdTGvlSRo9bzt9aw_13:
140020880  12 00 00 00 00 00 00 40 76 61 6c 75 65 20 6f 75 74 20 6f 66 20 72 61 6e 67 65 00 00 00 00 00 00  .......@value out of range......

1400208a0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_14 = 0x12
1400208a8  void* data_1400208a8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_13

1400208b0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
1400208c0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_70:
1400208c0  12 00 00 00 00 00 00 40 6f 76 65 72 2d 20 6f 72 20 75 6e 64 65 72 66 6c 6f 77 00 00 00 00 00 00  .......@over- or underflow......

1400208e0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_71 = 0x12
1400208e8  void* data_1400208e8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_70

1400208f0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140020900  TM__Q5wkpxktOdTGvlSRo9bzt9aw_81:
140020900  14 00 00 00 00 00 00 40 76 61 6c 75 65 20 6f 75 74 20 6f 66 20 72 61 6e 67 65 3a 20 00 00 00 00  .......@value out of range: ....

140020920  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_82 = 0x14
140020928  void* data_140020928 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_81

140020930                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140020940  TM__Q5wkpxktOdTGvlSRo9bzt9aw_90:
140020940  2b 00 00 00 00 00 00 40 69 6e 64 65 78 20 6f 75 74 20 6f 66 20 62 6f 75 6e 64 73 2c 20 74 68 65  +......@index out of bounds, the
140020960  20 63 6f 6e 74 61 69 6e 65 72 20 69 73 20 65 6d 70 74 79 00 00 00 00 00 00 00 00 00 00 00 00 00   container is empty.............
140020980  TM__Q5wkpxktOdTGvlSRo9bzt9aw_91:
140020980  2b 00 00 00 00 00 00 00                                                                          +.......

140020988  void* data_140020988 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_90

140020990  TM__Q5wkpxktOdTGvlSRo9bzt9aw_92:
140020990                                                  06 00 00 00 00 00 00 40 69 6e 64 65 78 20 00 00                  .......@index ..

1400209a0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_93 = 0x6
1400209a8  void* data_1400209a8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_92

1400209b0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_94:
1400209b0                                                  0d 00 00 00 00 00 00 40 20 6e 6f 74 20 69 6e 20                  .......@ not in 
1400209c0  30 20 2e 2e 20 00 00 00 00 00 00 00 00 00 00 00                                                  0 .. ...........

1400209d0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_95 = 0xd
1400209d8  void* data_1400209d8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_94

1400209e0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_107:
1400209e0  07 00 00 00 00 00 00 40 20 6e 6f 74 69 6e 20 00                                                  .......@ notin .

1400209f0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_108 = 0x7
1400209f8  void* data_1400209f8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_107

140020a00  TM__Q5wkpxktOdTGvlSRo9bzt9aw_109:
140020a00  04 00 00 00 00 00 00 40 20 2e 2e 20 00 00 00 00                                                  .......@ .. ....

140020a10  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_110 = 0x4
140020a18  void* data_140020a18 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_109

140020a20  TM__Q5wkpxktOdTGvlSRo9bzt9aw_112:
140020a20  22 00 00 00 00 00 00 40 54 72 61 63 65 62 61 63 6b 20 28 6d 6f 73 74 20 72 65 63 65 6e 74 20 63  "......@Traceback (most recent c
140020a40  61 6c 6c 20 6c 61 73 74 29 0a 00 00 00 00 00 00                                                  all last).......

140020a50  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_113 = 0x22
140020a58  void* data_140020a58 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_112

140020a60  TM__Q5wkpxktOdTGvlSRo9bzt9aw_114:
140020a60  01 00 00 00 00 00 00 40 28 00 00 00 00 00 00 00                                                  .......@(.......

140020a70  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_115 = 0x1
140020a78  void* data_140020a78 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_114

140020a80  TM__Q5wkpxktOdTGvlSRo9bzt9aw_116:
140020a80  14 00 00 00 00 00 00 40 20 63 61 6c 6c 73 20 6f 6d 69 74 74 65 64 29 20 2e 2e 2e 0a 00 00 00 00  .......@ calls omitted) ........

140020aa0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_117 = 0x14
140020aa8  void* data_140020aa8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_116
140020ab0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_119 = 0x1
140020ab8  void* data_140020ab8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_114

140020ac0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_120:
140020ac0  02 00 00 00 00 00 00 40 2c 20 00 00 00 00 00 00                                                  .......@, ......
140020ad0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_121:
140020ad0                                                  02 00 00 00 00 00 00 00                                          ........

140020ad8  void* data_140020ad8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_120

140020ae0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_122:
140020ae0  01 00 00 00 00 00 00 40 29 00 00 00 00 00 00 00                                                  .......@).......

140020af0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_123 = 0x1
140020af8  void* data_140020af8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_122

140020b00  TM__Q5wkpxktOdTGvlSRo9bzt9aw_124:
140020b00  01 00 00 00 00 00 00 40 0a 00 00 00 00 00 00 00                                                  .......@........

140020b10  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_125 = 0x1
140020b18  void* data_140020b18 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_124

140020b20  TM__Q5wkpxktOdTGvlSRo9bzt9aw_129:
140020b20  11 00 00 00 00 00 00 40 5b 5b 72 65 72 61 69 73 65 64 20 66 72 6f 6d 3a 0a 00 00 00 00 00 00 00  .......@[[reraised from:........

140020b40  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_130 = 0x11
140020b48  void* data_140020b48 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_129

140020b50  TM__Q5wkpxktOdTGvlSRo9bzt9aw_131:
140020b50                                                  03 00 00 00 00 00 00 40 5d 5d 0a 00 00 00 00 00                  .......@]]......

140020b60  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_132 = 0x3
140020b68  void* data_140020b68 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_131
140020b70  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_133 = 0x1
140020b78  void* data_140020b78 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_114

140020b80  TM__Q5wkpxktOdTGvlSRo9bzt9aw_134:
140020b80  02 00 00 00 00 00 00 00                                                                          ........

140020b88  void* data_140020b88 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_120
140020b90  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_135 = 0x1
140020b98  void* data_140020b98 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_122
140020ba0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_136 = 0x1
140020ba8  void* data_140020ba8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_124

140020bb0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140020bc0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_137:
140020bc0  1c 00 00 00 00 00 00 40 45 72 72 6f 72 3a 20 75 6e 68 61 6e 64 6c 65 64 20 65 78 63 65 70 74 69  .......@Error: unhandled excepti
140020be0  6f 6e 3a 20 00 00 00 00 00 00 00 00 00 00 00 00                                                  on: ............

140020bf0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_138 = 0x1c
140020bf8  void* data_140020bf8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_137

140020c00  TM__Q5wkpxktOdTGvlSRo9bzt9aw_139:
140020c00  02 00 00 00 00 00 00 40 20 5b 00 00 00 00 00 00                                                  .......@ [......

140020c10  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_140 = 0x2
140020c18  void* data_140020c18 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_139

140020c20  TM__Q5wkpxktOdTGvlSRo9bzt9aw_141:
140020c20  02 00 00 00 00 00 00 40 5d 0a 00 00 00 00 00 00                                                  .......@].......

140020c30  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_142 = 0x2
140020c38  void* data_140020c38 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_141

140020c40  TM__Q5wkpxktOdTGvlSRo9bzt9aw_143:
140020c40  32 00 00 00 00 00 00 40 45 72 72 6f 72 3a 20 63 61 6c 6c 20 64 65 70 74 68 20 6c 69 6d 69 74 20  2......@Error: call depth limit 
140020c60  72 65 61 63 68 65 64 20 69 6e 20 61 20 64 65 62 75 67 20 62 75 69 6c 64 20 28 00 00 00 00 00 00  reached in a debug build (......

140020c80  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_144 = 0x32
140020c88  void* data_140020c88 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_143

140020c90                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140020ca0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_145:
140020ca0  75 00 00 00 00 00 00 40 20 66 75 6e 63 74 69 6f 6e 20 63 61 6c 6c 73 29 2e 20 59 6f 75 20 63 61  u......@ function calls). You ca
140020cc0  6e 20 63 68 61 6e 67 65 20 69 74 20 77 69 74 68 20 2d 64 3a 6e 69 6d 43 61 6c 6c 44 65 70 74 68  n change it with -d:nimCallDepth
140020ce0  4c 69 6d 69 74 3d 3c 69 6e 74 3e 20 62 75 74 20 72 65 61 6c 6c 79 20 74 72 79 20 74 6f 20 61 76  Limit=<int> but really try to av
140020d00  6f 69 64 20 64 65 65 70 20 72 65 63 75 72 73 69 6f 6e 73 20 69 6e 73 74 65 61 64 2e 0a 00 00 00  oid deep recursions instead.....

140020d20  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_146 = 0x75
140020d28  void* data_140020d28 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_145

140020d30  TM__Q5wkpxktOdTGvlSRo9bzt9aw_147:
140020d30                                                  01 00 00 00 00 00 00 40 27 00 00 00 00 00 00 00                  .......@'.......

140020d40  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_148 = 0x1
140020d48  void* data_140020d48 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_147

140020d50                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140020d60  TM__Q5wkpxktOdTGvlSRo9bzt9aw_155:
140020d60  1f 00 00 00 00 00 00 40 53 49 47 49 4e 54 3a 20 49 6e 74 65 72 72 75 70 74 65 64 20 62 79 20 43  .......@SIGINT: Interrupted by C
140020d80  74 72 6c 2d 43 2e 0a 00 00 00 00 00 00 00 00 00                                                  trl-C...........

140020d90  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_156 = 0x1f
140020d98  void* data_140020d98 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_155

140020da0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_157:
140020da0  3d 00 00 00 00 00 00 40 53 49 47 53 45 47 56 3a 20 49 6c 6c 65 67 61 6c 20 73 74 6f 72 61 67 65  =......@SIGSEGV: Illegal storage
140020dc0  20 61 63 63 65 73 73 2e 20 28 41 74 74 65 6d 70 74 20 74 6f 20 72 65 61 64 20 66 72 6f 6d 20 6e   access. (Attempt to read from n
140020de0  69 6c 3f 29 0a 00 00 00 00 00 00 00 00 00 00 00                                                  il?)............

140020df0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_158 = 0x3d
140020df8  void* data_140020df8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_157

140020e00  TM__Q5wkpxktOdTGvlSRo9bzt9aw_159:
140020e00  1f 00 00 00 00 00 00 40 53 49 47 41 42 52 54 3a 20 41 62 6e 6f 72 6d 61 6c 20 74 65 72 6d 69 6e  .......@SIGABRT: Abnormal termin
140020e20  61 74 69 6f 6e 2e 0a 00 00 00 00 00 00 00 00 00                                                  ation...........

140020e30  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_160 = 0x1f
140020e38  void* data_140020e38 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_159

140020e40  TM__Q5wkpxktOdTGvlSRo9bzt9aw_161:
140020e40  1a 00 00 00 00 00 00 40 53 49 47 46 50 45 3a 20 41 72 69 74 68 6d 65 74 69 63 20 65 72 72 6f 72  .......@SIGFPE: Arithmetic error
140020e60  2e 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

140020e70  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_162 = 0x1a
140020e78  void* data_140020e78 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_161

140020e80  TM__Q5wkpxktOdTGvlSRo9bzt9aw_163:
140020e80  1b 00 00 00 00 00 00 40 53 49 47 49 4c 4c 3a 20 49 6c 6c 65 67 61 6c 20 6f 70 65 72 61 74 69 6f  .......@SIGILL: Illegal operatio
140020ea0  6e 2e 0a 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  n...............

140020eb0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_164 = 0x1b
140020eb8  void* data_140020eb8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_163

140020ec0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_165:
140020ec0  3c 00 00 00 00 00 00 40 53 49 47 42 55 53 3a 20 49 6c 6c 65 67 61 6c 20 73 74 6f 72 61 67 65 20  <......@SIGBUS: Illegal storage 
140020ee0  61 63 63 65 73 73 2e 20 28 41 74 74 65 6d 70 74 20 74 6f 20 72 65 61 64 20 66 72 6f 6d 20 6e 69  access. (Attempt to read from ni
140020f00  6c 3f 29 0a 00 00 00 00 00 00 00 00 00 00 00 00                                                  l?).............
140020f10  TM__Q5wkpxktOdTGvlSRo9bzt9aw_166:
140020f10                                                  3c 00 00 00 00 00 00 00                                          <.......

140020f18  void* data_140020f18 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_165

140020f20  TM__Q5wkpxktOdTGvlSRo9bzt9aw_167:
140020f20  0f 00 00 00 00 00 00 40 75 6e 6b 6e 6f 77 6e 20 73 69 67 6e 61 6c 0a 00 00 00 00 00 00 00 00 00  .......@unknown signal..........

140020f40  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_168 = 0xf
140020f48  void* data_140020f48 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_167

140020f50                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140020f60  TM__Q5wkpxktOdTGvlSRo9bzt9aw_174:
140020f60  10 00 00 00 00 00 00 40 64 69 76 69 73 69 6f 6e 20 62 79 20 7a 65 72 6f 00 00 00 00 00 00 00 00  .......@division by zero........

140020f80  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_175 = 0x10
140020f88  void* data_140020f88 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_174
140020f90  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_176 = 0x12
140020f98  void* data_140020f98 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_13

140020fa0  TM__Q5wkpxktOdTGvlSRo9bzt9aw_177:
140020fa0  1b 00 00 00 00 00 00 40 63 61 6e 6e 6f 74 20 77 72 69 74 65 20 73 74 72 69 6e 67 20 74 6f 20 66  .......@cannot write string to f
140020fc0  69 6c 65 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ile.............

140020fd0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_178 = 0x1b
140020fd8  void* data_140020fd8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_177
140020fe0  int64_t TM__Q5wkpxktOdTGvlSRo9bzt9aw_180 = 0x1b
140020fe8  void* data_140020fe8 = TM__Q5wkpxktOdTGvlSRo9bzt9aw_177

140020ff0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140021000  fsLookupTable__system_u6015:
140021000  ff 00 01 01 02 02 02 02 03 03 03 03 03 03 03 03 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04 04  ................................
140021020  05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05  ................................
140021040  06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06  ................................
140021060  06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06  ................................
140021080  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................................
1400210a0  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................................
1400210c0  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................................
1400210e0  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................................
140021100  nimStrVersion:
140021100  02 00 00 00 00 00 00 00                                                                          ........
140021108  nimSeqVersion:
140021108                          02 00 00 00 00 00 00 00                                                          ........
140021110  data_140021110:
140021110                                                  00                                                               .

140021111  char const data_140021111[0x11] = "could not load: ", 0

140021122        00 00 00 00 00 00                                                                            ......

140021128  char const data_140021128[0x31] = "\n(bad format; library may be wrong architecture)", 0

140021159  data_140021159:
140021159                                                                             0a 00                                          ..

14002115b  char const data_14002115b[0x10] = "unregisterCycle", 0

14002116b                                   00 00 00 00 00                                                             .....

140021170  char const data_140021170[0x32] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\orc.nim", 0
1400211a2  char const data_1400211a2[0x8] = "roundup", 0

1400211aa                                00 00 00 00 00 00                                                            ......

1400211b0  char const data_1400211b0[0x36] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\osalloc.nim", 0
1400211e6  char const data_1400211e6[0x6] = "msbit", 0

1400211ec                                      00 00 00 00                                                              ....

1400211f0  char const data_1400211f0[0x34] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\alloc.nim", 0
140021224  char const data_140021224[0xe] = "mappingSearch", 0
140021232  char const data_140021232[0x6] = "lsbit", 0
140021238  char const data_140021238[0x12] = "findSuitableBlock", 0
14002124a  char const data_14002124a[0xe] = "raiseOutOfMem", 0
140021258  char const data_140021258[0x35] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\mmdisp.nim", 0
14002128d  char const data_14002128d[0xf] = "out of memory\n", 0
14002129c  char const data_14002129c[0xd] = "osAllocPages", 0
1400212a9  char const data_1400212a9[0xb] = "allocPages", 0
1400212b4  char const data_1400212b4[0x10] = "osTryAllocPages", 0
1400212c4  char const data_1400212c4[0xe] = "tryAllocPages", 0
1400212d2  char const data_1400212d2[0xb] = "incCurrMem", 0
1400212dd  char const data_1400212dd[0x8] = "llAlloc", 0
1400212e5  char const data_1400212e5[0xc] = "addHeapLink", 0

1400212f1  data_1400212f1:
1400212f1                                                     2b 25 00 00 00 00 00                                           +%.....

1400212f8  char const data_1400212f8[0x3a] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\arithmetics.nim", 0
140021332  char const data_140021332[0xa] = "intSetGet", 0
14002133c  char const data_14002133c[0x9] = "contains", 0
140021345  char const data_140021345[0xa] = "pageIndex", 0

14002134f  data_14002134f:
14002134f                                               2d 25 00                                                           -%.

140021352  char const data_140021352[0x10] = "requestOsChunks", 0
140021362  char const data_140021362[0xd] = "isAccessible", 0
14002136f  char const data_14002136f[0xf] = "updatePrevSize", 0
14002137e  char const data_14002137e[0xa] = "intSetPut", 0
140021388  char const data_140021388[0x5] = "incl", 0
14002138d  char const data_14002138d[0xc] = "splitChunk2", 0
140021399  char const data_140021399[0xe] = "mappingInsert", 0
1400213a7  char const data_1400213a7[0x7] = "setBit", 0
1400213ae  char const data_1400213ae[0x11] = "addChunkToMatrix", 0
1400213bf  char const data_1400213bf[0xb] = "splitChunk", 0
1400213ca  char const data_1400213ca[0x9] = "clearBit", 0
1400213d3  char const data_1400213d3[0x17] = "removeChunkFromMatrix2", 0
1400213ea  char const data_1400213ea[0xc] = "getBigChunk", 0
1400213f6  char const data_1400213f6[0xe] = "getSmallChunk", 0
140021404  char const data_140021404[0x9] = "pageAddr", 0
14002140d  char const data_14002140d[0x13] = "compensateCounters", 0
140021420  char const data_140021420[0x8] = "listAdd", 0
140021428  char const data_140021428[0xb] = "listRemove", 0
140021433  char const data_140021433[0x5] = "excl", 0
140021438  char const data_140021438[0xb] = "decCurrMem", 0
140021443  char const data_140021443[0xf] = "osDeallocPages", 0
140021452  char const data_140021452[0x15] = "virtualFree failing!", 0
140021467  char const data_140021467[0xe] = "freeHugeChunk", 0
140021475  char const data_140021475[0xc] = "chunkUnused", 0
140021481  char const data_140021481[0xd] = "isSmallChunk", 0
14002148e  char const data_14002148e[0x16] = "removeChunkFromMatrix", 0
1400214a4  char const data_1400214a4[0xd] = "freeBigChunk", 0
1400214b1  char const data_1400214b1[0x10] = "deallocBigChunk", 0
1400214c1  char const data_1400214c1[0x1d] = "addToSharedFreeListBigChunks", 0
1400214de  char const data_1400214de[0x14] = "freeDeferredObjects", 0
1400214f2  char const data_1400214f2[0xd] = "getHugeChunk", 0
1400214ff  char const data_1400214ff[0x9] = "rawAlloc", 0
140021508  char const data_140021508[0x6] = "alloc", 0
14002150e  char const data_14002150e[0x5] = "init", 0

140021513                                                           00 00 00 00 00                                             .....

140021518  char const data_140021518[0x3a] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\cellseqs_v2.nim", 0
140021552  char const data_140021552[0x8] = "ptrSize", 0
14002155a  char const data_14002155a[0x14] = "addToSharedFreeList", 0
14002156e  char const data_14002156e[0xb] = "rawDealloc", 0
140021579  char const data_140021579[0x8] = "dealloc", 0
140021581  char const data_140021581[0x8] = "realloc", 0
140021589  char const data_140021589[0x7] = "resize", 0

140021590  data_140021590:
140021590                                                  61 64 64 00                                                      add.

140021594  char const data_140021594[0x6] = "trace", 0

14002159a                                                                                00 00 00 00 00 00                            ......

1400215a0  char const data_1400215a0[0x36] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\seqs_v2.nim", 0

1400215d6  data_1400215d6:
1400215d6                                                                    70 6f 70 00                                          pop.

1400215da  char const data_1400215da[0x9] = "markGray", 0

1400215e3           00 00 00 00 00                                                                             .....

1400215e8  char const data_1400215e8[0x32] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\arc.nim", 0
14002161a  char const data_14002161a[0xa] = "scanBlack", 0
140021624  char const data_140021624[0x5] = "scan", 0
140021629  char const data_140021629[0xd] = "collectColor", 0
140021636  char const data_140021636[0xe] = "nimRawDispose", 0
140021644  char const data_140021644[0x5] = "free", 0
140021649  char const data_140021649[0x7] = "deinit", 0
140021650  char const data_140021650[0x13] = "collectCyclesBacon", 0

140021663           00 00 00 00 00                                                                             .....

140021668  char const data_140021668[0x3a] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\iterators_1.nim", 0
1400216a2  char const data_1400216a2[0xe] = "collectCycles", 0
1400216b0  char const data_1400216b0[0xe] = "registerCycle", 0
1400216be  char const data_1400216be[0xe] = "rememberCycle", 0
1400216cc  char const data_1400216cc[0x15] = "nimDestroyAndDispose", 0
1400216e1  char const data_1400216e1[0x7] = "newSeq", 0
1400216e8  char const data_1400216e8[0x2e] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system.nim", 0
140021716  char const data_140021716[0x10] = "nimIncRefCyclic", 0
140021726  char const data_140021726[0x19] = "nimDecRefIsLastCyclicDyn", 0
14002173f  char const data_14002173f[0x9] = "sysFatal", 0
140021748  char const data_140021748[0x34] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\fatal.nim", 0
14002177c  char const data_14002177c[0xf] = "OverflowDefect", 0
14002178b  char const data_14002178b[0x6] = "align", 0
140021791  char const data_140021791[0xa] = "nimNewObj", 0
14002179b  char const data_14002179b[0xc] = "RangeDefect", 0
1400217a7  char const data_1400217a7[0xc] = "IndexDefect", 0
1400217b3  char const data_1400217b3[0x7] = "addInt", 0

1400217ba                                                                                00 00 00 00 00 00                            ......

1400217c0  char const data_1400217c0[0x3f] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\std\\private\\digitsutils.nim", 0
1400217ff  char const data_1400217ff[0x14] = "getCurrentException", 0

140021813                                                           00 00 00 00 00                                             .....

140021818  char const data_140021818[0x38] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\std\\typedthreads.nim", 0
140021850  char const data_140021850[0x12] = "isObjDisplayCheck", 0
140021862  char const data_140021862[0xc] = "raiseDefect", 0

14002186e  data_14002186e:
14002186e                                            25 25 00                                                             %%.

140021871  char const data_140021871[0x13] = "could not import: ", 0
140021884  char const data_140021884[0xc] = "FieldDefect", 0
140021890  char const data_140021890[0x6] = "reset", 0
140021896  char const data_140021896[0xb] = ":anonymous", 0
1400218a1  char const data_1400218a1[0x10] = "DivByZeroDefect", 0
1400218b1  char const data_1400218b1[0x9] = "raiseEIO", 0
1400218ba  char const data_1400218ba[0x8] = "IOError", 0
1400218c2  char const data_1400218c2[0xd] = "writeWindows", 0

1400218cf  data_1400218cf:
1400218cf                                               25 73 00                                                           %s.

1400218d2  char const data_1400218d2[0xc] = "echoBinSafe", 0

1400218de                                                                                            00 00                                ..

1400218e0  char const data_1400218e0[0x38] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\iterators.nim", 0

140021918                                                                          00 00 00 00 00 00 00 00                          ........
140021920  _.rdata:
140021920  00                                                                                               .

140021921  char const data_140021921[0x8] = "loadLib", 0

140021929                             00 00 00 00 00 00 00                                                           .......

140021930  char const data_140021930[0x33] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\pure\\dynlib.nim", 0
140021963  char const data_140021963[0x8] = "symAddr", 0

14002196b                                   00 00 00 00 00                                                             .....
140021970  TM__k6kyf4Co79a84IkK9blFuQVA_2:
140021970                                                  0a 00 00 00 00 00 00 40 57 73 32 5f 33 32 2e 64                  .......@Ws2_32.d
140021980  6c 6c 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ll..............

140021990  int64_t TM__k6kyf4Co79a84IkK9blFuQVA_3 = 0xa
140021998  void* data_140021998 = TM__k6kyf4Co79a84IkK9blFuQVA_2

1400219a0  TM__k6kyf4Co79a84IkK9blFuQVA_6:
1400219a0  08 00 00 00 00 00 00 40 6b 65 72 6e 65 6c 33 32 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .......@kernel32................

1400219c0  int64_t TM__k6kyf4Co79a84IkK9blFuQVA_7 = 0x8
1400219c8  void* data_1400219c8 = TM__k6kyf4Co79a84IkK9blFuQVA_6

1400219d0  TM__k6kyf4Co79a84IkK9blFuQVA_8:
1400219d0                                                  08 00 00 00 00 00 00 40 6b 65 72 6e 65 6c 33 32                  .......@kernel32
1400219e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

1400219f0  int64_t TM__k6kyf4Co79a84IkK9blFuQVA_9 = 0x8
1400219f8  void* data_1400219f8 = TM__k6kyf4Co79a84IkK9blFuQVA_8
140021a00  char const data_140021a00[0xb] = "rdFileTime", 0

140021a0b                                   00 00 00 00 00                                                             .....

140021a10  char const data_140021a10[0x37] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\windows\\winlean.nim", 0
140021a47  char const data_140021a47[0x8] = "winlean", 0
140021a4f  char const data_140021a4f[0xa] = "inet_ntop", 0
140021a59  char const data_140021a59[0x18] = "GetSystemTimeAsFileTime", 0

140021a71                                                     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                   ...............

140021a80  char const _.rdata[0x7] = "toUnix", 0

140021a87                       00                                                                                 .

140021a88  char const data_140021a88[0x32] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\pure\\times.nim", 0
140021aba  char const data_140021aba[0x9] = "initTime", 0
140021ac3  char const data_140021ac3[0xc] = "fromWinTime", 0
140021acf  char const data_140021acf[0x8] = "getTime", 0

140021ad7                                                                       00 00 00 00 00 00 00 00 00                         .........
140021ae0  TM__cGo7QGde1ZstH4i7xlaOag_4:
140021ae0  17 00 00 00 00 00 00 40 4e 69 6d 20 69 73 20 6e 6f 74 20 66 6f 72 20 6d 61 6c 77 61 72 65 21 00  .......@Nim is not for malware!.

140021b00  int64_t TM__cGo7QGde1ZstH4i7xlaOag_5 = 0x17
140021b08  void* data_140021b08 = TM__cGo7QGde1ZstH4i7xlaOag_4

140021b10                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140021b20  TM__cGo7QGde1ZstH4i7xlaOag_7:
140021b20  18 00 00 00 00 00 00 40 4f 70 65 72 61 74 69 6f 6e 20 6e 6f 74 20 70 65 72 6d 69 74 74 65 64 2e  .......@Operation not permitted.
140021b40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
140021b50  TM__cGo7QGde1ZstH4i7xlaOag_6:
140021b50                                                  18 00 00 00 00 00 00 00                                          ........

140021b58  void* data_140021b58 = TM__cGo7QGde1ZstH4i7xlaOag_7
140021b60  char const data_140021b60[0x11] = "buildEncodedFlag", 0

140021b71                                                     00 00 00 00 00 00 00                                           .......

140021b78  char const data_140021b78[0x1f] = "C:\\CTF\\nimcrackme1\\crackme.nim", 0
140021b97  char const data_140021b97[0xb] = "xorStrings", 0

140021ba2        00 00 00 00 00 00                                                                            ......

140021ba8  char const data_140021ba8[0x3a] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system\\iterators_1.nim", 0
140021be2  char const data_140021be2[0x5] = "main", 0

140021be7                       00                                                                                 .

140021be8  char const data_140021be8[0x2e] = "C:\\CTF\\nim-2.2.4_x64\\nim-2.2.4\\lib\\system.nim", 0
140021c16  char const data_140021c16[0x8] = "crackme", 0

140021c1e                                                                                            00 00                                ..

140021c20  void* _.rdata = _TLS_Entry_0

140021c28                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................

140021c40  void* __tls_directory = _.tls
140021c48  void* data_140021c48 = _.tls$ZZZ
140021c50  void* data_140021c50 = _tls_index
140021c58  void* data_140021c58 = _.CRT$XLC

140021c60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

140021c80  char const _.rdata[0x1f] = "Argument domain error (DOMAIN)", 0
140021c9f  char const data_140021c9f[0x1c] = "Argument singularity (SIGN)", 0

140021cbb                                                                                   00 00 00 00 00                             .....

140021cc0  char const data_140021cc0[0x20] = "Overflow range error (OVERFLOW)", 0
140021ce0  char const data_140021ce0[0x25] = "Partial loss of significance (PLOSS)", 0

140021d05                 00 00 00                                                                               ...

140021d08  char const data_140021d08[0x23] = "Total loss of significance (TLOSS)", 0

140021d2b                                   00 00 00 00 00                                                             .....

140021d30  char const data_140021d30[0x36] = "The result is too small to be represented (UNDERFLOW)", 0
140021d66  char const data_140021d66[0xe] = "Unknown error", 0

140021d74                                                              00 00 00 00                                              ....

140021d78  char const data_140021d78[0x2b] = "_matherr(): %s in %s(%g, %g)  (retval=%g)\n", 0

140021da3           00                                                                                         .
140021da4  uint32_t jump_table_140021da4[0x7] = 
140021da4  {
140021da4      [0x0] =  0xffff1408
140021da8      [0x1] =  0xffff13bc
140021dac      [0x2] =  0xffff1354
140021db0      [0x3] =  0xffff13dc
140021db4      [0x4] =  0xffff13ec
140021db8      [0x5] =  0xffff13fc
140021dbc      [0x6] =  0xffff13cc
140021dc0  }
140021dc0  char const _.rdata[0x1c] = "Mingw-w64 runtime failure:\n", 0

140021ddc                                                                                      00 00 00 00                              ....

140021de0  char const data_140021de0[0x20] = "Address %p has no image-section", 0
140021e00  char const data_140021e00[0x31] = "  VirtualQuery failed for %d bytes at address %p", 0

140021e31                                                     00 00 00 00 00 00 00                                           .......

140021e38  char const data_140021e38[0x27] = "  VirtualProtect failed with code 0x%x", 0

140021e5f                                                                                               00                                 .

140021e60  char const data_140021e60[0x32] = "  Unknown pseudo relocation protocol version %d.\n", 0

140021e92                                                        00 00 00 00 00 00                                            ......

140021e98  char const data_140021e98[0x2a] = "  Unknown pseudo relocation bit size %d.\n", 0

140021ec2        00 00 00 00 00 00                                                                            ......

140021ec8  char const data_140021ec8[0x53] = "%d bit pseudo relocation at %p out of range, targeting %p, yielding the value %p.\n", 0

140021f1b                                                                                   00 00 00 00 00                             .....
140021f20  uint32_t _.rdata[0xa] = 
140021f20  {
140021f20      [0x0] =  0xffff1920
140021f24      [0x1] =  0xffff1920
140021f28      [0x2] =  0xffff1920
140021f2c      [0x3] =  0xffff1920
140021f30      [0x4] =  0xffff1920
140021f34      [0x5] =  0xffff18cd
140021f38      [0x6] =  0xffff1920
140021f3c      [0x7] =  0xffff1948
140021f40      [0x8] =  0xffff18cd
140021f44      [0x9] =  0xffff18ab
140021f48  }

140021f48                          00 00 00 00 00 00 00 00                                                          ........

140021f50  char const _.rdata[0x7] = "(null)", 0

140021f57                                                                       00                                                 .

140021f58  wchar16 const data_140021f58[0x7] = "(null)", 0

140021f66  data_140021f66:
140021f66                    4e 61 4e 00                                                                          NaN.
140021f6a  data_140021f6a:
140021f6a                                49 6e 66 00 00 00                                                            Inf...
140021f70  uint32_t jump_table_140021f70[0x5b] = 
140021f70  {
140021f70      [0x00] =  0xffff43c0
140021f74      [0x01] =  0xffff3fd8
140021f78      [0x02] =  0xffff3fd8
140021f7c      [0x03] =  0xffff4692
140021f80      [0x04] =  0xffff3fd8
140021f84      [0x05] =  0xffff45aa
140021f88      [0x06] =  0xffff3fd8
140021f8c      [0x07] =  0xffff45c1
140021f90      [0x08] =  0xffff3fd8
140021f94      [0x09] =  0xffff3fd8
140021f98      [0x0a] =  0xffff463a
140021f9c      [0x0b] =  0xffff4675
140021fa0      [0x0c] =  0xffff3fd8
140021fa4      [0x0d] =  0xffff43da
140021fa8      [0x0e] =  0xffff43f7
140021fac      [0x0f] =  0xffff3fd8
140021fb0      [0x10] =  0xffff4413
140021fb4      [0x11] =  0xffff3fd8
140021fb8      [0x12] =  0xffff3fd8
140021fbc      [0x13] =  0xffff3fd8
140021fc0      [0x14] =  0xffff3fd8
140021fc4      [0x15] =  0xffff3fd8
140021fc8      [0x16] =  0xffff3fd8
140021fcc      [0x17] =  0xffff3fd8
140021fd0      [0x18] =  0xffff3fd8
140021fd4      [0x19] =  0xffff3fd8
140021fd8      [0x1a] =  0xffff3fd8
140021fdc      [0x1b] =  0xffff3fd8
140021fe0      [0x1c] =  0xffff3fd8
140021fe4      [0x1d] =  0xffff3fd8
140021fe8      [0x1e] =  0xffff3fd8
140021fec      [0x1f] =  0xffff3fd8
140021ff0      [0x20] =  0xffff3fd8
140021ff4      [0x21] =  0xffff4430
140021ff8      [0x22] =  0xffff3fd8
140021ffc      [0x23] =  0xffff44e0
140022000      [0x24] =  0xffff3fd8
140022004      [0x25] =  0xffff4517
140022008      [0x26] =  0xffff4548
14002200c      [0x27] =  0xffff4579
140022010      [0x28] =  0xffff3fd8
140022014      [0x29] =  0xffff41d9
140022018      [0x2a] =  0xffff3fd8
14002201c      [0x2b] =  0xffff3fd8
140022020      [0x2c] =  0xffff4210
140022024      [0x2d] =  0xffff3fd8
140022028      [0x2e] =  0xffff3fd8
14002202c      [0x2f] =  0xffff3fd8
140022030      [0x30] =  0xffff3fd8
140022034      [0x31] =  0xffff3fd8
140022038      [0x32] =  0xffff3fd8
14002203c      [0x33] =  0xffff46f6
140022040      [0x34] =  0xffff3fd8
140022044      [0x35] =  0xffff3fd8
140022048      [0x36] =  0xffff3fd8
14002204c      [0x37] =  0xffff3fd8
140022050      [0x38] =  0xffff4050
140022054      [0x39] =  0xffff3fd8
140022058      [0x3a] =  0xffff3fd8
14002205c      [0x3b] =  0xffff3fd8
140022060      [0x3c] =  0xffff3fd8
140022064      [0x3d] =  0xffff3fd8
140022068      [0x3e] =  0xffff3fd8
14002206c      [0x3f] =  0xffff3fd8
140022070      [0x40] =  0xffff3fd8
140022074      [0x41] =  0xffff4227
140022078      [0x42] =  0xffff3fd8
14002207c      [0x43] =  0xffff42b8
140022080      [0x44] =  0xffff40c8
140022084      [0x45] =  0xffff4392
140022088      [0x46] =  0xffff4364
14002208c      [0x47] =  0xffff4327
140022090      [0x48] =  0xffff4144
140022094      [0x49] =  0xffff40c8
140022098      [0x4a] =  0xffff40b0
14002209c      [0x4b] =  0xffff3fd8
1400220a0      [0x4c] =  0xffff41b9
1400220a4      [0x4d] =  0xffff4164
1400220a8      [0x4e] =  0xffff4182
1400220ac      [0x4f] =  0xffff4050
1400220b0      [0x50] =  0xffff4113
1400220b4      [0x51] =  0xffff3fd8
1400220b8      [0x52] =  0xffff3fd8
1400220bc      [0x53] =  0xffff42fc
1400220c0      [0x54] =  0xffff40b0
1400220c4      [0x55] =  0xffff4050
1400220c8      [0x56] =  0xffff3fd8
1400220cc      [0x57] =  0xffff3fd8
1400220d0      [0x58] =  0xffff4050
1400220d4      [0x59] =  0xffff3fd8
1400220d8      [0x5a] =  0xffff40b0
1400220dc  }

1400220dc                                                                                      00 00 00 00                              ....

1400220e0  char const _.rdata[0x9] = "Infinity", 0

1400220e9  data_1400220e9:
1400220e9                             4e 61 4e 00                                                                    NaN.
1400220ed  data_1400220ed:
1400220ed                                         30 00 00                                                               0..

1400220f0  int64_t data_1400220f0 = 0x3ff8000000000000
1400220f8  char const data_1400220f8[0x4] = "aCoc"

1400220fc                                                                                      a7 87 d2 3f                              ...?

140022100  int64_t data_140022100 = 0x3fc68a288b60c8b3
140022108  int64_t data_140022108 = 0x3fd34413509f79fb
140022110  int64_t data_140022110 = 0x3c942d169d7dfa04
140022118  char const data_140022118[0x4] = "2ZGU"

14002211c                                                                                      13 44 d3 3f                              .D.?

140022120  int64_t data_140022120 = 0x3ff0000000000000
140022128  int64_t data_140022128 = 0x4024000000000000
140022130  int64_t data_140022130 = 0x4008000000000000
140022138  int64_t data_140022138 = 0x401c000000000000
140022140  int64_t data_140022140 = 0x4014000000000000

140022148                          00 00 00 00 00 00 00 00                                                          ........

140022150  int128_t data_140022150 = 
140022150                                                  00 00 00 00 00 00 00 80 00 00 00 00 00 00 00 00                  ................
140022160  int64_t data_140022160 = 0x3fe0000000000000

140022168                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
140022180  _.rdata:
140022180  05 00 00 00 19 00 00 00 7d 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ........}.......................
1400221a0  __tens_D2A:
1400221a0  00 00 00 00 00 00 f0 3f 00 00 00 00 00 00 24 40 00 00 00 00 00 00 59 40 00 00 00 00 00 40 8f 40  .......?......$@......Y@.....@.@
1400221c0  00 00 00 00 00 88 c3 40 00 00 00 00 00 6a f8 40 00 00 00 00 80 84 2e 41 00 00 00 00 d0 12 63 41  .......@.....j.@.......A......cA
1400221e0  00 00 00 00 84 d7 97 41 00 00 00 00 65 cd cd 41 00 00 00 20 5f a0 02 42 00 00 00 e8 76 48 37 42  .......A....e..A... _..B....vH7B
140022200  00 00 00 a2 94 1a 6d 42 00 00 40 e5 9c 30 a2 42 00 00 90 1e c4 bc d6 42 00 00 34 26 f5 6b 0c 43  ......mB..@..0.B.......B..4&.k.C
140022220  00 80 e0 37 79 c3 41 43 00 a0 d8 85 57 34 76 43 00 c8 4e 67 6d c1 ab 43 00 3d 91 60 e4 58 e1 43  ...7y.AC....W4vC..Ngm..C.=.`.X.C
140022240  40 8c b5 78 1d af 15 44 50 ef e2 d6 e4 1a 4b 44 92 d5 4d 06 cf f0 80 44 00 00 00 00 00 00 00 00  @..x...DP.....KD..M....D........
140022260  __tinytens_D2A:
140022260  bc 89 d8 97 b2 d2 9c 3c 33 a7 a8 d5 23 f6 49 39 3d a7 f4 44 fd 0f a5 32 9d 97 8c cf 08 ba 5b 25  .......<3...#.I9=..D...2......[%
140022280  43 6f ac 64 28 06 c8 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  Co.d(...........................
1400222a0  __bigtens_D2A:
1400222a0  00 80 e0 37 79 c3 41 43 17 6e 05 b5 b5 b8 93 46 f5 f9 3f e9 03 4f 38 4d 32 1d 30 f9 48 77 82 5a  ...7y.AC.n.....F..?..O8M2.0.Hw.Z
1400222c0  3c bf 73 7f dd 4f 15 75                                                                          <.s..O.u

1400222c8  int64_t data_1400222c8 = 0x200000001
1400222d0  int64_t data_1400222d0 = 0x100000000

1400222d8                                                                          00 00 00 00 00 00 00 00                          ........

1400222e0  char const _.rdata[0x12] = "runtime error %d\n", 0

1400222f2                                                        00 00 00 00 00 00 00 00 00 00 00 00 00 00                    ..............

140022300  char const _.rdata[0x12] = "%p not found?!?!\n", 0
140022312  char const data_140022312[0x10] = " once %p is %d\n", 0
140022322  char const data_140022322[0xb] = "T%p %d %s\n", 0
14002232d  char const data_14002232d[0x16] = "T%p %d V=%0X H=%p %s\n", 0

140022343           00 00 00 00 00 00 00 00 00 00 00 00 00                                                     .............

140022350  char const _.rdata[0x41] = "../../src/mingw-w64/mingw-w64-libraries/winpthreads/src/rwlock.c", 0

140022391                                                     00 00 00 00 00 00 00                                           .......

140022398  char const data_140022398[0x4d] = "(((rwlock_t *)*rwl)->valid == LIFE_RWLOCK) && (((rwlock_t *)*rwl)->busy > 0)", 0

1400223e5                 00 00 00                                                                               ...

1400223e8  char const data_1400223e8[0x2a] = "Assertion failed: (%s), file %s, line %d\n", 0
140022412  char const data_140022412[0xd] = "RWL%p %d %s\n", 0

14002241f                                                                                               00                                 .

140022420  char const data_140022420[0x29] = "RWL%p %d V=%0X B=%d r=%ld w=%ld L=%p %s\n", 0

140022449                             00 00 00 00 00 00 00                                                           .......

140022450  char const _.rdata[0xb] = "C%p %d %s\n", 0
14002245b  char const data_14002245b[0x17] = "C%p %d V=%0X w=%ld %s\n", 0

140022472                                                        00 00 00 00 00 00 00 00 00 00 00 00 00 00                    ..............

140022480  void* _.rdata$.refptr.Dl_1426063656_ = Dl_1426063656_

140022488                          00 00 00 00 00 00 00 00                                                          ........

140022490  void* _.rdata$.refptr.NTIv2__1DmnNWJVVT9bplfmaalVeUA_ = NTIv2__1DmnNWJVVT9bplfmaalVeUA_

140022498                                                                          00 00 00 00 00 00 00 00                          ........

1400224a0  void* _.rdata$.refptr.NTIv2__RKHXYNwSRXz825VbZValEQ_ = NTIv2__RKHXYNwSRXz825VbZValEQ_

1400224a8                          00 00 00 00 00 00 00 00                                                          ........

1400224b0  void* _.rdata$.refptr.NTIv2__k6VacnfEHcFyOMal5EruvA_ = NTIv2__k6VacnfEHcFyOMal5EruvA_

1400224b8                                                                          00 00 00 00 00 00 00 00                          ........

1400224c0  void* _.rdata$.refptr.NTIv2__lVI5mUyBp9bAT9cco7UvZP8Q_ = NTIv2__lVI5mUyBp9bAT9cco7UvZP8Q_

1400224c8                          00 00 00 00 00 00 00 00                                                          ........

1400224d0  void* _.rdata$.refptr.NTIv2__txzrG6zQAbHR6Hap9b2RC7g_ = NTIv2__txzrG6zQAbHR6Hap9b2RC7g_

1400224d8                                                                          00 00 00 00 00 00 00 00                          ........

1400224e0  void* _.rdata$.refptr.NTIv2__xTnzBHckcPoKiwygsku9csg_ = NTIv2__xTnzBHckcPoKiwygsku9csg_

1400224e8                          00 00 00 00 00 00 00 00                                                          ........

1400224f0  void* _.rdata$.refptr._CRT_MT = _.data

1400224f8                                                                          00 00 00 00 00 00 00 00                          ........

140022500  void* _.rdata$.refptr._MINGW_INSTALL_DEBUG_MATHERR = _.data

140022508                          00 00 00 00 00 00 00 00                                                          ........

140022510  void* _.rdata$.refptr.__CTOR_LIST__ = __CTOR_LIST__

140022518                                                                          00 00 00 00 00 00 00 00                          ........

140022520  void* _.rdata$.refptr.__RUNTIME_PSEUDO_RELOC_LIST_END__ = 0x140022a70

140022528                          00 00 00 00 00 00 00 00                                                          ........

140022530  void* _.rdata$.refptr.__RUNTIME_PSEUDO_RELOC_LIST__ = 0x140022a70

140022538                                                                          00 00 00 00 00 00 00 00                          ........

140022540  void* _.rdata$.refptr.__dyn_tls_init_callback = _.rdata

140022548                          00 00 00 00 00 00 00 00                                                          ........

140022550  void* _.rdata$.refptr.__emutls_v.framePtr__system_u2692 = __emutls_v.framePtr__system_u2692

140022558                                                                          00 00 00 00 00 00 00 00                          ........

140022560  void* _.rdata$.refptr.__emutls_v.nimInErrorMode__system_u4460 = __emutls_v.nimInErrorMode__system_u4460

140022568                          00 00 00 00 00 00 00 00                                                          ........

140022570  void* _.rdata$.refptr.__image_base__ = __dos_header

140022578                                                                          00 00 00 00 00 00 00 00                          ........

140022580  void* _.rdata$.refptr.__imp___initenv = __imp___initenv

140022588                          00 00 00 00 00 00 00 00                                                          ........

140022590  void* _.rdata$.refptr.__imp__exit = api-ms-win-crt-runtime-l1-1-0:_exit

140022598                                                                          00 00 00 00 00 00 00 00                          ........

1400225a0  void* _.rdata$.refptr.__imp__tzset = api-ms-win-crt-time-l1-1-0:_tzset

1400225a8                          00 00 00 00 00 00 00 00                                                          ........

1400225b0  void* _.rdata$.refptr.__imp_exit = api-ms-win-crt-runtime-l1-1-0:exit

1400225b8                                                                          00 00 00 00 00 00 00 00                          ........

1400225c0  void* _.rdata$.refptr.__mingw_app_type = _.bss

1400225c8                          00 00 00 00 00 00 00 00                                                          ........

1400225d0  void* _.rdata$.refptr.__mingw_initltsdrot_force = __mingw_initltsdrot_force

1400225d8                                                                          00 00 00 00 00 00 00 00                          ........

1400225e0  void* _.rdata$.refptr.__mingw_initltsdyn_force = __mingw_initltsdyn_force

1400225e8                          00 00 00 00 00 00 00 00                                                          ........

1400225f0  void* _.rdata$.refptr.__mingw_initltssuo_force = _.bss

1400225f8                                                                          00 00 00 00 00 00 00 00                          ........

140022600  void* _.rdata$.refptr.__mingw_module_is_dll = _.bss

140022608                          00 00 00 00 00 00 00 00                                                          ........

140022610  void* _.rdata$.refptr.__mingw_oldexcpt_handler = _.bss

140022618                                                                          00 00 00 00 00 00 00 00                          ........

140022620  void* _.rdata$.refptr.__native_startup_lock = _.bss

140022628                          00 00 00 00 00 00 00 00                                                          ........

140022630  void* _.rdata$.refptr.__native_startup_state = __native_startup_state

140022638                                                                          00 00 00 00 00 00 00 00                          ........

140022640  void* _.rdata$.refptr.__tens_D2A = __tens_D2A

140022648                          00 00 00 00 00 00 00 00                                                          ........

140022650  void* _.rdata$.refptr.__xc_a = _.CRT$XCA

140022658                                                                          00 00 00 00 00 00 00 00                          ........

140022660  void* _.rdata$.refptr.__xc_z = _.CRT$XCZ

140022668                          00 00 00 00 00 00 00 00                                                          ........

140022670  void* _.rdata$.refptr.__xi_a = _.CRT$XIA

140022678                                                                          00 00 00 00 00 00 00 00                          ........

140022680  void* _.rdata$.refptr.__xi_z = _.CRT$XIZ

140022688                          00 00 00 00 00 00 00 00                                                          ........

140022690  void* _.rdata$.refptr._commode = _.bss

140022698                                                                          00 00 00 00 00 00 00 00                          ........

1400226a0  void* _.rdata$.refptr._dowildcard = _.data

1400226a8                          00 00 00 00 00 00 00 00                                                          ........

1400226b0  void* _.rdata$.refptr._fmode = _.bss

1400226b8                                                                          00 00 00 00 00 00 00 00                          ........

1400226c0  void* _.rdata$.refptr._gnu_exception_handler = _gnu_exception_handler

1400226c8                          00 00 00 00 00 00 00 00                                                          ........

1400226d0  void* _.rdata$.refptr._matherr = _matherr

1400226d8                                                                          00 00 00 00 00 00 00 00                          ........

1400226e0  void* _.rdata$.refptr._newmode = _.bss

1400226e8                          00 00 00 00 00 00 00 00                                                          ........

1400226f0  void* _.rdata$.refptr.nim_program_result = _.bss

1400226f8                                                                          00 00 00 00 00 00 00 00                          ........
140022700  _.rdata$zzz:
140022700  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73 69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69  GCC: (x86_64-posix-seh-rev0, Bui
140022720  6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c 64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32  lt by MinGW-Builds project) 13.2
140022740  2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  .0..............
140022750  _.rdata$zzz:
140022750                                                  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73                  GCC: (x86_64-pos
140022760  69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69 6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c  ix-seh-rev0, Built by MinGW-Buil
140022780  64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32 2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ds project) 13.2.0..............
1400227a0  _.rdata$zzz:
1400227a0  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73 69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69  GCC: (x86_64-posix-seh-rev0, Bui
1400227c0  6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c 64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32  lt by MinGW-Builds project) 13.2
1400227e0  2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  .0..............
1400227f0  _.rdata$zzz:
1400227f0                                                  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73                  GCC: (x86_64-pos
140022800  69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69 6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c  ix-seh-rev0, Built by MinGW-Buil
140022820  64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32 2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ds project) 13.2.0..............
140022840  _.rdata$zzz:
140022840  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73 69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69  GCC: (x86_64-posix-seh-rev0, Bui
140022860  6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c 64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32  lt by MinGW-Builds project) 13.2
140022880  2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  .0..............
140022890  _.rdata$zzz:
140022890                                                  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73                  GCC: (x86_64-pos
1400228a0  69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69 6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c  ix-seh-rev0, Built by MinGW-Buil
1400228c0  64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32 2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ds project) 13.2.0..............
1400228e0  _.rdata$zzz:
1400228e0  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73 69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69  GCC: (x86_64-posix-seh-rev0, Bui
140022900  6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c 64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32  lt by MinGW-Builds project) 13.2
140022920  2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  .0..............
140022930  _.rdata$zzz:
140022930                                                  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73                  GCC: (x86_64-pos
140022940  69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69 6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c  ix-seh-rev0, Built by MinGW-Buil
140022960  64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32 2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ds project) 13.2.0..............
140022980  _.rdata$zzz:
140022980  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73 69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69  GCC: (x86_64-posix-seh-rev0, Bui
1400229a0  6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c 64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32  lt by MinGW-Builds project) 13.2
1400229c0  2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  .0..............
1400229d0  _.rdata$zzz:
1400229d0                                                  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73                  GCC: (x86_64-pos
1400229e0  69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69 6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c  ix-seh-rev0, Built by MinGW-Buil
140022a00  64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32 2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ds project) 13.2.0..............
140022a20  _.rdata$zzz:
140022a20  47 43 43 3a 20 28 78 38 36 5f 36 34 2d 70 6f 73 69 78 2d 73 65 68 2d 72 65 76 30 2c 20 42 75 69  GCC: (x86_64-posix-seh-rev0, Bui
140022a40  6c 74 20 62 79 20 4d 69 6e 47 57 2d 42 75 69 6c 64 73 20 70 72 6f 6a 65 63 74 29 20 31 33 2e 32  lt by MinGW-Builds project) 13.2
140022a60  2e 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  .0..............
.rdata section ended  {0x140020000-0x140022a70}

.pdata section started  {0x140023000-0x140024950}
140023000  _.pdata:
140023000  00 10 00 00 01 10 00 00 00 50 02 00                                                              .........P..

14002300c  struct Exception_Directory_Entry __exception_directory_entries(1) = 
14002300c  {
14002300c      uint32_t beginAddress = 0x1010
140023010      uint32_t endAddress = 0x112e
140023014      uint32_t unwindInformation = 0x25004
140023018  }
140023018  struct Exception_Directory_Entry __exception_directory_entries(2) = 
140023018  {
140023018      uint32_t beginAddress = 0x1130
14002301c      uint32_t endAddress = 0x1179
140023020      uint32_t unwindInformation = 0x2500c
140023024  }
140023024  struct Exception_Directory_Entry __exception_directory_entries(3) = 
140023024  {
140023024      uint32_t beginAddress = 0x1180
140023028      uint32_t endAddress = 0x13d0
14002302c      uint32_t unwindInformation = 0x25014
140023030  }
140023030  struct Exception_Directory_Entry __exception_directory_entries(4) = 
140023030  {
140023030      uint32_t beginAddress = 0x13d0
140023034      uint32_t endAddress = 0x13ed
140023038      uint32_t unwindInformation = 0x25024
14002303c  }
14002303c  struct Exception_Directory_Entry __exception_directory_entries(5) = 
14002303c  {
14002303c      uint32_t beginAddress = 0x13f0
140023040      uint32_t endAddress = 0x140d
140023044      uint32_t unwindInformation = 0x25044
140023048  }
140023048  struct Exception_Directory_Entry __exception_directory_entries(6) = 
140023048  {
140023048      uint32_t beginAddress = 0x1410
14002304c      uint32_t endAddress = 0x1424
140023050      uint32_t unwindInformation = 0x25064
140023054  }

140023054  _.pdata:
140023054                                                              30 14 00 00 3c 14 00 00 6c 50 02 00                      0...<...lP..

140023060  struct Exception_Directory_Entry __exception_directory_entries(8) = 
140023060  {
140023060      uint32_t beginAddress = 0x1440
140023064      uint32_t endAddress = 0x1441
140023068      uint32_t unwindInformation = 0x25070
14002306c  }

14002306c  _.pdata:
14002306c                                      50 14 00 00 e0 14 00 00 74 50 02 00                                      P.......tP..

140023078  struct Exception_Directory_Entry __exception_directory_entries(10) = 
140023078  {
140023078      uint32_t beginAddress = 0x14e0
14002307c      uint32_t endAddress = 0x1507
140023080      uint32_t unwindInformation = 0x25080
140023084  }
140023084  struct Exception_Directory_Entry __exception_directory_entries(11) = 
140023084  {
140023084      uint32_t beginAddress = 0x1507
140023088      uint32_t endAddress = 0x1580
14002308c      uint32_t unwindInformation = 0x2508c
140023090  }
140023090  struct Exception_Directory_Entry __exception_directory_entries(12) = 
140023090  {
140023090      uint32_t beginAddress = 0x1580
140023094      uint32_t endAddress = 0x15a5
140023098      uint32_t unwindInformation = 0x25098
14002309c  }
14002309c  struct Exception_Directory_Entry __exception_directory_entries(13) = 
14002309c  {
14002309c      uint32_t beginAddress = 0x15a5
1400230a0      uint32_t endAddress = 0x1707
1400230a4      uint32_t unwindInformation = 0x250a4
1400230a8  }
1400230a8  struct Exception_Directory_Entry __exception_directory_entries(14) = 
1400230a8  {
1400230a8      uint32_t beginAddress = 0x1707
1400230ac      uint32_t endAddress = 0x17e1
1400230b0      uint32_t unwindInformation = 0x250b0
1400230b4  }
1400230b4  struct Exception_Directory_Entry __exception_directory_entries(15) = 
1400230b4  {
1400230b4      uint32_t beginAddress = 0x17e1
1400230b8      uint32_t endAddress = 0x1816
1400230bc      uint32_t unwindInformation = 0x250bc
1400230c0  }
1400230c0  struct Exception_Directory_Entry __exception_directory_entries(16) = 
1400230c0  {
1400230c0      uint32_t beginAddress = 0x1816
1400230c4      uint32_t endAddress = 0x193c
1400230c8      uint32_t unwindInformation = 0x250c8
1400230cc  }
1400230cc  struct Exception_Directory_Entry __exception_directory_entries(17) = 
1400230cc  {
1400230cc      uint32_t beginAddress = 0x193c
1400230d0      uint32_t endAddress = 0x19ef
1400230d4      uint32_t unwindInformation = 0x250d4
1400230d8  }
1400230d8  struct Exception_Directory_Entry __exception_directory_entries(18) = 
1400230d8  {
1400230d8      uint32_t beginAddress = 0x19ef
1400230dc      uint32_t endAddress = 0x1a2e
1400230e0      uint32_t unwindInformation = 0x250e0
1400230e4  }
1400230e4  struct Exception_Directory_Entry __exception_directory_entries(19) = 
1400230e4  {
1400230e4      uint32_t beginAddress = 0x1a2e
1400230e8      uint32_t endAddress = 0x1b08
1400230ec      uint32_t unwindInformation = 0x250ec
1400230f0  }
1400230f0  struct Exception_Directory_Entry __exception_directory_entries(20) = 
1400230f0  {
1400230f0      uint32_t beginAddress = 0x1b08
1400230f4      uint32_t endAddress = 0x1b3d
1400230f8      uint32_t unwindInformation = 0x250f8
1400230fc  }
1400230fc  struct Exception_Directory_Entry __exception_directory_entries(21) = 
1400230fc  {
1400230fc      uint32_t beginAddress = 0x1b3d
140023100      uint32_t endAddress = 0x1b7c
140023104      uint32_t unwindInformation = 0x25104
140023108  }
140023108  struct Exception_Directory_Entry __exception_directory_entries(22) = 
140023108  {
140023108      uint32_t beginAddress = 0x1b7c
14002310c      uint32_t endAddress = 0x1c56
140023110      uint32_t unwindInformation = 0x25110
140023114  }
140023114  struct Exception_Directory_Entry __exception_directory_entries(23) = 
140023114  {
140023114      uint32_t beginAddress = 0x1c56
140023118      uint32_t endAddress = 0x1c8b
14002311c      uint32_t unwindInformation = 0x2511c
140023120  }
140023120  struct Exception_Directory_Entry __exception_directory_entries(24) = 
140023120  {
140023120      uint32_t beginAddress = 0x1c8b
140023124      uint32_t endAddress = 0x1cca
140023128      uint32_t unwindInformation = 0x25128
14002312c  }
14002312c  struct Exception_Directory_Entry __exception_directory_entries(25) = 
14002312c  {
14002312c      uint32_t beginAddress = 0x1cca
140023130      uint32_t endAddress = 0x1da4
140023134      uint32_t unwindInformation = 0x25134
140023138  }
140023138  struct Exception_Directory_Entry __exception_directory_entries(26) = 
140023138  {
140023138      uint32_t beginAddress = 0x1da4
14002313c      uint32_t endAddress = 0x1dd9
140023140      uint32_t unwindInformation = 0x25140
140023144  }
140023144  struct Exception_Directory_Entry __exception_directory_entries(27) = 
140023144  {
140023144      uint32_t beginAddress = 0x1dd9
140023148      uint32_t endAddress = 0x1e18
14002314c      uint32_t unwindInformation = 0x2514c
140023150  }
140023150  struct Exception_Directory_Entry __exception_directory_entries(28) = 
140023150  {
140023150      uint32_t beginAddress = 0x1e18
140023154      uint32_t endAddress = 0x1ef2
140023158      uint32_t unwindInformation = 0x25158
14002315c  }
14002315c  struct Exception_Directory_Entry __exception_directory_entries(29) = 
14002315c  {
14002315c      uint32_t beginAddress = 0x1ef2
140023160      uint32_t endAddress = 0x1f27
140023164      uint32_t unwindInformation = 0x25164
140023168  }
140023168  struct Exception_Directory_Entry __exception_directory_entries(30) = 
140023168  {
140023168      uint32_t beginAddress = 0x1f27
14002316c      uint32_t endAddress = 0x1f66
140023170      uint32_t unwindInformation = 0x25170
140023174  }
140023174  struct Exception_Directory_Entry __exception_directory_entries(31) = 
140023174  {
140023174      uint32_t beginAddress = 0x1f66
140023178      uint32_t endAddress = 0x2040
14002317c      uint32_t unwindInformation = 0x2517c
140023180  }
140023180  struct Exception_Directory_Entry __exception_directory_entries(32) = 
140023180  {
140023180      uint32_t beginAddress = 0x2040
140023184      uint32_t endAddress = 0x2075
140023188      uint32_t unwindInformation = 0x25188
14002318c  }
14002318c  struct Exception_Directory_Entry __exception_directory_entries(33) = 
14002318c  {
14002318c      uint32_t beginAddress = 0x2075
140023190      uint32_t endAddress = 0x20b4
140023194      uint32_t unwindInformation = 0x25194
140023198  }

140023198  _.pdata:
140023198                                                                          c0 20 00 00 52 21 00 00                          . ..R!..
1400231a0  a0 51 02 00                                                                                      .Q..

1400231a4  struct Exception_Directory_Entry __exception_directory_entries(35) = 
1400231a4  {
1400231a4      uint32_t beginAddress = 0x2152
1400231a8      uint32_t endAddress = 0x2190
1400231ac      uint32_t unwindInformation = 0x251ac
1400231b0  }
1400231b0  struct Exception_Directory_Entry __exception_directory_entries(36) = 
1400231b0  {
1400231b0      uint32_t beginAddress = 0x2190
1400231b4      uint32_t endAddress = 0x21c2
1400231b8      uint32_t unwindInformation = 0x251b8
1400231bc  }
1400231bc  struct Exception_Directory_Entry __exception_directory_entries(37) = 
1400231bc  {
1400231bc      uint32_t beginAddress = 0x21c2
1400231c0      uint32_t endAddress = 0x2252
1400231c4      uint32_t unwindInformation = 0x251c4
1400231c8  }
1400231c8  struct Exception_Directory_Entry __exception_directory_entries(38) = 
1400231c8  {
1400231c8      uint32_t beginAddress = 0x2252
1400231cc      uint32_t endAddress = 0x2279
1400231d0      uint32_t unwindInformation = 0x251d0
1400231d4  }
1400231d4  struct Exception_Directory_Entry __exception_directory_entries(39) = 
1400231d4  {
1400231d4      uint32_t beginAddress = 0x2279
1400231d8      uint32_t endAddress = 0x2404
1400231dc      uint32_t unwindInformation = 0x251dc
1400231e0  }
1400231e0  struct Exception_Directory_Entry __exception_directory_entries(40) = 
1400231e0  {
1400231e0      uint32_t beginAddress = 0x2404
1400231e4      uint32_t endAddress = 0x2429
1400231e8      uint32_t unwindInformation = 0x251e8
1400231ec  }
1400231ec  struct Exception_Directory_Entry __exception_directory_entries(41) = 
1400231ec  {
1400231ec      uint32_t beginAddress = 0x2429
1400231f0      uint32_t endAddress = 0x2911
1400231f4      uint32_t unwindInformation = 0x251f4
1400231f8  }
1400231f8  struct Exception_Directory_Entry __exception_directory_entries(42) = 
1400231f8  {
1400231f8      uint32_t beginAddress = 0x2911
1400231fc      uint32_t endAddress = 0x298b
140023200      uint32_t unwindInformation = 0x25200
140023204  }
140023204  struct Exception_Directory_Entry __exception_directory_entries(43) = 
140023204  {
140023204      uint32_t beginAddress = 0x298b
140023208      uint32_t endAddress = 0x2a87
14002320c      uint32_t unwindInformation = 0x2520c
140023210  }

140023210  _.pdata:
140023210                                                  90 2a 00 00 20 2b 00 00 18 52 02 00                              .*.. +...R..

14002321c  struct Exception_Directory_Entry __exception_directory_entries(45) = 
14002321c  {
14002321c      uint32_t beginAddress = 0x2b20
140023220      uint32_t endAddress = 0x2b47
140023224      uint32_t unwindInformation = 0x25224
140023228  }
140023228  struct Exception_Directory_Entry __exception_directory_entries(46) = 
140023228  {
140023228      uint32_t beginAddress = 0x2b47
14002322c      uint32_t endAddress = 0x2bb6
140023230      uint32_t unwindInformation = 0x25230
140023234  }
140023234  struct Exception_Directory_Entry __exception_directory_entries(47) = 
140023234  {
140023234      uint32_t beginAddress = 0x2bb6
140023238      uint32_t endAddress = 0x2c56
14002323c      uint32_t unwindInformation = 0x2523c
140023240  }
140023240  struct Exception_Directory_Entry __exception_directory_entries(48) = 
140023240  {
140023240      uint32_t beginAddress = 0x2c56
140023244      uint32_t endAddress = 0x2ceb
140023248      uint32_t unwindInformation = 0x25248
14002324c  }

14002324c  _.pdata:
14002324c                                      f0 2c 00 00 13 2d 00 00 54 52 02 00                                      .,...-..TR..

140023258  struct Exception_Directory_Entry __exception_directory_entries(50) = 
140023258  {
140023258      uint32_t beginAddress = 0x2d13
14002325c      uint32_t endAddress = 0x2d38
140023260      uint32_t unwindInformation = 0x25260
140023264  }
140023264  struct Exception_Directory_Entry __exception_directory_entries(51) = 
140023264  {
140023264      uint32_t beginAddress = 0x2d38
140023268      uint32_t endAddress = 0x2d5b
14002326c      uint32_t unwindInformation = 0x2526c
140023270  }
140023270  struct Exception_Directory_Entry __exception_directory_entries(52) = 
140023270  {
140023270      uint32_t beginAddress = 0x2d5b
140023274      uint32_t endAddress = 0x2d97
140023278      uint32_t unwindInformation = 0x25278
14002327c  }
14002327c  struct Exception_Directory_Entry __exception_directory_entries(53) = 
14002327c  {
14002327c      uint32_t beginAddress = 0x2d97
140023280      uint32_t endAddress = 0x2ddc
140023284      uint32_t unwindInformation = 0x25284
140023288  }
140023288  struct Exception_Directory_Entry __exception_directory_entries(54) = 
140023288  {
140023288      uint32_t beginAddress = 0x2ddc
14002328c      uint32_t endAddress = 0x2e6c
140023290      uint32_t unwindInformation = 0x25290
140023294  }
140023294  struct Exception_Directory_Entry __exception_directory_entries(55) = 
140023294  {
140023294      uint32_t beginAddress = 0x2e6c
140023298      uint32_t endAddress = 0x2e93
14002329c      uint32_t unwindInformation = 0x2529c
1400232a0  }
1400232a0  struct Exception_Directory_Entry __exception_directory_entries(56) = 
1400232a0  {
1400232a0      uint32_t beginAddress = 0x2e93
1400232a4      uint32_t endAddress = 0x2f0c
1400232a8      uint32_t unwindInformation = 0x252a8
1400232ac  }
1400232ac  struct Exception_Directory_Entry __exception_directory_entries(57) = 
1400232ac  {
1400232ac      uint32_t beginAddress = 0x2f0c
1400232b0      uint32_t endAddress = 0x2ff4
1400232b4      uint32_t unwindInformation = 0x252b4
1400232b8  }
1400232b8  struct Exception_Directory_Entry __exception_directory_entries(58) = 
1400232b8  {
1400232b8      uint32_t beginAddress = 0x2ff4
1400232bc      uint32_t endAddress = 0x314b
1400232c0      uint32_t unwindInformation = 0x252c0
1400232c4  }
1400232c4  struct Exception_Directory_Entry __exception_directory_entries(59) = 
1400232c4  {
1400232c4      uint32_t beginAddress = 0x314b
1400232c8      uint32_t endAddress = 0x329b
1400232cc      uint32_t unwindInformation = 0x252cc
1400232d0  }
1400232d0  struct Exception_Directory_Entry __exception_directory_entries(60) = 
1400232d0  {
1400232d0      uint32_t beginAddress = 0x329b
1400232d4      uint32_t endAddress = 0x3316
1400232d8      uint32_t unwindInformation = 0x252d8
1400232dc  }
1400232dc  struct Exception_Directory_Entry __exception_directory_entries(61) = 
1400232dc  {
1400232dc      uint32_t beginAddress = 0x3316
1400232e0      uint32_t endAddress = 0x3372
1400232e4      uint32_t unwindInformation = 0x252e4
1400232e8  }
1400232e8  struct Exception_Directory_Entry __exception_directory_entries(62) = 
1400232e8  {
1400232e8      uint32_t beginAddress = 0x3372
1400232ec      uint32_t endAddress = 0x33c1
1400232f0      uint32_t unwindInformation = 0x252f0
1400232f4  }
1400232f4  struct Exception_Directory_Entry __exception_directory_entries(63) = 
1400232f4  {
1400232f4      uint32_t beginAddress = 0x33c1
1400232f8      uint32_t endAddress = 0x33e4
1400232fc      uint32_t unwindInformation = 0x252fc
140023300  }
140023300  struct Exception_Directory_Entry __exception_directory_entries(64) = 
140023300  {
140023300      uint32_t beginAddress = 0x33e4
140023304      uint32_t endAddress = 0x382c
140023308      uint32_t unwindInformation = 0x25308
14002330c  }
14002330c  struct Exception_Directory_Entry __exception_directory_entries(65) = 
14002330c  {
14002330c      uint32_t beginAddress = 0x382c
140023310      uint32_t endAddress = 0x3a40
140023314      uint32_t unwindInformation = 0x25314
140023318  }
140023318  struct Exception_Directory_Entry __exception_directory_entries(66) = 
140023318  {
140023318      uint32_t beginAddress = 0x3a40
14002331c      uint32_t endAddress = 0x3ac1
140023320      uint32_t unwindInformation = 0x25324
140023324  }

140023324  _.pdata:
140023324              d0 3a 00 00 60 3b 00 00 30 53 02 00                                                      .:..`;..0S..

140023330  struct Exception_Directory_Entry __exception_directory_entries(68) = 
140023330  {
140023330      uint32_t beginAddress = 0x3b60
140023334      uint32_t endAddress = 0x3b87
140023338      uint32_t unwindInformation = 0x2533c
14002333c  }
14002333c  struct Exception_Directory_Entry __exception_directory_entries(69) = 
14002333c  {
14002333c      uint32_t beginAddress = 0x3b87
140023340      uint32_t endAddress = 0x3be6
140023344      uint32_t unwindInformation = 0x25348
140023348  }
140023348  struct Exception_Directory_Entry __exception_directory_entries(70) = 
140023348  {
140023348      uint32_t beginAddress = 0x3be6
14002334c      uint32_t endAddress = 0x3c22
140023350      uint32_t unwindInformation = 0x25354
140023354  }
140023354  struct Exception_Directory_Entry __exception_directory_entries(71) = 
140023354  {
140023354      uint32_t beginAddress = 0x3c22
140023358      uint32_t endAddress = 0x3c47
14002335c      uint32_t unwindInformation = 0x25360
140023360  }
140023360  struct Exception_Directory_Entry __exception_directory_entries(72) = 
140023360  {
140023360      uint32_t beginAddress = 0x3c47
140023364      uint32_t endAddress = 0x3c8c
140023368      uint32_t unwindInformation = 0x2536c
14002336c  }
14002336c  struct Exception_Directory_Entry __exception_directory_entries(73) = 
14002336c  {
14002336c      uint32_t beginAddress = 0x3c8c
140023370      uint32_t endAddress = 0x3ceb
140023374      uint32_t unwindInformation = 0x25378
140023378  }
140023378  struct Exception_Directory_Entry __exception_directory_entries(74) = 
140023378  {
140023378      uint32_t beginAddress = 0x3ceb
14002337c      uint32_t endAddress = 0x3f5a
140023380      uint32_t unwindInformation = 0x25384
140023384  }
140023384  struct Exception_Directory_Entry __exception_directory_entries(75) = 
140023384  {
140023384      uint32_t beginAddress = 0x3f5a
140023388      uint32_t endAddress = 0x4034
14002338c      uint32_t unwindInformation = 0x25390
140023390  }

140023390  _.pdata:
140023390                                                  40 40 00 00 83 40 00 00 9c 53 02 00                              @@...@...S..

14002339c  struct Exception_Directory_Entry __exception_directory_entries(77) = 
14002339c  {
14002339c      uint32_t beginAddress = 0x4083
1400233a0      uint32_t endAddress = 0x40d7
1400233a4      uint32_t unwindInformation = 0x253a8
1400233a8  }
1400233a8  struct Exception_Directory_Entry __exception_directory_entries(78) = 
1400233a8  {
1400233a8      uint32_t beginAddress = 0x40d7
1400233ac      uint32_t endAddress = 0x4122
1400233b0      uint32_t unwindInformation = 0x253b4
1400233b4  }
1400233b4  struct Exception_Directory_Entry __exception_directory_entries(79) = 
1400233b4  {
1400233b4      uint32_t beginAddress = 0x4122
1400233b8      uint32_t endAddress = 0x4186
1400233bc      uint32_t unwindInformation = 0x253c0
1400233c0  }
1400233c0  struct Exception_Directory_Entry __exception_directory_entries(80) = 
1400233c0  {
1400233c0      uint32_t beginAddress = 0x4186
1400233c4      uint32_t endAddress = 0x41f6
1400233c8      uint32_t unwindInformation = 0x253cc
1400233cc  }
1400233cc  struct Exception_Directory_Entry __exception_directory_entries(81) = 
1400233cc  {
1400233cc      uint32_t beginAddress = 0x41f6
1400233d0      uint32_t endAddress = 0x42ce
1400233d4      uint32_t unwindInformation = 0x253d8
1400233d8  }
1400233d8  struct Exception_Directory_Entry __exception_directory_entries(82) = 
1400233d8  {
1400233d8      uint32_t beginAddress = 0x42ce
1400233dc      uint32_t endAddress = 0x430a
1400233e0      uint32_t unwindInformation = 0x253e4
1400233e4  }
1400233e4  struct Exception_Directory_Entry __exception_directory_entries(83) = 
1400233e4  {
1400233e4      uint32_t beginAddress = 0x430a
1400233e8      uint32_t endAddress = 0x432f
1400233ec      uint32_t unwindInformation = 0x253f0
1400233f0  }
1400233f0  struct Exception_Directory_Entry __exception_directory_entries(84) = 
1400233f0  {
1400233f0      uint32_t beginAddress = 0x432f
1400233f4      uint32_t endAddress = 0x4374
1400233f8      uint32_t unwindInformation = 0x253fc
1400233fc  }
1400233fc  struct Exception_Directory_Entry __exception_directory_entries(85) = 
1400233fc  {
1400233fc      uint32_t beginAddress = 0x4374
140023400      uint32_t endAddress = 0x43b2
140023404      uint32_t unwindInformation = 0x25408
140023408  }
140023408  struct Exception_Directory_Entry __exception_directory_entries(86) = 
140023408  {
140023408      uint32_t beginAddress = 0x43b2
14002340c      uint32_t endAddress = 0x43e4
140023410      uint32_t unwindInformation = 0x25414
140023414  }
140023414  struct Exception_Directory_Entry __exception_directory_entries(87) = 
140023414  {
140023414      uint32_t beginAddress = 0x43e4
140023418      uint32_t endAddress = 0x440b
14002341c      uint32_t unwindInformation = 0x25420
140023420  }
140023420  struct Exception_Directory_Entry __exception_directory_entries(88) = 
140023420  {
140023420      uint32_t beginAddress = 0x440b
140023424      uint32_t endAddress = 0x45f7
140023428      uint32_t unwindInformation = 0x2542c
14002342c  }
14002342c  struct Exception_Directory_Entry __exception_directory_entries(89) = 
14002342c  {
14002342c      uint32_t beginAddress = 0x45f7
140023430      uint32_t endAddress = 0x4676
140023434      uint32_t unwindInformation = 0x2543c
140023438  }
140023438  struct Exception_Directory_Entry __exception_directory_entries(90) = 
140023438  {
140023438      uint32_t beginAddress = 0x4676
14002343c      uint32_t endAddress = 0x47c9
140023440      uint32_t unwindInformation = 0x25448
140023444  }
140023444  struct Exception_Directory_Entry __exception_directory_entries(91) = 
140023444  {
140023444      uint32_t beginAddress = 0x47c9
140023448      uint32_t endAddress = 0x4936
14002344c      uint32_t unwindInformation = 0x25454
140023450  }
140023450  struct Exception_Directory_Entry __exception_directory_entries(92) = 
140023450  {
140023450      uint32_t beginAddress = 0x4936
140023454      uint32_t endAddress = 0x499b
140023458      uint32_t unwindInformation = 0x25460
14002345c  }
14002345c  struct Exception_Directory_Entry __exception_directory_entries(93) = 
14002345c  {
14002345c      uint32_t beginAddress = 0x499b
140023460      uint32_t endAddress = 0x4b3e
140023464      uint32_t unwindInformation = 0x2546c
140023468  }
140023468  struct Exception_Directory_Entry __exception_directory_entries(94) = 
140023468  {
140023468      uint32_t beginAddress = 0x4b3e
14002346c      uint32_t endAddress = 0x4bdc
140023470      uint32_t unwindInformation = 0x25478
140023474  }
140023474  struct Exception_Directory_Entry __exception_directory_entries(95) = 
140023474  {
140023474      uint32_t beginAddress = 0x4bdc
140023478      uint32_t endAddress = 0x4c76
14002347c      uint32_t unwindInformation = 0x25484
140023480  }
140023480  struct Exception_Directory_Entry __exception_directory_entries(96) = 
140023480  {
140023480      uint32_t beginAddress = 0x4c76
140023484      uint32_t endAddress = 0x4cf0
140023488      uint32_t unwindInformation = 0x25490
14002348c  }
14002348c  struct Exception_Directory_Entry __exception_directory_entries(97) = 
14002348c  {
14002348c      uint32_t beginAddress = 0x4cf0
140023490      uint32_t endAddress = 0x4d73
140023494      uint32_t unwindInformation = 0x2549c
140023498  }
140023498  struct Exception_Directory_Entry __exception_directory_entries(98) = 
140023498  {
140023498      uint32_t beginAddress = 0x4d73
14002349c      uint32_t endAddress = 0x4ded
1400234a0      uint32_t unwindInformation = 0x254a8
1400234a4  }
1400234a4  struct Exception_Directory_Entry __exception_directory_entries(99) = 
1400234a4  {
1400234a4      uint32_t beginAddress = 0x4ded
1400234a8      uint32_t endAddress = 0x4e5e
1400234ac      uint32_t unwindInformation = 0x254b4
1400234b0  }
1400234b0  struct Exception_Directory_Entry __exception_directory_entries(100) = 
1400234b0  {
1400234b0      uint32_t beginAddress = 0x4e5e
1400234b4      uint32_t endAddress = 0x4e85
1400234b8      uint32_t unwindInformation = 0x254c0
1400234bc  }
1400234bc  struct Exception_Directory_Entry __exception_directory_entries(101) = 
1400234bc  {
1400234bc      uint32_t beginAddress = 0x4e85
1400234c0      uint32_t endAddress = 0x5074
1400234c4      uint32_t unwindInformation = 0x254cc
1400234c8  }
1400234c8  struct Exception_Directory_Entry __exception_directory_entries(102) = 
1400234c8  {
1400234c8      uint32_t beginAddress = 0x5074
1400234cc      uint32_t endAddress = 0x528d
1400234d0      uint32_t unwindInformation = 0x254d8
1400234d4  }
1400234d4  struct Exception_Directory_Entry __exception_directory_entries(103) = 
1400234d4  {
1400234d4      uint32_t beginAddress = 0x528d
1400234d8      uint32_t endAddress = 0x5306
1400234dc      uint32_t unwindInformation = 0x254e4
1400234e0  }
1400234e0  struct Exception_Directory_Entry __exception_directory_entries(104) = 
1400234e0  {
1400234e0      uint32_t beginAddress = 0x5306
1400234e4      uint32_t endAddress = 0x53e1
1400234e8      uint32_t unwindInformation = 0x254f0
1400234ec  }
1400234ec  struct Exception_Directory_Entry __exception_directory_entries(105) = 
1400234ec  {
1400234ec      uint32_t beginAddress = 0x53e1
1400234f0      uint32_t endAddress = 0x54c0
1400234f4      uint32_t unwindInformation = 0x254fc
1400234f8  }
1400234f8  struct Exception_Directory_Entry __exception_directory_entries(106) = 
1400234f8  {
1400234f8      uint32_t beginAddress = 0x54c0
1400234fc      uint32_t endAddress = 0x551f
140023500      uint32_t unwindInformation = 0x25508
140023504  }
140023504  struct Exception_Directory_Entry __exception_directory_entries(107) = 
140023504  {
140023504      uint32_t beginAddress = 0x551f
140023508      uint32_t endAddress = 0x5598
14002350c      uint32_t unwindInformation = 0x25514
140023510  }
140023510  struct Exception_Directory_Entry __exception_directory_entries(108) = 
140023510  {
140023510      uint32_t beginAddress = 0x5598
140023514      uint32_t endAddress = 0x5aba
140023518      uint32_t unwindInformation = 0x25520
14002351c  }
14002351c  struct Exception_Directory_Entry __exception_directory_entries(109) = 
14002351c  {
14002351c      uint32_t beginAddress = 0x5aba
140023520      uint32_t endAddress = 0x5b19
140023524      uint32_t unwindInformation = 0x2552c
140023528  }
140023528  struct Exception_Directory_Entry __exception_directory_entries(110) = 
140023528  {
140023528      uint32_t beginAddress = 0x5b19
14002352c      uint32_t endAddress = 0x5ba1
140023530      uint32_t unwindInformation = 0x25538
140023534  }
140023534  struct Exception_Directory_Entry __exception_directory_entries(111) = 
140023534  {
140023534      uint32_t beginAddress = 0x5ba1
140023538      uint32_t endAddress = 0x5c6b
14002353c      uint32_t unwindInformation = 0x25544
140023540  }
140023540  struct Exception_Directory_Entry __exception_directory_entries(112) = 
140023540  {
140023540      uint32_t beginAddress = 0x5c6b
140023544      uint32_t endAddress = 0x5d66
140023548      uint32_t unwindInformation = 0x25550
14002354c  }
14002354c  struct Exception_Directory_Entry __exception_directory_entries(113) = 
14002354c  {
14002354c      uint32_t beginAddress = 0x5d66
140023550      uint32_t endAddress = 0x5e42
140023554      uint32_t unwindInformation = 0x2555c
140023558  }
140023558  struct Exception_Directory_Entry __exception_directory_entries(114) = 
140023558  {
140023558      uint32_t beginAddress = 0x5e42
14002355c      uint32_t endAddress = 0x5fb4
140023560      uint32_t unwindInformation = 0x25568
140023564  }
140023564  struct Exception_Directory_Entry __exception_directory_entries(115) = 
140023564  {
140023564      uint32_t beginAddress = 0x5fb4
140023568      uint32_t endAddress = 0x6075
14002356c      uint32_t unwindInformation = 0x25574
140023570  }
140023570  struct Exception_Directory_Entry __exception_directory_entries(116) = 
140023570  {
140023570      uint32_t beginAddress = 0x6075
140023574      uint32_t endAddress = 0x60ec
140023578      uint32_t unwindInformation = 0x25580
14002357c  }
14002357c  struct Exception_Directory_Entry __exception_directory_entries(117) = 
14002357c  {
14002357c      uint32_t beginAddress = 0x60ec
140023580      uint32_t endAddress = 0x628c
140023584      uint32_t unwindInformation = 0x2558c
140023588  }
140023588  struct Exception_Directory_Entry __exception_directory_entries(118) = 
140023588  {
140023588      uint32_t beginAddress = 0x628c
14002358c      uint32_t endAddress = 0x6317
140023590      uint32_t unwindInformation = 0x25598
140023594  }
140023594  struct Exception_Directory_Entry __exception_directory_entries(119) = 
140023594  {
140023594      uint32_t beginAddress = 0x6317
140023598      uint32_t endAddress = 0x6390
14002359c      uint32_t unwindInformation = 0x255a4
1400235a0  }
1400235a0  struct Exception_Directory_Entry __exception_directory_entries(120) = 
1400235a0  {
1400235a0      uint32_t beginAddress = 0x6390
1400235a4      uint32_t endAddress = 0x651c
1400235a8      uint32_t unwindInformation = 0x255b0
1400235ac  }
1400235ac  struct Exception_Directory_Entry __exception_directory_entries(121) = 
1400235ac  {
1400235ac      uint32_t beginAddress = 0x651c
1400235b0      uint32_t endAddress = 0x67a4
1400235b4      uint32_t unwindInformation = 0x255bc
1400235b8  }
1400235b8  struct Exception_Directory_Entry __exception_directory_entries(122) = 
1400235b8  {
1400235b8      uint32_t beginAddress = 0x67a4
1400235bc      uint32_t endAddress = 0x681c
1400235c0      uint32_t unwindInformation = 0x255c8
1400235c4  }
1400235c4  struct Exception_Directory_Entry __exception_directory_entries(123) = 
1400235c4  {
1400235c4      uint32_t beginAddress = 0x681c
1400235c8      uint32_t endAddress = 0x687d
1400235cc      uint32_t unwindInformation = 0x255d4
1400235d0  }
1400235d0  struct Exception_Directory_Entry __exception_directory_entries(124) = 
1400235d0  {
1400235d0      uint32_t beginAddress = 0x687d
1400235d4      uint32_t endAddress = 0x69c8
1400235d8      uint32_t unwindInformation = 0x255e0
1400235dc  }
1400235dc  struct Exception_Directory_Entry __exception_directory_entries(125) = 
1400235dc  {
1400235dc      uint32_t beginAddress = 0x69c8
1400235e0      uint32_t endAddress = 0x6a6c
1400235e4      uint32_t unwindInformation = 0x255ec
1400235e8  }
1400235e8  struct Exception_Directory_Entry __exception_directory_entries(126) = 
1400235e8  {
1400235e8      uint32_t beginAddress = 0x6a6c
1400235ec      uint32_t endAddress = 0x6b7d
1400235f0      uint32_t unwindInformation = 0x255f8
1400235f4  }
1400235f4  struct Exception_Directory_Entry __exception_directory_entries(127) = 
1400235f4  {
1400235f4      uint32_t beginAddress = 0x6b7d
1400235f8      uint32_t endAddress = 0x6c6e
1400235fc      uint32_t unwindInformation = 0x25604
140023600  }
140023600  struct Exception_Directory_Entry __exception_directory_entries(128) = 
140023600  {
140023600      uint32_t beginAddress = 0x6c6e
140023604      uint32_t endAddress = 0x6d0c
140023608      uint32_t unwindInformation = 0x25610
14002360c  }
14002360c  struct Exception_Directory_Entry __exception_directory_entries(129) = 
14002360c  {
14002360c      uint32_t beginAddress = 0x6d0c
140023610      uint32_t endAddress = 0x6dca
140023614      uint32_t unwindInformation = 0x2561c
140023618  }
140023618  struct Exception_Directory_Entry __exception_directory_entries(130) = 
140023618  {
140023618      uint32_t beginAddress = 0x6dca
14002361c      uint32_t endAddress = 0x6e9b
140023620      uint32_t unwindInformation = 0x25628
140023624  }
140023624  struct Exception_Directory_Entry __exception_directory_entries(131) = 
140023624  {
140023624      uint32_t beginAddress = 0x6e9b
140023628      uint32_t endAddress = 0x6f01
14002362c      uint32_t unwindInformation = 0x25634
140023630  }
140023630  struct Exception_Directory_Entry __exception_directory_entries(132) = 
140023630  {
140023630      uint32_t beginAddress = 0x6f01
140023634      uint32_t endAddress = 0x6f68
140023638      uint32_t unwindInformation = 0x25640
14002363c  }
14002363c  struct Exception_Directory_Entry __exception_directory_entries(133) = 
14002363c  {
14002363c      uint32_t beginAddress = 0x6f68
140023640      uint32_t endAddress = 0x7175
140023644      uint32_t unwindInformation = 0x2564c
140023648  }
140023648  struct Exception_Directory_Entry __exception_directory_entries(134) = 
140023648  {
140023648      uint32_t beginAddress = 0x7175
14002364c      uint32_t endAddress = 0x7634
140023650      uint32_t unwindInformation = 0x25658
140023654  }
140023654  struct Exception_Directory_Entry __exception_directory_entries(135) = 
140023654  {
140023654      uint32_t beginAddress = 0x7634
140023658      uint32_t endAddress = 0x76ec
14002365c      uint32_t unwindInformation = 0x25664
140023660  }
140023660  struct Exception_Directory_Entry __exception_directory_entries(136) = 
140023660  {
140023660      uint32_t beginAddress = 0x76ec
140023664      uint32_t endAddress = 0x77c6
140023668      uint32_t unwindInformation = 0x25670
14002366c  }
14002366c  struct Exception_Directory_Entry __exception_directory_entries(137) = 
14002366c  {
14002366c      uint32_t beginAddress = 0x77c6
140023670      uint32_t endAddress = 0x78f8
140023674      uint32_t unwindInformation = 0x2567c
140023678  }
140023678  struct Exception_Directory_Entry __exception_directory_entries(138) = 
140023678  {
140023678      uint32_t beginAddress = 0x78f8
14002367c      uint32_t endAddress = 0x7a3f
140023680      uint32_t unwindInformation = 0x25688
140023684  }
140023684  struct Exception_Directory_Entry __exception_directory_entries(139) = 
140023684  {
140023684      uint32_t beginAddress = 0x7a3f
140023688      uint32_t endAddress = 0x7f75
14002368c      uint32_t unwindInformation = 0x25694
140023690  }
140023690  struct Exception_Directory_Entry __exception_directory_entries(140) = 
140023690  {
140023690      uint32_t beginAddress = 0x7f75
140023694      uint32_t endAddress = 0x7fe0
140023698      uint32_t unwindInformation = 0x256a0
14002369c  }
14002369c  struct Exception_Directory_Entry __exception_directory_entries(141) = 
14002369c  {
14002369c      uint32_t beginAddress = 0x7fe0
1400236a0      uint32_t endAddress = 0x8018
1400236a4      uint32_t unwindInformation = 0x256ac
1400236a8  }
1400236a8  struct Exception_Directory_Entry __exception_directory_entries(142) = 
1400236a8  {
1400236a8      uint32_t beginAddress = 0x8018
1400236ac      uint32_t endAddress = 0x803e
1400236b0      uint32_t unwindInformation = 0x256b8
1400236b4  }
1400236b4  struct Exception_Directory_Entry __exception_directory_entries(143) = 
1400236b4  {
1400236b4      uint32_t beginAddress = 0x803e
1400236b8      uint32_t endAddress = 0x806f
1400236bc      uint32_t unwindInformation = 0x256c4
1400236c0  }
1400236c0  struct Exception_Directory_Entry __exception_directory_entries(144) = 
1400236c0  {
1400236c0      uint32_t beginAddress = 0x806f
1400236c4      uint32_t endAddress = 0x815c
1400236c8      uint32_t unwindInformation = 0x256d0
1400236cc  }
1400236cc  struct Exception_Directory_Entry __exception_directory_entries(145) = 
1400236cc  {
1400236cc      uint32_t beginAddress = 0x815c
1400236d0      uint32_t endAddress = 0x820f
1400236d4      uint32_t unwindInformation = 0x256dc
1400236d8  }
1400236d8  struct Exception_Directory_Entry __exception_directory_entries(146) = 
1400236d8  {
1400236d8      uint32_t beginAddress = 0x820f
1400236dc      uint32_t endAddress = 0x8302
1400236e0      uint32_t unwindInformation = 0x256e8
1400236e4  }
1400236e4  struct Exception_Directory_Entry __exception_directory_entries(147) = 
1400236e4  {
1400236e4      uint32_t beginAddress = 0x8302
1400236e8      uint32_t endAddress = 0x86cc
1400236ec      uint32_t unwindInformation = 0x256f4
1400236f0  }
1400236f0  struct Exception_Directory_Entry __exception_directory_entries(148) = 
1400236f0  {
1400236f0      uint32_t beginAddress = 0x86cc
1400236f4      uint32_t endAddress = 0x8730
1400236f8      uint32_t unwindInformation = 0x25700
1400236fc  }
1400236fc  struct Exception_Directory_Entry __exception_directory_entries(149) = 
1400236fc  {
1400236fc      uint32_t beginAddress = 0x8730
140023700      uint32_t endAddress = 0x885e
140023704      uint32_t unwindInformation = 0x2570c
140023708  }
140023708  struct Exception_Directory_Entry __exception_directory_entries(150) = 
140023708  {
140023708      uint32_t beginAddress = 0x885e
14002370c      uint32_t endAddress = 0x88a1
140023710      uint32_t unwindInformation = 0x25718
140023714  }
140023714  struct Exception_Directory_Entry __exception_directory_entries(151) = 
140023714  {
140023714      uint32_t beginAddress = 0x88a1
140023718      uint32_t endAddress = 0x88cf
14002371c      uint32_t unwindInformation = 0x25724
140023720  }
140023720  struct Exception_Directory_Entry __exception_directory_entries(152) = 
140023720  {
140023720      uint32_t beginAddress = 0x88cf
140023724      uint32_t endAddress = 0x8a1e
140023728      uint32_t unwindInformation = 0x25730
14002372c  }
14002372c  struct Exception_Directory_Entry __exception_directory_entries(153) = 
14002372c  {
14002372c      uint32_t beginAddress = 0x8a1e
140023730      uint32_t endAddress = 0x8b39
140023734      uint32_t unwindInformation = 0x2573c
140023738  }
140023738  struct Exception_Directory_Entry __exception_directory_entries(154) = 
140023738  {
140023738      uint32_t beginAddress = 0x8b39
14002373c      uint32_t endAddress = 0x8c1b
140023740      uint32_t unwindInformation = 0x25748
140023744  }
140023744  struct Exception_Directory_Entry __exception_directory_entries(155) = 
140023744  {
140023744      uint32_t beginAddress = 0x8c1b
140023748      uint32_t endAddress = 0x8d0f
14002374c      uint32_t unwindInformation = 0x25754
140023750  }
140023750  struct Exception_Directory_Entry __exception_directory_entries(156) = 
140023750  {
140023750      uint32_t beginAddress = 0x8d0f
140023754      uint32_t endAddress = 0x8e1d
140023758      uint32_t unwindInformation = 0x25760
14002375c  }
14002375c  struct Exception_Directory_Entry __exception_directory_entries(157) = 
14002375c  {
14002375c      uint32_t beginAddress = 0x8e1d
140023760      uint32_t endAddress = 0x9256
140023764      uint32_t unwindInformation = 0x2576c
140023768  }
140023768  struct Exception_Directory_Entry __exception_directory_entries(158) = 
140023768  {
140023768      uint32_t beginAddress = 0x9256
14002376c      uint32_t endAddress = 0x945a
140023770      uint32_t unwindInformation = 0x25778
140023774  }
140023774  struct Exception_Directory_Entry __exception_directory_entries(159) = 
140023774  {
140023774      uint32_t beginAddress = 0x945a
140023778      uint32_t endAddress = 0x96c8
14002377c      uint32_t unwindInformation = 0x25784
140023780  }
140023780  struct Exception_Directory_Entry __exception_directory_entries(160) = 
140023780  {
140023780      uint32_t beginAddress = 0x96c8
140023784      uint32_t endAddress = 0x9954
140023788      uint32_t unwindInformation = 0x25790
14002378c  }
14002378c  struct Exception_Directory_Entry __exception_directory_entries(161) = 
14002378c  {
14002378c      uint32_t beginAddress = 0x9954
140023790      uint32_t endAddress = 0x9985
140023794      uint32_t unwindInformation = 0x2579c
140023798  }
140023798  struct Exception_Directory_Entry __exception_directory_entries(162) = 
140023798  {
140023798      uint32_t beginAddress = 0x9985
14002379c      uint32_t endAddress = 0x99a4
1400237a0      uint32_t unwindInformation = 0x257a8
1400237a4  }
1400237a4  struct Exception_Directory_Entry __exception_directory_entries(163) = 
1400237a4  {
1400237a4      uint32_t beginAddress = 0x99a4
1400237a8      uint32_t endAddress = 0x99c3
1400237ac      uint32_t unwindInformation = 0x257b4
1400237b0  }
1400237b0  struct Exception_Directory_Entry __exception_directory_entries(164) = 
1400237b0  {
1400237b0      uint32_t beginAddress = 0x99c3
1400237b4      uint32_t endAddress = 0x9a41
1400237b8      uint32_t unwindInformation = 0x257c0
1400237bc  }
1400237bc  struct Exception_Directory_Entry __exception_directory_entries(165) = 
1400237bc  {
1400237bc      uint32_t beginAddress = 0x9a41
1400237c0      uint32_t endAddress = 0x9b0f
1400237c4      uint32_t unwindInformation = 0x257cc
1400237c8  }
1400237c8  struct Exception_Directory_Entry __exception_directory_entries(166) = 
1400237c8  {
1400237c8      uint32_t beginAddress = 0x9b0f
1400237cc      uint32_t endAddress = 0x9c1d
1400237d0      uint32_t unwindInformation = 0x257d8
1400237d4  }
1400237d4  struct Exception_Directory_Entry __exception_directory_entries(167) = 
1400237d4  {
1400237d4      uint32_t beginAddress = 0x9c1d
1400237d8      uint32_t endAddress = 0x9cdb
1400237dc      uint32_t unwindInformation = 0x257e4
1400237e0  }
1400237e0  struct Exception_Directory_Entry __exception_directory_entries(168) = 
1400237e0  {
1400237e0      uint32_t beginAddress = 0x9cdb
1400237e4      uint32_t endAddress = 0xa3f8
1400237e8      uint32_t unwindInformation = 0x257f0
1400237ec  }
1400237ec  struct Exception_Directory_Entry __exception_directory_entries(169) = 
1400237ec  {
1400237ec      uint32_t beginAddress = 0xa3f8
1400237f0      uint32_t endAddress = 0xa4b6
1400237f4      uint32_t unwindInformation = 0x257fc
1400237f8  }
1400237f8  struct Exception_Directory_Entry __exception_directory_entries(170) = 
1400237f8  {
1400237f8      uint32_t beginAddress = 0xa4b6
1400237fc      uint32_t endAddress = 0xa80d
140023800      uint32_t unwindInformation = 0x25808
140023804  }
140023804  struct Exception_Directory_Entry __exception_directory_entries(171) = 
140023804  {
140023804      uint32_t beginAddress = 0xa80d
140023808      uint32_t endAddress = 0xa998
14002380c      uint32_t unwindInformation = 0x25818
140023810  }
140023810  struct Exception_Directory_Entry __exception_directory_entries(172) = 
140023810  {
140023810      uint32_t beginAddress = 0xa998
140023814      uint32_t endAddress = 0xaad0
140023818      uint32_t unwindInformation = 0x25824
14002381c  }
14002381c  struct Exception_Directory_Entry __exception_directory_entries(173) = 
14002381c  {
14002381c      uint32_t beginAddress = 0xaad0
140023820      uint32_t endAddress = 0xab8e
140023824      uint32_t unwindInformation = 0x25830
140023828  }
140023828  struct Exception_Directory_Entry __exception_directory_entries(174) = 
140023828  {
140023828      uint32_t beginAddress = 0xab8e
14002382c      uint32_t endAddress = 0xabe9
140023830      uint32_t unwindInformation = 0x2583c
140023834  }
140023834  struct Exception_Directory_Entry __exception_directory_entries(175) = 
140023834  {
140023834      uint32_t beginAddress = 0xabe9
140023838      uint32_t endAddress = 0xad38
14002383c      uint32_t unwindInformation = 0x25848
140023840  }
140023840  struct Exception_Directory_Entry __exception_directory_entries(176) = 
140023840  {
140023840      uint32_t beginAddress = 0xad38
140023844      uint32_t endAddress = 0xb08a
140023848      uint32_t unwindInformation = 0x25854
14002384c  }
14002384c  struct Exception_Directory_Entry __exception_directory_entries(177) = 
14002384c  {
14002384c      uint32_t beginAddress = 0xb08a
140023850      uint32_t endAddress = 0xb0f9
140023854      uint32_t unwindInformation = 0x25860
140023858  }
140023858  struct Exception_Directory_Entry __exception_directory_entries(178) = 
140023858  {
140023858      uint32_t beginAddress = 0xb0f9
14002385c      uint32_t endAddress = 0xb169
140023860      uint32_t unwindInformation = 0x2586c
140023864  }
140023864  struct Exception_Directory_Entry __exception_directory_entries(179) = 
140023864  {
140023864      uint32_t beginAddress = 0xb169
140023868      uint32_t endAddress = 0xb183
14002386c      uint32_t unwindInformation = 0x25878
140023870  }
140023870  struct Exception_Directory_Entry __exception_directory_entries(180) = 
140023870  {
140023870      uint32_t beginAddress = 0xb183
140023874      uint32_t endAddress = 0xb384
140023878      uint32_t unwindInformation = 0x25880
14002387c  }
14002387c  struct Exception_Directory_Entry __exception_directory_entries(181) = 
14002387c  {
14002387c      uint32_t beginAddress = 0xb384
140023880      uint32_t endAddress = 0xb4c6
140023884      uint32_t unwindInformation = 0x2588c
140023888  }
140023888  struct Exception_Directory_Entry __exception_directory_entries(182) = 
140023888  {
140023888      uint32_t beginAddress = 0xb4c6
14002388c      uint32_t endAddress = 0xb57f
140023890      uint32_t unwindInformation = 0x25898
140023894  }
140023894  struct Exception_Directory_Entry __exception_directory_entries(183) = 
140023894  {
140023894      uint32_t beginAddress = 0xb57f
140023898      uint32_t endAddress = 0xb5fa
14002389c      uint32_t unwindInformation = 0x258a4
1400238a0  }
1400238a0  struct Exception_Directory_Entry __exception_directory_entries(184) = 
1400238a0  {
1400238a0      uint32_t beginAddress = 0xb5fa
1400238a4      uint32_t endAddress = 0xbabc
1400238a8      uint32_t unwindInformation = 0x258b0
1400238ac  }
1400238ac  struct Exception_Directory_Entry __exception_directory_entries(185) = 
1400238ac  {
1400238ac      uint32_t beginAddress = 0xbabc
1400238b0      uint32_t endAddress = 0xbc97
1400238b4      uint32_t unwindInformation = 0x258bc
1400238b8  }
1400238b8  struct Exception_Directory_Entry __exception_directory_entries(186) = 
1400238b8  {
1400238b8      uint32_t beginAddress = 0xbc97
1400238bc      uint32_t endAddress = 0xbccf
1400238c0      uint32_t unwindInformation = 0x258c8
1400238c4  }
1400238c4  struct Exception_Directory_Entry __exception_directory_entries(187) = 
1400238c4  {
1400238c4      uint32_t beginAddress = 0xbccf
1400238c8      uint32_t endAddress = 0xbd64
1400238cc      uint32_t unwindInformation = 0x258d4
1400238d0  }
1400238d0  struct Exception_Directory_Entry __exception_directory_entries(188) = 
1400238d0  {
1400238d0      uint32_t beginAddress = 0xbd64
1400238d4      uint32_t endAddress = 0xbeef
1400238d8      uint32_t unwindInformation = 0x258e0
1400238dc  }
1400238dc  struct Exception_Directory_Entry __exception_directory_entries(189) = 
1400238dc  {
1400238dc      uint32_t beginAddress = 0xbeef
1400238e0      uint32_t endAddress = 0xbf20
1400238e4      uint32_t unwindInformation = 0x258ec
1400238e8  }
1400238e8  struct Exception_Directory_Entry __exception_directory_entries(190) = 
1400238e8  {
1400238e8      uint32_t beginAddress = 0xbf20
1400238ec      uint32_t endAddress = 0xc087
1400238f0      uint32_t unwindInformation = 0x258f8
1400238f4  }
1400238f4  struct Exception_Directory_Entry __exception_directory_entries(191) = 
1400238f4  {
1400238f4      uint32_t beginAddress = 0xc087
1400238f8      uint32_t endAddress = 0xc16f
1400238fc      uint32_t unwindInformation = 0x25904
140023900  }
140023900  struct Exception_Directory_Entry __exception_directory_entries(192) = 
140023900  {
140023900      uint32_t beginAddress = 0xc16f
140023904      uint32_t endAddress = 0xc2c6
140023908      uint32_t unwindInformation = 0x25910
14002390c  }
14002390c  struct Exception_Directory_Entry __exception_directory_entries(193) = 
14002390c  {
14002390c      uint32_t beginAddress = 0xc2c6
140023910      uint32_t endAddress = 0xc33f
140023914      uint32_t unwindInformation = 0x2591c
140023918  }
140023918  struct Exception_Directory_Entry __exception_directory_entries(194) = 
140023918  {
140023918      uint32_t beginAddress = 0xc33f
14002391c      uint32_t endAddress = 0xc399
140023920      uint32_t unwindInformation = 0x25928
140023924  }
140023924  struct Exception_Directory_Entry __exception_directory_entries(195) = 
140023924  {
140023924      uint32_t beginAddress = 0xc399
140023928      uint32_t endAddress = 0xc3ea
14002392c      uint32_t unwindInformation = 0x25934
140023930  }
140023930  struct Exception_Directory_Entry __exception_directory_entries(196) = 
140023930  {
140023930      uint32_t beginAddress = 0xc3ea
140023934      uint32_t endAddress = 0xc49e
140023938      uint32_t unwindInformation = 0x25940
14002393c  }
14002393c  struct Exception_Directory_Entry __exception_directory_entries(197) = 
14002393c  {
14002393c      uint32_t beginAddress = 0xc49e
140023940      uint32_t endAddress = 0xc5e6
140023944      uint32_t unwindInformation = 0x2594c
140023948  }
140023948  struct Exception_Directory_Entry __exception_directory_entries(198) = 
140023948  {
140023948      uint32_t beginAddress = 0xc5e6
14002394c      uint32_t endAddress = 0xc729
140023950      uint32_t unwindInformation = 0x2595c
140023954  }
140023954  struct Exception_Directory_Entry __exception_directory_entries(199) = 
140023954  {
140023954      uint32_t beginAddress = 0xc729
140023958      uint32_t endAddress = 0xc75a
14002395c      uint32_t unwindInformation = 0x2596c
140023960  }
140023960  struct Exception_Directory_Entry __exception_directory_entries(200) = 
140023960  {
140023960      uint32_t beginAddress = 0xc75a
140023964      uint32_t endAddress = 0xc886
140023968      uint32_t unwindInformation = 0x25978
14002396c  }
14002396c  struct Exception_Directory_Entry __exception_directory_entries(201) = 
14002396c  {
14002396c      uint32_t beginAddress = 0xc886
140023970      uint32_t endAddress = 0xc8bc
140023974      uint32_t unwindInformation = 0x25984
140023978  }
140023978  struct Exception_Directory_Entry __exception_directory_entries(202) = 
140023978  {
140023978      uint32_t beginAddress = 0xc8bc
14002397c      uint32_t endAddress = 0xcabd
140023980      uint32_t unwindInformation = 0x25990
140023984  }
140023984  struct Exception_Directory_Entry __exception_directory_entries(203) = 
140023984  {
140023984      uint32_t beginAddress = 0xcabd
140023988      uint32_t endAddress = 0xcc4a
14002398c      uint32_t unwindInformation = 0x2599c
140023990  }
140023990  struct Exception_Directory_Entry __exception_directory_entries(204) = 
140023990  {
140023990      uint32_t beginAddress = 0xcc4a
140023994      uint32_t endAddress = 0xcd8d
140023998      uint32_t unwindInformation = 0x259a8
14002399c  }
14002399c  struct Exception_Directory_Entry __exception_directory_entries(205) = 
14002399c  {
14002399c      uint32_t beginAddress = 0xcd8d
1400239a0      uint32_t endAddress = 0xd184
1400239a4      uint32_t unwindInformation = 0x259b8
1400239a8  }
1400239a8  struct Exception_Directory_Entry __exception_directory_entries(206) = 
1400239a8  {
1400239a8      uint32_t beginAddress = 0xd184
1400239ac      uint32_t endAddress = 0xd2bc
1400239b0      uint32_t unwindInformation = 0x259c4
1400239b4  }
1400239b4  struct Exception_Directory_Entry __exception_directory_entries(207) = 
1400239b4  {
1400239b4      uint32_t beginAddress = 0xd2bc
1400239b8      uint32_t endAddress = 0xd3e1
1400239bc      uint32_t unwindInformation = 0x259d4
1400239c0  }
1400239c0  struct Exception_Directory_Entry __exception_directory_entries(208) = 
1400239c0  {
1400239c0      uint32_t beginAddress = 0xd3e1
1400239c4      uint32_t endAddress = 0xd6a3
1400239c8      uint32_t unwindInformation = 0x259e0
1400239cc  }
1400239cc  struct Exception_Directory_Entry __exception_directory_entries(209) = 
1400239cc  {
1400239cc      uint32_t beginAddress = 0xd6a3
1400239d0      uint32_t endAddress = 0xd715
1400239d4      uint32_t unwindInformation = 0x259ec
1400239d8  }
1400239d8  struct Exception_Directory_Entry __exception_directory_entries(210) = 
1400239d8  {
1400239d8      uint32_t beginAddress = 0xd715
1400239dc      uint32_t endAddress = 0xd74e
1400239e0      uint32_t unwindInformation = 0x259f8
1400239e4  }
1400239e4  struct Exception_Directory_Entry __exception_directory_entries(211) = 
1400239e4  {
1400239e4      uint32_t beginAddress = 0xd74e
1400239e8      uint32_t endAddress = 0xdc6e
1400239ec      uint32_t unwindInformation = 0x25a04
1400239f0  }
1400239f0  struct Exception_Directory_Entry __exception_directory_entries(212) = 
1400239f0  {
1400239f0      uint32_t beginAddress = 0xdc6e
1400239f4      uint32_t endAddress = 0xdf4e
1400239f8      uint32_t unwindInformation = 0x25a10
1400239fc  }
1400239fc  struct Exception_Directory_Entry __exception_directory_entries(213) = 
1400239fc  {
1400239fc      uint32_t beginAddress = 0xdf4e
140023a00      uint32_t endAddress = 0xe030
140023a04      uint32_t unwindInformation = 0x25a1c
140023a08  }
140023a08  struct Exception_Directory_Entry __exception_directory_entries(214) = 
140023a08  {
140023a08      uint32_t beginAddress = 0xe030
140023a0c      uint32_t endAddress = 0xe0c2
140023a10      uint32_t unwindInformation = 0x25a28
140023a14  }
140023a14  struct Exception_Directory_Entry __exception_directory_entries(215) = 
140023a14  {
140023a14      uint32_t beginAddress = 0xe0c2
140023a18      uint32_t endAddress = 0xe121
140023a1c      uint32_t unwindInformation = 0x25a34
140023a20  }
140023a20  struct Exception_Directory_Entry __exception_directory_entries(216) = 
140023a20  {
140023a20      uint32_t beginAddress = 0xe121
140023a24      uint32_t endAddress = 0xe190
140023a28      uint32_t unwindInformation = 0x25a40
140023a2c  }
140023a2c  struct Exception_Directory_Entry __exception_directory_entries(217) = 
140023a2c  {
140023a2c      uint32_t beginAddress = 0xe190
140023a30      uint32_t endAddress = 0xe742
140023a34      uint32_t unwindInformation = 0x25a4c
140023a38  }
140023a38  struct Exception_Directory_Entry __exception_directory_entries(218) = 
140023a38  {
140023a38      uint32_t beginAddress = 0xe742
140023a3c      uint32_t endAddress = 0xe7fc
140023a40      uint32_t unwindInformation = 0x25a58
140023a44  }
140023a44  struct Exception_Directory_Entry __exception_directory_entries(219) = 
140023a44  {
140023a44      uint32_t beginAddress = 0xe7fc
140023a48      uint32_t endAddress = 0xe9a3
140023a4c      uint32_t unwindInformation = 0x25a64
140023a50  }
140023a50  struct Exception_Directory_Entry __exception_directory_entries(220) = 
140023a50  {
140023a50      uint32_t beginAddress = 0xe9a3
140023a54      uint32_t endAddress = 0xe9f3
140023a58      uint32_t unwindInformation = 0x25a70
140023a5c  }
140023a5c  struct Exception_Directory_Entry __exception_directory_entries(221) = 
140023a5c  {
140023a5c      uint32_t beginAddress = 0xe9f3
140023a60      uint32_t endAddress = 0xeac4
140023a64      uint32_t unwindInformation = 0x25a7c
140023a68  }
140023a68  struct Exception_Directory_Entry __exception_directory_entries(222) = 
140023a68  {
140023a68      uint32_t beginAddress = 0xeac4
140023a6c      uint32_t endAddress = 0xeb4a
140023a70      uint32_t unwindInformation = 0x25a88
140023a74  }
140023a74  struct Exception_Directory_Entry __exception_directory_entries(223) = 
140023a74  {
140023a74      uint32_t beginAddress = 0xeb4a
140023a78      uint32_t endAddress = 0xebfc
140023a7c      uint32_t unwindInformation = 0x25a94
140023a80  }
140023a80  struct Exception_Directory_Entry __exception_directory_entries(224) = 
140023a80  {
140023a80      uint32_t beginAddress = 0xebfc
140023a84      uint32_t endAddress = 0xef56
140023a88      uint32_t unwindInformation = 0x25aa0
140023a8c  }
140023a8c  struct Exception_Directory_Entry __exception_directory_entries(225) = 
140023a8c  {
140023a8c      uint32_t beginAddress = 0xef56
140023a90      uint32_t endAddress = 0xf1e2
140023a94      uint32_t unwindInformation = 0x25ab0
140023a98  }
140023a98  struct Exception_Directory_Entry __exception_directory_entries(226) = 
140023a98  {
140023a98      uint32_t beginAddress = 0xf1e2
140023a9c      uint32_t endAddress = 0xf220
140023aa0      uint32_t unwindInformation = 0x25abc
140023aa4  }
140023aa4  struct Exception_Directory_Entry __exception_directory_entries(227) = 
140023aa4  {
140023aa4      uint32_t beginAddress = 0xf220
140023aa8      uint32_t endAddress = 0xf260
140023aac      uint32_t unwindInformation = 0x25ac8
140023ab0  }
140023ab0  struct Exception_Directory_Entry __exception_directory_entries(228) = 
140023ab0  {
140023ab0      uint32_t beginAddress = 0xf260
140023ab4      uint32_t endAddress = 0xf33e
140023ab8      uint32_t unwindInformation = 0x25ad4
140023abc  }
140023abc  struct Exception_Directory_Entry __exception_directory_entries(229) = 
140023abc  {
140023abc      uint32_t beginAddress = 0xf33e
140023ac0      uint32_t endAddress = 0xf371
140023ac4      uint32_t unwindInformation = 0x25ae0
140023ac8  }
140023ac8  struct Exception_Directory_Entry __exception_directory_entries(230) = 
140023ac8  {
140023ac8      uint32_t beginAddress = 0xf371
140023acc      uint32_t endAddress = 0xf3cd
140023ad0      uint32_t unwindInformation = 0x25aec
140023ad4  }
140023ad4  struct Exception_Directory_Entry __exception_directory_entries(231) = 
140023ad4  {
140023ad4      uint32_t beginAddress = 0xf3cd
140023ad8      uint32_t endAddress = 0xf408
140023adc      uint32_t unwindInformation = 0x25af8
140023ae0  }
140023ae0  struct Exception_Directory_Entry __exception_directory_entries(232) = 
140023ae0  {
140023ae0      uint32_t beginAddress = 0xf408
140023ae4      uint32_t endAddress = 0xf502
140023ae8      uint32_t unwindInformation = 0x25b04
140023aec  }
140023aec  struct Exception_Directory_Entry __exception_directory_entries(233) = 
140023aec  {
140023aec      uint32_t beginAddress = 0xf502
140023af0      uint32_t endAddress = 0xf552
140023af4      uint32_t unwindInformation = 0x25b10
140023af8  }
140023af8  struct Exception_Directory_Entry __exception_directory_entries(234) = 
140023af8  {
140023af8      uint32_t beginAddress = 0xf552
140023afc      uint32_t endAddress = 0xf5fa
140023b00      uint32_t unwindInformation = 0x25b1c
140023b04  }
140023b04  struct Exception_Directory_Entry __exception_directory_entries(235) = 
140023b04  {
140023b04      uint32_t beginAddress = 0xf5fa
140023b08      uint32_t endAddress = 0xf734
140023b0c      uint32_t unwindInformation = 0x25b28
140023b10  }
140023b10  struct Exception_Directory_Entry __exception_directory_entries(236) = 
140023b10  {
140023b10      uint32_t beginAddress = 0xf734
140023b14      uint32_t endAddress = 0xf7c4
140023b18      uint32_t unwindInformation = 0x25b34
140023b1c  }
140023b1c  struct Exception_Directory_Entry __exception_directory_entries(237) = 
140023b1c  {
140023b1c      uint32_t beginAddress = 0xf7c4
140023b20      uint32_t endAddress = 0xf845
140023b24      uint32_t unwindInformation = 0x25b40
140023b28  }
140023b28  struct Exception_Directory_Entry __exception_directory_entries(238) = 
140023b28  {
140023b28      uint32_t beginAddress = 0xf845
140023b2c      uint32_t endAddress = 0xf8b9
140023b30      uint32_t unwindInformation = 0x25b4c
140023b34  }
140023b34  struct Exception_Directory_Entry __exception_directory_entries(239) = 
140023b34  {
140023b34      uint32_t beginAddress = 0xf8b9
140023b38      uint32_t endAddress = 0xfb15
140023b3c      uint32_t unwindInformation = 0x25b58
140023b40  }
140023b40  struct Exception_Directory_Entry __exception_directory_entries(240) = 
140023b40  {
140023b40      uint32_t beginAddress = 0xfb15
140023b44      uint32_t endAddress = 0xfc58
140023b48      uint32_t unwindInformation = 0x25b64
140023b4c  }
140023b4c  struct Exception_Directory_Entry __exception_directory_entries(241) = 
140023b4c  {
140023b4c      uint32_t beginAddress = 0xfc58
140023b50      uint32_t endAddress = 0xfd9d
140023b54      uint32_t unwindInformation = 0x25b74
140023b58  }
140023b58  struct Exception_Directory_Entry __exception_directory_entries(242) = 
140023b58  {
140023b58      uint32_t beginAddress = 0xfd9d
140023b5c      uint32_t endAddress = 0xfe18
140023b60      uint32_t unwindInformation = 0x25b80
140023b64  }
140023b64  struct Exception_Directory_Entry __exception_directory_entries(243) = 
140023b64  {
140023b64      uint32_t beginAddress = 0xfe18
140023b68      uint32_t endAddress = 0xff52
140023b6c      uint32_t unwindInformation = 0x25b8c
140023b70  }
140023b70  struct Exception_Directory_Entry __exception_directory_entries(244) = 
140023b70  {
140023b70      uint32_t beginAddress = 0xff52
140023b74      uint32_t endAddress = 0x10176
140023b78      uint32_t unwindInformation = 0x25b98
140023b7c  }
140023b7c  struct Exception_Directory_Entry __exception_directory_entries(245) = 
140023b7c  {
140023b7c      uint32_t beginAddress = 0x10176
140023b80      uint32_t endAddress = 0x102dd
140023b84      uint32_t unwindInformation = 0x25ba4
140023b88  }
140023b88  struct Exception_Directory_Entry __exception_directory_entries(246) = 
140023b88  {
140023b88      uint32_t beginAddress = 0x102dd
140023b8c      uint32_t endAddress = 0x1035a
140023b90      uint32_t unwindInformation = 0x25bb0
140023b94  }
140023b94  struct Exception_Directory_Entry __exception_directory_entries(247) = 
140023b94  {
140023b94      uint32_t beginAddress = 0x1035a
140023b98      uint32_t endAddress = 0x1054a
140023b9c      uint32_t unwindInformation = 0x25bbc
140023ba0  }
140023ba0  struct Exception_Directory_Entry __exception_directory_entries(248) = 
140023ba0  {
140023ba0      uint32_t beginAddress = 0x1054a
140023ba4      uint32_t endAddress = 0x105f9
140023ba8      uint32_t unwindInformation = 0x25bc8
140023bac  }
140023bac  struct Exception_Directory_Entry __exception_directory_entries(249) = 
140023bac  {
140023bac      uint32_t beginAddress = 0x105f9
140023bb0      uint32_t endAddress = 0x10650
140023bb4      uint32_t unwindInformation = 0x25bd4
140023bb8  }
140023bb8  struct Exception_Directory_Entry __exception_directory_entries(250) = 
140023bb8  {
140023bb8      uint32_t beginAddress = 0x10650
140023bbc      uint32_t endAddress = 0x1077d
140023bc0      uint32_t unwindInformation = 0x25be0
140023bc4  }
140023bc4  struct Exception_Directory_Entry __exception_directory_entries(251) = 
140023bc4  {
140023bc4      uint32_t beginAddress = 0x1077d
140023bc8      uint32_t endAddress = 0x108de
140023bcc      uint32_t unwindInformation = 0x25bec
140023bd0  }
140023bd0  struct Exception_Directory_Entry __exception_directory_entries(252) = 
140023bd0  {
140023bd0      uint32_t beginAddress = 0x108de
140023bd4      uint32_t endAddress = 0x10a21
140023bd8      uint32_t unwindInformation = 0x25bf8
140023bdc  }
140023bdc  struct Exception_Directory_Entry __exception_directory_entries(253) = 
140023bdc  {
140023bdc      uint32_t beginAddress = 0x10a21
140023be0      uint32_t endAddress = 0x10a52
140023be4      uint32_t unwindInformation = 0x25c08
140023be8  }
140023be8  struct Exception_Directory_Entry __exception_directory_entries(254) = 
140023be8  {
140023be8      uint32_t beginAddress = 0x10a52
140023bec      uint32_t endAddress = 0x10a8f
140023bf0      uint32_t unwindInformation = 0x25c14
140023bf4  }
140023bf4  struct Exception_Directory_Entry __exception_directory_entries(255) = 
140023bf4  {
140023bf4      uint32_t beginAddress = 0x10a8f
140023bf8      uint32_t endAddress = 0x10bc8
140023bfc      uint32_t unwindInformation = 0x25c20
140023c00  }
140023c00  struct Exception_Directory_Entry __exception_directory_entries(256) = 
140023c00  {
140023c00      uint32_t beginAddress = 0x10bc8
140023c04      uint32_t endAddress = 0x10ec2
140023c08      uint32_t unwindInformation = 0x25c30
140023c0c  }
140023c0c  struct Exception_Directory_Entry __exception_directory_entries(257) = 
140023c0c  {
140023c0c      uint32_t beginAddress = 0x10ec2
140023c10      uint32_t endAddress = 0x110c2
140023c14      uint32_t unwindInformation = 0x25c40
140023c18  }
140023c18  struct Exception_Directory_Entry __exception_directory_entries(258) = 
140023c18  {
140023c18      uint32_t beginAddress = 0x110c2
140023c1c      uint32_t endAddress = 0x11157
140023c20      uint32_t unwindInformation = 0x25c4c
140023c24  }
140023c24  struct Exception_Directory_Entry __exception_directory_entries(259) = 
140023c24  {
140023c24      uint32_t beginAddress = 0x11157
140023c28      uint32_t endAddress = 0x11192
140023c2c      uint32_t unwindInformation = 0x25c58
140023c30  }

140023c30  _.pdata:
140023c30                                                  a0 11 01 00 49 12 01 00 64 5c 02 00                              ....I...d\..

140023c3c  struct Exception_Directory_Entry __exception_directory_entries(261) = 
140023c3c  {
140023c3c      uint32_t beginAddress = 0x11249
140023c40      uint32_t endAddress = 0x112fd
140023c44      uint32_t unwindInformation = 0x25c70
140023c48  }

140023c48  _.pdata:
140023c48                          00 13 01 00 4b 13 01 00 7c 5c 02 00                                              ....K...|\..

140023c54  struct Exception_Directory_Entry __exception_directory_entries(263) = 
140023c54  {
140023c54      uint32_t beginAddress = 0x1134b
140023c58      uint32_t endAddress = 0x113db
140023c5c      uint32_t unwindInformation = 0x25c88
140023c60  }
140023c60  struct Exception_Directory_Entry __exception_directory_entries(264) = 
140023c60  {
140023c60      uint32_t beginAddress = 0x113db
140023c64      uint32_t endAddress = 0x11402
140023c68      uint32_t unwindInformation = 0x25c94
140023c6c  }
140023c6c  struct Exception_Directory_Entry __exception_directory_entries(265) = 
140023c6c  {
140023c6c      uint32_t beginAddress = 0x11402
140023c70      uint32_t endAddress = 0x114bc
140023c74      uint32_t unwindInformation = 0x25ca0
140023c78  }
140023c78  struct Exception_Directory_Entry __exception_directory_entries(266) = 
140023c78  {
140023c78      uint32_t beginAddress = 0x114bc
140023c7c      uint32_t endAddress = 0x1153b
140023c80      uint32_t unwindInformation = 0x25cb0
140023c84  }

140023c84  _.pdata:
140023c84              40 15 01 00 65 15 01 00 bc 5c 02 00                                                      @...e....\..

140023c90  struct Exception_Directory_Entry __exception_directory_entries(268) = 
140023c90  {
140023c90      uint32_t beginAddress = 0x11565
140023c94      uint32_t endAddress = 0x115f5
140023c98      uint32_t unwindInformation = 0x25cc8
140023c9c  }
140023c9c  struct Exception_Directory_Entry __exception_directory_entries(269) = 
140023c9c  {
140023c9c      uint32_t beginAddress = 0x115f5
140023ca0      uint32_t endAddress = 0x1161c
140023ca4      uint32_t unwindInformation = 0x25cd4
140023ca8  }
140023ca8  struct Exception_Directory_Entry __exception_directory_entries(270) = 
140023ca8  {
140023ca8      uint32_t beginAddress = 0x1161c
140023cac      uint32_t endAddress = 0x1168f
140023cb0      uint32_t unwindInformation = 0x25ce0
140023cb4  }
140023cb4  struct Exception_Directory_Entry __exception_directory_entries(271) = 
140023cb4  {
140023cb4      uint32_t beginAddress = 0x1168f
140023cb8      uint32_t endAddress = 0x11795
140023cbc      uint32_t unwindInformation = 0x25cec
140023cc0  }
140023cc0  struct Exception_Directory_Entry __exception_directory_entries(272) = 
140023cc0  {
140023cc0      uint32_t beginAddress = 0x11795
140023cc4      uint32_t endAddress = 0x11818
140023cc8      uint32_t unwindInformation = 0x25cf8
140023ccc  }

140023ccc  _.pdata:
140023ccc                                      20 18 01 00 b0 18 01 00 04 5d 02 00                                       ........]..

140023cd8  struct Exception_Directory_Entry __exception_directory_entries(274) = 
140023cd8  {
140023cd8      uint32_t beginAddress = 0x118b0
140023cdc      uint32_t endAddress = 0x118d7
140023ce0      uint32_t unwindInformation = 0x25d10
140023ce4  }
140023ce4  struct Exception_Directory_Entry __exception_directory_entries(275) = 
140023ce4  {
140023ce4      uint32_t beginAddress = 0x118d7
140023ce8      uint32_t endAddress = 0x1194f
140023cec      uint32_t unwindInformation = 0x25d1c
140023cf0  }
140023cf0  struct Exception_Directory_Entry __exception_directory_entries(276) = 
140023cf0  {
140023cf0      uint32_t beginAddress = 0x1194f
140023cf4      uint32_t endAddress = 0x1198b
140023cf8      uint32_t unwindInformation = 0x25d28
140023cfc  }
140023cfc  struct Exception_Directory_Entry __exception_directory_entries(277) = 
140023cfc  {
140023cfc      uint32_t beginAddress = 0x1198b
140023d00      uint32_t endAddress = 0x119b0
140023d04      uint32_t unwindInformation = 0x25d34
140023d08  }
140023d08  struct Exception_Directory_Entry __exception_directory_entries(278) = 
140023d08  {
140023d08      uint32_t beginAddress = 0x119b0
140023d0c      uint32_t endAddress = 0x119f5
140023d10      uint32_t unwindInformation = 0x25d40
140023d14  }
140023d14  struct Exception_Directory_Entry __exception_directory_entries(279) = 
140023d14  {
140023d14      uint32_t beginAddress = 0x119f5
140023d18      uint32_t endAddress = 0x11a93
140023d1c      uint32_t unwindInformation = 0x25d4c
140023d20  }
140023d20  struct Exception_Directory_Entry __exception_directory_entries(280) = 
140023d20  {
140023d20      uint32_t beginAddress = 0x11a93
140023d24      uint32_t endAddress = 0x11c57
140023d28      uint32_t unwindInformation = 0x25d58
140023d2c  }
140023d2c  struct Exception_Directory_Entry __exception_directory_entries(281) = 
140023d2c  {
140023d2c      uint32_t beginAddress = 0x11c57
140023d30      uint32_t endAddress = 0x11d4d
140023d34      uint32_t unwindInformation = 0x25d64
140023d38  }

140023d38  _.pdata:
140023d38                                                                          50 1d 01 00 c1 1d 01 00                          P.......
140023d40  70 5d 02 00                                                                                      p]..

140023d44  struct Exception_Directory_Entry __exception_directory_entries(283) = 
140023d44  {
140023d44      uint32_t beginAddress = 0x11dc1
140023d48      uint32_t endAddress = 0x11e51
140023d4c      uint32_t unwindInformation = 0x25d7c
140023d50  }
140023d50  struct Exception_Directory_Entry __exception_directory_entries(284) = 
140023d50  {
140023d50      uint32_t beginAddress = 0x11e51
140023d54      uint32_t endAddress = 0x11e78
140023d58      uint32_t unwindInformation = 0x25d88
140023d5c  }
140023d5c  struct Exception_Directory_Entry __exception_directory_entries(285) = 
140023d5c  {
140023d5c      uint32_t beginAddress = 0x11e78
140023d60      uint32_t endAddress = 0x12883
140023d64      uint32_t unwindInformation = 0x25d94
140023d68  }
140023d68  struct Exception_Directory_Entry __exception_directory_entries(286) = 
140023d68  {
140023d68      uint32_t beginAddress = 0x12883
140023d6c      uint32_t endAddress = 0x12b5f
140023d70      uint32_t unwindInformation = 0x25da0
140023d74  }
140023d74  struct Exception_Directory_Entry __exception_directory_entries(287) = 
140023d74  {
140023d74      uint32_t beginAddress = 0x12b5f
140023d78      uint32_t endAddress = 0x12b84
140023d7c      uint32_t unwindInformation = 0x25db0
140023d80  }
140023d80  struct Exception_Directory_Entry __exception_directory_entries(288) = 
140023d80  {
140023d80      uint32_t beginAddress = 0x12b84
140023d84      uint32_t endAddress = 0x12dd3
140023d88      uint32_t unwindInformation = 0x25dbc
140023d8c  }
140023d8c  struct Exception_Directory_Entry __exception_directory_entries(289) = 
140023d8c  {
140023d8c      uint32_t beginAddress = 0x12dd3
140023d90      uint32_t endAddress = 0x12df1
140023d94      uint32_t unwindInformation = 0x25dc8
140023d98  }
140023d98  struct Exception_Directory_Entry __exception_directory_entries(290) = 
140023d98  {
140023d98      uint32_t beginAddress = 0x12df1
140023d9c      uint32_t endAddress = 0x12e14
140023da0      uint32_t unwindInformation = 0x25dd4
140023da4  }
140023da4  struct Exception_Directory_Entry __exception_directory_entries(291) = 
140023da4  {
140023da4      uint32_t beginAddress = 0x12e14
140023da8      uint32_t endAddress = 0x12e28
140023dac      uint32_t unwindInformation = 0x25de0
140023db0  }
140023db0  struct Exception_Directory_Entry __exception_directory_entries(292) = 
140023db0  {
140023db0      uint32_t beginAddress = 0x12e28
140023db4      uint32_t endAddress = 0x12e41
140023db8      uint32_t unwindInformation = 0x25dec
140023dbc  }
140023dbc  struct Exception_Directory_Entry __exception_directory_entries(293) = 
140023dbc  {
140023dbc      uint32_t beginAddress = 0x12e41
140023dc0      uint32_t endAddress = 0x12e8d
140023dc4      uint32_t unwindInformation = 0x25df8
140023dc8  }
140023dc8  struct Exception_Directory_Entry __exception_directory_entries(294) = 
140023dc8  {
140023dc8      uint32_t beginAddress = 0x12e8d
140023dcc      uint32_t endAddress = 0x12f04
140023dd0      uint32_t unwindInformation = 0x25e04
140023dd4  }

140023dd4  _.pdata:
140023dd4                                                              10 2f 01 00 4a 2f 01 00 10 5e 02 00                      ./..J/...^..

140023de0  struct Exception_Directory_Entry __exception_directory_entries(296) = 
140023de0  {
140023de0      uint32_t beginAddress = 0x12f50
140023de4      uint32_t endAddress = 0x12fba
140023de8      uint32_t unwindInformation = 0x25e18
140023dec  }
140023dec  struct Exception_Directory_Entry __exception_directory_entries(297) = 
140023dec  {
140023dec      uint32_t beginAddress = 0x12fc0
140023df0      uint32_t endAddress = 0x12fdf
140023df4      uint32_t unwindInformation = 0x25e24
140023df8  }

140023df8  _.pdata:
140023df8                                                                          e0 2f 01 00 e3 2f 01 00                          ./.../..
140023e00  28 5e 02 00                                                                                      (^..
140023e04  _.pdata:
140023e04              f0 2f 01 00 1f 30 01 00 2c 5e 02 00                                                      ./...0..,^..

140023e10  struct Exception_Directory_Entry __exception_directory_entries(300) = 
140023e10  {
140023e10      uint32_t beginAddress = 0x13020
140023e14      uint32_t endAddress = 0x130a1
140023e18      uint32_t unwindInformation = 0x25e34
140023e1c  }
140023e1c  struct Exception_Directory_Entry __exception_directory_entries(301) = 
140023e1c  {
140023e1c      uint32_t beginAddress = 0x130b0
140023e20      uint32_t endAddress = 0x130b3
140023e24      uint32_t unwindInformation = 0x25e40
140023e28  }

140023e28  _.pdata:
140023e28                          c0 30 01 00 b8 31 01 00 44 5e 02 00                                              .0...1..D^..
140023e34  _.pdata:
140023e34                                                              c0 31 01 00 c3 31 01 00 5c 5e 02 00                      .1...1..\^..
140023e40  _.pdata:
140023e40  d0 31 01 00 39 32 01 00 60 5e 02 00                                                              .1..92..`^..

140023e4c  struct Exception_Directory_Entry __exception_directory_entries(305) = 
140023e4c  {
140023e4c      uint32_t beginAddress = 0x13240
140023e50      uint32_t endAddress = 0x133a2
140023e54      uint32_t unwindInformation = 0x25e6c
140023e58  }
140023e58  struct Exception_Directory_Entry __exception_directory_entries(306) = 
140023e58  {
140023e58      uint32_t beginAddress = 0x133b0
140023e5c      uint32_t endAddress = 0x1370f
140023e60      uint32_t unwindInformation = 0x25e78
140023e64  }

140023e64  _.pdata:
140023e64              10 37 01 00 4e 37 01 00 90 5e 02 00                                                      .7..N7...^..

140023e70  struct Exception_Directory_Entry __exception_directory_entries(308) = 
140023e70  {
140023e70      uint32_t beginAddress = 0x13750
140023e74      uint32_t endAddress = 0x1375c
140023e78      uint32_t unwindInformation = 0x25e98
140023e7c  }

140023e7c  _.pdata:
140023e7c                                                                                      60 37 01 00                              `7..
140023e80  f8 38 01 00 9c 5e 02 00                                                                          .8...^..
140023e88  _.pdata:
140023e88                          00 39 01 00 70 39 01 00 a4 5e 02 00                                              .9..p9...^..

140023e94  struct Exception_Directory_Entry __exception_directory_entries(311) = 
140023e94  {
140023e94      uint32_t beginAddress = 0x13970
140023e98      uint32_t endAddress = 0x139df
140023e9c      uint32_t unwindInformation = 0x25eb4
140023ea0  }
140023ea0  struct Exception_Directory_Entry __exception_directory_entries(312) = 
140023ea0  {
140023ea0      uint32_t beginAddress = 0x139e0
140023ea4      uint32_t endAddress = 0x13a61
140023ea8      uint32_t unwindInformation = 0x25ec0
140023eac  }
140023eac  struct Exception_Directory_Entry __exception_directory_entries(313) = 
140023eac  {
140023eac      uint32_t beginAddress = 0x13a70
140023eb0      uint32_t endAddress = 0x13b62
140023eb4      uint32_t unwindInformation = 0x25ecc
140023eb8  }

140023eb8  _.pdata:
140023eb8                                                                          70 3b 01 00 7e 3b 01 00                          p;..~;..
140023ec0  d4 5e 02 00                                                                                      .^..

140023ec4  struct Exception_Directory_Entry __exception_directory_entries(315) = 
140023ec4  {
140023ec4      uint32_t beginAddress = 0x13b80
140023ec8      uint32_t endAddress = 0x13b8e
140023ecc      uint32_t unwindInformation = 0x25edc
140023ed0  }

140023ed0  _.pdata:
140023ed0                                                  90 3b 01 00 bc 3b 01 00 e4 5e 02 00                              .;...;...^..

140023edc  struct Exception_Directory_Entry __exception_directory_entries(317) = 
140023edc  {
140023edc      uint32_t beginAddress = 0x13bc0
140023ee0      uint32_t endAddress = 0x13c10
140023ee4      uint32_t unwindInformation = 0x25ee8
140023ee8  }
140023ee8  struct Exception_Directory_Entry __exception_directory_entries(318) = 
140023ee8  {
140023ee8      uint32_t beginAddress = 0x13c10
140023eec      uint32_t endAddress = 0x13cad
140023ef0      uint32_t unwindInformation = 0x25eec
140023ef4  }
140023ef4  struct Exception_Directory_Entry __exception_directory_entries(319) = 
140023ef4  {
140023ef4      uint32_t beginAddress = 0x13cb0
140023ef8      uint32_t endAddress = 0x13d30
140023efc      uint32_t unwindInformation = 0x25ef8
140023f00  }
140023f00  struct Exception_Directory_Entry __exception_directory_entries(320) = 
140023f00  {
140023f00      uint32_t beginAddress = 0x13d30
140023f04      uint32_t endAddress = 0x13d67
140023f08      uint32_t unwindInformation = 0x25efc
140023f0c  }
140023f0c  struct Exception_Directory_Entry __exception_directory_entries(321) = 
140023f0c  {
140023f0c      uint32_t beginAddress = 0x13d70
140023f10      uint32_t endAddress = 0x13de3
140023f14      uint32_t unwindInformation = 0x25f00
140023f18  }
140023f18  struct Exception_Directory_Entry __exception_directory_entries(322) = 
140023f18  {
140023f18      uint32_t beginAddress = 0x13df0
140023f1c      uint32_t endAddress = 0x13e26
140023f20      uint32_t unwindInformation = 0x25f04
140023f24  }
140023f24  struct Exception_Directory_Entry __exception_directory_entries(323) = 
140023f24  {
140023f24      uint32_t beginAddress = 0x13e30
140023f28      uint32_t endAddress = 0x13eb9
140023f2c      uint32_t unwindInformation = 0x25f08
140023f30  }
140023f30  struct Exception_Directory_Entry __exception_directory_entries(324) = 
140023f30  {
140023f30      uint32_t beginAddress = 0x13ec0
140023f34      uint32_t endAddress = 0x13f86
140023f38      uint32_t unwindInformation = 0x25f0c
140023f3c  }

140023f3c  _.pdata:
140023f3c                                                                                      d0 3f 01 00                              .?..
140023f40  13 40 01 00 10 5f 02 00                                                                          .@..._..

140023f48  struct Exception_Directory_Entry __exception_directory_entries(326) = 
140023f48  {
140023f48      uint32_t beginAddress = 0x14020
140023f4c      uint32_t endAddress = 0x14054
140023f50      uint32_t unwindInformation = 0x25f1c
140023f54  }
140023f54  struct Exception_Directory_Entry __exception_directory_entries(327) = 
140023f54  {
140023f54      uint32_t beginAddress = 0x14060
140023f58      uint32_t endAddress = 0x1425d
140023f5c      uint32_t unwindInformation = 0x25f24
140023f60  }
140023f60  struct Exception_Directory_Entry __exception_directory_entries(328) = 
140023f60  {
140023f60      uint32_t beginAddress = 0x14260
140023f64      uint32_t endAddress = 0x1428d
140023f68      uint32_t unwindInformation = 0x25f34
140023f6c  }

140023f6c  _.pdata:
140023f6c                                      90 42 01 00 d1 42 01 00 38 5f 02 00                                      .B...B..8_..
140023f78  _.pdata:
140023f78                                                                          e0 42 01 00 cc 43 01 00                          .B...C..
140023f80  44 5f 02 00                                                                                      D_..

140023f84  struct Exception_Directory_Entry __exception_directory_entries(331) = 
140023f84  {
140023f84      uint32_t beginAddress = 0x143d0
140023f88      uint32_t endAddress = 0x14427
140023f8c      uint32_t unwindInformation = 0x25f4c
140023f90  }
140023f90  struct Exception_Directory_Entry __exception_directory_entries(332) = 
140023f90  {
140023f90      uint32_t beginAddress = 0x14430
140023f94      uint32_t endAddress = 0x145be
140023f98      uint32_t unwindInformation = 0x25f54
140023f9c  }
140023f9c  struct Exception_Directory_Entry __exception_directory_entries(333) = 
140023f9c  {
140023f9c      uint32_t beginAddress = 0x145c0
140023fa0      uint32_t endAddress = 0x14704
140023fa4      uint32_t unwindInformation = 0x25f6c
140023fa8  }
140023fa8  struct Exception_Directory_Entry __exception_directory_entries(334) = 
140023fa8  {
140023fa8      uint32_t beginAddress = 0x14710
140023fac      uint32_t endAddress = 0x14757
140023fb0      uint32_t unwindInformation = 0x25f78
140023fb4  }
140023fb4  struct Exception_Directory_Entry __exception_directory_entries(335) = 
140023fb4  {
140023fb4      uint32_t beginAddress = 0x14760
140023fb8      uint32_t endAddress = 0x147f2
140023fbc      uint32_t unwindInformation = 0x25f84
140023fc0  }
140023fc0  struct Exception_Directory_Entry __exception_directory_entries(336) = 
140023fc0  {
140023fc0      uint32_t beginAddress = 0x14800
140023fc4      uint32_t endAddress = 0x14ca7
140023fc8      uint32_t unwindInformation = 0x25f8c
140023fcc  }
140023fcc  struct Exception_Directory_Entry __exception_directory_entries(337) = 
140023fcc  {
140023fcc      uint32_t beginAddress = 0x14cb0
140023fd0      uint32_t endAddress = 0x15033
140023fd4      uint32_t unwindInformation = 0x25fa4
140023fd8  }
140023fd8  struct Exception_Directory_Entry __exception_directory_entries(338) = 
140023fd8  {
140023fd8      uint32_t beginAddress = 0x15040
140023fdc      uint32_t endAddress = 0x1518e
140023fe0      uint32_t unwindInformation = 0x25fbc
140023fe4  }
140023fe4  struct Exception_Directory_Entry __exception_directory_entries(339) = 
140023fe4  {
140023fe4      uint32_t beginAddress = 0x15190
140023fe8      uint32_t endAddress = 0x15569
140023fec      uint32_t unwindInformation = 0x25fd0
140023ff0  }
140023ff0  struct Exception_Directory_Entry __exception_directory_entries(340) = 
140023ff0  {
140023ff0      uint32_t beginAddress = 0x15570
140023ff4      uint32_t endAddress = 0x1563c
140023ff8      uint32_t unwindInformation = 0x25fe0
140023ffc  }
140023ffc  struct Exception_Directory_Entry __exception_directory_entries(341) = 
140023ffc  {
140023ffc      uint32_t beginAddress = 0x15640
140024000      uint32_t endAddress = 0x156df
140024004      uint32_t unwindInformation = 0x25fec
140024008  }
140024008  struct Exception_Directory_Entry __exception_directory_entries(342) = 
140024008  {
140024008      uint32_t beginAddress = 0x156e0
14002400c      uint32_t endAddress = 0x157bf
140024010      uint32_t unwindInformation = 0x25ff8
140024014  }
140024014  struct Exception_Directory_Entry __exception_directory_entries(343) = 
140024014  {
140024014      uint32_t beginAddress = 0x157c0
140024018      uint32_t endAddress = 0x15938
14002401c      uint32_t unwindInformation = 0x26004
140024020  }
140024020  struct Exception_Directory_Entry __exception_directory_entries(344) = 
140024020  {
140024020      uint32_t beginAddress = 0x15940
140024024      uint32_t endAddress = 0x15deb
140024028      uint32_t unwindInformation = 0x26010
14002402c  }
14002402c  struct Exception_Directory_Entry __exception_directory_entries(345) = 
14002402c  {
14002402c      uint32_t beginAddress = 0x15df0
140024030      uint32_t endAddress = 0x168da
140024034      uint32_t unwindInformation = 0x26024
140024038  }

140024038  _.pdata:
140024038                                                                          e0 68 01 00 17 69 01 00                          .h...i..
140024040  3c 60 02 00                                                                                      <`..

140024044  struct Exception_Directory_Entry __exception_directory_entries(347) = 
140024044  {
140024044      uint32_t beginAddress = 0x16920
140024048      uint32_t endAddress = 0x1699c
14002404c      uint32_t unwindInformation = 0x26044
140024050  }
140024050  struct Exception_Directory_Entry __exception_directory_entries(348) = 
140024050  {
140024050      uint32_t beginAddress = 0x169a0
140024054      uint32_t endAddress = 0x169c7
140024058      uint32_t unwindInformation = 0x26050
14002405c  }
14002405c  struct Exception_Directory_Entry __exception_directory_entries(349) = 
14002405c  {
14002405c      uint32_t beginAddress = 0x169d0
140024060      uint32_t endAddress = 0x16b4d
140024064      uint32_t unwindInformation = 0x26054
140024068  }

140024068  _.pdata:
140024068                          50 6b 01 00 b8 82 01 00 6c 60 02 00                                              Pk......l`..
140024074  _.pdata:
140024074                                                              c0 82 01 00 b2 83 01 00 84 60 02 00                      .........`..

140024080  struct Exception_Directory_Entry __exception_directory_entries(352) = 
140024080  {
140024080      uint32_t beginAddress = 0x183c0
140024084      uint32_t endAddress = 0x183f9
140024088      uint32_t unwindInformation = 0x26094
14002408c  }

14002408c  _.pdata:
14002408c                                      00 84 01 00 d9 84 01 00 98 60 02 00                                      .........`..

140024098  struct Exception_Directory_Entry __exception_directory_entries(354) = 
140024098  {
140024098      uint32_t beginAddress = 0x184e0
14002409c      uint32_t endAddress = 0x18522
1400240a0      uint32_t unwindInformation = 0x260a4
1400240a4  }
1400240a4  struct Exception_Directory_Entry __exception_directory_entries(355) = 
1400240a4  {
1400240a4      uint32_t beginAddress = 0x18530
1400240a8      uint32_t endAddress = 0x1862b
1400240ac      uint32_t unwindInformation = 0x260ac
1400240b0  }
1400240b0  struct Exception_Directory_Entry __exception_directory_entries(356) = 
1400240b0  {
1400240b0      uint32_t beginAddress = 0x18630
1400240b4      uint32_t endAddress = 0x18693
1400240b8      uint32_t unwindInformation = 0x260b8
1400240bc  }
1400240bc  struct Exception_Directory_Entry __exception_directory_entries(357) = 
1400240bc  {
1400240bc      uint32_t beginAddress = 0x186a0
1400240c0      uint32_t endAddress = 0x18759
1400240c4      uint32_t unwindInformation = 0x260c0
1400240c8  }
1400240c8  struct Exception_Directory_Entry __exception_directory_entries(358) = 
1400240c8  {
1400240c8      uint32_t beginAddress = 0x18760
1400240cc      uint32_t endAddress = 0x1881d
1400240d0      uint32_t unwindInformation = 0x260d0
1400240d4  }
1400240d4  struct Exception_Directory_Entry __exception_directory_entries(359) = 
1400240d4  {
1400240d4      uint32_t beginAddress = 0x18820
1400240d8      uint32_t endAddress = 0x18977
1400240dc      uint32_t unwindInformation = 0x260d8
1400240e0  }
1400240e0  struct Exception_Directory_Entry __exception_directory_entries(360) = 
1400240e0  {
1400240e0      uint32_t beginAddress = 0x18980
1400240e4      uint32_t endAddress = 0x18b07
1400240e8      uint32_t unwindInformation = 0x260f0
1400240ec  }
1400240ec  struct Exception_Directory_Entry __exception_directory_entries(361) = 
1400240ec  {
1400240ec      uint32_t beginAddress = 0x18b10
1400240f0      uint32_t endAddress = 0x18c1e
1400240f4      uint32_t unwindInformation = 0x26100
1400240f8  }
1400240f8  struct Exception_Directory_Entry __exception_directory_entries(362) = 
1400240f8  {
1400240f8      uint32_t beginAddress = 0x18c20
1400240fc      uint32_t endAddress = 0x18c68
140024100      uint32_t unwindInformation = 0x26114
140024104  }
140024104  struct Exception_Directory_Entry __exception_directory_entries(363) = 
140024104  {
140024104      uint32_t beginAddress = 0x18c70
140024108      uint32_t endAddress = 0x18e46
14002410c      uint32_t unwindInformation = 0x26118
140024110  }
140024110  struct Exception_Directory_Entry __exception_directory_entries(364) = 
140024110  {
140024110      uint32_t beginAddress = 0x18e50
140024114      uint32_t endAddress = 0x18f5f
140024118      uint32_t unwindInformation = 0x2612c
14002411c  }
14002411c  struct Exception_Directory_Entry __exception_directory_entries(365) = 
14002411c  {
14002411c      uint32_t beginAddress = 0x18f60
140024120      uint32_t endAddress = 0x19062
140024124      uint32_t unwindInformation = 0x26138
140024128  }
140024128  struct Exception_Directory_Entry __exception_directory_entries(366) = 
140024128  {
140024128      uint32_t beginAddress = 0x19070
14002412c      uint32_t endAddress = 0x19092
140024130      uint32_t unwindInformation = 0x26144
140024134  }

140024134  _.pdata:
140024134                                                              a0 90 01 00 c8 90 01 00 48 61 02 00                      ........Ha..
140024140  _.pdata:
140024140  d0 90 01 00 f5 90 01 00 4c 61 02 00                                                              ........La..
14002414c  _.pdata:
14002414c                                      00 91 01 00 1e 91 01 00 50 61 02 00                                      ........Pa..
140024158  _.pdata:
140024158                                                                          20 91 01 00 52 91 01 00                           ...R...
140024160  58 61 02 00                                                                                      Xa..
140024164  _.pdata:
140024164              60 91 01 00 63 91 01 00 60 61 02 00                                                      `...c...`a..

140024170  struct Exception_Directory_Entry __exception_directory_entries(372) = 
140024170  {
140024170      uint32_t beginAddress = 0x19170
140024174      uint32_t endAddress = 0x191da
140024178      uint32_t unwindInformation = 0x26164
14002417c  }
14002417c  struct Exception_Directory_Entry __exception_directory_entries(373) = 
14002417c  {
14002417c      uint32_t beginAddress = 0x191e0
140024180      uint32_t endAddress = 0x1924a
140024184      uint32_t unwindInformation = 0x26174
140024188  }
140024188  struct Exception_Directory_Entry __exception_directory_entries(374) = 
140024188  {
140024188      uint32_t beginAddress = 0x19250
14002418c      uint32_t endAddress = 0x1926e
140024190      uint32_t unwindInformation = 0x26184
140024194  }
140024194  struct Exception_Directory_Entry __exception_directory_entries(375) = 
140024194  {
140024194      uint32_t beginAddress = 0x19270
140024198      uint32_t endAddress = 0x19285
14002419c      uint32_t unwindInformation = 0x2618c
1400241a0  }
1400241a0  struct Exception_Directory_Entry __exception_directory_entries(376) = 
1400241a0  {
1400241a0      uint32_t beginAddress = 0x19290
1400241a4      uint32_t endAddress = 0x192c2
1400241a8      uint32_t unwindInformation = 0x26190
1400241ac  }
1400241ac  struct Exception_Directory_Entry __exception_directory_entries(377) = 
1400241ac  {
1400241ac      uint32_t beginAddress = 0x192d0
1400241b0      uint32_t endAddress = 0x19305
1400241b4      uint32_t unwindInformation = 0x26198
1400241b8  }
1400241b8  struct Exception_Directory_Entry __exception_directory_entries(378) = 
1400241b8  {
1400241b8      uint32_t beginAddress = 0x19310
1400241bc      uint32_t endAddress = 0x19346
1400241c0      uint32_t unwindInformation = 0x261a0
1400241c4  }
1400241c4  struct Exception_Directory_Entry __exception_directory_entries(379) = 
1400241c4  {
1400241c4      uint32_t beginAddress = 0x19350
1400241c8      uint32_t endAddress = 0x19386
1400241cc      uint32_t unwindInformation = 0x261a8
1400241d0  }

1400241d0  _.pdata:
1400241d0                                                  b0 95 01 00 1f 96 01 00 b0 61 02 00                              .........a..

1400241dc  struct Exception_Directory_Entry __exception_directory_entries(381) = 
1400241dc  {
1400241dc      uint32_t beginAddress = 0x19620
1400241e0      uint32_t endAddress = 0x19763
1400241e4      uint32_t unwindInformation = 0x261bc
1400241e8  }
1400241e8  struct Exception_Directory_Entry __exception_directory_entries(382) = 
1400241e8  {
1400241e8      uint32_t beginAddress = 0x19770
1400241ec      uint32_t endAddress = 0x19903
1400241f0      uint32_t unwindInformation = 0x261cc
1400241f4  }
1400241f4  struct Exception_Directory_Entry __exception_directory_entries(383) = 
1400241f4  {
1400241f4      uint32_t beginAddress = 0x19910
1400241f8      uint32_t endAddress = 0x199c6
1400241fc      uint32_t unwindInformation = 0x261dc
140024200  }
140024200  struct Exception_Directory_Entry __exception_directory_entries(384) = 
140024200  {
140024200      uint32_t beginAddress = 0x199d0
140024204      uint32_t endAddress = 0x19a4e
140024208      uint32_t unwindInformation = 0x261e4
14002420c  }
14002420c  struct Exception_Directory_Entry __exception_directory_entries(385) = 
14002420c  {
14002420c      uint32_t beginAddress = 0x19a50
140024210      uint32_t endAddress = 0x19a96
140024214      uint32_t unwindInformation = 0x261f0
140024218  }
140024218  struct Exception_Directory_Entry __exception_directory_entries(386) = 
140024218  {
140024218      uint32_t beginAddress = 0x19aa0
14002421c      uint32_t endAddress = 0x19add
140024220      uint32_t unwindInformation = 0x261f4
140024224  }
140024224  struct Exception_Directory_Entry __exception_directory_entries(387) = 
140024224  {
140024224      uint32_t beginAddress = 0x19ae0
140024228      uint32_t endAddress = 0x19ae9
14002422c      uint32_t unwindInformation = 0x26200
140024230  }
140024230  struct Exception_Directory_Entry __exception_directory_entries(388) = 
140024230  {
140024230      uint32_t beginAddress = 0x19af0
140024234      uint32_t endAddress = 0x19afa
140024238      uint32_t unwindInformation = 0x26204
14002423c  }
14002423c  struct Exception_Directory_Entry __exception_directory_entries(389) = 
14002423c  {
14002423c      uint32_t beginAddress = 0x19b00
140024240      uint32_t endAddress = 0x19b1e
140024244      uint32_t unwindInformation = 0x26208
140024248  }
140024248  struct Exception_Directory_Entry __exception_directory_entries(390) = 
140024248  {
140024248      uint32_t beginAddress = 0x19b20
14002424c      uint32_t endAddress = 0x19b46
140024250      uint32_t unwindInformation = 0x2620c
140024254  }
140024254  struct Exception_Directory_Entry __exception_directory_entries(391) = 
140024254  {
140024254      uint32_t beginAddress = 0x19b50
140024258      uint32_t endAddress = 0x19b76
14002425c      uint32_t unwindInformation = 0x26210
140024260  }
140024260  struct Exception_Directory_Entry __exception_directory_entries(392) = 
140024260  {
140024260      uint32_t beginAddress = 0x19b80
140024264      uint32_t endAddress = 0x19ba6
140024268      uint32_t unwindInformation = 0x26214
14002426c  }
14002426c  struct Exception_Directory_Entry __exception_directory_entries(393) = 
14002426c  {
14002426c      uint32_t beginAddress = 0x19bb0
140024270      uint32_t endAddress = 0x19bba
140024274      uint32_t unwindInformation = 0x26218
140024278  }
140024278  struct Exception_Directory_Entry __exception_directory_entries(394) = 
140024278  {
140024278      uint32_t beginAddress = 0x19bc0
14002427c      uint32_t endAddress = 0x19bde
140024280      uint32_t unwindInformation = 0x2621c
140024284  }
140024284  struct Exception_Directory_Entry __exception_directory_entries(395) = 
140024284  {
140024284      uint32_t beginAddress = 0x19be0
140024288      uint32_t endAddress = 0x19bea
14002428c      uint32_t unwindInformation = 0x26220
140024290  }
140024290  struct Exception_Directory_Entry __exception_directory_entries(396) = 
140024290  {
140024290      uint32_t beginAddress = 0x19bf0
140024294      uint32_t endAddress = 0x19bff
140024298      uint32_t unwindInformation = 0x26224
14002429c  }

14002429c  _.pdata:
14002429c                                                                                      00 9c 01 00                              ....
1400242a0  18 9c 01 00 28 62 02 00                                                                          ....(b..

1400242a8  struct Exception_Directory_Entry __exception_directory_entries(398) = 
1400242a8  {
1400242a8      uint32_t beginAddress = 0x19c20
1400242ac      uint32_t endAddress = 0x19c9c
1400242b0      uint32_t unwindInformation = 0x2622c
1400242b4  }
1400242b4  struct Exception_Directory_Entry __exception_directory_entries(399) = 
1400242b4  {
1400242b4      uint32_t beginAddress = 0x19ca0
1400242b8      uint32_t endAddress = 0x19d52
1400242bc      uint32_t unwindInformation = 0x26230
1400242c0  }
1400242c0  struct Exception_Directory_Entry __exception_directory_entries(400) = 
1400242c0  {
1400242c0      uint32_t beginAddress = 0x19d60
1400242c4      uint32_t endAddress = 0x19f00
1400242c8      uint32_t unwindInformation = 0x2623c
1400242cc  }
1400242cc  struct Exception_Directory_Entry __exception_directory_entries(401) = 
1400242cc  {
1400242cc      uint32_t beginAddress = 0x19f00
1400242d0      uint32_t endAddress = 0x19f1e
1400242d4      uint32_t unwindInformation = 0x2624c
1400242d8  }
1400242d8  struct Exception_Directory_Entry __exception_directory_entries(402) = 
1400242d8  {
1400242d8      uint32_t beginAddress = 0x19f20
1400242dc      uint32_t endAddress = 0x1a03b
1400242e0      uint32_t unwindInformation = 0x26254
1400242e4  }
1400242e4  struct Exception_Directory_Entry __exception_directory_entries(403) = 
1400242e4  {
1400242e4      uint32_t beginAddress = 0x1a040
1400242e8      uint32_t endAddress = 0x1a117
1400242ec      uint32_t unwindInformation = 0x2625c
1400242f0  }
1400242f0  struct Exception_Directory_Entry __exception_directory_entries(404) = 
1400242f0  {
1400242f0      uint32_t beginAddress = 0x1a120
1400242f4      uint32_t endAddress = 0x1a14e
1400242f8      uint32_t unwindInformation = 0x26268
1400242fc  }
1400242fc  struct Exception_Directory_Entry __exception_directory_entries(405) = 
1400242fc  {
1400242fc      uint32_t beginAddress = 0x1a150
140024300      uint32_t endAddress = 0x1a21a
140024304      uint32_t unwindInformation = 0x26270
140024308  }
140024308  struct Exception_Directory_Entry __exception_directory_entries(406) = 
140024308  {
140024308      uint32_t beginAddress = 0x1a220
14002430c      uint32_t endAddress = 0x1a380
140024310      uint32_t unwindInformation = 0x2627c
140024314  }
140024314  struct Exception_Directory_Entry __exception_directory_entries(407) = 
140024314  {
140024314      uint32_t beginAddress = 0x1a380
140024318      uint32_t endAddress = 0x1a395
14002431c      uint32_t unwindInformation = 0x2628c
140024320  }
140024320  struct Exception_Directory_Entry __exception_directory_entries(408) = 
140024320  {
140024320      uint32_t beginAddress = 0x1a3a0
140024324      uint32_t endAddress = 0x1a44f
140024328      uint32_t unwindInformation = 0x26290
14002432c  }
14002432c  struct Exception_Directory_Entry __exception_directory_entries(409) = 
14002432c  {
14002432c      uint32_t beginAddress = 0x1a450
140024330      uint32_t endAddress = 0x1a581
140024334      uint32_t unwindInformation = 0x262a0
140024338  }
140024338  struct Exception_Directory_Entry __exception_directory_entries(410) = 
140024338  {
140024338      uint32_t beginAddress = 0x1a590
14002433c      uint32_t endAddress = 0x1a5b9
140024340      uint32_t unwindInformation = 0x262b0
140024344  }
140024344  struct Exception_Directory_Entry __exception_directory_entries(411) = 
140024344  {
140024344      uint32_t beginAddress = 0x1a5c0
140024348      uint32_t endAddress = 0x1a700
14002434c      uint32_t unwindInformation = 0x262b8
140024350  }
140024350  struct Exception_Directory_Entry __exception_directory_entries(412) = 
140024350  {
140024350      uint32_t beginAddress = 0x1a700
140024354      uint32_t endAddress = 0x1a896
140024358      uint32_t unwindInformation = 0x262d0
14002435c  }
14002435c  struct Exception_Directory_Entry __exception_directory_entries(413) = 
14002435c  {
14002435c      uint32_t beginAddress = 0x1a8a0
140024360      uint32_t endAddress = 0x1aaa5
140024364      uint32_t unwindInformation = 0x262f8
140024368  }
140024368  struct Exception_Directory_Entry __exception_directory_entries(414) = 
140024368  {
140024368      uint32_t beginAddress = 0x1aab0
14002436c      uint32_t endAddress = 0x1aaee
140024370      uint32_t unwindInformation = 0x26308
140024374  }
140024374  struct Exception_Directory_Entry __exception_directory_entries(415) = 
140024374  {
140024374      uint32_t beginAddress = 0x1aaf0
140024378      uint32_t endAddress = 0x1aaf7
14002437c      uint32_t unwindInformation = 0x26314
140024380  }
140024380  struct Exception_Directory_Entry __exception_directory_entries(416) = 
140024380  {
140024380      uint32_t beginAddress = 0x1ab00
140024384      uint32_t endAddress = 0x1ac19
140024388      uint32_t unwindInformation = 0x26318
14002438c  }
14002438c  struct Exception_Directory_Entry __exception_directory_entries(417) = 
14002438c  {
14002438c      uint32_t beginAddress = 0x1ac20
140024390      uint32_t endAddress = 0x1ac23
140024394      uint32_t unwindInformation = 0x2632c
140024398  }
140024398  struct Exception_Directory_Entry __exception_directory_entries(418) = 
140024398  {
140024398      uint32_t beginAddress = 0x1ac30
14002439c      uint32_t endAddress = 0x1ac85
1400243a0      uint32_t unwindInformation = 0x26330
1400243a4  }
1400243a4  struct Exception_Directory_Entry __exception_directory_entries(419) = 
1400243a4  {
1400243a4      uint32_t beginAddress = 0x1ac90
1400243a8      uint32_t endAddress = 0x1ad1e
1400243ac      uint32_t unwindInformation = 0x26338
1400243b0  }
1400243b0  struct Exception_Directory_Entry __exception_directory_entries(420) = 
1400243b0  {
1400243b0      uint32_t beginAddress = 0x1ad20
1400243b4      uint32_t endAddress = 0x1ae9b
1400243b8      uint32_t unwindInformation = 0x26348
1400243bc  }
1400243bc  struct Exception_Directory_Entry __exception_directory_entries(421) = 
1400243bc  {
1400243bc      uint32_t beginAddress = 0x1aea0
1400243c0      uint32_t endAddress = 0x1b016
1400243c4      uint32_t unwindInformation = 0x26358
1400243c8  }
1400243c8  struct Exception_Directory_Entry __exception_directory_entries(422) = 
1400243c8  {
1400243c8      uint32_t beginAddress = 0x1b020
1400243cc      uint32_t endAddress = 0x1b10b
1400243d0      uint32_t unwindInformation = 0x2636c
1400243d4  }
1400243d4  struct Exception_Directory_Entry __exception_directory_entries(423) = 
1400243d4  {
1400243d4      uint32_t beginAddress = 0x1b110
1400243d8      uint32_t endAddress = 0x1b192
1400243dc      uint32_t unwindInformation = 0x2637c
1400243e0  }
1400243e0  struct Exception_Directory_Entry __exception_directory_entries(424) = 
1400243e0  {
1400243e0      uint32_t beginAddress = 0x1b1a0
1400243e4      uint32_t endAddress = 0x1b2cf
1400243e8      uint32_t unwindInformation = 0x2638c
1400243ec  }
1400243ec  struct Exception_Directory_Entry __exception_directory_entries(425) = 
1400243ec  {
1400243ec      uint32_t beginAddress = 0x1b2d0
1400243f0      uint32_t endAddress = 0x1b2d9
1400243f4      uint32_t unwindInformation = 0x263a8
1400243f8  }
1400243f8  struct Exception_Directory_Entry __exception_directory_entries(426) = 
1400243f8  {
1400243f8      uint32_t beginAddress = 0x1b2e0
1400243fc      uint32_t endAddress = 0x1b2eb
140024400      uint32_t unwindInformation = 0x263ac
140024404  }
140024404  struct Exception_Directory_Entry __exception_directory_entries(427) = 
140024404  {
140024404      uint32_t beginAddress = 0x1b2f0
140024408      uint32_t endAddress = 0x1b334
14002440c      uint32_t unwindInformation = 0x263b0
140024410  }
140024410  struct Exception_Directory_Entry __exception_directory_entries(428) = 
140024410  {
140024410      uint32_t beginAddress = 0x1b340
140024414      uint32_t endAddress = 0x1b377
140024418      uint32_t unwindInformation = 0x263b8
14002441c  }
14002441c  struct Exception_Directory_Entry __exception_directory_entries(429) = 
14002441c  {
14002441c      uint32_t beginAddress = 0x1b380
140024420      uint32_t endAddress = 0x1b3c9
140024424      uint32_t unwindInformation = 0x263c0
140024428  }
140024428  struct Exception_Directory_Entry __exception_directory_entries(430) = 
140024428  {
140024428      uint32_t beginAddress = 0x1b3d0
14002442c      uint32_t endAddress = 0x1b404
140024430      uint32_t unwindInformation = 0x263cc
140024434  }
140024434  struct Exception_Directory_Entry __exception_directory_entries(431) = 
140024434  {
140024434      uint32_t beginAddress = 0x1b410
140024438      uint32_t endAddress = 0x1b41b
14002443c      uint32_t unwindInformation = 0x263d4
140024440  }
140024440  struct Exception_Directory_Entry __exception_directory_entries(432) = 
140024440  {
140024440      uint32_t beginAddress = 0x1b420
140024444      uint32_t endAddress = 0x1b429
140024448      uint32_t unwindInformation = 0x263d8
14002444c  }
14002444c  struct Exception_Directory_Entry __exception_directory_entries(433) = 
14002444c  {
14002444c      uint32_t beginAddress = 0x1b430
140024450      uint32_t endAddress = 0x1b504
140024454      uint32_t unwindInformation = 0x263dc
140024458  }
140024458  struct Exception_Directory_Entry __exception_directory_entries(434) = 
140024458  {
140024458      uint32_t beginAddress = 0x1b510
14002445c      uint32_t endAddress = 0x1b564
140024460      uint32_t unwindInformation = 0x263e8
140024464  }
140024464  struct Exception_Directory_Entry __exception_directory_entries(435) = 
140024464  {
140024464      uint32_t beginAddress = 0x1b570
140024468      uint32_t endAddress = 0x1b5c0
14002446c      uint32_t unwindInformation = 0x263f0
140024470  }
140024470  struct Exception_Directory_Entry __exception_directory_entries(436) = 
140024470  {
140024470      uint32_t beginAddress = 0x1b5c0
140024474      uint32_t endAddress = 0x1b619
140024478      uint32_t unwindInformation = 0x263f8
14002447c  }
14002447c  struct Exception_Directory_Entry __exception_directory_entries(437) = 
14002447c  {
14002447c      uint32_t beginAddress = 0x1b620
140024480      uint32_t endAddress = 0x1b69f
140024484      uint32_t unwindInformation = 0x26400
140024488  }
140024488  struct Exception_Directory_Entry __exception_directory_entries(438) = 
140024488  {
140024488      uint32_t beginAddress = 0x1b6a0
14002448c      uint32_t endAddress = 0x1b758
140024490      uint32_t unwindInformation = 0x2640c
140024494  }
140024494  struct Exception_Directory_Entry __exception_directory_entries(439) = 
140024494  {
140024494      uint32_t beginAddress = 0x1b760
140024498      uint32_t endAddress = 0x1b86d
14002449c      uint32_t unwindInformation = 0x26418
1400244a0  }
1400244a0  struct Exception_Directory_Entry __exception_directory_entries(440) = 
1400244a0  {
1400244a0      uint32_t beginAddress = 0x1b870
1400244a4      uint32_t endAddress = 0x1b8fa
1400244a8      uint32_t unwindInformation = 0x26424
1400244ac  }
1400244ac  struct Exception_Directory_Entry __exception_directory_entries(441) = 
1400244ac  {
1400244ac      uint32_t beginAddress = 0x1b900
1400244b0      uint32_t endAddress = 0x1bb17
1400244b4      uint32_t unwindInformation = 0x26430
1400244b8  }
1400244b8  struct Exception_Directory_Entry __exception_directory_entries(442) = 
1400244b8  {
1400244b8      uint32_t beginAddress = 0x1bb20
1400244bc      uint32_t endAddress = 0x1bbbf
1400244c0      uint32_t unwindInformation = 0x26440
1400244c4  }
1400244c4  struct Exception_Directory_Entry __exception_directory_entries(443) = 
1400244c4  {
1400244c4      uint32_t beginAddress = 0x1bbc0
1400244c8      uint32_t endAddress = 0x1bbc5
1400244cc      uint32_t unwindInformation = 0x2644c
1400244d0  }
1400244d0  struct Exception_Directory_Entry __exception_directory_entries(444) = 
1400244d0  {
1400244d0      uint32_t beginAddress = 0x1bbd0
1400244d4      uint32_t endAddress = 0x1bbe6
1400244d8      uint32_t unwindInformation = 0x26450
1400244dc  }
1400244dc  struct Exception_Directory_Entry __exception_directory_entries(445) = 
1400244dc  {
1400244dc      uint32_t beginAddress = 0x1bbf0
1400244e0      uint32_t endAddress = 0x1bc18
1400244e4      uint32_t unwindInformation = 0x26454
1400244e8  }
1400244e8  struct Exception_Directory_Entry __exception_directory_entries(446) = 
1400244e8  {
1400244e8      uint32_t beginAddress = 0x1bc20
1400244ec      uint32_t endAddress = 0x1bc42
1400244f0      uint32_t unwindInformation = 0x26458
1400244f4  }
1400244f4  struct Exception_Directory_Entry __exception_directory_entries(447) = 
1400244f4  {
1400244f4      uint32_t beginAddress = 0x1bc50
1400244f8      uint32_t endAddress = 0x1bc7a
1400244fc      uint32_t unwindInformation = 0x2645c
140024500  }
140024500  struct Exception_Directory_Entry __exception_directory_entries(448) = 
140024500  {
140024500      uint32_t beginAddress = 0x1bc80
140024504      uint32_t endAddress = 0x1bc8a
140024508      uint32_t unwindInformation = 0x26460
14002450c  }
14002450c  struct Exception_Directory_Entry __exception_directory_entries(449) = 
14002450c  {
14002450c      uint32_t beginAddress = 0x1bc90
140024510      uint32_t endAddress = 0x1bcba
140024514      uint32_t unwindInformation = 0x26464
140024518  }
140024518  struct Exception_Directory_Entry __exception_directory_entries(450) = 
140024518  {
140024518      uint32_t beginAddress = 0x1bcc0
14002451c      uint32_t endAddress = 0x1bcca
140024520      uint32_t unwindInformation = 0x26468
140024524  }
140024524  struct Exception_Directory_Entry __exception_directory_entries(451) = 
140024524  {
140024524      uint32_t beginAddress = 0x1bcd0
140024528      uint32_t endAddress = 0x1bcfa
14002452c      uint32_t unwindInformation = 0x2646c
140024530  }
140024530  struct Exception_Directory_Entry __exception_directory_entries(452) = 
140024530  {
140024530      uint32_t beginAddress = 0x1bd00
140024534      uint32_t endAddress = 0x1bd0a
140024538      uint32_t unwindInformation = 0x26470
14002453c  }
14002453c  struct Exception_Directory_Entry __exception_directory_entries(453) = 
14002453c  {
14002453c      uint32_t beginAddress = 0x1bd10
140024540      uint32_t endAddress = 0x1bd27
140024544      uint32_t unwindInformation = 0x26474
140024548  }
140024548  struct Exception_Directory_Entry __exception_directory_entries(454) = 
140024548  {
140024548      uint32_t beginAddress = 0x1bd30
14002454c      uint32_t endAddress = 0x1bd3e
140024550      uint32_t unwindInformation = 0x26478
140024554  }
140024554  struct Exception_Directory_Entry __exception_directory_entries(455) = 
140024554  {
140024554      uint32_t beginAddress = 0x1bd40
140024558      uint32_t endAddress = 0x1bd4a
14002455c      uint32_t unwindInformation = 0x2647c
140024560  }
140024560  struct Exception_Directory_Entry __exception_directory_entries(456) = 
140024560  {
140024560      uint32_t beginAddress = 0x1bd50
140024564      uint32_t endAddress = 0x1bd57
140024568      uint32_t unwindInformation = 0x26480
14002456c  }
14002456c  struct Exception_Directory_Entry __exception_directory_entries(457) = 
14002456c  {
14002456c      uint32_t beginAddress = 0x1bd60
140024570      uint32_t endAddress = 0x1bd6a
140024574      uint32_t unwindInformation = 0x26484
140024578  }
140024578  struct Exception_Directory_Entry __exception_directory_entries(458) = 
140024578  {
140024578      uint32_t beginAddress = 0x1bd70
14002457c      uint32_t endAddress = 0x1bd77
140024580      uint32_t unwindInformation = 0x26488
140024584  }
140024584  struct Exception_Directory_Entry __exception_directory_entries(459) = 
140024584  {
140024584      uint32_t beginAddress = 0x1bd80
140024588      uint32_t endAddress = 0x1be0b
14002458c      uint32_t unwindInformation = 0x2648c
140024590  }
140024590  struct Exception_Directory_Entry __exception_directory_entries(460) = 
140024590  {
140024590      uint32_t beginAddress = 0x1be10
140024594      uint32_t endAddress = 0x1bea7
140024598      uint32_t unwindInformation = 0x2649c
14002459c  }
14002459c  struct Exception_Directory_Entry __exception_directory_entries(461) = 
14002459c  {
14002459c      uint32_t beginAddress = 0x1beb0
1400245a0      uint32_t endAddress = 0x1c13d
1400245a4      uint32_t unwindInformation = 0x264ac
1400245a8  }
1400245a8  struct Exception_Directory_Entry __exception_directory_entries(462) = 
1400245a8  {
1400245a8      uint32_t beginAddress = 0x1c140
1400245ac      uint32_t endAddress = 0x1c2c5
1400245b0      uint32_t unwindInformation = 0x264c0
1400245b4  }
1400245b4  struct Exception_Directory_Entry __exception_directory_entries(463) = 
1400245b4  {
1400245b4      uint32_t beginAddress = 0x1c2d0
1400245b8      uint32_t endAddress = 0x1c4a0
1400245bc      uint32_t unwindInformation = 0x264d0
1400245c0  }
1400245c0  struct Exception_Directory_Entry __exception_directory_entries(464) = 
1400245c0  {
1400245c0      uint32_t beginAddress = 0x1c4a0
1400245c4      uint32_t endAddress = 0x1c5f0
1400245c8      uint32_t unwindInformation = 0x264e0
1400245cc  }
1400245cc  struct Exception_Directory_Entry __exception_directory_entries(465) = 
1400245cc  {
1400245cc      uint32_t beginAddress = 0x1c5f0
1400245d0      uint32_t endAddress = 0x1c5f7
1400245d4      uint32_t unwindInformation = 0x264f0
1400245d8  }
1400245d8  struct Exception_Directory_Entry __exception_directory_entries(466) = 
1400245d8  {
1400245d8      uint32_t beginAddress = 0x1c600
1400245dc      uint32_t endAddress = 0x1c609
1400245e0      uint32_t unwindInformation = 0x264f4
1400245e4  }
1400245e4  struct Exception_Directory_Entry __exception_directory_entries(467) = 
1400245e4  {
1400245e4      uint32_t beginAddress = 0x1c610
1400245e8      uint32_t endAddress = 0x1c737
1400245ec      uint32_t unwindInformation = 0x264f8
1400245f0  }
1400245f0  struct Exception_Directory_Entry __exception_directory_entries(468) = 
1400245f0  {
1400245f0      uint32_t beginAddress = 0x1c740
1400245f4      uint32_t endAddress = 0x1c85c
1400245f8      uint32_t unwindInformation = 0x26508
1400245fc  }

1400245fc  _.pdata.unlikely:
1400245fc                                                                                      60 c8 01 00                              `...
140024600  a4 c8 01 00 90 65 02 00                                                                          .....e..

140024608  struct Exception_Directory_Entry __exception_directory_entries(470) = 
140024608  {
140024608      uint32_t beginAddress = 0x1c8b0
14002460c      uint32_t endAddress = 0x1c8d9
140024610      uint32_t unwindInformation = 0x26598
140024614  }
140024614  struct Exception_Directory_Entry __exception_directory_entries(471) = 
140024614  {
140024614      uint32_t beginAddress = 0x1c8e0
140024618      uint32_t endAddress = 0x1c95d
14002461c      uint32_t unwindInformation = 0x2659c
140024620  }
140024620  struct Exception_Directory_Entry __exception_directory_entries(472) = 
140024620  {
140024620      uint32_t beginAddress = 0x1c960
140024624      uint32_t endAddress = 0x1c9d1
140024628      uint32_t unwindInformation = 0x265a4
14002462c  }
14002462c  struct Exception_Directory_Entry __exception_directory_entries(473) = 
14002462c  {
14002462c      uint32_t beginAddress = 0x1c9e0
140024630      uint32_t endAddress = 0x1ca75
140024634      uint32_t unwindInformation = 0x265b4
140024638  }

140024638  _.pdata:
140024638                                                                          80 ca 01 00 07 cb 01 00                          ........
140024640  c8 65 02 00                                                                                      .e..

140024644  struct Exception_Directory_Entry __exception_directory_entries(475) = 
140024644  {
140024644      uint32_t beginAddress = 0x1cb10
140024648      uint32_t endAddress = 0x1cb77
14002464c      uint32_t unwindInformation = 0x265d8
140024650  }
140024650  struct Exception_Directory_Entry __exception_directory_entries(476) = 
140024650  {
140024650      uint32_t beginAddress = 0x1cb80
140024654      uint32_t endAddress = 0x1cc04
140024658      uint32_t unwindInformation = 0x265e4
14002465c  }
14002465c  struct Exception_Directory_Entry __exception_directory_entries(477) = 
14002465c  {
14002465c      uint32_t beginAddress = 0x1cc10
140024660      uint32_t endAddress = 0x1cc3e
140024664      uint32_t unwindInformation = 0x265f0
140024668  }
140024668  struct Exception_Directory_Entry __exception_directory_entries(478) = 
140024668  {
140024668      uint32_t beginAddress = 0x1cc40
14002466c      uint32_t endAddress = 0x1cc47
140024670      uint32_t unwindInformation = 0x265f8
140024674  }

140024674  _.pdata:
140024674                                                              50 cc 01 00 e4 cc 01 00 fc 65 02 00                      P........e..

140024680  struct Exception_Directory_Entry __exception_directory_entries(480) = 
140024680  {
140024680      uint32_t beginAddress = 0x1ccf0
140024684      uint32_t endAddress = 0x1cde9
140024688      uint32_t unwindInformation = 0x2660c
14002468c  }
14002468c  struct Exception_Directory_Entry __exception_directory_entries(481) = 
14002468c  {
14002468c      uint32_t beginAddress = 0x1cdf0
140024690      uint32_t endAddress = 0x1ce46
140024694      uint32_t unwindInformation = 0x2661c
140024698  }
140024698  struct Exception_Directory_Entry __exception_directory_entries(482) = 
140024698  {
140024698      uint32_t beginAddress = 0x1ce50
14002469c      uint32_t endAddress = 0x1ceb0
1400246a0      uint32_t unwindInformation = 0x26628
1400246a4  }
1400246a4  struct Exception_Directory_Entry __exception_directory_entries(483) = 
1400246a4  {
1400246a4      uint32_t beginAddress = 0x1ceb0
1400246a8      uint32_t endAddress = 0x1cfe4
1400246ac      uint32_t unwindInformation = 0x26634
1400246b0  }
1400246b0  struct Exception_Directory_Entry __exception_directory_entries(484) = 
1400246b0  {
1400246b0      uint32_t beginAddress = 0x1cff0
1400246b4      uint32_t endAddress = 0x1d0a8
1400246b8      uint32_t unwindInformation = 0x26648
1400246bc  }
1400246bc  struct Exception_Directory_Entry __exception_directory_entries(485) = 
1400246bc  {
1400246bc      uint32_t beginAddress = 0x1d0b0
1400246c0      uint32_t endAddress = 0x1d187
1400246c4      uint32_t unwindInformation = 0x26658
1400246c8  }
1400246c8  struct Exception_Directory_Entry __exception_directory_entries(486) = 
1400246c8  {
1400246c8      uint32_t beginAddress = 0x1d190
1400246cc      uint32_t endAddress = 0x1d248
1400246d0      uint32_t unwindInformation = 0x26668
1400246d4  }
1400246d4  struct Exception_Directory_Entry __exception_directory_entries(487) = 
1400246d4  {
1400246d4      uint32_t beginAddress = 0x1d250
1400246d8      uint32_t endAddress = 0x1d319
1400246dc      uint32_t unwindInformation = 0x26678
1400246e0  }
1400246e0  struct Exception_Directory_Entry __exception_directory_entries(488) = 
1400246e0  {
1400246e0      uint32_t beginAddress = 0x1d320
1400246e4      uint32_t endAddress = 0x1d3ca
1400246e8      uint32_t unwindInformation = 0x26688
1400246ec  }
1400246ec  struct Exception_Directory_Entry __exception_directory_entries(489) = 
1400246ec  {
1400246ec      uint32_t beginAddress = 0x1d3d0
1400246f0      uint32_t endAddress = 0x1d509
1400246f4      uint32_t unwindInformation = 0x26698
1400246f8  }
1400246f8  struct Exception_Directory_Entry __exception_directory_entries(490) = 
1400246f8  {
1400246f8      uint32_t beginAddress = 0x1d510
1400246fc      uint32_t endAddress = 0x1d681
140024700      uint32_t unwindInformation = 0x266ac
140024704  }
140024704  struct Exception_Directory_Entry __exception_directory_entries(491) = 
140024704  {
140024704      uint32_t beginAddress = 0x1d690
140024708      uint32_t endAddress = 0x1d69a
14002470c      uint32_t unwindInformation = 0x266c0
140024710  }
140024710  struct Exception_Directory_Entry __exception_directory_entries(492) = 
140024710  {
140024710      uint32_t beginAddress = 0x1d6a0
140024714      uint32_t endAddress = 0x1d6b6
140024718      uint32_t unwindInformation = 0x266c4
14002471c  }
14002471c  struct Exception_Directory_Entry __exception_directory_entries(493) = 
14002471c  {
14002471c      uint32_t beginAddress = 0x1d6c0
140024720      uint32_t endAddress = 0x1d6de
140024724      uint32_t unwindInformation = 0x266c8
140024728  }
140024728  struct Exception_Directory_Entry __exception_directory_entries(494) = 
140024728  {
140024728      uint32_t beginAddress = 0x1d6e0
14002472c      uint32_t endAddress = 0x1d6f6
140024730      uint32_t unwindInformation = 0x266cc
140024734  }
140024734  struct Exception_Directory_Entry __exception_directory_entries(495) = 
140024734  {
140024734      uint32_t beginAddress = 0x1d700
140024738      uint32_t endAddress = 0x1d70a
14002473c      uint32_t unwindInformation = 0x266d0
140024740  }
140024740  struct Exception_Directory_Entry __exception_directory_entries(496) = 
140024740  {
140024740      uint32_t beginAddress = 0x1d710
140024744      uint32_t endAddress = 0x1d713
140024748      uint32_t unwindInformation = 0x266d4
14002474c  }
14002474c  struct Exception_Directory_Entry __exception_directory_entries(497) = 
14002474c  {
14002474c      uint32_t beginAddress = 0x1d720
140024750      uint32_t endAddress = 0x1d73c
140024754      uint32_t unwindInformation = 0x266d8
140024758  }
140024758  struct Exception_Directory_Entry __exception_directory_entries(498) = 
140024758  {
140024758      uint32_t beginAddress = 0x1d740
14002475c      uint32_t endAddress = 0x1d752
140024760      uint32_t unwindInformation = 0x266dc
140024764  }
140024764  struct Exception_Directory_Entry __exception_directory_entries(499) = 
140024764  {
140024764      uint32_t beginAddress = 0x1d760
140024768      uint32_t endAddress = 0x1d76a
14002476c      uint32_t unwindInformation = 0x266e0
140024770  }

140024770  _.pdata:
140024770                                                  70 d7 01 00 0c d8 01 00 e4 66 02 00                              p........f..

14002477c  struct Exception_Directory_Entry __exception_directory_entries(501) = 
14002477c  {
14002477c      uint32_t beginAddress = 0x1d810
140024780      uint32_t endAddress = 0x1d858
140024784      uint32_t unwindInformation = 0x266f4
140024788  }
140024788  struct Exception_Directory_Entry __exception_directory_entries(502) = 
140024788  {
140024788      uint32_t beginAddress = 0x1d860
14002478c      uint32_t endAddress = 0x1d8eb
140024790      uint32_t unwindInformation = 0x266fc
140024794  }
140024794  struct Exception_Directory_Entry __exception_directory_entries(503) = 
140024794  {
140024794      uint32_t beginAddress = 0x1d8f0
140024798      uint32_t endAddress = 0x1d906
14002479c      uint32_t unwindInformation = 0x2670c
1400247a0  }
1400247a0  struct Exception_Directory_Entry __exception_directory_entries(504) = 
1400247a0  {
1400247a0      uint32_t beginAddress = 0x1d910
1400247a4      uint32_t endAddress = 0x1d926
1400247a8      uint32_t unwindInformation = 0x26710
1400247ac  }

1400247ac  _.pdata:
1400247ac                                      30 d9 01 00 4e d9 01 00 14 67 02 00                                      0...N....g..

1400247b8  struct Exception_Directory_Entry __exception_directory_entries(506) = 
1400247b8  {
1400247b8      uint32_t beginAddress = 0x1d950
1400247bc      uint32_t endAddress = 0x1d96e
1400247c0      uint32_t unwindInformation = 0x26718
1400247c4  }
1400247c4  struct Exception_Directory_Entry __exception_directory_entries(507) = 
1400247c4  {
1400247c4      uint32_t beginAddress = 0x1d970
1400247c8      uint32_t endAddress = 0x1d986
1400247cc      uint32_t unwindInformation = 0x2671c
1400247d0  }
1400247d0  struct Exception_Directory_Entry __exception_directory_entries(508) = 
1400247d0  {
1400247d0      uint32_t beginAddress = 0x1d990
1400247d4      uint32_t endAddress = 0x1da2a
1400247d8      uint32_t unwindInformation = 0x26720
1400247dc  }
1400247dc  struct Exception_Directory_Entry __exception_directory_entries(509) = 
1400247dc  {
1400247dc      uint32_t beginAddress = 0x1da30
1400247e0      uint32_t endAddress = 0x1da56
1400247e4      uint32_t unwindInformation = 0x2672c
1400247e8  }
1400247e8  struct Exception_Directory_Entry __exception_directory_entries(510) = 
1400247e8  {
1400247e8      uint32_t beginAddress = 0x1da60
1400247ec      uint32_t endAddress = 0x1db8e
1400247f0      uint32_t unwindInformation = 0x26730
1400247f4  }
1400247f4  struct Exception_Directory_Entry __exception_directory_entries(511) = 
1400247f4  {
1400247f4      uint32_t beginAddress = 0x1db90
1400247f8      uint32_t endAddress = 0x1ddfd
1400247fc      uint32_t unwindInformation = 0x2673c
140024800  }
140024800  struct Exception_Directory_Entry __exception_directory_entries(512) = 
140024800  {
140024800      uint32_t beginAddress = 0x1de00
140024804      uint32_t endAddress = 0x1de9e
140024808      uint32_t unwindInformation = 0x2674c
14002480c  }
14002480c  struct Exception_Directory_Entry __exception_directory_entries(513) = 
14002480c  {
14002480c      uint32_t beginAddress = 0x1dea0
140024810      uint32_t endAddress = 0x1e042
140024814      uint32_t unwindInformation = 0x26764
140024818  }
140024818  struct Exception_Directory_Entry __exception_directory_entries(514) = 
140024818  {
140024818      uint32_t beginAddress = 0x1e050
14002481c      uint32_t endAddress = 0x1e17e
140024820      uint32_t unwindInformation = 0x26778
140024824  }
140024824  struct Exception_Directory_Entry __exception_directory_entries(515) = 
140024824  {
140024824      uint32_t beginAddress = 0x1e180
140024828      uint32_t endAddress = 0x1e2ae
14002482c      uint32_t unwindInformation = 0x26784
140024830  }
140024830  struct Exception_Directory_Entry __exception_directory_entries(516) = 
140024830  {
140024830      uint32_t beginAddress = 0x1e2b0
140024834      uint32_t endAddress = 0x1e4ca
140024838      uint32_t unwindInformation = 0x26790
14002483c  }
14002483c  struct Exception_Directory_Entry __exception_directory_entries(517) = 
14002483c  {
14002483c      uint32_t beginAddress = 0x1e4d0
140024840      uint32_t endAddress = 0x1e604
140024844      uint32_t unwindInformation = 0x267a4
140024848  }
140024848  struct Exception_Directory_Entry __exception_directory_entries(518) = 
140024848  {
140024848      uint32_t beginAddress = 0x1e610
14002484c      uint32_t endAddress = 0x1e877
140024850      uint32_t unwindInformation = 0x267b8
140024854  }
140024854  struct Exception_Directory_Entry __exception_directory_entries(519) = 
140024854  {
140024854      uint32_t beginAddress = 0x1e880
140024858      uint32_t endAddress = 0x1e888
14002485c      uint32_t unwindInformation = 0x267d0
140024860  }
140024860  struct Exception_Directory_Entry __exception_directory_entries(520) = 
140024860  {
140024860      uint32_t beginAddress = 0x1e890
140024864      uint32_t endAddress = 0x1e89b
140024868      uint32_t unwindInformation = 0x267d4
14002486c  }
14002486c  struct Exception_Directory_Entry __exception_directory_entries(521) = 
14002486c  {
14002486c      uint32_t beginAddress = 0x1e8a0
140024870      uint32_t endAddress = 0x1e8ea
140024874      uint32_t unwindInformation = 0x267d8
140024878  }
140024878  struct Exception_Directory_Entry __exception_directory_entries(522) = 
140024878  {
140024878      uint32_t beginAddress = 0x1e8f0
14002487c      uint32_t endAddress = 0x1e91e
140024880      uint32_t unwindInformation = 0x267e0
140024884  }
140024884  struct Exception_Directory_Entry __exception_directory_entries(523) = 
140024884  {
140024884      uint32_t beginAddress = 0x1e920
140024888      uint32_t endAddress = 0x1e946
14002488c      uint32_t unwindInformation = 0x267e8
140024890  }
140024890  struct Exception_Directory_Entry __exception_directory_entries(524) = 
140024890  {
140024890      uint32_t beginAddress = 0x1e950
140024894      uint32_t endAddress = 0x1e96e
140024898      uint32_t unwindInformation = 0x267f0
14002489c  }
14002489c  struct Exception_Directory_Entry __exception_directory_entries(525) = 
14002489c  {
14002489c      uint32_t beginAddress = 0x1e970
1400248a0      uint32_t endAddress = 0x1e98e
1400248a4      uint32_t unwindInformation = 0x267f4
1400248a8  }

1400248a8  _.pdata:
1400248a8                          90 e9 01 00 ae e9 01 00 f8 67 02 00                                              .........g..

1400248b4  struct Exception_Directory_Entry __exception_directory_entries(527) = 
1400248b4  {
1400248b4      uint32_t beginAddress = 0x1e9b0
1400248b8      uint32_t endAddress = 0x1e9ce
1400248bc      uint32_t unwindInformation = 0x267fc
1400248c0  }
1400248c0  struct Exception_Directory_Entry __exception_directory_entries(528) = 
1400248c0  {
1400248c0      uint32_t beginAddress = 0x1e9d0
1400248c4      uint32_t endAddress = 0x1ea38
1400248c8      uint32_t unwindInformation = 0x26800
1400248cc  }
1400248cc  struct Exception_Directory_Entry __exception_directory_entries(529) = 
1400248cc  {
1400248cc      uint32_t beginAddress = 0x1ea40
1400248d0      uint32_t endAddress = 0x1eae7
1400248d4      uint32_t unwindInformation = 0x26810
1400248d8  }
1400248d8  struct Exception_Directory_Entry __exception_directory_entries(530) = 
1400248d8  {
1400248d8      uint32_t beginAddress = 0x1eaf0
1400248dc      uint32_t endAddress = 0x1eb54
1400248e0      uint32_t unwindInformation = 0x2681c
1400248e4  }
1400248e4  struct Exception_Directory_Entry __exception_directory_entries(531) = 
1400248e4  {
1400248e4      uint32_t beginAddress = 0x1eb60
1400248e8      uint32_t endAddress = 0x1ebf0
1400248ec      uint32_t unwindInformation = 0x26824
1400248f0  }
1400248f0  struct Exception_Directory_Entry __exception_directory_entries(532) = 
1400248f0  {
1400248f0      uint32_t beginAddress = 0x1ebf0
1400248f4      uint32_t endAddress = 0x1ec03
1400248f8      uint32_t unwindInformation = 0x26830
1400248fc  }
1400248fc  struct Exception_Directory_Entry __exception_directory_entries(533) = 
1400248fc  {
1400248fc      uint32_t beginAddress = 0x1ed20
140024900      uint32_t endAddress = 0x1ed68
140024904      uint32_t unwindInformation = 0x26838
140024908  }
140024908  struct Exception_Directory_Entry __exception_directory_entries(534) = 
140024908  {
140024908      uint32_t beginAddress = 0x1edb0
14002490c      uint32_t endAddress = 0x1edb6
140024910      uint32_t unwindInformation = 0x26518
140024914  }
140024914  struct Exception_Directory_Entry __exception_directory_entries(535) = 
140024914  {
140024914      uint32_t beginAddress = 0x1edb6
140024918      uint32_t endAddress = 0x1edbc
14002491c      uint32_t unwindInformation = 0x26520
140024920  }
140024920  struct Exception_Directory_Entry __exception_directory_entries(536) = 
140024920  {
140024920      uint32_t beginAddress = 0x1edbc
140024924      uint32_t endAddress = 0x1edc2
140024928      uint32_t unwindInformation = 0x26538
14002492c  }
14002492c  struct Exception_Directory_Entry __exception_directory_entries(537) = 
14002492c  {
14002492c      uint32_t beginAddress = 0x1edc2
140024930      uint32_t endAddress = 0x1edd5
140024934      uint32_t unwindInformation = 0x26550
140024938  }

140024938  _.pdata:
140024938                                                                          d5 ed 01 00 fd ed 01 00                          ........
140024940  74 65 02 00                                                                                      te..
140024944  _.pdata.startup:
140024944              00 ee 01 00 05 ee 01 00 44 68 02 00                                                      ........Dh..
.pdata section ended  {0x140023000-0x140024950}

.xdata section started  {0x140025000-0x140026848}
140025000  _.xdata:
140025000  01 00 00 00                                                                                      ....

140025004  struct UNWIND_INFO data_140025004 = 
140025004  {
140025004      uint8_t VersionAndFlag = 0x1
140025005      uint8_t SizeOfProlog = 0x4
140025006      uint8_t CountOfUnwindCodes = 0x1
140025007      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025008  }
140025008  uint16_t data_140025008[0x1] = 
140025008  {
140025008      [0x0] =  0x4204
14002500a  }

14002500a                                00 00                                                                        ..

14002500c  struct UNWIND_INFO data_14002500c = 
14002500c  {
14002500c      uint8_t VersionAndFlag = 0x1
14002500d      uint8_t SizeOfProlog = 0x4
14002500e      uint8_t CountOfUnwindCodes = 0x1
14002500f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025010  }
140025010  uint16_t data_140025010[0x1] = 
140025010  {
140025010      [0x0] =  0x6204
140025012  }

140025012                                                        00 00                                                        ..

140025014  struct UNWIND_INFO data_140025014 = 
140025014  {
140025014      uint8_t VersionAndFlag = 0x1
140025015      uint8_t SizeOfProlog = 0xa
140025016      uint8_t CountOfUnwindCodes = 0x6
140025017      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025018  }
140025018  uint16_t data_140025018[0x6] = 
140025018  {
140025018      [0x0] =  0x320a
14002501a      [0x1] =  0x3006
14002501c      [0x2] =  0x6005
14002501e      [0x3] =  0x7004
140025020      [0x4] =  0x5003
140025022      [0x5] =  0xc002
140025024  }
140025024  struct UNWIND_INFO data_140025024 = 
140025024  {
140025024      uint8_t VersionAndFlag = 0x9
140025025      uint8_t SizeOfProlog = 0x4
140025026      uint8_t CountOfUnwindCodes = 0x1
140025027      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025028  }
140025028  uint16_t data_140025028[0x1] = 
140025028  {
140025028      [0x0] =  0x4204
14002502a  }

14002502a                                00 00                                                                        ..

14002502c  uint32_t data_14002502c = 0x194b0

140025030                                                  01 00 00 00 d4 13 00 00 e7 13 00 00 60 37 01 00                  ............`7..
140025040  e7 13 00 00                                                                                      ....

140025044  struct UNWIND_INFO data_140025044 = 
140025044  {
140025044      uint8_t VersionAndFlag = 0x9
140025045      uint8_t SizeOfProlog = 0x4
140025046      uint8_t CountOfUnwindCodes = 0x1
140025047      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025048  }
140025048  uint16_t data_140025048[0x1] = 
140025048  {
140025048      [0x0] =  0x4204
14002504a  }

14002504a                                00 00                                                                        ..

14002504c  uint32_t data_14002504c = 0x194b0

140025050                                                  01 00 00 00 f4 13 00 00 07 14 00 00 60 37 01 00                  ............`7..
140025060  07 14 00 00                                                                                      ....

140025064  struct UNWIND_INFO data_140025064 = 
140025064  {
140025064      uint8_t VersionAndFlag = 0x1
140025065      uint8_t SizeOfProlog = 0x4
140025066      uint8_t CountOfUnwindCodes = 0x1
140025067      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025068  }
140025068  uint16_t data_140025068[0x1] = 
140025068  {
140025068      [0x0] =  0x4204
14002506a  }

14002506a                                00 00                                                                        ..
14002506c  _.xdata:
14002506c                                      01 00 00 00                                                              ....

140025070  struct UNWIND_INFO data_140025070 = 
140025070  {
140025070      uint8_t VersionAndFlag = 0x1
140025071      uint8_t SizeOfProlog = 0x0
140025072      uint8_t CountOfUnwindCodes = 0x0
140025073      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025074  }

140025074  _.xdata:
140025074                                                              01 08 03 05                                              ....
140025078  uint16_t data_140025078[0x3] = 
140025078  {
140025078      [0x0] =  0x3208
14002507a      [0x1] =  0x0304
14002507c      [0x2] =  0x5001
14002507e  }

14002507e                                                                                            00 00                                ..

140025080  struct UNWIND_INFO data_140025080 = 
140025080  {
140025080      uint8_t VersionAndFlag = 0x1
140025081      uint8_t SizeOfProlog = 0x8
140025082      uint8_t CountOfUnwindCodes = 0x3
140025083      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025084  }
140025084  uint16_t data_140025084[0x3] = 
140025084  {
140025084      [0x0] =  0x3208
140025086      [0x1] =  0x0304
140025088      [0x2] =  0x5001
14002508a  }

14002508a                                00 00                                                                        ..

14002508c  struct UNWIND_INFO data_14002508c = 
14002508c  {
14002508c      uint8_t VersionAndFlag = 0x1
14002508d      uint8_t SizeOfProlog = 0x8
14002508e      uint8_t CountOfUnwindCodes = 0x3
14002508f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025090  }
140025090  uint16_t data_140025090[0x3] = 
140025090  {
140025090      [0x0] =  0xb208
140025092      [0x1] =  0x0304
140025094      [0x2] =  0x5001
140025096  }

140025096                                                                    00 00                                                ..

140025098  struct UNWIND_INFO data_140025098 = 
140025098  {
140025098      uint8_t VersionAndFlag = 0x1
140025099      uint8_t SizeOfProlog = 0x8
14002509a      uint8_t CountOfUnwindCodes = 0x3
14002509b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002509c  }
14002509c  uint16_t data_14002509c[0x3] = 
14002509c  {
14002509c      [0x0] =  0x5208
14002509e      [0x1] =  0x0304
1400250a0      [0x2] =  0x5001
1400250a2  }

1400250a2        00 00                                                                                        ..

1400250a4  struct UNWIND_INFO data_1400250a4 = 
1400250a4  {
1400250a4      uint8_t VersionAndFlag = 0x1
1400250a5      uint8_t SizeOfProlog = 0x8
1400250a6      uint8_t CountOfUnwindCodes = 0x3
1400250a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400250a8  }
1400250a8  uint16_t data_1400250a8[0x3] = 
1400250a8  {
1400250a8      [0x0] =  0xf208
1400250aa      [0x1] =  0x0304
1400250ac      [0x2] =  0x5001
1400250ae  }

1400250ae                                            00 00                                                                ..

1400250b0  struct UNWIND_INFO data_1400250b0 = 
1400250b0  {
1400250b0      uint8_t VersionAndFlag = 0x1
1400250b1      uint8_t SizeOfProlog = 0x8
1400250b2      uint8_t CountOfUnwindCodes = 0x3
1400250b3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400250b4  }
1400250b4  uint16_t data_1400250b4[0x3] = 
1400250b4  {
1400250b4      [0x0] =  0x7208
1400250b6      [0x1] =  0x0304
1400250b8      [0x2] =  0x5001
1400250ba  }

1400250ba                                                                                00 00                                        ..

1400250bc  struct UNWIND_INFO data_1400250bc = 
1400250bc  {
1400250bc      uint8_t VersionAndFlag = 0x1
1400250bd      uint8_t SizeOfProlog = 0x8
1400250be      uint8_t CountOfUnwindCodes = 0x3
1400250bf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400250c0  }
1400250c0  uint16_t data_1400250c0[0x3] = 
1400250c0  {
1400250c0      [0x0] =  0x5208
1400250c2      [0x1] =  0x0304
1400250c4      [0x2] =  0x5001
1400250c6  }

1400250c6                    00 00                                                                                ..

1400250c8  struct UNWIND_INFO data_1400250c8 = 
1400250c8  {
1400250c8      uint8_t VersionAndFlag = 0x1
1400250c9      uint8_t SizeOfProlog = 0x8
1400250ca      uint8_t CountOfUnwindCodes = 0x3
1400250cb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400250cc  }
1400250cc  uint16_t data_1400250cc[0x3] = 
1400250cc  {
1400250cc      [0x0] =  0xd208
1400250ce      [0x1] =  0x0304
1400250d0      [0x2] =  0x5001
1400250d2  }

1400250d2                                                        00 00                                                        ..

1400250d4  struct UNWIND_INFO data_1400250d4 = 
1400250d4  {
1400250d4      uint8_t VersionAndFlag = 0x1
1400250d5      uint8_t SizeOfProlog = 0x8
1400250d6      uint8_t CountOfUnwindCodes = 0x3
1400250d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400250d8  }
1400250d8  uint16_t data_1400250d8[0x3] = 
1400250d8  {
1400250d8      [0x0] =  0xb208
1400250da      [0x1] =  0x0304
1400250dc      [0x2] =  0x5001
1400250de  }

1400250de                                                                                            00 00                                ..

1400250e0  struct UNWIND_INFO data_1400250e0 = 
1400250e0  {
1400250e0      uint8_t VersionAndFlag = 0x1
1400250e1      uint8_t SizeOfProlog = 0x8
1400250e2      uint8_t CountOfUnwindCodes = 0x3
1400250e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400250e4  }
1400250e4  uint16_t data_1400250e4[0x3] = 
1400250e4  {
1400250e4      [0x0] =  0x3208
1400250e6      [0x1] =  0x0304
1400250e8      [0x2] =  0x5001
1400250ea  }

1400250ea                                00 00                                                                        ..

1400250ec  struct UNWIND_INFO data_1400250ec = 
1400250ec  {
1400250ec      uint8_t VersionAndFlag = 0x1
1400250ed      uint8_t SizeOfProlog = 0x8
1400250ee      uint8_t CountOfUnwindCodes = 0x3
1400250ef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400250f0  }
1400250f0  uint16_t data_1400250f0[0x3] = 
1400250f0  {
1400250f0      [0x0] =  0x7208
1400250f2      [0x1] =  0x0304
1400250f4      [0x2] =  0x5001
1400250f6  }

1400250f6                                                                    00 00                                                ..

1400250f8  struct UNWIND_INFO data_1400250f8 = 
1400250f8  {
1400250f8      uint8_t VersionAndFlag = 0x1
1400250f9      uint8_t SizeOfProlog = 0x8
1400250fa      uint8_t CountOfUnwindCodes = 0x3
1400250fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400250fc  }
1400250fc  uint16_t data_1400250fc[0x3] = 
1400250fc  {
1400250fc      [0x0] =  0x5208
1400250fe      [0x1] =  0x0304
140025100      [0x2] =  0x5001
140025102  }

140025102        00 00                                                                                        ..

140025104  struct UNWIND_INFO data_140025104 = 
140025104  {
140025104      uint8_t VersionAndFlag = 0x1
140025105      uint8_t SizeOfProlog = 0x8
140025106      uint8_t CountOfUnwindCodes = 0x3
140025107      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025108  }
140025108  uint16_t data_140025108[0x3] = 
140025108  {
140025108      [0x0] =  0x3208
14002510a      [0x1] =  0x0304
14002510c      [0x2] =  0x5001
14002510e  }

14002510e                                            00 00                                                                ..

140025110  struct UNWIND_INFO data_140025110 = 
140025110  {
140025110      uint8_t VersionAndFlag = 0x1
140025111      uint8_t SizeOfProlog = 0x8
140025112      uint8_t CountOfUnwindCodes = 0x3
140025113      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025114  }
140025114  uint16_t data_140025114[0x3] = 
140025114  {
140025114      [0x0] =  0x7208
140025116      [0x1] =  0x0304
140025118      [0x2] =  0x5001
14002511a  }

14002511a                                                                                00 00                                        ..

14002511c  struct UNWIND_INFO data_14002511c = 
14002511c  {
14002511c      uint8_t VersionAndFlag = 0x1
14002511d      uint8_t SizeOfProlog = 0x8
14002511e      uint8_t CountOfUnwindCodes = 0x3
14002511f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025120  }
140025120  uint16_t data_140025120[0x3] = 
140025120  {
140025120      [0x0] =  0x5208
140025122      [0x1] =  0x0304
140025124      [0x2] =  0x5001
140025126  }

140025126                    00 00                                                                                ..

140025128  struct UNWIND_INFO data_140025128 = 
140025128  {
140025128      uint8_t VersionAndFlag = 0x1
140025129      uint8_t SizeOfProlog = 0x8
14002512a      uint8_t CountOfUnwindCodes = 0x3
14002512b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002512c  }
14002512c  uint16_t data_14002512c[0x3] = 
14002512c  {
14002512c      [0x0] =  0x3208
14002512e      [0x1] =  0x0304
140025130      [0x2] =  0x5001
140025132  }

140025132                                                        00 00                                                        ..

140025134  struct UNWIND_INFO data_140025134 = 
140025134  {
140025134      uint8_t VersionAndFlag = 0x1
140025135      uint8_t SizeOfProlog = 0x8
140025136      uint8_t CountOfUnwindCodes = 0x3
140025137      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025138  }
140025138  uint16_t data_140025138[0x3] = 
140025138  {
140025138      [0x0] =  0x7208
14002513a      [0x1] =  0x0304
14002513c      [0x2] =  0x5001
14002513e  }

14002513e                                                                                            00 00                                ..

140025140  struct UNWIND_INFO data_140025140 = 
140025140  {
140025140      uint8_t VersionAndFlag = 0x1
140025141      uint8_t SizeOfProlog = 0x8
140025142      uint8_t CountOfUnwindCodes = 0x3
140025143      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025144  }
140025144  uint16_t data_140025144[0x3] = 
140025144  {
140025144      [0x0] =  0x5208
140025146      [0x1] =  0x0304
140025148      [0x2] =  0x5001
14002514a  }

14002514a                                00 00                                                                        ..

14002514c  struct UNWIND_INFO data_14002514c = 
14002514c  {
14002514c      uint8_t VersionAndFlag = 0x1
14002514d      uint8_t SizeOfProlog = 0x8
14002514e      uint8_t CountOfUnwindCodes = 0x3
14002514f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025150  }
140025150  uint16_t data_140025150[0x3] = 
140025150  {
140025150      [0x0] =  0x3208
140025152      [0x1] =  0x0304
140025154      [0x2] =  0x5001
140025156  }

140025156                                                                    00 00                                                ..

140025158  struct UNWIND_INFO data_140025158 = 
140025158  {
140025158      uint8_t VersionAndFlag = 0x1
140025159      uint8_t SizeOfProlog = 0x8
14002515a      uint8_t CountOfUnwindCodes = 0x3
14002515b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002515c  }
14002515c  uint16_t data_14002515c[0x3] = 
14002515c  {
14002515c      [0x0] =  0x7208
14002515e      [0x1] =  0x0304
140025160      [0x2] =  0x5001
140025162  }

140025162        00 00                                                                                        ..

140025164  struct UNWIND_INFO data_140025164 = 
140025164  {
140025164      uint8_t VersionAndFlag = 0x1
140025165      uint8_t SizeOfProlog = 0x8
140025166      uint8_t CountOfUnwindCodes = 0x3
140025167      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025168  }
140025168  uint16_t data_140025168[0x3] = 
140025168  {
140025168      [0x0] =  0x5208
14002516a      [0x1] =  0x0304
14002516c      [0x2] =  0x5001
14002516e  }

14002516e                                            00 00                                                                ..

140025170  struct UNWIND_INFO data_140025170 = 
140025170  {
140025170      uint8_t VersionAndFlag = 0x1
140025171      uint8_t SizeOfProlog = 0x8
140025172      uint8_t CountOfUnwindCodes = 0x3
140025173      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025174  }
140025174  uint16_t data_140025174[0x3] = 
140025174  {
140025174      [0x0] =  0x3208
140025176      [0x1] =  0x0304
140025178      [0x2] =  0x5001
14002517a  }

14002517a                                                                                00 00                                        ..

14002517c  struct UNWIND_INFO data_14002517c = 
14002517c  {
14002517c      uint8_t VersionAndFlag = 0x1
14002517d      uint8_t SizeOfProlog = 0x8
14002517e      uint8_t CountOfUnwindCodes = 0x3
14002517f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025180  }
140025180  uint16_t data_140025180[0x3] = 
140025180  {
140025180      [0x0] =  0x7208
140025182      [0x1] =  0x0304
140025184      [0x2] =  0x5001
140025186  }

140025186                    00 00                                                                                ..

140025188  struct UNWIND_INFO data_140025188 = 
140025188  {
140025188      uint8_t VersionAndFlag = 0x1
140025189      uint8_t SizeOfProlog = 0x8
14002518a      uint8_t CountOfUnwindCodes = 0x3
14002518b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002518c  }
14002518c  uint16_t data_14002518c[0x3] = 
14002518c  {
14002518c      [0x0] =  0x5208
14002518e      [0x1] =  0x0304
140025190      [0x2] =  0x5001
140025192  }

140025192                                                        00 00                                                        ..

140025194  struct UNWIND_INFO data_140025194 = 
140025194  {
140025194      uint8_t VersionAndFlag = 0x1
140025195      uint8_t SizeOfProlog = 0x8
140025196      uint8_t CountOfUnwindCodes = 0x3
140025197      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025198  }
140025198  uint16_t data_140025198[0x3] = 
140025198  {
140025198      [0x0] =  0x3208
14002519a      [0x1] =  0x0304
14002519c      [0x2] =  0x5001
14002519e  }

14002519e                                                                                            00 00                                ..
1400251a0  _.xdata:
1400251a0  01 08 03 05                                                                                      ....
1400251a4  uint16_t data_1400251a4[0x3] = 
1400251a4  {
1400251a4      [0x0] =  0x5208
1400251a6      [0x1] =  0x0304
1400251a8      [0x2] =  0x5001
1400251aa  }

1400251aa                                00 00                                                                        ..

1400251ac  struct UNWIND_INFO data_1400251ac = 
1400251ac  {
1400251ac      uint8_t VersionAndFlag = 0x1
1400251ad      uint8_t SizeOfProlog = 0x8
1400251ae      uint8_t CountOfUnwindCodes = 0x3
1400251af      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400251b0  }
1400251b0  uint16_t data_1400251b0[0x3] = 
1400251b0  {
1400251b0      [0x0] =  0x5208
1400251b2      [0x1] =  0x0304
1400251b4      [0x2] =  0x5001
1400251b6  }

1400251b6                                                                    00 00                                                ..

1400251b8  struct UNWIND_INFO data_1400251b8 = 
1400251b8  {
1400251b8      uint8_t VersionAndFlag = 0x1
1400251b9      uint8_t SizeOfProlog = 0x8
1400251ba      uint8_t CountOfUnwindCodes = 0x3
1400251bb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400251bc  }
1400251bc  uint16_t data_1400251bc[0x3] = 
1400251bc  {
1400251bc      [0x0] =  0x3208
1400251be      [0x1] =  0x0304
1400251c0      [0x2] =  0x5001
1400251c2  }

1400251c2        00 00                                                                                        ..

1400251c4  struct UNWIND_INFO data_1400251c4 = 
1400251c4  {
1400251c4      uint8_t VersionAndFlag = 0x1
1400251c5      uint8_t SizeOfProlog = 0x8
1400251c6      uint8_t CountOfUnwindCodes = 0x3
1400251c7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400251c8  }
1400251c8  uint16_t data_1400251c8[0x3] = 
1400251c8  {
1400251c8      [0x0] =  0x3208
1400251ca      [0x1] =  0x0304
1400251cc      [0x2] =  0x5001
1400251ce  }

1400251ce                                            00 00                                                                ..

1400251d0  struct UNWIND_INFO data_1400251d0 = 
1400251d0  {
1400251d0      uint8_t VersionAndFlag = 0x1
1400251d1      uint8_t SizeOfProlog = 0x8
1400251d2      uint8_t CountOfUnwindCodes = 0x3
1400251d3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400251d4  }
1400251d4  uint16_t data_1400251d4[0x3] = 
1400251d4  {
1400251d4      [0x0] =  0x3208
1400251d6      [0x1] =  0x0304
1400251d8      [0x2] =  0x5001
1400251da  }

1400251da                                                                                00 00                                        ..

1400251dc  struct UNWIND_INFO data_1400251dc = 
1400251dc  {
1400251dc      uint8_t VersionAndFlag = 0x1
1400251dd      uint8_t SizeOfProlog = 0x8
1400251de      uint8_t CountOfUnwindCodes = 0x3
1400251df      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400251e0  }
1400251e0  uint16_t data_1400251e0[0x3] = 
1400251e0  {
1400251e0      [0x0] =  0xb208
1400251e2      [0x1] =  0x0304
1400251e4      [0x2] =  0x5001
1400251e6  }

1400251e6                    00 00                                                                                ..

1400251e8  struct UNWIND_INFO data_1400251e8 = 
1400251e8  {
1400251e8      uint8_t VersionAndFlag = 0x1
1400251e9      uint8_t SizeOfProlog = 0x8
1400251ea      uint8_t CountOfUnwindCodes = 0x3
1400251eb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400251ec  }
1400251ec  uint16_t data_1400251ec[0x3] = 
1400251ec  {
1400251ec      [0x0] =  0x5208
1400251ee      [0x1] =  0x0304
1400251f0      [0x2] =  0x5001
1400251f2  }

1400251f2                                                        00 00                                                        ..

1400251f4  struct UNWIND_INFO data_1400251f4 = 
1400251f4  {
1400251f4      uint8_t VersionAndFlag = 0x1
1400251f5      uint8_t SizeOfProlog = 0xb
1400251f6      uint8_t CountOfUnwindCodes = 0x4
1400251f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400251f8  }
1400251f8  uint16_t data_1400251f8[0x4] = 
1400251f8  {
1400251f8      [0x0] =  0x010b
1400251fa      [0x1] =  0x001c
1400251fc      [0x2] =  0x0304
1400251fe      [0x3] =  0x5001
140025200  }
140025200  struct UNWIND_INFO data_140025200 = 
140025200  {
140025200      uint8_t VersionAndFlag = 0x1
140025201      uint8_t SizeOfProlog = 0x8
140025202      uint8_t CountOfUnwindCodes = 0x3
140025203      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025204  }
140025204  uint16_t data_140025204[0x3] = 
140025204  {
140025204      [0x0] =  0xb208
140025206      [0x1] =  0x0304
140025208      [0x2] =  0x5001
14002520a  }

14002520a                                00 00                                                                        ..

14002520c  struct UNWIND_INFO data_14002520c = 
14002520c  {
14002520c      uint8_t VersionAndFlag = 0x1
14002520d      uint8_t SizeOfProlog = 0x8
14002520e      uint8_t CountOfUnwindCodes = 0x3
14002520f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025210  }
140025210  uint16_t data_140025210[0x3] = 
140025210  {
140025210      [0x0] =  0xb208
140025212      [0x1] =  0x0304
140025214      [0x2] =  0x5001
140025216  }

140025216                                                                    00 00                                                ..
140025218  _.xdata:
140025218                                                                          01 08 03 05                                      ....
14002521c  uint16_t data_14002521c[0x3] = 
14002521c  {
14002521c      [0x0] =  0x3208
14002521e      [0x1] =  0x0304
140025220      [0x2] =  0x5001
140025222  }

140025222        00 00                                                                                        ..

140025224  struct UNWIND_INFO data_140025224 = 
140025224  {
140025224      uint8_t VersionAndFlag = 0x1
140025225      uint8_t SizeOfProlog = 0x8
140025226      uint8_t CountOfUnwindCodes = 0x3
140025227      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025228  }
140025228  uint16_t data_140025228[0x3] = 
140025228  {
140025228      [0x0] =  0x3208
14002522a      [0x1] =  0x0304
14002522c      [0x2] =  0x5001
14002522e  }

14002522e                                            00 00                                                                ..

140025230  struct UNWIND_INFO data_140025230 = 
140025230  {
140025230      uint8_t VersionAndFlag = 0x1
140025231      uint8_t SizeOfProlog = 0x8
140025232      uint8_t CountOfUnwindCodes = 0x3
140025233      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025234  }
140025234  uint16_t data_140025234[0x3] = 
140025234  {
140025234      [0x0] =  0x9208
140025236      [0x1] =  0x0304
140025238      [0x2] =  0x5001
14002523a  }

14002523a                                                                                00 00                                        ..

14002523c  struct UNWIND_INFO data_14002523c = 
14002523c  {
14002523c      uint8_t VersionAndFlag = 0x1
14002523d      uint8_t SizeOfProlog = 0x8
14002523e      uint8_t CountOfUnwindCodes = 0x3
14002523f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025240  }
140025240  uint16_t data_140025240[0x3] = 
140025240  {
140025240      [0x0] =  0xb208
140025242      [0x1] =  0x0304
140025244      [0x2] =  0x5001
140025246  }

140025246                    00 00                                                                                ..

140025248  struct UNWIND_INFO data_140025248 = 
140025248  {
140025248      uint8_t VersionAndFlag = 0x1
140025249      uint8_t SizeOfProlog = 0x8
14002524a      uint8_t CountOfUnwindCodes = 0x3
14002524b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002524c  }
14002524c  uint16_t data_14002524c[0x3] = 
14002524c  {
14002524c      [0x0] =  0xb208
14002524e      [0x1] =  0x0304
140025250      [0x2] =  0x5001
140025252  }

140025252                                                        00 00                                                        ..
140025254  _.xdata:
140025254                                                              01 08 03 05                                              ....
140025258  uint16_t data_140025258[0x3] = 
140025258  {
140025258      [0x0] =  0x3208
14002525a      [0x1] =  0x0304
14002525c      [0x2] =  0x5001
14002525e  }

14002525e                                                                                            00 00                                ..

140025260  struct UNWIND_INFO data_140025260 = 
140025260  {
140025260      uint8_t VersionAndFlag = 0x1
140025261      uint8_t SizeOfProlog = 0x8
140025262      uint8_t CountOfUnwindCodes = 0x3
140025263      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025264  }
140025264  uint16_t data_140025264[0x3] = 
140025264  {
140025264      [0x0] =  0x5208
140025266      [0x1] =  0x0304
140025268      [0x2] =  0x5001
14002526a  }

14002526a                                00 00                                                                        ..

14002526c  struct UNWIND_INFO data_14002526c = 
14002526c  {
14002526c      uint8_t VersionAndFlag = 0x1
14002526d      uint8_t SizeOfProlog = 0x8
14002526e      uint8_t CountOfUnwindCodes = 0x3
14002526f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025270  }
140025270  uint16_t data_140025270[0x3] = 
140025270  {
140025270      [0x0] =  0x3208
140025272      [0x1] =  0x0304
140025274      [0x2] =  0x5001
140025276  }

140025276                                                                    00 00                                                ..

140025278  struct UNWIND_INFO data_140025278 = 
140025278  {
140025278      uint8_t VersionAndFlag = 0x1
140025279      uint8_t SizeOfProlog = 0x8
14002527a      uint8_t CountOfUnwindCodes = 0x3
14002527b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002527c  }
14002527c  uint16_t data_14002527c[0x3] = 
14002527c  {
14002527c      [0x0] =  0x5208
14002527e      [0x1] =  0x0304
140025280      [0x2] =  0x5001
140025282  }

140025282        00 00                                                                                        ..

140025284  struct UNWIND_INFO data_140025284 = 
140025284  {
140025284      uint8_t VersionAndFlag = 0x1
140025285      uint8_t SizeOfProlog = 0x8
140025286      uint8_t CountOfUnwindCodes = 0x3
140025287      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025288  }
140025288  uint16_t data_140025288[0x3] = 
140025288  {
140025288      [0x0] =  0x5208
14002528a      [0x1] =  0x0304
14002528c      [0x2] =  0x5001
14002528e  }

14002528e                                            00 00                                                                ..

140025290  struct UNWIND_INFO data_140025290 = 
140025290  {
140025290      uint8_t VersionAndFlag = 0x1
140025291      uint8_t SizeOfProlog = 0x8
140025292      uint8_t CountOfUnwindCodes = 0x3
140025293      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025294  }
140025294  uint16_t data_140025294[0x3] = 
140025294  {
140025294      [0x0] =  0x3208
140025296      [0x1] =  0x0304
140025298      [0x2] =  0x5001
14002529a  }

14002529a                                                                                00 00                                        ..

14002529c  struct UNWIND_INFO data_14002529c = 
14002529c  {
14002529c      uint8_t VersionAndFlag = 0x1
14002529d      uint8_t SizeOfProlog = 0x8
14002529e      uint8_t CountOfUnwindCodes = 0x3
14002529f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400252a0  }
1400252a0  uint16_t data_1400252a0[0x3] = 
1400252a0  {
1400252a0      [0x0] =  0x3208
1400252a2      [0x1] =  0x0304
1400252a4      [0x2] =  0x5001
1400252a6  }

1400252a6                    00 00                                                                                ..

1400252a8  struct UNWIND_INFO data_1400252a8 = 
1400252a8  {
1400252a8      uint8_t VersionAndFlag = 0x1
1400252a9      uint8_t SizeOfProlog = 0x8
1400252aa      uint8_t CountOfUnwindCodes = 0x3
1400252ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400252ac  }
1400252ac  uint16_t data_1400252ac[0x3] = 
1400252ac  {
1400252ac      [0x0] =  0xb208
1400252ae      [0x1] =  0x0304
1400252b0      [0x2] =  0x5001
1400252b2  }

1400252b2                                                        00 00                                                        ..

1400252b4  struct UNWIND_INFO data_1400252b4 = 
1400252b4  {
1400252b4      uint8_t VersionAndFlag = 0x1
1400252b5      uint8_t SizeOfProlog = 0x8
1400252b6      uint8_t CountOfUnwindCodes = 0x3
1400252b7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400252b8  }
1400252b8  uint16_t data_1400252b8[0x3] = 
1400252b8  {
1400252b8      [0x0] =  0xd208
1400252ba      [0x1] =  0x0304
1400252bc      [0x2] =  0x5001
1400252be  }

1400252be                                                                                            00 00                                ..

1400252c0  struct UNWIND_INFO data_1400252c0 = 
1400252c0  {
1400252c0      uint8_t VersionAndFlag = 0x1
1400252c1      uint8_t SizeOfProlog = 0x8
1400252c2      uint8_t CountOfUnwindCodes = 0x3
1400252c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400252c4  }
1400252c4  uint16_t data_1400252c4[0x3] = 
1400252c4  {
1400252c4      [0x0] =  0xf208
1400252c6      [0x1] =  0x0304
1400252c8      [0x2] =  0x5001
1400252ca  }

1400252ca                                00 00                                                                        ..

1400252cc  struct UNWIND_INFO data_1400252cc = 
1400252cc  {
1400252cc      uint8_t VersionAndFlag = 0x1
1400252cd      uint8_t SizeOfProlog = 0xb
1400252ce      uint8_t CountOfUnwindCodes = 0x4
1400252cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x55
1400252d0  }
1400252d0  uint16_t data_1400252d0[0x4] = 
1400252d0  {
1400252d0      [0x0] =  0x030b
1400252d2      [0x1] =  0xa206
1400252d4      [0x2] =  0x3002
1400252d6      [0x3] =  0x5001
1400252d8  }
1400252d8  struct UNWIND_INFO data_1400252d8 = 
1400252d8  {
1400252d8      uint8_t VersionAndFlag = 0x1
1400252d9      uint8_t SizeOfProlog = 0x8
1400252da      uint8_t CountOfUnwindCodes = 0x3
1400252db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400252dc  }
1400252dc  uint16_t data_1400252dc[0x3] = 
1400252dc  {
1400252dc      [0x0] =  0x1208
1400252de      [0x1] =  0x0304
1400252e0      [0x2] =  0x5001
1400252e2  }

1400252e2        00 00                                                                                        ..

1400252e4  struct UNWIND_INFO data_1400252e4 = 
1400252e4  {
1400252e4      uint8_t VersionAndFlag = 0x1
1400252e5      uint8_t SizeOfProlog = 0x8
1400252e6      uint8_t CountOfUnwindCodes = 0x3
1400252e7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400252e8  }
1400252e8  uint16_t data_1400252e8[0x3] = 
1400252e8  {
1400252e8      [0x0] =  0x5208
1400252ea      [0x1] =  0x0304
1400252ec      [0x2] =  0x5001
1400252ee  }

1400252ee                                            00 00                                                                ..

1400252f0  struct UNWIND_INFO data_1400252f0 = 
1400252f0  {
1400252f0      uint8_t VersionAndFlag = 0x1
1400252f1      uint8_t SizeOfProlog = 0x8
1400252f2      uint8_t CountOfUnwindCodes = 0x3
1400252f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400252f4  }
1400252f4  uint16_t data_1400252f4[0x3] = 
1400252f4  {
1400252f4      [0x0] =  0x3208
1400252f6      [0x1] =  0x0304
1400252f8      [0x2] =  0x5001
1400252fa  }

1400252fa                                                                                00 00                                        ..

1400252fc  struct UNWIND_INFO data_1400252fc = 
1400252fc  {
1400252fc      uint8_t VersionAndFlag = 0x1
1400252fd      uint8_t SizeOfProlog = 0x8
1400252fe      uint8_t CountOfUnwindCodes = 0x3
1400252ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025300  }
140025300  uint16_t data_140025300[0x3] = 
140025300  {
140025300      [0x0] =  0x3208
140025302      [0x1] =  0x0304
140025304      [0x2] =  0x5001
140025306  }

140025306                    00 00                                                                                ..

140025308  struct UNWIND_INFO data_140025308 = 
140025308  {
140025308      uint8_t VersionAndFlag = 0x1
140025309      uint8_t SizeOfProlog = 0x10
14002530a      uint8_t CountOfUnwindCodes = 0x4
14002530b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x85
14002530c  }
14002530c  uint16_t data_14002530c[0x4] = 
14002530c  {
14002530c      [0x0] =  0x0310
14002530e      [0x1] =  0x0108
140025310      [0x2] =  0x0022
140025312      [0x3] =  0x5001
140025314  }
140025314  struct UNWIND_INFO data_140025314 = 
140025314  {
140025314      uint8_t VersionAndFlag = 0x1
140025315      uint8_t SizeOfProlog = 0x11
140025316      uint8_t CountOfUnwindCodes = 0x5
140025317      uint8_t FrameRegisterAndFrameRegisterOffset = 0xe5
140025318  }
140025318  uint16_t data_140025318[0x5] = 
140025318  {
140025318      [0x0] =  0x0311
14002531a      [0x1] =  0x0109
14002531c      [0x2] =  0x001d
14002531e      [0x3] =  0x3002
140025320      [0x4] =  0x5001
140025322  }

140025322        00 00                                                                                        ..

140025324  struct UNWIND_INFO data_140025324 = 
140025324  {
140025324      uint8_t VersionAndFlag = 0x1
140025325      uint8_t SizeOfProlog = 0x8
140025326      uint8_t CountOfUnwindCodes = 0x3
140025327      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025328  }
140025328  uint16_t data_140025328[0x3] = 
140025328  {
140025328      [0x0] =  0xb208
14002532a      [0x1] =  0x0304
14002532c      [0x2] =  0x5001
14002532e  }

14002532e                                            00 00                                                                ..
140025330  _.xdata:
140025330                                                  01 08 03 05                                                      ....
140025334  uint16_t data_140025334[0x3] = 
140025334  {
140025334      [0x0] =  0x3208
140025336      [0x1] =  0x0304
140025338      [0x2] =  0x5001
14002533a  }

14002533a                                                                                00 00                                        ..

14002533c  struct UNWIND_INFO data_14002533c = 
14002533c  {
14002533c      uint8_t VersionAndFlag = 0x1
14002533d      uint8_t SizeOfProlog = 0x8
14002533e      uint8_t CountOfUnwindCodes = 0x3
14002533f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025340  }
140025340  uint16_t data_140025340[0x3] = 
140025340  {
140025340      [0x0] =  0x3208
140025342      [0x1] =  0x0304
140025344      [0x2] =  0x5001
140025346  }

140025346                    00 00                                                                                ..

140025348  struct UNWIND_INFO data_140025348 = 
140025348  {
140025348      uint8_t VersionAndFlag = 0x1
140025349      uint8_t SizeOfProlog = 0x8
14002534a      uint8_t CountOfUnwindCodes = 0x3
14002534b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002534c  }
14002534c  uint16_t data_14002534c[0x3] = 
14002534c  {
14002534c      [0x0] =  0xb208
14002534e      [0x1] =  0x0304
140025350      [0x2] =  0x5001
140025352  }

140025352                                                        00 00                                                        ..

140025354  struct UNWIND_INFO data_140025354 = 
140025354  {
140025354      uint8_t VersionAndFlag = 0x1
140025355      uint8_t SizeOfProlog = 0x8
140025356      uint8_t CountOfUnwindCodes = 0x3
140025357      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025358  }
140025358  uint16_t data_140025358[0x3] = 
140025358  {
140025358      [0x0] =  0x5208
14002535a      [0x1] =  0x0304
14002535c      [0x2] =  0x5001
14002535e  }

14002535e                                                                                            00 00                                ..

140025360  struct UNWIND_INFO data_140025360 = 
140025360  {
140025360      uint8_t VersionAndFlag = 0x1
140025361      uint8_t SizeOfProlog = 0x8
140025362      uint8_t CountOfUnwindCodes = 0x3
140025363      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025364  }
140025364  uint16_t data_140025364[0x3] = 
140025364  {
140025364      [0x0] =  0x5208
140025366      [0x1] =  0x0304
140025368      [0x2] =  0x5001
14002536a  }

14002536a                                00 00                                                                        ..

14002536c  struct UNWIND_INFO data_14002536c = 
14002536c  {
14002536c      uint8_t VersionAndFlag = 0x1
14002536d      uint8_t SizeOfProlog = 0x8
14002536e      uint8_t CountOfUnwindCodes = 0x3
14002536f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025370  }
140025370  uint16_t data_140025370[0x3] = 
140025370  {
140025370      [0x0] =  0x5208
140025372      [0x1] =  0x0304
140025374      [0x2] =  0x5001
140025376  }

140025376                                                                    00 00                                                ..

140025378  struct UNWIND_INFO data_140025378 = 
140025378  {
140025378      uint8_t VersionAndFlag = 0x1
140025379      uint8_t SizeOfProlog = 0x8
14002537a      uint8_t CountOfUnwindCodes = 0x3
14002537b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002537c  }
14002537c  uint16_t data_14002537c[0x3] = 
14002537c  {
14002537c      [0x0] =  0xb208
14002537e      [0x1] =  0x0304
140025380      [0x2] =  0x5001
140025382  }

140025382        00 00                                                                                        ..

140025384  struct UNWIND_INFO data_140025384 = 
140025384  {
140025384      uint8_t VersionAndFlag = 0x1
140025385      uint8_t SizeOfProlog = 0xb
140025386      uint8_t CountOfUnwindCodes = 0x4
140025387      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025388  }
140025388  uint16_t data_140025388[0x4] = 
140025388  {
140025388      [0x0] =  0x010b
14002538a      [0x1] =  0x0014
14002538c      [0x2] =  0x0304
14002538e      [0x3] =  0x5001
140025390  }
140025390  struct UNWIND_INFO data_140025390 = 
140025390  {
140025390      uint8_t VersionAndFlag = 0x1
140025391      uint8_t SizeOfProlog = 0x8
140025392      uint8_t CountOfUnwindCodes = 0x3
140025393      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025394  }
140025394  uint16_t data_140025394[0x3] = 
140025394  {
140025394      [0x0] =  0x5208
140025396      [0x1] =  0x0304
140025398      [0x2] =  0x5001
14002539a  }

14002539a                                                                                00 00                                        ..
14002539c  _.xdata:
14002539c                                                                                      01 08 03 05                              ....
1400253a0  uint16_t data_1400253a0[0x3] = 
1400253a0  {
1400253a0      [0x0] =  0x5208
1400253a2      [0x1] =  0x0304
1400253a4      [0x2] =  0x5001
1400253a6  }

1400253a6                    00 00                                                                                ..

1400253a8  struct UNWIND_INFO data_1400253a8 = 
1400253a8  {
1400253a8      uint8_t VersionAndFlag = 0x1
1400253a9      uint8_t SizeOfProlog = 0xb
1400253aa      uint8_t CountOfUnwindCodes = 0x4
1400253ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x35
1400253ac  }
1400253ac  uint16_t data_1400253ac[0x4] = 
1400253ac  {
1400253ac      [0x0] =  0x030b
1400253ae      [0x1] =  0x6206
1400253b0      [0x2] =  0x3002
1400253b2      [0x3] =  0x5001
1400253b4  }
1400253b4  struct UNWIND_INFO data_1400253b4 = 
1400253b4  {
1400253b4      uint8_t VersionAndFlag = 0x1
1400253b5      uint8_t SizeOfProlog = 0xb
1400253b6      uint8_t CountOfUnwindCodes = 0x4
1400253b7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x25
1400253b8  }
1400253b8  uint16_t data_1400253b8[0x4] = 
1400253b8  {
1400253b8      [0x0] =  0x030b
1400253ba      [0x1] =  0x4206
1400253bc      [0x2] =  0x3002
1400253be      [0x3] =  0x5001
1400253c0  }
1400253c0  struct UNWIND_INFO data_1400253c0 = 
1400253c0  {
1400253c0      uint8_t VersionAndFlag = 0x1
1400253c1      uint8_t SizeOfProlog = 0xb
1400253c2      uint8_t CountOfUnwindCodes = 0x4
1400253c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x55
1400253c4  }
1400253c4  uint16_t data_1400253c4[0x4] = 
1400253c4  {
1400253c4      [0x0] =  0x030b
1400253c6      [0x1] =  0xa206
1400253c8      [0x2] =  0x3002
1400253ca      [0x3] =  0x5001
1400253cc  }
1400253cc  struct UNWIND_INFO data_1400253cc = 
1400253cc  {
1400253cc      uint8_t VersionAndFlag = 0x1
1400253cd      uint8_t SizeOfProlog = 0x8
1400253ce      uint8_t CountOfUnwindCodes = 0x3
1400253cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400253d0  }
1400253d0  uint16_t data_1400253d0[0x3] = 
1400253d0  {
1400253d0      [0x0] =  0x7208
1400253d2      [0x1] =  0x0304
1400253d4      [0x2] =  0x5001
1400253d6  }

1400253d6                                                                    00 00                                                ..

1400253d8  struct UNWIND_INFO data_1400253d8 = 
1400253d8  {
1400253d8      uint8_t VersionAndFlag = 0x1
1400253d9      uint8_t SizeOfProlog = 0xb
1400253da      uint8_t CountOfUnwindCodes = 0x4
1400253db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x55
1400253dc  }
1400253dc  uint16_t data_1400253dc[0x4] = 
1400253dc  {
1400253dc      [0x0] =  0x030b
1400253de      [0x1] =  0xa206
1400253e0      [0x2] =  0x3002
1400253e2      [0x3] =  0x5001
1400253e4  }
1400253e4  struct UNWIND_INFO data_1400253e4 = 
1400253e4  {
1400253e4      uint8_t VersionAndFlag = 0x1
1400253e5      uint8_t SizeOfProlog = 0x8
1400253e6      uint8_t CountOfUnwindCodes = 0x3
1400253e7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400253e8  }
1400253e8  uint16_t data_1400253e8[0x3] = 
1400253e8  {
1400253e8      [0x0] =  0x5208
1400253ea      [0x1] =  0x0304
1400253ec      [0x2] =  0x5001
1400253ee  }

1400253ee                                            00 00                                                                ..

1400253f0  struct UNWIND_INFO data_1400253f0 = 
1400253f0  {
1400253f0      uint8_t VersionAndFlag = 0x1
1400253f1      uint8_t SizeOfProlog = 0x8
1400253f2      uint8_t CountOfUnwindCodes = 0x3
1400253f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400253f4  }
1400253f4  uint16_t data_1400253f4[0x3] = 
1400253f4  {
1400253f4      [0x0] =  0x5208
1400253f6      [0x1] =  0x0304
1400253f8      [0x2] =  0x5001
1400253fa  }

1400253fa                                                                                00 00                                        ..

1400253fc  struct UNWIND_INFO data_1400253fc = 
1400253fc  {
1400253fc      uint8_t VersionAndFlag = 0x1
1400253fd      uint8_t SizeOfProlog = 0x8
1400253fe      uint8_t CountOfUnwindCodes = 0x3
1400253ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025400  }
140025400  uint16_t data_140025400[0x3] = 
140025400  {
140025400      [0x0] =  0x5208
140025402      [0x1] =  0x0304
140025404      [0x2] =  0x5001
140025406  }

140025406                    00 00                                                                                ..

140025408  struct UNWIND_INFO data_140025408 = 
140025408  {
140025408      uint8_t VersionAndFlag = 0x1
140025409      uint8_t SizeOfProlog = 0x8
14002540a      uint8_t CountOfUnwindCodes = 0x3
14002540b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002540c  }
14002540c  uint16_t data_14002540c[0x3] = 
14002540c  {
14002540c      [0x0] =  0x5208
14002540e      [0x1] =  0x0304
140025410      [0x2] =  0x5001
140025412  }

140025412                                                        00 00                                                        ..

140025414  struct UNWIND_INFO data_140025414 = 
140025414  {
140025414      uint8_t VersionAndFlag = 0x1
140025415      uint8_t SizeOfProlog = 0x8
140025416      uint8_t CountOfUnwindCodes = 0x3
140025417      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025418  }
140025418  uint16_t data_140025418[0x3] = 
140025418  {
140025418      [0x0] =  0x3208
14002541a      [0x1] =  0x0304
14002541c      [0x2] =  0x5001
14002541e  }

14002541e                                                                                            00 00                                ..

140025420  struct UNWIND_INFO data_140025420 = 
140025420  {
140025420      uint8_t VersionAndFlag = 0x1
140025421      uint8_t SizeOfProlog = 0x8
140025422      uint8_t CountOfUnwindCodes = 0x3
140025423      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025424  }
140025424  uint16_t data_140025424[0x3] = 
140025424  {
140025424      [0x0] =  0x3208
140025426      [0x1] =  0x0304
140025428      [0x2] =  0x5001
14002542a  }

14002542a                                00 00                                                                        ..

14002542c  struct UNWIND_INFO data_14002542c = 
14002542c  {
14002542c      uint8_t VersionAndFlag = 0x1
14002542d      uint8_t SizeOfProlog = 0x11
14002542e      uint8_t CountOfUnwindCodes = 0x5
14002542f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x85
140025430  }
140025430  uint16_t data_140025430[0x5] = 
140025430  {
140025430      [0x0] =  0x0311
140025432      [0x1] =  0x0109
140025434      [0x2] =  0x0011
140025436      [0x3] =  0x3002
140025438      [0x4] =  0x5001
14002543a  }

14002543a                                                                                00 00                                        ..

14002543c  struct UNWIND_INFO data_14002543c = 
14002543c  {
14002543c      uint8_t VersionAndFlag = 0x1
14002543d      uint8_t SizeOfProlog = 0x8
14002543e      uint8_t CountOfUnwindCodes = 0x3
14002543f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025440  }
140025440  uint16_t data_140025440[0x3] = 
140025440  {
140025440      [0x0] =  0xb208
140025442      [0x1] =  0x0304
140025444      [0x2] =  0x5001
140025446  }

140025446                    00 00                                                                                ..

140025448  struct UNWIND_INFO data_140025448 = 
140025448  {
140025448      uint8_t VersionAndFlag = 0x1
140025449      uint8_t SizeOfProlog = 0xb
14002544a      uint8_t CountOfUnwindCodes = 0x4
14002544b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002544c  }
14002544c  uint16_t data_14002544c[0x4] = 
14002544c  {
14002544c      [0x0] =  0x010b
14002544e      [0x1] =  0x0012
140025450      [0x2] =  0x0304
140025452      [0x3] =  0x5001
140025454  }
140025454  struct UNWIND_INFO data_140025454 = 
140025454  {
140025454      uint8_t VersionAndFlag = 0x1
140025455      uint8_t SizeOfProlog = 0x8
140025456      uint8_t CountOfUnwindCodes = 0x3
140025457      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025458  }
140025458  uint16_t data_140025458[0x3] = 
140025458  {
140025458      [0x0] =  0xd208
14002545a      [0x1] =  0x0304
14002545c      [0x2] =  0x5001
14002545e  }

14002545e                                                                                            00 00                                ..

140025460  struct UNWIND_INFO data_140025460 = 
140025460  {
140025460      uint8_t VersionAndFlag = 0x1
140025461      uint8_t SizeOfProlog = 0x8
140025462      uint8_t CountOfUnwindCodes = 0x3
140025463      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025464  }
140025464  uint16_t data_140025464[0x3] = 
140025464  {
140025464      [0x0] =  0xb208
140025466      [0x1] =  0x0304
140025468      [0x2] =  0x5001
14002546a  }

14002546a                                00 00                                                                        ..

14002546c  struct UNWIND_INFO data_14002546c = 
14002546c  {
14002546c      uint8_t VersionAndFlag = 0x1
14002546d      uint8_t SizeOfProlog = 0x8
14002546e      uint8_t CountOfUnwindCodes = 0x3
14002546f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025470  }
140025470  uint16_t data_140025470[0x3] = 
140025470  {
140025470      [0x0] =  0xb208
140025472      [0x1] =  0x0304
140025474      [0x2] =  0x5001
140025476  }

140025476                                                                    00 00                                                ..

140025478  struct UNWIND_INFO data_140025478 = 
140025478  {
140025478      uint8_t VersionAndFlag = 0x1
140025479      uint8_t SizeOfProlog = 0x8
14002547a      uint8_t CountOfUnwindCodes = 0x3
14002547b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002547c  }
14002547c  uint16_t data_14002547c[0x3] = 
14002547c  {
14002547c      [0x0] =  0x9208
14002547e      [0x1] =  0x0304
140025480      [0x2] =  0x5001
140025482  }

140025482        00 00                                                                                        ..

140025484  struct UNWIND_INFO data_140025484 = 
140025484  {
140025484      uint8_t VersionAndFlag = 0x1
140025485      uint8_t SizeOfProlog = 0x8
140025486      uint8_t CountOfUnwindCodes = 0x3
140025487      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025488  }
140025488  uint16_t data_140025488[0x3] = 
140025488  {
140025488      [0x0] =  0xb208
14002548a      [0x1] =  0x0304
14002548c      [0x2] =  0x5001
14002548e  }

14002548e                                            00 00                                                                ..

140025490  struct UNWIND_INFO data_140025490 = 
140025490  {
140025490      uint8_t VersionAndFlag = 0x1
140025491      uint8_t SizeOfProlog = 0x8
140025492      uint8_t CountOfUnwindCodes = 0x3
140025493      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025494  }
140025494  uint16_t data_140025494[0x3] = 
140025494  {
140025494      [0x0] =  0xb208
140025496      [0x1] =  0x0304
140025498      [0x2] =  0x5001
14002549a  }

14002549a                                                                                00 00                                        ..

14002549c  struct UNWIND_INFO data_14002549c = 
14002549c  {
14002549c      uint8_t VersionAndFlag = 0x1
14002549d      uint8_t SizeOfProlog = 0x8
14002549e      uint8_t CountOfUnwindCodes = 0x3
14002549f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400254a0  }
1400254a0  uint16_t data_1400254a0[0x3] = 
1400254a0  {
1400254a0      [0x0] =  0xb208
1400254a2      [0x1] =  0x0304
1400254a4      [0x2] =  0x5001
1400254a6  }

1400254a6                    00 00                                                                                ..

1400254a8  struct UNWIND_INFO data_1400254a8 = 
1400254a8  {
1400254a8      uint8_t VersionAndFlag = 0x1
1400254a9      uint8_t SizeOfProlog = 0x8
1400254aa      uint8_t CountOfUnwindCodes = 0x3
1400254ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400254ac  }
1400254ac  uint16_t data_1400254ac[0x3] = 
1400254ac  {
1400254ac      [0x0] =  0xb208
1400254ae      [0x1] =  0x0304
1400254b0      [0x2] =  0x5001
1400254b2  }

1400254b2                                                        00 00                                                        ..

1400254b4  struct UNWIND_INFO data_1400254b4 = 
1400254b4  {
1400254b4      uint8_t VersionAndFlag = 0x1
1400254b5      uint8_t SizeOfProlog = 0x8
1400254b6      uint8_t CountOfUnwindCodes = 0x3
1400254b7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400254b8  }
1400254b8  uint16_t data_1400254b8[0x3] = 
1400254b8  {
1400254b8      [0x0] =  0x9208
1400254ba      [0x1] =  0x0304
1400254bc      [0x2] =  0x5001
1400254be  }

1400254be                                                                                            00 00                                ..

1400254c0  struct UNWIND_INFO data_1400254c0 = 
1400254c0  {
1400254c0      uint8_t VersionAndFlag = 0x1
1400254c1      uint8_t SizeOfProlog = 0x8
1400254c2      uint8_t CountOfUnwindCodes = 0x3
1400254c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400254c4  }
1400254c4  uint16_t data_1400254c4[0x3] = 
1400254c4  {
1400254c4      [0x0] =  0x3208
1400254c6      [0x1] =  0x0304
1400254c8      [0x2] =  0x5001
1400254ca  }

1400254ca                                00 00                                                                        ..

1400254cc  struct UNWIND_INFO data_1400254cc = 
1400254cc  {
1400254cc      uint8_t VersionAndFlag = 0x1
1400254cd      uint8_t SizeOfProlog = 0x8
1400254ce      uint8_t CountOfUnwindCodes = 0x3
1400254cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400254d0  }
1400254d0  uint16_t data_1400254d0[0x3] = 
1400254d0  {
1400254d0      [0x0] =  0xd208
1400254d2      [0x1] =  0x0304
1400254d4      [0x2] =  0x5001
1400254d6  }

1400254d6                                                                    00 00                                                ..

1400254d8  struct UNWIND_INFO data_1400254d8 = 
1400254d8  {
1400254d8      uint8_t VersionAndFlag = 0x1
1400254d9      uint8_t SizeOfProlog = 0xb
1400254da      uint8_t CountOfUnwindCodes = 0x4
1400254db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400254dc  }
1400254dc  uint16_t data_1400254dc[0x4] = 
1400254dc  {
1400254dc      [0x0] =  0x010b
1400254de      [0x1] =  0x0014
1400254e0      [0x2] =  0x0304
1400254e2      [0x3] =  0x5001
1400254e4  }
1400254e4  struct UNWIND_INFO data_1400254e4 = 
1400254e4  {
1400254e4      uint8_t VersionAndFlag = 0x1
1400254e5      uint8_t SizeOfProlog = 0x8
1400254e6      uint8_t CountOfUnwindCodes = 0x3
1400254e7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400254e8  }
1400254e8  uint16_t data_1400254e8[0x3] = 
1400254e8  {
1400254e8      [0x0] =  0xb208
1400254ea      [0x1] =  0x0304
1400254ec      [0x2] =  0x5001
1400254ee  }

1400254ee                                            00 00                                                                ..

1400254f0  struct UNWIND_INFO data_1400254f0 = 
1400254f0  {
1400254f0      uint8_t VersionAndFlag = 0x1
1400254f1      uint8_t SizeOfProlog = 0x8
1400254f2      uint8_t CountOfUnwindCodes = 0x3
1400254f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400254f4  }
1400254f4  uint16_t data_1400254f4[0x3] = 
1400254f4  {
1400254f4      [0x0] =  0xb208
1400254f6      [0x1] =  0x0304
1400254f8      [0x2] =  0x5001
1400254fa  }

1400254fa                                                                                00 00                                        ..

1400254fc  struct UNWIND_INFO data_1400254fc = 
1400254fc  {
1400254fc      uint8_t VersionAndFlag = 0x1
1400254fd      uint8_t SizeOfProlog = 0x8
1400254fe      uint8_t CountOfUnwindCodes = 0x3
1400254ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025500  }
140025500  uint16_t data_140025500[0x3] = 
140025500  {
140025500      [0x0] =  0xd208
140025502      [0x1] =  0x0304
140025504      [0x2] =  0x5001
140025506  }

140025506                    00 00                                                                                ..

140025508  struct UNWIND_INFO data_140025508 = 
140025508  {
140025508      uint8_t VersionAndFlag = 0x1
140025509      uint8_t SizeOfProlog = 0x8
14002550a      uint8_t CountOfUnwindCodes = 0x3
14002550b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002550c  }
14002550c  uint16_t data_14002550c[0x3] = 
14002550c  {
14002550c      [0x0] =  0xb208
14002550e      [0x1] =  0x0304
140025510      [0x2] =  0x5001
140025512  }

140025512                                                        00 00                                                        ..

140025514  struct UNWIND_INFO data_140025514 = 
140025514  {
140025514      uint8_t VersionAndFlag = 0x1
140025515      uint8_t SizeOfProlog = 0x8
140025516      uint8_t CountOfUnwindCodes = 0x3
140025517      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025518  }
140025518  uint16_t data_140025518[0x3] = 
140025518  {
140025518      [0x0] =  0xb208
14002551a      [0x1] =  0x0304
14002551c      [0x2] =  0x5001
14002551e  }

14002551e                                                                                            00 00                                ..

140025520  struct UNWIND_INFO data_140025520 = 
140025520  {
140025520      uint8_t VersionAndFlag = 0x1
140025521      uint8_t SizeOfProlog = 0xb
140025522      uint8_t CountOfUnwindCodes = 0x4
140025523      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025524  }
140025524  uint16_t data_140025524[0x4] = 
140025524  {
140025524      [0x0] =  0x010b
140025526      [0x1] =  0x001e
140025528      [0x2] =  0x0304
14002552a      [0x3] =  0x5001
14002552c  }
14002552c  struct UNWIND_INFO data_14002552c = 
14002552c  {
14002552c      uint8_t VersionAndFlag = 0x1
14002552d      uint8_t SizeOfProlog = 0x8
14002552e      uint8_t CountOfUnwindCodes = 0x3
14002552f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025530  }
140025530  uint16_t data_140025530[0x3] = 
140025530  {
140025530      [0x0] =  0xb208
140025532      [0x1] =  0x0304
140025534      [0x2] =  0x5001
140025536  }

140025536                                                                    00 00                                                ..

140025538  struct UNWIND_INFO data_140025538 = 
140025538  {
140025538      uint8_t VersionAndFlag = 0x1
140025539      uint8_t SizeOfProlog = 0x8
14002553a      uint8_t CountOfUnwindCodes = 0x3
14002553b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002553c  }
14002553c  uint16_t data_14002553c[0x3] = 
14002553c  {
14002553c      [0x0] =  0xb208
14002553e      [0x1] =  0x0304
140025540      [0x2] =  0x5001
140025542  }

140025542        00 00                                                                                        ..

140025544  struct UNWIND_INFO data_140025544 = 
140025544  {
140025544      uint8_t VersionAndFlag = 0x1
140025545      uint8_t SizeOfProlog = 0x8
140025546      uint8_t CountOfUnwindCodes = 0x3
140025547      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025548  }
140025548  uint16_t data_140025548[0x3] = 
140025548  {
140025548      [0x0] =  0xd208
14002554a      [0x1] =  0x0304
14002554c      [0x2] =  0x5001
14002554e  }

14002554e                                            00 00                                                                ..

140025550  struct UNWIND_INFO data_140025550 = 
140025550  {
140025550      uint8_t VersionAndFlag = 0x1
140025551      uint8_t SizeOfProlog = 0x8
140025552      uint8_t CountOfUnwindCodes = 0x3
140025553      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025554  }
140025554  uint16_t data_140025554[0x3] = 
140025554  {
140025554      [0x0] =  0xb208
140025556      [0x1] =  0x0304
140025558      [0x2] =  0x5001
14002555a  }

14002555a                                                                                00 00                                        ..

14002555c  struct UNWIND_INFO data_14002555c = 
14002555c  {
14002555c      uint8_t VersionAndFlag = 0x1
14002555d      uint8_t SizeOfProlog = 0x8
14002555e      uint8_t CountOfUnwindCodes = 0x3
14002555f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025560  }
140025560  uint16_t data_140025560[0x3] = 
140025560  {
140025560      [0x0] =  0xb208
140025562      [0x1] =  0x0304
140025564      [0x2] =  0x5001
140025566  }

140025566                    00 00                                                                                ..

140025568  struct UNWIND_INFO data_140025568 = 
140025568  {
140025568      uint8_t VersionAndFlag = 0x1
140025569      uint8_t SizeOfProlog = 0x8
14002556a      uint8_t CountOfUnwindCodes = 0x3
14002556b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002556c  }
14002556c  uint16_t data_14002556c[0x3] = 
14002556c  {
14002556c      [0x0] =  0xd208
14002556e      [0x1] =  0x0304
140025570      [0x2] =  0x5001
140025572  }

140025572                                                        00 00                                                        ..

140025574  struct UNWIND_INFO data_140025574 = 
140025574  {
140025574      uint8_t VersionAndFlag = 0x1
140025575      uint8_t SizeOfProlog = 0x8
140025576      uint8_t CountOfUnwindCodes = 0x3
140025577      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025578  }
140025578  uint16_t data_140025578[0x3] = 
140025578  {
140025578      [0x0] =  0xb208
14002557a      [0x1] =  0x0304
14002557c      [0x2] =  0x5001
14002557e  }

14002557e                                                                                            00 00                                ..

140025580  struct UNWIND_INFO data_140025580 = 
140025580  {
140025580      uint8_t VersionAndFlag = 0x1
140025581      uint8_t SizeOfProlog = 0x8
140025582      uint8_t CountOfUnwindCodes = 0x3
140025583      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025584  }
140025584  uint16_t data_140025584[0x3] = 
140025584  {
140025584      [0x0] =  0x9208
140025586      [0x1] =  0x0304
140025588      [0x2] =  0x5001
14002558a  }

14002558a                                00 00                                                                        ..

14002558c  struct UNWIND_INFO data_14002558c = 
14002558c  {
14002558c      uint8_t VersionAndFlag = 0x1
14002558d      uint8_t SizeOfProlog = 0x8
14002558e      uint8_t CountOfUnwindCodes = 0x3
14002558f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025590  }
140025590  uint16_t data_140025590[0x3] = 
140025590  {
140025590      [0x0] =  0xd208
140025592      [0x1] =  0x0304
140025594      [0x2] =  0x5001
140025596  }

140025596                                                                    00 00                                                ..

140025598  struct UNWIND_INFO data_140025598 = 
140025598  {
140025598      uint8_t VersionAndFlag = 0x1
140025599      uint8_t SizeOfProlog = 0x8
14002559a      uint8_t CountOfUnwindCodes = 0x3
14002559b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002559c  }
14002559c  uint16_t data_14002559c[0x3] = 
14002559c  {
14002559c      [0x0] =  0xb208
14002559e      [0x1] =  0x0304
1400255a0      [0x2] =  0x5001
1400255a2  }

1400255a2        00 00                                                                                        ..

1400255a4  struct UNWIND_INFO data_1400255a4 = 
1400255a4  {
1400255a4      uint8_t VersionAndFlag = 0x1
1400255a5      uint8_t SizeOfProlog = 0x8
1400255a6      uint8_t CountOfUnwindCodes = 0x3
1400255a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400255a8  }
1400255a8  uint16_t data_1400255a8[0x3] = 
1400255a8  {
1400255a8      [0x0] =  0x9208
1400255aa      [0x1] =  0x0304
1400255ac      [0x2] =  0x5001
1400255ae  }

1400255ae                                            00 00                                                                ..

1400255b0  struct UNWIND_INFO data_1400255b0 = 
1400255b0  {
1400255b0      uint8_t VersionAndFlag = 0x1
1400255b1      uint8_t SizeOfProlog = 0x8
1400255b2      uint8_t CountOfUnwindCodes = 0x3
1400255b3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400255b4  }
1400255b4  uint16_t data_1400255b4[0x3] = 
1400255b4  {
1400255b4      [0x0] =  0x9208
1400255b6      [0x1] =  0x0304
1400255b8      [0x2] =  0x5001
1400255ba  }

1400255ba                                                                                00 00                                        ..

1400255bc  struct UNWIND_INFO data_1400255bc = 
1400255bc  {
1400255bc      uint8_t VersionAndFlag = 0x1
1400255bd      uint8_t SizeOfProlog = 0x8
1400255be      uint8_t CountOfUnwindCodes = 0x3
1400255bf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400255c0  }
1400255c0  uint16_t data_1400255c0[0x3] = 
1400255c0  {
1400255c0      [0x0] =  0xf208
1400255c2      [0x1] =  0x0304
1400255c4      [0x2] =  0x5001
1400255c6  }

1400255c6                    00 00                                                                                ..

1400255c8  struct UNWIND_INFO data_1400255c8 = 
1400255c8  {
1400255c8      uint8_t VersionAndFlag = 0x1
1400255c9      uint8_t SizeOfProlog = 0x8
1400255ca      uint8_t CountOfUnwindCodes = 0x3
1400255cb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400255cc  }
1400255cc  uint16_t data_1400255cc[0x3] = 
1400255cc  {
1400255cc      [0x0] =  0xb208
1400255ce      [0x1] =  0x0304
1400255d0      [0x2] =  0x5001
1400255d2  }

1400255d2                                                        00 00                                                        ..

1400255d4  struct UNWIND_INFO data_1400255d4 = 
1400255d4  {
1400255d4      uint8_t VersionAndFlag = 0x1
1400255d5      uint8_t SizeOfProlog = 0x8
1400255d6      uint8_t CountOfUnwindCodes = 0x3
1400255d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400255d8  }
1400255d8  uint16_t data_1400255d8[0x3] = 
1400255d8  {
1400255d8      [0x0] =  0xb208
1400255da      [0x1] =  0x0304
1400255dc      [0x2] =  0x5001
1400255de  }

1400255de                                                                                            00 00                                ..

1400255e0  struct UNWIND_INFO data_1400255e0 = 
1400255e0  {
1400255e0      uint8_t VersionAndFlag = 0x1
1400255e1      uint8_t SizeOfProlog = 0x8
1400255e2      uint8_t CountOfUnwindCodes = 0x3
1400255e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400255e4  }
1400255e4  uint16_t data_1400255e4[0x3] = 
1400255e4  {
1400255e4      [0x0] =  0xd208
1400255e6      [0x1] =  0x0304
1400255e8      [0x2] =  0x5001
1400255ea  }

1400255ea                                00 00                                                                        ..

1400255ec  struct UNWIND_INFO data_1400255ec = 
1400255ec  {
1400255ec      uint8_t VersionAndFlag = 0x1
1400255ed      uint8_t SizeOfProlog = 0x8
1400255ee      uint8_t CountOfUnwindCodes = 0x3
1400255ef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400255f0  }
1400255f0  uint16_t data_1400255f0[0x3] = 
1400255f0  {
1400255f0      [0x0] =  0x9208
1400255f2      [0x1] =  0x0304
1400255f4      [0x2] =  0x5001
1400255f6  }

1400255f6                                                                    00 00                                                ..

1400255f8  struct UNWIND_INFO data_1400255f8 = 
1400255f8  {
1400255f8      uint8_t VersionAndFlag = 0x1
1400255f9      uint8_t SizeOfProlog = 0x8
1400255fa      uint8_t CountOfUnwindCodes = 0x3
1400255fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400255fc  }
1400255fc  uint16_t data_1400255fc[0x3] = 
1400255fc  {
1400255fc      [0x0] =  0x9208
1400255fe      [0x1] =  0x0304
140025600      [0x2] =  0x5001
140025602  }

140025602        00 00                                                                                        ..

140025604  struct UNWIND_INFO data_140025604 = 
140025604  {
140025604      uint8_t VersionAndFlag = 0x1
140025605      uint8_t SizeOfProlog = 0x8
140025606      uint8_t CountOfUnwindCodes = 0x3
140025607      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025608  }
140025608  uint16_t data_140025608[0x3] = 
140025608  {
140025608      [0x0] =  0xb208
14002560a      [0x1] =  0x0304
14002560c      [0x2] =  0x5001
14002560e  }

14002560e                                            00 00                                                                ..

140025610  struct UNWIND_INFO data_140025610 = 
140025610  {
140025610      uint8_t VersionAndFlag = 0x1
140025611      uint8_t SizeOfProlog = 0x8
140025612      uint8_t CountOfUnwindCodes = 0x3
140025613      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025614  }
140025614  uint16_t data_140025614[0x3] = 
140025614  {
140025614      [0x0] =  0x9208
140025616      [0x1] =  0x0304
140025618      [0x2] =  0x5001
14002561a  }

14002561a                                                                                00 00                                        ..

14002561c  struct UNWIND_INFO data_14002561c = 
14002561c  {
14002561c      uint8_t VersionAndFlag = 0x1
14002561d      uint8_t SizeOfProlog = 0x8
14002561e      uint8_t CountOfUnwindCodes = 0x3
14002561f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025620  }
140025620  uint16_t data_140025620[0x3] = 
140025620  {
140025620      [0x0] =  0xb208
140025622      [0x1] =  0x0304
140025624      [0x2] =  0x5001
140025626  }

140025626                    00 00                                                                                ..

140025628  struct UNWIND_INFO data_140025628 = 
140025628  {
140025628      uint8_t VersionAndFlag = 0x1
140025629      uint8_t SizeOfProlog = 0x8
14002562a      uint8_t CountOfUnwindCodes = 0x3
14002562b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002562c  }
14002562c  uint16_t data_14002562c[0x3] = 
14002562c  {
14002562c      [0x0] =  0xb208
14002562e      [0x1] =  0x0304
140025630      [0x2] =  0x5001
140025632  }

140025632                                                        00 00                                                        ..

140025634  struct UNWIND_INFO data_140025634 = 
140025634  {
140025634      uint8_t VersionAndFlag = 0x1
140025635      uint8_t SizeOfProlog = 0x8
140025636      uint8_t CountOfUnwindCodes = 0x3
140025637      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025638  }
140025638  uint16_t data_140025638[0x3] = 
140025638  {
140025638      [0x0] =  0xb208
14002563a      [0x1] =  0x0304
14002563c      [0x2] =  0x5001
14002563e  }

14002563e                                                                                            00 00                                ..

140025640  struct UNWIND_INFO data_140025640 = 
140025640  {
140025640      uint8_t VersionAndFlag = 0x1
140025641      uint8_t SizeOfProlog = 0x8
140025642      uint8_t CountOfUnwindCodes = 0x3
140025643      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025644  }
140025644  uint16_t data_140025644[0x3] = 
140025644  {
140025644      [0x0] =  0xb208
140025646      [0x1] =  0x0304
140025648      [0x2] =  0x5001
14002564a  }

14002564a                                00 00                                                                        ..

14002564c  struct UNWIND_INFO data_14002564c = 
14002564c  {
14002564c      uint8_t VersionAndFlag = 0x1
14002564d      uint8_t SizeOfProlog = 0x8
14002564e      uint8_t CountOfUnwindCodes = 0x3
14002564f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025650  }
140025650  uint16_t data_140025650[0x3] = 
140025650  {
140025650      [0x0] =  0xd208
140025652      [0x1] =  0x0304
140025654      [0x2] =  0x5001
140025656  }

140025656                                                                    00 00                                                ..

140025658  struct UNWIND_INFO data_140025658 = 
140025658  {
140025658      uint8_t VersionAndFlag = 0x1
140025659      uint8_t SizeOfProlog = 0xb
14002565a      uint8_t CountOfUnwindCodes = 0x4
14002565b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002565c  }
14002565c  uint16_t data_14002565c[0x4] = 
14002565c  {
14002565c      [0x0] =  0x010b
14002565e      [0x1] =  0x0018
140025660      [0x2] =  0x0304
140025662      [0x3] =  0x5001
140025664  }
140025664  struct UNWIND_INFO data_140025664 = 
140025664  {
140025664      uint8_t VersionAndFlag = 0x1
140025665      uint8_t SizeOfProlog = 0x8
140025666      uint8_t CountOfUnwindCodes = 0x3
140025667      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025668  }
140025668  uint16_t data_140025668[0x3] = 
140025668  {
140025668      [0x0] =  0x9208
14002566a      [0x1] =  0x0304
14002566c      [0x2] =  0x5001
14002566e  }

14002566e                                            00 00                                                                ..

140025670  struct UNWIND_INFO data_140025670 = 
140025670  {
140025670      uint8_t VersionAndFlag = 0x1
140025671      uint8_t SizeOfProlog = 0x8
140025672      uint8_t CountOfUnwindCodes = 0x3
140025673      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025674  }
140025674  uint16_t data_140025674[0x3] = 
140025674  {
140025674      [0x0] =  0xb208
140025676      [0x1] =  0x0304
140025678      [0x2] =  0x5001
14002567a  }

14002567a                                                                                00 00                                        ..

14002567c  struct UNWIND_INFO data_14002567c = 
14002567c  {
14002567c      uint8_t VersionAndFlag = 0x1
14002567d      uint8_t SizeOfProlog = 0x8
14002567e      uint8_t CountOfUnwindCodes = 0x3
14002567f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025680  }
140025680  uint16_t data_140025680[0x3] = 
140025680  {
140025680      [0x0] =  0xd208
140025682      [0x1] =  0x0304
140025684      [0x2] =  0x5001
140025686  }

140025686                    00 00                                                                                ..

140025688  struct UNWIND_INFO data_140025688 = 
140025688  {
140025688      uint8_t VersionAndFlag = 0x1
140025689      uint8_t SizeOfProlog = 0x8
14002568a      uint8_t CountOfUnwindCodes = 0x3
14002568b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002568c  }
14002568c  uint16_t data_14002568c[0x3] = 
14002568c  {
14002568c      [0x0] =  0xd208
14002568e      [0x1] =  0x0304
140025690      [0x2] =  0x5001
140025692  }

140025692                                                        00 00                                                        ..

140025694  struct UNWIND_INFO data_140025694 = 
140025694  {
140025694      uint8_t VersionAndFlag = 0x1
140025695      uint8_t SizeOfProlog = 0xb
140025696      uint8_t CountOfUnwindCodes = 0x4
140025697      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025698  }
140025698  uint16_t data_140025698[0x4] = 
140025698  {
140025698      [0x0] =  0x010b
14002569a      [0x1] =  0x0014
14002569c      [0x2] =  0x0304
14002569e      [0x3] =  0x5001
1400256a0  }
1400256a0  struct UNWIND_INFO data_1400256a0 = 
1400256a0  {
1400256a0      uint8_t VersionAndFlag = 0x1
1400256a1      uint8_t SizeOfProlog = 0x8
1400256a2      uint8_t CountOfUnwindCodes = 0x3
1400256a3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400256a4  }
1400256a4  uint16_t data_1400256a4[0x3] = 
1400256a4  {
1400256a4      [0x0] =  0xb208
1400256a6      [0x1] =  0x0304
1400256a8      [0x2] =  0x5001
1400256aa  }

1400256aa                                00 00                                                                        ..

1400256ac  struct UNWIND_INFO data_1400256ac = 
1400256ac  {
1400256ac      uint8_t VersionAndFlag = 0x1
1400256ad      uint8_t SizeOfProlog = 0x8
1400256ae      uint8_t CountOfUnwindCodes = 0x3
1400256af      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400256b0  }
1400256b0  uint16_t data_1400256b0[0x3] = 
1400256b0  {
1400256b0      [0x0] =  0x5208
1400256b2      [0x1] =  0x0304
1400256b4      [0x2] =  0x5001
1400256b6  }

1400256b6                                                                    00 00                                                ..

1400256b8  struct UNWIND_INFO data_1400256b8 = 
1400256b8  {
1400256b8      uint8_t VersionAndFlag = 0x1
1400256b9      uint8_t SizeOfProlog = 0x8
1400256ba      uint8_t CountOfUnwindCodes = 0x3
1400256bb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400256bc  }
1400256bc  uint16_t data_1400256bc[0x3] = 
1400256bc  {
1400256bc      [0x0] =  0x5208
1400256be      [0x1] =  0x0304
1400256c0      [0x2] =  0x5001
1400256c2  }

1400256c2        00 00                                                                                        ..

1400256c4  struct UNWIND_INFO data_1400256c4 = 
1400256c4  {
1400256c4      uint8_t VersionAndFlag = 0x1
1400256c5      uint8_t SizeOfProlog = 0x8
1400256c6      uint8_t CountOfUnwindCodes = 0x3
1400256c7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400256c8  }
1400256c8  uint16_t data_1400256c8[0x3] = 
1400256c8  {
1400256c8      [0x0] =  0x5208
1400256ca      [0x1] =  0x0304
1400256cc      [0x2] =  0x5001
1400256ce  }

1400256ce                                            00 00                                                                ..

1400256d0  struct UNWIND_INFO data_1400256d0 = 
1400256d0  {
1400256d0      uint8_t VersionAndFlag = 0x1
1400256d1      uint8_t SizeOfProlog = 0x8
1400256d2      uint8_t CountOfUnwindCodes = 0x3
1400256d3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400256d4  }
1400256d4  uint16_t data_1400256d4[0x3] = 
1400256d4  {
1400256d4      [0x0] =  0xb208
1400256d6      [0x1] =  0x0304
1400256d8      [0x2] =  0x5001
1400256da  }

1400256da                                                                                00 00                                        ..

1400256dc  struct UNWIND_INFO data_1400256dc = 
1400256dc  {
1400256dc      uint8_t VersionAndFlag = 0x1
1400256dd      uint8_t SizeOfProlog = 0x8
1400256de      uint8_t CountOfUnwindCodes = 0x3
1400256df      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400256e0  }
1400256e0  uint16_t data_1400256e0[0x3] = 
1400256e0  {
1400256e0      [0x0] =  0xd208
1400256e2      [0x1] =  0x0304
1400256e4      [0x2] =  0x5001
1400256e6  }

1400256e6                    00 00                                                                                ..

1400256e8  struct UNWIND_INFO data_1400256e8 = 
1400256e8  {
1400256e8      uint8_t VersionAndFlag = 0x1
1400256e9      uint8_t SizeOfProlog = 0x8
1400256ea      uint8_t CountOfUnwindCodes = 0x3
1400256eb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400256ec  }
1400256ec  uint16_t data_1400256ec[0x3] = 
1400256ec  {
1400256ec      [0x0] =  0xb208
1400256ee      [0x1] =  0x0304
1400256f0      [0x2] =  0x5001
1400256f2  }

1400256f2                                                        00 00                                                        ..

1400256f4  struct UNWIND_INFO data_1400256f4 = 
1400256f4  {
1400256f4      uint8_t VersionAndFlag = 0x1
1400256f5      uint8_t SizeOfProlog = 0xb
1400256f6      uint8_t CountOfUnwindCodes = 0x4
1400256f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400256f8  }
1400256f8  uint16_t data_1400256f8[0x4] = 
1400256f8  {
1400256f8      [0x0] =  0x010b
1400256fa      [0x1] =  0x0012
1400256fc      [0x2] =  0x0304
1400256fe      [0x3] =  0x5001
140025700  }
140025700  struct UNWIND_INFO data_140025700 = 
140025700  {
140025700      uint8_t VersionAndFlag = 0x1
140025701      uint8_t SizeOfProlog = 0x8
140025702      uint8_t CountOfUnwindCodes = 0x3
140025703      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025704  }
140025704  uint16_t data_140025704[0x3] = 
140025704  {
140025704      [0x0] =  0x9208
140025706      [0x1] =  0x0304
140025708      [0x2] =  0x5001
14002570a  }

14002570a                                00 00                                                                        ..

14002570c  struct UNWIND_INFO data_14002570c = 
14002570c  {
14002570c      uint8_t VersionAndFlag = 0x1
14002570d      uint8_t SizeOfProlog = 0x8
14002570e      uint8_t CountOfUnwindCodes = 0x3
14002570f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025710  }
140025710  uint16_t data_140025710[0x3] = 
140025710  {
140025710      [0x0] =  0xb208
140025712      [0x1] =  0x0304
140025714      [0x2] =  0x5001
140025716  }

140025716                                                                    00 00                                                ..

140025718  struct UNWIND_INFO data_140025718 = 
140025718  {
140025718      uint8_t VersionAndFlag = 0x1
140025719      uint8_t SizeOfProlog = 0x8
14002571a      uint8_t CountOfUnwindCodes = 0x3
14002571b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002571c  }
14002571c  uint16_t data_14002571c[0x3] = 
14002571c  {
14002571c      [0x0] =  0x5208
14002571e      [0x1] =  0x0304
140025720      [0x2] =  0x5001
140025722  }

140025722        00 00                                                                                        ..

140025724  struct UNWIND_INFO data_140025724 = 
140025724  {
140025724      uint8_t VersionAndFlag = 0x1
140025725      uint8_t SizeOfProlog = 0x8
140025726      uint8_t CountOfUnwindCodes = 0x3
140025727      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025728  }
140025728  uint16_t data_140025728[0x3] = 
140025728  {
140025728      [0x0] =  0x5208
14002572a      [0x1] =  0x0304
14002572c      [0x2] =  0x5001
14002572e  }

14002572e                                            00 00                                                                ..

140025730  struct UNWIND_INFO data_140025730 = 
140025730  {
140025730      uint8_t VersionAndFlag = 0x1
140025731      uint8_t SizeOfProlog = 0x8
140025732      uint8_t CountOfUnwindCodes = 0x3
140025733      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025734  }
140025734  uint16_t data_140025734[0x3] = 
140025734  {
140025734      [0x0] =  0xd208
140025736      [0x1] =  0x0304
140025738      [0x2] =  0x5001
14002573a  }

14002573a                                                                                00 00                                        ..

14002573c  struct UNWIND_INFO data_14002573c = 
14002573c  {
14002573c      uint8_t VersionAndFlag = 0x1
14002573d      uint8_t SizeOfProlog = 0x8
14002573e      uint8_t CountOfUnwindCodes = 0x3
14002573f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025740  }
140025740  uint16_t data_140025740[0x3] = 
140025740  {
140025740      [0x0] =  0xd208
140025742      [0x1] =  0x0304
140025744      [0x2] =  0x5001
140025746  }

140025746                    00 00                                                                                ..

140025748  struct UNWIND_INFO data_140025748 = 
140025748  {
140025748      uint8_t VersionAndFlag = 0x1
140025749      uint8_t SizeOfProlog = 0x8
14002574a      uint8_t CountOfUnwindCodes = 0x3
14002574b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002574c  }
14002574c  uint16_t data_14002574c[0x3] = 
14002574c  {
14002574c      [0x0] =  0xb208
14002574e      [0x1] =  0x0304
140025750      [0x2] =  0x5001
140025752  }

140025752                                                        00 00                                                        ..

140025754  struct UNWIND_INFO data_140025754 = 
140025754  {
140025754      uint8_t VersionAndFlag = 0x1
140025755      uint8_t SizeOfProlog = 0x8
140025756      uint8_t CountOfUnwindCodes = 0x3
140025757      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025758  }
140025758  uint16_t data_140025758[0x3] = 
140025758  {
140025758      [0x0] =  0xd208
14002575a      [0x1] =  0x0304
14002575c      [0x2] =  0x5001
14002575e  }

14002575e                                                                                            00 00                                ..

140025760  struct UNWIND_INFO data_140025760 = 
140025760  {
140025760      uint8_t VersionAndFlag = 0x1
140025761      uint8_t SizeOfProlog = 0x8
140025762      uint8_t CountOfUnwindCodes = 0x3
140025763      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025764  }
140025764  uint16_t data_140025764[0x3] = 
140025764  {
140025764      [0x0] =  0xd208
140025766      [0x1] =  0x0304
140025768      [0x2] =  0x5001
14002576a  }

14002576a                                00 00                                                                        ..

14002576c  struct UNWIND_INFO data_14002576c = 
14002576c  {
14002576c      uint8_t VersionAndFlag = 0x1
14002576d      uint8_t SizeOfProlog = 0xb
14002576e      uint8_t CountOfUnwindCodes = 0x4
14002576f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025770  }
140025770  uint16_t data_140025770[0x4] = 
140025770  {
140025770      [0x0] =  0x010b
140025772      [0x1] =  0x001c
140025774      [0x2] =  0x0304
140025776      [0x3] =  0x5001
140025778  }
140025778  struct UNWIND_INFO data_140025778 = 
140025778  {
140025778      uint8_t VersionAndFlag = 0x1
140025779      uint8_t SizeOfProlog = 0xb
14002577a      uint8_t CountOfUnwindCodes = 0x4
14002577b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002577c  }
14002577c  uint16_t data_14002577c[0x4] = 
14002577c  {
14002577c      [0x0] =  0x010b
14002577e      [0x1] =  0x0014
140025780      [0x2] =  0x0304
140025782      [0x3] =  0x5001
140025784  }
140025784  struct UNWIND_INFO data_140025784 = 
140025784  {
140025784      uint8_t VersionAndFlag = 0x1
140025785      uint8_t SizeOfProlog = 0xb
140025786      uint8_t CountOfUnwindCodes = 0x4
140025787      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025788  }
140025788  uint16_t data_140025788[0x4] = 
140025788  {
140025788      [0x0] =  0x010b
14002578a      [0x1] =  0x0012
14002578c      [0x2] =  0x0304
14002578e      [0x3] =  0x5001
140025790  }
140025790  struct UNWIND_INFO data_140025790 = 
140025790  {
140025790      uint8_t VersionAndFlag = 0x1
140025791      uint8_t SizeOfProlog = 0xb
140025792      uint8_t CountOfUnwindCodes = 0x4
140025793      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025794  }
140025794  uint16_t data_140025794[0x4] = 
140025794  {
140025794      [0x0] =  0x010b
140025796      [0x1] =  0x0012
140025798      [0x2] =  0x0304
14002579a      [0x3] =  0x5001
14002579c  }
14002579c  struct UNWIND_INFO data_14002579c = 
14002579c  {
14002579c      uint8_t VersionAndFlag = 0x1
14002579d      uint8_t SizeOfProlog = 0x8
14002579e      uint8_t CountOfUnwindCodes = 0x3
14002579f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400257a0  }
1400257a0  uint16_t data_1400257a0[0x3] = 
1400257a0  {
1400257a0      [0x0] =  0x3208
1400257a2      [0x1] =  0x0304
1400257a4      [0x2] =  0x5001
1400257a6  }

1400257a6                    00 00                                                                                ..

1400257a8  struct UNWIND_INFO data_1400257a8 = 
1400257a8  {
1400257a8      uint8_t VersionAndFlag = 0x1
1400257a9      uint8_t SizeOfProlog = 0x8
1400257aa      uint8_t CountOfUnwindCodes = 0x3
1400257ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400257ac  }
1400257ac  uint16_t data_1400257ac[0x3] = 
1400257ac  {
1400257ac      [0x0] =  0x3208
1400257ae      [0x1] =  0x0304
1400257b0      [0x2] =  0x5001
1400257b2  }

1400257b2                                                        00 00                                                        ..

1400257b4  struct UNWIND_INFO data_1400257b4 = 
1400257b4  {
1400257b4      uint8_t VersionAndFlag = 0x1
1400257b5      uint8_t SizeOfProlog = 0x8
1400257b6      uint8_t CountOfUnwindCodes = 0x3
1400257b7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400257b8  }
1400257b8  uint16_t data_1400257b8[0x3] = 
1400257b8  {
1400257b8      [0x0] =  0x3208
1400257ba      [0x1] =  0x0304
1400257bc      [0x2] =  0x5001
1400257be  }

1400257be                                                                                            00 00                                ..

1400257c0  struct UNWIND_INFO data_1400257c0 = 
1400257c0  {
1400257c0      uint8_t VersionAndFlag = 0x1
1400257c1      uint8_t SizeOfProlog = 0x8
1400257c2      uint8_t CountOfUnwindCodes = 0x3
1400257c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400257c4  }
1400257c4  uint16_t data_1400257c4[0x3] = 
1400257c4  {
1400257c4      [0x0] =  0x7208
1400257c6      [0x1] =  0x0304
1400257c8      [0x2] =  0x5001
1400257ca  }

1400257ca                                00 00                                                                        ..

1400257cc  struct UNWIND_INFO data_1400257cc = 
1400257cc  {
1400257cc      uint8_t VersionAndFlag = 0x1
1400257cd      uint8_t SizeOfProlog = 0x8
1400257ce      uint8_t CountOfUnwindCodes = 0x3
1400257cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400257d0  }
1400257d0  uint16_t data_1400257d0[0x3] = 
1400257d0  {
1400257d0      [0x0] =  0xb208
1400257d2      [0x1] =  0x0304
1400257d4      [0x2] =  0x5001
1400257d6  }

1400257d6                                                                    00 00                                                ..

1400257d8  struct UNWIND_INFO data_1400257d8 = 
1400257d8  {
1400257d8      uint8_t VersionAndFlag = 0x1
1400257d9      uint8_t SizeOfProlog = 0x8
1400257da      uint8_t CountOfUnwindCodes = 0x3
1400257db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400257dc  }
1400257dc  uint16_t data_1400257dc[0x3] = 
1400257dc  {
1400257dc      [0x0] =  0xd208
1400257de      [0x1] =  0x0304
1400257e0      [0x2] =  0x5001
1400257e2  }

1400257e2        00 00                                                                                        ..

1400257e4  struct UNWIND_INFO data_1400257e4 = 
1400257e4  {
1400257e4      uint8_t VersionAndFlag = 0x1
1400257e5      uint8_t SizeOfProlog = 0x8
1400257e6      uint8_t CountOfUnwindCodes = 0x3
1400257e7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400257e8  }
1400257e8  uint16_t data_1400257e8[0x3] = 
1400257e8  {
1400257e8      [0x0] =  0x9208
1400257ea      [0x1] =  0x0304
1400257ec      [0x2] =  0x5001
1400257ee  }

1400257ee                                            00 00                                                                ..

1400257f0  struct UNWIND_INFO data_1400257f0 = 
1400257f0  {
1400257f0      uint8_t VersionAndFlag = 0x1
1400257f1      uint8_t SizeOfProlog = 0xb
1400257f2      uint8_t CountOfUnwindCodes = 0x4
1400257f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400257f4  }
1400257f4  uint16_t data_1400257f4[0x4] = 
1400257f4  {
1400257f4      [0x0] =  0x010b
1400257f6      [0x1] =  0x001e
1400257f8      [0x2] =  0x0304
1400257fa      [0x3] =  0x5001
1400257fc  }
1400257fc  struct UNWIND_INFO data_1400257fc = 
1400257fc  {
1400257fc      uint8_t VersionAndFlag = 0x1
1400257fd      uint8_t SizeOfProlog = 0x8
1400257fe      uint8_t CountOfUnwindCodes = 0x3
1400257ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025800  }
140025800  uint16_t data_140025800[0x3] = 
140025800  {
140025800      [0x0] =  0x9208
140025802      [0x1] =  0x0304
140025804      [0x2] =  0x5001
140025806  }

140025806                    00 00                                                                                ..

140025808  struct UNWIND_INFO data_140025808 = 
140025808  {
140025808      uint8_t VersionAndFlag = 0x1
140025809      uint8_t SizeOfProlog = 0x11
14002580a      uint8_t CountOfUnwindCodes = 0x5
14002580b      uint8_t FrameRegisterAndFrameRegisterOffset = 0xe5
14002580c  }
14002580c  uint16_t data_14002580c[0x5] = 
14002580c  {
14002580c      [0x0] =  0x0311
14002580e      [0x1] =  0x0109
140025810      [0x2] =  0x001d
140025812      [0x3] =  0x3002
140025814      [0x4] =  0x5001
140025816  }

140025816                                                                    00 00                                                ..

140025818  struct UNWIND_INFO data_140025818 = 
140025818  {
140025818      uint8_t VersionAndFlag = 0x1
140025819      uint8_t SizeOfProlog = 0xb
14002581a      uint8_t CountOfUnwindCodes = 0x4
14002581b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x75
14002581c  }
14002581c  uint16_t data_14002581c[0x4] = 
14002581c  {
14002581c      [0x0] =  0x030b
14002581e      [0x1] =  0xe206
140025820      [0x2] =  0x3002
140025822      [0x3] =  0x5001
140025824  }
140025824  struct UNWIND_INFO data_140025824 = 
140025824  {
140025824      uint8_t VersionAndFlag = 0x1
140025825      uint8_t SizeOfProlog = 0x8
140025826      uint8_t CountOfUnwindCodes = 0x3
140025827      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025828  }
140025828  uint16_t data_140025828[0x3] = 
140025828  {
140025828      [0x0] =  0xb208
14002582a      [0x1] =  0x0304
14002582c      [0x2] =  0x5001
14002582e  }

14002582e                                            00 00                                                                ..

140025830  struct UNWIND_INFO data_140025830 = 
140025830  {
140025830      uint8_t VersionAndFlag = 0x1
140025831      uint8_t SizeOfProlog = 0x8
140025832      uint8_t CountOfUnwindCodes = 0x3
140025833      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025834  }
140025834  uint16_t data_140025834[0x3] = 
140025834  {
140025834      [0x0] =  0xb208
140025836      [0x1] =  0x0304
140025838      [0x2] =  0x5001
14002583a  }

14002583a                                                                                00 00                                        ..

14002583c  struct UNWIND_INFO data_14002583c = 
14002583c  {
14002583c      uint8_t VersionAndFlag = 0x1
14002583d      uint8_t SizeOfProlog = 0xb
14002583e      uint8_t CountOfUnwindCodes = 0x4
14002583f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x35
140025840  }
140025840  uint16_t data_140025840[0x4] = 
140025840  {
140025840      [0x0] =  0x030b
140025842      [0x1] =  0x6206
140025844      [0x2] =  0x3002
140025846      [0x3] =  0x5001
140025848  }
140025848  struct UNWIND_INFO data_140025848 = 
140025848  {
140025848      uint8_t VersionAndFlag = 0x1
140025849      uint8_t SizeOfProlog = 0x8
14002584a      uint8_t CountOfUnwindCodes = 0x3
14002584b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002584c  }
14002584c  uint16_t data_14002584c[0x3] = 
14002584c  {
14002584c      [0x0] =  0xd208
14002584e      [0x1] =  0x0304
140025850      [0x2] =  0x5001
140025852  }

140025852                                                        00 00                                                        ..

140025854  struct UNWIND_INFO data_140025854 = 
140025854  {
140025854      uint8_t VersionAndFlag = 0x1
140025855      uint8_t SizeOfProlog = 0xb
140025856      uint8_t CountOfUnwindCodes = 0x4
140025857      uint8_t FrameRegisterAndFrameRegisterOffset = 0x65
140025858  }
140025858  uint16_t data_140025858[0x4] = 
140025858  {
140025858      [0x0] =  0x030b
14002585a      [0x1] =  0xc206
14002585c      [0x2] =  0x3002
14002585e      [0x3] =  0x5001
140025860  }
140025860  struct UNWIND_INFO data_140025860 = 
140025860  {
140025860      uint8_t VersionAndFlag = 0x1
140025861      uint8_t SizeOfProlog = 0xb
140025862      uint8_t CountOfUnwindCodes = 0x4
140025863      uint8_t FrameRegisterAndFrameRegisterOffset = 0x55
140025864  }
140025864  uint16_t data_140025864[0x4] = 
140025864  {
140025864      [0x0] =  0x030b
140025866      [0x1] =  0xa206
140025868      [0x2] =  0x3002
14002586a      [0x3] =  0x5001
14002586c  }
14002586c  struct UNWIND_INFO data_14002586c = 
14002586c  {
14002586c      uint8_t VersionAndFlag = 0x1
14002586d      uint8_t SizeOfProlog = 0xb
14002586e      uint8_t CountOfUnwindCodes = 0x4
14002586f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x45
140025870  }
140025870  uint16_t data_140025870[0x4] = 
140025870  {
140025870      [0x0] =  0x030b
140025872      [0x1] =  0x8206
140025874      [0x2] =  0x3002
140025876      [0x3] =  0x5001
140025878  }
140025878  struct UNWIND_INFO data_140025878 = 
140025878  {
140025878      uint8_t VersionAndFlag = 0x1
140025879      uint8_t SizeOfProlog = 0x4
14002587a      uint8_t CountOfUnwindCodes = 0x2
14002587b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002587c  }
14002587c  uint16_t data_14002587c[0x2] = 
14002587c  {
14002587c      [0x0] =  0x0304
14002587e      [0x1] =  0x5001
140025880  }
140025880  struct UNWIND_INFO data_140025880 = 
140025880  {
140025880      uint8_t VersionAndFlag = 0x1
140025881      uint8_t SizeOfProlog = 0x8
140025882      uint8_t CountOfUnwindCodes = 0x3
140025883      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025884  }
140025884  uint16_t data_140025884[0x3] = 
140025884  {
140025884      [0x0] =  0xf208
140025886      [0x1] =  0x0304
140025888      [0x2] =  0x5001
14002588a  }

14002588a                                00 00                                                                        ..

14002588c  struct UNWIND_INFO data_14002588c = 
14002588c  {
14002588c      uint8_t VersionAndFlag = 0x1
14002588d      uint8_t SizeOfProlog = 0x8
14002588e      uint8_t CountOfUnwindCodes = 0x3
14002588f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025890  }
140025890  uint16_t data_140025890[0x3] = 
140025890  {
140025890      [0x0] =  0x9208
140025892      [0x1] =  0x0304
140025894      [0x2] =  0x5001
140025896  }

140025896                                                                    00 00                                                ..

140025898  struct UNWIND_INFO data_140025898 = 
140025898  {
140025898      uint8_t VersionAndFlag = 0x1
140025899      uint8_t SizeOfProlog = 0x8
14002589a      uint8_t CountOfUnwindCodes = 0x3
14002589b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002589c  }
14002589c  uint16_t data_14002589c[0x3] = 
14002589c  {
14002589c      [0x0] =  0x7208
14002589e      [0x1] =  0x0304
1400258a0      [0x2] =  0x5001
1400258a2  }

1400258a2        00 00                                                                                        ..

1400258a4  struct UNWIND_INFO data_1400258a4 = 
1400258a4  {
1400258a4      uint8_t VersionAndFlag = 0x1
1400258a5      uint8_t SizeOfProlog = 0x8
1400258a6      uint8_t CountOfUnwindCodes = 0x3
1400258a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400258a8  }
1400258a8  uint16_t data_1400258a8[0x3] = 
1400258a8  {
1400258a8      [0x0] =  0x5208
1400258aa      [0x1] =  0x0304
1400258ac      [0x2] =  0x5001
1400258ae  }

1400258ae                                            00 00                                                                ..

1400258b0  struct UNWIND_INFO data_1400258b0 = 
1400258b0  {
1400258b0      uint8_t VersionAndFlag = 0x1
1400258b1      uint8_t SizeOfProlog = 0xb
1400258b2      uint8_t CountOfUnwindCodes = 0x4
1400258b3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400258b4  }
1400258b4  uint16_t data_1400258b4[0x4] = 
1400258b4  {
1400258b4      [0x0] =  0x010b
1400258b6      [0x1] =  0x001c
1400258b8      [0x2] =  0x0304
1400258ba      [0x3] =  0x5001
1400258bc  }
1400258bc  struct UNWIND_INFO data_1400258bc = 
1400258bc  {
1400258bc      uint8_t VersionAndFlag = 0x1
1400258bd      uint8_t SizeOfProlog = 0xb
1400258be      uint8_t CountOfUnwindCodes = 0x4
1400258bf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400258c0  }
1400258c0  uint16_t data_1400258c0[0x4] = 
1400258c0  {
1400258c0      [0x0] =  0x010b
1400258c2      [0x1] =  0x0012
1400258c4      [0x2] =  0x0304
1400258c6      [0x3] =  0x5001
1400258c8  }
1400258c8  struct UNWIND_INFO data_1400258c8 = 
1400258c8  {
1400258c8      uint8_t VersionAndFlag = 0x1
1400258c9      uint8_t SizeOfProlog = 0x8
1400258ca      uint8_t CountOfUnwindCodes = 0x3
1400258cb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400258cc  }
1400258cc  uint16_t data_1400258cc[0x3] = 
1400258cc  {
1400258cc      [0x0] =  0x3208
1400258ce      [0x1] =  0x0304
1400258d0      [0x2] =  0x5001
1400258d2  }

1400258d2                                                        00 00                                                        ..

1400258d4  struct UNWIND_INFO data_1400258d4 = 
1400258d4  {
1400258d4      uint8_t VersionAndFlag = 0x1
1400258d5      uint8_t SizeOfProlog = 0x8
1400258d6      uint8_t CountOfUnwindCodes = 0x3
1400258d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400258d8  }
1400258d8  uint16_t data_1400258d8[0x3] = 
1400258d8  {
1400258d8      [0x0] =  0xb208
1400258da      [0x1] =  0x0304
1400258dc      [0x2] =  0x5001
1400258de  }

1400258de                                                                                            00 00                                ..

1400258e0  struct UNWIND_INFO data_1400258e0 = 
1400258e0  {
1400258e0      uint8_t VersionAndFlag = 0x1
1400258e1      uint8_t SizeOfProlog = 0xb
1400258e2      uint8_t CountOfUnwindCodes = 0x4
1400258e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400258e4  }
1400258e4  uint16_t data_1400258e4[0x4] = 
1400258e4  {
1400258e4      [0x0] =  0x010b
1400258e6      [0x1] =  0x0014
1400258e8      [0x2] =  0x0304
1400258ea      [0x3] =  0x5001
1400258ec  }
1400258ec  struct UNWIND_INFO data_1400258ec = 
1400258ec  {
1400258ec      uint8_t VersionAndFlag = 0x1
1400258ed      uint8_t SizeOfProlog = 0x8
1400258ee      uint8_t CountOfUnwindCodes = 0x3
1400258ef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400258f0  }
1400258f0  uint16_t data_1400258f0[0x3] = 
1400258f0  {
1400258f0      [0x0] =  0x3208
1400258f2      [0x1] =  0x0304
1400258f4      [0x2] =  0x5001
1400258f6  }

1400258f6                                                                    00 00                                                ..

1400258f8  struct UNWIND_INFO data_1400258f8 = 
1400258f8  {
1400258f8      uint8_t VersionAndFlag = 0x1
1400258f9      uint8_t SizeOfProlog = 0xb
1400258fa      uint8_t CountOfUnwindCodes = 0x4
1400258fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x75
1400258fc  }
1400258fc  uint16_t data_1400258fc[0x4] = 
1400258fc  {
1400258fc      [0x0] =  0x030b
1400258fe      [0x1] =  0xe206
140025900      [0x2] =  0x3002
140025902      [0x3] =  0x5001
140025904  }
140025904  struct UNWIND_INFO data_140025904 = 
140025904  {
140025904      uint8_t VersionAndFlag = 0x1
140025905      uint8_t SizeOfProlog = 0x8
140025906      uint8_t CountOfUnwindCodes = 0x3
140025907      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025908  }
140025908  uint16_t data_140025908[0x3] = 
140025908  {
140025908      [0x0] =  0xd208
14002590a      [0x1] =  0x0304
14002590c      [0x2] =  0x5001
14002590e  }

14002590e                                            00 00                                                                ..

140025910  struct UNWIND_INFO data_140025910 = 
140025910  {
140025910      uint8_t VersionAndFlag = 0x1
140025911      uint8_t SizeOfProlog = 0x8
140025912      uint8_t CountOfUnwindCodes = 0x3
140025913      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025914  }
140025914  uint16_t data_140025914[0x3] = 
140025914  {
140025914      [0x0] =  0xf208
140025916      [0x1] =  0x0304
140025918      [0x2] =  0x5001
14002591a  }

14002591a                                                                                00 00                                        ..

14002591c  struct UNWIND_INFO data_14002591c = 
14002591c  {
14002591c      uint8_t VersionAndFlag = 0x1
14002591d      uint8_t SizeOfProlog = 0x8
14002591e      uint8_t CountOfUnwindCodes = 0x3
14002591f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025920  }
140025920  uint16_t data_140025920[0x3] = 
140025920  {
140025920      [0x0] =  0x5208
140025922      [0x1] =  0x0304
140025924      [0x2] =  0x5001
140025926  }

140025926                    00 00                                                                                ..

140025928  struct UNWIND_INFO data_140025928 = 
140025928  {
140025928      uint8_t VersionAndFlag = 0x1
140025929      uint8_t SizeOfProlog = 0x8
14002592a      uint8_t CountOfUnwindCodes = 0x3
14002592b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002592c  }
14002592c  uint16_t data_14002592c[0x3] = 
14002592c  {
14002592c      [0x0] =  0x5208
14002592e      [0x1] =  0x0304
140025930      [0x2] =  0x5001
140025932  }

140025932                                                        00 00                                                        ..

140025934  struct UNWIND_INFO data_140025934 = 
140025934  {
140025934      uint8_t VersionAndFlag = 0x1
140025935      uint8_t SizeOfProlog = 0xb
140025936      uint8_t CountOfUnwindCodes = 0x4
140025937      uint8_t FrameRegisterAndFrameRegisterOffset = 0x25
140025938  }
140025938  uint16_t data_140025938[0x4] = 
140025938  {
140025938      [0x0] =  0x030b
14002593a      [0x1] =  0x4206
14002593c      [0x2] =  0x3002
14002593e      [0x3] =  0x5001
140025940  }
140025940  struct UNWIND_INFO data_140025940 = 
140025940  {
140025940      uint8_t VersionAndFlag = 0x1
140025941      uint8_t SizeOfProlog = 0x8
140025942      uint8_t CountOfUnwindCodes = 0x3
140025943      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025944  }
140025944  uint16_t data_140025944[0x3] = 
140025944  {
140025944      [0x0] =  0x5208
140025946      [0x1] =  0x0304
140025948      [0x2] =  0x5001
14002594a  }

14002594a                                00 00                                                                        ..

14002594c  struct UNWIND_INFO data_14002594c = 
14002594c  {
14002594c      uint8_t VersionAndFlag = 0x1
14002594d      uint8_t SizeOfProlog = 0x11
14002594e      uint8_t CountOfUnwindCodes = 0x5
14002594f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x85
140025950  }
140025950  uint16_t data_140025950[0x5] = 
140025950  {
140025950      [0x0] =  0x0311
140025952      [0x1] =  0x0109
140025954      [0x2] =  0x0011
140025956      [0x3] =  0x3002
140025958      [0x4] =  0x5001
14002595a  }

14002595a                                                                                00 00                                        ..

14002595c  struct UNWIND_INFO data_14002595c = 
14002595c  {
14002595c      uint8_t VersionAndFlag = 0x1
14002595d      uint8_t SizeOfProlog = 0x11
14002595e      uint8_t CountOfUnwindCodes = 0x5
14002595f      uint8_t FrameRegisterAndFrameRegisterOffset = 0xa5
140025960  }
140025960  uint16_t data_140025960[0x5] = 
140025960  {
140025960      [0x0] =  0x0311
140025962      [0x1] =  0x0109
140025964      [0x2] =  0x0015
140025966      [0x3] =  0x3002
140025968      [0x4] =  0x5001
14002596a  }

14002596a                                00 00                                                                        ..

14002596c  struct UNWIND_INFO data_14002596c = 
14002596c  {
14002596c      uint8_t VersionAndFlag = 0x1
14002596d      uint8_t SizeOfProlog = 0x8
14002596e      uint8_t CountOfUnwindCodes = 0x3
14002596f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025970  }
140025970  uint16_t data_140025970[0x3] = 
140025970  {
140025970      [0x0] =  0x5208
140025972      [0x1] =  0x0304
140025974      [0x2] =  0x5001
140025976  }

140025976                                                                    00 00                                                ..

140025978  struct UNWIND_INFO data_140025978 = 
140025978  {
140025978      uint8_t VersionAndFlag = 0x1
140025979      uint8_t SizeOfProlog = 0x8
14002597a      uint8_t CountOfUnwindCodes = 0x3
14002597b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
14002597c  }
14002597c  uint16_t data_14002597c[0x3] = 
14002597c  {
14002597c      [0x0] =  0xf208
14002597e      [0x1] =  0x0304
140025980      [0x2] =  0x5001
140025982  }

140025982        00 00                                                                                        ..

140025984  struct UNWIND_INFO data_140025984 = 
140025984  {
140025984      uint8_t VersionAndFlag = 0x1
140025985      uint8_t SizeOfProlog = 0x8
140025986      uint8_t CountOfUnwindCodes = 0x3
140025987      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025988  }
140025988  uint16_t data_140025988[0x3] = 
140025988  {
140025988      [0x0] =  0x5208
14002598a      [0x1] =  0x0304
14002598c      [0x2] =  0x5001
14002598e  }

14002598e                                            00 00                                                                ..

140025990  struct UNWIND_INFO data_140025990 = 
140025990  {
140025990      uint8_t VersionAndFlag = 0x1
140025991      uint8_t SizeOfProlog = 0x8
140025992      uint8_t CountOfUnwindCodes = 0x3
140025993      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025994  }
140025994  uint16_t data_140025994[0x3] = 
140025994  {
140025994      [0x0] =  0xf208
140025996      [0x1] =  0x0304
140025998      [0x2] =  0x5001
14002599a  }

14002599a                                                                                00 00                                        ..

14002599c  struct UNWIND_INFO data_14002599c = 
14002599c  {
14002599c      uint8_t VersionAndFlag = 0x1
14002599d      uint8_t SizeOfProlog = 0x8
14002599e      uint8_t CountOfUnwindCodes = 0x3
14002599f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400259a0  }
1400259a0  uint16_t data_1400259a0[0x3] = 
1400259a0  {
1400259a0      [0x0] =  0xf208
1400259a2      [0x1] =  0x0304
1400259a4      [0x2] =  0x5001
1400259a6  }

1400259a6                    00 00                                                                                ..

1400259a8  struct UNWIND_INFO data_1400259a8 = 
1400259a8  {
1400259a8      uint8_t VersionAndFlag = 0x1
1400259a9      uint8_t SizeOfProlog = 0x11
1400259aa      uint8_t CountOfUnwindCodes = 0x5
1400259ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0xa5
1400259ac  }
1400259ac  uint16_t data_1400259ac[0x5] = 
1400259ac  {
1400259ac      [0x0] =  0x0311
1400259ae      [0x1] =  0x0109
1400259b0      [0x2] =  0x0015
1400259b2      [0x3] =  0x3002
1400259b4      [0x4] =  0x5001
1400259b6  }

1400259b6                                                                    00 00                                                ..

1400259b8  struct UNWIND_INFO data_1400259b8 = 
1400259b8  {
1400259b8      uint8_t VersionAndFlag = 0x1
1400259b9      uint8_t SizeOfProlog = 0xb
1400259ba      uint8_t CountOfUnwindCodes = 0x4
1400259bb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400259bc  }
1400259bc  uint16_t data_1400259bc[0x4] = 
1400259bc  {
1400259bc      [0x0] =  0x010b
1400259be      [0x1] =  0x0014
1400259c0      [0x2] =  0x0304
1400259c2      [0x3] =  0x5001
1400259c4  }
1400259c4  struct UNWIND_INFO data_1400259c4 = 
1400259c4  {
1400259c4      uint8_t VersionAndFlag = 0x1
1400259c5      uint8_t SizeOfProlog = 0x11
1400259c6      uint8_t CountOfUnwindCodes = 0x5
1400259c7      uint8_t FrameRegisterAndFrameRegisterOffset = 0xa5
1400259c8  }
1400259c8  uint16_t data_1400259c8[0x5] = 
1400259c8  {
1400259c8      [0x0] =  0x0311
1400259ca      [0x1] =  0x0109
1400259cc      [0x2] =  0x0015
1400259ce      [0x3] =  0x3002
1400259d0      [0x4] =  0x5001
1400259d2  }

1400259d2                                                        00 00                                                        ..

1400259d4  struct UNWIND_INFO data_1400259d4 = 
1400259d4  {
1400259d4      uint8_t VersionAndFlag = 0x1
1400259d5      uint8_t SizeOfProlog = 0x8
1400259d6      uint8_t CountOfUnwindCodes = 0x3
1400259d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400259d8  }
1400259d8  uint16_t data_1400259d8[0x3] = 
1400259d8  {
1400259d8      [0x0] =  0x9208
1400259da      [0x1] =  0x0304
1400259dc      [0x2] =  0x5001
1400259de  }

1400259de                                                                                            00 00                                ..

1400259e0  struct UNWIND_INFO data_1400259e0 = 
1400259e0  {
1400259e0      uint8_t VersionAndFlag = 0x1
1400259e1      uint8_t SizeOfProlog = 0xb
1400259e2      uint8_t CountOfUnwindCodes = 0x4
1400259e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400259e4  }
1400259e4  uint16_t data_1400259e4[0x4] = 
1400259e4  {
1400259e4      [0x0] =  0x010b
1400259e6      [0x1] =  0x0014
1400259e8      [0x2] =  0x0304
1400259ea      [0x3] =  0x5001
1400259ec  }
1400259ec  struct UNWIND_INFO data_1400259ec = 
1400259ec  {
1400259ec      uint8_t VersionAndFlag = 0x1
1400259ed      uint8_t SizeOfProlog = 0x8
1400259ee      uint8_t CountOfUnwindCodes = 0x3
1400259ef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400259f0  }
1400259f0  uint16_t data_1400259f0[0x3] = 
1400259f0  {
1400259f0      [0x0] =  0x5208
1400259f2      [0x1] =  0x0304
1400259f4      [0x2] =  0x5001
1400259f6  }

1400259f6                                                                    00 00                                                ..

1400259f8  struct UNWIND_INFO data_1400259f8 = 
1400259f8  {
1400259f8      uint8_t VersionAndFlag = 0x1
1400259f9      uint8_t SizeOfProlog = 0x8
1400259fa      uint8_t CountOfUnwindCodes = 0x3
1400259fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400259fc  }
1400259fc  uint16_t data_1400259fc[0x3] = 
1400259fc  {
1400259fc      [0x0] =  0x5208
1400259fe      [0x1] =  0x0304
140025a00      [0x2] =  0x5001
140025a02  }

140025a02        00 00                                                                                        ..

140025a04  struct UNWIND_INFO data_140025a04 = 
140025a04  {
140025a04      uint8_t VersionAndFlag = 0x1
140025a05      uint8_t SizeOfProlog = 0xb
140025a06      uint8_t CountOfUnwindCodes = 0x4
140025a07      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a08  }
140025a08  uint16_t data_140025a08[0x4] = 
140025a08  {
140025a08      [0x0] =  0x010b
140025a0a      [0x1] =  0x0014
140025a0c      [0x2] =  0x0304
140025a0e      [0x3] =  0x5001
140025a10  }
140025a10  struct UNWIND_INFO data_140025a10 = 
140025a10  {
140025a10      uint8_t VersionAndFlag = 0x1
140025a11      uint8_t SizeOfProlog = 0xb
140025a12      uint8_t CountOfUnwindCodes = 0x4
140025a13      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a14  }
140025a14  uint16_t data_140025a14[0x4] = 
140025a14  {
140025a14      [0x0] =  0x010b
140025a16      [0x1] =  0x0012
140025a18      [0x2] =  0x0304
140025a1a      [0x3] =  0x5001
140025a1c  }
140025a1c  struct UNWIND_INFO data_140025a1c = 
140025a1c  {
140025a1c      uint8_t VersionAndFlag = 0x1
140025a1d      uint8_t SizeOfProlog = 0xb
140025a1e      uint8_t CountOfUnwindCodes = 0x4
140025a1f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x45
140025a20  }
140025a20  uint16_t data_140025a20[0x4] = 
140025a20  {
140025a20      [0x0] =  0x030b
140025a22      [0x1] =  0x8206
140025a24      [0x2] =  0x3002
140025a26      [0x3] =  0x5001
140025a28  }
140025a28  struct UNWIND_INFO data_140025a28 = 
140025a28  {
140025a28      uint8_t VersionAndFlag = 0x1
140025a29      uint8_t SizeOfProlog = 0x8
140025a2a      uint8_t CountOfUnwindCodes = 0x3
140025a2b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a2c  }
140025a2c  uint16_t data_140025a2c[0x3] = 
140025a2c  {
140025a2c      [0x0] =  0x5208
140025a2e      [0x1] =  0x0304
140025a30      [0x2] =  0x5001
140025a32  }

140025a32                                                        00 00                                                        ..

140025a34  struct UNWIND_INFO data_140025a34 = 
140025a34  {
140025a34      uint8_t VersionAndFlag = 0x1
140025a35      uint8_t SizeOfProlog = 0x8
140025a36      uint8_t CountOfUnwindCodes = 0x3
140025a37      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a38  }
140025a38  uint16_t data_140025a38[0x3] = 
140025a38  {
140025a38      [0x0] =  0x5208
140025a3a      [0x1] =  0x0304
140025a3c      [0x2] =  0x5001
140025a3e  }

140025a3e                                                                                            00 00                                ..

140025a40  struct UNWIND_INFO data_140025a40 = 
140025a40  {
140025a40      uint8_t VersionAndFlag = 0x1
140025a41      uint8_t SizeOfProlog = 0x8
140025a42      uint8_t CountOfUnwindCodes = 0x3
140025a43      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a44  }
140025a44  uint16_t data_140025a44[0x3] = 
140025a44  {
140025a44      [0x0] =  0x9208
140025a46      [0x1] =  0x0304
140025a48      [0x2] =  0x5001
140025a4a  }

140025a4a                                00 00                                                                        ..

140025a4c  struct UNWIND_INFO data_140025a4c = 
140025a4c  {
140025a4c      uint8_t VersionAndFlag = 0x1
140025a4d      uint8_t SizeOfProlog = 0x10
140025a4e      uint8_t CountOfUnwindCodes = 0x4
140025a4f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x85
140025a50  }
140025a50  uint16_t data_140025a50[0x4] = 
140025a50  {
140025a50      [0x0] =  0x0310
140025a52      [0x1] =  0x0108
140025a54      [0x2] =  0x009a
140025a56      [0x3] =  0x5001
140025a58  }
140025a58  struct UNWIND_INFO data_140025a58 = 
140025a58  {
140025a58      uint8_t VersionAndFlag = 0x1
140025a59      uint8_t SizeOfProlog = 0x8
140025a5a      uint8_t CountOfUnwindCodes = 0x3
140025a5b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a5c  }
140025a5c  uint16_t data_140025a5c[0x3] = 
140025a5c  {
140025a5c      [0x0] =  0x5208
140025a5e      [0x1] =  0x0304
140025a60      [0x2] =  0x5001
140025a62  }

140025a62        00 00                                                                                        ..

140025a64  struct UNWIND_INFO data_140025a64 = 
140025a64  {
140025a64      uint8_t VersionAndFlag = 0x1
140025a65      uint8_t SizeOfProlog = 0x8
140025a66      uint8_t CountOfUnwindCodes = 0x3
140025a67      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a68  }
140025a68  uint16_t data_140025a68[0x3] = 
140025a68  {
140025a68      [0x0] =  0xd208
140025a6a      [0x1] =  0x0304
140025a6c      [0x2] =  0x5001
140025a6e  }

140025a6e                                            00 00                                                                ..

140025a70  struct UNWIND_INFO data_140025a70 = 
140025a70  {
140025a70      uint8_t VersionAndFlag = 0x1
140025a71      uint8_t SizeOfProlog = 0x8
140025a72      uint8_t CountOfUnwindCodes = 0x3
140025a73      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a74  }
140025a74  uint16_t data_140025a74[0x3] = 
140025a74  {
140025a74      [0x0] =  0x5208
140025a76      [0x1] =  0x0304
140025a78      [0x2] =  0x5001
140025a7a  }

140025a7a                                                                                00 00                                        ..

140025a7c  struct UNWIND_INFO data_140025a7c = 
140025a7c  {
140025a7c      uint8_t VersionAndFlag = 0x1
140025a7d      uint8_t SizeOfProlog = 0x8
140025a7e      uint8_t CountOfUnwindCodes = 0x3
140025a7f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a80  }
140025a80  uint16_t data_140025a80[0x3] = 
140025a80  {
140025a80      [0x0] =  0xb208
140025a82      [0x1] =  0x0304
140025a84      [0x2] =  0x5001
140025a86  }

140025a86                    00 00                                                                                ..

140025a88  struct UNWIND_INFO data_140025a88 = 
140025a88  {
140025a88      uint8_t VersionAndFlag = 0x1
140025a89      uint8_t SizeOfProlog = 0x8
140025a8a      uint8_t CountOfUnwindCodes = 0x3
140025a8b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a8c  }
140025a8c  uint16_t data_140025a8c[0x3] = 
140025a8c  {
140025a8c      [0x0] =  0xb208
140025a8e      [0x1] =  0x0304
140025a90      [0x2] =  0x5001
140025a92  }

140025a92                                                        00 00                                                        ..

140025a94  struct UNWIND_INFO data_140025a94 = 
140025a94  {
140025a94      uint8_t VersionAndFlag = 0x1
140025a95      uint8_t SizeOfProlog = 0x8
140025a96      uint8_t CountOfUnwindCodes = 0x3
140025a97      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025a98  }
140025a98  uint16_t data_140025a98[0x3] = 
140025a98  {
140025a98      [0x0] =  0xb208
140025a9a      [0x1] =  0x0304
140025a9c      [0x2] =  0x5001
140025a9e  }

140025a9e                                                                                            00 00                                ..

140025aa0  struct UNWIND_INFO data_140025aa0 = 
140025aa0  {
140025aa0      uint8_t VersionAndFlag = 0x1
140025aa1      uint8_t SizeOfProlog = 0x11
140025aa2      uint8_t CountOfUnwindCodes = 0x5
140025aa3      uint8_t FrameRegisterAndFrameRegisterOffset = 0xa5
140025aa4  }
140025aa4  uint16_t data_140025aa4[0x5] = 
140025aa4  {
140025aa4      [0x0] =  0x0311
140025aa6      [0x1] =  0x0109
140025aa8      [0x2] =  0x0015
140025aaa      [0x3] =  0x3002
140025aac      [0x4] =  0x5001
140025aae  }

140025aae                                            00 00                                                                ..

140025ab0  struct UNWIND_INFO data_140025ab0 = 
140025ab0  {
140025ab0      uint8_t VersionAndFlag = 0x1
140025ab1      uint8_t SizeOfProlog = 0x8
140025ab2      uint8_t CountOfUnwindCodes = 0x3
140025ab3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025ab4  }
140025ab4  uint16_t data_140025ab4[0x3] = 
140025ab4  {
140025ab4      [0x0] =  0xd208
140025ab6      [0x1] =  0x0304
140025ab8      [0x2] =  0x5001
140025aba  }

140025aba                                                                                00 00                                        ..

140025abc  struct UNWIND_INFO data_140025abc = 
140025abc  {
140025abc      uint8_t VersionAndFlag = 0x1
140025abd      uint8_t SizeOfProlog = 0x8
140025abe      uint8_t CountOfUnwindCodes = 0x3
140025abf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025ac0  }
140025ac0  uint16_t data_140025ac0[0x3] = 
140025ac0  {
140025ac0      [0x0] =  0x3208
140025ac2      [0x1] =  0x0304
140025ac4      [0x2] =  0x5001
140025ac6  }

140025ac6                    00 00                                                                                ..

140025ac8  struct UNWIND_INFO data_140025ac8 = 
140025ac8  {
140025ac8      uint8_t VersionAndFlag = 0x1
140025ac9      uint8_t SizeOfProlog = 0x8
140025aca      uint8_t CountOfUnwindCodes = 0x3
140025acb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025acc  }
140025acc  uint16_t data_140025acc[0x3] = 
140025acc  {
140025acc      [0x0] =  0x5208
140025ace      [0x1] =  0x0304
140025ad0      [0x2] =  0x5001
140025ad2  }

140025ad2                                                        00 00                                                        ..

140025ad4  struct UNWIND_INFO data_140025ad4 = 
140025ad4  {
140025ad4      uint8_t VersionAndFlag = 0x1
140025ad5      uint8_t SizeOfProlog = 0x8
140025ad6      uint8_t CountOfUnwindCodes = 0x3
140025ad7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025ad8  }
140025ad8  uint16_t data_140025ad8[0x3] = 
140025ad8  {
140025ad8      [0x0] =  0xb208
140025ada      [0x1] =  0x0304
140025adc      [0x2] =  0x5001
140025ade  }

140025ade                                                                                            00 00                                ..

140025ae0  struct UNWIND_INFO data_140025ae0 = 
140025ae0  {
140025ae0      uint8_t VersionAndFlag = 0x1
140025ae1      uint8_t SizeOfProlog = 0x8
140025ae2      uint8_t CountOfUnwindCodes = 0x3
140025ae3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025ae4  }
140025ae4  uint16_t data_140025ae4[0x3] = 
140025ae4  {
140025ae4      [0x0] =  0x3208
140025ae6      [0x1] =  0x0304
140025ae8      [0x2] =  0x5001
140025aea  }

140025aea                                00 00                                                                        ..

140025aec  struct UNWIND_INFO data_140025aec = 
140025aec  {
140025aec      uint8_t VersionAndFlag = 0x1
140025aed      uint8_t SizeOfProlog = 0x8
140025aee      uint8_t CountOfUnwindCodes = 0x3
140025aef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025af0  }
140025af0  uint16_t data_140025af0[0x3] = 
140025af0  {
140025af0      [0x0] =  0x5208
140025af2      [0x1] =  0x0304
140025af4      [0x2] =  0x5001
140025af6  }

140025af6                                                                    00 00                                                ..

140025af8  struct UNWIND_INFO data_140025af8 = 
140025af8  {
140025af8      uint8_t VersionAndFlag = 0x1
140025af9      uint8_t SizeOfProlog = 0x8
140025afa      uint8_t CountOfUnwindCodes = 0x3
140025afb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025afc  }
140025afc  uint16_t data_140025afc[0x3] = 
140025afc  {
140025afc      [0x0] =  0x3208
140025afe      [0x1] =  0x0304
140025b00      [0x2] =  0x5001
140025b02  }

140025b02        00 00                                                                                        ..

140025b04  struct UNWIND_INFO data_140025b04 = 
140025b04  {
140025b04      uint8_t VersionAndFlag = 0x1
140025b05      uint8_t SizeOfProlog = 0x8
140025b06      uint8_t CountOfUnwindCodes = 0x3
140025b07      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025b08  }
140025b08  uint16_t data_140025b08[0x3] = 
140025b08  {
140025b08      [0x0] =  0x9208
140025b0a      [0x1] =  0x0304
140025b0c      [0x2] =  0x5001
140025b0e  }

140025b0e                                            00 00                                                                ..

140025b10  struct UNWIND_INFO data_140025b10 = 
140025b10  {
140025b10      uint8_t VersionAndFlag = 0x1
140025b11      uint8_t SizeOfProlog = 0xb
140025b12      uint8_t CountOfUnwindCodes = 0x4
140025b13      uint8_t FrameRegisterAndFrameRegisterOffset = 0x45
140025b14  }
140025b14  uint16_t data_140025b14[0x4] = 
140025b14  {
140025b14      [0x0] =  0x030b
140025b16      [0x1] =  0x8206
140025b18      [0x2] =  0x3002
140025b1a      [0x3] =  0x5001
140025b1c  }
140025b1c  struct UNWIND_INFO data_140025b1c = 
140025b1c  {
140025b1c      uint8_t VersionAndFlag = 0x1
140025b1d      uint8_t SizeOfProlog = 0x8
140025b1e      uint8_t CountOfUnwindCodes = 0x3
140025b1f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025b20  }
140025b20  uint16_t data_140025b20[0x3] = 
140025b20  {
140025b20      [0x0] =  0x9208
140025b22      [0x1] =  0x0304
140025b24      [0x2] =  0x5001
140025b26  }

140025b26                    00 00                                                                                ..

140025b28  struct UNWIND_INFO data_140025b28 = 
140025b28  {
140025b28      uint8_t VersionAndFlag = 0x1
140025b29      uint8_t SizeOfProlog = 0x8
140025b2a      uint8_t CountOfUnwindCodes = 0x3
140025b2b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025b2c  }
140025b2c  uint16_t data_140025b2c[0x3] = 
140025b2c  {
140025b2c      [0x0] =  0xd208
140025b2e      [0x1] =  0x0304
140025b30      [0x2] =  0x5001
140025b32  }

140025b32                                                        00 00                                                        ..

140025b34  struct UNWIND_INFO data_140025b34 = 
140025b34  {
140025b34      uint8_t VersionAndFlag = 0x1
140025b35      uint8_t SizeOfProlog = 0x8
140025b36      uint8_t CountOfUnwindCodes = 0x3
140025b37      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025b38  }
140025b38  uint16_t data_140025b38[0x3] = 
140025b38  {
140025b38      [0x0] =  0x3208
140025b3a      [0x1] =  0x0304
140025b3c      [0x2] =  0x5001
140025b3e  }

140025b3e                                                                                            00 00                                ..

140025b40  struct UNWIND_INFO data_140025b40 = 
140025b40  {
140025b40      uint8_t VersionAndFlag = 0x1
140025b41      uint8_t SizeOfProlog = 0x8
140025b42      uint8_t CountOfUnwindCodes = 0x3
140025b43      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025b44  }
140025b44  uint16_t data_140025b44[0x3] = 
140025b44  {
140025b44      [0x0] =  0xb208
140025b46      [0x1] =  0x0304
140025b48      [0x2] =  0x5001
140025b4a  }

140025b4a                                00 00                                                                        ..

140025b4c  struct UNWIND_INFO data_140025b4c = 
140025b4c  {
140025b4c      uint8_t VersionAndFlag = 0x1
140025b4d      uint8_t SizeOfProlog = 0x8
140025b4e      uint8_t CountOfUnwindCodes = 0x3
140025b4f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025b50  }
140025b50  uint16_t data_140025b50[0x3] = 
140025b50  {
140025b50      [0x0] =  0x3208
140025b52      [0x1] =  0x0304
140025b54      [0x2] =  0x5001
140025b56  }

140025b56                                                                    00 00                                                ..

140025b58  struct UNWIND_INFO data_140025b58 = 
140025b58  {
140025b58      uint8_t VersionAndFlag = 0x1
140025b59      uint8_t SizeOfProlog = 0x10
140025b5a      uint8_t CountOfUnwindCodes = 0x4
140025b5b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x85
140025b5c  }
140025b5c  uint16_t data_140025b5c[0x4] = 
140025b5c  {
140025b5c      [0x0] =  0x0310
140025b5e      [0x1] =  0x0108
140025b60      [0x2] =  0x002a
140025b62      [0x3] =  0x5001
140025b64  }
140025b64  struct UNWIND_INFO data_140025b64 = 
140025b64  {
140025b64      uint8_t VersionAndFlag = 0x1
140025b65      uint8_t SizeOfProlog = 0x11
140025b66      uint8_t CountOfUnwindCodes = 0x5
140025b67      uint8_t FrameRegisterAndFrameRegisterOffset = 0xa5
140025b68  }
140025b68  uint16_t data_140025b68[0x5] = 
140025b68  {
140025b68      [0x0] =  0x0311
140025b6a      [0x1] =  0x0109
140025b6c      [0x2] =  0x0015
140025b6e      [0x3] =  0x3002
140025b70      [0x4] =  0x5001
140025b72  }

140025b72                                                        00 00                                                        ..

140025b74  struct UNWIND_INFO data_140025b74 = 
140025b74  {
140025b74      uint8_t VersionAndFlag = 0x1
140025b75      uint8_t SizeOfProlog = 0xb
140025b76      uint8_t CountOfUnwindCodes = 0x4
140025b77      uint8_t FrameRegisterAndFrameRegisterOffset = 0x75
140025b78  }
140025b78  uint16_t data_140025b78[0x4] = 
140025b78  {
140025b78      [0x0] =  0x030b
140025b7a      [0x1] =  0xe206
140025b7c      [0x2] =  0x3002
140025b7e      [0x3] =  0x5001
140025b80  }
140025b80  struct UNWIND_INFO data_140025b80 = 
140025b80  {
140025b80      uint8_t VersionAndFlag = 0x1
140025b81      uint8_t SizeOfProlog = 0x8
140025b82      uint8_t CountOfUnwindCodes = 0x3
140025b83      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025b84  }
140025b84  uint16_t data_140025b84[0x3] = 
140025b84  {
140025b84      [0x0] =  0x9208
140025b86      [0x1] =  0x0304
140025b88      [0x2] =  0x5001
140025b8a  }

140025b8a                                00 00                                                                        ..

140025b8c  struct UNWIND_INFO data_140025b8c = 
140025b8c  {
140025b8c      uint8_t VersionAndFlag = 0x1
140025b8d      uint8_t SizeOfProlog = 0x8
140025b8e      uint8_t CountOfUnwindCodes = 0x3
140025b8f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025b90  }
140025b90  uint16_t data_140025b90[0x3] = 
140025b90  {
140025b90      [0x0] =  0xb208
140025b92      [0x1] =  0x0304
140025b94      [0x2] =  0x5001
140025b96  }

140025b96                                                                    00 00                                                ..

140025b98  struct UNWIND_INFO data_140025b98 = 
140025b98  {
140025b98      uint8_t VersionAndFlag = 0x1
140025b99      uint8_t SizeOfProlog = 0xb
140025b9a      uint8_t CountOfUnwindCodes = 0x4
140025b9b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025b9c  }
140025b9c  uint16_t data_140025b9c[0x4] = 
140025b9c  {
140025b9c      [0x0] =  0x010b
140025b9e      [0x1] =  0x0016
140025ba0      [0x2] =  0x0304
140025ba2      [0x3] =  0x5001
140025ba4  }
140025ba4  struct UNWIND_INFO data_140025ba4 = 
140025ba4  {
140025ba4      uint8_t VersionAndFlag = 0x1
140025ba5      uint8_t SizeOfProlog = 0xb
140025ba6      uint8_t CountOfUnwindCodes = 0x4
140025ba7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x75
140025ba8  }
140025ba8  uint16_t data_140025ba8[0x4] = 
140025ba8  {
140025ba8      [0x0] =  0x030b
140025baa      [0x1] =  0xe206
140025bac      [0x2] =  0x3002
140025bae      [0x3] =  0x5001
140025bb0  }
140025bb0  struct UNWIND_INFO data_140025bb0 = 
140025bb0  {
140025bb0      uint8_t VersionAndFlag = 0x1
140025bb1      uint8_t SizeOfProlog = 0xb
140025bb2      uint8_t CountOfUnwindCodes = 0x4
140025bb3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x45
140025bb4  }
140025bb4  uint16_t data_140025bb4[0x4] = 
140025bb4  {
140025bb4      [0x0] =  0x030b
140025bb6      [0x1] =  0x8206
140025bb8      [0x2] =  0x3002
140025bba      [0x3] =  0x5001
140025bbc  }
140025bbc  struct UNWIND_INFO data_140025bbc = 
140025bbc  {
140025bbc      uint8_t VersionAndFlag = 0x1
140025bbd      uint8_t SizeOfProlog = 0x8
140025bbe      uint8_t CountOfUnwindCodes = 0x3
140025bbf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025bc0  }
140025bc0  uint16_t data_140025bc0[0x3] = 
140025bc0  {
140025bc0      [0x0] =  0x7208
140025bc2      [0x1] =  0x0304
140025bc4      [0x2] =  0x5001
140025bc6  }

140025bc6                    00 00                                                                                ..

140025bc8  struct UNWIND_INFO data_140025bc8 = 
140025bc8  {
140025bc8      uint8_t VersionAndFlag = 0x1
140025bc9      uint8_t SizeOfProlog = 0x8
140025bca      uint8_t CountOfUnwindCodes = 0x3
140025bcb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025bcc  }
140025bcc  uint16_t data_140025bcc[0x3] = 
140025bcc  {
140025bcc      [0x0] =  0x9208
140025bce      [0x1] =  0x0304
140025bd0      [0x2] =  0x5001
140025bd2  }

140025bd2                                                        00 00                                                        ..

140025bd4  struct UNWIND_INFO data_140025bd4 = 
140025bd4  {
140025bd4      uint8_t VersionAndFlag = 0x1
140025bd5      uint8_t SizeOfProlog = 0x8
140025bd6      uint8_t CountOfUnwindCodes = 0x3
140025bd7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025bd8  }
140025bd8  uint16_t data_140025bd8[0x3] = 
140025bd8  {
140025bd8      [0x0] =  0x9208
140025bda      [0x1] =  0x0304
140025bdc      [0x2] =  0x5001
140025bde  }

140025bde                                                                                            00 00                                ..

140025be0  struct UNWIND_INFO data_140025be0 = 
140025be0  {
140025be0      uint8_t VersionAndFlag = 0x1
140025be1      uint8_t SizeOfProlog = 0x8
140025be2      uint8_t CountOfUnwindCodes = 0x3
140025be3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025be4  }
140025be4  uint16_t data_140025be4[0x3] = 
140025be4  {
140025be4      [0x0] =  0xb208
140025be6      [0x1] =  0x0304
140025be8      [0x2] =  0x5001
140025bea  }

140025bea                                00 00                                                                        ..

140025bec  struct UNWIND_INFO data_140025bec = 
140025bec  {
140025bec      uint8_t VersionAndFlag = 0x1
140025bed      uint8_t SizeOfProlog = 0x8
140025bee      uint8_t CountOfUnwindCodes = 0x3
140025bef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025bf0  }
140025bf0  uint16_t data_140025bf0[0x3] = 
140025bf0  {
140025bf0      [0x0] =  0x9208
140025bf2      [0x1] =  0x0304
140025bf4      [0x2] =  0x5001
140025bf6  }

140025bf6                                                                    00 00                                                ..

140025bf8  struct UNWIND_INFO data_140025bf8 = 
140025bf8  {
140025bf8      uint8_t VersionAndFlag = 0x1
140025bf9      uint8_t SizeOfProlog = 0x11
140025bfa      uint8_t CountOfUnwindCodes = 0x5
140025bfb      uint8_t FrameRegisterAndFrameRegisterOffset = 0xa5
140025bfc  }
140025bfc  uint16_t data_140025bfc[0x5] = 
140025bfc  {
140025bfc      [0x0] =  0x0311
140025bfe      [0x1] =  0x0109
140025c00      [0x2] =  0x0015
140025c02      [0x3] =  0x3002
140025c04      [0x4] =  0x5001
140025c06  }

140025c06                    00 00                                                                                ..

140025c08  struct UNWIND_INFO data_140025c08 = 
140025c08  {
140025c08      uint8_t VersionAndFlag = 0x1
140025c09      uint8_t SizeOfProlog = 0x8
140025c0a      uint8_t CountOfUnwindCodes = 0x3
140025c0b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025c0c  }
140025c0c  uint16_t data_140025c0c[0x3] = 
140025c0c  {
140025c0c      [0x0] =  0x5208
140025c0e      [0x1] =  0x0304
140025c10      [0x2] =  0x5001
140025c12  }

140025c12                                                        00 00                                                        ..

140025c14  struct UNWIND_INFO data_140025c14 = 
140025c14  {
140025c14      uint8_t VersionAndFlag = 0x1
140025c15      uint8_t SizeOfProlog = 0x8
140025c16      uint8_t CountOfUnwindCodes = 0x3
140025c17      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025c18  }
140025c18  uint16_t data_140025c18[0x3] = 
140025c18  {
140025c18      [0x0] =  0x5208
140025c1a      [0x1] =  0x0304
140025c1c      [0x2] =  0x5001
140025c1e  }

140025c1e                                                                                            00 00                                ..

140025c20  struct UNWIND_INFO data_140025c20 = 
140025c20  {
140025c20      uint8_t VersionAndFlag = 0x1
140025c21      uint8_t SizeOfProlog = 0x11
140025c22      uint8_t CountOfUnwindCodes = 0x5
140025c23      uint8_t FrameRegisterAndFrameRegisterOffset = 0xa5
140025c24  }
140025c24  uint16_t data_140025c24[0x5] = 
140025c24  {
140025c24      [0x0] =  0x0311
140025c26      [0x1] =  0x0109
140025c28      [0x2] =  0x0015
140025c2a      [0x3] =  0x3002
140025c2c      [0x4] =  0x5001
140025c2e  }

140025c2e                                            00 00                                                                ..

140025c30  struct UNWIND_INFO data_140025c30 = 
140025c30  {
140025c30      uint8_t VersionAndFlag = 0x1
140025c31      uint8_t SizeOfProlog = 0x11
140025c32      uint8_t CountOfUnwindCodes = 0x5
140025c33      uint8_t FrameRegisterAndFrameRegisterOffset = 0xa5
140025c34  }
140025c34  uint16_t data_140025c34[0x5] = 
140025c34  {
140025c34      [0x0] =  0x0311
140025c36      [0x1] =  0x0109
140025c38      [0x2] =  0x0015
140025c3a      [0x3] =  0x3002
140025c3c      [0x4] =  0x5001
140025c3e  }

140025c3e                                                                                            00 00                                ..

140025c40  struct UNWIND_INFO data_140025c40 = 
140025c40  {
140025c40      uint8_t VersionAndFlag = 0x1
140025c41      uint8_t SizeOfProlog = 0xb
140025c42      uint8_t CountOfUnwindCodes = 0x4
140025c43      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025c44  }
140025c44  uint16_t data_140025c44[0x4] = 
140025c44  {
140025c44      [0x0] =  0x010b
140025c46      [0x1] =  0x0012
140025c48      [0x2] =  0x0304
140025c4a      [0x3] =  0x5001
140025c4c  }
140025c4c  struct UNWIND_INFO data_140025c4c = 
140025c4c  {
140025c4c      uint8_t VersionAndFlag = 0x1
140025c4d      uint8_t SizeOfProlog = 0xb
140025c4e      uint8_t CountOfUnwindCodes = 0x4
140025c4f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x35
140025c50  }
140025c50  uint16_t data_140025c50[0x4] = 
140025c50  {
140025c50      [0x0] =  0x030b
140025c52      [0x1] =  0x6206
140025c54      [0x2] =  0x3002
140025c56      [0x3] =  0x5001
140025c58  }
140025c58  struct UNWIND_INFO data_140025c58 = 
140025c58  {
140025c58      uint8_t VersionAndFlag = 0x1
140025c59      uint8_t SizeOfProlog = 0x8
140025c5a      uint8_t CountOfUnwindCodes = 0x3
140025c5b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025c5c  }
140025c5c  uint16_t data_140025c5c[0x3] = 
140025c5c  {
140025c5c      [0x0] =  0x3208
140025c5e      [0x1] =  0x0304
140025c60      [0x2] =  0x5001
140025c62  }

140025c62        00 00                                                                                        ..
140025c64  _.xdata:
140025c64              01 08 03 05                                                                              ....
140025c68  uint16_t data_140025c68[0x3] = 
140025c68  {
140025c68      [0x0] =  0x1208
140025c6a      [0x1] =  0x0304
140025c6c      [0x2] =  0x5001
140025c6e  }

140025c6e                                            00 00                                                                ..

140025c70  struct UNWIND_INFO data_140025c70 = 
140025c70  {
140025c70      uint8_t VersionAndFlag = 0x1
140025c71      uint8_t SizeOfProlog = 0x8
140025c72      uint8_t CountOfUnwindCodes = 0x3
140025c73      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025c74  }
140025c74  uint16_t data_140025c74[0x3] = 
140025c74  {
140025c74      [0x0] =  0x3208
140025c76      [0x1] =  0x0304
140025c78      [0x2] =  0x5001
140025c7a  }

140025c7a                                                                                00 00                                        ..
140025c7c  _.xdata:
140025c7c                                                                                      01 0b 04 25                              ...%
140025c80  uint16_t data_140025c80[0x4] = 
140025c80  {
140025c80      [0x0] =  0x030b
140025c82      [0x1] =  0x4206
140025c84      [0x2] =  0x3002
140025c86      [0x3] =  0x5001
140025c88  }
140025c88  struct UNWIND_INFO data_140025c88 = 
140025c88  {
140025c88      uint8_t VersionAndFlag = 0x1
140025c89      uint8_t SizeOfProlog = 0x8
140025c8a      uint8_t CountOfUnwindCodes = 0x3
140025c8b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025c8c  }
140025c8c  uint16_t data_140025c8c[0x3] = 
140025c8c  {
140025c8c      [0x0] =  0x3208
140025c8e      [0x1] =  0x0304
140025c90      [0x2] =  0x5001
140025c92  }

140025c92                                                        00 00                                                        ..

140025c94  struct UNWIND_INFO data_140025c94 = 
140025c94  {
140025c94      uint8_t VersionAndFlag = 0x1
140025c95      uint8_t SizeOfProlog = 0x8
140025c96      uint8_t CountOfUnwindCodes = 0x3
140025c97      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025c98  }
140025c98  uint16_t data_140025c98[0x3] = 
140025c98  {
140025c98      [0x0] =  0x3208
140025c9a      [0x1] =  0x0304
140025c9c      [0x2] =  0x5001
140025c9e  }

140025c9e                                                                                            00 00                                ..

140025ca0  struct UNWIND_INFO data_140025ca0 = 
140025ca0  {
140025ca0      uint8_t VersionAndFlag = 0x1
140025ca1      uint8_t SizeOfProlog = 0x11
140025ca2      uint8_t CountOfUnwindCodes = 0x5
140025ca3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x85
140025ca4  }
140025ca4  uint16_t data_140025ca4[0x5] = 
140025ca4  {
140025ca4      [0x0] =  0x0311
140025ca6      [0x1] =  0x0109
140025ca8      [0x2] =  0x0011
140025caa      [0x3] =  0x3002
140025cac      [0x4] =  0x5001
140025cae  }

140025cae                                            00 00                                                                ..

140025cb0  struct UNWIND_INFO data_140025cb0 = 
140025cb0  {
140025cb0      uint8_t VersionAndFlag = 0x1
140025cb1      uint8_t SizeOfProlog = 0x8
140025cb2      uint8_t CountOfUnwindCodes = 0x3
140025cb3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025cb4  }
140025cb4  uint16_t data_140025cb4[0x3] = 
140025cb4  {
140025cb4      [0x0] =  0xb208
140025cb6      [0x1] =  0x0304
140025cb8      [0x2] =  0x5001
140025cba  }

140025cba                                                                                00 00                                        ..
140025cbc  _.xdata:
140025cbc                                                                                      01 08 03 05                              ....
140025cc0  uint16_t data_140025cc0[0x3] = 
140025cc0  {
140025cc0      [0x0] =  0x5208
140025cc2      [0x1] =  0x0304
140025cc4      [0x2] =  0x5001
140025cc6  }

140025cc6                    00 00                                                                                ..

140025cc8  struct UNWIND_INFO data_140025cc8 = 
140025cc8  {
140025cc8      uint8_t VersionAndFlag = 0x1
140025cc9      uint8_t SizeOfProlog = 0x8
140025cca      uint8_t CountOfUnwindCodes = 0x3
140025ccb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025ccc  }
140025ccc  uint16_t data_140025ccc[0x3] = 
140025ccc  {
140025ccc      [0x0] =  0x3208
140025cce      [0x1] =  0x0304
140025cd0      [0x2] =  0x5001
140025cd2  }

140025cd2                                                        00 00                                                        ..

140025cd4  struct UNWIND_INFO data_140025cd4 = 
140025cd4  {
140025cd4      uint8_t VersionAndFlag = 0x1
140025cd5      uint8_t SizeOfProlog = 0x8
140025cd6      uint8_t CountOfUnwindCodes = 0x3
140025cd7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025cd8  }
140025cd8  uint16_t data_140025cd8[0x3] = 
140025cd8  {
140025cd8      [0x0] =  0x3208
140025cda      [0x1] =  0x0304
140025cdc      [0x2] =  0x5001
140025cde  }

140025cde                                                                                            00 00                                ..

140025ce0  struct UNWIND_INFO data_140025ce0 = 
140025ce0  {
140025ce0      uint8_t VersionAndFlag = 0x1
140025ce1      uint8_t SizeOfProlog = 0x8
140025ce2      uint8_t CountOfUnwindCodes = 0x3
140025ce3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025ce4  }
140025ce4  uint16_t data_140025ce4[0x3] = 
140025ce4  {
140025ce4      [0x0] =  0xb208
140025ce6      [0x1] =  0x0304
140025ce8      [0x2] =  0x5001
140025cea  }

140025cea                                00 00                                                                        ..

140025cec  struct UNWIND_INFO data_140025cec = 
140025cec  {
140025cec      uint8_t VersionAndFlag = 0x1
140025ced      uint8_t SizeOfProlog = 0x8
140025cee      uint8_t CountOfUnwindCodes = 0x3
140025cef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025cf0  }
140025cf0  uint16_t data_140025cf0[0x3] = 
140025cf0  {
140025cf0      [0x0] =  0xf208
140025cf2      [0x1] =  0x0304
140025cf4      [0x2] =  0x5001
140025cf6  }

140025cf6                                                                    00 00                                                ..

140025cf8  struct UNWIND_INFO data_140025cf8 = 
140025cf8  {
140025cf8      uint8_t VersionAndFlag = 0x1
140025cf9      uint8_t SizeOfProlog = 0x8
140025cfa      uint8_t CountOfUnwindCodes = 0x3
140025cfb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025cfc  }
140025cfc  uint16_t data_140025cfc[0x3] = 
140025cfc  {
140025cfc      [0x0] =  0x5208
140025cfe      [0x1] =  0x0304
140025d00      [0x2] =  0x5001
140025d02  }

140025d02        00 00                                                                                        ..
140025d04  _.xdata:
140025d04              01 08 03 05                                                                              ....
140025d08  uint16_t data_140025d08[0x3] = 
140025d08  {
140025d08      [0x0] =  0x3208
140025d0a      [0x1] =  0x0304
140025d0c      [0x2] =  0x5001
140025d0e  }

140025d0e                                            00 00                                                                ..

140025d10  struct UNWIND_INFO data_140025d10 = 
140025d10  {
140025d10      uint8_t VersionAndFlag = 0x1
140025d11      uint8_t SizeOfProlog = 0x8
140025d12      uint8_t CountOfUnwindCodes = 0x3
140025d13      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d14  }
140025d14  uint16_t data_140025d14[0x3] = 
140025d14  {
140025d14      [0x0] =  0x3208
140025d16      [0x1] =  0x0304
140025d18      [0x2] =  0x5001
140025d1a  }

140025d1a                                                                                00 00                                        ..

140025d1c  struct UNWIND_INFO data_140025d1c = 
140025d1c  {
140025d1c      uint8_t VersionAndFlag = 0x1
140025d1d      uint8_t SizeOfProlog = 0xb
140025d1e      uint8_t CountOfUnwindCodes = 0x4
140025d1f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x75
140025d20  }
140025d20  uint16_t data_140025d20[0x4] = 
140025d20  {
140025d20      [0x0] =  0x030b
140025d22      [0x1] =  0xe206
140025d24      [0x2] =  0x3002
140025d26      [0x3] =  0x5001
140025d28  }
140025d28  struct UNWIND_INFO data_140025d28 = 
140025d28  {
140025d28      uint8_t VersionAndFlag = 0x1
140025d29      uint8_t SizeOfProlog = 0x8
140025d2a      uint8_t CountOfUnwindCodes = 0x3
140025d2b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d2c  }
140025d2c  uint16_t data_140025d2c[0x3] = 
140025d2c  {
140025d2c      [0x0] =  0x5208
140025d2e      [0x1] =  0x0304
140025d30      [0x2] =  0x5001
140025d32  }

140025d32                                                        00 00                                                        ..

140025d34  struct UNWIND_INFO data_140025d34 = 
140025d34  {
140025d34      uint8_t VersionAndFlag = 0x1
140025d35      uint8_t SizeOfProlog = 0x8
140025d36      uint8_t CountOfUnwindCodes = 0x3
140025d37      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d38  }
140025d38  uint16_t data_140025d38[0x3] = 
140025d38  {
140025d38      [0x0] =  0x5208
140025d3a      [0x1] =  0x0304
140025d3c      [0x2] =  0x5001
140025d3e  }

140025d3e                                                                                            00 00                                ..

140025d40  struct UNWIND_INFO data_140025d40 = 
140025d40  {
140025d40      uint8_t VersionAndFlag = 0x1
140025d41      uint8_t SizeOfProlog = 0x8
140025d42      uint8_t CountOfUnwindCodes = 0x3
140025d43      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d44  }
140025d44  uint16_t data_140025d44[0x3] = 
140025d44  {
140025d44      [0x0] =  0x5208
140025d46      [0x1] =  0x0304
140025d48      [0x2] =  0x5001
140025d4a  }

140025d4a                                00 00                                                                        ..

140025d4c  struct UNWIND_INFO data_140025d4c = 
140025d4c  {
140025d4c      uint8_t VersionAndFlag = 0x1
140025d4d      uint8_t SizeOfProlog = 0x8
140025d4e      uint8_t CountOfUnwindCodes = 0x3
140025d4f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d50  }
140025d50  uint16_t data_140025d50[0x3] = 
140025d50  {
140025d50      [0x0] =  0xd208
140025d52      [0x1] =  0x0304
140025d54      [0x2] =  0x5001
140025d56  }

140025d56                                                                    00 00                                                ..

140025d58  struct UNWIND_INFO data_140025d58 = 
140025d58  {
140025d58      uint8_t VersionAndFlag = 0x1
140025d59      uint8_t SizeOfProlog = 0xb
140025d5a      uint8_t CountOfUnwindCodes = 0x4
140025d5b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d5c  }
140025d5c  uint16_t data_140025d5c[0x4] = 
140025d5c  {
140025d5c      [0x0] =  0x010b
140025d5e      [0x1] =  0x0014
140025d60      [0x2] =  0x0304
140025d62      [0x3] =  0x5001
140025d64  }
140025d64  struct UNWIND_INFO data_140025d64 = 
140025d64  {
140025d64      uint8_t VersionAndFlag = 0x1
140025d65      uint8_t SizeOfProlog = 0xb
140025d66      uint8_t CountOfUnwindCodes = 0x4
140025d67      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d68  }
140025d68  uint16_t data_140025d68[0x4] = 
140025d68  {
140025d68      [0x0] =  0x010b
140025d6a      [0x1] =  0x0012
140025d6c      [0x2] =  0x0304
140025d6e      [0x3] =  0x5001
140025d70  }
140025d70  _.xdata:
140025d70                                                  01 08 03 05                                                      ....
140025d74  uint16_t data_140025d74[0x3] = 
140025d74  {
140025d74      [0x0] =  0x5208
140025d76      [0x1] =  0x0304
140025d78      [0x2] =  0x5001
140025d7a  }

140025d7a                                                                                00 00                                        ..

140025d7c  struct UNWIND_INFO data_140025d7c = 
140025d7c  {
140025d7c      uint8_t VersionAndFlag = 0x1
140025d7d      uint8_t SizeOfProlog = 0x8
140025d7e      uint8_t CountOfUnwindCodes = 0x3
140025d7f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d80  }
140025d80  uint16_t data_140025d80[0x3] = 
140025d80  {
140025d80      [0x0] =  0x3208
140025d82      [0x1] =  0x0304
140025d84      [0x2] =  0x5001
140025d86  }

140025d86                    00 00                                                                                ..

140025d88  struct UNWIND_INFO data_140025d88 = 
140025d88  {
140025d88      uint8_t VersionAndFlag = 0x1
140025d89      uint8_t SizeOfProlog = 0x8
140025d8a      uint8_t CountOfUnwindCodes = 0x3
140025d8b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d8c  }
140025d8c  uint16_t data_140025d8c[0x3] = 
140025d8c  {
140025d8c      [0x0] =  0x3208
140025d8e      [0x1] =  0x0304
140025d90      [0x2] =  0x5001
140025d92  }

140025d92                                                        00 00                                                        ..

140025d94  struct UNWIND_INFO data_140025d94 = 
140025d94  {
140025d94      uint8_t VersionAndFlag = 0x1
140025d95      uint8_t SizeOfProlog = 0x8
140025d96      uint8_t CountOfUnwindCodes = 0x3
140025d97      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025d98  }
140025d98  uint16_t data_140025d98[0x3] = 
140025d98  {
140025d98      [0x0] =  0xd208
140025d9a      [0x1] =  0x0304
140025d9c      [0x2] =  0x5001
140025d9e  }

140025d9e                                                                                            00 00                                ..

140025da0  struct UNWIND_INFO data_140025da0 = 
140025da0  {
140025da0      uint8_t VersionAndFlag = 0x1
140025da1      uint8_t SizeOfProlog = 0x11
140025da2      uint8_t CountOfUnwindCodes = 0x5
140025da3      uint8_t FrameRegisterAndFrameRegisterOffset = 0xc5
140025da4  }
140025da4  uint16_t data_140025da4[0x5] = 
140025da4  {
140025da4      [0x0] =  0x0311
140025da6      [0x1] =  0x0109
140025da8      [0x2] =  0x0019
140025daa      [0x3] =  0x3002
140025dac      [0x4] =  0x5001
140025dae  }

140025dae                                            00 00                                                                ..

140025db0  struct UNWIND_INFO data_140025db0 = 
140025db0  {
140025db0      uint8_t VersionAndFlag = 0x1
140025db1      uint8_t SizeOfProlog = 0x8
140025db2      uint8_t CountOfUnwindCodes = 0x3
140025db3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025db4  }
140025db4  uint16_t data_140025db4[0x3] = 
140025db4  {
140025db4      [0x0] =  0x5208
140025db6      [0x1] =  0x0304
140025db8      [0x2] =  0x5001
140025dba  }

140025dba                                                                                00 00                                        ..

140025dbc  struct UNWIND_INFO data_140025dbc = 
140025dbc  {
140025dbc      uint8_t VersionAndFlag = 0x1
140025dbd      uint8_t SizeOfProlog = 0xb
140025dbe      uint8_t CountOfUnwindCodes = 0x4
140025dbf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025dc0  }
140025dc0  uint16_t data_140025dc0[0x4] = 
140025dc0  {
140025dc0      [0x0] =  0x010b
140025dc2      [0x1] =  0x0018
140025dc4      [0x2] =  0x0304
140025dc6      [0x3] =  0x5001
140025dc8  }
140025dc8  struct UNWIND_INFO data_140025dc8 = 
140025dc8  {
140025dc8      uint8_t VersionAndFlag = 0x1
140025dc9      uint8_t SizeOfProlog = 0x8
140025dca      uint8_t CountOfUnwindCodes = 0x3
140025dcb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025dcc  }
140025dcc  uint16_t data_140025dcc[0x3] = 
140025dcc  {
140025dcc      [0x0] =  0x3208
140025dce      [0x1] =  0x0304
140025dd0      [0x2] =  0x5001
140025dd2  }

140025dd2                                                        00 00                                                        ..

140025dd4  struct UNWIND_INFO data_140025dd4 = 
140025dd4  {
140025dd4      uint8_t VersionAndFlag = 0x1
140025dd5      uint8_t SizeOfProlog = 0x8
140025dd6      uint8_t CountOfUnwindCodes = 0x3
140025dd7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025dd8  }
140025dd8  uint16_t data_140025dd8[0x3] = 
140025dd8  {
140025dd8      [0x0] =  0x3208
140025dda      [0x1] =  0x0304
140025ddc      [0x2] =  0x5001
140025dde  }

140025dde                                                                                            00 00                                ..

140025de0  struct UNWIND_INFO data_140025de0 = 
140025de0  {
140025de0      uint8_t VersionAndFlag = 0x1
140025de1      uint8_t SizeOfProlog = 0x8
140025de2      uint8_t CountOfUnwindCodes = 0x3
140025de3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025de4  }
140025de4  uint16_t data_140025de4[0x3] = 
140025de4  {
140025de4      [0x0] =  0x3208
140025de6      [0x1] =  0x0304
140025de8      [0x2] =  0x5001
140025dea  }

140025dea                                00 00                                                                        ..

140025dec  struct UNWIND_INFO data_140025dec = 
140025dec  {
140025dec      uint8_t VersionAndFlag = 0x1
140025ded      uint8_t SizeOfProlog = 0x8
140025dee      uint8_t CountOfUnwindCodes = 0x3
140025def      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025df0  }
140025df0  uint16_t data_140025df0[0x3] = 
140025df0  {
140025df0      [0x0] =  0x3208
140025df2      [0x1] =  0x0304
140025df4      [0x2] =  0x5001
140025df6  }

140025df6                                                                    00 00                                                ..

140025df8  struct UNWIND_INFO data_140025df8 = 
140025df8  {
140025df8      uint8_t VersionAndFlag = 0x1
140025df9      uint8_t SizeOfProlog = 0x8
140025dfa      uint8_t CountOfUnwindCodes = 0x3
140025dfb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025dfc  }
140025dfc  uint16_t data_140025dfc[0x3] = 
140025dfc  {
140025dfc      [0x0] =  0x3208
140025dfe      [0x1] =  0x0304
140025e00      [0x2] =  0x5001
140025e02  }

140025e02        00 00                                                                                        ..

140025e04  struct UNWIND_INFO data_140025e04 = 
140025e04  {
140025e04      uint8_t VersionAndFlag = 0x1
140025e05      uint8_t SizeOfProlog = 0x8
140025e06      uint8_t CountOfUnwindCodes = 0x3
140025e07      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
140025e08  }
140025e08  uint16_t data_140025e08[0x3] = 
140025e08  {
140025e08      [0x0] =  0xb208
140025e0a      [0x1] =  0x0304
140025e0c      [0x2] =  0x5001
140025e0e  }

140025e0e                                            00 00                                                                ..
140025e10  _.xdata:
140025e10                                                  01 04 01 00                                                      ....
140025e14  uint16_t data_140025e14[0x1] = 
140025e14  {
140025e14      [0x0] =  0x4204
140025e16  }

140025e16                                                                    00 00                                                ..

140025e18  struct UNWIND_INFO data_140025e18 = 
140025e18  {
140025e18      uint8_t VersionAndFlag = 0x1
140025e19      uint8_t SizeOfProlog = 0x6
140025e1a      uint8_t CountOfUnwindCodes = 0x3
140025e1b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025e1c  }
140025e1c  uint16_t data_140025e1c[0x3] = 
140025e1c  {
140025e1c      [0x0] =  0x4206
140025e1e      [0x1] =  0x3002
140025e20      [0x2] =  0x6001
140025e22  }

140025e22        00 00                                                                                        ..

140025e24  struct UNWIND_INFO data_140025e24 = 
140025e24  {
140025e24      uint8_t VersionAndFlag = 0x1
140025e25      uint8_t SizeOfProlog = 0x0
140025e26      uint8_t CountOfUnwindCodes = 0x0
140025e27      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025e28  }

140025e28  _.xdata:
140025e28                          01 00 00 00                                                                      ....
140025e2c  _.xdata:
140025e2c                                      01 04 01 00                                                              ....
140025e30  uint16_t data_140025e30[0x1] = 
140025e30  {
140025e30      [0x0] =  0x4204
140025e32  }

140025e32                                                        00 00                                                        ..

140025e34  struct UNWIND_INFO data_140025e34 = 
140025e34  {
140025e34      uint8_t VersionAndFlag = 0x1
140025e35      uint8_t SizeOfProlog = 0x6
140025e36      uint8_t CountOfUnwindCodes = 0x3
140025e37      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025e38  }
140025e38  uint16_t data_140025e38[0x3] = 
140025e38  {
140025e38      [0x0] =  0x4206
140025e3a      [0x1] =  0x3002
140025e3c      [0x2] =  0x6001
140025e3e  }

140025e3e                                                                                            00 00                                ..

140025e40  struct UNWIND_INFO data_140025e40 = 
140025e40  {
140025e40      uint8_t VersionAndFlag = 0x1
140025e41      uint8_t SizeOfProlog = 0x0
140025e42      uint8_t CountOfUnwindCodes = 0x0
140025e43      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025e44  }

140025e44  _.xdata:
140025e44              01 16 09 00                                                                              ....
140025e48  uint16_t data_140025e48[0x9] = 
140025e48  {
140025e48      [0x0] =  0x8816
140025e4a      [0x1] =  0x0006
140025e4c      [0x2] =  0x7810
140025e4e      [0x3] =  0x0005
140025e50      [0x4] =  0x680b
140025e52      [0x5] =  0x0004
140025e54      [0x6] =  0xe206
140025e56      [0x7] =  0x3002
140025e58      [0x8] =  0x6001
140025e5a  }

140025e5a                                                                                00 00                                        ..
140025e5c  _.xdata:
140025e5c                                                                                      01 00 00 00                              ....
140025e60  _.xdata:
140025e60  01 06 03 00                                                                                      ....
140025e64  uint16_t data_140025e64[0x3] = 
140025e64  {
140025e64      [0x0] =  0x6206
140025e66      [0x1] =  0x3002
140025e68      [0x2] =  0x6001
140025e6a  }

140025e6a                                00 00                                                                        ..

140025e6c  struct UNWIND_INFO data_140025e6c = 
140025e6c  {
140025e6c      uint8_t VersionAndFlag = 0x1
140025e6d      uint8_t SizeOfProlog = 0x7
140025e6e      uint8_t CountOfUnwindCodes = 0x4
140025e6f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025e70  }
140025e70  uint16_t data_140025e70[0x4] = 
140025e70  {
140025e70      [0x0] =  0x9207
140025e72      [0x1] =  0x3003
140025e74      [0x2] =  0x6002
140025e76      [0x3] =  0x7001
140025e78  }
140025e78  struct UNWIND_INFO data_140025e78 = 
140025e78  {
140025e78      uint8_t VersionAndFlag = 0x1
140025e79      uint8_t SizeOfProlog = 0x15
140025e7a      uint8_t CountOfUnwindCodes = 0xa
140025e7b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x45
140025e7c  }
140025e7c  uint16_t data_140025e7c[0xa] = 
140025e7c  {
140025e7c      [0x0] =  0x0315
140025e7e      [0x1] =  0x8210
140025e80      [0x2] =  0x300c
140025e82      [0x3] =  0x600b
140025e84      [0x4] =  0x700a
140025e86      [0x5] =  0xc009
140025e88      [0x6] =  0xd007
140025e8a      [0x7] =  0xe005
140025e8c      [0x8] =  0xf003
140025e8e      [0x9] =  0x5001
140025e90  }
140025e90  _.xdata:
140025e90                                                  01 04 01 00                                                      ....
140025e94  uint16_t data_140025e94[0x1] = 
140025e94  {
140025e94      [0x0] =  0xa204
140025e96  }

140025e96                                                                    00 00                                                ..

140025e98  struct UNWIND_INFO data_140025e98 = 
140025e98  {
140025e98      uint8_t VersionAndFlag = 0x1
140025e99      uint8_t SizeOfProlog = 0x0
140025e9a      uint8_t CountOfUnwindCodes = 0x0
140025e9b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025e9c  }

140025e9c  _.xdata:
140025e9c                                                                                      01 05 02 00                              ....
140025ea0  uint16_t data_140025ea0[0x2] = 
140025ea0  {
140025ea0      [0x0] =  0x3205
140025ea2      [0x1] =  0x3001
140025ea4  }
140025ea4  _.xdata:
140025ea4              01 0a 06 00                                                                              ....
140025ea8  uint16_t data_140025ea8[0x6] = 
140025ea8  {
140025ea8      [0x0] =  0x320a
140025eaa      [0x1] =  0x3006
140025eac      [0x2] =  0x6005
140025eae      [0x3] =  0x7004
140025eb0      [0x4] =  0x5003
140025eb2      [0x5] =  0xc002
140025eb4  }
140025eb4  struct UNWIND_INFO data_140025eb4 = 
140025eb4  {
140025eb4      uint8_t VersionAndFlag = 0x1
140025eb5      uint8_t SizeOfProlog = 0x7
140025eb6      uint8_t CountOfUnwindCodes = 0x4
140025eb7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025eb8  }
140025eb8  uint16_t data_140025eb8[0x4] = 
140025eb8  {
140025eb8      [0x0] =  0x3207
140025eba      [0x1] =  0x3003
140025ebc      [0x2] =  0x6002
140025ebe      [0x3] =  0x7001
140025ec0  }
140025ec0  struct UNWIND_INFO data_140025ec0 = 
140025ec0  {
140025ec0      uint8_t VersionAndFlag = 0x1
140025ec1      uint8_t SizeOfProlog = 0x6
140025ec2      uint8_t CountOfUnwindCodes = 0x3
140025ec3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025ec4  }
140025ec4  uint16_t data_140025ec4[0x3] = 
140025ec4  {
140025ec4      [0x0] =  0x4206
140025ec6      [0x1] =  0x3002
140025ec8      [0x2] =  0x6001
140025eca  }

140025eca                                00 00                                                                        ..

140025ecc  struct UNWIND_INFO data_140025ecc = 
140025ecc  {
140025ecc      uint8_t VersionAndFlag = 0x1
140025ecd      uint8_t SizeOfProlog = 0x5
140025ece      uint8_t CountOfUnwindCodes = 0x2
140025ecf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025ed0  }
140025ed0  uint16_t data_140025ed0[0x2] = 
140025ed0  {
140025ed0      [0x0] =  0x3205
140025ed2      [0x1] =  0x3001
140025ed4  }
140025ed4  _.xdata:
140025ed4                                                              01 04 01 00                                              ....
140025ed8  uint16_t data_140025ed8[0x1] = 
140025ed8  {
140025ed8      [0x0] =  0x4204
140025eda  }

140025eda                                                                                00 00                                        ..

140025edc  struct UNWIND_INFO data_140025edc = 
140025edc  {
140025edc      uint8_t VersionAndFlag = 0x1
140025edd      uint8_t SizeOfProlog = 0x4
140025ede      uint8_t CountOfUnwindCodes = 0x1
140025edf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025ee0  }
140025ee0  uint16_t data_140025ee0[0x1] = 
140025ee0  {
140025ee0      [0x0] =  0x4204
140025ee2  }

140025ee2        00 00                                                                                        ..
140025ee4  _.xdata:
140025ee4              01 00 00 00                                                                              ....

140025ee8  struct UNWIND_INFO data_140025ee8 = 
140025ee8  {
140025ee8      uint8_t VersionAndFlag = 0x1
140025ee9      uint8_t SizeOfProlog = 0x0
140025eea      uint8_t CountOfUnwindCodes = 0x0
140025eeb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025eec  }
140025eec  struct UNWIND_INFO data_140025eec = 
140025eec  {
140025eec      uint8_t VersionAndFlag = 0x1
140025eed      uint8_t SizeOfProlog = 0x7
140025eee      uint8_t CountOfUnwindCodes = 0x4
140025eef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025ef0  }
140025ef0  uint16_t data_140025ef0[0x4] = 
140025ef0  {
140025ef0      [0x0] =  0x3207
140025ef2      [0x1] =  0x3003
140025ef4      [0x2] =  0x6002
140025ef6      [0x3] =  0x7001
140025ef8  }
140025ef8  struct UNWIND_INFO data_140025ef8 = 
140025ef8  {
140025ef8      uint8_t VersionAndFlag = 0x1
140025ef9      uint8_t SizeOfProlog = 0x0
140025efa      uint8_t CountOfUnwindCodes = 0x0
140025efb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025efc  }
140025efc  struct UNWIND_INFO data_140025efc = 
140025efc  {
140025efc      uint8_t VersionAndFlag = 0x1
140025efd      uint8_t SizeOfProlog = 0x0
140025efe      uint8_t CountOfUnwindCodes = 0x0
140025eff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f00  }
140025f00  struct UNWIND_INFO data_140025f00 = 
140025f00  {
140025f00      uint8_t VersionAndFlag = 0x1
140025f01      uint8_t SizeOfProlog = 0x0
140025f02      uint8_t CountOfUnwindCodes = 0x0
140025f03      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f04  }
140025f04  struct UNWIND_INFO data_140025f04 = 
140025f04  {
140025f04      uint8_t VersionAndFlag = 0x1
140025f05      uint8_t SizeOfProlog = 0x0
140025f06      uint8_t CountOfUnwindCodes = 0x0
140025f07      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f08  }
140025f08  struct UNWIND_INFO data_140025f08 = 
140025f08  {
140025f08      uint8_t VersionAndFlag = 0x1
140025f09      uint8_t SizeOfProlog = 0x0
140025f0a      uint8_t CountOfUnwindCodes = 0x0
140025f0b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f0c  }
140025f0c  struct UNWIND_INFO data_140025f0c = 
140025f0c  {
140025f0c      uint8_t VersionAndFlag = 0x1
140025f0d      uint8_t SizeOfProlog = 0x0
140025f0e      uint8_t CountOfUnwindCodes = 0x0
140025f0f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f10  }

140025f10  _.xdata:
140025f10                                                  01 07 04 00                                                      ....
140025f14  uint16_t data_140025f14[0x4] = 
140025f14  {
140025f14      [0x0] =  0x3207
140025f16      [0x1] =  0x3003
140025f18      [0x2] =  0x6002
140025f1a      [0x3] =  0x7001
140025f1c  }
140025f1c  struct UNWIND_INFO data_140025f1c = 
140025f1c  {
140025f1c      uint8_t VersionAndFlag = 0x1
140025f1d      uint8_t SizeOfProlog = 0x4
140025f1e      uint8_t CountOfUnwindCodes = 0x1
140025f1f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f20  }
140025f20  uint16_t data_140025f20[0x1] = 
140025f20  {
140025f20      [0x0] =  0x4204
140025f22  }

140025f22        00 00                                                                                        ..

140025f24  struct UNWIND_INFO data_140025f24 = 
140025f24  {
140025f24      uint8_t VersionAndFlag = 0x1
140025f25      uint8_t SizeOfProlog = 0xa
140025f26      uint8_t CountOfUnwindCodes = 0x6
140025f27      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f28  }
140025f28  uint16_t data_140025f28[0x6] = 
140025f28  {
140025f28      [0x0] =  0x320a
140025f2a      [0x1] =  0x3006
140025f2c      [0x2] =  0x6005
140025f2e      [0x3] =  0x7004
140025f30      [0x4] =  0x5003
140025f32      [0x5] =  0xc002
140025f34  }
140025f34  struct UNWIND_INFO data_140025f34 = 
140025f34  {
140025f34      uint8_t VersionAndFlag = 0x1
140025f35      uint8_t SizeOfProlog = 0x0
140025f36      uint8_t CountOfUnwindCodes = 0x0
140025f37      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f38  }

140025f38  _.xdata:
140025f38                                                                          01 07 04 00                                      ....
140025f3c  uint16_t data_140025f3c[0x4] = 
140025f3c  {
140025f3c      [0x0] =  0x5207
140025f3e      [0x1] =  0x3003
140025f40      [0x2] =  0x6002
140025f42      [0x3] =  0x7001
140025f44  }
140025f44  _.xdata:
140025f44              01 04 01 00                                                                              ....
140025f48  uint16_t data_140025f48[0x1] = 
140025f48  {
140025f48      [0x0] =  0xc204
140025f4a  }

140025f4a                                00 00                                                                        ..

140025f4c  struct UNWIND_INFO data_140025f4c = 
140025f4c  {
140025f4c      uint8_t VersionAndFlag = 0x1
140025f4d      uint8_t SizeOfProlog = 0x5
140025f4e      uint8_t CountOfUnwindCodes = 0x2
140025f4f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f50  }
140025f50  uint16_t data_140025f50[0x2] = 
140025f50  {
140025f50      [0x0] =  0x3205
140025f52      [0x1] =  0x3001
140025f54  }
140025f54  struct UNWIND_INFO data_140025f54 = 
140025f54  {
140025f54      uint8_t VersionAndFlag = 0x1
140025f55      uint8_t SizeOfProlog = 0x10
140025f56      uint8_t CountOfUnwindCodes = 0x9
140025f57      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f58  }
140025f58  uint16_t data_140025f58[0x9] = 
140025f58  {
140025f58      [0x0] =  0x8210
140025f5a      [0x1] =  0x300c
140025f5c      [0x2] =  0x600b
140025f5e      [0x3] =  0x700a
140025f60      [0x4] =  0x5009
140025f62      [0x5] =  0xc008
140025f64      [0x6] =  0xd006
140025f66      [0x7] =  0xe004
140025f68      [0x8] =  0xf002
140025f6a  }

140025f6a                                00 00                                                                        ..

140025f6c  struct UNWIND_INFO data_140025f6c = 
140025f6c  {
140025f6c      uint8_t VersionAndFlag = 0x1
140025f6d      uint8_t SizeOfProlog = 0x7
140025f6e      uint8_t CountOfUnwindCodes = 0x4
140025f6f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f70  }
140025f70  uint16_t data_140025f70[0x4] = 
140025f70  {
140025f70      [0x0] =  0x3207
140025f72      [0x1] =  0x3003
140025f74      [0x2] =  0x6002
140025f76      [0x3] =  0x7001
140025f78  }
140025f78  struct UNWIND_INFO data_140025f78 = 
140025f78  {
140025f78      uint8_t VersionAndFlag = 0x1
140025f79      uint8_t SizeOfProlog = 0x6
140025f7a      uint8_t CountOfUnwindCodes = 0x3
140025f7b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f7c  }
140025f7c  uint16_t data_140025f7c[0x3] = 
140025f7c  {
140025f7c      [0x0] =  0x4206
140025f7e      [0x1] =  0x3002
140025f80      [0x2] =  0x6001
140025f82  }

140025f82        00 00                                                                                        ..

140025f84  struct UNWIND_INFO data_140025f84 = 
140025f84  {
140025f84      uint8_t VersionAndFlag = 0x1
140025f85      uint8_t SizeOfProlog = 0x4
140025f86      uint8_t CountOfUnwindCodes = 0x1
140025f87      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025f88  }
140025f88  uint16_t data_140025f88[0x1] = 
140025f88  {
140025f88      [0x0] =  0x6204
140025f8a  }

140025f8a                                00 00                                                                        ..

140025f8c  struct UNWIND_INFO data_140025f8c = 
140025f8c  {
140025f8c      uint8_t VersionAndFlag = 0x1
140025f8d      uint8_t SizeOfProlog = 0x15
140025f8e      uint8_t CountOfUnwindCodes = 0xa
140025f8f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x25
140025f90  }
140025f90  uint16_t data_140025f90[0xa] = 
140025f90  {
140025f90      [0x0] =  0x0315
140025f92      [0x1] =  0x4210
140025f94      [0x2] =  0x300c
140025f96      [0x3] =  0x600b
140025f98      [0x4] =  0x700a
140025f9a      [0x5] =  0xc009
140025f9c      [0x6] =  0xd007
140025f9e      [0x7] =  0xe005
140025fa0      [0x8] =  0xf003
140025fa2      [0x9] =  0x5001
140025fa4  }
140025fa4  struct UNWIND_INFO data_140025fa4 = 
140025fa4  {
140025fa4      uint8_t VersionAndFlag = 0x1
140025fa5      uint8_t SizeOfProlog = 0x15
140025fa6      uint8_t CountOfUnwindCodes = 0xa
140025fa7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x25
140025fa8  }
140025fa8  uint16_t data_140025fa8[0xa] = 
140025fa8  {
140025fa8      [0x0] =  0x0315
140025faa      [0x1] =  0x4210
140025fac      [0x2] =  0x300c
140025fae      [0x3] =  0x600b
140025fb0      [0x4] =  0x700a
140025fb2      [0x5] =  0xc009
140025fb4      [0x6] =  0xd007
140025fb6      [0x7] =  0xe005
140025fb8      [0x8] =  0xf003
140025fba      [0x9] =  0x5001
140025fbc  }
140025fbc  struct UNWIND_INFO data_140025fbc = 
140025fbc  {
140025fbc      uint8_t VersionAndFlag = 0x1
140025fbd      uint8_t SizeOfProlog = 0xf
140025fbe      uint8_t CountOfUnwindCodes = 0x7
140025fbf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x35
140025fc0  }
140025fc0  uint16_t data_140025fc0[0x7] = 
140025fc0  {
140025fc0      [0x0] =  0x030f
140025fc2      [0x1] =  0x520a
140025fc4      [0x2] =  0x3006
140025fc6      [0x3] =  0x6005
140025fc8      [0x4] =  0x7004
140025fca      [0x5] =  0xc003
140025fcc      [0x6] =  0x5001
140025fce  }

140025fce                                            00 00                                                                ..

140025fd0  struct UNWIND_INFO data_140025fd0 = 
140025fd0  {
140025fd0      uint8_t VersionAndFlag = 0x1
140025fd1      uint8_t SizeOfProlog = 0x8
140025fd2      uint8_t CountOfUnwindCodes = 0x5
140025fd3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025fd4  }
140025fd4  uint16_t data_140025fd4[0x5] = 
140025fd4  {
140025fd4      [0x0] =  0x4208
140025fd6      [0x1] =  0x3004
140025fd8      [0x2] =  0x6003
140025fda      [0x3] =  0x7002
140025fdc      [0x4] =  0x5001
140025fde  }

140025fde                                                                                            00 00                                ..

140025fe0  struct UNWIND_INFO data_140025fe0 = 
140025fe0  {
140025fe0      uint8_t VersionAndFlag = 0x1
140025fe1      uint8_t SizeOfProlog = 0x7
140025fe2      uint8_t CountOfUnwindCodes = 0x4
140025fe3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025fe4  }
140025fe4  uint16_t data_140025fe4[0x4] = 
140025fe4  {
140025fe4      [0x0] =  0x3207
140025fe6      [0x1] =  0x3003
140025fe8      [0x2] =  0x6002
140025fea      [0x3] =  0x7001
140025fec  }
140025fec  struct UNWIND_INFO data_140025fec = 
140025fec  {
140025fec      uint8_t VersionAndFlag = 0x1
140025fed      uint8_t SizeOfProlog = 0x6
140025fee      uint8_t CountOfUnwindCodes = 0x3
140025fef      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025ff0  }
140025ff0  uint16_t data_140025ff0[0x3] = 
140025ff0  {
140025ff0      [0x0] =  0xa206
140025ff2      [0x1] =  0x3002
140025ff4      [0x2] =  0x6001
140025ff6  }

140025ff6                                                                    00 00                                                ..

140025ff8  struct UNWIND_INFO data_140025ff8 = 
140025ff8  {
140025ff8      uint8_t VersionAndFlag = 0x1
140025ff9      uint8_t SizeOfProlog = 0x6
140025ffa      uint8_t CountOfUnwindCodes = 0x3
140025ffb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140025ffc  }
140025ffc  uint16_t data_140025ffc[0x3] = 
140025ffc  {
140025ffc      [0x0] =  0xa206
140025ffe      [0x1] =  0x3002
140026000      [0x2] =  0x6001
140026002  }

140026002        00 00                                                                                        ..

140026004  struct UNWIND_INFO data_140026004 = 
140026004  {
140026004      uint8_t VersionAndFlag = 0x1
140026005      uint8_t SizeOfProlog = 0x7
140026006      uint8_t CountOfUnwindCodes = 0x4
140026007      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026008  }
140026008  uint16_t data_140026008[0x4] = 
140026008  {
140026008      [0x0] =  0x9207
14002600a      [0x1] =  0x3003
14002600c      [0x2] =  0x6002
14002600e      [0x3] =  0x7001
140026010  }
140026010  struct UNWIND_INFO data_140026010 = 
140026010  {
140026010      uint8_t VersionAndFlag = 0x1
140026011      uint8_t SizeOfProlog = 0xc
140026012      uint8_t CountOfUnwindCodes = 0x7
140026013      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026014  }
140026014  uint16_t data_140026014[0x7] = 
140026014  {
140026014      [0x0] =  0xa20c
140026016      [0x1] =  0x3008
140026018      [0x2] =  0x6007
14002601a      [0x3] =  0x7006
14002601c      [0x4] =  0x5005
14002601e      [0x5] =  0xc004
140026020      [0x6] =  0xd002
140026022  }

140026022        00 00                                                                                        ..

140026024  struct UNWIND_INFO data_140026024 = 
140026024  {
140026024      uint8_t VersionAndFlag = 0x1
140026025      uint8_t SizeOfProlog = 0x13
140026026      uint8_t CountOfUnwindCodes = 0xa
140026027      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026028  }
140026028  uint16_t data_140026028[0xa] = 
140026028  {
140026028      [0x0] =  0x0113
14002602a      [0x1] =  0x0015
14002602c      [0x2] =  0x300c
14002602e      [0x3] =  0x600b
140026030      [0x4] =  0x700a
140026032      [0x5] =  0x5009
140026034      [0x6] =  0xc008
140026036      [0x7] =  0xd006
140026038      [0x8] =  0xe004
14002603a      [0x9] =  0xf002
14002603c  }
14002603c  _.xdata:
14002603c                                                                                      01 05 02 00                              ....
140026040  uint16_t data_140026040[0x2] = 
140026040  {
140026040      [0x0] =  0x3205
140026042      [0x1] =  0x3001
140026044  }
140026044  struct UNWIND_INFO data_140026044 = 
140026044  {
140026044      uint8_t VersionAndFlag = 0x1
140026045      uint8_t SizeOfProlog = 0x7
140026046      uint8_t CountOfUnwindCodes = 0x4
140026047      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026048  }
140026048  uint16_t data_140026048[0x4] = 
140026048  {
140026048      [0x0] =  0x3207
14002604a      [0x1] =  0x3003
14002604c      [0x2] =  0x6002
14002604e      [0x3] =  0x7001
140026050  }
140026050  struct UNWIND_INFO data_140026050 = 
140026050  {
140026050      uint8_t VersionAndFlag = 0x1
140026051      uint8_t SizeOfProlog = 0x0
140026052      uint8_t CountOfUnwindCodes = 0x0
140026053      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026054  }
140026054  struct UNWIND_INFO data_140026054 = 
140026054  {
140026054      uint8_t VersionAndFlag = 0x1
140026055      uint8_t SizeOfProlog = 0x10
140026056      uint8_t CountOfUnwindCodes = 0x9
140026057      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026058  }
140026058  uint16_t data_140026058[0x9] = 
140026058  {
140026058      [0x0] =  0x6210
14002605a      [0x1] =  0x300c
14002605c      [0x2] =  0x600b
14002605e      [0x3] =  0x700a
140026060      [0x4] =  0x5009
140026062      [0x5] =  0xc008
140026064      [0x6] =  0xd006
140026066      [0x7] =  0xe004
140026068      [0x8] =  0xf002
14002606a  }

14002606a                                00 00                                                                        ..
14002606c  _.xdata:
14002606c                                      01 13 0a 00                                                              ....
140026070  uint16_t data_140026070[0xa] = 
140026070  {
140026070      [0x0] =  0x0113
140026072      [0x1] =  0x0017
140026074      [0x2] =  0x300c
140026076      [0x3] =  0x600b
140026078      [0x4] =  0x700a
14002607a      [0x5] =  0x5009
14002607c      [0x6] =  0xc008
14002607e      [0x7] =  0xd006
140026080      [0x8] =  0xe004
140026082      [0x9] =  0xf002
140026084  }
140026084  _.xdata:
140026084              01 06 05 00                                                                              ....
140026088  uint16_t data_140026088[0x5] = 
140026088  {
140026088      [0x0] =  0x3006
14002608a      [0x1] =  0x6005
14002608c      [0x2] =  0x7004
14002608e      [0x3] =  0x5003
140026090      [0x4] =  0xc002
140026092  }

140026092                                                        00 00                                                        ..

140026094  struct UNWIND_INFO data_140026094 = 
140026094  {
140026094      uint8_t VersionAndFlag = 0x1
140026095      uint8_t SizeOfProlog = 0x0
140026096      uint8_t CountOfUnwindCodes = 0x0
140026097      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026098  }

140026098  _.xdata:
140026098                                                                          01 07 04 00                                      ....
14002609c  uint16_t data_14002609c[0x4] = 
14002609c  {
14002609c      [0x0] =  0x3207
14002609e      [0x1] =  0x3003
1400260a0      [0x2] =  0x6002
1400260a2      [0x3] =  0x7001
1400260a4  }
1400260a4  struct UNWIND_INFO data_1400260a4 = 
1400260a4  {
1400260a4      uint8_t VersionAndFlag = 0x1
1400260a5      uint8_t SizeOfProlog = 0x5
1400260a6      uint8_t CountOfUnwindCodes = 0x2
1400260a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400260a8  }
1400260a8  uint16_t data_1400260a8[0x2] = 
1400260a8  {
1400260a8      [0x0] =  0x3205
1400260aa      [0x1] =  0x3001
1400260ac  }
1400260ac  struct UNWIND_INFO data_1400260ac = 
1400260ac  {
1400260ac      uint8_t VersionAndFlag = 0x1
1400260ad      uint8_t SizeOfProlog = 0x6
1400260ae      uint8_t CountOfUnwindCodes = 0x3
1400260af      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400260b0  }
1400260b0  uint16_t data_1400260b0[0x3] = 
1400260b0  {
1400260b0      [0x0] =  0x6206
1400260b2      [0x1] =  0x3002
1400260b4      [0x2] =  0x6001
1400260b6  }

1400260b6                                                                    00 00                                                ..

1400260b8  struct UNWIND_INFO data_1400260b8 = 
1400260b8  {
1400260b8      uint8_t VersionAndFlag = 0x1
1400260b9      uint8_t SizeOfProlog = 0x5
1400260ba      uint8_t CountOfUnwindCodes = 0x2
1400260bb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400260bc  }
1400260bc  uint16_t data_1400260bc[0x2] = 
1400260bc  {
1400260bc      [0x0] =  0x3205
1400260be      [0x1] =  0x3001
1400260c0  }
1400260c0  struct UNWIND_INFO data_1400260c0 = 
1400260c0  {
1400260c0      uint8_t VersionAndFlag = 0x1
1400260c1      uint8_t SizeOfProlog = 0x8
1400260c2      uint8_t CountOfUnwindCodes = 0x5
1400260c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400260c4  }
1400260c4  uint16_t data_1400260c4[0x5] = 
1400260c4  {
1400260c4      [0x0] =  0x4208
1400260c6      [0x1] =  0x3004
1400260c8      [0x2] =  0x6003
1400260ca      [0x3] =  0x7002
1400260cc      [0x4] =  0x5001
1400260ce  }

1400260ce                                            00 00                                                                ..

1400260d0  struct UNWIND_INFO data_1400260d0 = 
1400260d0  {
1400260d0      uint8_t VersionAndFlag = 0x1
1400260d1      uint8_t SizeOfProlog = 0x5
1400260d2      uint8_t CountOfUnwindCodes = 0x2
1400260d3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400260d4  }
1400260d4  uint16_t data_1400260d4[0x2] = 
1400260d4  {
1400260d4      [0x0] =  0x5205
1400260d6      [0x1] =  0x3001
1400260d8  }
1400260d8  struct UNWIND_INFO data_1400260d8 = 
1400260d8  {
1400260d8      uint8_t VersionAndFlag = 0x1
1400260d9      uint8_t SizeOfProlog = 0x10
1400260da      uint8_t CountOfUnwindCodes = 0x9
1400260db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400260dc  }
1400260dc  uint16_t data_1400260dc[0x9] = 
1400260dc  {
1400260dc      [0x0] =  0x4210
1400260de      [0x1] =  0x300c
1400260e0      [0x2] =  0x600b
1400260e2      [0x3] =  0x700a
1400260e4      [0x4] =  0x5009
1400260e6      [0x5] =  0xc008
1400260e8      [0x6] =  0xd006
1400260ea      [0x7] =  0xe004
1400260ec      [0x8] =  0xf002
1400260ee  }

1400260ee                                            00 00                                                                ..

1400260f0  struct UNWIND_INFO data_1400260f0 = 
1400260f0  {
1400260f0      uint8_t VersionAndFlag = 0x1
1400260f1      uint8_t SizeOfProlog = 0x8
1400260f2      uint8_t CountOfUnwindCodes = 0x5
1400260f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400260f4  }
1400260f4  uint16_t data_1400260f4[0x5] = 
1400260f4  {
1400260f4      [0x0] =  0x4208
1400260f6      [0x1] =  0x3004
1400260f8      [0x2] =  0x6003
1400260fa      [0x3] =  0x7002
1400260fc      [0x4] =  0x5001
1400260fe  }

1400260fe                                                                                            00 00                                ..

140026100  struct UNWIND_INFO data_140026100 = 
140026100  {
140026100      uint8_t VersionAndFlag = 0x1
140026101      uint8_t SizeOfProlog = 0xe
140026102      uint8_t CountOfUnwindCodes = 0x8
140026103      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026104  }
140026104  uint16_t data_140026104[0x8] = 
140026104  {
140026104      [0x0] =  0x320e
140026106      [0x1] =  0x300a
140026108      [0x2] =  0x6009
14002610a      [0x3] =  0x7008
14002610c      [0x4] =  0x5007
14002610e      [0x5] =  0xc006
140026110      [0x6] =  0xd004
140026112      [0x7] =  0xe002
140026114  }
140026114  struct UNWIND_INFO data_140026114 = 
140026114  {
140026114      uint8_t VersionAndFlag = 0x1
140026115      uint8_t SizeOfProlog = 0x0
140026116      uint8_t CountOfUnwindCodes = 0x0
140026117      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026118  }
140026118  struct UNWIND_INFO data_140026118 = 
140026118  {
140026118      uint8_t VersionAndFlag = 0x1
140026119      uint8_t SizeOfProlog = 0xe
14002611a      uint8_t CountOfUnwindCodes = 0x8
14002611b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002611c  }
14002611c  uint16_t data_14002611c[0x8] = 
14002611c  {
14002611c      [0x0] =  0x320e
14002611e      [0x1] =  0x300a
140026120      [0x2] =  0x6009
140026122      [0x3] =  0x7008
140026124      [0x4] =  0x5007
140026126      [0x5] =  0xc006
140026128      [0x6] =  0xd004
14002612a      [0x7] =  0xe002
14002612c  }
14002612c  struct UNWIND_INFO data_14002612c = 
14002612c  {
14002612c      uint8_t VersionAndFlag = 0x1
14002612d      uint8_t SizeOfProlog = 0x3
14002612e      uint8_t CountOfUnwindCodes = 0x3
14002612f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026130  }
140026130  uint16_t data_140026130[0x3] = 
140026130  {
140026130      [0x0] =  0x3003
140026132      [0x1] =  0x6002
140026134      [0x2] =  0x7001
140026136  }

140026136                                                                    00 00                                                ..

140026138  struct UNWIND_INFO data_140026138 = 
140026138  {
140026138      uint8_t VersionAndFlag = 0x1
140026139      uint8_t SizeOfProlog = 0x7
14002613a      uint8_t CountOfUnwindCodes = 0x4
14002613b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002613c  }
14002613c  uint16_t data_14002613c[0x4] = 
14002613c  {
14002613c      [0x0] =  0x3207
14002613e      [0x1] =  0x3003
140026140      [0x2] =  0x6002
140026142      [0x3] =  0x7001
140026144  }
140026144  struct UNWIND_INFO data_140026144 = 
140026144  {
140026144      uint8_t VersionAndFlag = 0x1
140026145      uint8_t SizeOfProlog = 0x0
140026146      uint8_t CountOfUnwindCodes = 0x0
140026147      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026148  }

140026148  _.xdata:
140026148                          01 00 00 00                                                                      ....
14002614c  _.xdata:
14002614c                                      01 00 00 00                                                              ....
140026150  _.xdata:
140026150                                                  01 04 01 00                                                      ....
140026154  uint16_t data_140026154[0x1] = 
140026154  {
140026154      [0x0] =  0x6204
140026156  }

140026156                                                                    00 00                                                ..
140026158  _.xdata:
140026158                                                                          01 04 01 00                                      ....
14002615c  uint16_t data_14002615c[0x1] = 
14002615c  {
14002615c      [0x0] =  0x8204
14002615e  }

14002615e                                                                                            00 00                                ..
140026160  _.xdata:
140026160  01 00 00 00                                                                                      ....

140026164  struct UNWIND_INFO data_140026164 = 
140026164  {
140026164      uint8_t VersionAndFlag = 0x1
140026165      uint8_t SizeOfProlog = 0xa
140026166      uint8_t CountOfUnwindCodes = 0x6
140026167      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026168  }
140026168  uint16_t data_140026168[0x6] = 
140026168  {
140026168      [0x0] =  0x320a
14002616a      [0x1] =  0x3006
14002616c      [0x2] =  0x6005
14002616e      [0x3] =  0x7004
140026170      [0x4] =  0x5003
140026172      [0x5] =  0xc002
140026174  }
140026174  struct UNWIND_INFO data_140026174 = 
140026174  {
140026174      uint8_t VersionAndFlag = 0x1
140026175      uint8_t SizeOfProlog = 0xa
140026176      uint8_t CountOfUnwindCodes = 0x6
140026177      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026178  }
140026178  uint16_t data_140026178[0x6] = 
140026178  {
140026178      [0x0] =  0x320a
14002617a      [0x1] =  0x3006
14002617c      [0x2] =  0x6005
14002617e      [0x3] =  0x7004
140026180      [0x4] =  0x5003
140026182      [0x5] =  0xc002
140026184  }
140026184  struct UNWIND_INFO data_140026184 = 
140026184  {
140026184      uint8_t VersionAndFlag = 0x1
140026185      uint8_t SizeOfProlog = 0x5
140026186      uint8_t CountOfUnwindCodes = 0x2
140026187      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026188  }
140026188  uint16_t data_140026188[0x2] = 
140026188  {
140026188      [0x0] =  0x3205
14002618a      [0x1] =  0x3001
14002618c  }
14002618c  struct UNWIND_INFO data_14002618c = 
14002618c  {
14002618c      uint8_t VersionAndFlag = 0x1
14002618d      uint8_t SizeOfProlog = 0x0
14002618e      uint8_t CountOfUnwindCodes = 0x0
14002618f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026190  }
140026190  struct UNWIND_INFO data_140026190 = 
140026190  {
140026190      uint8_t VersionAndFlag = 0x1
140026191      uint8_t SizeOfProlog = 0x5
140026192      uint8_t CountOfUnwindCodes = 0x2
140026193      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026194  }
140026194  uint16_t data_140026194[0x2] = 
140026194  {
140026194      [0x0] =  0x3205
140026196      [0x1] =  0x3001
140026198  }
140026198  struct UNWIND_INFO data_140026198 = 
140026198  {
140026198      uint8_t VersionAndFlag = 0x1
140026199      uint8_t SizeOfProlog = 0x4
14002619a      uint8_t CountOfUnwindCodes = 0x1
14002619b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002619c  }
14002619c  uint16_t data_14002619c[0x1] = 
14002619c  {
14002619c      [0x0] =  0x8204
14002619e  }

14002619e                                                                                            00 00                                ..

1400261a0  struct UNWIND_INFO data_1400261a0 = 
1400261a0  {
1400261a0      uint8_t VersionAndFlag = 0x1
1400261a1      uint8_t SizeOfProlog = 0x4
1400261a2      uint8_t CountOfUnwindCodes = 0x1
1400261a3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400261a4  }
1400261a4  uint16_t data_1400261a4[0x1] = 
1400261a4  {
1400261a4      [0x0] =  0x4204
1400261a6  }

1400261a6                    00 00                                                                                ..

1400261a8  struct UNWIND_INFO data_1400261a8 = 
1400261a8  {
1400261a8      uint8_t VersionAndFlag = 0x1
1400261a9      uint8_t SizeOfProlog = 0x4
1400261aa      uint8_t CountOfUnwindCodes = 0x1
1400261ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400261ac  }
1400261ac  uint16_t data_1400261ac[0x1] = 
1400261ac  {
1400261ac      [0x0] =  0x4204
1400261ae  }

1400261ae                                            00 00                                                                ..
1400261b0  _.xdata:
1400261b0                                                  01 06 03 00                                                      ....
1400261b4  uint16_t data_1400261b4[0x3] = 
1400261b4  {
1400261b4      [0x0] =  0x4206
1400261b6      [0x1] =  0x3002
1400261b8      [0x2] =  0x6001
1400261ba  }

1400261ba                                                                                00 00                                        ..

1400261bc  struct UNWIND_INFO data_1400261bc = 
1400261bc  {
1400261bc      uint8_t VersionAndFlag = 0x1
1400261bd      uint8_t SizeOfProlog = 0x8
1400261be      uint8_t CountOfUnwindCodes = 0x5
1400261bf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400261c0  }
1400261c0  uint16_t data_1400261c0[0x5] = 
1400261c0  {
1400261c0      [0x0] =  0x4208
1400261c2      [0x1] =  0x3004
1400261c4      [0x2] =  0x6003
1400261c6      [0x3] =  0x7002
1400261c8      [0x4] =  0x5001
1400261ca  }

1400261ca                                00 00                                                                        ..

1400261cc  struct UNWIND_INFO data_1400261cc = 
1400261cc  {
1400261cc      uint8_t VersionAndFlag = 0x1
1400261cd      uint8_t SizeOfProlog = 0xa
1400261ce      uint8_t CountOfUnwindCodes = 0x6
1400261cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400261d0  }
1400261d0  uint16_t data_1400261d0[0x6] = 
1400261d0  {
1400261d0      [0x0] =  0x320a
1400261d2      [0x1] =  0x3006
1400261d4      [0x2] =  0x6005
1400261d6      [0x3] =  0x7004
1400261d8      [0x4] =  0x5003
1400261da      [0x5] =  0xc002
1400261dc  }
1400261dc  struct UNWIND_INFO data_1400261dc = 
1400261dc  {
1400261dc      uint8_t VersionAndFlag = 0x1
1400261dd      uint8_t SizeOfProlog = 0x5
1400261de      uint8_t CountOfUnwindCodes = 0x2
1400261df      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400261e0  }
1400261e0  uint16_t data_1400261e0[0x2] = 
1400261e0  {
1400261e0      [0x0] =  0x5205
1400261e2      [0x1] =  0x3001
1400261e4  }
1400261e4  struct UNWIND_INFO data_1400261e4 = 
1400261e4  {
1400261e4      uint8_t VersionAndFlag = 0x1
1400261e5      uint8_t SizeOfProlog = 0x6
1400261e6      uint8_t CountOfUnwindCodes = 0x3
1400261e7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400261e8  }
1400261e8  uint16_t data_1400261e8[0x3] = 
1400261e8  {
1400261e8      [0x0] =  0x4206
1400261ea      [0x1] =  0x3002
1400261ec      [0x2] =  0x6001
1400261ee  }

1400261ee                                            00 00                                                                ..

1400261f0  struct UNWIND_INFO data_1400261f0 = 
1400261f0  {
1400261f0      uint8_t VersionAndFlag = 0x1
1400261f1      uint8_t SizeOfProlog = 0x0
1400261f2      uint8_t CountOfUnwindCodes = 0x0
1400261f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400261f4  }
1400261f4  struct UNWIND_INFO data_1400261f4 = 
1400261f4  {
1400261f4      uint8_t VersionAndFlag = 0x1
1400261f5      uint8_t SizeOfProlog = 0x6
1400261f6      uint8_t CountOfUnwindCodes = 0x3
1400261f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400261f8  }
1400261f8  uint16_t data_1400261f8[0x3] = 
1400261f8  {
1400261f8      [0x0] =  0x4206
1400261fa      [0x1] =  0x3002
1400261fc      [0x2] =  0x6001
1400261fe  }

1400261fe                                                                                            00 00                                ..

140026200  struct UNWIND_INFO data_140026200 = 
140026200  {
140026200      uint8_t VersionAndFlag = 0x1
140026201      uint8_t SizeOfProlog = 0x0
140026202      uint8_t CountOfUnwindCodes = 0x0
140026203      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026204  }
140026204  struct UNWIND_INFO data_140026204 = 
140026204  {
140026204      uint8_t VersionAndFlag = 0x1
140026205      uint8_t SizeOfProlog = 0x0
140026206      uint8_t CountOfUnwindCodes = 0x0
140026207      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026208  }
140026208  struct UNWIND_INFO data_140026208 = 
140026208  {
140026208      uint8_t VersionAndFlag = 0x1
140026209      uint8_t SizeOfProlog = 0x0
14002620a      uint8_t CountOfUnwindCodes = 0x0
14002620b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002620c  }
14002620c  struct UNWIND_INFO data_14002620c = 
14002620c  {
14002620c      uint8_t VersionAndFlag = 0x1
14002620d      uint8_t SizeOfProlog = 0x0
14002620e      uint8_t CountOfUnwindCodes = 0x0
14002620f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026210  }
140026210  struct UNWIND_INFO data_140026210 = 
140026210  {
140026210      uint8_t VersionAndFlag = 0x1
140026211      uint8_t SizeOfProlog = 0x0
140026212      uint8_t CountOfUnwindCodes = 0x0
140026213      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026214  }
140026214  struct UNWIND_INFO data_140026214 = 
140026214  {
140026214      uint8_t VersionAndFlag = 0x1
140026215      uint8_t SizeOfProlog = 0x0
140026216      uint8_t CountOfUnwindCodes = 0x0
140026217      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026218  }
140026218  struct UNWIND_INFO data_140026218 = 
140026218  {
140026218      uint8_t VersionAndFlag = 0x1
140026219      uint8_t SizeOfProlog = 0x0
14002621a      uint8_t CountOfUnwindCodes = 0x0
14002621b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002621c  }
14002621c  struct UNWIND_INFO data_14002621c = 
14002621c  {
14002621c      uint8_t VersionAndFlag = 0x1
14002621d      uint8_t SizeOfProlog = 0x0
14002621e      uint8_t CountOfUnwindCodes = 0x0
14002621f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026220  }
140026220  struct UNWIND_INFO data_140026220 = 
140026220  {
140026220      uint8_t VersionAndFlag = 0x1
140026221      uint8_t SizeOfProlog = 0x0
140026222      uint8_t CountOfUnwindCodes = 0x0
140026223      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026224  }
140026224  struct UNWIND_INFO data_140026224 = 
140026224  {
140026224      uint8_t VersionAndFlag = 0x1
140026225      uint8_t SizeOfProlog = 0x0
140026226      uint8_t CountOfUnwindCodes = 0x0
140026227      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026228  }

140026228  _.xdata:
140026228                          01 00 00 00                                                                      ....

14002622c  struct UNWIND_INFO data_14002622c = 
14002622c  {
14002622c      uint8_t VersionAndFlag = 0x1
14002622d      uint8_t SizeOfProlog = 0x0
14002622e      uint8_t CountOfUnwindCodes = 0x0
14002622f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026230  }
140026230  struct UNWIND_INFO data_140026230 = 
140026230  {
140026230      uint8_t VersionAndFlag = 0x1
140026231      uint8_t SizeOfProlog = 0x7
140026232      uint8_t CountOfUnwindCodes = 0x4
140026233      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026234  }
140026234  uint16_t data_140026234[0x4] = 
140026234  {
140026234      [0x0] =  0x3207
140026236      [0x1] =  0x3003
140026238      [0x2] =  0x6002
14002623a      [0x3] =  0x7001
14002623c  }
14002623c  struct UNWIND_INFO data_14002623c = 
14002623c  {
14002623c      uint8_t VersionAndFlag = 0x1
14002623d      uint8_t SizeOfProlog = 0xa
14002623e      uint8_t CountOfUnwindCodes = 0x6
14002623f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026240  }
140026240  uint16_t data_140026240[0x6] = 
140026240  {
140026240      [0x0] =  0x320a
140026242      [0x1] =  0x3006
140026244      [0x2] =  0x6005
140026246      [0x3] =  0x7004
140026248      [0x4] =  0x5003
14002624a      [0x5] =  0xc002
14002624c  }
14002624c  struct UNWIND_INFO data_14002624c = 
14002624c  {
14002624c      uint8_t VersionAndFlag = 0x1
14002624d      uint8_t SizeOfProlog = 0x4
14002624e      uint8_t CountOfUnwindCodes = 0x1
14002624f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026250  }
140026250  uint16_t data_140026250[0x1] = 
140026250  {
140026250      [0x0] =  0x4204
140026252  }

140026252                                                        00 00                                                        ..

140026254  struct UNWIND_INFO data_140026254 = 
140026254  {
140026254      uint8_t VersionAndFlag = 0x1
140026255      uint8_t SizeOfProlog = 0x7
140026256      uint8_t CountOfUnwindCodes = 0x2
140026257      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026258  }
140026258  uint16_t data_140026258[0x2] = 
140026258  {
140026258      [0x0] =  0x0107
14002625a      [0x1] =  0x0013
14002625c  }
14002625c  struct UNWIND_INFO data_14002625c = 
14002625c  {
14002625c      uint8_t VersionAndFlag = 0x1
14002625d      uint8_t SizeOfProlog = 0x7
14002625e      uint8_t CountOfUnwindCodes = 0x4
14002625f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026260  }
140026260  uint16_t data_140026260[0x4] = 
140026260  {
140026260      [0x0] =  0x3207
140026262      [0x1] =  0x3003
140026264      [0x2] =  0x6002
140026266      [0x3] =  0x7001
140026268  }
140026268  struct UNWIND_INFO data_140026268 = 
140026268  {
140026268      uint8_t VersionAndFlag = 0x1
140026269      uint8_t SizeOfProlog = 0x5
14002626a      uint8_t CountOfUnwindCodes = 0x2
14002626b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002626c  }
14002626c  uint16_t data_14002626c[0x2] = 
14002626c  {
14002626c      [0x0] =  0x3205
14002626e      [0x1] =  0x3001
140026270  }
140026270  struct UNWIND_INFO data_140026270 = 
140026270  {
140026270      uint8_t VersionAndFlag = 0x1
140026271      uint8_t SizeOfProlog = 0x7
140026272      uint8_t CountOfUnwindCodes = 0x4
140026273      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026274  }
140026274  uint16_t data_140026274[0x4] = 
140026274  {
140026274      [0x0] =  0x3207
140026276      [0x1] =  0x3003
140026278      [0x2] =  0x6002
14002627a      [0x3] =  0x7001
14002627c  }
14002627c  struct UNWIND_INFO data_14002627c = 
14002627c  {
14002627c      uint8_t VersionAndFlag = 0x1
14002627d      uint8_t SizeOfProlog = 0x8
14002627e      uint8_t CountOfUnwindCodes = 0x5
14002627f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026280  }
140026280  uint16_t data_140026280[0x5] = 
140026280  {
140026280      [0x0] =  0x4208
140026282      [0x1] =  0x3004
140026284      [0x2] =  0x6003
140026286      [0x3] =  0x7002
140026288      [0x4] =  0x5001
14002628a  }

14002628a                                00 00                                                                        ..

14002628c  struct UNWIND_INFO data_14002628c = 
14002628c  {
14002628c      uint8_t VersionAndFlag = 0x1
14002628d      uint8_t SizeOfProlog = 0x0
14002628e      uint8_t CountOfUnwindCodes = 0x0
14002628f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026290  }
140026290  struct UNWIND_INFO data_140026290 = 
140026290  {
140026290      uint8_t VersionAndFlag = 0x1
140026291      uint8_t SizeOfProlog = 0x8
140026292      uint8_t CountOfUnwindCodes = 0x5
140026293      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026294  }
140026294  uint16_t data_140026294[0x5] = 
140026294  {
140026294      [0x0] =  0x4208
140026296      [0x1] =  0x3004
140026298      [0x2] =  0x6003
14002629a      [0x3] =  0x7002
14002629c      [0x4] =  0x5001
14002629e  }

14002629e                                                                                            00 00                                ..

1400262a0  struct UNWIND_INFO data_1400262a0 = 
1400262a0  {
1400262a0      uint8_t VersionAndFlag = 0x1
1400262a1      uint8_t SizeOfProlog = 0x8
1400262a2      uint8_t CountOfUnwindCodes = 0x5
1400262a3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400262a4  }
1400262a4  uint16_t data_1400262a4[0x5] = 
1400262a4  {
1400262a4      [0x0] =  0x8208
1400262a6      [0x1] =  0x3004
1400262a8      [0x2] =  0x6003
1400262aa      [0x3] =  0x7002
1400262ac      [0x4] =  0x5001
1400262ae  }

1400262ae                                            00 00                                                                ..

1400262b0  struct UNWIND_INFO data_1400262b0 = 
1400262b0  {
1400262b0      uint8_t VersionAndFlag = 0x1
1400262b1      uint8_t SizeOfProlog = 0x4
1400262b2      uint8_t CountOfUnwindCodes = 0x1
1400262b3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400262b4  }
1400262b4  uint16_t data_1400262b4[0x1] = 
1400262b4  {
1400262b4      [0x0] =  0x4204
1400262b6  }

1400262b6                                                                    00 00                                                ..

1400262b8  struct UNWIND_INFO data_1400262b8 = 
1400262b8  {
1400262b8      uint8_t VersionAndFlag = 0x1
1400262b9      uint8_t SizeOfProlog = 0x10
1400262ba      uint8_t CountOfUnwindCodes = 0x9
1400262bb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400262bc  }
1400262bc  uint16_t data_1400262bc[0x9] = 
1400262bc  {
1400262bc      [0x0] =  0x4210
1400262be      [0x1] =  0x300c
1400262c0      [0x2] =  0x600b
1400262c2      [0x3] =  0x700a
1400262c4      [0x4] =  0x5009
1400262c6      [0x5] =  0xc008
1400262c8      [0x6] =  0xd006
1400262ca      [0x7] =  0xe004
1400262cc      [0x8] =  0xf002
1400262ce  }

1400262ce                                            00 00                                                                ..

1400262d0  struct UNWIND_INFO data_1400262d0 = 
1400262d0  {
1400262d0      uint8_t VersionAndFlag = 0x9
1400262d1      uint8_t SizeOfProlog = 0xa
1400262d2      uint8_t CountOfUnwindCodes = 0x5
1400262d3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x5
1400262d4  }
1400262d4  uint16_t data_1400262d4[0x5] = 
1400262d4  {
1400262d4      [0x0] =  0x320a
1400262d6      [0x1] =  0x3006
1400262d8      [0x2] =  0x6005
1400262da      [0x3] =  0x0304
1400262dc      [0x4] =  0x5001
1400262de  }

1400262de                                                                                            00 00                                ..

1400262e0  uint32_t data_1400262e0 = 0x194b0

1400262e4              01 00 00 00 74 a7 01 00 9f a7 01 00 60 37 01 00 9f a7 01 00                              ....t.......`7......

1400262f8  struct UNWIND_INFO data_1400262f8 = 
1400262f8  {
1400262f8      uint8_t VersionAndFlag = 0x1
1400262f9      uint8_t SizeOfProlog = 0x8
1400262fa      uint8_t CountOfUnwindCodes = 0x5
1400262fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400262fc  }
1400262fc  uint16_t data_1400262fc[0x5] = 
1400262fc  {
1400262fc      [0x0] =  0x4208
1400262fe      [0x1] =  0x3004
140026300      [0x2] =  0x6003
140026302      [0x3] =  0x7002
140026304      [0x4] =  0x5001
140026306  }

140026306                    00 00                                                                                ..

140026308  struct UNWIND_INFO data_140026308 = 
140026308  {
140026308      uint8_t VersionAndFlag = 0x1
140026309      uint8_t SizeOfProlog = 0x7
14002630a      uint8_t CountOfUnwindCodes = 0x4
14002630b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002630c  }
14002630c  uint16_t data_14002630c[0x4] = 
14002630c  {
14002630c      [0x0] =  0x3207
14002630e      [0x1] =  0x3003
140026310      [0x2] =  0x6002
140026312      [0x3] =  0x7001
140026314  }
140026314  struct UNWIND_INFO data_140026314 = 
140026314  {
140026314      uint8_t VersionAndFlag = 0x1
140026315      uint8_t SizeOfProlog = 0x0
140026316      uint8_t CountOfUnwindCodes = 0x0
140026317      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026318  }
140026318  struct UNWIND_INFO data_140026318 = 
140026318  {
140026318      uint8_t VersionAndFlag = 0x1
140026319      uint8_t SizeOfProlog = 0xe
14002631a      uint8_t CountOfUnwindCodes = 0x8
14002631b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002631c  }
14002631c  uint16_t data_14002631c[0x8] = 
14002631c  {
14002631c      [0x0] =  0x520e
14002631e      [0x1] =  0x300a
140026320      [0x2] =  0x6009
140026322      [0x3] =  0x7008
140026324      [0x4] =  0x5007
140026326      [0x5] =  0xc006
140026328      [0x6] =  0xd004
14002632a      [0x7] =  0xe002
14002632c  }
14002632c  struct UNWIND_INFO data_14002632c = 
14002632c  {
14002632c      uint8_t VersionAndFlag = 0x1
14002632d      uint8_t SizeOfProlog = 0x0
14002632e      uint8_t CountOfUnwindCodes = 0x0
14002632f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026330  }
140026330  struct UNWIND_INFO data_140026330 = 
140026330  {
140026330      uint8_t VersionAndFlag = 0x1
140026331      uint8_t SizeOfProlog = 0x4
140026332      uint8_t CountOfUnwindCodes = 0x1
140026333      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026334  }
140026334  uint16_t data_140026334[0x1] = 
140026334  {
140026334      [0x0] =  0x6204
140026336  }

140026336                                                                    00 00                                                ..

140026338  struct UNWIND_INFO data_140026338 = 
140026338  {
140026338      uint8_t VersionAndFlag = 0x1
140026339      uint8_t SizeOfProlog = 0x8
14002633a      uint8_t CountOfUnwindCodes = 0x5
14002633b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002633c  }
14002633c  uint16_t data_14002633c[0x5] = 
14002633c  {
14002633c      [0x0] =  0x6208
14002633e      [0x1] =  0x3004
140026340      [0x2] =  0x6003
140026342      [0x3] =  0x7002
140026344      [0x4] =  0x5001
140026346  }

140026346                    00 00                                                                                ..

140026348  struct UNWIND_INFO data_140026348 = 
140026348  {
140026348      uint8_t VersionAndFlag = 0x1
140026349      uint8_t SizeOfProlog = 0xa
14002634a      uint8_t CountOfUnwindCodes = 0x6
14002634b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002634c  }
14002634c  uint16_t data_14002634c[0x6] = 
14002634c  {
14002634c      [0x0] =  0x720a
14002634e      [0x1] =  0x3006
140026350      [0x2] =  0x6005
140026352      [0x3] =  0x7004
140026354      [0x4] =  0x5003
140026356      [0x5] =  0xc002
140026358  }
140026358  struct UNWIND_INFO data_140026358 = 
140026358  {
140026358      uint8_t VersionAndFlag = 0x1
140026359      uint8_t SizeOfProlog = 0xe
14002635a      uint8_t CountOfUnwindCodes = 0x8
14002635b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002635c  }
14002635c  uint16_t data_14002635c[0x8] = 
14002635c  {
14002635c      [0x0] =  0x320e
14002635e      [0x1] =  0x300a
140026360      [0x2] =  0x6009
140026362      [0x3] =  0x7008
140026364      [0x4] =  0x5007
140026366      [0x5] =  0xc006
140026368      [0x6] =  0xd004
14002636a      [0x7] =  0xe002
14002636c  }
14002636c  struct UNWIND_INFO data_14002636c = 
14002636c  {
14002636c      uint8_t VersionAndFlag = 0x1
14002636d      uint8_t SizeOfProlog = 0xa
14002636e      uint8_t CountOfUnwindCodes = 0x6
14002636f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026370  }
140026370  uint16_t data_140026370[0x6] = 
140026370  {
140026370      [0x0] =  0x320a
140026372      [0x1] =  0x3006
140026374      [0x2] =  0x6005
140026376      [0x3] =  0x7004
140026378      [0x4] =  0x5003
14002637a      [0x5] =  0xc002
14002637c  }
14002637c  struct UNWIND_INFO data_14002637c = 
14002637c  {
14002637c      uint8_t VersionAndFlag = 0x1
14002637d      uint8_t SizeOfProlog = 0xa
14002637e      uint8_t CountOfUnwindCodes = 0x6
14002637f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026380  }
140026380  uint16_t data_140026380[0x6] = 
140026380  {
140026380      [0x0] =  0x320a
140026382      [0x1] =  0x3006
140026384      [0x2] =  0x6005
140026386      [0x3] =  0x7004
140026388      [0x4] =  0x5003
14002638a      [0x5] =  0xc002
14002638c  }
14002638c  struct UNWIND_INFO data_14002638c = 
14002638c  {
14002638c      uint8_t VersionAndFlag = 0x1
14002638d      uint8_t SizeOfProlog = 0x15
14002638e      uint8_t CountOfUnwindCodes = 0xb
14002638f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026390  }
140026390  uint16_t data_140026390[0xb] = 
140026390  {
140026390      [0x0] =  0x6815
140026392      [0x1] =  0x0002
140026394      [0x2] =  0x6210
140026396      [0x3] =  0x300c
140026398      [0x4] =  0x600b
14002639a      [0x5] =  0x700a
14002639c      [0x6] =  0x5009
14002639e      [0x7] =  0xc008
1400263a0      [0x8] =  0xd006
1400263a2      [0x9] =  0xe004
1400263a4      [0xa] =  0xf002
1400263a6  }

1400263a6                    00 00                                                                                ..

1400263a8  struct UNWIND_INFO data_1400263a8 = 
1400263a8  {
1400263a8      uint8_t VersionAndFlag = 0x1
1400263a9      uint8_t SizeOfProlog = 0x0
1400263aa      uint8_t CountOfUnwindCodes = 0x0
1400263ab      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263ac  }
1400263ac  struct UNWIND_INFO data_1400263ac = 
1400263ac  {
1400263ac      uint8_t VersionAndFlag = 0x1
1400263ad      uint8_t SizeOfProlog = 0x0
1400263ae      uint8_t CountOfUnwindCodes = 0x0
1400263af      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263b0  }
1400263b0  struct UNWIND_INFO data_1400263b0 = 
1400263b0  {
1400263b0      uint8_t VersionAndFlag = 0x1
1400263b1      uint8_t SizeOfProlog = 0x4
1400263b2      uint8_t CountOfUnwindCodes = 0x1
1400263b3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263b4  }
1400263b4  uint16_t data_1400263b4[0x1] = 
1400263b4  {
1400263b4      [0x0] =  0x4204
1400263b6  }

1400263b6                                                                    00 00                                                ..

1400263b8  struct UNWIND_INFO data_1400263b8 = 
1400263b8  {
1400263b8      uint8_t VersionAndFlag = 0x1
1400263b9      uint8_t SizeOfProlog = 0x4
1400263ba      uint8_t CountOfUnwindCodes = 0x1
1400263bb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263bc  }
1400263bc  uint16_t data_1400263bc[0x1] = 
1400263bc  {
1400263bc      [0x0] =  0x4204
1400263be  }

1400263be                                                                                            00 00                                ..

1400263c0  struct UNWIND_INFO data_1400263c0 = 
1400263c0  {
1400263c0      uint8_t VersionAndFlag = 0x1
1400263c1      uint8_t SizeOfProlog = 0x6
1400263c2      uint8_t CountOfUnwindCodes = 0x3
1400263c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263c4  }
1400263c4  uint16_t data_1400263c4[0x3] = 
1400263c4  {
1400263c4      [0x0] =  0x4206
1400263c6      [0x1] =  0x3002
1400263c8      [0x2] =  0x6001
1400263ca  }

1400263ca                                00 00                                                                        ..

1400263cc  struct UNWIND_INFO data_1400263cc = 
1400263cc  {
1400263cc      uint8_t VersionAndFlag = 0x1
1400263cd      uint8_t SizeOfProlog = 0x4
1400263ce      uint8_t CountOfUnwindCodes = 0x1
1400263cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263d0  }
1400263d0  uint16_t data_1400263d0[0x1] = 
1400263d0  {
1400263d0      [0x0] =  0x4204
1400263d2  }

1400263d2                                                        00 00                                                        ..

1400263d4  struct UNWIND_INFO data_1400263d4 = 
1400263d4  {
1400263d4      uint8_t VersionAndFlag = 0x1
1400263d5      uint8_t SizeOfProlog = 0x0
1400263d6      uint8_t CountOfUnwindCodes = 0x0
1400263d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263d8  }
1400263d8  struct UNWIND_INFO data_1400263d8 = 
1400263d8  {
1400263d8      uint8_t VersionAndFlag = 0x1
1400263d9      uint8_t SizeOfProlog = 0x0
1400263da      uint8_t CountOfUnwindCodes = 0x0
1400263db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263dc  }
1400263dc  struct UNWIND_INFO data_1400263dc = 
1400263dc  {
1400263dc      uint8_t VersionAndFlag = 0x1
1400263dd      uint8_t SizeOfProlog = 0x6
1400263de      uint8_t CountOfUnwindCodes = 0x3
1400263df      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263e0  }
1400263e0  uint16_t data_1400263e0[0x3] = 
1400263e0  {
1400263e0      [0x0] =  0x4206
1400263e2      [0x1] =  0x3002
1400263e4      [0x2] =  0x6001
1400263e6  }

1400263e6                    00 00                                                                                ..

1400263e8  struct UNWIND_INFO data_1400263e8 = 
1400263e8  {
1400263e8      uint8_t VersionAndFlag = 0x1
1400263e9      uint8_t SizeOfProlog = 0x4
1400263ea      uint8_t CountOfUnwindCodes = 0x1
1400263eb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263ec  }
1400263ec  uint16_t data_1400263ec[0x1] = 
1400263ec  {
1400263ec      [0x0] =  0x4204
1400263ee  }

1400263ee                                            00 00                                                                ..

1400263f0  struct UNWIND_INFO data_1400263f0 = 
1400263f0  {
1400263f0      uint8_t VersionAndFlag = 0x1
1400263f1      uint8_t SizeOfProlog = 0x5
1400263f2      uint8_t CountOfUnwindCodes = 0x2
1400263f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263f4  }
1400263f4  uint16_t data_1400263f4[0x2] = 
1400263f4  {
1400263f4      [0x0] =  0x3205
1400263f6      [0x1] =  0x3001
1400263f8  }
1400263f8  struct UNWIND_INFO data_1400263f8 = 
1400263f8  {
1400263f8      uint8_t VersionAndFlag = 0x1
1400263f9      uint8_t SizeOfProlog = 0x5
1400263fa      uint8_t CountOfUnwindCodes = 0x2
1400263fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400263fc  }
1400263fc  uint16_t data_1400263fc[0x2] = 
1400263fc  {
1400263fc      [0x0] =  0x3205
1400263fe      [0x1] =  0x3001
140026400  }
140026400  struct UNWIND_INFO data_140026400 = 
140026400  {
140026400      uint8_t VersionAndFlag = 0x1
140026401      uint8_t SizeOfProlog = 0x6
140026402      uint8_t CountOfUnwindCodes = 0x3
140026403      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026404  }
140026404  uint16_t data_140026404[0x3] = 
140026404  {
140026404      [0x0] =  0x4206
140026406      [0x1] =  0x3002
140026408      [0x2] =  0x6001
14002640a  }

14002640a                                00 00                                                                        ..

14002640c  struct UNWIND_INFO data_14002640c = 
14002640c  {
14002640c      uint8_t VersionAndFlag = 0x1
14002640d      uint8_t SizeOfProlog = 0x6
14002640e      uint8_t CountOfUnwindCodes = 0x3
14002640f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026410  }
140026410  uint16_t data_140026410[0x3] = 
140026410  {
140026410      [0x0] =  0x4206
140026412      [0x1] =  0x3002
140026414      [0x2] =  0x6001
140026416  }

140026416                                                                    00 00                                                ..

140026418  struct UNWIND_INFO data_140026418 = 
140026418  {
140026418      uint8_t VersionAndFlag = 0x1
140026419      uint8_t SizeOfProlog = 0x7
14002641a      uint8_t CountOfUnwindCodes = 0x4
14002641b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002641c  }
14002641c  uint16_t data_14002641c[0x4] = 
14002641c  {
14002641c      [0x0] =  0x3207
14002641e      [0x1] =  0x3003
140026420      [0x2] =  0x6002
140026422      [0x3] =  0x7001
140026424  }
140026424  struct UNWIND_INFO data_140026424 = 
140026424  {
140026424      uint8_t VersionAndFlag = 0x1
140026425      uint8_t SizeOfProlog = 0x6
140026426      uint8_t CountOfUnwindCodes = 0x3
140026427      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026428  }
140026428  uint16_t data_140026428[0x3] = 
140026428  {
140026428      [0x0] =  0x4206
14002642a      [0x1] =  0x3002
14002642c      [0x2] =  0x6001
14002642e  }

14002642e                                            00 00                                                                ..

140026430  struct UNWIND_INFO data_140026430 = 
140026430  {
140026430      uint8_t VersionAndFlag = 0x1
140026431      uint8_t SizeOfProlog = 0xb
140026432      uint8_t CountOfUnwindCodes = 0x6
140026433      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026434  }
140026434  uint16_t data_140026434[0x6] = 
140026434  {
140026434      [0x0] =  0x010b
140026436      [0x1] =  0x009f
140026438      [0x2] =  0x3004
14002643a      [0x3] =  0x6003
14002643c      [0x4] =  0x7002
14002643e      [0x5] =  0x5001
140026440  }
140026440  struct UNWIND_INFO data_140026440 = 
140026440  {
140026440      uint8_t VersionAndFlag = 0x1
140026441      uint8_t SizeOfProlog = 0x7
140026442      uint8_t CountOfUnwindCodes = 0x4
140026443      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026444  }
140026444  uint16_t data_140026444[0x4] = 
140026444  {
140026444      [0x0] =  0x3207
140026446      [0x1] =  0x3003
140026448      [0x2] =  0x6002
14002644a      [0x3] =  0x7001
14002644c  }
14002644c  struct UNWIND_INFO data_14002644c = 
14002644c  {
14002644c      uint8_t VersionAndFlag = 0x1
14002644d      uint8_t SizeOfProlog = 0x0
14002644e      uint8_t CountOfUnwindCodes = 0x0
14002644f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026450  }
140026450  struct UNWIND_INFO data_140026450 = 
140026450  {
140026450      uint8_t VersionAndFlag = 0x1
140026451      uint8_t SizeOfProlog = 0x0
140026452      uint8_t CountOfUnwindCodes = 0x0
140026453      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026454  }
140026454  struct UNWIND_INFO data_140026454 = 
140026454  {
140026454      uint8_t VersionAndFlag = 0x1
140026455      uint8_t SizeOfProlog = 0x0
140026456      uint8_t CountOfUnwindCodes = 0x0
140026457      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026458  }
140026458  struct UNWIND_INFO data_140026458 = 
140026458  {
140026458      uint8_t VersionAndFlag = 0x1
140026459      uint8_t SizeOfProlog = 0x0
14002645a      uint8_t CountOfUnwindCodes = 0x0
14002645b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002645c  }
14002645c  struct UNWIND_INFO data_14002645c = 
14002645c  {
14002645c      uint8_t VersionAndFlag = 0x1
14002645d      uint8_t SizeOfProlog = 0x0
14002645e      uint8_t CountOfUnwindCodes = 0x0
14002645f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026460  }
140026460  struct UNWIND_INFO data_140026460 = 
140026460  {
140026460      uint8_t VersionAndFlag = 0x1
140026461      uint8_t SizeOfProlog = 0x0
140026462      uint8_t CountOfUnwindCodes = 0x0
140026463      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026464  }
140026464  struct UNWIND_INFO data_140026464 = 
140026464  {
140026464      uint8_t VersionAndFlag = 0x1
140026465      uint8_t SizeOfProlog = 0x0
140026466      uint8_t CountOfUnwindCodes = 0x0
140026467      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026468  }
140026468  struct UNWIND_INFO data_140026468 = 
140026468  {
140026468      uint8_t VersionAndFlag = 0x1
140026469      uint8_t SizeOfProlog = 0x0
14002646a      uint8_t CountOfUnwindCodes = 0x0
14002646b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002646c  }
14002646c  struct UNWIND_INFO data_14002646c = 
14002646c  {
14002646c      uint8_t VersionAndFlag = 0x1
14002646d      uint8_t SizeOfProlog = 0x0
14002646e      uint8_t CountOfUnwindCodes = 0x0
14002646f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026470  }
140026470  struct UNWIND_INFO data_140026470 = 
140026470  {
140026470      uint8_t VersionAndFlag = 0x1
140026471      uint8_t SizeOfProlog = 0x0
140026472      uint8_t CountOfUnwindCodes = 0x0
140026473      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026474  }
140026474  struct UNWIND_INFO data_140026474 = 
140026474  {
140026474      uint8_t VersionAndFlag = 0x1
140026475      uint8_t SizeOfProlog = 0x0
140026476      uint8_t CountOfUnwindCodes = 0x0
140026477      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026478  }
140026478  struct UNWIND_INFO data_140026478 = 
140026478  {
140026478      uint8_t VersionAndFlag = 0x1
140026479      uint8_t SizeOfProlog = 0x0
14002647a      uint8_t CountOfUnwindCodes = 0x0
14002647b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002647c  }
14002647c  struct UNWIND_INFO data_14002647c = 
14002647c  {
14002647c      uint8_t VersionAndFlag = 0x1
14002647d      uint8_t SizeOfProlog = 0x0
14002647e      uint8_t CountOfUnwindCodes = 0x0
14002647f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026480  }
140026480  struct UNWIND_INFO data_140026480 = 
140026480  {
140026480      uint8_t VersionAndFlag = 0x1
140026481      uint8_t SizeOfProlog = 0x0
140026482      uint8_t CountOfUnwindCodes = 0x0
140026483      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026484  }
140026484  struct UNWIND_INFO data_140026484 = 
140026484  {
140026484      uint8_t VersionAndFlag = 0x1
140026485      uint8_t SizeOfProlog = 0x0
140026486      uint8_t CountOfUnwindCodes = 0x0
140026487      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026488  }
140026488  struct UNWIND_INFO data_140026488 = 
140026488  {
140026488      uint8_t VersionAndFlag = 0x1
140026489      uint8_t SizeOfProlog = 0x0
14002648a      uint8_t CountOfUnwindCodes = 0x0
14002648b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002648c  }
14002648c  struct UNWIND_INFO data_14002648c = 
14002648c  {
14002648c      uint8_t VersionAndFlag = 0x1
14002648d      uint8_t SizeOfProlog = 0x8
14002648e      uint8_t CountOfUnwindCodes = 0x5
14002648f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026490  }
140026490  uint16_t data_140026490[0x5] = 
140026490  {
140026490      [0x0] =  0x4208
140026492      [0x1] =  0x3004
140026494      [0x2] =  0x6003
140026496      [0x3] =  0x7002
140026498      [0x4] =  0x5001
14002649a  }

14002649a                                                                                00 00                                        ..

14002649c  struct UNWIND_INFO data_14002649c = 
14002649c  {
14002649c      uint8_t VersionAndFlag = 0x1
14002649d      uint8_t SizeOfProlog = 0xa
14002649e      uint8_t CountOfUnwindCodes = 0x6
14002649f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400264a0  }
1400264a0  uint16_t data_1400264a0[0x6] = 
1400264a0  {
1400264a0      [0x0] =  0x320a
1400264a2      [0x1] =  0x3006
1400264a4      [0x2] =  0x6005
1400264a6      [0x3] =  0x7004
1400264a8      [0x4] =  0x5003
1400264aa      [0x5] =  0xc002
1400264ac  }
1400264ac  struct UNWIND_INFO data_1400264ac = 
1400264ac  {
1400264ac      uint8_t VersionAndFlag = 0x1
1400264ad      uint8_t SizeOfProlog = 0xe
1400264ae      uint8_t CountOfUnwindCodes = 0x8
1400264af      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400264b0  }
1400264b0  uint16_t data_1400264b0[0x8] = 
1400264b0  {
1400264b0      [0x0] =  0x520e
1400264b2      [0x1] =  0x300a
1400264b4      [0x2] =  0x6009
1400264b6      [0x3] =  0x7008
1400264b8      [0x4] =  0x5007
1400264ba      [0x5] =  0xc006
1400264bc      [0x6] =  0xd004
1400264be      [0x7] =  0xe002
1400264c0  }
1400264c0  struct UNWIND_INFO data_1400264c0 = 
1400264c0  {
1400264c0      uint8_t VersionAndFlag = 0x1
1400264c1      uint8_t SizeOfProlog = 0x8
1400264c2      uint8_t CountOfUnwindCodes = 0x5
1400264c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400264c4  }
1400264c4  uint16_t data_1400264c4[0x5] = 
1400264c4  {
1400264c4      [0x0] =  0x6208
1400264c6      [0x1] =  0x3004
1400264c8      [0x2] =  0x6003
1400264ca      [0x3] =  0x7002
1400264cc      [0x4] =  0x5001
1400264ce  }

1400264ce                                            00 00                                                                ..

1400264d0  struct UNWIND_INFO data_1400264d0 = 
1400264d0  {
1400264d0      uint8_t VersionAndFlag = 0x1
1400264d1      uint8_t SizeOfProlog = 0x8
1400264d2      uint8_t CountOfUnwindCodes = 0x5
1400264d3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400264d4  }
1400264d4  uint16_t data_1400264d4[0x5] = 
1400264d4  {
1400264d4      [0x0] =  0x6208
1400264d6      [0x1] =  0x3004
1400264d8      [0x2] =  0x6003
1400264da      [0x3] =  0x7002
1400264dc      [0x4] =  0x5001
1400264de  }

1400264de                                                                                            00 00                                ..

1400264e0  struct UNWIND_INFO data_1400264e0 = 
1400264e0  {
1400264e0      uint8_t VersionAndFlag = 0x1
1400264e1      uint8_t SizeOfProlog = 0x8
1400264e2      uint8_t CountOfUnwindCodes = 0x5
1400264e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400264e4  }
1400264e4  uint16_t data_1400264e4[0x5] = 
1400264e4  {
1400264e4      [0x0] =  0x6208
1400264e6      [0x1] =  0x3004
1400264e8      [0x2] =  0x6003
1400264ea      [0x3] =  0x7002
1400264ec      [0x4] =  0x5001
1400264ee  }

1400264ee                                            00 00                                                                ..

1400264f0  struct UNWIND_INFO data_1400264f0 = 
1400264f0  {
1400264f0      uint8_t VersionAndFlag = 0x1
1400264f1      uint8_t SizeOfProlog = 0x0
1400264f2      uint8_t CountOfUnwindCodes = 0x0
1400264f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400264f4  }
1400264f4  struct UNWIND_INFO data_1400264f4 = 
1400264f4  {
1400264f4      uint8_t VersionAndFlag = 0x1
1400264f5      uint8_t SizeOfProlog = 0x0
1400264f6      uint8_t CountOfUnwindCodes = 0x0
1400264f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400264f8  }
1400264f8  struct UNWIND_INFO data_1400264f8 = 
1400264f8  {
1400264f8      uint8_t VersionAndFlag = 0x1
1400264f9      uint8_t SizeOfProlog = 0x8
1400264fa      uint8_t CountOfUnwindCodes = 0x5
1400264fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400264fc  }
1400264fc  uint16_t data_1400264fc[0x5] = 
1400264fc  {
1400264fc      [0x0] =  0x8208
1400264fe      [0x1] =  0x3004
140026500      [0x2] =  0x6003
140026502      [0x3] =  0x7002
140026504      [0x4] =  0x5001
140026506  }

140026506                    00 00                                                                                ..

140026508  struct UNWIND_INFO data_140026508 = 
140026508  {
140026508      uint8_t VersionAndFlag = 0x1
140026509      uint8_t SizeOfProlog = 0xa
14002650a      uint8_t CountOfUnwindCodes = 0x6
14002650b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002650c  }
14002650c  uint16_t data_14002650c[0x6] = 
14002650c  {
14002650c      [0x0] =  0x320a
14002650e      [0x1] =  0x3006
140026510      [0x2] =  0x6005
140026512      [0x3] =  0x7004
140026514      [0x4] =  0x5003
140026516      [0x5] =  0xc002
140026518  }
140026518  _.xdata.unlikely:
140026518                                                                          01 00 01 00                                      ....
14002651c  uint16_t data_14002651c[0x1] = 
14002651c  {
14002651c      [0x0] =  0x4200
14002651e  }

14002651e                                                                                            00 00                                ..

140026520  struct UNWIND_INFO data_140026520 = 
140026520  {
140026520      uint8_t VersionAndFlag = 0x1
140026521      uint8_t SizeOfProlog = 0x0
140026522      uint8_t CountOfUnwindCodes = 0x9
140026523      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026524  }
140026524  uint16_t data_140026524[0x9] = 
140026524  {
140026524      [0x0] =  0x5400
140026526      [0x1] =  0x0008
140026528      [0x2] =  0x7400
14002652a      [0x3] =  0x0007
14002652c      [0x4] =  0x6400
14002652e      [0x5] =  0x0006
140026530      [0x6] =  0x3400
140026532      [0x7] =  0x0005
140026534      [0x8] =  0x8200
140026536  }

140026536                                                                    00 00                                                ..

140026538  struct UNWIND_INFO data_140026538 = 
140026538  {
140026538      uint8_t VersionAndFlag = 0x1
140026539      uint8_t SizeOfProlog = 0x0
14002653a      uint8_t CountOfUnwindCodes = 0x9
14002653b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002653c  }
14002653c  uint16_t data_14002653c[0x9] = 
14002653c  {
14002653c      [0x0] =  0x5400
14002653e      [0x1] =  0x000c
140026540      [0x2] =  0x7400
140026542      [0x3] =  0x000b
140026544      [0x4] =  0x6400
140026546      [0x5] =  0x000a
140026548      [0x6] =  0x3400
14002654a      [0x7] =  0x0009
14002654c      [0x8] =  0xc200
14002654e  }

14002654e                                            00 00                                                                ..

140026550  struct UNWIND_INFO data_140026550 = 
140026550  {
140026550      uint8_t VersionAndFlag = 0x1
140026551      uint8_t SizeOfProlog = 0x0
140026552      uint8_t CountOfUnwindCodes = 0xf
140026553      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026554  }
140026554  uint16_t data_140026554[0xf] = 
140026554  {
140026554      [0x0] =  0xe400
140026556      [0x1] =  0x000c
140026558      [0x2] =  0xd400
14002655a      [0x3] =  0x000b
14002655c      [0x4] =  0xc400
14002655e      [0x5] =  0x000a
140026560      [0x6] =  0x5400
140026562      [0x7] =  0x0009
140026564      [0x8] =  0x7400
140026566      [0x9] =  0x0008
140026568      [0xa] =  0x6400
14002656a      [0xb] =  0x0007
14002656c      [0xc] =  0x3400
14002656e      [0xd] =  0x0006
140026570      [0xe] =  0xc200
140026572  }

140026572                                                        00 00                                                        ..

140026574  struct UNWIND_INFO data_140026574 = 
140026574  {
140026574      uint8_t VersionAndFlag = 0x1
140026575      uint8_t SizeOfProlog = 0x0
140026576      uint8_t CountOfUnwindCodes = 0xb
140026577      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026578  }
140026578  uint16_t data_140026578[0xb] = 
140026578  {
140026578      [0x0] =  0xc400
14002657a      [0x1] =  0x000c
14002657c      [0x2] =  0x5400
14002657e      [0x3] =  0x000b
140026580      [0x4] =  0x7400
140026582      [0x5] =  0x000a
140026584      [0x6] =  0x6400
140026586      [0x7] =  0x0009
140026588      [0x8] =  0x3400
14002658a      [0x9] =  0x0008
14002658c      [0xa] =  0xc200
14002658e  }

14002658e                                            00 00                                                                ..
140026590  _.xdata:
140026590                                                  01 04 01 00                                                      ....
140026594  uint16_t data_140026594[0x1] = 
140026594  {
140026594      [0x0] =  0x6204
140026596  }

140026596                                                                    00 00                                                ..

140026598  struct UNWIND_INFO data_140026598 = 
140026598  {
140026598      uint8_t VersionAndFlag = 0x1
140026599      uint8_t SizeOfProlog = 0x0
14002659a      uint8_t CountOfUnwindCodes = 0x0
14002659b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002659c  }
14002659c  struct UNWIND_INFO data_14002659c = 
14002659c  {
14002659c      uint8_t VersionAndFlag = 0x1
14002659d      uint8_t SizeOfProlog = 0x5
14002659e      uint8_t CountOfUnwindCodes = 0x2
14002659f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400265a0  }
1400265a0  uint16_t data_1400265a0[0x2] = 
1400265a0  {
1400265a0      [0x0] =  0x5205
1400265a2      [0x1] =  0x3001
1400265a4  }
1400265a4  struct UNWIND_INFO data_1400265a4 = 
1400265a4  {
1400265a4      uint8_t VersionAndFlag = 0x1
1400265a5      uint8_t SizeOfProlog = 0xa
1400265a6      uint8_t CountOfUnwindCodes = 0x6
1400265a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400265a8  }
1400265a8  uint16_t data_1400265a8[0x6] = 
1400265a8  {
1400265a8      [0x0] =  0x520a
1400265aa      [0x1] =  0x3006
1400265ac      [0x2] =  0x6005
1400265ae      [0x3] =  0x7004
1400265b0      [0x4] =  0x5003
1400265b2      [0x5] =  0xc002
1400265b4  }
1400265b4  struct UNWIND_INFO data_1400265b4 = 
1400265b4  {
1400265b4      uint8_t VersionAndFlag = 0x1
1400265b5      uint8_t SizeOfProlog = 0xe
1400265b6      uint8_t CountOfUnwindCodes = 0x8
1400265b7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400265b8  }
1400265b8  uint16_t data_1400265b8[0x8] = 
1400265b8  {
1400265b8      [0x0] =  0x520e
1400265ba      [0x1] =  0x300a
1400265bc      [0x2] =  0x6009
1400265be      [0x3] =  0x7008
1400265c0      [0x4] =  0x5007
1400265c2      [0x5] =  0xc006
1400265c4      [0x6] =  0xd004
1400265c6      [0x7] =  0xe002
1400265c8  }
1400265c8  _.xdata:
1400265c8                          01 08 05 00                                                                      ....
1400265cc  uint16_t data_1400265cc[0x5] = 
1400265cc  {
1400265cc      [0x0] =  0x4208
1400265ce      [0x1] =  0x3004
1400265d0      [0x2] =  0x6003
1400265d2      [0x3] =  0x7002
1400265d4      [0x4] =  0x5001
1400265d6  }

1400265d6                                                                    00 00                                                ..

1400265d8  struct UNWIND_INFO data_1400265d8 = 
1400265d8  {
1400265d8      uint8_t VersionAndFlag = 0x1
1400265d9      uint8_t SizeOfProlog = 0x6
1400265da      uint8_t CountOfUnwindCodes = 0x3
1400265db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400265dc  }
1400265dc  uint16_t data_1400265dc[0x3] = 
1400265dc  {
1400265dc      [0x0] =  0x4206
1400265de      [0x1] =  0x3002
1400265e0      [0x2] =  0x6001
1400265e2  }

1400265e2        00 00                                                                                        ..

1400265e4  struct UNWIND_INFO data_1400265e4 = 
1400265e4  {
1400265e4      uint8_t VersionAndFlag = 0x1
1400265e5      uint8_t SizeOfProlog = 0x7
1400265e6      uint8_t CountOfUnwindCodes = 0x4
1400265e7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400265e8  }
1400265e8  uint16_t data_1400265e8[0x4] = 
1400265e8  {
1400265e8      [0x0] =  0x5207
1400265ea      [0x1] =  0x3003
1400265ec      [0x2] =  0x6002
1400265ee      [0x3] =  0x7001
1400265f0  }
1400265f0  struct UNWIND_INFO data_1400265f0 = 
1400265f0  {
1400265f0      uint8_t VersionAndFlag = 0x1
1400265f1      uint8_t SizeOfProlog = 0x5
1400265f2      uint8_t CountOfUnwindCodes = 0x2
1400265f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400265f4  }
1400265f4  uint16_t data_1400265f4[0x2] = 
1400265f4  {
1400265f4      [0x0] =  0x3205
1400265f6      [0x1] =  0x3001
1400265f8  }
1400265f8  struct UNWIND_INFO data_1400265f8 = 
1400265f8  {
1400265f8      uint8_t VersionAndFlag = 0x1
1400265f9      uint8_t SizeOfProlog = 0x0
1400265fa      uint8_t CountOfUnwindCodes = 0x0
1400265fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400265fc  }
1400265fc  struct UNWIND_INFO data_1400265fc = 
1400265fc  {
1400265fc      uint8_t VersionAndFlag = 0x1
1400265fd      uint8_t SizeOfProlog = 0x8
1400265fe      uint8_t CountOfUnwindCodes = 0x5
1400265ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026600  }
140026600  uint16_t data_140026600[0x5] = 
140026600  {
140026600      [0x0] =  0xa208
140026602      [0x1] =  0x3004
140026604      [0x2] =  0x6003
140026606      [0x3] =  0x7002
140026608      [0x4] =  0x5001
14002660a  }

14002660a                                00 00                                                                        ..

14002660c  struct UNWIND_INFO data_14002660c = 
14002660c  {
14002660c      uint8_t VersionAndFlag = 0x1
14002660d      uint8_t SizeOfProlog = 0xa
14002660e      uint8_t CountOfUnwindCodes = 0x6
14002660f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026610  }
140026610  uint16_t data_140026610[0x6] = 
140026610  {
140026610      [0x0] =  0x320a
140026612      [0x1] =  0x3006
140026614      [0x2] =  0x6005
140026616      [0x3] =  0x7004
140026618      [0x4] =  0x5003
14002661a      [0x5] =  0xc002
14002661c  }
14002661c  struct UNWIND_INFO data_14002661c = 
14002661c  {
14002661c      uint8_t VersionAndFlag = 0x1
14002661d      uint8_t SizeOfProlog = 0x6
14002661e      uint8_t CountOfUnwindCodes = 0x3
14002661f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026620  }
140026620  uint16_t data_140026620[0x3] = 
140026620  {
140026620      [0x0] =  0x4206
140026622      [0x1] =  0x3002
140026624      [0x2] =  0x6001
140026626  }

140026626                    00 00                                                                                ..

140026628  struct UNWIND_INFO data_140026628 = 
140026628  {
140026628      uint8_t VersionAndFlag = 0x1
140026629      uint8_t SizeOfProlog = 0x7
14002662a      uint8_t CountOfUnwindCodes = 0x4
14002662b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002662c  }
14002662c  uint16_t data_14002662c[0x4] = 
14002662c  {
14002662c      [0x0] =  0x3207
14002662e      [0x1] =  0x3003
140026630      [0x2] =  0x6002
140026632      [0x3] =  0x7001
140026634  }
140026634  struct UNWIND_INFO data_140026634 = 
140026634  {
140026634      uint8_t VersionAndFlag = 0x1
140026635      uint8_t SizeOfProlog = 0xc
140026636      uint8_t CountOfUnwindCodes = 0x7
140026637      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026638  }
140026638  uint16_t data_140026638[0x7] = 
140026638  {
140026638      [0x0] =  0x620c
14002663a      [0x1] =  0x3008
14002663c      [0x2] =  0x6007
14002663e      [0x3] =  0x7006
140026640      [0x4] =  0x5005
140026642      [0x5] =  0xc004
140026644      [0x6] =  0xd002
140026646  }

140026646                    00 00                                                                                ..

140026648  struct UNWIND_INFO data_140026648 = 
140026648  {
140026648      uint8_t VersionAndFlag = 0x1
140026649      uint8_t SizeOfProlog = 0xa
14002664a      uint8_t CountOfUnwindCodes = 0x6
14002664b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002664c  }
14002664c  uint16_t data_14002664c[0x6] = 
14002664c  {
14002664c      [0x0] =  0x320a
14002664e      [0x1] =  0x3006
140026650      [0x2] =  0x6005
140026652      [0x3] =  0x7004
140026654      [0x4] =  0x5003
140026656      [0x5] =  0xc002
140026658  }
140026658  struct UNWIND_INFO data_140026658 = 
140026658  {
140026658      uint8_t VersionAndFlag = 0x1
140026659      uint8_t SizeOfProlog = 0xa
14002665a      uint8_t CountOfUnwindCodes = 0x6
14002665b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002665c  }
14002665c  uint16_t data_14002665c[0x6] = 
14002665c  {
14002665c      [0x0] =  0x320a
14002665e      [0x1] =  0x3006
140026660      [0x2] =  0x6005
140026662      [0x3] =  0x7004
140026664      [0x4] =  0x5003
140026666      [0x5] =  0xc002
140026668  }
140026668  struct UNWIND_INFO data_140026668 = 
140026668  {
140026668      uint8_t VersionAndFlag = 0x1
140026669      uint8_t SizeOfProlog = 0xa
14002666a      uint8_t CountOfUnwindCodes = 0x6
14002666b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002666c  }
14002666c  uint16_t data_14002666c[0x6] = 
14002666c  {
14002666c      [0x0] =  0x320a
14002666e      [0x1] =  0x3006
140026670      [0x2] =  0x6005
140026672      [0x3] =  0x7004
140026674      [0x4] =  0x5003
140026676      [0x5] =  0xc002
140026678  }
140026678  struct UNWIND_INFO data_140026678 = 
140026678  {
140026678      uint8_t VersionAndFlag = 0x1
140026679      uint8_t SizeOfProlog = 0xa
14002667a      uint8_t CountOfUnwindCodes = 0x6
14002667b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002667c  }
14002667c  uint16_t data_14002667c[0x6] = 
14002667c  {
14002667c      [0x0] =  0x320a
14002667e      [0x1] =  0x3006
140026680      [0x2] =  0x6005
140026682      [0x3] =  0x7004
140026684      [0x4] =  0x5003
140026686      [0x5] =  0xc002
140026688  }
140026688  struct UNWIND_INFO data_140026688 = 
140026688  {
140026688      uint8_t VersionAndFlag = 0x1
140026689      uint8_t SizeOfProlog = 0x8
14002668a      uint8_t CountOfUnwindCodes = 0x5
14002668b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002668c  }
14002668c  uint16_t data_14002668c[0x5] = 
14002668c  {
14002668c      [0x0] =  0x4208
14002668e      [0x1] =  0x3004
140026690      [0x2] =  0x6003
140026692      [0x3] =  0x7002
140026694      [0x4] =  0x5001
140026696  }

140026696                                                                    00 00                                                ..

140026698  struct UNWIND_INFO data_140026698 = 
140026698  {
140026698      uint8_t VersionAndFlag = 0x1
140026699      uint8_t SizeOfProlog = 0xc
14002669a      uint8_t CountOfUnwindCodes = 0x7
14002669b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002669c  }
14002669c  uint16_t data_14002669c[0x7] = 
14002669c  {
14002669c      [0x0] =  0x820c
14002669e      [0x1] =  0x3008
1400266a0      [0x2] =  0x6007
1400266a2      [0x3] =  0x7006
1400266a4      [0x4] =  0x5005
1400266a6      [0x5] =  0xc004
1400266a8      [0x6] =  0xd002
1400266aa  }

1400266aa                                00 00                                                                        ..

1400266ac  struct UNWIND_INFO data_1400266ac = 
1400266ac  {
1400266ac      uint8_t VersionAndFlag = 0x1
1400266ad      uint8_t SizeOfProlog = 0xe
1400266ae      uint8_t CountOfUnwindCodes = 0x8
1400266af      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266b0  }
1400266b0  uint16_t data_1400266b0[0x8] = 
1400266b0  {
1400266b0      [0x0] =  0x720e
1400266b2      [0x1] =  0x300a
1400266b4      [0x2] =  0x6009
1400266b6      [0x3] =  0x7008
1400266b8      [0x4] =  0x5007
1400266ba      [0x5] =  0xc006
1400266bc      [0x6] =  0xd004
1400266be      [0x7] =  0xe002
1400266c0  }
1400266c0  struct UNWIND_INFO data_1400266c0 = 
1400266c0  {
1400266c0      uint8_t VersionAndFlag = 0x1
1400266c1      uint8_t SizeOfProlog = 0x0
1400266c2      uint8_t CountOfUnwindCodes = 0x0
1400266c3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266c4  }
1400266c4  struct UNWIND_INFO data_1400266c4 = 
1400266c4  {
1400266c4      uint8_t VersionAndFlag = 0x1
1400266c5      uint8_t SizeOfProlog = 0x0
1400266c6      uint8_t CountOfUnwindCodes = 0x0
1400266c7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266c8  }
1400266c8  struct UNWIND_INFO data_1400266c8 = 
1400266c8  {
1400266c8      uint8_t VersionAndFlag = 0x1
1400266c9      uint8_t SizeOfProlog = 0x0
1400266ca      uint8_t CountOfUnwindCodes = 0x0
1400266cb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266cc  }
1400266cc  struct UNWIND_INFO data_1400266cc = 
1400266cc  {
1400266cc      uint8_t VersionAndFlag = 0x1
1400266cd      uint8_t SizeOfProlog = 0x0
1400266ce      uint8_t CountOfUnwindCodes = 0x0
1400266cf      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266d0  }

1400266d0  _.xdata:
1400266d0                                                  01 00 00 00                                                      ....

1400266d4  struct UNWIND_INFO data_1400266d4 = 
1400266d4  {
1400266d4      uint8_t VersionAndFlag = 0x1
1400266d5      uint8_t SizeOfProlog = 0x0
1400266d6      uint8_t CountOfUnwindCodes = 0x0
1400266d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266d8  }
1400266d8  struct UNWIND_INFO data_1400266d8 = 
1400266d8  {
1400266d8      uint8_t VersionAndFlag = 0x1
1400266d9      uint8_t SizeOfProlog = 0x0
1400266da      uint8_t CountOfUnwindCodes = 0x0
1400266db      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266dc  }
1400266dc  struct UNWIND_INFO data_1400266dc = 
1400266dc  {
1400266dc      uint8_t VersionAndFlag = 0x1
1400266dd      uint8_t SizeOfProlog = 0x0
1400266de      uint8_t CountOfUnwindCodes = 0x0
1400266df      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266e0  }
1400266e0  struct UNWIND_INFO data_1400266e0 = 
1400266e0  {
1400266e0      uint8_t VersionAndFlag = 0x1
1400266e1      uint8_t SizeOfProlog = 0x0
1400266e2      uint8_t CountOfUnwindCodes = 0x0
1400266e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266e4  }

1400266e4  _.xdata:
1400266e4              01 08 05 00                                                                              ....
1400266e8  uint16_t data_1400266e8[0x5] = 
1400266e8  {
1400266e8      [0x0] =  0x4208
1400266ea      [0x1] =  0x3004
1400266ec      [0x2] =  0x6003
1400266ee      [0x3] =  0x7002
1400266f0      [0x4] =  0x5001
1400266f2  }

1400266f2                                                        00 00                                                        ..

1400266f4  struct UNWIND_INFO data_1400266f4 = 
1400266f4  {
1400266f4      uint8_t VersionAndFlag = 0x1
1400266f5      uint8_t SizeOfProlog = 0x5
1400266f6      uint8_t CountOfUnwindCodes = 0x2
1400266f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400266f8  }
1400266f8  uint16_t data_1400266f8[0x2] = 
1400266f8  {
1400266f8      [0x0] =  0x3205
1400266fa      [0x1] =  0x3001
1400266fc  }
1400266fc  struct UNWIND_INFO data_1400266fc = 
1400266fc  {
1400266fc      uint8_t VersionAndFlag = 0x1
1400266fd      uint8_t SizeOfProlog = 0x8
1400266fe      uint8_t CountOfUnwindCodes = 0x5
1400266ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026700  }
140026700  uint16_t data_140026700[0x5] = 
140026700  {
140026700      [0x0] =  0x8208
140026702      [0x1] =  0x3004
140026704      [0x2] =  0x6003
140026706      [0x3] =  0x7002
140026708      [0x4] =  0x5001
14002670a  }

14002670a                                00 00                                                                        ..

14002670c  struct UNWIND_INFO data_14002670c = 
14002670c  {
14002670c      uint8_t VersionAndFlag = 0x1
14002670d      uint8_t SizeOfProlog = 0x0
14002670e      uint8_t CountOfUnwindCodes = 0x0
14002670f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026710  }
140026710  struct UNWIND_INFO data_140026710 = 
140026710  {
140026710      uint8_t VersionAndFlag = 0x1
140026711      uint8_t SizeOfProlog = 0x0
140026712      uint8_t CountOfUnwindCodes = 0x0
140026713      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026714  }
140026714  struct UNWIND_INFO data_140026714 = 
140026714  {
140026714      uint8_t VersionAndFlag = 0x1
140026715      uint8_t SizeOfProlog = 0x0
140026716      uint8_t CountOfUnwindCodes = 0x0
140026717      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026718  }
140026718  struct UNWIND_INFO data_140026718 = 
140026718  {
140026718      uint8_t VersionAndFlag = 0x1
140026719      uint8_t SizeOfProlog = 0x0
14002671a      uint8_t CountOfUnwindCodes = 0x0
14002671b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002671c  }
14002671c  struct UNWIND_INFO data_14002671c = 
14002671c  {
14002671c      uint8_t VersionAndFlag = 0x1
14002671d      uint8_t SizeOfProlog = 0x0
14002671e      uint8_t CountOfUnwindCodes = 0x0
14002671f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026720  }
140026720  struct UNWIND_INFO data_140026720 = 
140026720  {
140026720      uint8_t VersionAndFlag = 0x1
140026721      uint8_t SizeOfProlog = 0x7
140026722      uint8_t CountOfUnwindCodes = 0x4
140026723      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026724  }
140026724  uint16_t data_140026724[0x4] = 
140026724  {
140026724      [0x0] =  0x3207
140026726      [0x1] =  0x3003
140026728      [0x2] =  0x6002
14002672a      [0x3] =  0x7001
14002672c  }
14002672c  struct UNWIND_INFO data_14002672c = 
14002672c  {
14002672c      uint8_t VersionAndFlag = 0x1
14002672d      uint8_t SizeOfProlog = 0x0
14002672e      uint8_t CountOfUnwindCodes = 0x0
14002672f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026730  }
140026730  struct UNWIND_INFO data_140026730 = 
140026730  {
140026730      uint8_t VersionAndFlag = 0x1
140026731      uint8_t SizeOfProlog = 0x7
140026732      uint8_t CountOfUnwindCodes = 0x4
140026733      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026734  }
140026734  uint16_t data_140026734[0x4] = 
140026734  {
140026734      [0x0] =  0x3207
140026736      [0x1] =  0x3003
140026738      [0x2] =  0x6002
14002673a      [0x3] =  0x7001
14002673c  }
14002673c  struct UNWIND_INFO data_14002673c = 
14002673c  {
14002673c      uint8_t VersionAndFlag = 0x1
14002673d      uint8_t SizeOfProlog = 0xa
14002673e      uint8_t CountOfUnwindCodes = 0x6
14002673f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026740  }
140026740  uint16_t data_140026740[0x6] = 
140026740  {
140026740      [0x0] =  0x520a
140026742      [0x1] =  0x3006
140026744      [0x2] =  0x6005
140026746      [0x3] =  0x7004
140026748      [0x4] =  0x5003
14002674a      [0x5] =  0xc002
14002674c  }
14002674c  struct UNWIND_INFO data_14002674c = 
14002674c  {
14002674c      uint8_t VersionAndFlag = 0x1
14002674d      uint8_t SizeOfProlog = 0x10
14002674e      uint8_t CountOfUnwindCodes = 0x9
14002674f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026750  }
140026750  uint16_t data_140026750[0x9] = 
140026750  {
140026750      [0x0] =  0x4210
140026752      [0x1] =  0x300c
140026754      [0x2] =  0x600b
140026756      [0x3] =  0x700a
140026758      [0x4] =  0x5009
14002675a      [0x5] =  0xc008
14002675c      [0x6] =  0xd006
14002675e      [0x7] =  0xe004
140026760      [0x8] =  0xf002
140026762  }

140026762        00 00                                                                                        ..

140026764  struct UNWIND_INFO data_140026764 = 
140026764  {
140026764      uint8_t VersionAndFlag = 0x1
140026765      uint8_t SizeOfProlog = 0xc
140026766      uint8_t CountOfUnwindCodes = 0x7
140026767      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026768  }
140026768  uint16_t data_140026768[0x7] = 
140026768  {
140026768      [0x0] =  0x620c
14002676a      [0x1] =  0x3008
14002676c      [0x2] =  0x6007
14002676e      [0x3] =  0x7006
140026770      [0x4] =  0x5005
140026772      [0x5] =  0xc004
140026774      [0x6] =  0xd002
140026776  }

140026776                                                                    00 00                                                ..

140026778  struct UNWIND_INFO data_140026778 = 
140026778  {
140026778      uint8_t VersionAndFlag = 0x1
140026779      uint8_t SizeOfProlog = 0x6
14002677a      uint8_t CountOfUnwindCodes = 0x3
14002677b      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
14002677c  }
14002677c  uint16_t data_14002677c[0x3] = 
14002677c  {
14002677c      [0x0] =  0x8206
14002677e      [0x1] =  0x3002
140026780      [0x2] =  0x6001
140026782  }

140026782        00 00                                                                                        ..

140026784  struct UNWIND_INFO data_140026784 = 
140026784  {
140026784      uint8_t VersionAndFlag = 0x1
140026785      uint8_t SizeOfProlog = 0x7
140026786      uint8_t CountOfUnwindCodes = 0x4
140026787      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026788  }
140026788  uint16_t data_140026788[0x4] = 
140026788  {
140026788      [0x0] =  0x7207
14002678a      [0x1] =  0x3003
14002678c      [0x2] =  0x6002
14002678e      [0x3] =  0x7001
140026790  }
140026790  struct UNWIND_INFO data_140026790 = 
140026790  {
140026790      uint8_t VersionAndFlag = 0x1
140026791      uint8_t SizeOfProlog = 0xe
140026792      uint8_t CountOfUnwindCodes = 0x8
140026793      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026794  }
140026794  uint16_t data_140026794[0x8] = 
140026794  {
140026794      [0x0] =  0xf20e
140026796      [0x1] =  0x300a
140026798      [0x2] =  0x6009
14002679a      [0x3] =  0x7008
14002679c      [0x4] =  0x5007
14002679e      [0x5] =  0xc006
1400267a0      [0x6] =  0xd004
1400267a2      [0x7] =  0xe002
1400267a4  }
1400267a4  struct UNWIND_INFO data_1400267a4 = 
1400267a4  {
1400267a4      uint8_t VersionAndFlag = 0x1
1400267a5      uint8_t SizeOfProlog = 0xc
1400267a6      uint8_t CountOfUnwindCodes = 0x7
1400267a7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400267a8  }
1400267a8  uint16_t data_1400267a8[0x7] = 
1400267a8  {
1400267a8      [0x0] =  0x620c
1400267aa      [0x1] =  0x3008
1400267ac      [0x2] =  0x6007
1400267ae      [0x3] =  0x7006
1400267b0      [0x4] =  0x5005
1400267b2      [0x5] =  0xc004
1400267b4      [0x6] =  0xd002
1400267b6  }

1400267b6                                                                    00 00                                                ..

1400267b8  struct UNWIND_INFO data_1400267b8 = 
1400267b8  {
1400267b8      uint8_t VersionAndFlag = 0x1
1400267b9      uint8_t SizeOfProlog = 0x13
1400267ba      uint8_t CountOfUnwindCodes = 0xa
1400267bb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400267bc  }
1400267bc  uint16_t data_1400267bc[0xa] = 
1400267bc  {
1400267bc      [0x0] =  0x0113
1400267be      [0x1] =  0x0011
1400267c0      [0x2] =  0x300c
1400267c2      [0x3] =  0x600b
1400267c4      [0x4] =  0x700a
1400267c6      [0x5] =  0x5009
1400267c8      [0x6] =  0xc008
1400267ca      [0x7] =  0xd006
1400267cc      [0x8] =  0xe004
1400267ce      [0x9] =  0xf002
1400267d0  }
1400267d0  struct UNWIND_INFO data_1400267d0 = 
1400267d0  {
1400267d0      uint8_t VersionAndFlag = 0x1
1400267d1      uint8_t SizeOfProlog = 0x0
1400267d2      uint8_t CountOfUnwindCodes = 0x0
1400267d3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400267d4  }
1400267d4  struct UNWIND_INFO data_1400267d4 = 
1400267d4  {
1400267d4      uint8_t VersionAndFlag = 0x1
1400267d5      uint8_t SizeOfProlog = 0x0
1400267d6      uint8_t CountOfUnwindCodes = 0x0
1400267d7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400267d8  }

1400267d8  _.xdata:
1400267d8                                                                          01 04 01 00                                      ....
1400267dc  uint16_t data_1400267dc[0x1] = 
1400267dc  {
1400267dc      [0x0] =  0x6204
1400267de  }

1400267de                                                                                            00 00                                ..

1400267e0  struct UNWIND_INFO data_1400267e0 = 
1400267e0  {
1400267e0      uint8_t VersionAndFlag = 0x1
1400267e1      uint8_t SizeOfProlog = 0x4
1400267e2      uint8_t CountOfUnwindCodes = 0x1
1400267e3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400267e4  }
1400267e4  uint16_t data_1400267e4[0x1] = 
1400267e4  {
1400267e4      [0x0] =  0x4204
1400267e6  }

1400267e6                    00 00                                                                                ..

1400267e8  struct UNWIND_INFO data_1400267e8 = 
1400267e8  {
1400267e8      uint8_t VersionAndFlag = 0x1
1400267e9      uint8_t SizeOfProlog = 0x4
1400267ea      uint8_t CountOfUnwindCodes = 0x1
1400267eb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400267ec  }
1400267ec  uint16_t data_1400267ec[0x1] = 
1400267ec  {
1400267ec      [0x0] =  0x4204
1400267ee  }

1400267ee                                            00 00                                                                ..

1400267f0  struct UNWIND_INFO data_1400267f0 = 
1400267f0  {
1400267f0      uint8_t VersionAndFlag = 0x1
1400267f1      uint8_t SizeOfProlog = 0x0
1400267f2      uint8_t CountOfUnwindCodes = 0x0
1400267f3      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400267f4  }
1400267f4  struct UNWIND_INFO data_1400267f4 = 
1400267f4  {
1400267f4      uint8_t VersionAndFlag = 0x1
1400267f5      uint8_t SizeOfProlog = 0x0
1400267f6      uint8_t CountOfUnwindCodes = 0x0
1400267f7      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400267f8  }
1400267f8  struct UNWIND_INFO data_1400267f8 = 
1400267f8  {
1400267f8      uint8_t VersionAndFlag = 0x1
1400267f9      uint8_t SizeOfProlog = 0x0
1400267fa      uint8_t CountOfUnwindCodes = 0x0
1400267fb      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
1400267fc  }
1400267fc  struct UNWIND_INFO data_1400267fc = 
1400267fc  {
1400267fc      uint8_t VersionAndFlag = 0x1
1400267fd      uint8_t SizeOfProlog = 0x0
1400267fe      uint8_t CountOfUnwindCodes = 0x0
1400267ff      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026800  }
140026800  struct UNWIND_INFO data_140026800 = 
140026800  {
140026800      uint8_t VersionAndFlag = 0x1
140026801      uint8_t SizeOfProlog = 0x8
140026802      uint8_t CountOfUnwindCodes = 0x5
140026803      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026804  }
140026804  uint16_t data_140026804[0x5] = 
140026804  {
140026804      [0x0] =  0x4208
140026806      [0x1] =  0x3004
140026808      [0x2] =  0x6003
14002680a      [0x3] =  0x7002
14002680c      [0x4] =  0x5001
14002680e  }

14002680e                                            00 00                                                                ..

140026810  struct UNWIND_INFO data_140026810 = 
140026810  {
140026810      uint8_t VersionAndFlag = 0x1
140026811      uint8_t SizeOfProlog = 0x7
140026812      uint8_t CountOfUnwindCodes = 0x4
140026813      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026814  }
140026814  uint16_t data_140026814[0x4] = 
140026814  {
140026814      [0x0] =  0x3207
140026816      [0x1] =  0x3003
140026818      [0x2] =  0x6002
14002681a      [0x3] =  0x7001
14002681c  }
14002681c  struct UNWIND_INFO data_14002681c = 
14002681c  {
14002681c      uint8_t VersionAndFlag = 0x1
14002681d      uint8_t SizeOfProlog = 0x5
14002681e      uint8_t CountOfUnwindCodes = 0x2
14002681f      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026820  }
140026820  uint16_t data_140026820[0x2] = 
140026820  {
140026820      [0x0] =  0x3205
140026822      [0x1] =  0x3001
140026824  }
140026824  struct UNWIND_INFO data_140026824 = 
140026824  {
140026824      uint8_t VersionAndFlag = 0x1
140026825      uint8_t SizeOfProlog = 0x6
140026826      uint8_t CountOfUnwindCodes = 0x3
140026827      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026828  }
140026828  uint16_t data_140026828[0x3] = 
140026828  {
140026828      [0x0] =  0x4206
14002682a      [0x1] =  0x3002
14002682c      [0x2] =  0x6001
14002682e  }

14002682e                                            00 00                                                                ..

140026830  struct UNWIND_INFO data_140026830 = 
140026830  {
140026830      uint8_t VersionAndFlag = 0x1
140026831      uint8_t SizeOfProlog = 0x4
140026832      uint8_t CountOfUnwindCodes = 0x1
140026833      uint8_t FrameRegisterAndFrameRegisterOffset = 0x0
140026834  }
140026834  uint16_t data_140026834[0x1] = 
140026834  {
140026834      [0x0] =  0x4204
140026836  }

140026836                                                                    00 00                                                ..
140026838  _.xdata:
140026838                                                                          01 06 03 00                                      ....
14002683c  uint16_t data_14002683c[0x3] = 
14002683c  {
14002683c      [0x0] =  0x8206
14002683e      [0x1] =  0x3002
140026840      [0x2] =  0x6001
140026842  }

140026842        00 00                                                                                        ..
140026844  _.xdata.startup:
140026844              01 00 00 00                                                                              ....
.xdata section ended  {0x140025000-0x140026848}

.bss section started  {0x140027000-0x140027d80}
140027000  char _.bss = 0x0

140027001     00 00 00                                                                                       ...

140027004  int32_t startinfo = 0x0
140027008  int32_t has_cctor = 0x0
14002700c  int32_t managedapp = 0x0
140027010  int32_t mainret = 0x0

140027014                                                              00 00 00 00                                              ....

140027018  int64_t envp = 0x0
140027020  int64_t argv = 0x0
140027028  int32_t argc = 0x0

14002702c                                      00 00 00 00                                                              ....
140027030  _.bss:
140027030                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................

140027040  int64_t _.bss = 0x0
140027048  int64_t data_140027048 = 0x0

140027050                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140027060  gFunsLock__stdZexitprocs_u14:
140027060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027080  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

1400270a0  int32_t _.bss = 0x0

1400270a4              00 00 00 00                                                                              ....

1400270a8  int64_t Dl_520094348_ = 0x0
1400270b0  int32_t consoleCP__stdZsyncio_u656 = 0x0

1400270b4                                                              00 00 00 00                                              ....

1400270b8  int64_t Dl_520094349_ = 0x0
1400270c0  int64_t Dl_520094344_ = 0x0
1400270c8  int64_t Dl_520094346_ = 0x0
1400270d0  int64_t TM__xNF6mvRQ4Pd1hTNM9cEHXwQ_2 = 0x0

1400270d8                                                                          00 00 00 00 00 00 00 00                          ........

1400270e0  int64_t _.bss = 0x0
1400270e8  int64_t globalRaiseHook__system_u3630 = 0x0
1400270f0  int64_t outOfMemHook__system_u3635 = 0x0
1400270f8  int64_t unhandledExceptionHook__system_u3638 = 0x0
140027100  int64_t errorMessageWriter__system_u4067 = 0x0
140027108  int64_t onUnhandledException__system_u4442 = 0x0

140027110                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140027120  echoLock__system_u9047:
140027120  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027140  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

140027160  int64_t _.bss = 0x0
140027168  int64_t ws2__windowsZwinlean_u797 = 0x0
140027170  int64_t Dl_1426063656_ = 0x0
140027178  int64_t TM__k6kyf4Co79a84IkK9blFuQVA_4 = 0x0
140027180  int32_t _.bss = 0x0

140027184              00 00 00 00                                                                              ....

140027188  int64_t cmdLine = 0x0
140027190  int64_t gEnv = 0x0

140027198                                                                          00 00 00 00 00 00 00 00                          ........

1400271a0  int32_t _.bss = 0x0

1400271a4              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

1400271b0  int64_t _.bss = 0x0
1400271b8  int32_t __native_startup_state = 0x0

1400271bc                                                                                      00 00 00 00                              ....

1400271c0  int32_t _.bss = 0x0

1400271c4              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

1400271d0  int32_t _.bss = 0x0
1400271d4  int32_t __mingw_initltsdyn_force = 0x0
1400271d8  int32_t __mingw_initltsdrot_force = 0x0

1400271dc  _tls_index:
1400271dc                                                                                      00 00 00 00                              ....

1400271e0  int32_t _.bss = 0x0

1400271e4              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

1400271f0  int32_t _.bss = 0x0

1400271f4                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

140027200  int32_t _.bss = 0x0
140027204  int32_t maxSections = 0x0
140027208  int64_t the_secs = 0x0
140027210  int64_t _.bss = 0x0

140027218                                                                          00 00 00 00 00 00 00 00                          ........

140027220  int32_t _.bss = 0x0

140027224              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

140027230  int64_t _.bss = 0x0

140027238                                                                          00 00 00 00 00 00 00 00                          ........

140027240  int64_t _.bss = 0x0
140027248  int32_t __mingwthr_cs_init = 0x0

14002724c                                      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ....................
140027260  __mingwthr_cs:
140027260  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027280  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400272a0  _.bss:
1400272a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
1400272b0  _.bss:
1400272b0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
1400272c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
1400272d0  _.bss:
1400272d0                                                  00 00 00 00 00 00 00 00                                          ........

1400272d8  int64_t emutls_size = 0x0
1400272e0  int32_t emutls_key = 0x0

1400272e4              00 00 00 00                                                                              ....
1400272e8  emutls_mutex:
1400272e8                          00 00 00 00 00 00 00 00                                                          ........
1400272f0  _.bss:
1400272f0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................

140027300  int64_t _.bss = 0x0

140027308                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
140027320  private_mem:
140027320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400273a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400273c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400273e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027400  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027460  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400274a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400274c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400274e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400275a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400275c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400275e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027600  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027620  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027640  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027660  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027680  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400276a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400276c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400276e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027700  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027720  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027760  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400277a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400277c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400277e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027800  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027820  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027860  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027880  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400278a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400278c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400278e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027900  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027920  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027940  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027960  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027980  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400279a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400279c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
1400279e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027a00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027a20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027a40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027a60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027a80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027aa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027ac0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027ae0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027b00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027b20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027b40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027b60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027b80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027ba0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027bc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027be0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027c00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027c20  freelist:
140027c20  00 00 00 00 00 00 00 00                                                                          ........

140027c28  int64_t data_140027c28 = 0x0

140027c30                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
140027c40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027c60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

140027c70  int32_t dtoa_CS_init = 0x0

140027c74                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............
140027c80  dtoa_CritSec:
140027c80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027ca0  00 00 00 00 00 00 00 00                                                                          ........
140027ca8  data_140027ca8:
140027ca8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
140027cc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
140027ce0  _.bss:
140027ce0  00 00 00 00 00 00 00 00                                                                          ........
140027ce8  local__initenv:
140027ce8                          00 00 00 00 00 00 00 00                                                          ........

140027cf0  int64_t _.bss = 0x0
140027cf8  int32_t dummy_concurrency_level = 0x0

140027cfc                                                                                      00 00 00 00                              ....

140027d00  int64_t once_obj = 0x0
140027d08  int32_t print_state = 0x0

140027d0c                                      00 00 00 00                                                              ....

140027d10  int64_t SetThreadName_VEH_handle = 0x0
140027d18  int64_t idListNextId = 0x0
140027d20  int64_t idListMax = 0x0
140027d28  int64_t idListCnt = 0x0
140027d30  int64_t idList = 0x0
140027d38  int64_t pthr_last = 0x0
140027d40  int64_t pthr_root = 0x0
140027d48  int32_t _pthread_key_sch = 0x0
140027d4c  int32_t _pthread_key_max = 0x0
140027d50  int32_t _pthread_tls_once = 0x0
140027d54  int32_t _pthread_concur = 0x0
140027d58  int32_t _pthread_cancelling = 0x0

140027d5c                                                                                      00 00 00 00                              ....

140027d60  int32_t _.bss = 0x0

140027d64              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

140027d70  int64_t _.bss = 0x0
140027d78  int32_t print_state = 0x0

140027d7c                                                                                      00 00 00 00                              ....
.bss section ended  {0x140027000-0x140027d80}

.idata section started  {0x140028000-0x1400292cc}
140028000  _.idata$2:
140028000  04 81 02 00 00 00 00 00 00 00 00 00 4c 90 02 00 bc 84 02 00                                      ............L.......
140028014  _.idata$2:
140028014                                                              8c 82 02 00 00 00 00 00 00 00 00 00                      ............
140028020  68 90 02 00 44 86 02 00                                                                          h...D...
140028028  _.idata$2:
140028028                          ac 82 02 00 00 00 00 00 00 00 00 00 94 90 02 00 64 86 02 00                      ................d...
14002803c  _.idata$2:
14002803c                                                                                      c4 82 02 00                              ....
140028040  00 00 00 00 00 00 00 00 c4 90 02 00 7c 86 02 00                                                  ............|...
140028050  _.idata$2:
140028050                                                  dc 82 02 00 00 00 00 00 00 00 00 00 00 91 02 00                  ................
140028060  94 86 02 00                                                                                      ....
140028064  _.idata$2:
140028064              0c 83 02 00 00 00 00 00 00 00 00 00 24 91 02 00 c4 86 02 00                              ............$.......
140028078  _.idata$2:
140028078                                                                          1c 83 02 00 00 00 00 00                          ........
140028080  00 00 00 00 4c 91 02 00 d4 86 02 00                                                              ....L.......
14002808c  _.idata$2:
14002808c                                      2c 83 02 00 00 00 00 00 00 00 00 00 80 91 02 00 e4 86 02 00              ,...................
1400280a0  _.idata$2:
1400280a0  5c 83 02 00 00 00 00 00 00 00 00 00 f8 91 02 00 14 87 02 00                                      \...................
1400280b4  _.idata$2:
1400280b4                                                              0c 84 02 00 00 00 00 00 00 00 00 00                      ............
1400280c0  44 92 02 00 c4 87 02 00                                                                          D.......
1400280c8  _.idata$2:
1400280c8                          64 84 02 00 00 00 00 00 00 00 00 00 78 92 02 00 1c 88 02 00                      d...........x.......
1400280dc  _.idata$2:
1400280dc                                                                                      94 84 02 00                              ....
1400280e0  00 00 00 00 00 00 00 00 ac 92 02 00 4c 88 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ............L...................
140028100  00 00 00 00                                                                                      ....
140028104  _.idata$4:
140028104              74 88 02 00 00 00 00 00                                                                  t.......
14002810c  _.idata$4:
14002810c                                      92 88 02 00 00 00 00 00                                                  ........
140028114  _.idata$4:
140028114                                                              a0 88 02 00 00 00 00 00                                  ........
14002811c  _.idata$4:
14002811c                                                                                      b0 88 02 00                              ....
140028120  00 00 00 00                                                                                      ....
140028124  _.idata$4:
140028124              c4 88 02 00 00 00 00 00                                                                  ........
14002812c  _.idata$4:
14002812c                                      dc 88 02 00 00 00 00 00                                                  ........
140028134  _.idata$4:
140028134                                                              ee 88 02 00 00 00 00 00                                  ........
14002813c  _.idata$4:
14002813c                                                                                      06 89 02 00                              ....
140028140  00 00 00 00                                                                                      ....
140028144  _.idata$4:
140028144              1a 89 02 00 00 00 00 00                                                                  ........
14002814c  _.idata$4:
14002814c                                      30 89 02 00 00 00 00 00                                                  0.......
140028154  _.idata$4:
140028154                                                              44 89 02 00 00 00 00 00                                  D.......
14002815c  _.idata$4:
14002815c                                                                                      5a 89 02 00                              Z...
140028160  00 00 00 00                                                                                      ....
140028164  _.idata$4:
140028164              72 89 02 00 00 00 00 00                                                                  r.......
14002816c  _.idata$4:
14002816c                                      82 89 02 00 00 00 00 00                                                  ........
140028174  _.idata$4:
140028174                                                              94 89 02 00 00 00 00 00                                  ........
14002817c  _.idata$4:
14002817c                                                                                      ae 89 02 00                              ....
140028180  00 00 00 00                                                                                      ....
140028184  _.idata$4:
140028184              c8 89 02 00 00 00 00 00                                                                  ........
14002818c  _.idata$4:
14002818c                                      dc 89 02 00 00 00 00 00                                                  ........
140028194  _.idata$4:
140028194                                                              f0 89 02 00 00 00 00 00                                  ........
14002819c  _.idata$4:
14002819c                                                                                      02 8a 02 00                              ....
1400281a0  00 00 00 00                                                                                      ....
1400281a4  _.idata$4:
1400281a4              1e 8a 02 00 00 00 00 00                                                                  ........
1400281ac  _.idata$4:
1400281ac                                      32 8a 02 00 00 00 00 00                                                  2.......
1400281b4  _.idata$4:
1400281b4                                                              4a 8a 02 00 00 00 00 00                                  J.......
1400281bc  _.idata$4:
1400281bc                                                                                      5a 8a 02 00                              Z...
1400281c0  00 00 00 00                                                                                      ....
1400281c4  _.idata$4:
1400281c4              68 8a 02 00 00 00 00 00                                                                  h.......
1400281cc  _.idata$4:
1400281cc                                      7e 8a 02 00 00 00 00 00                                                  ~.......
1400281d4  _.idata$4:
1400281d4                                                              90 8a 02 00 00 00 00 00                                  ........
1400281dc  _.idata$4:
1400281dc                                                                                      a4 8a 02 00                              ....
1400281e0  00 00 00 00                                                                                      ....
1400281e4  _.idata$4:
1400281e4              c6 8a 02 00 00 00 00 00                                                                  ........
1400281ec  _.idata$4:
1400281ec                                      d4 8a 02 00 00 00 00 00                                                  ........
1400281f4  _.idata$4:
1400281f4                                                              e4 8a 02 00 00 00 00 00                                  ........
1400281fc  _.idata$4:
1400281fc                                                                                      f0 8a 02 00                              ....
140028200  00 00 00 00                                                                                      ....
140028204  _.idata$4:
140028204              00 8b 02 00 00 00 00 00                                                                  ........
14002820c  _.idata$4:
14002820c                                      1a 8b 02 00 00 00 00 00                                                  ........
140028214  _.idata$4:
140028214                                                              2e 8b 02 00 00 00 00 00                                  ........
14002821c  _.idata$4:
14002821c                                                                                      42 8b 02 00                              B...
140028220  00 00 00 00                                                                                      ....
140028224  _.idata$4:
140028224              60 8b 02 00 00 00 00 00                                                                  `.......
14002822c  _.idata$4:
14002822c                                      68 8b 02 00 00 00 00 00                                                  h.......
140028234  _.idata$4:
140028234                                                              78 8b 02 00 00 00 00 00                                  x.......
14002823c  _.idata$4:
14002823c                                                                                      84 8b 02 00                              ....
140028240  00 00 00 00                                                                                      ....
140028244  _.idata$4:
140028244              92 8b 02 00 00 00 00 00                                                                  ........
14002824c  _.idata$4:
14002824c                                      a0 8b 02 00 00 00 00 00                                                  ........
140028254  _.idata$4:
140028254                                                              ba 8b 02 00 00 00 00 00                                  ........
14002825c  _.idata$4:
14002825c                                                                                      ca 8b 02 00                              ....
140028260  00 00 00 00                                                                                      ....
140028264  _.idata$4:
140028264              d8 8b 02 00 00 00 00 00                                                                  ........
14002826c  _.idata$4:
14002826c                                      ea 8b 02 00 00 00 00 00                                                  ........
140028274  _.idata$4:
140028274                                                              fa 8b 02 00 00 00 00 00                                  ........
14002827c  _.idata$4:
14002827c                                                                                      14 8c 02 00                              ....
140028280  00 00 00 00                                                                                      ....
140028284  _.idata$4:
140028284              00 00 00 00 00 00 00 00                                                                  ........
14002828c  _.idata$4:
14002828c                                      2a 8c 02 00 00 00 00 00                                                  *.......
140028294  _.idata$4:
140028294                                                              34 8c 02 00 00 00 00 00                                  4.......
14002829c  _.idata$4:
14002829c                                                                                      3e 8c 02 00                              >...
1400282a0  00 00 00 00                                                                                      ....
1400282a4  _.idata$4:
1400282a4              00 00 00 00 00 00 00 00                                                                  ........
1400282ac  _.idata$4:
1400282ac                                      48 8c 02 00 00 00 00 00                                                  H.......
1400282b4  _.idata$4:
1400282b4                                                              58 8c 02 00 00 00 00 00                                  X.......
1400282bc  _.idata$4:
1400282bc                                                                                      00 00 00 00                              ....
1400282c0  00 00 00 00                                                                                      ....
1400282c4  _.idata$4:
1400282c4              68 8c 02 00 00 00 00 00                                                                  h.......
1400282cc  _.idata$4:
1400282cc                                      76 8c 02 00 00 00 00 00                                                  v.......
1400282d4  _.idata$4:
1400282d4                                                              00 00 00 00 00 00 00 00                                  ........
1400282dc  _.idata$4:
1400282dc                                                                                      86 8c 02 00                              ....
1400282e0  00 00 00 00                                                                                      ....
1400282e4  _.idata$4:
1400282e4              96 8c 02 00 00 00 00 00                                                                  ........
1400282ec  _.idata$4:
1400282ec                                      a0 8c 02 00 00 00 00 00                                                  ........
1400282f4  _.idata$4:
1400282f4                                                              a8 8c 02 00 00 00 00 00                                  ........
1400282fc  _.idata$4:
1400282fc                                                                                      b2 8c 02 00                              ....
140028300  00 00 00 00                                                                                      ....
140028304  _.idata$4:
140028304              00 00 00 00 00 00 00 00                                                                  ........
14002830c  _.idata$4:
14002830c                                      bc 8c 02 00 00 00 00 00                                                  ........
140028314  _.idata$4:
140028314                                                              00 00 00 00 00 00 00 00                                  ........
14002831c  _.idata$4:
14002831c                                                                                      ca 8c 02 00                              ....
140028320  00 00 00 00                                                                                      ....
140028324  _.idata$4:
140028324              00 00 00 00 00 00 00 00                                                                  ........
14002832c  _.idata$4:
14002832c                                      de 8c 02 00 00 00 00 00                                                  ........
140028334  _.idata$4:
140028334                                                              f6 8c 02 00 00 00 00 00                                  ........
14002833c  _.idata$4:
14002833c                                                                                      0e 8d 02 00                              ....
140028340  00 00 00 00                                                                                      ....
140028344  _.idata$4:
140028344              18 8d 02 00 00 00 00 00                                                                  ........
14002834c  _.idata$4:
14002834c                                      22 8d 02 00 00 00 00 00                                                  ".......
140028354  _.idata$4:
140028354                                                              00 00 00 00 00 00 00 00                                  ........
14002835c  _.idata$4:
14002835c                                                                                      2c 8d 02 00                              ,...
140028360  00 00 00 00                                                                                      ....
140028364  _.idata$4:
140028364              3a 8d 02 00 00 00 00 00                                                                  :.......
14002836c  _.idata$4:
14002836c                                      48 8d 02 00 00 00 00 00                                                  H.......
140028374  _.idata$4:
140028374                                                              56 8d 02 00 00 00 00 00                                  V.......
14002837c  _.idata$4:
14002837c                                                                                      68 8d 02 00                              h...
140028380  00 00 00 00                                                                                      ....
140028384  _.idata$4:
140028384              72 8d 02 00 00 00 00 00                                                                  r.......
14002838c  _.idata$4:
14002838c                                      8c 8d 02 00 00 00 00 00                                                  ........
140028394  _.idata$4:
140028394                                                              a4 8d 02 00 00 00 00 00                                  ........
14002839c  _.idata$4:
14002839c                                                                                      ba 8d 02 00                              ....
1400283a0  00 00 00 00                                                                                      ....
1400283a4  _.idata$4:
1400283a4              c8 8d 02 00 00 00 00 00                                                                  ........
1400283ac  _.idata$4:
1400283ac                                      d8 8d 02 00 00 00 00 00                                                  ........
1400283b4  _.idata$4:
1400283b4                                                              e2 8d 02 00 00 00 00 00                                  ........
1400283bc  _.idata$4:
1400283bc                                                                                      ea 8d 02 00                              ....
1400283c0  00 00 00 00                                                                                      ....
1400283c4  _.idata$4:
1400283c4              0c 8e 02 00 00 00 00 00                                                                  ........
1400283cc  _.idata$4:
1400283cc                                      2c 8e 02 00 00 00 00 00                                                  ,.......
1400283d4  _.idata$4:
1400283d4                                                              38 8e 02 00 00 00 00 00                                  8.......
1400283dc  _.idata$4:
1400283dc                                                                                      48 8e 02 00                              H...
1400283e0  00 00 00 00                                                                                      ....
1400283e4  _.idata$4:
1400283e4              6a 8e 02 00 00 00 00 00                                                                  j.......
1400283ec  _.idata$4:
1400283ec                                      72 8e 02 00 00 00 00 00                                                  r.......
1400283f4  _.idata$4:
1400283f4                                                              7a 8e 02 00 00 00 00 00                                  z.......
1400283fc  _.idata$4:
1400283fc                                                                                      84 8e 02 00                              ....
140028400  00 00 00 00                                                                                      ....
140028404  _.idata$4:
140028404              00 00 00 00 00 00 00 00                                                                  ........
14002840c  _.idata$4:
14002840c                                      90 8e 02 00 00 00 00 00                                                  ........
140028414  _.idata$4:
140028414                                                              a2 8e 02 00 00 00 00 00                                  ........
14002841c  _.idata$4:
14002841c                                                                                      b2 8e 02 00                              ....
140028420  00 00 00 00                                                                                      ....
140028424  _.idata$4:
140028424              c0 8e 02 00 00 00 00 00                                                                  ........
14002842c  _.idata$4:
14002842c                                      da 8e 02 00 00 00 00 00                                                  ........
140028434  _.idata$4:
140028434                                                              f6 8e 02 00 00 00 00 00                                  ........
14002843c  _.idata$4:
14002843c                                                                                      00 8f 02 00                              ....
140028440  00 00 00 00                                                                                      ....
140028444  _.idata$4:
140028444              0c 8f 02 00 00 00 00 00                                                                  ........
14002844c  _.idata$4:
14002844c                                      16 8f 02 00 00 00 00 00                                                  ........
140028454  _.idata$4:
140028454                                                              1e 8f 02 00 00 00 00 00                                  ........
14002845c  _.idata$4:
14002845c                                                                                      00 00 00 00                              ....
140028460  00 00 00 00                                                                                      ....
140028464  _.idata$4:
140028464              28 8f 02 00 00 00 00 00                                                                  (.......
14002846c  _.idata$4:
14002846c                                      32 8f 02 00 00 00 00 00                                                  2.......
140028474  _.idata$4:
140028474                                                              3c 8f 02 00 00 00 00 00                                  <.......
14002847c  _.idata$4:
14002847c                                                                                      46 8f 02 00                              F...
140028480  00 00 00 00                                                                                      ....
140028484  _.idata$4:
140028484              50 8f 02 00 00 00 00 00                                                                  P.......
14002848c  _.idata$4:
14002848c                                      00 00 00 00 00 00 00 00                                                  ........
140028494  _.idata$4:
140028494                                                              5a 8f 02 00 00 00 00 00                                  Z.......
14002849c  _.idata$4:
14002849c                                                                                      68 8f 02 00                              h...
1400284a0  00 00 00 00                                                                                      ....
1400284a4  _.idata$4:
1400284a4              76 8f 02 00 00 00 00 00                                                                  v.......
1400284ac  _.idata$4:
1400284ac                                      82 8f 02 00 00 00 00 00                                                  ........
1400284b4  _.idata$4:
1400284b4                                                              00 00 00 00 00 00 00 00                                  ........

1400284bc  void* (* const KERNEL32:AddVectoredExceptionHandler)(uint32_t First, PVECTORED_EXCEPTION_HANDLER Handler) = AddVectoredExceptionHandler
1400284c4  BOOL (* const KERNEL32:CloseHandle)(HANDLE hObject) = CloseHandle
1400284cc  HANDLE (* const KERNEL32:CreateEventA)(SECURITY_ATTRIBUTES* lpEventAttributes, BOOL bManualReset, BOOL bInitialState, PSTR lpName) = CreateEventA
1400284d4  HANDLE (* const KERNEL32:CreateSemaphoreA)(SECURITY_ATTRIBUTES* lpSemaphoreAttributes, int32_t lInitialCount, int32_t lMaximumCount, PSTR lpName) = CreateSemaphoreA
1400284dc  void (* const KERNEL32:DeleteCriticalSection)(CRITICAL_SECTION* lpCriticalSection) = DeleteCriticalSection
1400284e4  BOOL (* const KERNEL32:DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, HANDLE* lpTargetHandle, uint32_t dwDesiredAccess, BOOL bInheritHandle, enum DUPLICATE_HANDLE_OPTIONS dwOptions) = DuplicateHandle
1400284ec  void (* const KERNEL32:EnterCriticalSection)(CRITICAL_SECTION* lpCriticalSection) = EnterCriticalSection
1400284f4  HANDLE (* const KERNEL32:GetCurrentProcess)() = GetCurrentProcess
1400284fc  uint32_t (* const KERNEL32:GetCurrentProcessId)() = GetCurrentProcessId
140028504  HANDLE (* const KERNEL32:GetCurrentThread)() = GetCurrentThread
14002850c  uint32_t (* const KERNEL32:GetCurrentThreadId)() = GetCurrentThreadId
140028514  BOOL (* const KERNEL32:GetHandleInformation)(HANDLE hObject, uint32_t* lpdwFlags) = GetHandleInformation
14002851c  enum WIN32_ERROR (* const KERNEL32:GetLastError)() = GetLastError
140028524  FARPROC (* const KERNEL32:GetProcAddress)(HMODULE hModule, PSTR lpProcName) = GetProcAddress
14002852c  BOOL (* const KERNEL32:GetProcessAffinityMask)(HANDLE hProcess, uint64_t* lpProcessAffinityMask, uint64_t* lpSystemAffinityMask) = GetProcessAffinityMask
140028534  void (* const KERNEL32:GetSystemTimeAsFileTime)(FILETIME* lpSystemTimeAsFileTime) = GetSystemTimeAsFileTime
14002853c  BOOL (* const KERNEL32:GetThreadContext)(HANDLE hThread, CONTEXT* lpContext) = GetThreadContext
140028544  int32_t (* const KERNEL32:GetThreadPriority)(HANDLE hThread) = GetThreadPriority
14002854c  uint64_t (* const KERNEL32:GetTickCount64)() = GetTickCount64
140028554  void (* const KERNEL32:InitializeCriticalSection)(CRITICAL_SECTION* lpCriticalSection) = InitializeCriticalSection
14002855c  BOOL (* const KERNEL32:IsDebuggerPresent)() = IsDebuggerPresent
140028564  void (* const KERNEL32:LeaveCriticalSection)(CRITICAL_SECTION* lpCriticalSection) = LeaveCriticalSection
14002856c  HMODULE (* const KERNEL32:LoadLibraryA)(PSTR lpLibFileName) = LoadLibraryA
140028574  HANDLE (* const KERNEL32:OpenProcess)(enum PROCESS_ACCESS_RIGHTS dwDesiredAccess, BOOL bInheritHandle, uint32_t dwProcessId) = OpenProcess
14002857c  void (* const KERNEL32:OutputDebugStringA)(PSTR lpOutputString) = OutputDebugStringA
140028584  void (* const KERNEL32:RaiseException)(uint32_t dwExceptionCode, uint32_t dwExceptionFlags, uint32_t nNumberOfArguments, uint64_t* lpArguments) __noreturn = RaiseException
14002858c  BOOL (* const KERNEL32:ReleaseSemaphore)(HANDLE hSemaphore, int32_t lReleaseCount, int32_t* lpPreviousCount) = ReleaseSemaphore
140028594  uint32_t (* const KERNEL32:RemoveVectoredExceptionHandler)(void* Handle) = RemoveVectoredExceptionHandler
14002859c  BOOL (* const KERNEL32:ResetEvent)(HANDLE hEvent) = ResetEvent
1400285a4  uint32_t (* const KERNEL32:ResumeThread)(HANDLE hThread) = ResumeThread
1400285ac  BOOL (* const KERNEL32:SetEvent)(HANDLE hEvent) = SetEvent
1400285b4  void (* const KERNEL32:SetLastError)(enum WIN32_ERROR dwErrCode) = SetLastError
1400285bc  BOOL (* const KERNEL32:SetProcessAffinityMask)(HANDLE hProcess, uint64_t dwProcessAffinityMask) = SetProcessAffinityMask
1400285c4  BOOL (* const KERNEL32:SetThreadContext)(HANDLE hThread, CONTEXT* lpContext) = SetThreadContext
1400285cc  BOOL (* const KERNEL32:SetThreadPriority)(HANDLE hThread, enum THREAD_PRIORITY nPriority) = SetThreadPriority
1400285d4  LPTOP_LEVEL_EXCEPTION_FILTER (* const KERNEL32:SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter) = SetUnhandledExceptionFilter
1400285dc  void (* const KERNEL32:Sleep)(uint32_t dwMilliseconds) = Sleep
1400285e4  uint32_t (* const KERNEL32:SuspendThread)(HANDLE hThread) = SuspendThread
1400285ec  uint32_t (* const KERNEL32:TlsAlloc)() = TlsAlloc
1400285f4  void* (* const KERNEL32:TlsGetValue)(uint32_t dwTlsIndex) = TlsGetValue
1400285fc  BOOL (* const KERNEL32:TlsSetValue)(uint32_t dwTlsIndex, void* lpTlsValue) = TlsSetValue
140028604  BOOL (* const KERNEL32:TryEnterCriticalSection)(CRITICAL_SECTION* lpCriticalSection) = TryEnterCriticalSection
14002860c  void* (* const KERNEL32:VirtualAlloc)(void* lpAddress, uint64_t dwSize, enum VIRTUAL_ALLOCATION_TYPE flAllocationType, enum PAGE_PROTECTION_FLAGS flProtect) = VirtualAlloc
140028614  BOOL (* const KERNEL32:VirtualFree)(void* lpAddress, uint64_t dwSize, enum VIRTUAL_FREE_TYPE dwFreeType) = VirtualFree
14002861c  BOOL (* const KERNEL32:VirtualProtect)(void* lpAddress, uint64_t dwSize, enum PAGE_PROTECTION_FLAGS flNewProtect, enum PAGE_PROTECTION_FLAGS* lpflOldProtect) = VirtualProtect
140028624  uint64_t (* const KERNEL32:VirtualQuery)(void* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, uint64_t dwLength) = VirtualQuery
14002862c  enum WAIT_EVENT (* const KERNEL32:WaitForMultipleObjects)(uint32_t nCount, HANDLE* lpHandles, BOOL bWaitAll, uint32_t dwMilliseconds) = WaitForMultipleObjects
140028634  enum WAIT_EVENT (* const KERNEL32:WaitForSingleObject)(HANDLE hHandle, uint32_t dwMilliseconds) = WaitForSingleObject

14002863c  _.idata$5:
14002863c                                                                                      00 00 00 00                              ....
140028640  00 00 00 00                                                                                      ....

140028644  char* (* const api-ms-win-crt-convert-l1-1-0:_ultoa)(uint32_t _Value, char* _Buffer, int32_t _Radix) = _ultoa
14002864c  uint64_t (* const api-ms-win-crt-convert-l1-1-0:mbrtowc)(wchar16* _DstCh, char const* _SrcCh, uint64_t _SizeInBytes, mbstate_t* _State) = mbrtowc
140028654  uint64_t (* const api-ms-win-crt-convert-l1-1-0:wcrtomb)(char* _Dest, wchar16 _Source, mbstate_t* _State) = wcrtomb

14002865c  _.idata$5:
14002865c                                                                                      00 00 00 00                              ....
140028660  00 00 00 00                                                                                      ....

140028664  char*** (* const api-ms-win-crt-environment-l1-1-0:__p__environ)() = __p__environ
14002866c  wchar16*** (* const api-ms-win-crt-environment-l1-1-0:__p__wenviron)() = __p__wenviron

140028674  _.idata$5:
140028674                                                              00 00 00 00 00 00 00 00                                  ........

14002867c  void (* const api-ms-win-crt-filesystem-l1-1-0:_lock_file)(FILE* _Stream) = _lock_file
140028684  void (* const api-ms-win-crt-filesystem-l1-1-0:_unlock_file)(FILE* _Stream) = _unlock_file

14002868c  _.idata$5:
14002868c                                      00 00 00 00 00 00 00 00                                                  ........

140028694  int32_t (* const api-ms-win-crt-heap-l1-1-0:_set_new_mode)(int32_t _NewMode) = _set_new_mode
14002869c  void* (* const api-ms-win-crt-heap-l1-1-0:calloc)(uint64_t _Count, uint64_t _Size) = calloc
1400286a4  void (* const api-ms-win-crt-heap-l1-1-0:free)(void* _Block) = free
1400286ac  void* (* const api-ms-win-crt-heap-l1-1-0:malloc)(uint64_t _Size) = malloc
1400286b4  void* (* const api-ms-win-crt-heap-l1-1-0:realloc)(void* _Block, uint64_t _Size) = realloc

1400286bc  _.idata$5:
1400286bc                                                                                      00 00 00 00                              ....
1400286c0  00 00 00 00                                                                                      ....

1400286c4  struct lconv* (* const api-ms-win-crt-locale-l1-1-0:localeconv)() = localeconv

1400286cc  _.idata$5:
1400286cc                                      00 00 00 00 00 00 00 00                                                  ........

1400286d4  void (* const api-ms-win-crt-math-l1-1-0:__setusermatherr)(_UserMathErrorFunctionPointer _UserMathErrorFunction) = __setusermatherr

1400286dc  _.idata$5:
1400286dc                                                                                      00 00 00 00                              ....
1400286e0  00 00 00 00                                                                                      ....

1400286e4  int64_t (* const api-ms-win-crt-private-l1-1-0:__C_specific_handler)() = __C_specific_handler
1400286ec  int64_t (* const api-ms-win-crt-private-l1-1-0:__intrinsic_setjmpex)(int64_t* arg1) = __intrinsic_setjmpex
1400286f4  void (* const api-ms-win-crt-private-l1-1-0:longjmp)(jmp_buf& _Buf, int32_t _Value) __noreturn = longjmp
1400286fc  void* (* const api-ms-win-crt-private-l1-1-0:memcpy)(void* _Dst, void const* _Src, uint64_t _Size) = memcpy
140028704  void* (* const api-ms-win-crt-private-l1-1-0:memmove)(void* _Dst, void const* _Src, uint64_t _Size) = memmove

14002870c  _.idata$5:
14002870c                                      00 00 00 00 00 00 00 00                                                  ........

140028714  int32_t* (* const api-ms-win-crt-runtime-l1-1-0:__p___argc)() = __p___argc
14002871c  char*** (* const api-ms-win-crt-runtime-l1-1-0:__p___argv)() = __p___argv
140028724  wchar16*** (* const api-ms-win-crt-runtime-l1-1-0:__p___wargv)() = __p___wargv
14002872c  uintptr_t (* const api-ms-win-crt-runtime-l1-1-0:_beginthreadex)(void* _Security, uint32_t _StackSize, _beginthreadex_proc_type _StartAddress, void* _ArgList, uint32_t _InitFlag, uint32_t* _ThrdAddr) = _beginthreadex
140028734  void (* const api-ms-win-crt-runtime-l1-1-0:_cexit)() = _cexit
14002873c  errno_t (* const api-ms-win-crt-runtime-l1-1-0:_configure_narrow_argv)(enum _crt_argv_mode mode) = _configure_narrow_argv
140028744  errno_t (* const api-ms-win-crt-runtime-l1-1-0:_configure_wide_argv)(enum _crt_argv_mode mode) = _configure_wide_argv
14002874c  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_crt_at_quick_exit)(_PVFV _Function) = _crt_at_quick_exit
140028754  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_crt_atexit)(_PVFV _Function) = _crt_atexit
14002875c  void (* const api-ms-win-crt-runtime-l1-1-0:_endthreadex)(uint32_t _ReturnCode) = _endthreadex
140028764  int32_t* (* const api-ms-win-crt-runtime-l1-1-0:_errno)() = _errno
14002876c  void (* const api-ms-win-crt-runtime-l1-1-0:_exit)(int32_t _Except) __noreturn = _exit
140028774  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_initialize_narrow_environment)() = _initialize_narrow_environment
14002877c  int32_t (* const api-ms-win-crt-runtime-l1-1-0:_initialize_wide_environment)() = _initialize_wide_environment
140028784  void (* const api-ms-win-crt-runtime-l1-1-0:_initterm)(_PVFV* _First, _PVFV* _Last) = _initterm
14002878c  void (* const api-ms-win-crt-runtime-l1-1-0:_set_app_type)(enum _crt_app_type _Type) = _set_app_type
140028794  _invalid_parameter_handler_1 (* const api-ms-win-crt-runtime-l1-1-0:_set_invalid_parameter_handler)(_invalid_parameter_handler_1 _Handler) = _set_invalid_parameter_handler
14002879c  void (* const api-ms-win-crt-runtime-l1-1-0:abort)() __noreturn = abort
1400287a4  void (* const api-ms-win-crt-runtime-l1-1-0:exit)(int32_t _Except) __noreturn = exit
1400287ac  _crt_signal_t (* const api-ms-win-crt-runtime-l1-1-0:signal)(int32_t _Signal, _crt_signal_t _Function) = signal
1400287b4  char* (* const api-ms-win-crt-runtime-l1-1-0:strerror)(char const* _Source) = strerror

1400287bc  _.idata$5:
1400287bc                                                                                      00 00 00 00                              ....
1400287c0  00 00 00 00                                                                                      ....

1400287c4  FILE* (* const api-ms-win-crt-stdio-l1-1-0:__acrt_iob_func)(uint32_t _Ix) = __acrt_iob_func
1400287cc  int32_t* (* const api-ms-win-crt-stdio-l1-1-0:__p__commode)() = __p__commode
1400287d4  int32_t* (* const api-ms-win-crt-stdio-l1-1-0:__p__fmode)() = __p__fmode
1400287dc  int32_t (* const api-ms-win-crt-stdio-l1-1-0:__stdio_common_vfprintf)(uint64_t _Options, FILE* _Stream, char const* _Format, _locale_t _Locale, va_list _ArgList) = __stdio_common_vfprintf
1400287e4  int32_t (* const api-ms-win-crt-stdio-l1-1-0:__stdio_common_vfwprintf)(uint64_t _Options, FILE* _Stream, wchar16 const* _Format, _locale_t _Locale, va_list _ArgList) = __stdio_common_vfwprintf
1400287ec  int32_t (* const api-ms-win-crt-stdio-l1-1-0:_fileno)(FILE* _Stream) = _fileno
1400287f4  int32_t (* const api-ms-win-crt-stdio-l1-1-0:_setmode)(int32_t _FileHandleSrc, int32_t _FileHandleDst) = _setmode
1400287fc  int32_t (* const api-ms-win-crt-stdio-l1-1-0:fflush)(FILE* _Stream) = fflush
140028804  int32_t (* const api-ms-win-crt-stdio-l1-1-0:fputc)(int32_t _Character, FILE* _Stream) = fputc
14002880c  uint64_t (* const api-ms-win-crt-stdio-l1-1-0:fwrite)(void const* _Buffer, uint64_t _ElementSize, uint64_t _ElementCount, FILE* _Stream) = fwrite

140028814  _.idata$5:
140028814                                                              00 00 00 00 00 00 00 00                                  ........

14002881c  char* (* const api-ms-win-crt-string-l1-1-0:_strdup)(char const* _Source) = _strdup
140028824  void* (* const api-ms-win-crt-string-l1-1-0:memset)(void* _Dst, int32_t _Val, uint64_t _Size) = memset
14002882c  uint64_t (* const api-ms-win-crt-string-l1-1-0:strlen)(char const* _Str) = strlen
140028834  int32_t (* const api-ms-win-crt-string-l1-1-0:strncmp)(char const* _Str1, char const* _Str2, uint64_t _MaxCount) = strncmp
14002883c  uint64_t (* const api-ms-win-crt-string-l1-1-0:wcslen)(wchar16 const* _String) = wcslen

140028844  _.idata$5:
140028844              00 00 00 00 00 00 00 00                                                                  ........

14002884c  int32_t* (* const api-ms-win-crt-time-l1-1-0:__daylight)() = __daylight
140028854  int32_t* (* const api-ms-win-crt-time-l1-1-0:__timezone)() = __timezone
14002885c  char** (* const api-ms-win-crt-time-l1-1-0:__tzname)() = __tzname
140028864  void (* const api-ms-win-crt-time-l1-1-0:_tzset)() = _tzset

14002886c  _.idata$5:
14002886c                                      00 00 00 00 00 00 00 00                                                  ........
140028874  _.idata$6:
140028874                                                              14 00                                                    ..

140028876  char __import_name_0(KERNEL32:AddVectoredExceptionHandler)[0x1c] = "AddVectoredExceptionHandler", 0

140028892  _.idata$6:
140028892                                                        8d 00                                                        ..

140028894  char __import_name_0(KERNEL32:CloseHandle)[0xc] = "CloseHandle", 0

1400288a0  _.idata$6:
1400288a0  c5 00                                                                                            ..

1400288a2  char __import_name_0(KERNEL32:CreateEventA)[0xd] = "CreateEventA", 0

1400288af                                               00                                                                 .
1400288b0  _.idata$6:
1400288b0                                                  f1 00                                                            ..

1400288b2  char __import_name_0(KERNEL32:CreateSemaphoreA)[0x11] = "CreateSemaphoreA", 0

1400288c3           00                                                                                         .
1400288c4  _.idata$6:
1400288c4              19 01                                                                                    ..

1400288c6  char __import_name_0(KERNEL32:DeleteCriticalSection)[0x16] = "DeleteCriticalSection", 0

1400288dc  _.idata$6:
1400288dc                                                                                      37 01                                    7.

1400288de  char __import_name_0(KERNEL32:DuplicateHandle)[0x10] = "DuplicateHandle", 0

1400288ee  _.idata$6:
1400288ee                                            3d 01                                                                =.

1400288f0  char __import_name_0(KERNEL32:EnterCriticalSection)[0x15] = "EnterCriticalSection", 0

140028905                 00                                                                                     .
140028906  _.idata$6:
140028906                    26 02                                                                                &.

140028908  char __import_name_0(KERNEL32:GetCurrentProcess)[0x12] = "GetCurrentProcess", 0

14002891a  _.idata$6:
14002891a                                                                                27 02                                        '.

14002891c  char __import_name_0(KERNEL32:GetCurrentProcessId)[0x14] = "GetCurrentProcessId", 0

140028930  _.idata$6:
140028930                                                  2a 02                                                            *.

140028932  char __import_name_0(KERNEL32:GetCurrentThread)[0x11] = "GetCurrentThread", 0

140028943           00                                                                                         .
140028944  _.idata$6:
140028944              2b 02                                                                                    +.

140028946  char __import_name_0(KERNEL32:GetCurrentThreadId)[0x13] = "GetCurrentThreadId", 0

140028959                                                                             00                                             .
14002895a  _.idata$6:
14002895a                                                                                71 02                                        q.

14002895c  char __import_name_0(KERNEL32:GetHandleInformation)[0x15] = "GetHandleInformation", 0

140028971                                                     00                                                             .
140028972  _.idata$6:
140028972                                                        74 02                                                        t.

140028974  char __import_name_0(KERNEL32:GetLastError)[0xd] = "GetLastError", 0

140028981     00                                                                                             .
140028982  _.idata$6:
140028982        c4 02                                                                                        ..

140028984  char __import_name_0(KERNEL32:GetProcAddress)[0xf] = "GetProcAddress", 0

140028993                                                           00                                                         .
140028994  _.idata$6:
140028994                                                              c5 02                                                    ..

140028996  char __import_name_0(KERNEL32:GetProcessAffinityMask)[0x17] = "GetProcessAffinityMask", 0

1400289ad                                         00                                                                     .
1400289ae  _.idata$6:
1400289ae                                            ff 02                                                                ..

1400289b0  char __import_name_0(KERNEL32:GetSystemTimeAsFileTime)[0x18] = "GetSystemTimeAsFileTime", 0

1400289c8  _.idata$6:
1400289c8                          0d 03                                                                            ..

1400289ca  char __import_name_0(KERNEL32:GetThreadContext)[0x11] = "GetThreadContext", 0

1400289db                                                                                   00                                         .
1400289dc  _.idata$6:
1400289dc                                                                                      17 03                                    ..

1400289de  char __import_name_0(KERNEL32:GetThreadPriority)[0x12] = "GetThreadPriority", 0

1400289f0  _.idata$6:
1400289f0                                                  1e 03                                                            ..

1400289f2  char __import_name_0(KERNEL32:GetTickCount64)[0xf] = "GetTickCount64", 0

140028a01     00                                                                                             .
140028a02  _.idata$6:
140028a02        7a 03                                                                                        z.

140028a04  char __import_name_0(KERNEL32:InitializeCriticalSection)[0x1a] = "InitializeCriticalSection", 0

140028a1e  _.idata$6:
140028a1e                                                                                            96 03                                ..

140028a20  char __import_name_0(KERNEL32:IsDebuggerPresent)[0x12] = "IsDebuggerPresent", 0

140028a32  _.idata$6:
140028a32                                                        d6 03                                                        ..

140028a34  char __import_name_0(KERNEL32:LeaveCriticalSection)[0x15] = "LeaveCriticalSection", 0

140028a49                             00                                                                             .
140028a4a  _.idata$6:
140028a4a                                da 03                                                                        ..

140028a4c  char __import_name_0(KERNEL32:LoadLibraryA)[0xd] = "LoadLibraryA", 0

140028a59                                                                             00                                             .
140028a5a  _.idata$6:
140028a5a                                                                                2b 04                                        +.

140028a5c  char __import_name_0(KERNEL32:OpenProcess)[0xc] = "OpenProcess", 0

140028a68  _.idata$6:
140028a68                          34 04                                                                            4.

140028a6a  char __import_name_0(KERNEL32:OutputDebugStringA)[0x13] = "OutputDebugStringA", 0

140028a7d                                                                                         00                                     .
140028a7e  _.idata$6:
140028a7e                                                                                            7f 04                                ..

140028a80  char __import_name_0(KERNEL32:RaiseException)[0xf] = "RaiseException", 0

140028a8f                                               00                                                                 .
140028a90  _.idata$6:
140028a90                                                  aa 04                                                            ..

140028a92  char __import_name_0(KERNEL32:ReleaseSemaphore)[0x11] = "ReleaseSemaphore", 0

140028aa3           00                                                                                         .
140028aa4  _.idata$6:
140028aa4              b5 04                                                                                    ..

140028aa6  char __import_name_0(KERNEL32:RemoveVectoredExceptionHandler)[0x1f] = "RemoveVectoredExceptionHandler", 0

140028ac5                 00                                                                                     .
140028ac6  _.idata$6:
140028ac6                    bc 04                                                                                ..

140028ac8  char __import_name_0(KERNEL32:ResetEvent)[0xb] = "ResetEvent", 0

140028ad3                                                           00                                                         .
140028ad4  _.idata$6:
140028ad4                                                              c3 04                                                    ..

140028ad6  char __import_name_0(KERNEL32:ResumeThread)[0xd] = "ResumeThread", 0

140028ae3           00                                                                                         .
140028ae4  _.idata$6:
140028ae4              18 05                                                                                    ..

140028ae6  char __import_name_0(KERNEL32:SetEvent)[0x9] = "SetEvent", 0

140028aef                                               00                                                                 .
140028af0  _.idata$6:
140028af0                                                  34 05                                                            4.

140028af2  char __import_name_0(KERNEL32:SetLastError)[0xd] = "SetLastError", 0

140028aff                                                                                               00                                 .
140028b00  _.idata$6:
140028b00  3f 05                                                                                            ?.

140028b02  char __import_name_0(KERNEL32:SetProcessAffinityMask)[0x17] = "SetProcessAffinityMask", 0

140028b19                                                                             00                                             .
140028b1a  _.idata$6:
140028b1a                                                                                56 05                                        V.

140028b1c  char __import_name_0(KERNEL32:SetThreadContext)[0x11] = "SetThreadContext", 0

140028b2d                                         00                                                                     .
140028b2e  _.idata$6:
140028b2e                                            60 05                                                                `.

140028b30  char __import_name_0(KERNEL32:SetThreadPriority)[0x12] = "SetThreadPriority", 0

140028b42  _.idata$6:
140028b42        6f 05                                                                                        o.

140028b44  char __import_name_0(KERNEL32:SetUnhandledExceptionFilter)[0x1c] = "SetUnhandledExceptionFilter", 0

140028b60  _.idata$6:
140028b60  7f 05                                                                                            ..

140028b62  char __import_name_0(KERNEL32:Sleep)[0x6] = "Sleep", 0

140028b68  _.idata$6:
140028b68                          87 05                                                                            ..

140028b6a  char __import_name_0(KERNEL32:SuspendThread)[0xe] = "SuspendThread", 0

140028b78  _.idata$6:
140028b78                                                                          a0 05                                            ..

140028b7a  char __import_name_0(KERNEL32:TlsAlloc)[0x9] = "TlsAlloc", 0

140028b83           00                                                                                         .
140028b84  _.idata$6:
140028b84              a2 05                                                                                    ..

140028b86  char __import_name_0(KERNEL32:TlsGetValue)[0xc] = "TlsGetValue", 0

140028b92  _.idata$6:
140028b92                                                        a3 05                                                        ..

140028b94  char __import_name_0(KERNEL32:TlsSetValue)[0xc] = "TlsSetValue", 0

140028ba0  _.idata$6:
140028ba0  a9 05                                                                                            ..

140028ba2  char __import_name_0(KERNEL32:TryEnterCriticalSection)[0x18] = "TryEnterCriticalSection", 0

140028bba  _.idata$6:
140028bba                                                                                cb 05                                        ..

140028bbc  char __import_name_0(KERNEL32:VirtualAlloc)[0xd] = "VirtualAlloc", 0

140028bc9                             00                                                                             .
140028bca  _.idata$6:
140028bca                                ce 05                                                                        ..

140028bcc  char __import_name_0(KERNEL32:VirtualFree)[0xc] = "VirtualFree", 0

140028bd8  _.idata$6:
140028bd8                                                                          d1 05                                            ..

140028bda  char __import_name_0(KERNEL32:VirtualProtect)[0xf] = "VirtualProtect", 0

140028be9                             00                                                                             .
140028bea  _.idata$6:
140028bea                                d3 05                                                                        ..

140028bec  char __import_name_0(KERNEL32:VirtualQuery)[0xd] = "VirtualQuery", 0

140028bf9                                                                             00                                             .
140028bfa  _.idata$6:
140028bfa                                                                                da 05                                        ..

140028bfc  char __import_name_0(KERNEL32:WaitForMultipleObjects)[0x17] = "WaitForMultipleObjects", 0

140028c13                                                           00                                                         .
140028c14  _.idata$6:
140028c14                                                              dc 05                                                    ..

140028c16  char __import_name_0(KERNEL32:WaitForSingleObject)[0x14] = "WaitForSingleObject", 0

140028c2a  _.idata$6:
140028c2a                                37 00                                                                        7.

140028c2c  char __import_name_1(api-ms-win-crt-convert-l1-1-0:_ultoa)[0x7] = "_ultoa", 0

140028c33                                                           00                                                         .
140028c34  _.idata$6:
140028c34                                                              5f 00                                                    _.

140028c36  char __import_name_1(api-ms-win-crt-convert-l1-1-0:mbrtowc)[0x8] = "mbrtowc", 0

140028c3e  _.idata$6:
140028c3e                                                                                            6d 00                                m.

140028c40  char __import_name_1(api-ms-win-crt-convert-l1-1-0:wcrtomb)[0x8] = "wcrtomb", 0

140028c48  _.idata$6:
140028c48                          01 00                                                                            ..

140028c4a  char __import_name_2(api-ms-win-crt-environment-l1-1-0:__p__environ)[0xd] = "__p__environ", 0

140028c57                                                                       00                                                 .
140028c58  _.idata$6:
140028c58                                                                          02 00                                            ..

140028c5a  char __import_name_2(api-ms-win-crt-environment-l1-1-0:__p__wenviron)[0xe] = "__p__wenviron", 0

140028c68  _.idata$6:
140028c68                          1b 00                                                                            ..

140028c6a  char __import_name_3(api-ms-win-crt-filesystem-l1-1-0:_lock_file)[0xb] = "_lock_file", 0

140028c75                                                                 00                                                     .
140028c76  _.idata$6:
140028c76                                                                    2d 00                                                -.

140028c78  char __import_name_3(api-ms-win-crt-filesystem-l1-1-0:_unlock_file)[0xd] = "_unlock_file", 0

140028c85                 00                                                                                     .
140028c86  _.idata$6:
140028c86                    18 00                                                                                ..

140028c88  char __import_name_4(api-ms-win-crt-heap-l1-1-0:_set_new_mode)[0xe] = "_set_new_mode", 0

140028c96  _.idata$6:
140028c96                                                                    19 00                                                ..

140028c98  char __import_name_4(api-ms-win-crt-heap-l1-1-0:calloc)[0x7] = "calloc", 0

140028c9f                                                                                               00                                 .
140028ca0  _.idata$6:
140028ca0  1a 00                                                                                            ..

140028ca2  char __import_name_4(api-ms-win-crt-heap-l1-1-0:free)[0x5] = "free", 0

140028ca7                       00                                                                                 .
140028ca8  _.idata$6:
140028ca8                          1b 00                                                                            ..

140028caa  char __import_name_4(api-ms-win-crt-heap-l1-1-0:malloc)[0x7] = "malloc", 0

140028cb1                                                     00                                                             .
140028cb2  _.idata$6:
140028cb2                                                        1c 00                                                        ..

140028cb4  char __import_name_4(api-ms-win-crt-heap-l1-1-0:realloc)[0x8] = "realloc", 0

140028cbc  _.idata$6:
140028cbc                                                                                      14 00                                    ..

140028cbe  char __import_name_5(api-ms-win-crt-locale-l1-1-0:localeconv)[0xb] = "localeconv", 0

140028cc9                             00                                                                             .
140028cca  _.idata$6:
140028cca                                0a 00                                                                        ..

140028ccc  char __import_name_6(api-ms-win-crt-math-l1-1-0:__setusermatherr)[0x11] = "__setusermatherr", 0

140028cdd                                                                                         00                                     .
140028cde  _.idata$6:
140028cde                                                                                            10 00                                ..

140028ce0  char __import_name_7(api-ms-win-crt-private-l1-1-0:__C_specific_handler)[0x15] = "__C_specific_handler", 0

140028cf5                                                                 00                                                     .
140028cf6  _.idata$6:
140028cf6                                                                    28 00                                                (.

140028cf8  char __import_name_7(api-ms-win-crt-private-l1-1-0:__intrinsic_setjmpex)[0x15] = "__intrinsic_setjmpex", 0

140028d0d                                         00                                                                     .
140028d0e  _.idata$6:
140028d0e                                            75 04                                                                u.

140028d10  char __import_name_7(api-ms-win-crt-private-l1-1-0:longjmp)[0x8] = "longjmp", 0

140028d18  _.idata$6:
140028d18                                                                          78 04                                            x.

140028d1a  char __import_name_7(api-ms-win-crt-private-l1-1-0:memcpy)[0x7] = "memcpy", 0

140028d21     00                                                                                             .
140028d22  _.idata$6:
140028d22        79 04                                                                                        y.

140028d24  char __import_name_7(api-ms-win-crt-private-l1-1-0:memmove)[0x8] = "memmove", 0

140028d2c  _.idata$6:
140028d2c                                      05 00                                                                    ..

140028d2e  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:__p___argc)[0xb] = "__p___argc", 0

140028d39                                                                             00                                             .
140028d3a  _.idata$6:
140028d3a                                                                                06 00                                        ..

140028d3c  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:__p___argv)[0xb] = "__p___argv", 0

140028d47                       00                                                                                 .
140028d48  _.idata$6:
140028d48                          07 00                                                                            ..

140028d4a  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:__p___wargv)[0xc] = "__p___wargv", 0

140028d56  _.idata$6:
140028d56                                                                    15 00                                                ..

140028d58  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_beginthreadex)[0xf] = "_beginthreadex", 0

140028d67                       00                                                                                 .
140028d68  _.idata$6:
140028d68                          17 00                                                                            ..

140028d6a  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_cexit)[0x7] = "_cexit", 0

140028d71                                                     00                                                             .
140028d72  _.idata$6:
140028d72                                                        19 00                                                        ..

140028d74  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_configure_narrow_argv)[0x17] = "_configure_narrow_argv", 0

140028d8b                                   00                                                                         .
140028d8c  _.idata$6:
140028d8c                                      1a 00                                                                    ..

140028d8e  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_configure_wide_argv)[0x15] = "_configure_wide_argv", 0

140028da3           00                                                                                         .
140028da4  _.idata$6:
140028da4              1e 00                                                                                    ..

140028da6  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_crt_at_quick_exit)[0x13] = "_crt_at_quick_exit", 0

140028db9                                                                             00                                             .
140028dba  _.idata$6:
140028dba                                                                                1f 00                                        ..

140028dbc  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_crt_atexit)[0xc] = "_crt_atexit", 0

140028dc8  _.idata$6:
140028dc8                          22 00                                                                            ".

140028dca  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_endthreadex)[0xd] = "_endthreadex", 0

140028dd7                                                                       00                                                 .
140028dd8  _.idata$6:
140028dd8                                                                          23 00                                            #.

140028dda  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_errno)[0x7] = "_errno", 0

140028de1     00                                                                                             .
140028de2  _.idata$6:
140028de2        25 00                                                                                        %.

140028de4  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_exit)[0x6] = "_exit", 0

140028dea  _.idata$6:
140028dea                                36 00                                                                        6.

140028dec  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_initialize_narrow_environment)[0x1f] = "_initialize_narrow_environment", 0

140028e0b                                   00                                                                         .
140028e0c  _.idata$6:
140028e0c                                      38 00                                                                    8.

140028e0e  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_initialize_wide_environment)[0x1d] = "_initialize_wide_environment", 0

140028e2b                                   00                                                                         .
140028e2c  _.idata$6:
140028e2c                                      39 00                                                                    9.

140028e2e  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_initterm)[0xa] = "_initterm", 0

140028e38  _.idata$6:
140028e38                                                                          45 00                                            E.

140028e3a  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_set_app_type)[0xe] = "_set_app_type", 0

140028e48  _.idata$6:
140028e48                          4b 00                                                                            K.

140028e4a  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:_set_invalid_parameter_handler)[0x1f] = "_set_invalid_parameter_handler", 0

140028e69                             00                                                                             .
140028e6a  _.idata$6:
140028e6a                                58 00                                                                        X.

140028e6c  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:abort)[0x6] = "abort", 0

140028e72  _.idata$6:
140028e72                                                        59 00                                                        Y.

140028e74  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:exit)[0x5] = "exit", 0

140028e79                                                                             00                                             .
140028e7a  _.idata$6:
140028e7a                                                                                67 00                                        g.

140028e7c  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:signal)[0x7] = "signal", 0

140028e83           00                                                                                         .
140028e84  _.idata$6:
140028e84              68 00                                                                                    h.

140028e86  char __import_name_8(api-ms-win-crt-runtime-l1-1-0:strerror)[0x9] = "strerror", 0

140028e8f                                               00                                                                 .
140028e90  _.idata$6:
140028e90                                                  01 00                                                            ..

140028e92  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:__acrt_iob_func)[0x10] = "__acrt_iob_func", 0

140028ea2  _.idata$6:
140028ea2        02 00                                                                                        ..

140028ea4  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:__p__commode)[0xd] = "__p__commode", 0

140028eb1                                                     00                                                             .
140028eb2  _.idata$6:
140028eb2                                                        03 00                                                        ..

140028eb4  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:__p__fmode)[0xb] = "__p__fmode", 0

140028ebf                                                                                               00                                 .
140028ec0  _.idata$6:
140028ec0  04 00                                                                                            ..

140028ec2  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:__stdio_common_vfprintf)[0x18] = "__stdio_common_vfprintf", 0

140028eda  _.idata$6:
140028eda                                                                                08 00                                        ..

140028edc  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:__stdio_common_vfwprintf)[0x19] = "__stdio_common_vfwprintf", 0

140028ef5                                                                 00                                                     .
140028ef6  _.idata$6:
140028ef6                                                                    30 00                                                0.

140028ef8  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:_fileno)[0x8] = "_fileno", 0

140028f00  _.idata$6:
140028f00  71 00                                                                                            q.

140028f02  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:_setmode)[0x9] = "_setmode", 0

140028f0b                                   00                                                                         .
140028f0c  _.idata$6:
140028f0c                                      96 00                                                                    ..

140028f0e  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:fflush)[0x7] = "fflush", 0

140028f15                                                                 00                                                     .
140028f16  _.idata$6:
140028f16                                                                    9e 00                                                ..

140028f18  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:fputc)[0x6] = "fputc", 0

140028f1e  _.idata$6:
140028f1e                                                                                            a9 00                                ..

140028f20  char __import_name_9(api-ms-win-crt-stdio-l1-1-0:fwrite)[0x7] = "fwrite", 0

140028f27                       00                                                                                 .
140028f28  _.idata$6:
140028f28                          36 00                                                                            6.

140028f2a  char __import_name_10(api-ms-win-crt-string-l1-1-0:_strdup)[0x8] = "_strdup", 0

140028f32  _.idata$6:
140028f32                                                        a0 00                                                        ..

140028f34  char __import_name_10(api-ms-win-crt-string-l1-1-0:memset)[0x7] = "memset", 0

140028f3b                                                                                   00                                         .
140028f3c  _.idata$6:
140028f3c                                                                                      a8 00                                    ..

140028f3e  char __import_name_10(api-ms-win-crt-string-l1-1-0:strlen)[0x7] = "strlen", 0

140028f45                 00                                                                                     .
140028f46  _.idata$6:
140028f46                    ab 00                                                                                ..

140028f48  char __import_name_10(api-ms-win-crt-string-l1-1-0:strncmp)[0x8] = "strncmp", 0

140028f50  _.idata$6:
140028f50                                                  bf 00                                                            ..

140028f52  char __import_name_10(api-ms-win-crt-string-l1-1-0:wcslen)[0x7] = "wcslen", 0

140028f59                                                                             00                                             .
140028f5a  _.idata$6:
140028f5a                                                                                09 00                                        ..

140028f5c  char __import_name_11(api-ms-win-crt-time-l1-1-0:__daylight)[0xb] = "__daylight", 0

140028f67                       00                                                                                 .
140028f68  _.idata$6:
140028f68                          0b 00                                                                            ..

140028f6a  char __import_name_11(api-ms-win-crt-time-l1-1-0:__timezone)[0xb] = "__timezone", 0

140028f75                                                                 00                                                     .
140028f76  _.idata$6:
140028f76                                                                    0c 00                                                ..

140028f78  char __import_name_11(api-ms-win-crt-time-l1-1-0:__tzname)[0x9] = "__tzname", 0

140028f81     00                                                                                             .
140028f82  _.idata$6:
140028f82        3c 00                                                                                        <.

140028f84  char __import_name_11(api-ms-win-crt-time-l1-1-0:_tzset)[0x7] = "_tzset", 0

140028f8b                                   00                                                                         .
140028f8c  _.idata$7:
140028f8c                                      00 80 02 00                                                              ....
140028f90  _.idata$7:
140028f90                                                  00 80 02 00                                                      ....
140028f94  _.idata$7:
140028f94                                                              00 80 02 00                                              ....
140028f98  _.idata$7:
140028f98                                                                          00 80 02 00                                      ....
140028f9c  _.idata$7:
140028f9c                                                                                      00 80 02 00                              ....
140028fa0  _.idata$7:
140028fa0  00 80 02 00                                                                                      ....
140028fa4  _.idata$7:
140028fa4              00 80 02 00                                                                              ....
140028fa8  _.idata$7:
140028fa8                          00 80 02 00                                                                      ....
140028fac  _.idata$7:
140028fac                                      00 80 02 00                                                              ....
140028fb0  _.idata$7:
140028fb0                                                  00 80 02 00                                                      ....
140028fb4  _.idata$7:
140028fb4                                                              00 80 02 00                                              ....
140028fb8  _.idata$7:
140028fb8                                                                          00 80 02 00                                      ....
140028fbc  _.idata$7:
140028fbc                                                                                      00 80 02 00                              ....
140028fc0  _.idata$7:
140028fc0  00 80 02 00                                                                                      ....
140028fc4  _.idata$7:
140028fc4              00 80 02 00                                                                              ....
140028fc8  _.idata$7:
140028fc8                          00 80 02 00                                                                      ....
140028fcc  _.idata$7:
140028fcc                                      00 80 02 00                                                              ....
140028fd0  _.idata$7:
140028fd0                                                  00 80 02 00                                                      ....
140028fd4  _.idata$7:
140028fd4                                                              00 80 02 00                                              ....
140028fd8  _.idata$7:
140028fd8                                                                          00 80 02 00                                      ....
140028fdc  _.idata$7:
140028fdc                                                                                      00 80 02 00                              ....
140028fe0  _.idata$7:
140028fe0  00 80 02 00                                                                                      ....
140028fe4  _.idata$7:
140028fe4              00 80 02 00                                                                              ....
140028fe8  _.idata$7:
140028fe8                          00 80 02 00                                                                      ....
140028fec  _.idata$7:
140028fec                                      00 80 02 00                                                              ....
140028ff0  _.idata$7:
140028ff0                                                  00 80 02 00                                                      ....
140028ff4  _.idata$7:
140028ff4                                                              00 80 02 00                                              ....
140028ff8  _.idata$7:
140028ff8                                                                          00 80 02 00                                      ....
140028ffc  _.idata$7:
140028ffc                                                                                      00 80 02 00                              ....
140029000  _.idata$7:
140029000  00 80 02 00                                                                                      ....
140029004  _.idata$7:
140029004              00 80 02 00                                                                              ....
140029008  _.idata$7:
140029008                          00 80 02 00                                                                      ....
14002900c  _.idata$7:
14002900c                                      00 80 02 00                                                              ....
140029010  _.idata$7:
140029010                                                  00 80 02 00                                                      ....
140029014  _.idata$7:
140029014                                                              00 80 02 00                                              ....
140029018  _.idata$7:
140029018                                                                          00 80 02 00                                      ....
14002901c  _.idata$7:
14002901c                                                                                      00 80 02 00                              ....
140029020  _.idata$7:
140029020  00 80 02 00                                                                                      ....
140029024  _.idata$7:
140029024              00 80 02 00                                                                              ....
140029028  _.idata$7:
140029028                          00 80 02 00                                                                      ....
14002902c  _.idata$7:
14002902c                                      00 80 02 00                                                              ....
140029030  _.idata$7:
140029030                                                  00 80 02 00                                                      ....
140029034  _.idata$7:
140029034                                                              00 80 02 00                                              ....
140029038  _.idata$7:
140029038                                                                          00 80 02 00                                      ....
14002903c  _.idata$7:
14002903c                                                                                      00 80 02 00                              ....
140029040  _.idata$7:
140029040  00 80 02 00                                                                                      ....
140029044  _.idata$7:
140029044              00 80 02 00                                                                              ....
140029048  _.idata$7:
140029048                          00 80 02 00                                                                      ....
14002904c  _.idata$7:
14002904c                                      4b 45 52 4e 45 4c 33 32 2e 64 6c 6c 00 00 00 00                          KERNEL32.dll....
14002905c  _.idata$7:
14002905c                                                                                      14 80 02 00                              ....
140029060  _.idata$7:
140029060  14 80 02 00                                                                                      ....
140029064  _.idata$7:
140029064              14 80 02 00                                                                              ....
140029068  _.idata$7:
140029068                          61 70 69 2d 6d 73 2d 77 69 6e 2d 63 72 74 2d 63 6f 6e 76 65 72 74 2d 6c          api-ms-win-crt-convert-l
140029080  31 2d 31 2d 30 2e 64 6c 6c 00 00 00                                                              1-1-0.dll...
14002908c  _.idata$7:
14002908c                                      28 80 02 00                                                              (...
140029090  _.idata$7:
140029090                                                  28 80 02 00                                                      (...
140029094  _.idata$7:
140029094                                                              61 70 69 2d 6d 73 2d 77 69 6e 2d 63                      api-ms-win-c
1400290a0  72 74 2d 65 6e 76 69 72 6f 6e 6d 65 6e 74 2d 6c 31 2d 31 2d 30 2e 64 6c 6c 00 00 00              rt-environment-l1-1-0.dll...
1400290bc  _.idata$7:
1400290bc                                                                                      3c 80 02 00                              <...
1400290c0  _.idata$7:
1400290c0  3c 80 02 00                                                                                      <...
1400290c4  _.idata$7:
1400290c4              61 70 69 2d 6d 73 2d 77 69 6e 2d 63 72 74 2d 66 69 6c 65 73 79 73 74 65 6d 2d 6c 31      api-ms-win-crt-filesystem-l1
1400290e0  2d 31 2d 30 2e 64 6c 6c 00 00 00 00                                                              -1-0.dll....
1400290ec  _.idata$7:
1400290ec                                      50 80 02 00                                                              P...
1400290f0  _.idata$7:
1400290f0                                                  50 80 02 00                                                      P...
1400290f4  _.idata$7:
1400290f4                                                              50 80 02 00                                              P...
1400290f8  _.idata$7:
1400290f8                                                                          50 80 02 00                                      P...
1400290fc  _.idata$7:
1400290fc                                                                                      50 80 02 00                              P...
140029100  _.idata$7:
140029100  61 70 69 2d 6d 73 2d 77 69 6e 2d 63 72 74 2d 68 65 61 70 2d 6c 31 2d 31 2d 30 2e 64 6c 6c 00 00  api-ms-win-crt-heap-l1-1-0.dll..
140029120  _.idata$7:
140029120  64 80 02 00                                                                                      d...
140029124  _.idata$7:
140029124              61 70 69 2d 6d 73 2d 77 69 6e 2d 63 72 74 2d 6c 6f 63 61 6c 65 2d 6c 31 2d 31 2d 30      api-ms-win-crt-locale-l1-1-0
140029140  2e 64 6c 6c 00 00 00 00                                                                          .dll....
140029148  _.idata$7:
140029148                          78 80 02 00                                                                      x...
14002914c  _.idata$7:
14002914c                                      61 70 69 2d 6d 73 2d 77 69 6e 2d 63 72 74 2d 6d 61 74 68 2d              api-ms-win-crt-math-
140029160  6c 31 2d 31 2d 30 2e 64 6c 6c 00 00                                                              l1-1-0.dll..
14002916c  _.idata$7:
14002916c                                      8c 80 02 00                                                              ....
140029170  _.idata$7:
140029170                                                  8c 80 02 00                                                      ....
140029174  _.idata$7:
140029174                                                              8c 80 02 00                                              ....
140029178  _.idata$7:
140029178                                                                          8c 80 02 00                                      ....
14002917c  _.idata$7:
14002917c                                                                                      8c 80 02 00                              ....
140029180  _.idata$7:
140029180  61 70 69 2d 6d 73 2d 77 69 6e 2d 63 72 74 2d 70 72 69 76 61 74 65 2d 6c 31 2d 31 2d 30 2e 64 6c  api-ms-win-crt-private-l1-1-0.dl
1400291a0  6c 00 00 00                                                                                      l...
1400291a4  _.idata$7:
1400291a4              a0 80 02 00                                                                              ....
1400291a8  _.idata$7:
1400291a8                          a0 80 02 00                                                                      ....
1400291ac  _.idata$7:
1400291ac                                      a0 80 02 00                                                              ....
1400291b0  _.idata$7:
1400291b0                                                  a0 80 02 00                                                      ....
1400291b4  _.idata$7:
1400291b4                                                              a0 80 02 00                                              ....
1400291b8  _.idata$7:
1400291b8                                                                          a0 80 02 00                                      ....
1400291bc  _.idata$7:
1400291bc                                                                                      a0 80 02 00                              ....
1400291c0  _.idata$7:
1400291c0  a0 80 02 00                                                                                      ....
1400291c4  _.idata$7:
1400291c4              a0 80 02 00                                                                              ....
1400291c8  _.idata$7:
1400291c8                          a0 80 02 00                                                                      ....
1400291cc  _.idata$7:
1400291cc                                      a0 80 02 00                                                              ....
1400291d0  _.idata$7:
1400291d0                                                  a0 80 02 00                                                      ....
1400291d4  _.idata$7:
1400291d4                                                              a0 80 02 00                                              ....
1400291d8  _.idata$7:
1400291d8                                                                          a0 80 02 00                                      ....
1400291dc  _.idata$7:
1400291dc                                                                                      a0 80 02 00                              ....
1400291e0  _.idata$7:
1400291e0  a0 80 02 00                                                                                      ....
1400291e4  _.idata$7:
1400291e4              a0 80 02 00                                                                              ....
1400291e8  _.idata$7:
1400291e8                          a0 80 02 00                                                                      ....
1400291ec  _.idata$7:
1400291ec                                      a0 80 02 00                                                              ....
1400291f0  _.idata$7:
1400291f0                                                  a0 80 02 00                                                      ....
1400291f4  _.idata$7:
1400291f4                                                              a0 80 02 00                                              ....
1400291f8  _.idata$7:
1400291f8                                                                          61 70 69 2d 6d 73 2d 77                          api-ms-w
140029200  69 6e 2d 63 72 74 2d 72 75 6e 74 69 6d 65 2d 6c 31 2d 31 2d 30 2e 64 6c 6c 00 00 00              in-crt-runtime-l1-1-0.dll...
14002921c  _.idata$7:
14002921c                                                                                      b4 80 02 00                              ....
140029220  _.idata$7:
140029220  b4 80 02 00                                                                                      ....
140029224  _.idata$7:
140029224              b4 80 02 00                                                                              ....
140029228  _.idata$7:
140029228                          b4 80 02 00                                                                      ....
14002922c  _.idata$7:
14002922c                                      b4 80 02 00                                                              ....
140029230  _.idata$7:
140029230                                                  b4 80 02 00                                                      ....
140029234  _.idata$7:
140029234                                                              b4 80 02 00                                              ....
140029238  _.idata$7:
140029238                                                                          b4 80 02 00                                      ....
14002923c  _.idata$7:
14002923c                                                                                      b4 80 02 00                              ....
140029240  _.idata$7:
140029240  b4 80 02 00                                                                                      ....
140029244  _.idata$7:
140029244              61 70 69 2d 6d 73 2d 77 69 6e 2d 63 72 74 2d 73 74 64 69 6f 2d 6c 31 2d 31 2d 30 2e      api-ms-win-crt-stdio-l1-1-0.
140029260  64 6c 6c 00                                                                                      dll.
140029264  _.idata$7:
140029264              c8 80 02 00                                                                              ....
140029268  _.idata$7:
140029268                          c8 80 02 00                                                                      ....
14002926c  _.idata$7:
14002926c                                      c8 80 02 00                                                              ....
140029270  _.idata$7:
140029270                                                  c8 80 02 00                                                      ....
140029274  _.idata$7:
140029274                                                              c8 80 02 00                                              ....
140029278  _.idata$7:
140029278                                                                          61 70 69 2d 6d 73 2d 77                          api-ms-w
140029280  69 6e 2d 63 72 74 2d 73 74 72 69 6e 67 2d 6c 31 2d 31 2d 30 2e 64 6c 6c 00 00 00 00              in-crt-string-l1-1-0.dll....
14002929c  _.idata$7:
14002929c                                                                                      dc 80 02 00                              ....
1400292a0  _.idata$7:
1400292a0  dc 80 02 00                                                                                      ....
1400292a4  _.idata$7:
1400292a4              dc 80 02 00                                                                              ....
1400292a8  _.idata$7:
1400292a8                          dc 80 02 00                                                                      ....
1400292ac  _.idata$7:
1400292ac                                      61 70 69 2d 6d 73 2d 77 69 6e 2d 63 72 74 2d 74 69 6d 65 2d              api-ms-win-crt-time-
1400292c0  6c 31 2d 31 2d 30 2e 64 6c 6c 00 00                                                              l1-1-0.dll..
.idata section ended  {0x140028000-0x1400292cc}

.CRT section started  {0x14002a000-0x14002a068}
14002a000  _.CRT$XCA:
14002a000  00 00 00 00 00 00 00 00                                                                          ........

14002a008  void* _.CRT$XCAA = pre_cpp_init

14002a010  _.CRT$XCZ:
14002a010                                                  00 00 00 00 00 00 00 00                                          ........
14002a018  _.CRT$XIA:
14002a018                                                                          00 00 00 00 00 00 00 00                          ........

14002a020  void* _.CRT$XIAA = pre_c_init

14002a028  _.CRT$XIZ:
14002a028                          00 00 00 00 00 00 00 00                                                          ........
14002a030  _.CRT$XLA:
14002a030                                                  00 00 00 00 00 00 00 00                                          ........

14002a038  void* _.CRT$XLC = _TLS_Entry_0
14002a040  void* _.CRT$XLD = _TLS_Entry_1
14002a048  void* _.CRT$XLF = _TLS_Entry_2

14002a050  _.CRT$XLZ:
14002a050                                                  00 00 00 00 00 00 00 00                                          ........
14002a058  _.CRT$XDA:
14002a058                                                                          00 00 00 00 00 00 00 00                          ........
14002a060  _.CRT$XDZ:
14002a060  00 00 00 00 00 00 00 00                                                                          ........
.CRT section ended  {0x14002a000-0x14002a068}

.tls section started  {0x14002b000-0x14002b010}
14002b000  _.tls:
14002b000  00 00 00 00 00 00 00 00                                                                          ........
14002b008  _.tls$ZZZ:
14002b008                          00 00 00 00 00 00 00 00                                                          ........
.tls section ended  {0x14002b000-0x14002b010}

.reloc section started  {0x14002c000-0x14002c154}
14002c000  00 e0 01 00 0c 00 00 00 18 ae 00 00 00 f0 01 00 54 00 00 00 00 a0 18 a0 20 a0 40 a0 58 a0 60 a0  ................T....... .@.X.`.
14002c020  80 a0 98 a0 a0 a0 c0 a0 d8 a0 e0 a0 00 a1 18 a1 20 a1 40 a1 58 a1 60 a1 20 a3 90 a3 a0 a3 b0 a3  ................ .@.X.`. .......
14002c040  c0 a3 c8 a3 d0 a3 d8 a3 e0 a3 e8 a3 f0 a3 f8 a3 00 a4 08 a4 10 a4 20 a4 28 a4 38 a4 40 a4 90 a4  ...................... .(.8.@...
14002c060  00 00 02 00 6c 00 00 00 f8 a2 08 a3 f8 a3 28 a4 48 a4 68 a4 d8 a4 28 a7 58 a7 38 a8 78 a8 a8 a8  ....l.........(.H.h...(.X.8.x...
14002c080  e8 a8 28 a9 88 a9 a8 a9 d8 a9 f8 a9 18 aa 58 aa 78 aa a8 aa b8 aa d8 aa f8 aa 18 ab 48 ab 68 ab  ..(...........X.x...........H.h.
14002c0a0  78 ab 88 ab 98 ab a8 ab f8 ab 18 ac 38 ac 88 ac 28 ad 48 ad 98 ad f8 ad 38 ae 78 ae b8 ae 18 af  x...........8...(.H.....8.x.....
14002c0c0  48 af 88 af 98 af d8 af e8 af 00 00 00 10 02 00 1c 00 00 00 98 a9 c8 a9 f8 a9 08 ab 58 ab 20 ac  H...........................X. .
14002c0e0  40 ac 48 ac 50 ac 58 ac 00 20 02 00 58 00 00 00 80 a4 90 a4 a0 a4 b0 a4 c0 a4 d0 a4 e0 a4 f0 a4  @.H.P.X.. ..X...................
14002c100  00 a5 10 a5 20 a5 30 a5 40 a5 50 a5 60 a5 70 a5 80 a5 90 a5 a0 a5 b0 a5 c0 a5 d0 a5 e0 a5 f0 a5  .... .0.@.P.`.p.................
14002c120  00 a6 10 a6 20 a6 30 a6 40 a6 50 a6 60 a6 70 a6 80 a6 90 a6 a0 a6 b0 a6 c0 a6 d0 a6 e0 a6 f0 a6  .... .0.@.P.`.p.................
14002c140  00 a0 02 00 14 00 00 00 08 a0 20 a0 38 a0 40 a0 48 a0 00 00                                      .......... .8.@.H...
.reloc section ended  {0x14002c000-0x14002c154}

.debug_aranges section started  {0x14002d000-0x14002d080}
14002d000  _.debug_aranges:
14002d000  2c 00 00 00 02 00 00 00 00 00 08 00 00 00 00 00 90 3f 01 40 01 00 00 00 32 00 00 00 00 00 00 00  ,................?.@....2.......
14002d020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
14002d030  _.debug_aranges:
14002d030                                                  1c 00 00 00 02 00 28 00 00 00 08 00 00 00 00 00                  ......(.........
14002d040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................
14002d050  _.debug_aranges:
14002d050                                                  2c 00 00 00 02 00 dd 0f 00 00 08 00 00 00 00 00                  ,...............
14002d060  d0 3f 01 40 01 00 00 00 bd 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .?.@............................
.debug_aranges section ended  {0x14002d000-0x14002d080}

.debug_info section started  {0x14002e000-0x140030a58}
14002e000  _.debug_info:
14002e000  24 00 00 00 05 00 01 08 00 00 00 00 01 00 00 00 00 90 3f 01 40 01 00 00 00 32 00 00 00 00 38 00  $.................?.@....2....8.
14002e020  00 00 97 00 00 00 01 80                                                                          ........
14002e028  _.debug_info:
14002e028                          b1 0f 00 00 05 00 01 08 14 00 00 00 07 47 4e 55 20 43 31 37 20 31 33 2e          .............GNU C17 13.
14002e040  32 2e 30 20 2d 6d 74 75 6e 65 3d 63 6f 72 65 32 20 2d 6d 61 72 63 68 3d 6e 6f 63 6f 6e 61 20 2d  2.0 -mtune=core2 -march=nocona -
14002e060  67 20 2d 67 20 2d 67 20 2d 4f 32 20 2d 4f 32 20 2d 4f 32 20 2d 66 6e 6f 2d 69 64 65 6e 74 20 2d  g -g -g -O2 -O2 -O2 -fno-ident -
14002e080  66 50 49 43 20 2d 66 62 75 69 6c 64 69 6e 67 2d 6c 69 62 67 63 63 20 2d 66 6e 6f 2d 73 74 61 63  fPIC -fbuilding-libgcc -fno-stac
14002e0a0  6b 2d 70 72 6f 74 65 63 74 6f 72 00 1d 97 00 00 00 c4 00 00 00 5c 00 00 00 02 01 06 63 68 61 72  k-protector..........\......char
14002e0c0  00 02 08 07 6c 6f 6e 67 20 6c 6f 6e 67 20 75 6e 73 69 67 6e 65 64 20 69 6e 74 00 02 08 05 6c 6f  ....long long unsigned int....lo
14002e0e0  6e 67 20 6c 6f 6e 67 20 69 6e 74 00 02 02 07 73 68 6f 72 74 20 75 6e 73 69 67 6e 65 64 20 69 6e  ng long int....short unsigned in
14002e100  74 00 02 04 05 69 6e 74 00 02 04 05 6c 6f 6e 67 20 69 6e 74 00 02 04 07 75 6e 73 69 67 6e 65 64  t....int....long int....unsigned
14002e120  20 69 6e 74 00 02 10 04 6c 6f 6e 67 20 64 6f 75 62 6c 65 00 02 01 08 75 6e 73 69 67 6e 65 64 20   int....long double....unsigned 
14002e140  63 68 61 72 00 02 08 04 64 6f 75 62 6c 65 00 02 04 04 66 6c 6f 61 74 00 08 08 36 01 00 00 09 02  char....double....float...6.....
14002e160  04 07 6c 6f 6e 67 20 75 6e 73 69 67 6e 65 64 20 69 6e 74 00 02 02 05 73 68 6f 72 74 20 69 6e 74  ..long unsigned int....short int
14002e180  00 03 69 78 38 36 5f 74 75 6e 65 5f 69 6e 64 69 63 65 73 00 ed 00 00 00 21 01 03 0e 00 00 01 58  ..ix86_tune_indices.....!......X
14002e1a0  38 36 5f 54 55 4e 45 5f 53 43 48 45 44 55 4c 45 00 00 01 58 38 36 5f 54 55 4e 45 5f 50 41 52 54  86_TUNE_SCHEDULE...X86_TUNE_PART
14002e1c0  49 41 4c 5f 52 45 47 5f 44 45 50 45 4e 44 45 4e 43 59 00 01 01 58 38 36 5f 54 55 4e 45 5f 53 53  IAL_REG_DEPENDENCY...X86_TUNE_SS
14002e1e0  45 5f 50 41 52 54 49 41 4c 5f 52 45 47 5f 44 45 50 45 4e 44 45 4e 43 59 00 02 01 58 38 36 5f 54  E_PARTIAL_REG_DEPENDENCY...X86_T
14002e200  55 4e 45 5f 53 53 45 5f 50 41 52 54 49 41 4c 5f 52 45 47 5f 46 50 5f 43 4f 4e 56 45 52 54 53 5f  UNE_SSE_PARTIAL_REG_FP_CONVERTS_
14002e220  44 45 50 45 4e 44 45 4e 43 59 00 03 01 58 38 36 5f 54 55 4e 45 5f 53 53 45 5f 50 41 52 54 49 41  DEPENDENCY...X86_TUNE_SSE_PARTIA
14002e240  4c 5f 52 45 47 5f 43 4f 4e 56 45 52 54 53 5f 44 45 50 45 4e 44 45 4e 43 59 00 04 01 58 38 36 5f  L_REG_CONVERTS_DEPENDENCY...X86_
14002e260  54 55 4e 45 5f 44 45 53 54 5f 46 41 4c 53 45 5f 44 45 50 5f 46 4f 52 5f 47 4c 43 00 05 01 58 38  TUNE_DEST_FALSE_DEP_FOR_GLC...X8
14002e280  36 5f 54 55 4e 45 5f 53 53 45 5f 53 50 4c 49 54 5f 52 45 47 53 00 06 01 58 38 36 5f 54 55 4e 45  6_TUNE_SSE_SPLIT_REGS...X86_TUNE
14002e2a0  5f 50 41 52 54 49 41 4c 5f 46 4c 41 47 5f 52 45 47 5f 53 54 41 4c 4c 00 07 01 58 38 36 5f 54 55  _PARTIAL_FLAG_REG_STALL...X86_TU
14002e2c0  4e 45 5f 4d 4f 56 58 00 08 01 58 38 36 5f 54 55 4e 45 5f 4d 45 4d 4f 52 59 5f 4d 49 53 4d 41 54  NE_MOVX...X86_TUNE_MEMORY_MISMAT
14002e2e0  43 48 5f 53 54 41 4c 4c 00 09 01 58 38 36 5f 54 55 4e 45 5f 46 55 53 45 5f 43 4d 50 5f 41 4e 44  CH_STALL...X86_TUNE_FUSE_CMP_AND
14002e300  5f 42 52 41 4e 43 48 5f 33 32 00 0a 01 58 38 36 5f 54 55 4e 45 5f 46 55 53 45 5f 43 4d 50 5f 41  _BRANCH_32...X86_TUNE_FUSE_CMP_A
14002e320  4e 44 5f 42 52 41 4e 43 48 5f 36 34 00 0b 01 58 38 36 5f 54 55 4e 45 5f 46 55 53 45 5f 43 4d 50  ND_BRANCH_64...X86_TUNE_FUSE_CMP
14002e340  5f 41 4e 44 5f 42 52 41 4e 43 48 5f 53 4f 46 4c 41 47 53 00 0c 01 58 38 36 5f 54 55 4e 45 5f 46  _AND_BRANCH_SOFLAGS...X86_TUNE_F
14002e360  55 53 45 5f 41 4c 55 5f 41 4e 44 5f 42 52 41 4e 43 48 00 0d 01 58 38 36 5f 54 55 4e 45 5f 41 43  USE_ALU_AND_BRANCH...X86_TUNE_AC
14002e380  43 55 4d 55 4c 41 54 45 5f 4f 55 54 47 4f 49 4e 47 5f 41 52 47 53 00 0e 01 58 38 36 5f 54 55 4e  CUMULATE_OUTGOING_ARGS...X86_TUN
14002e3a0  45 5f 50 52 4f 4c 4f 47 55 45 5f 55 53 49 4e 47 5f 4d 4f 56 45 00 0f 01 58 38 36 5f 54 55 4e 45  E_PROLOGUE_USING_MOVE...X86_TUNE
14002e3c0  5f 45 50 49 4c 4f 47 55 45 5f 55 53 49 4e 47 5f 4d 4f 56 45 00 10 01 58 38 36 5f 54 55 4e 45 5f  _EPILOGUE_USING_MOVE...X86_TUNE_
14002e3e0  55 53 45 5f 4c 45 41 56 45 00 11 01 58 38 36 5f 54 55 4e 45 5f 50 55 53 48 5f 4d 45 4d 4f 52 59  USE_LEAVE...X86_TUNE_PUSH_MEMORY
14002e400  00 12 01 58 38 36 5f 54 55 4e 45 5f 53 49 4e 47 4c 45 5f 50 55 53 48 00 13 01 58 38 36 5f 54 55  ...X86_TUNE_SINGLE_PUSH...X86_TU
14002e420  4e 45 5f 44 4f 55 42 4c 45 5f 50 55 53 48 00 14 01 58 38 36 5f 54 55 4e 45 5f 53 49 4e 47 4c 45  NE_DOUBLE_PUSH...X86_TUNE_SINGLE
14002e440  5f 50 4f 50 00 15 01 58 38 36 5f 54 55 4e 45 5f 44 4f 55 42 4c 45 5f 50 4f 50 00 16 01 58 38 36  _POP...X86_TUNE_DOUBLE_POP...X86
14002e460  5f 54 55 4e 45 5f 50 41 44 5f 53 48 4f 52 54 5f 46 55 4e 43 54 49 4f 4e 00 17 01 58 38 36 5f 54  _TUNE_PAD_SHORT_FUNCTION...X86_T
14002e480  55 4e 45 5f 50 41 44 5f 52 45 54 55 52 4e 53 00 18 01 58 38 36 5f 54 55 4e 45 5f 46 4f 55 52 5f  UNE_PAD_RETURNS...X86_TUNE_FOUR_
14002e4a0  4a 55 4d 50 5f 4c 49 4d 49 54 00 19 01 58 38 36 5f 54 55 4e 45 5f 53 4f 46 54 57 41 52 45 5f 50  JUMP_LIMIT...X86_TUNE_SOFTWARE_P
14002e4c0  52 45 46 45 54 43 48 49 4e 47 5f 42 45 4e 45 46 49 43 49 41 4c 00 1a 01 58 38 36 5f 54 55 4e 45  REFETCHING_BENEFICIAL...X86_TUNE
14002e4e0  5f 4c 43 50 5f 53 54 41 4c 4c 00 1b 01 58 38 36 5f 54 55 4e 45 5f 52 45 41 44 5f 4d 4f 44 49 46  _LCP_STALL...X86_TUNE_READ_MODIF
14002e500  59 00 1c 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 49 4e 43 44 45 43 00 1d 01 58 38 36 5f 54 55  Y...X86_TUNE_USE_INCDEC...X86_TU
14002e520  4e 45 5f 49 4e 54 45 47 45 52 5f 44 46 4d 4f 44 45 5f 4d 4f 56 45 53 00 1e 01 58 38 36 5f 54 55  NE_INTEGER_DFMODE_MOVES...X86_TU
14002e540  4e 45 5f 4f 50 54 5f 41 47 55 00 1f 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44 5f 4c 45 41 5f  NE_OPT_AGU...X86_TUNE_AVOID_LEA_
14002e560  46 4f 52 5f 41 44 44 52 00 20 01 58 38 36 5f 54 55 4e 45 5f 53 4c 4f 57 5f 49 4d 55 4c 5f 49 4d  FOR_ADDR. .X86_TUNE_SLOW_IMUL_IM
14002e580  4d 33 32 5f 4d 45 4d 00 21 01 58 38 36 5f 54 55 4e 45 5f 53 4c 4f 57 5f 49 4d 55 4c 5f 49 4d 4d  M32_MEM.!.X86_TUNE_SLOW_IMUL_IMM
14002e5a0  38 00 22 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44 5f 4d 45 4d 5f 4f 50 4e 44 5f 46 4f 52 5f  8.".X86_TUNE_AVOID_MEM_OPND_FOR_
14002e5c0  43 4d 4f 56 45 00 23 01 58 38 36 5f 54 55 4e 45 5f 53 49 4e 47 4c 45 5f 53 54 52 49 4e 47 4f 50  CMOVE.#.X86_TUNE_SINGLE_STRINGOP
14002e5e0  00 24 01 58 38 36 5f 54 55 4e 45 5f 50 52 45 46 45 52 5f 4b 4e 4f 57 4e 5f 52 45 50 5f 4d 4f 56  .$.X86_TUNE_PREFER_KNOWN_REP_MOV
14002e600  53 42 5f 53 54 4f 53 42 00 25 01 58 38 36 5f 54 55 4e 45 5f 4d 49 53 41 4c 49 47 4e 45 44 5f 4d  SB_STOSB.%.X86_TUNE_MISALIGNED_M
14002e620  4f 56 45 5f 53 54 52 49 4e 47 5f 50 52 4f 5f 45 50 49 4c 4f 47 55 45 53 00 26 01 58 38 36 5f 54  OVE_STRING_PRO_EPILOGUES.&.X86_T
14002e640  55 4e 45 5f 55 53 45 5f 53 41 48 46 00 27 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 43 4c 54 44  UNE_USE_SAHF.'.X86_TUNE_USE_CLTD
14002e660  00 28 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 42 54 00 29 01 58 38 36 5f 54 55 4e 45 5f 41 56  .(.X86_TUNE_USE_BT.).X86_TUNE_AV
14002e680  4f 49 44 5f 46 41 4c 53 45 5f 44 45 50 5f 46 4f 52 5f 42 4d 49 00 2a 01 58 38 36 5f 54 55 4e 45  OID_FALSE_DEP_FOR_BMI.*.X86_TUNE
14002e6a0  5f 41 44 4a 55 53 54 5f 55 4e 52 4f 4c 4c 00 2b 01 58 38 36 5f 54 55 4e 45 5f 4f 4e 45 5f 49 46  _ADJUST_UNROLL.+.X86_TUNE_ONE_IF
14002e6c0  5f 43 4f 4e 56 5f 49 4e 53 4e 00 2c 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44 5f 4d 46 45 4e  _CONV_INSN.,.X86_TUNE_AVOID_MFEN
14002e6e0  43 45 00 2d 01 58 38 36 5f 54 55 4e 45 5f 45 58 50 41 4e 44 5f 41 42 53 00 2e 01 58 38 36 5f 54  CE.-.X86_TUNE_EXPAND_ABS...X86_T
14002e700  55 4e 45 5f 55 53 45 5f 48 49 4d 4f 44 45 5f 46 49 4f 50 00 2f 01 58 38 36 5f 54 55 4e 45 5f 55  UNE_USE_HIMODE_FIOP./.X86_TUNE_U
14002e720  53 45 5f 53 49 4d 4f 44 45 5f 46 49 4f 50 00 30 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 46 46  SE_SIMODE_FIOP.0.X86_TUNE_USE_FF
14002e740  52 45 45 50 00 31 01 58 38 36 5f 54 55 4e 45 5f 45 58 54 5f 38 30 33 38 37 5f 43 4f 4e 53 54 41  REEP.1.X86_TUNE_EXT_80387_CONSTA
14002e760  4e 54 53 00 32 01 58 38 36 5f 54 55 4e 45 5f 47 45 4e 45 52 41 4c 5f 52 45 47 53 5f 53 53 45 5f  NTS.2.X86_TUNE_GENERAL_REGS_SSE_
14002e780  53 50 49 4c 4c 00 33 01 58 38 36 5f 54 55 4e 45 5f 53 53 45 5f 55 4e 41 4c 49 47 4e 45 44 5f 4c  SPILL.3.X86_TUNE_SSE_UNALIGNED_L
14002e7a0  4f 41 44 5f 4f 50 54 49 4d 41 4c 00 34 01 58 38 36 5f 54 55 4e 45 5f 53 53 45 5f 55 4e 41 4c 49  OAD_OPTIMAL.4.X86_TUNE_SSE_UNALI
14002e7c0  47 4e 45 44 5f 53 54 4f 52 45 5f 4f 50 54 49 4d 41 4c 00 35 01 58 38 36 5f 54 55 4e 45 5f 53 53  GNED_STORE_OPTIMAL.5.X86_TUNE_SS
14002e7e0  45 5f 50 41 43 4b 45 44 5f 53 49 4e 47 4c 45 5f 49 4e 53 4e 5f 4f 50 54 49 4d 41 4c 00 36 01 58  E_PACKED_SINGLE_INSN_OPTIMAL.6.X
14002e800  38 36 5f 54 55 4e 45 5f 53 53 45 5f 54 59 50 45 4c 45 53 53 5f 53 54 4f 52 45 53 00 37 01 58 38  86_TUNE_SSE_TYPELESS_STORES.7.X8
14002e820  36 5f 54 55 4e 45 5f 53 53 45 5f 4c 4f 41 44 30 5f 42 59 5f 50 58 4f 52 00 38 01 58 38 36 5f 54  6_TUNE_SSE_LOAD0_BY_PXOR.8.X86_T
14002e840  55 4e 45 5f 49 4e 54 45 52 5f 55 4e 49 54 5f 4d 4f 56 45 53 5f 54 4f 5f 56 45 43 00 39 01 58 38  UNE_INTER_UNIT_MOVES_TO_VEC.9.X8
14002e860  36 5f 54 55 4e 45 5f 49 4e 54 45 52 5f 55 4e 49 54 5f 4d 4f 56 45 53 5f 46 52 4f 4d 5f 56 45 43  6_TUNE_INTER_UNIT_MOVES_FROM_VEC
14002e880  00 3a 01 58 38 36 5f 54 55 4e 45 5f 49 4e 54 45 52 5f 55 4e 49 54 5f 43 4f 4e 56 45 52 53 49 4f  .:.X86_TUNE_INTER_UNIT_CONVERSIO
14002e8a0  4e 53 00 3b 01 58 38 36 5f 54 55 4e 45 5f 53 50 4c 49 54 5f 4d 45 4d 5f 4f 50 4e 44 5f 46 4f 52  NS.;.X86_TUNE_SPLIT_MEM_OPND_FOR
14002e8c0  5f 46 50 5f 43 4f 4e 56 45 52 54 53 00 3c 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 56 45 43 54  _FP_CONVERTS.<.X86_TUNE_USE_VECT
14002e8e0  4f 52 5f 46 50 5f 43 4f 4e 56 45 52 54 53 00 3d 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 56 45  OR_FP_CONVERTS.=.X86_TUNE_USE_VE
14002e900  43 54 4f 52 5f 43 4f 4e 56 45 52 54 53 00 3e 01 58 38 36 5f 54 55 4e 45 5f 53 4c 4f 57 5f 50 53  CTOR_CONVERTS.>.X86_TUNE_SLOW_PS
14002e920  48 55 46 42 00 3f 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44 5f 34 42 59 54 45 5f 50 52 45 46  HUFB.?.X86_TUNE_AVOID_4BYTE_PREF
14002e940  49 58 45 53 00 40 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 47 41 54 48 45 52 5f 32 50 41 52 54  IXES.@.X86_TUNE_USE_GATHER_2PART
14002e960  53 00 41 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 53 43 41 54 54 45 52 5f 32 50 41 52 54 53 00  S.A.X86_TUNE_USE_SCATTER_2PARTS.
14002e980  42 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 47 41 54 48 45 52 5f 34 50 41 52 54 53 00 43 01 58  B.X86_TUNE_USE_GATHER_4PARTS.C.X
14002e9a0  38 36 5f 54 55 4e 45 5f 55 53 45 5f 53 43 41 54 54 45 52 5f 34 50 41 52 54 53 00 44 01 58 38 36  86_TUNE_USE_SCATTER_4PARTS.D.X86
14002e9c0  5f 54 55 4e 45 5f 55 53 45 5f 47 41 54 48 45 52 00 45 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f  _TUNE_USE_GATHER.E.X86_TUNE_USE_
14002e9e0  53 43 41 54 54 45 52 00 46 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44 5f 31 32 38 46 4d 41 5f  SCATTER.F.X86_TUNE_AVOID_128FMA_
14002ea00  43 48 41 49 4e 53 00 47 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44 5f 32 35 36 46 4d 41 5f 43  CHAINS.G.X86_TUNE_AVOID_256FMA_C
14002ea20  48 41 49 4e 53 00 48 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44 5f 35 31 32 46 4d 41 5f 43 48  HAINS.H.X86_TUNE_AVOID_512FMA_CH
14002ea40  41 49 4e 53 00 49 01 58 38 36 5f 54 55 4e 45 5f 56 32 44 46 5f 52 45 44 55 43 54 49 4f 4e 5f 50  AINS.I.X86_TUNE_V2DF_REDUCTION_P
14002ea60  52 45 46 45 52 5f 48 41 44 44 50 44 00 4a 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 32 35 36 5f 55  REFER_HADDPD.J.X86_TUNE_AVX256_U
14002ea80  4e 41 4c 49 47 4e 45 44 5f 4c 4f 41 44 5f 4f 50 54 49 4d 41 4c 00 4b 01 58 38 36 5f 54 55 4e 45  NALIGNED_LOAD_OPTIMAL.K.X86_TUNE
14002eaa0  5f 41 56 58 32 35 36 5f 55 4e 41 4c 49 47 4e 45 44 5f 53 54 4f 52 45 5f 4f 50 54 49 4d 41 4c 00  _AVX256_UNALIGNED_STORE_OPTIMAL.
14002eac0  4c 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 32 35 36 5f 53 50 4c 49 54 5f 52 45 47 53 00 4d 01 58  L.X86_TUNE_AVX256_SPLIT_REGS.M.X
14002eae0  38 36 5f 54 55 4e 45 5f 41 56 58 31 32 38 5f 4f 50 54 49 4d 41 4c 00 4e 01 58 38 36 5f 54 55 4e  86_TUNE_AVX128_OPTIMAL.N.X86_TUN
14002eb00  45 5f 41 56 58 32 35 36 5f 4f 50 54 49 4d 41 4c 00 4f 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 35  E_AVX256_OPTIMAL.O.X86_TUNE_AVX5
14002eb20  31 32 5f 53 50 4c 49 54 5f 52 45 47 53 00 50 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 32 35 36 5f  12_SPLIT_REGS.P.X86_TUNE_AVX256_
14002eb40  4d 4f 56 45 5f 42 59 5f 50 49 45 43 45 53 00 51 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 32 35 36  MOVE_BY_PIECES.Q.X86_TUNE_AVX256
14002eb60  5f 53 54 4f 52 45 5f 42 59 5f 50 49 45 43 45 53 00 52 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 35  _STORE_BY_PIECES.R.X86_TUNE_AVX5
14002eb80  31 32 5f 4d 4f 56 45 5f 42 59 5f 50 49 45 43 45 53 00 53 01 58 38 36 5f 54 55 4e 45 5f 41 56 58  12_MOVE_BY_PIECES.S.X86_TUNE_AVX
14002eba0  35 31 32 5f 53 54 4f 52 45 5f 42 59 5f 50 49 45 43 45 53 00 54 01 58 38 36 5f 54 55 4e 45 5f 44  512_STORE_BY_PIECES.T.X86_TUNE_D
14002ebc0  4f 55 42 4c 45 5f 57 49 54 48 5f 41 44 44 00 55 01 58 38 36 5f 54 55 4e 45 5f 41 4c 57 41 59 53  OUBLE_WITH_ADD.U.X86_TUNE_ALWAYS
14002ebe0  5f 46 41 4e 43 59 5f 4d 41 54 48 5f 33 38 37 00 56 01 58 38 36 5f 54 55 4e 45 5f 55 4e 52 4f 4c  _FANCY_MATH_387.V.X86_TUNE_UNROL
14002ec00  4c 5f 53 54 52 4c 45 4e 00 57 01 58 38 36 5f 54 55 4e 45 5f 53 48 49 46 54 31 00 58 01 58 38 36  L_STRLEN.W.X86_TUNE_SHIFT1.X.X86
14002ec20  5f 54 55 4e 45 5f 5a 45 52 4f 5f 45 58 54 45 4e 44 5f 57 49 54 48 5f 41 4e 44 00 59 01 58 38 36  _TUNE_ZERO_EXTEND_WITH_AND.Y.X86
14002ec40  5f 54 55 4e 45 5f 50 52 4f 4d 4f 54 45 5f 48 49 4d 4f 44 45 5f 49 4d 55 4c 00 5a 01 58 38 36 5f  _TUNE_PROMOTE_HIMODE_IMUL.Z.X86_
14002ec60  54 55 4e 45 5f 46 41 53 54 5f 50 52 45 46 49 58 00 5b 01 58 38 36 5f 54 55 4e 45 5f 52 45 41 44  TUNE_FAST_PREFIX.[.X86_TUNE_READ
14002ec80  5f 4d 4f 44 49 46 59 5f 57 52 49 54 45 00 5c 01 58 38 36 5f 54 55 4e 45 5f 4d 4f 56 45 5f 4d 31  _MODIFY_WRITE.\.X86_TUNE_MOVE_M1
14002eca0  5f 56 49 41 5f 4f 52 00 5d 01 58 38 36 5f 54 55 4e 45 5f 4e 4f 54 5f 55 4e 50 41 49 52 41 42 4c  _VIA_OR.].X86_TUNE_NOT_UNPAIRABL
14002ecc0  45 00 5e 01 58 38 36 5f 54 55 4e 45 5f 50 41 52 54 49 41 4c 5f 52 45 47 5f 53 54 41 4c 4c 00 5f  E.^.X86_TUNE_PARTIAL_REG_STALL._
14002ece0  01 58 38 36 5f 54 55 4e 45 5f 50 52 4f 4d 4f 54 45 5f 51 49 4d 4f 44 45 00 60 01 58 38 36 5f 54  .X86_TUNE_PROMOTE_QIMODE.`.X86_T
14002ed00  55 4e 45 5f 50 52 4f 4d 4f 54 45 5f 48 49 5f 52 45 47 53 00 61 01 58 38 36 5f 54 55 4e 45 5f 48  UNE_PROMOTE_HI_REGS.a.X86_TUNE_H
14002ed20  49 4d 4f 44 45 5f 4d 41 54 48 00 62 01 58 38 36 5f 54 55 4e 45 5f 53 50 4c 49 54 5f 4c 4f 4e 47  IMODE_MATH.b.X86_TUNE_SPLIT_LONG
14002ed40  5f 4d 4f 56 45 53 00 63 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 58 43 48 47 42 00 64 01 58 38  _MOVES.c.X86_TUNE_USE_XCHGB.d.X8
14002ed60  36 5f 54 55 4e 45 5f 55 53 45 5f 4d 4f 56 30 00 65 01 58 38 36 5f 54 55 4e 45 5f 4e 4f 54 5f 56  6_TUNE_USE_MOV0.e.X86_TUNE_NOT_V
14002ed80  45 43 54 4f 52 4d 4f 44 45 00 66 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44 5f 56 45 43 54 4f  ECTORMODE.f.X86_TUNE_AVOID_VECTO
14002eda0  52 5f 44 45 43 4f 44 45 00 67 01 58 38 36 5f 54 55 4e 45 5f 42 52 41 4e 43 48 5f 50 52 45 44 49  R_DECODE.g.X86_TUNE_BRANCH_PREDI
14002edc0  43 54 49 4f 4e 5f 48 49 4e 54 53 00 68 01 58 38 36 5f 54 55 4e 45 5f 51 49 4d 4f 44 45 5f 4d 41  CTION_HINTS.h.X86_TUNE_QIMODE_MA
14002ede0  54 48 00 69 01 58 38 36 5f 54 55 4e 45 5f 50 52 4f 4d 4f 54 45 5f 51 49 5f 52 45 47 53 00 6a 01  TH.i.X86_TUNE_PROMOTE_QI_REGS.j.
14002ee00  58 38 36 5f 54 55 4e 45 5f 45 4d 49 54 5f 56 5a 45 52 4f 55 50 50 45 52 00 6b 01 58 38 36 5f 54  X86_TUNE_EMIT_VZEROUPPER.k.X86_T
14002ee20  55 4e 45 5f 4c 41 53 54 00 6c 00 03 69 78 38 36 5f 61 72 63 68 5f 69 6e 64 69 63 65 73 00 ed 00  UNE_LAST.l..ix86_arch_indices...
14002ee40  00 00 c5 01 8a 0e 00 00 01 58 38 36 5f 41 52 43 48 5f 43 4d 4f 56 00 00 01 58 38 36 5f 41 52 43  .........X86_ARCH_CMOV...X86_ARC
14002ee60  48 5f 43 4d 50 58 43 48 47 00 01 01 58 38 36 5f 41 52 43 48 5f 43 4d 50 58 43 48 47 38 42 00 02  H_CMPXCHG...X86_ARCH_CMPXCHG8B..
14002ee80  01 58 38 36 5f 41 52 43 48 5f 58 41 44 44 00 03 01 58 38 36 5f 41 52 43 48 5f 42 53 57 41 50 00  .X86_ARCH_XADD...X86_ARCH_BSWAP.
14002eea0  04 01 58 38 36 5f 41 52 43 48 5f 4c 41 53 54 00 05 00 02 01 06 73 69 67 6e 65 64 20 63 68 61 72  ..X86_ARCH_LAST......signed char
14002eec0  00 02 10 05 5f 5f 69 6e 74 31 32 38 00 02 10 07 5f 5f 69 6e 74 31 32 38 20 75 6e 73 69 67 6e 65  ....__int128....__int128 unsigne
14002eee0  64 00 02 02 04 5f 46 6c 6f 61 74 31 36 00 02 04 03 63 6f 6d 70 6c 65 78 20 5f 46 6c 6f 61 74 31  d...._Float16....complex _Float1
14002ef00  36 00 02 08 03 63 6f 6d 70 6c 65 78 20 66 6c 6f 61 74 00 02 10 03 63 6f 6d 70 6c 65 78 20 64 6f  6....complex float....complex do
14002ef20  75 62 6c 65 00 02 20 03 63 6f 6d 70 6c 65 78 20 6c 6f 6e 67 20 64 6f 75 62 6c 65 00 02 10 04 5f  uble.. .complex long double...._
14002ef40  46 6c 6f 61 74 31 32 38 00 02 20 03 63 6f 6d 70 6c 65 78 20 5f 46 6c 6f 61 74 31 32 38 00 0a 66  Float128.. .complex _Float128..f
14002ef60  75 6e 63 5f 70 74 72 00 02 2a 10 30 01 00 00 04 36 0f 00 00 52 0f 00 00 0b 00 05 5f 5f 43 54 4f  unc_ptr..*.0....6...R......__CTO
14002ef80  52 5f 4c 49 53 54 5f 5f 00 2f 47 0f 00 00 05 5f 5f 44 54 4f 52 5f 4c 49 53 54 5f 5f 00 30 47 0f  R_LIST__./G....__DTOR_LIST__.0G.
14002efa0  00 00 04 36 0f 00 00 8a 0f 00 00 0c 99 00 00 00 01 00 06 52 0f 00 00 94 09 7a 0f 00 00 09 03 c0  ...6...............R.....z......
14002efc0  72 02 40 01 00 00 00 06 66 0f 00 00 95 09 7a 0f 00 00 09 03 b0 72 02 40 01 00 00 00 00           r.@.....f.....z......r.@.....
14002efdd  _.debug_info:
14002efdd                                                                                         77 1a 00                               w..
14002efe0  00 05 00 01 08 af 00 00 00 21 47 4e 55 20 43 31 37 20 31 33 2e 32 2e 30 20 2d 6d 74 75 6e 65 3d  .........!GNU C17 13.2.0 -mtune=
14002f000  63 6f 72 65 32 20 2d 6d 61 72 63 68 3d 6e 6f 63 6f 6e 61 20 2d 67 20 2d 67 20 2d 67 20 2d 4f 32  core2 -march=nocona -g -g -g -O2
14002f020  20 2d 4f 32 20 2d 4f 32 20 2d 66 6e 6f 2d 69 64 65 6e 74 20 2d 66 50 49 43 20 2d 66 62 75 69 6c   -O2 -O2 -fno-ident -fPIC -fbuil
14002f040  64 69 6e 67 2d 6c 69 62 67 63 63 20 2d 66 6e 6f 2d 73 74 61 63 6b 2d 70 72 6f 74 65 63 74 6f 72  ding-libgcc -fno-stack-protector
14002f060  20 2d 66 65 78 63 65 70 74 69 6f 6e 73 00 1d f8 01 00 00 24 02 00 00 d0 3f 01 40 01 00 00 00 bd   -fexceptions......$....?.@.....
14002f080  02 00 00 00 00 00 00 a4 00 00 00 04 01 06 63 68 61 72 00 07 73 69 7a 65 5f 74 00 03 23 2c c5 00  ..............char..size_t..#,..
14002f0a0  00 00 04 08 07 6c 6f 6e 67 20 6c 6f 6e 67 20 75 6e 73 69 67 6e 65 64 20 69 6e 74 00 04 08 05 6c  .....long long unsigned int....l
14002f0c0  6f 6e 67 20 6c 6f 6e 67 20 69 6e 74 00 07 69 6e 74 70 74 72 5f 74 00 03 3e 23 df 00 00 00 04 02  ong long int..intptr_t..>#......
14002f0e0  07 73 68 6f 72 74 20 75 6e 73 69 67 6e 65 64 20 69 6e 74 00 04 04 05 69 6e 74 00 04 04 05 6c 6f  .short unsigned int....int....lo
14002f100  6e 67 20 69 6e 74 00 04 04 07 75 6e 73 69 67 6e 65 64 20 69 6e 74 00 04 10 04 6c 6f 6e 67 20 64  ng int....unsigned int....long d
14002f120  6f 75 62 6c 65 00 22 08 04 01 08 75 6e 73 69 67 6e 65 64 20 63 68 61 72 00 04 08 04 64 6f 75 62  ouble."....unsigned char....doub
14002f140  6c 65 00 04 04 04 66 6c 6f 61 74 00 05 74 01 00 00 23 04 04 07 6c 6f 6e 67 20 75 6e 73 69 67 6e  le....float..t...#...long unsign
14002f160  65 64 20 69 6e 74 00 05 8f 01 00 00 24 9a 01 00 00 02 49 01 00 00 00 04 02 05 73 68 6f 72 74 20  ed int......$.....I.......short 
14002f180  69 6e 74 00 05 ac 01 00 00 25 05 49 01 00 00 15 69 78 38 36 5f 74 75 6e 65 5f 69 6e 64 69 63 65  int......%.I....ix86_tune_indice
14002f1a0  73 00 2a 01 00 00 21 01 5c 0e 00 00 01 58 38 36 5f 54 55 4e 45 5f 53 43 48 45 44 55 4c 45 00 00  s.*...!.\....X86_TUNE_SCHEDULE..
14002f1c0  01 58 38 36 5f 54 55 4e 45 5f 50 41 52 54 49 41 4c 5f 52 45 47 5f 44 45 50 45 4e 44 45 4e 43 59  .X86_TUNE_PARTIAL_REG_DEPENDENCY
14002f1e0  00 01 01 58 38 36 5f 54 55 4e 45 5f 53 53 45 5f 50 41 52 54 49 41 4c 5f 52 45 47 5f 44 45 50 45  ...X86_TUNE_SSE_PARTIAL_REG_DEPE
14002f200  4e 44 45 4e 43 59 00 02 01 58 38 36 5f 54 55 4e 45 5f 53 53 45 5f 50 41 52 54 49 41 4c 5f 52 45  NDENCY...X86_TUNE_SSE_PARTIAL_RE
14002f220  47 5f 46 50 5f 43 4f 4e 56 45 52 54 53 5f 44 45 50 45 4e 44 45 4e 43 59 00 03 01 58 38 36 5f 54  G_FP_CONVERTS_DEPENDENCY...X86_T
14002f240  55 4e 45 5f 53 53 45 5f 50 41 52 54 49 41 4c 5f 52 45 47 5f 43 4f 4e 56 45 52 54 53 5f 44 45 50  UNE_SSE_PARTIAL_REG_CONVERTS_DEP
14002f260  45 4e 44 45 4e 43 59 00 04 01 58 38 36 5f 54 55 4e 45 5f 44 45 53 54 5f 46 41 4c 53 45 5f 44 45  ENDENCY...X86_TUNE_DEST_FALSE_DE
14002f280  50 5f 46 4f 52 5f 47 4c 43 00 05 01 58 38 36 5f 54 55 4e 45 5f 53 53 45 5f 53 50 4c 49 54 5f 52  P_FOR_GLC...X86_TUNE_SSE_SPLIT_R
14002f2a0  45 47 53 00 06 01 58 38 36 5f 54 55 4e 45 5f 50 41 52 54 49 41 4c 5f 46 4c 41 47 5f 52 45 47 5f  EGS...X86_TUNE_PARTIAL_FLAG_REG_
14002f2c0  53 54 41 4c 4c 00 07 01 58 38 36 5f 54 55 4e 45 5f 4d 4f 56 58 00 08 01 58 38 36 5f 54 55 4e 45  STALL...X86_TUNE_MOVX...X86_TUNE
14002f2e0  5f 4d 45 4d 4f 52 59 5f 4d 49 53 4d 41 54 43 48 5f 53 54 41 4c 4c 00 09 01 58 38 36 5f 54 55 4e  _MEMORY_MISMATCH_STALL...X86_TUN
14002f300  45 5f 46 55 53 45 5f 43 4d 50 5f 41 4e 44 5f 42 52 41 4e 43 48 5f 33 32 00 0a 01 58 38 36 5f 54  E_FUSE_CMP_AND_BRANCH_32...X86_T
14002f320  55 4e 45 5f 46 55 53 45 5f 43 4d 50 5f 41 4e 44 5f 42 52 41 4e 43 48 5f 36 34 00 0b 01 58 38 36  UNE_FUSE_CMP_AND_BRANCH_64...X86
14002f340  5f 54 55 4e 45 5f 46 55 53 45 5f 43 4d 50 5f 41 4e 44 5f 42 52 41 4e 43 48 5f 53 4f 46 4c 41 47  _TUNE_FUSE_CMP_AND_BRANCH_SOFLAG
14002f360  53 00 0c 01 58 38 36 5f 54 55 4e 45 5f 46 55 53 45 5f 41 4c 55 5f 41 4e 44 5f 42 52 41 4e 43 48  S...X86_TUNE_FUSE_ALU_AND_BRANCH
14002f380  00 0d 01 58 38 36 5f 54 55 4e 45 5f 41 43 43 55 4d 55 4c 41 54 45 5f 4f 55 54 47 4f 49 4e 47 5f  ...X86_TUNE_ACCUMULATE_OUTGOING_
14002f3a0  41 52 47 53 00 0e 01 58 38 36 5f 54 55 4e 45 5f 50 52 4f 4c 4f 47 55 45 5f 55 53 49 4e 47 5f 4d  ARGS...X86_TUNE_PROLOGUE_USING_M
14002f3c0  4f 56 45 00 0f 01 58 38 36 5f 54 55 4e 45 5f 45 50 49 4c 4f 47 55 45 5f 55 53 49 4e 47 5f 4d 4f  OVE...X86_TUNE_EPILOGUE_USING_MO
14002f3e0  56 45 00 10 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 4c 45 41 56 45 00 11 01 58 38 36 5f 54 55  VE...X86_TUNE_USE_LEAVE...X86_TU
14002f400  4e 45 5f 50 55 53 48 5f 4d 45 4d 4f 52 59 00 12 01 58 38 36 5f 54 55 4e 45 5f 53 49 4e 47 4c 45  NE_PUSH_MEMORY...X86_TUNE_SINGLE
14002f420  5f 50 55 53 48 00 13 01 58 38 36 5f 54 55 4e 45 5f 44 4f 55 42 4c 45 5f 50 55 53 48 00 14 01 58  _PUSH...X86_TUNE_DOUBLE_PUSH...X
14002f440  38 36 5f 54 55 4e 45 5f 53 49 4e 47 4c 45 5f 50 4f 50 00 15 01 58 38 36 5f 54 55 4e 45 5f 44 4f  86_TUNE_SINGLE_POP...X86_TUNE_DO
14002f460  55 42 4c 45 5f 50 4f 50 00 16 01 58 38 36 5f 54 55 4e 45 5f 50 41 44 5f 53 48 4f 52 54 5f 46 55  UBLE_POP...X86_TUNE_PAD_SHORT_FU
14002f480  4e 43 54 49 4f 4e 00 17 01 58 38 36 5f 54 55 4e 45 5f 50 41 44 5f 52 45 54 55 52 4e 53 00 18 01  NCTION...X86_TUNE_PAD_RETURNS...
14002f4a0  58 38 36 5f 54 55 4e 45 5f 46 4f 55 52 5f 4a 55 4d 50 5f 4c 49 4d 49 54 00 19 01 58 38 36 5f 54  X86_TUNE_FOUR_JUMP_LIMIT...X86_T
14002f4c0  55 4e 45 5f 53 4f 46 54 57 41 52 45 5f 50 52 45 46 45 54 43 48 49 4e 47 5f 42 45 4e 45 46 49 43  UNE_SOFTWARE_PREFETCHING_BENEFIC
14002f4e0  49 41 4c 00 1a 01 58 38 36 5f 54 55 4e 45 5f 4c 43 50 5f 53 54 41 4c 4c 00 1b 01 58 38 36 5f 54  IAL...X86_TUNE_LCP_STALL...X86_T
14002f500  55 4e 45 5f 52 45 41 44 5f 4d 4f 44 49 46 59 00 1c 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 49  UNE_READ_MODIFY...X86_TUNE_USE_I
14002f520  4e 43 44 45 43 00 1d 01 58 38 36 5f 54 55 4e 45 5f 49 4e 54 45 47 45 52 5f 44 46 4d 4f 44 45 5f  NCDEC...X86_TUNE_INTEGER_DFMODE_
14002f540  4d 4f 56 45 53 00 1e 01 58 38 36 5f 54 55 4e 45 5f 4f 50 54 5f 41 47 55 00 1f 01 58 38 36 5f 54  MOVES...X86_TUNE_OPT_AGU...X86_T
14002f560  55 4e 45 5f 41 56 4f 49 44 5f 4c 45 41 5f 46 4f 52 5f 41 44 44 52 00 20 01 58 38 36 5f 54 55 4e  UNE_AVOID_LEA_FOR_ADDR. .X86_TUN
14002f580  45 5f 53 4c 4f 57 5f 49 4d 55 4c 5f 49 4d 4d 33 32 5f 4d 45 4d 00 21 01 58 38 36 5f 54 55 4e 45  E_SLOW_IMUL_IMM32_MEM.!.X86_TUNE
14002f5a0  5f 53 4c 4f 57 5f 49 4d 55 4c 5f 49 4d 4d 38 00 22 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44  _SLOW_IMUL_IMM8.".X86_TUNE_AVOID
14002f5c0  5f 4d 45 4d 5f 4f 50 4e 44 5f 46 4f 52 5f 43 4d 4f 56 45 00 23 01 58 38 36 5f 54 55 4e 45 5f 53  _MEM_OPND_FOR_CMOVE.#.X86_TUNE_S
14002f5e0  49 4e 47 4c 45 5f 53 54 52 49 4e 47 4f 50 00 24 01 58 38 36 5f 54 55 4e 45 5f 50 52 45 46 45 52  INGLE_STRINGOP.$.X86_TUNE_PREFER
14002f600  5f 4b 4e 4f 57 4e 5f 52 45 50 5f 4d 4f 56 53 42 5f 53 54 4f 53 42 00 25 01 58 38 36 5f 54 55 4e  _KNOWN_REP_MOVSB_STOSB.%.X86_TUN
14002f620  45 5f 4d 49 53 41 4c 49 47 4e 45 44 5f 4d 4f 56 45 5f 53 54 52 49 4e 47 5f 50 52 4f 5f 45 50 49  E_MISALIGNED_MOVE_STRING_PRO_EPI
14002f640  4c 4f 47 55 45 53 00 26 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 53 41 48 46 00 27 01 58 38 36  LOGUES.&.X86_TUNE_USE_SAHF.'.X86
14002f660  5f 54 55 4e 45 5f 55 53 45 5f 43 4c 54 44 00 28 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 42 54  _TUNE_USE_CLTD.(.X86_TUNE_USE_BT
14002f680  00 29 01 58 38 36 5f 54 55 4e 45 5f 41 56 4f 49 44 5f 46 41 4c 53 45 5f 44 45 50 5f 46 4f 52 5f  .).X86_TUNE_AVOID_FALSE_DEP_FOR_
14002f6a0  42 4d 49 00 2a 01 58 38 36 5f 54 55 4e 45 5f 41 44 4a 55 53 54 5f 55 4e 52 4f 4c 4c 00 2b 01 58  BMI.*.X86_TUNE_ADJUST_UNROLL.+.X
14002f6c0  38 36 5f 54 55 4e 45 5f 4f 4e 45 5f 49 46 5f 43 4f 4e 56 5f 49 4e 53 4e 00 2c 01 58 38 36 5f 54  86_TUNE_ONE_IF_CONV_INSN.,.X86_T
14002f6e0  55 4e 45 5f 41 56 4f 49 44 5f 4d 46 45 4e 43 45 00 2d 01 58 38 36 5f 54 55 4e 45 5f 45 58 50 41  UNE_AVOID_MFENCE.-.X86_TUNE_EXPA
14002f700  4e 44 5f 41 42 53 00 2e 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 48 49 4d 4f 44 45 5f 46 49 4f  ND_ABS...X86_TUNE_USE_HIMODE_FIO
14002f720  50 00 2f 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 53 49 4d 4f 44 45 5f 46 49 4f 50 00 30 01 58  P./.X86_TUNE_USE_SIMODE_FIOP.0.X
14002f740  38 36 5f 54 55 4e 45 5f 55 53 45 5f 46 46 52 45 45 50 00 31 01 58 38 36 5f 54 55 4e 45 5f 45 58  86_TUNE_USE_FFREEP.1.X86_TUNE_EX
14002f760  54 5f 38 30 33 38 37 5f 43 4f 4e 53 54 41 4e 54 53 00 32 01 58 38 36 5f 54 55 4e 45 5f 47 45 4e  T_80387_CONSTANTS.2.X86_TUNE_GEN
14002f780  45 52 41 4c 5f 52 45 47 53 5f 53 53 45 5f 53 50 49 4c 4c 00 33 01 58 38 36 5f 54 55 4e 45 5f 53  ERAL_REGS_SSE_SPILL.3.X86_TUNE_S
14002f7a0  53 45 5f 55 4e 41 4c 49 47 4e 45 44 5f 4c 4f 41 44 5f 4f 50 54 49 4d 41 4c 00 34 01 58 38 36 5f  SE_UNALIGNED_LOAD_OPTIMAL.4.X86_
14002f7c0  54 55 4e 45 5f 53 53 45 5f 55 4e 41 4c 49 47 4e 45 44 5f 53 54 4f 52 45 5f 4f 50 54 49 4d 41 4c  TUNE_SSE_UNALIGNED_STORE_OPTIMAL
14002f7e0  00 35 01 58 38 36 5f 54 55 4e 45 5f 53 53 45 5f 50 41 43 4b 45 44 5f 53 49 4e 47 4c 45 5f 49 4e  .5.X86_TUNE_SSE_PACKED_SINGLE_IN
14002f800  53 4e 5f 4f 50 54 49 4d 41 4c 00 36 01 58 38 36 5f 54 55 4e 45 5f 53 53 45 5f 54 59 50 45 4c 45  SN_OPTIMAL.6.X86_TUNE_SSE_TYPELE
14002f820  53 53 5f 53 54 4f 52 45 53 00 37 01 58 38 36 5f 54 55 4e 45 5f 53 53 45 5f 4c 4f 41 44 30 5f 42  SS_STORES.7.X86_TUNE_SSE_LOAD0_B
14002f840  59 5f 50 58 4f 52 00 38 01 58 38 36 5f 54 55 4e 45 5f 49 4e 54 45 52 5f 55 4e 49 54 5f 4d 4f 56  Y_PXOR.8.X86_TUNE_INTER_UNIT_MOV
14002f860  45 53 5f 54 4f 5f 56 45 43 00 39 01 58 38 36 5f 54 55 4e 45 5f 49 4e 54 45 52 5f 55 4e 49 54 5f  ES_TO_VEC.9.X86_TUNE_INTER_UNIT_
14002f880  4d 4f 56 45 53 5f 46 52 4f 4d 5f 56 45 43 00 3a 01 58 38 36 5f 54 55 4e 45 5f 49 4e 54 45 52 5f  MOVES_FROM_VEC.:.X86_TUNE_INTER_
14002f8a0  55 4e 49 54 5f 43 4f 4e 56 45 52 53 49 4f 4e 53 00 3b 01 58 38 36 5f 54 55 4e 45 5f 53 50 4c 49  UNIT_CONVERSIONS.;.X86_TUNE_SPLI
14002f8c0  54 5f 4d 45 4d 5f 4f 50 4e 44 5f 46 4f 52 5f 46 50 5f 43 4f 4e 56 45 52 54 53 00 3c 01 58 38 36  T_MEM_OPND_FOR_FP_CONVERTS.<.X86
14002f8e0  5f 54 55 4e 45 5f 55 53 45 5f 56 45 43 54 4f 52 5f 46 50 5f 43 4f 4e 56 45 52 54 53 00 3d 01 58  _TUNE_USE_VECTOR_FP_CONVERTS.=.X
14002f900  38 36 5f 54 55 4e 45 5f 55 53 45 5f 56 45 43 54 4f 52 5f 43 4f 4e 56 45 52 54 53 00 3e 01 58 38  86_TUNE_USE_VECTOR_CONVERTS.>.X8
14002f920  36 5f 54 55 4e 45 5f 53 4c 4f 57 5f 50 53 48 55 46 42 00 3f 01 58 38 36 5f 54 55 4e 45 5f 41 56  6_TUNE_SLOW_PSHUFB.?.X86_TUNE_AV
14002f940  4f 49 44 5f 34 42 59 54 45 5f 50 52 45 46 49 58 45 53 00 40 01 58 38 36 5f 54 55 4e 45 5f 55 53  OID_4BYTE_PREFIXES.@.X86_TUNE_US
14002f960  45 5f 47 41 54 48 45 52 5f 32 50 41 52 54 53 00 41 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 53  E_GATHER_2PARTS.A.X86_TUNE_USE_S
14002f980  43 41 54 54 45 52 5f 32 50 41 52 54 53 00 42 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 47 41 54  CATTER_2PARTS.B.X86_TUNE_USE_GAT
14002f9a0  48 45 52 5f 34 50 41 52 54 53 00 43 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 53 43 41 54 54 45  HER_4PARTS.C.X86_TUNE_USE_SCATTE
14002f9c0  52 5f 34 50 41 52 54 53 00 44 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 47 41 54 48 45 52 00 45  R_4PARTS.D.X86_TUNE_USE_GATHER.E
14002f9e0  01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 53 43 41 54 54 45 52 00 46 01 58 38 36 5f 54 55 4e 45  .X86_TUNE_USE_SCATTER.F.X86_TUNE
14002fa00  5f 41 56 4f 49 44 5f 31 32 38 46 4d 41 5f 43 48 41 49 4e 53 00 47 01 58 38 36 5f 54 55 4e 45 5f  _AVOID_128FMA_CHAINS.G.X86_TUNE_
14002fa20  41 56 4f 49 44 5f 32 35 36 46 4d 41 5f 43 48 41 49 4e 53 00 48 01 58 38 36 5f 54 55 4e 45 5f 41  AVOID_256FMA_CHAINS.H.X86_TUNE_A
14002fa40  56 4f 49 44 5f 35 31 32 46 4d 41 5f 43 48 41 49 4e 53 00 49 01 58 38 36 5f 54 55 4e 45 5f 56 32  VOID_512FMA_CHAINS.I.X86_TUNE_V2
14002fa60  44 46 5f 52 45 44 55 43 54 49 4f 4e 5f 50 52 45 46 45 52 5f 48 41 44 44 50 44 00 4a 01 58 38 36  DF_REDUCTION_PREFER_HADDPD.J.X86
14002fa80  5f 54 55 4e 45 5f 41 56 58 32 35 36 5f 55 4e 41 4c 49 47 4e 45 44 5f 4c 4f 41 44 5f 4f 50 54 49  _TUNE_AVX256_UNALIGNED_LOAD_OPTI
14002faa0  4d 41 4c 00 4b 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 32 35 36 5f 55 4e 41 4c 49 47 4e 45 44 5f  MAL.K.X86_TUNE_AVX256_UNALIGNED_
14002fac0  53 54 4f 52 45 5f 4f 50 54 49 4d 41 4c 00 4c 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 32 35 36 5f  STORE_OPTIMAL.L.X86_TUNE_AVX256_
14002fae0  53 50 4c 49 54 5f 52 45 47 53 00 4d 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 31 32 38 5f 4f 50 54  SPLIT_REGS.M.X86_TUNE_AVX128_OPT
14002fb00  49 4d 41 4c 00 4e 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 32 35 36 5f 4f 50 54 49 4d 41 4c 00 4f  IMAL.N.X86_TUNE_AVX256_OPTIMAL.O
14002fb20  01 58 38 36 5f 54 55 4e 45 5f 41 56 58 35 31 32 5f 53 50 4c 49 54 5f 52 45 47 53 00 50 01 58 38  .X86_TUNE_AVX512_SPLIT_REGS.P.X8
14002fb40  36 5f 54 55 4e 45 5f 41 56 58 32 35 36 5f 4d 4f 56 45 5f 42 59 5f 50 49 45 43 45 53 00 51 01 58  6_TUNE_AVX256_MOVE_BY_PIECES.Q.X
14002fb60  38 36 5f 54 55 4e 45 5f 41 56 58 32 35 36 5f 53 54 4f 52 45 5f 42 59 5f 50 49 45 43 45 53 00 52  86_TUNE_AVX256_STORE_BY_PIECES.R
14002fb80  01 58 38 36 5f 54 55 4e 45 5f 41 56 58 35 31 32 5f 4d 4f 56 45 5f 42 59 5f 50 49 45 43 45 53 00  .X86_TUNE_AVX512_MOVE_BY_PIECES.
14002fba0  53 01 58 38 36 5f 54 55 4e 45 5f 41 56 58 35 31 32 5f 53 54 4f 52 45 5f 42 59 5f 50 49 45 43 45  S.X86_TUNE_AVX512_STORE_BY_PIECE
14002fbc0  53 00 54 01 58 38 36 5f 54 55 4e 45 5f 44 4f 55 42 4c 45 5f 57 49 54 48 5f 41 44 44 00 55 01 58  S.T.X86_TUNE_DOUBLE_WITH_ADD.U.X
14002fbe0  38 36 5f 54 55 4e 45 5f 41 4c 57 41 59 53 5f 46 41 4e 43 59 5f 4d 41 54 48 5f 33 38 37 00 56 01  86_TUNE_ALWAYS_FANCY_MATH_387.V.
14002fc00  58 38 36 5f 54 55 4e 45 5f 55 4e 52 4f 4c 4c 5f 53 54 52 4c 45 4e 00 57 01 58 38 36 5f 54 55 4e  X86_TUNE_UNROLL_STRLEN.W.X86_TUN
14002fc20  45 5f 53 48 49 46 54 31 00 58 01 58 38 36 5f 54 55 4e 45 5f 5a 45 52 4f 5f 45 58 54 45 4e 44 5f  E_SHIFT1.X.X86_TUNE_ZERO_EXTEND_
14002fc40  57 49 54 48 5f 41 4e 44 00 59 01 58 38 36 5f 54 55 4e 45 5f 50 52 4f 4d 4f 54 45 5f 48 49 4d 4f  WITH_AND.Y.X86_TUNE_PROMOTE_HIMO
14002fc60  44 45 5f 49 4d 55 4c 00 5a 01 58 38 36 5f 54 55 4e 45 5f 46 41 53 54 5f 50 52 45 46 49 58 00 5b  DE_IMUL.Z.X86_TUNE_FAST_PREFIX.[
14002fc80  01 58 38 36 5f 54 55 4e 45 5f 52 45 41 44 5f 4d 4f 44 49 46 59 5f 57 52 49 54 45 00 5c 01 58 38  .X86_TUNE_READ_MODIFY_WRITE.\.X8
14002fca0  36 5f 54 55 4e 45 5f 4d 4f 56 45 5f 4d 31 5f 56 49 41 5f 4f 52 00 5d 01 58 38 36 5f 54 55 4e 45  6_TUNE_MOVE_M1_VIA_OR.].X86_TUNE
14002fcc0  5f 4e 4f 54 5f 55 4e 50 41 49 52 41 42 4c 45 00 5e 01 58 38 36 5f 54 55 4e 45 5f 50 41 52 54 49  _NOT_UNPAIRABLE.^.X86_TUNE_PARTI
14002fce0  41 4c 5f 52 45 47 5f 53 54 41 4c 4c 00 5f 01 58 38 36 5f 54 55 4e 45 5f 50 52 4f 4d 4f 54 45 5f  AL_REG_STALL._.X86_TUNE_PROMOTE_
14002fd00  51 49 4d 4f 44 45 00 60 01 58 38 36 5f 54 55 4e 45 5f 50 52 4f 4d 4f 54 45 5f 48 49 5f 52 45 47  QIMODE.`.X86_TUNE_PROMOTE_HI_REG
14002fd20  53 00 61 01 58 38 36 5f 54 55 4e 45 5f 48 49 4d 4f 44 45 5f 4d 41 54 48 00 62 01 58 38 36 5f 54  S.a.X86_TUNE_HIMODE_MATH.b.X86_T
14002fd40  55 4e 45 5f 53 50 4c 49 54 5f 4c 4f 4e 47 5f 4d 4f 56 45 53 00 63 01 58 38 36 5f 54 55 4e 45 5f  UNE_SPLIT_LONG_MOVES.c.X86_TUNE_
14002fd60  55 53 45 5f 58 43 48 47 42 00 64 01 58 38 36 5f 54 55 4e 45 5f 55 53 45 5f 4d 4f 56 30 00 65 01  USE_XCHGB.d.X86_TUNE_USE_MOV0.e.
14002fd80  58 38 36 5f 54 55 4e 45 5f 4e 4f 54 5f 56 45 43 54 4f 52 4d 4f 44 45 00 66 01 58 38 36 5f 54 55  X86_TUNE_NOT_VECTORMODE.f.X86_TU
14002fda0  4e 45 5f 41 56 4f 49 44 5f 56 45 43 54 4f 52 5f 44 45 43 4f 44 45 00 67 01 58 38 36 5f 54 55 4e  NE_AVOID_VECTOR_DECODE.g.X86_TUN
14002fdc0  45 5f 42 52 41 4e 43 48 5f 50 52 45 44 49 43 54 49 4f 4e 5f 48 49 4e 54 53 00 68 01 58 38 36 5f  E_BRANCH_PREDICTION_HINTS.h.X86_
14002fde0  54 55 4e 45 5f 51 49 4d 4f 44 45 5f 4d 41 54 48 00 69 01 58 38 36 5f 54 55 4e 45 5f 50 52 4f 4d  TUNE_QIMODE_MATH.i.X86_TUNE_PROM
14002fe00  4f 54 45 5f 51 49 5f 52 45 47 53 00 6a 01 58 38 36 5f 54 55 4e 45 5f 45 4d 49 54 5f 56 5a 45 52  OTE_QI_REGS.j.X86_TUNE_EMIT_VZER
14002fe20  4f 55 50 50 45 52 00 6b 01 58 38 36 5f 54 55 4e 45 5f 4c 41 53 54 00 6c 00 15 69 78 38 36 5f 61  OUPPER.k.X86_TUNE_LAST.l..ix86_a
14002fe40  72 63 68 5f 69 6e 64 69 63 65 73 00 2a 01 00 00 c5 01 e3 0e 00 00 01 58 38 36 5f 41 52 43 48 5f  rch_indices.*..........X86_ARCH_
14002fe60  43 4d 4f 56 00 00 01 58 38 36 5f 41 52 43 48 5f 43 4d 50 58 43 48 47 00 01 01 58 38 36 5f 41 52  CMOV...X86_ARCH_CMPXCHG...X86_AR
14002fe80  43 48 5f 43 4d 50 58 43 48 47 38 42 00 02 01 58 38 36 5f 41 52 43 48 5f 58 41 44 44 00 03 01 58  CH_CMPXCHG8B...X86_ARCH_XADD...X
14002fea0  38 36 5f 41 52 43 48 5f 42 53 57 41 50 00 04 01 58 38 36 5f 41 52 43 48 5f 4c 41 53 54 00 05 00  86_ARCH_BSWAP...X86_ARCH_LAST...
14002fec0  07 70 74 68 72 65 61 64 5f 6f 6e 63 65 5f 74 00 05 b9 0e 1e 01 00 00 07 70 74 68 72 65 61 64 5f  .pthread_once_t.........pthread_
14002fee0  6d 75 74 65 78 61 74 74 72 5f 74 00 05 ba 12 2a 01 00 00 26 fa 0e 00 00 07 70 74 68 72 65 61 64  mutexattr_t....*...&.....pthread
14002ff00  5f 6b 65 79 5f 74 00 05 bb 12 2a 01 00 00 27 70 74 68 72 65 61 64 5f 6d 75 74 65 78 5f 74 00 05  _key_t....*...'pthread_mutex_t..
14002ff20  04 01 12 f0 00 00 00 07 5f 5f 67 74 68 72 65 61 64 5f 6b 65 79 5f 74 00 02 30 17 1b 0f 00 00 07  ........__gthread_key_t..0......
14002ff40  5f 5f 67 74 68 72 65 61 64 5f 6f 6e 63 65 5f 74 00 02 31 18 e3 0e 00 00 07 5f 5f 67 74 68 72 65  __gthread_once_t..1......__gthre
14002ff60  61 64 5f 6d 75 74 65 78 5f 74 00 02 32 19 31 0f 00 00 07 77 6f 72 64 00 01 21 16 c5 00 00 00 07  ad_mutex_t..2.1....word..!......
14002ff80  70 6f 69 6e 74 65 72 00 01 22 16 c5 00 00 00 28 08 01 28 03 d5 0f 00 00 16 6f 66 66 73 65 74 00  pointer..".....(..(......offset.
14002ffa0  29 0d a2 0f 00 00 16 70 74 72 00 2a 0b 49 01 00 00 00 17 5f 5f 65 6d 75 74 6c 73 5f 6f 62 6a 65  )......ptr.*.I.....__emutls_obje
14002ffc0  63 74 00 20 24 20 10 00 00 18 ab 00 00 00 26 08 95 0f 00 00 0f 61 6c 69 67 6e 00 27 08 95 0f 00  ct. $ ........&......align.'....
14002ffe0  00 08 0f 6c 6f 63 00 2b 05 b2 0f 00 00 10 0f 74 65 6d 70 6c 00 2c 09 49 01 00 00 18 00 17 5f 5f  ...loc.+.......templ.,.I......__
140030000  65 6d 75 74 6c 73 5f 61 72 72 61 79 00 08 2f 4f 10 00 00 18 ab 00 00 00 31 0b a2 0f 00 00 0f 64  emutls_array../O........1......d
140030020  61 74 61 00 32 0a 4f 10 00 00 08 00 29 ad 01 00 00 5e 10 00 00 2a c5 00 00 00 00 10 65 6d 75 74  ata.2.O.....)....^...*......emut
140030040  6c 73 5f 6d 75 74 65 78 00 45 1a 7b 0f 00 00 09 03 e8 72 02 40 01 00 00 00 10 65 6d 75 74 6c 73  ls_mutex.E.{......r.@.....emutls
140030060  5f 6b 65 79 00 47 18 4a 0f 00 00 09 03 e0 72 02 40 01 00 00 00 10 65 6d 75 74 6c 73 5f 73 69 7a  _key.G.J......r.@.....emutls_siz
140030080  65 00 48 10 a2 0f 00 00 09 03 d8 72 02 40 01 00 00 00 19 6d 65 6d 63 70 79 00 32 49 01 00 00 d6  e.H........r.@.....memcpy.2I....
1400300a0  10 00 00 02 49 01 00 00 02 a7 01 00 00 02 b6 00 00 00 00 08 6d 61 6c 6c 6f 63 00 07 1a 02 11 49  ....I...............malloc.....I
1400300c0  01 00 00 f0 10 00 00 02 b6 00 00 00 00 08 70 74 68 72 65 61 64 5f 73 65 74 73 70 65 63 69 66 69  ..............pthread_setspecifi
1400300e0  63 00 05 1e 01 1c 17 01 00 00 1c 11 00 00 02 1b 0f 00 00 02 a7 01 00 00 00 08 70 74 68 72 65 61  c.........................pthrea
140030100  64 5f 67 65 74 73 70 65 63 69 66 69 63 00 05 1d 01 1c 49 01 00 00 43 11 00 00 02 1b 0f 00 00 00  d_getspecific.....I...C.........
140030120  08 70 74 68 72 65 61 64 5f 6d 75 74 65 78 5f 75 6e 6c 6f 63 6b 00 05 4c 01 14 17 01 00 00 6b 11  .pthread_mutex_unlock..L......k.
140030140  00 00 02 6b 11 00 00 00 05 31 0f 00 00 08 70 74 68 72 65 61 64 5f 6d 75 74 65 78 5f 6c 6f 63 6b  ...k.....1....pthread_mutex_lock
140030160  00 05 4a 01 14 17 01 00 00 96 11 00 00 02 6b 11 00 00 00 08 70 74 68 72 65 61 64 5f 6f 6e 63 65  ..J...........k.....pthread_once
140030180  00 05 21 01 1a 17 01 00 00 bb 11 00 00 02 bb 11 00 00 02 6f 01 00 00 00 05 e3 0e 00 00 08 70 74  ..!................o..........pt
1400301a0  68 72 65 61 64 5f 6b 65 79 5f 63 72 65 61 74 65 00 05 1b 01 1c 17 01 00 00 eb 11 00 00 02 eb 11  hread_key_create................
1400301c0  00 00 02 8a 01 00 00 00 05 1b 0f 00 00 08 70 74 68 72 65 61 64 5f 6d 75 74 65 78 5f 69 6e 69 74  ..............pthread_mutex_init
1400301e0  00 05 4e 01 14 17 01 00 00 1b 12 00 00 02 6b 11 00 00 02 1b 12 00 00 00 05 16 0f 00 00 2b 66 72  ..N...........k..............+fr
140030200  65 65 00 07 19 02 10 34 12 00 00 02 49 01 00 00 00 19 6d 65 6d 73 65 74 00 35 49 01 00 00 55 12  ee.....4....I.....memset.5I...U.
140030220  00 00 02 49 01 00 00 02 17 01 00 00 02 b6 00 00 00 00 08 72 65 61 6c 6c 6f 63 00 07 1b 02 11 49  ...I...............realloc.....I
140030240  01 00 00 75 12 00 00 02 49 01 00 00 02 b6 00 00 00 00 2c 61 62 6f 72 74 00 07 95 01 28 08 63 61  ...u....I.........,abort....(.ca
140030260  6c 6c 6f 63 00 07 18 02 11 49 01 00 00 9f 12 00 00 02 b6 00 00 00 02 b6 00 00 00 00 2d 5f 5f 65  lloc.....I..................-__e
140030280  6d 75 74 6c 73 5f 72 65 67 69 73 74 65 72 5f 63 6f 6d 6d 6f 6e 00 01 cc 01 60 42 01 40 01 00 00  mutls_register_common....`B.@...
1400302a0  00 2d 00 00 00 00 00 00 00 01 9c 0c 13 00 00 12 6f 62 6a 00 cc 33 0c 13 00 00 01 52 2e ab 00 00  .-..............obj..3.....R....
1400302c0  00 01 cd 0b 95 0f 00 00 01 51 12 61 6c 69 67 6e 00 cd 16 95 0f 00 00 01 58 12 74 65 6d 70 6c 00  .........Q.align........X.templ.
1400302e0  cd 23 49 01 00 00 01 59 00 05 d5 0f 00 00 2f 5f 5f 65 6d 75 74 6c 73 5f 67 65 74 5f 61 64 64 72  .#I....Y....../__emutls_get_addr
140030300  65 73 73 00 01 8c 01 49 01 00 00 60 40 01 40 01 00 00 00 fd 01 00 00 00 00 00 00 01 9c e7 16 00  ess....I...`@.@.................
140030320  00 1a 6f 62 6a 00 8c 2f 0c 13 00 00 1a 00 00 00 0c 00 00 00 0b 6f 66 66 73 65 74 00 98 0b a2 0f  ..obj../.............offset.....
140030340  00 00 62 00 00 00 52 00 00 00 0b 61 72 72 00 a8 1a e7 16 00 00 b6 00 00 00 a0 00 00 00 0b 72 65  ..b...R....arr................re
140030360  74 00 c1 09 49 01 00 00 0c 01 00 00 04 01 00 00 1b 17 00 00 00 a3 14 00 00 10 6f 6e 63 65 00 9c  t...I.....................once..
140030380  1f 62 0f 00 00 09 03 d0 72 02 40 01 00 00 00 0d ed 19 00 00 b8 40 01 40 01 00 00 00 02 b8 40 01  .b......r.@..........@.@......@.
1400303a0  40 01 00 00 00 13 00 00 00 00 00 00 00 9d 07 19 14 00 00 06 16 1a 00 00 2b 01 00 00 29 01 00 00  @.......................+...)...
1400303c0  06 07 1a 00 00 3e 01 00 00 3c 01 00 00 09 cb 40 01 40 01 00 00 00 96 11 00 00 03 01 52 09 03 d0  .....>...<.....@.@..........R...
1400303e0  72 02 40 01 00 00 00 03 01 51 09 03 20 40 01 40 01 00 00 00 00 00 0d da 18 00 00 cb 40 01 40 01  r.@......Q.. @.@............@.@.
140030400  00 00 00 02 cb 40 01 40 01 00 00 00 0f 00 00 00 00 00 00 00 9e 07 5f 14 00 00 06 fa 18 00 00 51  .....@.@.............._........Q
140030420  01 00 00 4f 01 00 00 09 da 40 01 40 01 00 00 00 70 11 00 00 03 01 52 02 73 00 00 00 30 a6 18 00  ...O.....@.@....p.....R.s...0...
140030440  00 e7 40 01 40 01 00 00 00 01 e7 40 01 40 01 00 00 00 11 00 00 00 00 00 00 00 01 a5 07 06 c8 18  ..@.@......@.@..................
140030460  00 00 64 01 00 00 62 01 00 00 09 ef 40 01 40 01 00 00 00 43 11 00 00 03 01 52 02 73 00 00 00 00  ..d...b.....@.@....C.....R.s....
140030480  1b 22 00 00 00 31 15 00 00 13 ab 00 00 00 ab 0f a2 0f 00 00 77 01 00 00 75 01 00 00 1c 3c 19 00  ."...1..............w...u....<..
1400304a0  00 23 41 01 40 01 00 00 00 01 32 00 00 00 b0 07 06 15 00 00 06 6b 19 00 00 83 01 00 00 7f 01 00  .#A.@.....2..........k..........
1400304c0  00 06 5d 19 00 00 94 01 00 00 92 01 00 00 09 2b 41 01 40 01 00 00 00 f0 10 00 00 03 01 51 02 73  ..]............+A.@..........Q.s
1400304e0  00 00 00 0e 06 41 01 40 01 00 00 00 80 12 00 00 23 15 00 00 03 01 52 02 74 21 03 01 51 01 38 00  .....A.@........#.....R.t!..Q.8.
140030500  11 5d 42 01 40 01 00 00 00 75 12 00 00 00 31 a0 41 01 40 01 00 00 00 60 00 00 00 00 00 00 00 10  .]B.@....u....1.A.@....`........
140030520  16 00 00 0b 6f 72 69 67 5f 73 69 7a 65 00 b4 0f a2 0f 00 00 9e 01 00 00 9c 01 00 00 13 ab 00 00  ....orig_size...................
140030540  00 b5 0f a2 0f 00 00 ac 01 00 00 a6 01 00 00 0d 3c 19 00 00 e6 41 01 40 01 00 00 00 01 e6 41 01  ................<....A.@......A.
140030560  40 01 00 00 00 1a 00 00 00 00 00 00 00 be 07 c5 15 00 00 06 6b 19 00 00 ed 01 00 00 eb 01 00 00  @...................k...........
140030580  06 5d 19 00 00 f7 01 00 00 f5 01 00 00 09 f4 41 01 40 01 00 00 00 f0 10 00 00 03 01 51 02 73 00  .].............A.@..........Q.s.
1400305a0  00 00 0e c0 41 01 40 01 00 00 00 55 12 00 00 e7 15 00 00 03 01 52 02 73 00 03 01 51 06 7c 00 33  ....A.@....U.........R.s...Q.|.3
1400305c0  24 23 08 00 09 e6 41 01 40 01 00 00 00 48 1a 00 00 03 01 52 09 76 00 33 24 73 00 22 23 08 03 01  $#....A.@....H.....R.v.3$s."#...
1400305e0  51 01 30 03 01 58 04 7c 00 33 24 00 00 1c 7a 19 00 00 76 40 01 40 01 00 00 00 01 0c 00 00 00 a8  Q.0..X.|.3$...z...v@.@..........
140030600  20 43 16 00 00 06 9b 19 00 00 09 02 00 00 07 02 00 00 11 81 40 01 40 01 00 00 00 1c 11 00 00 00   C..................@.@.........
140030620  32 ec 16 00 00 40 41 01 40 01 00 00 00 01 3d 00 00 00 01 c4 0d 06 06 17 00 00 1f 02 00 00 19 02  2....@A.@.....=.................
140030640  00 00 33 3d 00 00 00 1d 12 17 00 00 3b 02 00 00 35 02 00 00 1d 1c 17 00 00 57 02 00 00 51 02 00  ..3=........;...5........W...Q..
140030660  00 0e 5b 41 01 40 01 00 00 00 d6 10 00 00 9c 16 00 00 03 01 52 02 7c 08 00 0e 80 41 01 40 01 00  ..[A.@..............R.|....A.@..
140030680  00 00 61 1a 00 00 b4 16 00 00 03 01 58 02 7c 00 00 0e 0a 42 01 40 01 00 00 00 d6 10 00 00 d1 16  ..a.........X.|....B.@..........
1400306a0  00 00 03 01 52 07 76 00 7c 00 22 23 07 00 09 4f 42 01 40 01 00 00 00 48 1a 00 00 03 01 51 01 30  ....R.v.|."#...OB.@....H.....Q.0
1400306c0  00 00 00 00 05 20 10 00 00 34 65 6d 75 74 6c 73 5f 61 6c 6c 6f 63 00 01 66 01 49 01 00 00 01 27  ..... ...4emutls_alloc..f.I....'
1400306e0  17 00 00 35 6f 62 6a 00 01 66 27 0c 13 00 00 1e 70 74 72 00 68 49 01 00 00 1e 72 65 74 00 69 49  ...5obj..f'.....ptr.hI....ret.iI
140030700  01 00 00 00 1f 65 6d 75 74 6c 73 5f 69 6e 69 74 00 5b 20 40 01 40 01 00 00 00 34 00 00 00 00 00  .....emutls_init.[ @.@....4.....
140030720  00 00 01 9c 12 18 00 00 0d 07 19 00 00 24 40 01 40 01 00 00 00 01 24 40 01 40 01 00 00 00 0e 00  .............$@.@.....$@.@......
140030740  00 00 00 00 00 00 5e 03 9d 17 00 00 06 2f 19 00 00 6f 02 00 00 6d 02 00 00 09 32 40 01 40 01 00  ......^....../...o...m....2@.@..
140030760  00 00 f0 11 00 00 03 01 52 09 03 e8 72 02 40 01 00 00 00 03 01 51 01 30 00 00 0d aa 19 00 00 32  ........R...r.@......Q.0.......2
140030780  40 01 40 01 00 00 00 02 32 40 01 40 01 00 00 00 13 00 00 00 00 00 00 00 60 07 04 18 00 00 06 d8  @.@.....2@.@............`.......
1400307a0  19 00 00 80 02 00 00 7e 02 00 00 06 ca 19 00 00 91 02 00 00 8f 02 00 00 09 45 40 01 40 01 00 00  .......~.................E@.@...
1400307c0  00 c0 11 00 00 03 01 52 09 03 e0 72 02 40 01 00 00 00 03 01 51 09 03 d0 3f 01 40 01 00 00 00 00  .......R...r.@......Q...?.@.....
1400307e0  00 11 54 40 01 40 01 00 00 00 75 12 00 00 00 1f 65 6d 75 74 6c 73 5f 64 65 73 74 72 6f 79 00 4b  ..T@.@....u.....emutls_destroy.K
140030800  d0 3f 01 40 01 00 00 00 43 00 00 00 00 00 00 00 01 9c a6 18 00 00 1a 70 74 72 00 4b 17 49 01 00  .?.@....C..............ptr.K.I..
140030820  00 a8 02 00 00 a0 02 00 00 0b 61 72 72 00 4d 1a e7 16 00 00 c8 02 00 00 c0 02 00 00 13 ab 00 00  ..........arr.M.................
140030840  00 4e 0b a2 0f 00 00 e2 02 00 00 e0 02 00 00 0b 69 00 4f 0b a2 0f 00 00 ec 02 00 00 e8 02 00 00  .N..............i.O.............
140030860  11 fb 3f 01 40 01 00 00 00 20 12 00 00 36 13 40 01 40 01 00 00 00 20 12 00 00 03 01 52 03 a3 01  ..?.@.... ...6.@.@.... .....R...
140030880  52 00 00 0c 5f 5f 67 74 68 72 65 61 64 5f 6d 75 74 65 78 5f 75 6e 6c 6f 63 6b 00 08 03 17 01 00  R...__gthread_mutex_unlock......
1400308a0  00 d5 18 00 00 14 a3 00 00 00 08 03 2c d5 18 00 00 00 05 7b 0f 00 00 0c 5f 5f 67 74 68 72 65 61  ............,......{....__gthrea
1400308c0  64 5f 6d 75 74 65 78 5f 6c 6f 63 6b 00 ea 02 17 01 00 00 07 19 00 00 14 a3 00 00 00 ea 02 2a d5  d_mutex_lock..................*.
1400308e0  18 00 00 00 37 5f 5f 67 74 68 72 65 61 64 5f 6d 75 74 65 78 5f 69 6e 69 74 5f 66 75 6e 63 74 69  ....7__gthread_mutex_init_functi
140030900  6f 6e 00 02 da 02 01 03 3c 19 00 00 14 a3 00 00 00 da 02 33 d5 18 00 00 00 0c 5f 5f 67 74 68 72  on......<..........3......__gthr
140030920  65 61 64 5f 73 65 74 73 70 65 63 69 66 69 63 00 d4 02 17 01 00 00 7a 19 00 00 0a 5f 5f 6b 65 79  ead_setspecific.......z....__key
140030940  00 d4 02 28 4a 0f 00 00 0a 5f 5f 70 74 72 00 d4 02 3b a7 01 00 00 00 0c 5f 5f 67 74 68 72 65 61  ...(J....__ptr...;......__gthrea
140030960  64 5f 67 65 74 73 70 65 63 69 66 69 63 00 ce 02 49 01 00 00 aa 19 00 00 0a 5f 5f 6b 65 79 00 ce  d_getspecific...I........__key..
140030980  02 28 4a 0f 00 00 00 0c 5f 5f 67 74 68 72 65 61 64 5f 6b 65 79 5f 63 72 65 61 74 65 00 c2 02 17  .(J.....__gthread_key_create....
1400309a0  01 00 00 e8 19 00 00 0a 5f 5f 6b 65 79 00 c2 02 28 e8 19 00 00 0a 5f 5f 64 74 6f 72 00 c2 02 36  ........__key...(.....__dtor...6
1400309c0  8a 01 00 00 00 05 4a 0f 00 00 0c 5f 5f 67 74 68 72 65 61 64 5f 6f 6e 63 65 00 b9 02 17 01 00 00  ......J....__gthread_once.......
1400309e0  26 1a 00 00 0a 5f 5f 6f 6e 63 65 00 b9 02 23 26 1a 00 00 0a 5f 5f 66 75 6e 63 00 b9 02 32 6f 01  &....__once...#&....__func...2o.
140030a00  00 00 00 05 62 0f 00 00 38 5f 5f 67 74 68 72 65 61 64 5f 61 63 74 69 76 65 5f 70 00 02 2c 01 01  ....b...8__gthread_active_p..,..
140030a20  17 01 00 00 03 20 6d 65 6d 73 65 74 00 5f 5f 62 75 69 6c 74 69 6e 5f 6d 65 6d 73 65 74 00 20 6d  ..... memset.__builtin_memset. m
140030a40  65 6d 63 70 79 00 5f 5f 62 75 69 6c 74 69 6e 5f 6d 65 6d 63 70 79 00 00                          emcpy.__builtin_memcpy..
.debug_info section ended  {0x14002e000-0x140030a58}

.debug_abbrev section started  {0x140031000-0x140031430}
140031000  _.debug_abbrev:
140031000  01 11 00 10 17 11 01 12 0f 03 0e 1b 0e 25 0e 13 05 00 00 00                                      .............%......
140031014  _.debug_abbrev:
140031014                                                              01 28 00 03 08 1c 0b 00 00 02 24 00                      .(........$.
140031020  0b 0b 3e 0b 03 08 00 00 03 04 01 03 08 3e 21 07 0b 21 04 49 13 3a 21 01 3b 05 39 21 06 01 13 00  ..>..........>!..!.I.:!.;.9!....
140031040  00 04 01 01 49 13 01 13 00 00 05 34 00 03 08 3a 21 02 3b 0b 39 21 11 49 13 3f 19 3c 19 00 00 06  ....I......4...:!.;.9!.I.?.<....
140031060  34 00 47 13 3a 21 03 3b 05 39 21 0a 49 13 02 18 00 00 07 11 01 25 08 13 0b 03 1f 1b 1f 10 17 00  4.G.:!.;.9!.I........%..........
140031080  00 08 0f 00 0b 0b 49 13 00 00 09 15 00 27 19 00 00 0a 16 00 03 08 3a 0b 3b 0b 39 0b 49 13 00 00  ......I......'........:.;.9.I...
1400310a0  0b 21 00 00 00 0c 21 00 49 13 2f 0b 00 00 00                                                     .!....!.I./....
1400310af  _.debug_abbrev:
1400310af                                               01 28 00 03 08 1c 0b 00 00 02 05 00 49 13 00 00 03                 .(..........I....
1400310c0  49 00 02 18 7e 18 00 00 04 24 00 0b 0b 3e 0b 03 08 00 00 05 0f 00 0b 21 08 49 13 00 00 06 05 00  I...~....$...>.........!.I......
1400310e0  31 13 02 17 b7 42 17 00 00 07 16 00 03 08 3a 0b 3b 0b 39 0b 49 13 00 00 08 2e 01 3f 19 03 08 3a  1....B........:.;.9.I......?...:
140031100  0b 3b 05 39 0b 27 19 49 13 3c 19 01 13 00 00 09 48 01 7d 01 7f 13 00 00 0a 05 00 03 08 3a 21 02  .;.9.'.I.<......H.}..........:!.
140031120  3b 05 39 0b 49 13 00 00 0b 34 00 03 08 3a 21 01 3b 0b 39 0b 49 13 02 17 b7 42 17 00 00 0c 2e 01  ;.9.I....4...:!.;.9.I....B......
140031140  03 08 3a 21 02 3b 05 39 21 01 27 19 49 13 20 21 03 01 13 00 00 0d 1d 01 31 13 52 01 b8 42 0b 11  ..:!.;.9!.'.I. !........1.R..B..
140031160  01 12 07 58 21 01 59 0b 57 0b 01 13 00 00 0e 48 01 7d 01 7f 13 01 13 00 00 0f 0d 00 03 08 3a 21  ...X!.Y.W......H.}............:!
140031180  01 3b 0b 39 0b 49 13 38 0b 00 00 10 34 00 03 08 3a 21 01 3b 0b 39 0b 49 13 02 18 00 00 11 48 00  .;.9.I.8....4...:!.;.9.I......H.
1400311a0  7d 01 7f 13 00 00 12 05 00 03 08 3a 21 01 3b 0b 39 0b 49 13 02 18 00 00 13 34 00 03 0e 3a 21 01  }..........:!.;.9.I......4...:!.
1400311c0  3b 0b 39 0b 49 13 02 17 b7 42 17 00 00 14 05 00 03 0e 3a 21 02 3b 05 39 0b 49 13 00 00 15 04 01  ;.9.I....B........:!.;.9.I......
1400311e0  03 08 3e 21 07 0b 21 04 49 13 3a 21 04 3b 05 39 21 06 01 13 00 00 16 0d 00 03 08 3a 21 01 3b 0b  ..>!..!.I.:!.;.9!..........:!.;.
140031200  39 0b 49 13 00 00 17 13 01 03 08 0b 0b 3a 21 01 3b 0b 39 21 08 01 13 00 00 18 0d 00 03 0e 3a 21  9.I..........:!.;.9!..........:!
140031220  01 3b 0b 39 0b 49 13 38 21 00 00 00 19 2e 01 3f 19 03 08 3a 21 06 3b 0b 39 21 12 27 19 49 13 3c  .;.9.I.8!......?...:!.;.9!.'.I.<
140031240  19 01 13 00 00 1a 05 00 03 08 3a 21 01 3b 0b 39 0b 49 13 02 17 b7 42 17 00 00 1b 0b 01 55 17 01  ..........:!.;.9.I....B......U..
140031260  13 00 00 1c 1d 01 31 13 52 01 b8 42 0b 55 17 58 21 01 59 0b 57 0b 01 13 00 00 1d 34 00 31 13 02  ......1.R..B.U.X!.Y.W......4.1..
140031280  17 b7 42 17 00 00 1e 34 00 03 08 3a 21 01 3b 0b 39 21 09 49 13 00 00 1f 2e 01 03 08 3a 21 01 3b  ..B....4...:!.;.9!.I........:!.;
1400312a0  0b 39 21 01 27 19 11 01 12 07 40 18 7a 19 01 13 00 00 20 2e 00 3f 19 3c 19 6e 08 03 08 3a 21 08  .9!.'.....@.z..... ..?.<.n...:!.
1400312c0  3b 21 00 00 00 21 11 01 25 08 13 0b 03 1f 1b 1f 11 01 12 07 10 17 00 00 22 0f 00 0b 0b 00 00 23  ;!...!..%..............."......#
1400312e0  15 00 27 19 00 00 24 15 01 27 19 01 13 00 00 25 26 00 00 00 26 26 00 49 13 00 00 27 16 00 03 08  ..'...$..'.....%&...&&.I...'....
140031300  3a 0b 3b 05 39 0b 49 13 00 00 28 17 01 0b 0b 3a 0b 3b 0b 39 0b 01 13 00 00 29 01 01 49 13 01 13  :.;.9.I...(....:.;.9.....)..I...
140031320  00 00 2a 21 00 49 13 00 00 2b 2e 01 3f 19 03 08 3a 0b 3b 05 39 0b 27 19 3c 19 01 13 00 00 2c 2e  ..*!.I...+..?...:.;.9.'.<.....,.
140031340  00 3f 19 03 08 3a 0b 3b 05 39 0b 27 19 87 01 19 3c 19 00 00 2d 2e 01 3f 19 03 08 3a 0b 3b 0b 39  .?...:.;.9.'....<...-..?...:.;.9
140031360  0b 27 19 11 01 12 07 40 18 7a 19 01 13 00 00 2e 05 00 03 0e 3a 0b 3b 0b 39 0b 49 13 02 18 00 00  .'.....@.z..........:.;.9.I.....
140031380  2f 2e 01 3f 19 03 08 3a 0b 3b 0b 39 0b 27 19 49 13 11 01 12 07 40 18 7a 19 01 13 00 00 30 1d 01  /..?...:.;.9.'.I.....@.z.....0..
1400313a0  31 13 52 01 b8 42 0b 11 01 12 07 58 0b 59 0b 57 0b 00 00 31 0b 01 11 01 12 07 01 13 00 00 32 1d  1.R..B.....X.Y.W...1..........2.
1400313c0  01 31 13 52 01 b8 42 0b 55 17 58 0b 59 0b 57 0b 00 00 33 0b 01 55 17 00 00 34 2e 01 03 08 3a 0b  .1.R..B.U.X.Y.W...3..U...4....:.
1400313e0  3b 0b 39 0b 27 19 49 13 20 0b 01 13 00 00 35 05 00 03 08 3a 0b 3b 0b 39 0b 49 13 00 00 36 48 01  ;.9.'.I. .....5....:.;.9.I...6H.
140031400  7d 01 82 01 19 7f 13 00 00 37 2e 01 03 08 3a 0b 3b 05 39 0b 27 19 20 0b 01 13 00 00 38 2e 00 03  }........7....:.;.9.'. .....8...
140031420  08 3a 0b 3b 05 39 0b 27 19 49 13 20 0b 00 00 00                                                  .:.;.9.'.I. ....
.debug_abbrev section ended  {0x140031000-0x140031430}

.debug_line section started  {0x140032000-0x14003247c}
140032000  _.debug_line:
140032000  58 00 00 00 05 00 08 00 2e 00 00 00 01 01 01 fb 0e 0d 00 01 01 01 01 00 00 00 01 00 00 01 01 01  X...............................
140032020  1f 02 00 00 00 00 5f 00 00 00 02 01 1f 02 0f 02 8e 00 00 00 01 8e 00 00 00 01 00 09 02 90 3f 01  ......_.......................?.
140032040  40 01 00 00 00 03 f4 00 01 22 22 67 59 30 75 4b 67 67 30 3d 4c 22 22 02 01 00 01 01              @........""gY0uKgg0=L"".....
14003205c  _.debug_line:
14003205c                                                                                      44 00 00 00                              D...
140032060  05 00 08 00 3c 00 00 00 01 01 01 fb 0e 0d 00 01 01 01 01 00 00 00 01 00 00 01 01 01 1f 03 23 01  ....<.........................#.
140032080  00 00 82 01 00 00 a5 01 00 00 02 01 1f 02 0f 04 d1 01 00 00 01 db 01 00 00 02 e2 01 00 00 01 ee  ................................
1400320a0  01 00 00 01                                                                                      ....
1400320a4  _.debug_line:
1400320a4              d4 03 00 00 05 00 08 00 59 00 00 00 01 01 01 fb 0e 0d 00 01 01 01 01 00 00 00 01 00      ........Y...................
1400320c0  00 01 01 01 1f 04 83 02 00 00 e2 02 00 00 05 03 00 00 4f 03 00 00 02 01 1f 02 0f 09 7b 03 00 00  ..................O.........{...
1400320e0  01 84 03 00 00 01 8d 03 00 00 00 9e 03 00 00 02 a8 03 00 00 03 af 03 00 00 02 b9 03 00 00 02 c2  ................................
140032100  03 00 00 02 cb 03 00 00 00 05 01 00 09 02 d0 3f 01 40 01 00 00 00 03 cb 00 01 06 01 05 03 06 75  ...............?.@.............u
140032120  13 05 0b 06 01 05 03 06 3d 14 05 11 00 02 04 01 01 05 01 06 37 05 11 00 02 04 01 41 05 0a 2e 05  ........=...........7......A....
140032140  07 06 68 05 14 06 01 05 0a 58 05 02 06 59 05 19 00 02 04 02 8d 05 11 00 02 04 01 4a 05 03 5e 05  ..h......X...Y.............J..^.
140032160  01 06 3d 66 05 03 1f 58 05 01 06 00 09 02 20 40 01 40 01 00 00 00 17 05 03 4c 04 02 05 01 03 fc  ..=f...X...... @.@.......L......
140032180  04 01 05 03 14 05 05 13 06 d6 04 01 05 03 06 03 83 7b 01 04 02 05 01 03 e2 04 01 05 03 14 05 0a  .................{..............
1400321a0  06 01 08 2e 04 01 05 06 00 02 04 01 03 9c 7b 01 05 01 4c 05 05 06 57 05 01 03 2c 08 20 06 01 05  ..............{...L...W...,. ...
1400321c0  03 06 9f 03 0a 01 05 14 06 01 05 03 06 4c 05 06 00 02 04 01 06 01 05 01 03 73 3c 05 06 00 02 04  .............L...........s<.....
1400321e0  01 03 0d 3c 05 03 06 03 0e 2e 04 02 05 01 03 a6 04 01 05 03 14 05 0a 06 01 ac 04 01 05 06 00 02  ...<............................
140032200  04 01 03 d9 7b 01 04 02 05 0a 03 a7 04 3c 3c 04 01 05 03 06 03 d9 7b 01 05 06 00 02 04 01 06 01  ....{........<<.......{.........
140032220  05 08 06 03 09 2e 05 2a 06 01 05 0b 00 02 04 01 3c 05 03 06 03 0f 90 05 20 06 01 05 09 4a 05 03  .......*........<....... ....J..
140032240  06 59 05 06 00 02 04 01 06 01 05 01 97 82 2e 05 07 06 03 53 74 13 04 02 05 01 03 9c 04 01 05 03  .Y.................St...........
140032260  14 05 05 13 05 0c 06 01 d6 58 04 01 05 07 06 03 e2 7b 01 04 02 05 01 03 cc 04 01 05 03 14 05 05  .........X.......{..............
140032280  13 05 0c 06 01 e4 04 01 05 07 06 03 b2 7b 01 05 0e 06 01 05 07 06 4b 05 0a 06 01 05 07 06 95 04  .............{........K.........
1400322a0  02 05 01 03 e3 04 01 05 03 14 05 05 13 05 0c 06 01 82 90 04 01 05 07 06 03 a0 7b 01 05 0d 06 13  ..........................{.....
1400322c0  05 0f d5 05 07 06 4b 05 0a 06 13 05 0d 3b 05 07 06 3d 05 0a 06 01 05 07 06 68 04 02 05 0a 06 03  ......K......;...=.......h......
1400322e0  a7 04 01 04 01 05 20 03 eb 7b 66 05 11 03 6e 4a 05 07 06 3d 04 02 05 01 03 a4 04 01 05 03 14 05  ...... ..{f...nJ...=............
140032300  0a 06 01 82 04 01 05 03 06 03 eb 7b 01 05 09 06 01 05 03 06 59 05 06 00 02 04 01 06 01 05 07 06  ...........{........Y...........
140032320  f4 05 01 03 a2 7f 01 05 03 14 13 16 05 0a 06 01 05 18 4c 05 06 3a 05 07 06 a0 05 0d 06 01 58 05  ..................L..:........X.
140032340  07 06 59 05 0a 06 01 05 07 06 92 05 1a 06 01 05 07 06 3d 05 0b 06 01 05 03 06 03 0c 4a 05 0a 06  ..Y...............=.........J...
140032360  01 05 05 4b 05 06 3b 05 05 06 91 06 58 05 03 06 40 06 01 05 07 06 03 c1 00 01 05 01 06 16 05 1d  ...K..;.....X...@...............
140032380  38 05 03 06 5a 05 01 06 14 58 2e 05 07 06 03 6b d6 13 05 0f 06 01 05 07 06 59 05 0d 06 14 05 07  8...Z....X.....k.........Y......
1400323a0  3b 4a 06 75 05 0d 06 01 05 0a c9 05 0d 3b 05 07 06 3d 05 0a 06 01 05 07 06 68 05 11 06 01 05 07  ;J.u.........;...=.......h......
1400323c0  06 3d 05 0e 06 59 05 07 3b 06 e6 04 02 05 01 03 96 04 01 05 03 14 05 0a 06 01 d6 ba 04 01 05 07  .=...Y..;.......................
1400323e0  06 03 a1 7b 01 05 0d 06 01 58 05 07 06 59 05 0a 06 01 05 07 06 5a 05 46 06 01 05 0b 59 05 09 3c  ...{.....X...Y.......Z.F....Y..<
140032400  05 07 06 3d 05 1b 06 01 d6 05 04 06 03 26 01 05 0d 06 01 05 0b ac 05 04 06 75 06 d6 05 05 06 03  ...=.........&...........u......
140032420  5f 01 06 74 82 05 02 06 03 2c 01 05 01 03 20 90 06 01 05 03 06 13 05 06 06 01 05 07 06 5a 05 11  _..t.....,.... ..............Z..
140032440  06 01 05 07 06 3d 05 12 06 01 05 03 06 84 05 06 06 01 05 05 06 67 05 10 06 01 05 03 06 4b 05 06  .....=...............g.......K..
140032460  06 01 05 0d 00 02 04 01 58 05 01 5a 05 05 06 49 05 10 06 01 05 01 4b 02 01 00 01 01              ........X..Z...I......K.....
.debug_line section ended  {0x140032000-0x14003247c}

.debug_frame section started  {0x140033000-0x140033150}
140033000  _.debug_frame:
140033000  14 00 00 00 ff ff ff ff 01 00 01 78 20 0c 07 08 a0 01 00 00 00 00 00 00 2c 00 00 00 00 00 00 00  ...........x ...........,.......
140033020  90 3f 01 40 01 00 00 00 32 00 00 00 00 00 00 00 41 0e 10 82 02 41 0e 18 80 03 6e 0e 10 c0 41 0e  .?.@....2.......A....A....n...A.
140033040  08 c2 00 00 00 00 00 00                                                                          ........
140033048  _.debug_frame:
140033048                          14 00 00 00 ff ff ff ff 01 00 01 78 20 0c 07 08 a0 01 00 00 00 00 00 00          ...........x ...........
140033060  3c 00 00 00 48 00 00 00 d0 3f 01 40 01 00 00 00 43 00 00 00 00 00 00 00 41 0e 10 85 02 41 0e 18  <...H....?.@....C.......A....A..
140033080  84 03 41 0e 20 83 04 44 0e 40 74 0e 20 41 c3 0e 18 41 c4 0e 10 41 c5 0e 08 00 00 00 00 00 00 00  ..A. ..D.@t. A...A...A..........
1400330a0  24 00 00 00 48 00 00 00 20 40 01 40 01 00 00 00 34 00 00 00 00 00 00 00 44 0e 30 69 0a 0e 08 41  $...H... @.@....4.......D.0i...A
1400330c0  0b 00 00 00 00 00 00 00 6c 00 00 00 48 00 00 00 60 40 01 40 01 00 00 00 fd 01 00 00 00 00 00 00  ........l...H...`@.@............
1400330e0  42 0e 10 8c 02 41 0e 18 86 03 41 0e 20 85 04 41 0e 28 84 05 41 0e 30 83 06 44 0e 50 02 44 0a 0e  B....A....A. ..A.(..A.0..D.P.D..
140033100  30 41 c3 0e 28 41 c4 0e 20 41 c5 0e 18 41 c6 0e 10 42 cc 0e 08 44 0b 02 d7 0a 0e 30 41 c3 0e 28  0A..(A.. A...A...B...D.....0A..(
140033120  41 c4 0e 20 41 c5 0e 18 41 c6 0e 10 42 cc 0e 08 4b 0b 00 00 00 00 00 00 14 00 00 00 48 00 00 00  A.. A...A...B...K...........H...
140033140  60 42 01 40 01 00 00 00 2d 00 00 00 00 00 00 00                                                  `B.@....-.......
.debug_frame section ended  {0x140033000-0x140033150}

.debug_str section started  {0x140034000-0x1400340b0}
140034000  _.debug_str:
140034000  43 3a 2f 62 75 69 6c 64 72 6f 6f 74 2f 73 72 63 2f 67 63 63 2d 31 33 2e 32 2e 30 2f 6c 69 62 67  C:/buildroot/src/gcc-13.2.0/libg
140034020  63 63 2f 63 6f 6e 66 69 67 2f 69 33 38 36 5c 63 79 67 77 69 6e 2e 53 00 43 3a 5c 62 75 69 6c 64  cc/config/i386\cygwin.S.C:\build
140034040  72 6f 6f 74 5c 78 38 36 5f 36 34 2d 31 33 32 30 2d 70 6f 73 69 78 2d 73 65 68 2d 75 63 72 74 2d  root\x86_64-1320-posix-seh-ucrt-
140034060  72 74 5f 76 31 31 2d 72 65 76 30 5c 62 75 69 6c 64 5c 67 63 63 2d 31 33 2e 32 2e 30 5c 78 38 36  rt_v11-rev0\build\gcc-13.2.0\x86
140034080  5f 36 34 2d 77 36 34 2d 6d 69 6e 67 77 33 32 5c 6c 69 62 67 63 63 00 47 4e 55 20 41 53 20 32 2e  _64-w64-mingw32\libgcc.GNU AS 2.
1400340a0  33 39 00                                                                                         39.
1400340a3  _.debug_str:
1400340a3           5f 5f 6d 75 74 65 78 00 73 69 7a 65 00                                                     __mutex.size.
.debug_str section ended  {0x140034000-0x1400340b0}

.debug_line_str section started  {0x140035000-0x1400353d6}
140035000  _.debug_line_str:
140035000  43 3a 5c 62 75 69 6c 64 72 6f 6f 74 5c 78 38 36 5f 36 34 2d 31 33 32 30 2d 70 6f 73 69 78 2d 73  C:\buildroot\x86_64-1320-posix-s
140035020  65 68 2d 75 63 72 74 2d 72 74 5f 76 31 31 2d 72 65 76 30 5c 62 75 69 6c 64 5c 67 63 63 2d 31 33  eh-ucrt-rt_v11-rev0\build\gcc-13
140035040  2e 32 2e 30 5c 78 38 36 5f 36 34 2d 77 36 34 2d 6d 69 6e 67 77 33 32 5c 6c 69 62 67 63 63 00 43  .2.0\x86_64-w64-mingw32\libgcc.C
140035060  3a 2f 62 75 69 6c 64 72 6f 6f 74 2f 73 72 63 2f 67 63 63 2d 31 33 2e 32 2e 30 2f 6c 69 62 67 63  :/buildroot/src/gcc-13.2.0/libgc
140035080  63 2f 63 6f 6e 66 69 67 2f 69 33 38 36 00 63 79 67 77 69 6e 2e 53 00                             c/config/i386.cygwin.S.
140035097  _.debug_line_str:
140035097                                                                       43 3a 2f 62 75 69 6c 64 72                         C:/buildr
1400350a0  6f 6f 74 2f 73 72 63 2f 67 63 63 2d 31 33 2e 32 2e 30 2f 6c 69 62 67 63 63 2f 6c 69 62 67 63 63  oot/src/gcc-13.2.0/libgcc/libgcc
1400350c0  32 2e 63 00 43 3a 5c 62 75 69 6c 64 72 6f 6f 74 5c 78 38 36 5f 36 34 2d 31 33 32 30 2d 70 6f 73  2.c.C:\buildroot\x86_64-1320-pos
1400350e0  69 78 2d 73 65 68 2d 75 63 72 74 2d 72 74 5f 76 31 31 2d 72 65 76 30 5c 62 75 69 6c 64 5c 67 63  ix-seh-ucrt-rt_v11-rev0\build\gc
140035100  63 2d 31 33 2e 32 2e 30 5c 78 38 36 5f 36 34 2d 77 36 34 2d 6d 69 6e 67 77 33 32 5c 6c 69 62 67  c-13.2.0\x86_64-w64-mingw32\libg
140035120  63 63 00 43 3a 2f 62 75 69 6c 64 72 6f 6f 74 2f 78 38 36 5f 36 34 2d 31 33 32 30 2d 70 6f 73 69  cc.C:/buildroot/x86_64-1320-posi
140035140  78 2d 73 65 68 2d 75 63 72 74 2d 72 74 5f 76 31 31 2d 72 65 76 30 2f 62 75 69 6c 64 2f 67 63 63  x-seh-ucrt-rt_v11-rev0/build/gcc
140035160  2d 31 33 2e 32 2e 30 2f 78 38 36 5f 36 34 2d 77 36 34 2d 6d 69 6e 67 77 33 32 2f 6c 69 62 67 63  -13.2.0/x86_64-w64-mingw32/libgc
140035180  63 00 43 3a 2f 62 75 69 6c 64 72 6f 6f 74 2f 73 72 63 2f 67 63 63 2d 31 33 2e 32 2e 30 2f 6c 69  c.C:/buildroot/src/gcc-13.2.0/li
1400351a0  62 67 63 63 00 43 3a 2f 62 75 69 6c 64 72 6f 6f 74 2f 73 72 63 2f 67 63 63 2d 31 33 2e 32 2e 30  bgcc.C:/buildroot/src/gcc-13.2.0
1400351c0  2f 67 63 63 2f 63 6f 6e 66 69 67 2f 69 33 38 36 00 6c 69 62 67 63 63 32 2e 63 00 69 33 38 36 2e  /gcc/config/i386.libgcc2.c.i386.
1400351e0  68 00 67 62 6c 2d 63 74 6f 72 73 2e 68 00 6c 69 62 67 63 63 32 2e 63 00                          h.gbl-ctors.h.libgcc2.c.
1400351f8  _.debug_line_str:
1400351f8                                                                          43 3a 2f 62 75 69 6c 64                          C:/build
140035200  72 6f 6f 74 2f 73 72 63 2f 67 63 63 2d 31 33 2e 32 2e 30 2f 6c 69 62 67 63 63 2f 65 6d 75 74 6c  root/src/gcc-13.2.0/libgcc/emutl
140035220  73 2e 63 00 43 3a 5c 62 75 69 6c 64 72 6f 6f 74 5c 78 38 36 5f 36 34 2d 31 33 32 30 2d 70 6f 73  s.c.C:\buildroot\x86_64-1320-pos
140035240  69 78 2d 73 65 68 2d 75 63 72 74 2d 72 74 5f 76 31 31 2d 72 65 76 30 5c 62 75 69 6c 64 5c 67 63  ix-seh-ucrt-rt_v11-rev0\build\gc
140035260  63 2d 31 33 2e 32 2e 30 5c 78 38 36 5f 36 34 2d 77 36 34 2d 6d 69 6e 67 77 33 32 5c 6c 69 62 67  c-13.2.0\x86_64-w64-mingw32\libg
140035280  63 63 00 43 3a 2f 62 75 69 6c 64 72 6f 6f 74 2f 78 38 36 5f 36 34 2d 31 33 32 30 2d 70 6f 73 69  cc.C:/buildroot/x86_64-1320-posi
1400352a0  78 2d 73 65 68 2d 75 63 72 74 2d 72 74 5f 76 31 31 2d 72 65 76 30 2f 62 75 69 6c 64 2f 67 63 63  x-seh-ucrt-rt_v11-rev0/build/gcc
1400352c0  2d 31 33 2e 32 2e 30 2f 78 38 36 5f 36 34 2d 77 36 34 2d 6d 69 6e 67 77 33 32 2f 6c 69 62 67 63  -13.2.0/x86_64-w64-mingw32/libgc
1400352e0  63 00 43 3a 2f 62 75 69 6c 64 72 6f 6f 74 2f 73 72 63 2f 67 63 63 2d 31 33 2e 32 2e 30 2f 6c 69  c.C:/buildroot/src/gcc-13.2.0/li
140035300  62 67 63 63 00 43 3a 2f 62 75 69 6c 64 72 6f 6f 74 2f 78 38 36 5f 36 34 2d 31 33 32 30 2d 70 6f  bgcc.C:/buildroot/x86_64-1320-po
140035320  73 69 78 2d 73 65 68 2d 75 63 72 74 2d 72 74 5f 76 31 31 2d 72 65 76 30 2f 6d 69 6e 67 77 36 34  six-seh-ucrt-rt_v11-rev0/mingw64
140035340  2f 6d 69 6e 67 77 2f 69 6e 63 6c 75 64 65 00 43 3a 2f 62 75 69 6c 64 72 6f 6f 74 2f 73 72 63 2f  /mingw/include.C:/buildroot/src/
140035360  67 63 63 2d 31 33 2e 32 2e 30 2f 67 63 63 2f 63 6f 6e 66 69 67 2f 69 33 38 36 00 65 6d 75 74 6c  gcc-13.2.0/gcc/config/i386.emutl
140035380  73 2e 63 00 65 6d 75 74 6c 73 2e 63 00 2e 2f 67 74 68 72 2d 64 65 66 61 75 6c 74 2e 68 00 63 6f  s.c.emutls.c../gthr-default.h.co
1400353a0  72 65 63 72 74 2e 68 00 69 33 38 36 2e 68 00 70 74 68 72 65 61 64 2e 68 00 73 74 72 69 6e 67 2e  recrt.h.i386.h.pthread.h.string.
1400353c0  68 00 73 74 64 6c 69 62 2e 68 00 3c 62 75 69 6c 74 2d 69 6e 3e 00                                h.stdlib.h.<built-in>.
.debug_line_str section ended  {0x140035000-0x1400353d6}

.debug_loclists section started  {0x140036000-0x1400362f8}
140036000  _.debug_loclists:
140036000  f4 02 00 00 05 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 90 01 a6 01 01  ................................
140036020  52 04 a6 01 e1 01 01 55 04 e1 01 e5 01 04 a3 01 52 9f 04 e5 01 f6 01 01 52 04 f6 01 c2 03 01 55  R......U........R.......R......U
140036040  04 c2 03 c6 03 04 a3 01 52 9f 04 c6 03 8d 05 01 55 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ........R.......U...............
140036060  00 00 04 9e 01 c9 01 01 54 04 c9 01 d7 01 03 74 01 9f 04 e5 01 d0 02 01 54 04 d0 02 e9 02 03 74  ........T......t........T......t
140036080  01 9f 04 c6 03 a9 04 01 54 04 d3 04 e3 04 01 54 04 e3 04 ea 04 02 75 10 04 ea 04 f3 04 01 54 00  ........T......T......u.......T.
1400360a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 b7 01 c5 01 01 50 04 c5 01  ............................P...
1400360c0  df 01 01 53 04 a1 02 b5 02 01 50 04 b5 02 c0 02 01 53 04 c0 02 da 02 01 50 04 da 02 c0 03 01 53  ...S......P......S......P......S
1400360e0  04 c6 03 dc 03 01 50 04 dc 03 f6 03 01 53 04 f6 03 95 04 01 50 04 95 04 d3 04 01 53 04 f3 04 8d  ......P......S......P......S....
140036100  05 01 53 00 00 00 00 00 01 00 00 00 04 ce 01 e5 01 01 52 04 e0 02 86 03 01 52 04 b3 03 c6 03 01  ..S...............R......R......
140036120  52 04 a9 04 b5 04 01 52 00 02 00 04 e5 01 fb 01 0a 03 20 40 01 40 01 00 00 00 9f 00 02 00 04 e5  R......R.......... @.@..........
140036140  01 fb 01 0a 03 d0 72 02 40 01 00 00 00 9f 00 02 00 04 fb 01 8a 02 0a 03 e8 72 02 40 01 00 00 00  ......r.@................r.@....
140036160  9f 00 01 00 04 97 02 9f 02 0a 03 e8 72 02 40 01 00 00 00 9f 00 00 00 04 ba 02 e9 02 01 56 00 01  ............r.@..............V..
140036180  00 00 00 04 d3 02 da 02 01 50 04 da 02 db 02 01 53 00 01 00 04 d3 02 da 02 01 52 00 01 00 04 c6  .........P......S.........R.....
1400361a0  03 a9 04 01 56 00 00 00 00 00 00 00 04 d5 03 87 04 01 5c 04 87 04 95 04 02 70 00 04 95 04 a9 04  ....V.............\......p......
1400361c0  29 74 20 76 00 31 24 76 00 31 24 23 80 80 80 80 80 80 80 80 80 01 74 00 23 80 80 80 80 80 80 80  )t v.1$v.1$#..........t.#.......
1400361e0  80 80 01 2d 28 01 00 16 13 9f 00 01 00 04 96 04 a4 04 01 53 00 01 00 04 96 04 a3 04 09 03 e0 72  ...-(..............S...........r
140036200  02 40 01 00 00 00 00 01 00 04 a6 01 b0 01 09 03 e0 72 02 40 01 00 00 00 00 01 01 00 00 00 00 04  .@...............r.@............
140036220  e9 02 b3 03 01 55 04 a9 04 d3 04 01 55 04 f3 04 87 05 01 55 00 00 00 00 00 00 00 04 8b 03 af 03  .....U......U......U............
140036240  01 50 04 ba 04 d3 04 01 50 04 f3 04 fe 04 01 50 00 00 00 00 00 00 00 04 9b 03 af 03 01 52 04 ca  .P......P......P.............R..
140036260  04 d3 04 01 52 04 f3 04 fe 04 01 52 00 01 00 04 54 62 0a 03 e8 72 02 40 01 00 00 00 9f 00 02 00  ....R......R....Tb...r.@........
140036280  04 62 75 0a 03 d0 3f 01 40 01 00 00 00 9f 00 02 00 04 62 75 0a 03 e0 72 02 40 01 00 00 00 9f 00  .bu...?.@.........bu...r.@......
1400362a0  00 00 00 00 00 00 00 00 04 00 14 01 52 04 14 3d 01 54 04 3d 42 01 52 04 42 43 04 a3 01 52 9f 00  ............R..=.T.=B.R.BC...R..
1400362c0  01 00 00 00 00 00 00 00 04 07 14 01 52 04 14 3d 01 54 04 3d 42 01 52 04 42 43 04 a3 01 52 9f 00  ............R..=.T.=B.R.BC...R..
1400362e0  00 00 04 0a 3e 01 55 00 02 00 00 00 04 0a 14 02 30 9f 04 14 34 01 53 00                          ....>.U.........0...4.S.
.debug_loclists section ended  {0x140036000-0x1400362f8}

.debug_rnglists section started  {0x140037000-0x14003704d}
140037000  _.debug_rnglists:
140037000  49 00 00 00 05 00 08 00 00 00 00 00 04 a6 01 b1 01 04 b4 01 b7 01 00 04 e8 01 a8 02 04 d8 04 f8  I...............................
140037020  04 00 04 a8 02 cc 02 04 d0 02 db 02 04 87 05 8d 05 00 04 c6 02 cc 02 04 d3 02 db 02 00 04 f0 02  ................................
140037040  b3 03 04 b0 04 d8 04 04 f8 04 87 05 00                                                           .............
.debug_rnglists section ended  {0x140037000-0x14003704d}

.extern section started  {0x140037050-0x1400373a8}
140037050  extern void* AddVectoredExceptionHandler(uint32_t First, PVECTORED_EXCEPTION_HANDLER Handler)
140037058  extern BOOL CloseHandle(HANDLE hObject)
140037060  extern HANDLE CreateEventA(SECURITY_ATTRIBUTES* lpEventAttributes, BOOL bManualReset, BOOL bInitialState, PSTR lpName)
140037068  extern HANDLE CreateSemaphoreA(SECURITY_ATTRIBUTES* lpSemaphoreAttributes, int32_t lInitialCount, int32_t lMaximumCount, PSTR lpName)
140037070  extern void DeleteCriticalSection(CRITICAL_SECTION* lpCriticalSection)
140037078  extern BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, HANDLE* lpTargetHandle, uint32_t dwDesiredAccess, BOOL bInheritHandle, enum DUPLICATE_HANDLE_OPTIONS dwOptions)
140037080  extern void EnterCriticalSection(CRITICAL_SECTION* lpCriticalSection)
140037088  extern HANDLE GetCurrentProcess()
140037090  extern uint32_t GetCurrentProcessId()
140037098  extern HANDLE GetCurrentThread()
1400370a0  extern uint32_t GetCurrentThreadId()
1400370a8  extern BOOL GetHandleInformation(HANDLE hObject, uint32_t* lpdwFlags)
1400370b0  extern enum WIN32_ERROR GetLastError()
1400370b8  extern FARPROC GetProcAddress(HMODULE hModule, PSTR lpProcName)
1400370c0  extern BOOL GetProcessAffinityMask(HANDLE hProcess, uint64_t* lpProcessAffinityMask, uint64_t* lpSystemAffinityMask)
1400370c8  extern void GetSystemTimeAsFileTime(FILETIME* lpSystemTimeAsFileTime)
1400370d0  extern BOOL GetThreadContext(HANDLE hThread, CONTEXT* lpContext)
1400370d8  extern int32_t GetThreadPriority(HANDLE hThread)
1400370e0  extern uint64_t GetTickCount64()
1400370e8  extern void InitializeCriticalSection(CRITICAL_SECTION* lpCriticalSection)
1400370f0  extern BOOL IsDebuggerPresent()
1400370f8  extern void LeaveCriticalSection(CRITICAL_SECTION* lpCriticalSection)
140037100  extern HMODULE LoadLibraryA(PSTR lpLibFileName)
140037108  extern HANDLE OpenProcess(enum PROCESS_ACCESS_RIGHTS dwDesiredAccess, BOOL bInheritHandle, uint32_t dwProcessId)
140037110  extern void OutputDebugStringA(PSTR lpOutputString)
140037118  extern void RaiseException(uint32_t dwExceptionCode, uint32_t dwExceptionFlags, uint32_t nNumberOfArguments, uint64_t* lpArguments) __noreturn
140037120  extern BOOL ReleaseSemaphore(HANDLE hSemaphore, int32_t lReleaseCount, int32_t* lpPreviousCount)
140037128  extern uint32_t RemoveVectoredExceptionHandler(void* Handle)
140037130  extern BOOL ResetEvent(HANDLE hEvent)
140037138  extern uint32_t ResumeThread(HANDLE hThread)
140037140  extern BOOL SetEvent(HANDLE hEvent)
140037148  extern void SetLastError(enum WIN32_ERROR dwErrCode)
140037150  extern BOOL SetProcessAffinityMask(HANDLE hProcess, uint64_t dwProcessAffinityMask)
140037158  extern BOOL SetThreadContext(HANDLE hThread, CONTEXT* lpContext)
140037160  extern BOOL SetThreadPriority(HANDLE hThread, enum THREAD_PRIORITY nPriority)
140037168  extern LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
140037170  extern void Sleep(uint32_t dwMilliseconds)
140037178  extern uint32_t SuspendThread(HANDLE hThread)
140037180  extern uint32_t TlsAlloc()
140037188  extern void* TlsGetValue(uint32_t dwTlsIndex)
140037190  extern BOOL TlsSetValue(uint32_t dwTlsIndex, void* lpTlsValue)
140037198  extern BOOL TryEnterCriticalSection(CRITICAL_SECTION* lpCriticalSection)
1400371a0  extern void* VirtualAlloc(void* lpAddress, uint64_t dwSize, enum VIRTUAL_ALLOCATION_TYPE flAllocationType, enum PAGE_PROTECTION_FLAGS flProtect)
1400371a8  extern BOOL VirtualFree(void* lpAddress, uint64_t dwSize, enum VIRTUAL_FREE_TYPE dwFreeType)
1400371b0  extern BOOL VirtualProtect(void* lpAddress, uint64_t dwSize, enum PAGE_PROTECTION_FLAGS flNewProtect, enum PAGE_PROTECTION_FLAGS* lpflOldProtect)
1400371b8  extern uint64_t VirtualQuery(void* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, uint64_t dwLength)
1400371c0  extern enum WAIT_EVENT WaitForMultipleObjects(uint32_t nCount, HANDLE* lpHandles, BOOL bWaitAll, uint32_t dwMilliseconds)
1400371c8  extern enum WAIT_EVENT WaitForSingleObject(HANDLE hHandle, uint32_t dwMilliseconds)
1400371d0  extern __C_specific_handler
1400371d8  extern FILE* __acrt_iob_func(uint32_t _Ix)
1400371e0  extern int32_t* __daylight()
1400371e8  extern int64_t __intrinsic_setjmpex(int64_t* arg1)
1400371f0  extern int32_t* __p___argc()
1400371f8  extern char*** __p___argv()
140037200  extern wchar16*** __p___wargv()
140037208  extern int32_t* __p__commode()
140037210  extern char*** __p__environ()
140037218  extern int32_t* __p__fmode()
140037220  extern wchar16*** __p__wenviron()
140037228  extern void __setusermatherr(_UserMathErrorFunctionPointer _UserMathErrorFunction)
140037230  extern int32_t __stdio_common_vfprintf(uint64_t _Options, FILE* _Stream, char const* _Format, _locale_t _Locale, va_list _ArgList)
140037238  extern int32_t __stdio_common_vfwprintf(uint64_t _Options, FILE* _Stream, wchar16 const* _Format, _locale_t _Locale, va_list _ArgList)
140037240  extern int32_t* __timezone()
140037248  extern char** __tzname()
140037250  extern uintptr_t _beginthreadex(void* _Security, uint32_t _StackSize, _beginthreadex_proc_type _StartAddress, void* _ArgList, uint32_t _InitFlag, uint32_t* _ThrdAddr)
140037258  extern void _cexit()
140037260  extern errno_t _configure_narrow_argv(enum _crt_argv_mode mode)
140037268  extern errno_t _configure_wide_argv(enum _crt_argv_mode mode)
140037270  extern int32_t _crt_at_quick_exit(_PVFV _Function)
140037278  extern int32_t _crt_atexit(_PVFV _Function)
140037280  extern void _endthreadex(uint32_t _ReturnCode)
140037288  extern int32_t* _errno()
140037290  extern void _exit(int32_t _Except) __noreturn
140037298  extern int32_t _fileno(FILE* _Stream)
1400372a0  extern int32_t _initialize_narrow_environment()
1400372a8  extern int32_t _initialize_wide_environment()
1400372b0  extern void _initterm(_PVFV* _First, _PVFV* _Last)
1400372b8  extern void _lock_file(FILE* _Stream)
1400372c0  extern void _set_app_type(enum _crt_app_type _Type)
1400372c8  extern _invalid_parameter_handler_1 _set_invalid_parameter_handler(_invalid_parameter_handler_1 _Handler)
1400372d0  extern int32_t _set_new_mode(int32_t _NewMode)
1400372d8  extern int32_t _setmode(int32_t _FileHandleSrc, int32_t _FileHandleDst)
1400372e0  extern char* _strdup(char const* _Source)
1400372e8  extern void _tzset()
1400372f0  extern char* _ultoa(uint32_t _Value, char* _Buffer, int32_t _Radix)
1400372f8  extern void _unlock_file(FILE* _Stream)
140037300  extern void abort() __noreturn
140037308  extern void* calloc(uint64_t _Count, uint64_t _Size)
140037310  extern void exit(int32_t _Except) __noreturn
140037318  extern int32_t fflush(FILE* _Stream)
140037320  extern int32_t fputc(int32_t _Character, FILE* _Stream)
140037328  extern void free(void* _Block)
140037330  extern uint64_t fwrite(void const* _Buffer, uint64_t _ElementSize, uint64_t _ElementCount, FILE* _Stream)
140037338  extern struct lconv* localeconv()
140037340  extern void longjmp(jmp_buf& _Buf, int32_t _Value) __noreturn
140037348  extern void* malloc(uint64_t _Size)
140037350  extern uint64_t mbrtowc(wchar16* _DstCh, char const* _SrcCh, uint64_t _SizeInBytes, mbstate_t* _State)
140037358  extern void* memcpy(void* _Dst, void const* _Src, uint64_t _Size)
140037360  extern void* memmove(void* _Dst, void const* _Src, uint64_t _Size)
140037368  extern void* memset(void* _Dst, int32_t _Val, uint64_t _Size)
140037370  extern void* realloc(void* _Block, uint64_t _Size)
140037378  extern _crt_signal_t signal(int32_t _Signal, _crt_signal_t _Function)
140037380  extern char* strerror(char const* _Source)
140037388  extern uint64_t strlen(char const* _Str)
140037390  extern int32_t strncmp(char const* _Str1, char const* _Str2, uint64_t _MaxCount)
140037398  extern uint64_t wcrtomb(char* _Dest, wchar16 _Source, mbstate_t* _State)
1400373a0  extern uint64_t wcslen(wchar16 const* _String)
.extern section ended  {0x140037050-0x1400373a8}

.synthetic_builtins section started  {0x1400373b0-0x1400373e0}
1400373b0  extern void* __builtin_memcpy(void* dest, void const* src, uint64_t count)
1400373b8  extern void* __builtin_memset(void* dest, int32_t ch, uint64_t count)
1400373c0  extern char* __builtin_strcpy(char* dest, char const* src)
1400373c8  extern char* __builtin_strncpy(char* dest, char const* src, uint64_t count)
1400373d0  extern wchar16* __builtin_wcscpy(wchar16* dest, wchar16 const* src)
1400373d8  extern wchar16* __builtin_wmemcpy(wchar16* dest, wchar16 const* src, uint64_t count)
.synthetic_builtins section ended  {0x1400373b0-0x1400373e0}

