/*
Type: PE
Platform: windows-x86
Architecture: x86

Libraries: 
  KERNEL32.dll
  USER32.dll

Compiler(s) Used: 
  Imported Functions (73 objects)
  MASM 6.13.7299 (40 objects)
  VS97 v5.0 SP3 link 5.10.7303 and VS98 v6.0 RTM/SP1/SP2 build 8168 (5 objects)
  VC++ 6.0 SP3 build 8447 (29 objects)
  VB 6.0 SP6 / VC++ build 9782 (159 objects)

Segments:
r--  0x00400000-0x00401000 
r-x  0x00401000-0x004274bc  {Code}
r--  0x00428000-0x0042a262  {Data}
rw-  0x0042b000-0x00431000  {Data}
rw-  0x00431000-0x00431f58  {Data}
---  0x00431f60-0x00432080 
---  0x00432080-0x00432098 

Sections:
0x00401000-0x004274bc  .text  {Code}
0x00428000-0x0042a262  .rdata  {Read-only data}
0x0042b000-0x00431f58  .data  {Writable data}
0x00431f60-0x00432080  .extern  {External}
0x00432080-0x00432098  .synthetic_builtins  {External}
*/
00400000  struct DOS_Header __dos_header = 
00400000  {
00400000      char e_magic[0x2] = "MZ"
00400002      uint16_t e_cblp = 0x90
00400004      uint16_t e_cp = 0x3
00400006      uint16_t e_crlc = 0x0
00400008      uint16_t e_cparhdr = 0x4
0040000a      uint16_t e_minalloc = 0x0
0040000c      uint16_t e_maxalloc = 0xffff
0040000e      uint16_t e_ss = 0x0
00400010      uint16_t e_sp = 0xb8
00400012      uint16_t e_csum = 0x0
00400014      uint16_t e_ip = 0x0
00400016      uint16_t e_cs = 0x0
00400018      uint16_t e_lfarlc = 0x40
0040001a      uint16_t e_ovno = 0x0
0040001c      char e_res1[0x8] = "\x00\x00\x00\x00\x00\x00\x00", 0
00400024      uint16_t e_oemid = 0x0
00400026      uint16_t e_oeminfo = 0x0
00400028      char e_res2[0x14] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 0
0040003c      uint32_t e_lfanew = 0xd0
00400040  }

00400040  __dos_stub:
00400040  0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f  ........!..L.!This program canno
00400060  74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00  t be run in DOS mode....$.......

00400080  struct Rich_Header __rich_header = 
00400080  {
00400080      uint32_t e_magic__DanS = 0xa987dc3d
00400084      uint32_t e_align[0x3] = 
00400084      {
00400084          [0x0] =  0xfae9bd79
00400088          [0x1] =  0xfae9bd79
0040008c          [0x2] =  0xfae9bd79
00400090      }
00400090      uint32_t e_entry_id0__000b2636 = 0xfae29b4f
00400094      uint32_t e_entry_count0__1 = 0xfae9bd78
00400098      uint32_t e_entry_id1__000e1c83 = 0xfae7a1fa
0040009c      uint32_t e_entry_count1__40 = 0xfae9bd51
004000a0      uint32_t e_entry_id2__00131f62 = 0xfafaa21b
004000a4      uint32_t e_entry_count2__5 = 0xfae9bd7c
004000a8      uint32_t e_entry_id3__00010000 = 0xfae8bd79
004000ac      uint32_t e_entry_count3__73 = 0xfae9bd30
004000b0      uint32_t e_entry_id4__000a20ff = 0xfae39d86
004000b4      uint32_t e_entry_count4__29 = 0xfae9bd64
004000b8      uint32_t e_entry_id5__000a2636 = 0xfae39b4f
004000bc      uint32_t e_entry_count5__158 = 0xfae9bde7
004000c0      char e_magic[0x4] = "Rich"
004000c4      uint32_t e_checksum = 0xfae9bd79
004000c8  }

004000c8                          00 00 00 00 00 00 00 00                                                          ........

004000d0  struct COFF_Header __coff_header = 
004000d0  {
004000d0      char magic[0x4] = "PE\x00", 0
004000d4      enum coff_machine machine = IMAGE_FILE_MACHINE_I386
004000d6      uint16_t numberOfSections = 0x3
004000d8      uint32_t timeDateStamp = 0x4453813b
004000dc      uint32_t pointerToSymbolTable = 0x0
004000e0      uint32_t numberOfSymbols = 0x0
004000e4      uint16_t sizeOfOptionalHeader = 0xe0
004000e6      enum coff_characteristics characteristics = IMAGE_FILE_RELOCS_STRIPPED | IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED | IMAGE_FILE_32BIT_MACHINE
004000e8  }
004000e8  struct PE32_Optional_Header __pe32_optional_header = 
004000e8  {
004000e8      enum pe_magic magic = PE_32BIT
004000ea      uint8_t majorLinkerVersion = 0x6
004000eb      uint8_t minorLinkerVersion = 0x0
004000ec      uint32_t sizeOfCode = 0x27000
004000f0      uint32_t sizeOfInitializedData = 0xa000
004000f4      uint32_t sizeOfUninitializedData = 0x0
004000f8      uint32_t addressOfEntryPoint = 0x1712b
004000fc      uint32_t baseOfCode = 0x1000
00400100      uint32_t baseOfData = 0x28000
00400104      uint32_t imageBase = 0x400000
00400108      uint32_t sectionAlignment = 0x1000
0040010c      uint32_t fileAlignment = 0x1000
00400110      uint16_t majorOperatingSystemVersion = 0x4
00400112      uint16_t minorOperatingSystemVersion = 0x0
00400114      uint16_t majorImageVersion = 0x0
00400116      uint16_t minorImageVersion = 0x0
00400118      uint16_t majorSubsystemVersion = 0x4
0040011a      uint16_t minorSubsystemVersion = 0x0
0040011c      uint32_t win32VersionValue = 0x0
00400120      uint32_t sizeOfImage = 0x32000
00400124      uint32_t sizeOfHeaders = 0x1000
00400128      uint32_t checkSum = 0x0
0040012c      enum pe_subsystem subsystem = IMAGE_SUBSYSTEM_WINDOWS_CUI
0040012e      enum pe_dll_characteristics dllCharacteristics = 0
00400130      uint32_t sizeOfStackReserve = 0x100000
00400134      uint32_t sizeOfStackCommit = 0x1000
00400138      uint32_t sizeOfHeapReserve = 0x100000
0040013c      uint32_t sizeOfHeapCommit = 0x1000
00400140      uint32_t loaderFlags = 0x0
00400144      uint32_t numberOfRvaAndSizes = 0x10
00400148      struct PE_Data_Directory_Entry exportTableEntry = 
00400148      {
00400148          uint32_t virtualAddress = 0x0
0040014c          uint32_t size = 0x0
00400150      }
00400150      struct PE_Data_Directory_Entry importTableEntry = 
00400150      {
00400150          uint32_t virtualAddress = 0x29be4
00400154          uint32_t size = 0x3c
00400158      }
00400158      struct PE_Data_Directory_Entry resourceTableEntry = 
00400158      {
00400158          uint32_t virtualAddress = 0x0
0040015c          uint32_t size = 0x0
00400160      }
00400160      struct PE_Data_Directory_Entry exceptionTableEntry = 
00400160      {
00400160          uint32_t virtualAddress = 0x0
00400164          uint32_t size = 0x0
00400168      }
00400168      struct PE_Data_Directory_Entry certificateTableEntry = 
00400168      {
00400168          uint32_t virtualAddress = 0x0
0040016c          uint32_t size = 0x0
00400170      }
00400170      struct PE_Data_Directory_Entry baseRelocationTableEntry = 
00400170      {
00400170          uint32_t virtualAddress = 0x0
00400174          uint32_t size = 0x0
00400178      }
00400178      struct PE_Data_Directory_Entry debugEntry = 
00400178      {
00400178          uint32_t virtualAddress = 0x0
0040017c          uint32_t size = 0x0
00400180      }
00400180      struct PE_Data_Directory_Entry architectureEntry = 
00400180      {
00400180          uint32_t virtualAddress = 0x0
00400184          uint32_t size = 0x0
00400188      }
00400188      struct PE_Data_Directory_Entry globalPtrEntry = 
00400188      {
00400188          uint32_t virtualAddress = 0x0
0040018c          uint32_t size = 0x0
00400190      }
00400190      struct PE_Data_Directory_Entry tlsTableEntry = 
00400190      {
00400190          uint32_t virtualAddress = 0x0
00400194          uint32_t size = 0x0
00400198      }
00400198      struct PE_Data_Directory_Entry loadConfigTableEntry = 
00400198      {
00400198          uint32_t virtualAddress = 0x0
0040019c          uint32_t size = 0x0
004001a0      }
004001a0      struct PE_Data_Directory_Entry boundImportEntry = 
004001a0      {
004001a0          uint32_t virtualAddress = 0x0
004001a4          uint32_t size = 0x0
004001a8      }
004001a8      struct PE_Data_Directory_Entry iatEntry = 
004001a8      {
004001a8          uint32_t virtualAddress = 0x28000
004001ac          uint32_t size = 0x128
004001b0      }
004001b0      struct PE_Data_Directory_Entry delayImportDescriptorEntry = 
004001b0      {
004001b0          uint32_t virtualAddress = 0x0
004001b4          uint32_t size = 0x0
004001b8      }
004001b8      struct PE_Data_Directory_Entry clrRuntimeHeaderEntry = 
004001b8      {
004001b8          uint32_t virtualAddress = 0x0
004001bc          uint32_t size = 0x0
004001c0      }
004001c0      struct PE_Data_Directory_Entry reservedEntry = 
004001c0      {
004001c0          uint32_t virtualAddress = 0x0
004001c4          uint32_t size = 0x0
004001c8      }
004001c8  }
004001c8  struct Section_Header __section_headers[0x3] = 
004001c8  {
004001c8      [0x0] = 
004001c8      {
004001c8          char name[0x8] = ".text\x00\x00", 0
004001d0          uint32_t virtualSize = 0x264bc
004001d4          uint32_t virtualAddress = 0x1000
004001d8          uint32_t sizeOfRawData = 0x27000
004001dc          uint32_t pointerToRawData = 0x1000
004001e0          uint32_t pointerToRelocations = 0x0
004001e4          uint32_t pointerToLineNumbers = 0x0
004001e8          uint16_t numberOfRelocations = 0x0
004001ea          uint16_t numberOfLineNumbers = 0x0
004001ec          enum pe_section_flags characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ
004001f0      }
004001f0      [0x1] = 
004001f0      {
004001f0          char name[0x8] = ".rdata\x00", 0
004001f8          uint32_t virtualSize = 0x2262
004001fc          uint32_t virtualAddress = 0x28000
00400200          uint32_t sizeOfRawData = 0x3000
00400204          uint32_t pointerToRawData = 0x28000
00400208          uint32_t pointerToRelocations = 0x0
0040020c          uint32_t pointerToLineNumbers = 0x0
00400210          uint16_t numberOfRelocations = 0x0
00400212          uint16_t numberOfLineNumbers = 0x0
00400214          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ
00400218      }
00400218      [0x2] = 
00400218      {
00400218          char name[0x8] = ".data\x00\x00", 0
00400220          uint32_t virtualSize = 0x6f58
00400224          uint32_t virtualAddress = 0x2b000
00400228          uint32_t sizeOfRawData = 0x6000
0040022c          uint32_t pointerToRawData = 0x2b000
00400230          uint32_t pointerToRelocations = 0x0
00400234          uint32_t pointerToLineNumbers = 0x0
00400238          uint16_t numberOfRelocations = 0x0
0040023a          uint16_t numberOfLineNumbers = 0x0
0040023c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
00400240      }
00400240  }

00400240  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400260  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400280  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004002a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004002c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004002e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004003a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004003c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004003e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400400  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400460  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004004a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004004c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004004e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004005a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004005c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004005e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400600  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400620  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400640  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400660  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400680  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004006a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004006c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004006e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400700  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400720  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400760  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004007a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004007c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004007e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400800  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400820  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400860  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400880  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004008a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004008c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004008e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400900  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400920  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400940  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400960  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400980  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004009a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004009c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004009e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400aa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ac0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ae0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ba0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400bc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400be0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ca0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400cc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ce0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400da0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400dc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400de0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ea0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ec0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ee0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400fa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400fc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400fe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

.text section started  {0x401000-0x4274bc}

00401000    int32_t sub_401000(PSTR* arg1)

00401000  {
00401014      uint8_t filename[0x104];
00401014      uint32_t hWnd = GetModuleFileNameA(nullptr, &filename, 0x104);
00401014      
0040101c      if (!hWnd)
0040101c      {
00401030          MessageBoxA(hWnd, "cannot locate this executable", *(uint32_t*)arg1, MB_ICONHAND);
00401043          return 1;
0040101c      }
0040101c      
0040104f      *(uint32_t*)arg1 = &filename;
00401051      int32_t* hWnd_1 = sub_403b50();
00401051      
0040105a      if (!hWnd_1)
0040105a      {
00401067          MessageBoxA(hWnd_1, "not enough memory for state", *(uint32_t*)arg1, MB_ICONHAND);
0040107a          return 1;
0040105a      }
0040105a      
0040108c      if (sub_402810(hWnd_1, sub_4010c0, arg1))
004010a3          MessageBoxA(nullptr, sub_401db0(hWnd_1, 0xffffffff, nullptr), *(uint32_t*)arg1, 
004010a3              MB_ICONHAND);
004010a3      
004010aa      sub_401700(hWnd_1);
004010bc      return 0;
00401000  }

004010bd                                                                                         90 90 90                               ...

004010c0    int32_t sub_4010c0(int32_t arg1)

004010c0  {
004010c3      void* esi = arg1;
004010cb      int32_t* eax = sub_401ed0(esi, 1);
004010d3      sub_403be0(esi);
004010dc      sub_4011c0(esi, *(uint32_t*)eax);
004010e6      sub_402330(esi, 0, 0);
004010eb      char* i = *(uint32_t*)eax;
004010f0      int32_t edi = 0;
004010f0      
004010f4      if (i)
004010f4      {
004010f6          int32_t* ebp_1 = eax;
004010f6          
00401114          do
00401114          {
004010fa              sub_402040(esi, i);
00401103              sub_402570(esi, 0xfffffffe, edi);
00401108              i = ebp_1[1];
0040110b              ebp_1 = &ebp_1[1];
00401111              edi += 1;
00401114          } while (i);
004010f4      }
004010f4      
0040111e      sub_401ff0(esi, U"n", 1);
00401129      arg1 = edi - 1;
00401135      sub_401fa0(esi, 0x42b0ac);
0040113d      sub_402500(esi, 0xfffffffd);
0040114d      sub_402490(esi, 0xffffd8ee, "arg");
00401156      sub_402040(esi, *(uint32_t*)eax);
00401166      sub_402490(esi, 0xffffd8ee, "_PROGNAME");
00401172      sub_402ff0(esi, edi, "too many arguments to script");
00401177      char* i_1 = eax[1];
00401180      int32_t ebp_2 = 1;
00401180      
00401187      if (i_1)
00401187      {
00401189          void* edi_1 = &eax[1];
00401189          
0040119e          do
0040119e          {
0040118d              sub_402040(esi, i_1);
00401192              i_1 = *(uint32_t*)((char*)edi_1 + 4);
00401195              edi_1 += 4;
0040119b              ebp_2 += 1;
0040119e          } while (i_1);
00401187      }
00401187      
004011a5      sub_402730(esi, ebp_2 - 1, 0);
004011b3      return 0;
004010c0  }

004011b4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

004011c0    int32_t sub_4011c0(void* arg1, void* arg2)

004011c0  {
004011d6      int32_t* eax = sub_417118(arg2, "rb");
004011d6      
004011ed      if (!eax)
004011ed      {
004011f5          sub_416fca(data_4307d4);
004011fa          int32_t var_230_1 = 0x4307ac;
004011fb          void* var_234_1 = arg2;
004011fc          char* var_238_1 = "open";
00401207          sub_402e40(arg1, "cannot %s %s: %s");
004011ed      }
004011ed      
0040121e      if (sub_416f3e(eax, 0xfffffff0, FILE_END))
0040121e      {
00401227          sub_416fca(data_4307d4);
0040122c          int32_t var_230_2 = 0x4307ac;
0040122d          void* var_234_3 = arg2;
0040122e          char* var_238_2 = "seek";
00401239          sub_402e40(arg1, "cannot %s %s: %s");
0040121e      }
0040121e      
00401256      void var_218;
00401256      
00401256      if (sub_416e56(&var_218, 0x10, 1, eax) != 1)
00401256      {
0040125e          sub_416fca(data_4307d4);
00401263          int32_t var_230_3 = 0x4307ac;
00401264          void* var_234_4 = arg2;
00401265          char* var_238_4 = "read";
00401270          sub_402e40(arg1, "cannot %s %s: %s");
00401256      }
00401256      
00401279      int32_t i = 2;
0040127e      char* edi = "%%glue:L";
00401283      void* esi_1 = &var_218;
00401287      bool cond:1 = true;
00401287      
00401289      while (i)
00401289      {
00401289          int32_t temp0_1 = *(uint32_t*)esi_1;
00401289          int32_t temp1_1 = *(uint32_t*)edi;
00401289          cond:1 = temp0_1 == temp1_1;
00401289          esi_1 += 4;
00401289          edi = &edi[4];
00401289          i -= 1;
00401289          
00401289          if (temp0_1 != temp1_1)
00401289              break;
00401289      }
00401289      
0040128c      if (!cond:1)
0040128c      {
0040128e          void* __saved_edi_5 = arg2;
00401295          sub_402e40(arg1, "no Lua program found in %s");
0040128c      }
0040128c      
004012b3      void* var_210;
004012b3      
004012b3      if (sub_416f3e(eax, var_210, FILE_BEGIN))
004012b3      {
004012bc          sub_416fca(data_4307d4);
004012c1          int32_t var_230_5 = 0x4307ac;
004012c2          void* var_234_7 = arg2;
004012c3          char* var_238_5 = "seek";
004012ce          sub_402e40(arg1, "cannot %s %s: %s");
004012b3      }
004012b3      
004012e6      int32_t* var_208 = eax;
004012ea      int32_t var_20c;
004012ea      int32_t var_204 = var_20c;
004012ea      
004012f8      if (sub_4028b0(arg1, sub_401320, &var_208, arg2))
004012fb          sub_402a30(arg1);
004012fb      
00401315      return sub_416e00(eax);
004011c0  }

00401316                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00401320    void* sub_401320(int32_t* arg1, uint32_t* arg2)

00401320  {
00401326      uint32_t eax = arg1[1];
00401326      
0040132b      if (eax <= 0)
00401331          return 0;
00401331      
00401337      if (eax >= 0x200)
00401339          eax = 0x200;
00401339      
00401348      uint32_t eax_2 = sub_416e56(&arg1[2], 1, eax, *(uint32_t*)arg1);
00401348      
00401353      if (eax_2 == 0xffffffff)
00401359          return 0;
00401359      
00401363      arg1[1] -= eax_2;
00401366      *(uint32_t*)arg2 = eax_2;
0040136c      return &arg1[2];
00401320  }

0040136d                                         90 90 90                                                               ...

00401370    int32_t* sub_401370(void* arg1)

00401370  {
0040137d      int32_t* result = sub_404d00(arg1, 0, 0, 0x78);
00401388      sub_404bc0(arg1, result, 8);
00401392      sub_401460(result, *(uint32_t*)((char*)arg1 + 0x10));
00401399      sub_4013d0(result, arg1);
004013a4      result[0x12] = *(uint32_t*)((char*)arg1 + 0x48);
004013aa      result[0x13] = *(uint32_t*)((char*)arg1 + 0x4c);
004013b0      result[0x14] = *(uint32_t*)((char*)arg1 + 0x50);
004013b3      int32_t ecx;
004013b3      (uint8_t)ecx = *(uint8_t*)((char*)arg1 + 0x36);
004013b6      *(uint8_t*)((char*)result + 0x36) = (uint8_t)ecx;
004013b9      int32_t edx_1 = *(uint32_t*)((char*)arg1 + 0x38);
004013bc      result[0xe] = edx_1;
004013c4      result[0x10] = *(uint32_t*)((char*)arg1 + 0x40);
004013c7      result[0xf] = edx_1;
004013ce      return result;
00401370  }

004013cf                                               90                                                                 .

004013d0    int32_t* sub_4013d0(void* arg1, void* arg2)

004013d0  {
004013e0      int32_t eax = sub_404d00(arg2, 0, 0, 0xc0);
004013f2      *(uint32_t*)((char*)arg1 + 0x28) = eax;
004013f5      *(uint32_t*)((char*)arg1 + 0x14) = eax;
004013fe      *(uint32_t*)((char*)arg1 + 0x30) = 8;
00401405      *(uint32_t*)((char*)arg1 + 0x24) = eax + 0xa8;
00401408      int32_t eax_2 = sub_404d00(arg2, 0, 0, 0x2d0);
0040140d      void* edx = *(uint32_t*)((char*)arg1 + 0x14);
00401416      *(uint32_t*)((char*)arg1 + 0x20) = eax_2;
00401419      *(uint32_t*)((char*)arg1 + 0x2c) = 0x2d;
00401420      *(uint32_t*)((char*)arg1 + 8) = eax_2;
00401423      *(uint32_t*)((char*)arg1 + 0x1c) = eax_2 + 0x270;
00401426      *(uint32_t*)((char*)edx + 4) = eax_2;
0040142f      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) + 8) = 0;
00401439      int32_t* ecx_1 = *(uint32_t*)((char*)arg1 + 0x14);
0040143c      int32_t edi_2 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00401441      *(uint32_t*)((char*)arg1 + 8) = edi_2;
00401444      *(uint32_t*)ecx_1 = edi_2;
00401446      int32_t* result = *(uint32_t*)((char*)arg1 + 0x14);
0040144f      int32_t ecx_3 = *(uint32_t*)((char*)arg1 + 8) + 0x140;
00401455      *(uint32_t*)((char*)arg1 + 0xc) = *(uint32_t*)result;
00401458      result[2] = ecx_3;
0040145c      return result;
004013d0  }

0040145d                                                                                         90 90 90                               ...

00401460    void* sub_401460(void* arg1, int32_t arg2)

00401460  {
00401468      *(uint32_t*)((char*)arg1 + 0x10) = arg2;
0040146d      *(uint32_t*)((char*)arg1 + 0x20) = 0;
00401470      *(uint32_t*)((char*)arg1 + 0x2c) = 0;
00401473      *(uint32_t*)((char*)arg1 + 0x70) = 0;
00401476      *(uint32_t*)((char*)arg1 + 0x40) = 0;
00401479      *(uint8_t*)((char*)arg1 + 0x36) = 0;
0040147c      *(uint32_t*)((char*)arg1 + 0x38) = 0;
0040147f      *(uint8_t*)((char*)arg1 + 0x37) = 1;
00401483      *(uint32_t*)((char*)arg1 + 0x3c) = 0;
00401486      *(uint32_t*)((char*)arg1 + 0x68) = 0;
00401489      *(uint32_t*)((char*)arg1 + 0x30) = 0;
0040148c      *(uint16_t*)((char*)arg1 + 0x34) = 0;
00401490      *(uint8_t*)((char*)arg1 + 6) = 0;
00401493      *(uint32_t*)((char*)arg1 + 0x14) = 0;
00401496      *(uint32_t*)((char*)arg1 + 0x28) = 0;
00401499      *(uint32_t*)((char*)arg1 + 0x18) = 0;
0040149c      *(uint32_t*)((char*)arg1 + 0x74) = 0;
0040149f      *(uint32_t*)((char*)arg1 + 0x50) = 0;
004014a2      return arg1;
00401460  }

004014a3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

004014b0    int32_t sub_4014b0(void* arg1, void* arg2)

004014b0  {
004014bb      sub_404f10(arg2, *(uint32_t*)((char*)arg2 + 0x20));
004014c6      sub_4014e0(arg1, arg2);
004014db      return sub_404d00(arg1, arg2, 0x78, 0);
004014b0  }

004014dc                                                                                      90 90 90 90                              ....

004014e0    int32_t sub_4014e0(void* arg1, void* arg2)

004014e0  {
004014fb      sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 0x28), 
004014fb          *(uint32_t*)((char*)arg2 + 0x30) * 0x18, 0);
00401518      return sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 0x20), 
00401518          *(uint32_t*)((char*)arg2 + 0x2c) << 4, 0);
004014e0  }

00401519                                                                             90 90 90 90 90 90 90                           .......

00401520    int32_t* sub_401520(int32_t arg1, int32_t* arg2)

00401520  {
00401531      int32_t* result = arg1(arg2, 0, 0, 0x178);
00401531      
0040153c      if (!result)
00401543          return 0;
00401543      
00401548      *(uint32_t*)result = 0;
0040154b      result[1] = 8;
00401550      result[0x23] = 0x21;
00401559      *(uint8_t*)((char*)result + 5) = 0x61;
0040155d      sub_401460(result, &result[0x1e]);
00401566      result[0x22] = arg2;
00401569      result[0x21] = arg1;
0040156f      result[0x3a] = result;
00401572      result[0x40] = &result[0x3c];
00401578      result[0x41] = &result[0x3c];
0040157e      result[0x2e] = 0;
00401581      result[0x20] = 0;
00401584      result[0x1f] = 0;
00401587      result[0x1e] = 0;
00401595      *(uint32_t*)(result[4] + 0x68) = 0;
00401598      result[0x26] = &result[0x25];
0040159b      result[0x25] = result;
004015a2      result[0x32] = 0xc8;
004015a5      result[0x33] = 0xc8;
004015b3      result[0x2d] = 0;
004015b6      result[0x34] = 0;
004015b9      *(uint8_t*)((char*)result + 0x8d) = 0;
004015bc      result[0x24] = 0;
004015bf      __builtin_memset(&result[0x27], 0, 0x14);
004015cb      result[0x2f] = 0x178;
004015d2      result[0x31] = 0;
004015db      __builtin_memset(&result[0x44], 0, 0x24);
004015db      
004015e8      if (!sub_405290(result, sub_401610, 0))
00401600          return result;
00401600      
004015eb      sub_401690(result);
004015f8      return 0;
00401520  }

00401601     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00401610    int32_t sub_401610(void* arg1)

00401610  {
00401619      void* ebx = *(uint32_t*)((char*)arg1 + 0x10);
0040161c      sub_4013d0(arg1, arg1);
0040162b      *(uint32_t*)((char*)arg1 + 0x48) = sub_407b30(arg1, 0, 2);
0040162e      *(uint32_t*)((char*)arg1 + 0x50) = 5;
0040163d      int32_t** edi_1 = *(uint32_t*)((char*)arg1 + 0x10) + 0x60;
00401648      *(uint32_t*)edi_1 = sub_407b30(arg1, 0, 2);
0040164a      edi_1[2] = 5;
00401651      sub_405ea0(arg1, 0x20);
00401657      sub_4074b0(arg1);
0040165d      sub_406120(arg1);
0040166a      void** eax_2 = sub_405f60(arg1, "not enough memory", 0x11);
0040167b      *(uint8_t*)((char*)eax_2 + 5) |= 0x20;
00401680      int32_t result = *(uint32_t*)((char*)ebx + 0x44) << 2;
00401684      *(uint32_t*)((char*)ebx + 0x40) = result;
00401689      return result;
00401610  }

0040168a                                90 90 90 90 90 90                                                            ......

00401690    int32_t sub_401690(void* arg1)

00401690  {
00401699      void* edi = *(uint32_t*)((char*)arg1 + 0x10);
0040169e      sub_404f10(arg1, *(uint32_t*)((char*)arg1 + 0x20));
004016a4      sub_403dc0(arg1);
004016a9      int32_t* eax_1 = *(uint32_t*)((char*)arg1 + 0x10);
004016b9      sub_404d00(arg1, *(uint32_t*)eax_1, eax_1[2] << 2, 0);
004016d0      *(uint32_t*)((char*)edi + 0x34) = sub_404d00(arg1, *(uint32_t*)((char*)edi + 0x34), 
004016d0          *(uint32_t*)((char*)edi + 0x3c), 0);
004016d3      *(uint32_t*)((char*)edi + 0x3c) = 0;
004016da      sub_4014e0(arg1, arg1);
004016f3      return (*(uint32_t*)((char*)edi + 0xc))(*(uint32_t*)((char*)edi + 0x10), arg1, 0x178, 
004016f3          0);
00401690  }

004016f4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00401700    int32_t sub_401700(void* arg1)

00401700  {
00401708      int32_t* esi = *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 0x70);
00401710      sub_404f10(esi, esi[8]);
00401718      sub_403c20(esi, 1);
00401720      esi[0x1d] = 0;
0040174d      int32_t i;
0040174d      
0040174d      do
0040174d      {
00401727          int32_t* eax = esi[0xa];
0040172c          esi[5] = eax;
00401734          int32_t eax_1 = *(uint32_t*)eax;
00401737          esi[2] = eax_1;
0040173a          esi[3] = eax_1;
0040173d          esi[0xd] = 0;
00401743          i = sub_405290(esi, sub_401760, 0);
0040174d      } while (i);
00401759      return sub_401690(esi);
00401700  }

0040175a                                                                                90 90 90 90 90 90                            ......

00401760    void* sub_401760(void* arg1)

00401760  {
0040176b      return sub_403cc0(arg1);
00401760  }

0040176c                                      90 90 90 90                                                              ....

00401770    int32_t sub_401770(void* arg1, int32_t* arg2)

00401770  {
00401779      int32_t* eax = *(uint32_t*)((char*)arg1 + 8);
0040177e      *(uint32_t*)eax = *(uint32_t*)arg2;
00401783      eax[1] = arg2[1];
00401789      eax[2] = arg2[2];
0040178f      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00401793      *(uint32_t*)((char*)arg1 + 8) = result;
00401796      return result;
00401770  }

00401797                                                                       90 90 90 90 90 90 90 90 90                         .........

004017a0    int32_t sub_4017a0(void* arg1, int32_t arg2)

004017a0  {
004017aa      int32_t eax = *(uint32_t*)((char*)arg1 + 8);
004017aa      
004017bf      if (((eax - *(uint32_t*)((char*)arg1 + 0xc)) >> 4) + arg2 > 0x800)
004017c5          return 0;
004017c5      
004017cb      int32_t edi_2 = arg2 << 4;
004017cb      
004017d2      if (*(uint32_t*)((char*)arg1 + 0x1c) - eax <= edi_2)
004017d6          sub_405460(arg1, arg2);
004017d6      
004017e1      void* esi_1 = *(uint32_t*)((char*)arg1 + 0x14);
004017e4      int32_t eax_3 = *(uint32_t*)((char*)arg1 + 8) + edi_2;
004017e4      
004017e9      if (*(uint32_t*)((char*)esi_1 + 8) < eax_3)
004017eb          *(uint32_t*)((char*)esi_1 + 8) = eax_3;
004017eb      
004017f5      return 1;
004017a0  }

004017f6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00401800    void sub_401800(void* arg1, void* arg2, int32_t arg3)

00401800  {
0040180d      if (arg1 == arg2)
0040180d          return;
0040180d      
0040180f      int32_t i_1 = arg3;
00401821      *(uint32_t*)((char*)arg1 + 8) += -(i_1) << 4;
00401821      
00401824      if (i_1 <= 0)
00401824          return;
00401824      
00401827      int32_t edx_1 = 0;
0040184b      int32_t i;
0040184b      
0040184b      do
0040184b      {
00401829          int32_t* ecx_3 = *(uint32_t*)((char*)arg2 + 8);
0040182f          int32_t* eax_4 = *(uint32_t*)((char*)arg1 + 8) + edx_1;
00401831          edx_1 += 0x10;
00401837          i = i_1;
00401837          i_1 -= 1;
00401838          *(uint32_t*)((char*)arg2 + 8) = &ecx_3[4];
0040183d          *(uint32_t*)ecx_3 = *(uint32_t*)eax_4;
00401842          ecx_3[1] = eax_4[1];
00401848          ecx_3[2] = eax_4[2];
0040184b      } while (i != 1);
00401800  }

00401852                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00401860    int32_t sub_401860(void* arg1, int32_t arg2)

00401860  {
00401868      void* ecx = *(uint32_t*)((char*)arg1 + 0x10);
0040186b      int32_t result = *(uint32_t*)((char*)ecx + 0x58);
0040186e      *(uint32_t*)((char*)ecx + 0x58) = arg2;
00401871      return result;
00401860  }

00401872                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00401880    int32_t* sub_401880(void* arg1)

00401880  {
00401885      void* eax = *(uint32_t*)((char*)arg1 + 0x10);
00401885      
00401890      if (*(uint32_t*)((char*)eax + 0x44) >= *(uint32_t*)((char*)eax + 0x40))
00401893          sub_403f70(arg1);
00401893      
0040189c      int32_t* result = sub_401370(arg1);
004018a1      int32_t** ecx_1 = *(uint32_t*)((char*)arg1 + 8);
004018a7      *(uint32_t*)ecx_1 = result;
004018a9      ecx_1[2] = 8;
004018b6      *(uint32_t*)((char*)arg1 + 8) += 0x10;
004018ba      return result;
00401880  }

004018bb                                                                                   90 90 90 90 90                             .....

004018c0    int32_t sub_4018c0(void* arg1)

004018c0  {
004018cf      return (*(uint32_t*)((char*)arg1 + 8) - *(uint32_t*)((char*)arg1 + 0xc)) >> 4;
004018c0  }


004018d0    void* sub_4018d0(void* arg1, int32_t arg2)

004018d0  {
004018d6      if (arg2 < 0)
004018d6      {
0040191a          *(uint32_t*)((char*)arg1 + 8) += (arg2 + 1) << 4;
0040191d          return arg1;
004018d6      }
004018d6      
004018dd      int32_t edx = arg2 << 4;
004018dd      
004018ea      if (*(uint32_t*)((char*)arg1 + 8) < *(uint32_t*)((char*)arg1 + 0xc) + edx)
004018ea      {
00401906          int32_t ecx_4;
00401906          int32_t ebx_2;
00401906          
00401906          do
00401906          {
004018ef              *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) + 8) = 0;
004018fc              ecx_4 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
004018ff              ebx_2 = *(uint32_t*)((char*)arg1 + 0xc) + edx;
00401901              *(uint32_t*)((char*)arg1 + 8) = ecx_4;
00401906          } while (ecx_4 < ebx_2);
004018ea      }
004018ea      
0040190e      *(uint32_t*)((char*)arg1 + 8) = *(uint32_t*)((char*)arg1 + 0xc) + edx;
00401911      return arg1;
004018d0  }

0040191e                                                                                            90 90                                ..

00401920    int32_t sub_401920(void* arg1, int32_t arg2)

00401920  {
00401933      void* i = sub_401970(arg1, arg2) + 0x10;
00401933      
0040193b      if (i < *(uint32_t*)((char*)arg1 + 8))
0040193b      {
0040193d          void* ecx_1 = (char*)i - 0x10;
0040193d          
0040195b          do
0040195b          {
00401940              int32_t edx_1 = *(uint32_t*)i;
00401942              i += 0x10;
00401945              *(uint32_t*)ecx_1 = edx_1;
0040194a              *(uint32_t*)((char*)ecx_1 + 4) = *(uint32_t*)((char*)i - 0xc);
00401950              *(uint32_t*)((char*)ecx_1 + 8) = *(uint32_t*)((char*)ecx_1 + 0x18);
00401956              ecx_1 += 0x10;
0040195b          } while (i < *(uint32_t*)((char*)arg1 + 8));
0040193b      }
0040193b      
00401960      int32_t result = *(uint32_t*)((char*)arg1 + 8) - 0x10;
00401963      *(uint32_t*)((char*)arg1 + 8) = result;
00401967      return result;
00401920  }

00401968                          90 90 90 90 90 90 90 90                                                          ........

00401970    void* sub_401970(void* arg1, int32_t arg2)

00401970  {
00401976      if (arg2 <= 0)
00401976      {
0040199d          if (arg2 > 0xffffd8f0)
004019ab              return *(uint32_t*)((char*)arg1 + 8) + (arg2 << 4);
004019ab          
004019b2          if (arg2 == 0xffffd8ee)
00401a13              return (char*)arg1 + 0x48;
00401a13          
004019ba          if (arg2 == 0xffffd8ef)
004019ba          {
00401a02              int32_t edx_7 =
00401a02                  *(uint32_t*)(**(uint32_t**)(*(uint32_t*)((char*)arg1 + 0x14) + 4) + 0xc);
00401a05              *(uint32_t*)((char*)arg1 + 0x60) = 5;
00401a0c              *(uint32_t*)((char*)arg1 + 0x58) = edx_7;
00401a0e              return (char*)arg1 + 0x58;
004019ba          }
004019ba          
004019c2          if (arg2 == 0xffffd8f0)
004019f2              return *(uint32_t*)((char*)arg1 + 0x10) + 0x60;
004019f2          
004019ce          void* edx_4 = **(uint32_t**)(*(uint32_t*)((char*)arg1 + 0x14) + 4);
004019d9          int32_t ecx_3;
004019d9          (uint8_t)ecx_3 = *(uint8_t*)((char*)edx_4 + 7);
004019d9          
004019de          if (0xffffd8ee - arg2 <= ecx_3)
004019e7              return ((0xffffd8ee - arg2) << 4) + edx_4 + 8;
00401976      }
00401976      else
00401976      {
00401982          void* result = *(uint32_t*)((char*)arg1 + 0xc) + (arg2 << 4) - 0x10;
00401982          
0040198b          if (result < *(uint32_t*)((char*)arg1 + 8))
00401a16              return result;
00401976      }
00401976      
00401996      return &data_428330;
00401970  }

00401a17                                                                       90 90 90 90 90 90 90 90 90                         .........

00401a20    void* sub_401a20(void* arg1, int32_t arg2)

00401a20  {
00401a2b      void* result = sub_401970(arg1, arg2);
00401a30      int32_t* edx = *(uint32_t*)((char*)arg1 + 8);
00401a30      
00401a38      if (edx > result)
00401a38      {
00401a3b          int32_t* ecx_1 = &edx[-4];
00401a3b          
00401a56          do
00401a56          {
00401a3e              int32_t edi_1 = *(uint32_t*)ecx_1;
00401a40              ecx_1 -= 0x10;
00401a43              *(uint32_t*)edx = edi_1;
00401a48              edx[1] = ecx_1[5];
00401a4e              ecx_1[0xa] = ecx_1[6];
00401a51              edx -= 0x10;
00401a56          } while (edx > result);
00401a38      }
00401a38      
00401a59      int32_t* ecx_2 = *(uint32_t*)((char*)arg1 + 8);
00401a5f      *(uint32_t*)result = *(uint32_t*)ecx_2;
00401a64      *(uint32_t*)((char*)result + 4) = ecx_2[1];
00401a6a      *(uint32_t*)((char*)result + 8) = ecx_2[2];
00401a6d      return result;
00401a20  }

00401a6e                                            90 90                                                                ..

00401a70    int32_t sub_401a70(void* arg1, int32_t arg2)

00401a70  {
00401a7c      void* eax = sub_401970(arg1, arg2);
00401a8a      void* eax_2;
00401a8a      void* ecx_3;
00401a8a      
00401a8a      if (arg2 != 0xffffd8ef)
00401a8a      {
00401abd          int32_t* ecx_5 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
00401ac8          *(uint32_t*)eax = *(uint32_t*)ecx_5;
00401acd          *(uint32_t*)((char*)eax + 4) = ecx_5[1];
00401ad3          *(uint32_t*)((char*)eax + 8) = ecx_5[2];
00401ad3          
00401ad6          if (arg2 < 0xffffd8ee)
00401ad6          {
00401ad8              void* eax_3 = *(uint32_t*)((char*)arg1 + 8);
00401ad8              
00401ae3              if (*(uint32_t*)((char*)eax_3 - 8) >= 4)
00401ae3              {
00401ae5                  ecx_3 = *(uint32_t*)((char*)eax_3 - 0x10);
00401ae5                  
00401aec                  if (*(uint8_t*)((char*)ecx_3 + 5) & 3)
00401aec                  {
00401af4                      eax_2 = **(uint32_t**)(*(uint32_t*)((char*)arg1 + 0x14) + 4);
00401af4                      
00401af9                      if (*(uint8_t*)((char*)eax_2 + 5) & 4)
00401afe                          sub_404b60(arg1, eax_2, ecx_3);
00401aec                  }
00401ae3              }
00401ad6          }
00401a8a      }
00401a8a      else
00401a8a      {
00401a95          eax_2 = **(uint32_t**)(*(uint32_t*)((char*)arg1 + 0x14) + 4);
00401a9f          *(uint32_t*)((char*)eax_2 + 0xc) =
00401a9f              *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) - 0x10);
00401aa2          void* ecx_2 = *(uint32_t*)((char*)arg1 + 8);
00401aa2          
00401aa8          if (*(uint32_t*)((char*)ecx_2 - 8) >= 4)
00401aa8          {
00401aaa              ecx_3 = *(uint32_t*)((char*)ecx_2 - 0x10);
00401aaa              
00401ab6              if (*(uint8_t*)((char*)ecx_3 + 5) & 3 && *(uint8_t*)((char*)eax_2 + 5) & 4)
00401afe                  sub_404b60(arg1, eax_2, ecx_3);
00401aa8          }
00401a8a      }
00401b0a      int32_t result = *(uint32_t*)((char*)arg1 + 8) - 0x10;
00401b0d      *(uint32_t*)((char*)arg1 + 8) = result;
00401b11      return result;
00401a70  }

00401b12                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00401b20    int32_t sub_401b20(void* arg1, int32_t arg2)

00401b20  {
00401b2b      void* eax = sub_401970(arg1, arg2);
00401b30      int32_t* ecx = *(uint32_t*)((char*)arg1 + 8);
00401b38      *(uint32_t*)ecx = *(uint32_t*)eax;
00401b3d      ecx[1] = *(uint32_t*)((char*)eax + 4);
00401b43      ecx[2] = *(uint32_t*)((char*)eax + 8);
00401b49      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00401b4c      *(uint32_t*)((char*)arg1 + 8) = result;
00401b50      return result;
00401b20  }

00401b51                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00401b60    int32_t sub_401b60(void* arg1, int32_t arg2)

00401b60  {
00401b6a      void* eax = sub_401970(arg1, arg2);
00401b6a      
00401b77      if (eax != &data_428330)
00401b80          return *(uint32_t*)((char*)eax + 8);
00401b80      
00401b7c      return 0xffffffff;
00401b60  }

00401b81     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00401b90    int32_t sub_401b90(int32_t arg1)

00401b90  {
00401b97      if (arg1 != 0xffffffff)
00401ba6          return *(uint32_t*)((arg1 << 2) + &data_428298);
00401ba6      
00401b9e      return "no value";
00401b90  }

00401ba7                       90 90 90 90 90 90 90 90 90                                                         .........

00401bb0    int32_t sub_401bb0(void* arg1, int32_t arg2)

00401bb0  {
00401bba      void* eax = sub_401970(arg1, arg2);
00401bba      
00401bc8      if (*(uint32_t*)((char*)eax + 8) == 6)
00401bc8      {
00401bcc          (uint8_t)eax = *(uint8_t*)(*(uint32_t*)eax + 6);
00401bcc          
00401bd1          if ((uint8_t)eax)
00401bd8              return 1;
00401bc8      }
00401bc8      
00401bdb      return 0;
00401bb0  }

00401bdc                                                                                      90 90 90 90                              ....

00401be0    int32_t* sub_401be0(void* arg1, int32_t arg2)

00401be0  {
00401bed      void* eax = sub_401970(arg1, arg2);
00401bed      
00401bfb      if (*(uint32_t*)((char*)eax + 8) != 3)
00401bfb      {
00401c03          double var_10[0x2];
00401c03          int32_t* result = sub_408900(eax, &var_10);
00401c03          
00401c0d          if (!result)
00401c12              return result;
00401bfb      }
00401bfb      
00401c1b      return 1;
00401be0  }

00401c1c                                                                                      90 90 90 90                              ....

00401c20    int32_t sub_401c20(void* arg1, int32_t arg2)

00401c20  {
00401c2a      int32_t eax = sub_401b60(arg1, arg2);
00401c2a      
00401c3a      if (eax != 4 && eax != 3)
00401c3e          return 0;
00401c3e      
00401c44      return 1;
00401c20  }

00401c45                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00401c50    int32_t sub_401c50(void* arg1, int32_t arg2, int32_t arg3)

00401c50  {
00401c5c      void* eax = sub_401970(arg1, arg2);
00401c69      double* eax_1 = sub_401970(arg1, arg3);
00401c69      
00401c7e      if (eax != &data_428330 && eax_1 != &data_428330)
00401c8c          return sub_408390(eax, eax_1);
00401c8c      
00401c91      return 0;
00401c50  }

00401c92                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00401ca0    int32_t sub_401ca0(void* arg1, int32_t arg2, int32_t arg3)

00401ca0  {
00401cac      void* eax = sub_401970(arg1, arg2);
00401cb9      double* eax_1 = sub_401970(arg1, arg3);
00401cb9      
00401cce      if (eax != &data_428330 && eax_1 != &data_428330)
00401cdd          return sub_408d20(arg1, eax, eax_1);
00401cdd      
00401ce2      return 0;
00401ca0  }

00401ce3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00401cf0    long double sub_401cf0(void* arg1, int32_t arg2)

00401cf0  {
00401cfd      void* eax = sub_401970(arg1, arg2);
00401cfd      
00401d0b      if (*(uint32_t*)((char*)eax + 8) != 3)
00401d0b      {
00401d13          double var_10[0x2];
00401d13          eax = sub_408900(eax, &var_10);
00401d13          
00401d1d          if (!eax)
00401d28              return (long double)0.0;
00401d0b      }
00401d0b      
00401d2e      return (long double)*(uint64_t*)eax;
00401cf0  }

00401d2f                                               90                                                                 .

00401d30    void* sub_401d30(void* arg1, int32_t arg2)

00401d30  {
00401d3d      void* result = sub_401970(arg1, arg2);
00401d4b      double var_10[0x2];
00401d4b      
00401d4b      if (*(uint32_t*)((char*)result + 8) != 3)
00401d4b      {
00401d53          result = sub_408900(result, &var_10);
00401d53          
00401d5d          if (!result)
00401d62              return result;
00401d4b      }
00401d4b      
00401d6b      var_10[0] =
00401d6b          (double)((long double)*(uint64_t*)result + (long double)6755399441055744.0);
00401d76      return var_10[0];
00401d30  }

00401d77                                                                       90 90 90 90 90 90 90 90 90                         .........

00401d80    int32_t sub_401d80(void* arg1, int32_t arg2)

00401d80  {
00401d8a      void* eax = sub_401970(arg1, arg2);
00401d8f      int32_t ecx_1 = *(uint32_t*)((char*)eax + 8);
00401d8f      
00401da1      if (ecx_1 && (ecx_1 != 1 || *(uint32_t*)eax))
00401da8          return 1;
00401da8      
00401dab      return 0;
00401d80  }

00401dac                                      90 90 90 90                                                              ....

00401db0    int32_t sub_401db0(void* arg1, int32_t arg2, int32_t* arg3)

00401db0  {
00401dbc      void* eax = sub_401970(arg1, arg2);
00401dbc      
00401dca      if (*(uint32_t*)((char*)eax + 8) != 4)
00401dca      {
00401dd8          if (!sub_408950(arg1, eax))
00401dd8          {
00401de0              if (arg3)
00401de2                  *(uint32_t*)arg3 = 0;
00401de2              
00401dec              return 0;
00401dd8          }
00401dd8          
00401ded          void* eax_4 = *(uint32_t*)((char*)arg1 + 0x10);
00401ded          
00401df8          if (*(uint32_t*)((char*)eax_4 + 0x44) >= *(uint32_t*)((char*)eax_4 + 0x40))
00401dfb              sub_403f70(arg1);
00401dfb          
00401e05          eax = sub_401970(arg1, arg2);
00401dca      }
00401dca      
00401e13      if (arg3)
00401e1a          *(uint32_t*)arg3 = *(uint32_t*)(*(uint32_t*)eax + 0xc);
00401e1a      
00401e23      return *(uint32_t*)eax + 0x10;
00401db0  }

00401e24              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00401e30    int32_t sub_401e30(void* arg1, int32_t arg2)

00401e30  {
00401e3c      void* eax = sub_401970(arg1, arg2);
00401e3c      
00401e51      switch (*(uint32_t*)((char*)eax + 8) - 3)
00401e51      {
00401e70          case 0:
00401e70          {
00401e7a              if (sub_408950(arg1, eax))
00401e83                  return *(uint32_t*)(*(uint32_t*)eax + 0xc);
00401e70              break;
00401e70          }
00401e83          case 1:
00401e83          {
00401e83              return *(uint32_t*)(*(uint32_t*)eax + 0xc);
00401e83              break;
00401e83          }
00401e6d          case 2:
00401e6d          {
00401e6d              return sub_4081f0(*(uint32_t*)eax);
00401e6d              break;
00401e6d          }
00401e5f          case 4:
00401e5f          {
00401e5f              return *(uint32_t*)(*(uint32_t*)eax + 0x10);
00401e5f              break;
00401e5f          }
00401e51      }
00401e51      
00401e88      return 0;
00401e30  }

00401e89                             8d 49 00                                                                       .I.
00401e8c  uint32_t jump_table_401e8c[0x5] = 
00401e8c  {
00401e8c      [0x0] =  0x00401e6e
00401e90      [0x1] =  0x00401e7c
00401e94      [0x2] =  0x00401e60
00401e98      [0x3] =  0x00401e84
00401e9c      [0x4] =  0x00401e58
00401ea0  }

00401ea0    int32_t sub_401ea0(void* arg1, int32_t arg2)

00401ea0  {
00401eaa      void* eax = sub_401970(arg1, arg2);
00401eaa      
00401eb8      if (*(uint32_t*)((char*)eax + 8) == 6)
00401eb8      {
00401eba          void* eax_1 = *(uint32_t*)eax;
00401ebc          int32_t ecx_1;
00401ebc          (uint8_t)ecx_1 = *(uint8_t*)((char*)eax_1 + 6);
00401ebc          
00401ec1          if ((uint8_t)ecx_1)
00401ec6              return *(uint32_t*)((char*)eax_1 + 0x10);
00401eb8      }
00401eb8      
00401ec9      return 0;
00401ea0  }

00401eca                                90 90 90 90 90 90                                                            ......

00401ed0    int32_t sub_401ed0(void* arg1, int32_t arg2)

00401ed0  {
00401eda      void* eax = sub_401970(arg1, arg2);
00401edf      int32_t ecx_1 = *(uint32_t*)((char*)eax + 8);
00401edf      
00401ee8      if (ecx_1 == 2)
00401efa          return *(uint32_t*)eax;
00401efa      
00401eed      if (ecx_1 == 7)
00401ef7          return *(uint32_t*)eax + 0x18;
00401ef7      
00401ef1      return 0;
00401ed0  }

00401efb                                                                                   90 90 90 90 90                             .....

00401f00    int32_t sub_401f00(void* arg1, int32_t arg2)

00401f00  {
00401f0a      void* eax = sub_401970(arg1, arg2);
00401f0a      
00401f18      if (*(uint32_t*)((char*)eax + 8) == 8)
00401f1f          return *(uint32_t*)eax;
00401f1f      
00401f1c      return 0;
00401f00  }


00401f20    int32_t sub_401f20(void* arg1, int32_t arg2)

00401f20  {
00401f2c      void* eax = sub_401970(arg1, arg2);
00401f2c      
00401f3f      switch (*(uint32_t*)((char*)eax + 8) - 2)
00401f3f      {
00401f57          case 0:
00401f57          case 5:
00401f57          {
00401f57              return sub_401ed0(arg1, arg2);
00401f57              break;
00401f57          }
00401f4a          case 3:
00401f4a          case 4:
00401f4a          case 6:
00401f4a          {
00401f4a              return *(uint32_t*)eax;
00401f4a              break;
00401f4a          }
00401f3f      }
00401f3f      
00401f5c      return 0;
00401f20  }

00401f5d                                                                                         8d 49 00                               .I.
00401f60  uint32_t jump_table_401f60[0x7] = 
00401f60  {
00401f60      [0x0] =  0x00401f4b
00401f64      [0x1] =  0x00401f58
00401f68      [0x2] =  0x00401f58
00401f6c      [0x3] =  0x00401f46
00401f70      [0x4] =  0x00401f46
00401f74      [0x5] =  0x00401f4b
00401f78      [0x6] =  0x00401f46
00401f7c  }

00401f7c                                                                                      90 90 90 90                              ....

00401f80    void* sub_401f80(void* arg1)

00401f80  {
00401f87      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) + 8) = 0;
00401f94      *(uint32_t*)((char*)arg1 + 8) += 0x10;
00401f97      return arg1;
00401f80  }

00401f98                                                                          90 90 90 90 90 90 90 90                          ........

00401fa0    int32_t sub_401fa0(void* arg1, int32_t arg2, int32_t arg3)

00401fa0  {
00401fad      int32_t* eax = *(uint32_t*)((char*)arg1 + 8);
00401fb0      *(uint32_t*)eax = arg2;
00401fb2      eax[1] = arg3;
00401fb5      eax[2] = 3;
00401fbf      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00401fc3      *(uint32_t*)((char*)arg1 + 8) = result;
00401fc6      return result;
00401fa0  }

00401fc7                       90 90 90 90 90 90 90 90 90                                                         .........

00401fd0    void* sub_401fd0(void* arg1, int32_t arg2)

00401fd0  {
00401fd8      double* ecx = *(uint32_t*)((char*)arg1 + 8);
00401fdb      *(uint64_t*)ecx = (double)(long double)arg2;
00401fdd      ecx[1] = 3;
00401fea      *(uint32_t*)((char*)arg1 + 8) += 0x10;
00401fed      return arg1;
00401fd0  }

00401fee                                            90 90                                                                ..

00401ff0    int32_t sub_401ff0(void* arg1, char* arg2, int32_t* arg3)

00401ff0  {
00401ff6      void* eax = *(uint32_t*)((char*)arg1 + 0x10);
00401ff6      
00402001      if (*(uint32_t*)((char*)eax + 0x44) >= *(uint32_t*)((char*)eax + 0x40))
00402004          sub_403f70(arg1);
00402004      
00402014      void*** edi = *(uint32_t*)((char*)arg1 + 8);
0040201f      *(uint32_t*)edi = sub_405f60(arg1, arg2, arg3);
00402021      edi[2] = 4;
0040202e      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00402031      *(uint32_t*)((char*)arg1 + 8) = result;
00402036      return result;
00401ff0  }

00402037                                                                       90 90 90 90 90 90 90 90 90                         .........

00402040    void* sub_402040(void* arg1, char* arg2)

00402040  {
00402046      if (!arg2)
00402055          return sub_401f80(arg1);
00402055      
00402057      char* edi = arg2;
00402059      int32_t i = 0xffffffff;
00402059      
0040205e      while (i)
0040205e      {
0040205e          bool cond:0_1 = 0 != *(uint8_t*)edi;
0040205e          edi = &edi[1];
0040205e          i -= 1;
0040205e          
0040205e          if (!cond:0_1)
0040205e              break;
0040205e      }
0040205e      
00402073      return sub_401ff0(arg1, arg2, ~i - 1);
00402040  }

00402074                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00402080    int32_t sub_402080(void* arg1, double* arg2, int32_t arg3)

00402080  {
00402085      void* eax = *(uint32_t*)((char*)arg1 + 0x10);
00402085      
00402090      if (*(uint32_t*)((char*)eax + 0x44) >= *(uint32_t*)((char*)eax + 0x40))
00402093          sub_403f70(arg1);
00402093      
004020a3      int32_t var_8_2 = arg3;
004020af      return sub_4084b0(arg1, arg2);
00402080  }


004020b0    int32_t sub_4020b0(void* arg1, double* arg2)

004020b0  {
004020b5      void* eax = *(uint32_t*)((char*)arg1 + 0x10);
004020b5      
004020c0      if (*(uint32_t*)((char*)eax + 0x44) >= *(uint32_t*)((char*)eax + 0x40))
004020c3          sub_403f70(arg1);
004020c3      
004020d3      void arg_c;
004020d3      void* var_8_2 = &arg_c;
004020df      return sub_4084b0(arg1, arg2);
004020b0  }


004020e0    int32_t sub_4020e0(void* arg1, int32_t arg2, int32_t arg3)

004020e0  {
004020e7      void* eax = *(uint32_t*)((char*)arg1 + 0x10);
004020e7      
004020f2      if (*(uint32_t*)((char*)eax + 0x44) >= *(uint32_t*)((char*)eax + 0x40))
004020f5          sub_403f70(arg1);
004020f5      
0040210a      int32_t* eax_2 = sub_404d50(arg1, arg3, sub_402180(arg1));
00402117      eax_2[4] = arg2;
0040212a      *(uint32_t*)((char*)arg1 + 8) += -(arg3) << 4;
0040212a      
0040212d      if (arg3)
0040212d      {
0040213c          void* edx_3 = &eax_2[(arg3 - 1) * 4 + 6];
00402140          int32_t i = arg3;
00402140          
00402160          do
00402160          {
00402147              void* ecx_7 = 0xffffffe8 - eax_2 + edx_3 + *(uint32_t*)((char*)arg1 + 8);
00402149              i -= 1;
0040214a              edx_3 -= 0x10;
0040214f              *(uint32_t*)((char*)edx_3 + 0x10) = *(uint32_t*)ecx_7;
00402155              *(uint32_t*)((char*)edx_3 + 0x14) = *(uint32_t*)((char*)ecx_7 + 4);
0040215b              *(uint32_t*)((char*)edx_3 + 0x18) = *(uint32_t*)((char*)ecx_7 + 8);
00402160          } while (i > 0);
0040212d      }
0040212d      
00402163      int32_t** ecx_9 = *(uint32_t*)((char*)arg1 + 8);
00402167      *(uint32_t*)ecx_9 = eax_2;
00402169      ecx_9[2] = 6;
00402173      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00402176      *(uint32_t*)((char*)arg1 + 8) = result;
0040217b      return result;
004020e0  }

0040217c                                                                                      90 90 90 90                              ....

00402180    int32_t sub_402180(void* arg1)

00402180  {
00402184      void* ecx = *(uint32_t*)((char*)arg1 + 0x14);
00402184      
0040218c      if (ecx != *(uint32_t*)((char*)arg1 + 0x28))
0040219a          return *(uint32_t*)(**(uint32_t**)((char*)ecx + 4) + 0xc);
0040219a      
00402191      return *(uint32_t*)((char*)arg1 + 0x48);
00402180  }

0040219b                                                                                   90 90 90 90 90                             .....

004021a0    void* sub_4021a0(void* arg1, int32_t arg2)

004021a0  {
004021ab      int32_t* ecx = *(uint32_t*)((char*)arg1 + 8);
004021b0      int32_t edx;
004021b0      (uint8_t)edx = arg2;
004021b3      *(uint32_t*)ecx = edx;
004021b5      ecx[2] = 1;
004021c3      *(uint32_t*)((char*)arg1 + 8) += 0x10;
004021c6      return arg1;
004021a0  }

004021c7                       90 90 90 90 90 90 90 90 90                                                         .........

004021d0    void* sub_4021d0(void* arg1, int32_t arg2)

004021d0  {
004021d8      int32_t* ecx = *(uint32_t*)((char*)arg1 + 8);
004021db      *(uint32_t*)ecx = arg2;
004021dd      ecx[2] = 2;
004021e4      *(uint32_t*)((char*)arg1 + 8) += 0x10;
004021e8      return arg1;
004021d0  }

004021e9                             90 90 90 90 90 90 90                                                           .......

004021f0    int32_t sub_4021f0(void* arg1)

004021f0  {
004021f7      void** ecx = *(uint32_t*)((char*)arg1 + 8);
004021fa      *(uint32_t*)ecx = arg1;
004021fc      ecx[2] = 8;
00402209      *(uint32_t*)((char*)arg1 + 8) += 0x10;
00402215      int32_t result;
00402215      (uint8_t)result = *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 0x70) == arg1;
0040221a      return result;
004021f0  }

0040221b                                                                                   90 90 90 90 90                             .....

00402220    int32_t* sub_402220(void* arg1, int32_t arg2)

00402220  {
0040222b      void* eax = sub_401970(arg1, arg2);
00402233      int32_t* ecx_1 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
00402243      return sub_4089c0(arg1, eax, ecx_1, ecx_1);
00402220  }

00402244              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00402250    int32_t sub_402250(void* arg1, int32_t arg2, char* arg3)

00402250  {
00402260      void* eax_1 = sub_401970(arg1, arg2);
0040226b      char* edi = arg3;
0040226d      int32_t i = 0xffffffff;
0040226d      
00402272      while (i)
00402272      {
00402272          bool cond:0_1 = 0 != *(uint8_t*)edi;
00402272          edi = &edi[1];
00402272          i -= 1;
00402272          
00402272          if (!cond:0_1)
00402272              break;
00402272      }
00402272      
0040227a      void** eax_2 = sub_405f60(arg1, arg3, ~i - 1);
0040227f      int32_t* ecx_2 = *(uint32_t*)((char*)arg1 + 8);
0040228a      void** var_10 = eax_2;
0040228e      int32_t var_8 = 4;
00402296      sub_4089c0(arg1, eax_1, &var_10, ecx_2);
004022a1      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
004022a4      *(uint32_t*)((char*)arg1 + 8) = result;
004022ad      return result;
00402250  }

004022ae                                            90 90                                                                ..

004022b0    int32_t sub_4022b0(void* arg1, int32_t arg2)

004022b0  {
004022ca      void* eax_1 = sub_407cb0(*(uint32_t*)sub_401970(arg1, arg2), 
004022ca          *(uint32_t*)((char*)arg1 + 8) - 0x10);
004022d4      int32_t* ecx_3 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
004022da      *(uint32_t*)ecx_3 = *(uint32_t*)eax_1;
004022df      ecx_3[1] = *(uint32_t*)((char*)eax_1 + 4);
004022e2      int32_t result = *(uint32_t*)((char*)eax_1 + 8);
004022e5      ecx_3[2] = result;
004022e9      return result;
004022b0  }

004022ea                                90 90 90 90 90 90                                                            ......

004022f0    int32_t sub_4022f0(void* arg1, int32_t arg2, int32_t arg3)

004022f0  {
00402308      int32_t* eax_1 = sub_407bf0(*(uint32_t*)sub_401970(arg1, arg2), arg3);
0040230d      int32_t* ecx_1 = *(uint32_t*)((char*)arg1 + 8);
00402315      *(uint32_t*)ecx_1 = *(uint32_t*)eax_1;
0040231a      ecx_1[1] = eax_1[1];
00402320      ecx_1[2] = eax_1[2];
00402326      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00402329      *(uint32_t*)((char*)arg1 + 8) = result;
0040232d      return result;
004022f0  }

0040232e                                            90 90                                                                ..

00402330    int32_t sub_402330(void* arg1, int32_t arg2, int32_t arg3)

00402330  {
00402336      void* eax = *(uint32_t*)((char*)arg1 + 0x10);
00402336      
00402341      if (*(uint32_t*)((char*)eax + 0x44) >= *(uint32_t*)((char*)eax + 0x40))
00402344          sub_403f70(arg1);
00402344      
00402354      int32_t** edi = *(uint32_t*)((char*)arg1 + 8);
0040235f      *(uint32_t*)edi = sub_407b30(arg1, arg2, arg3);
00402361      edi[2] = 5;
0040236e      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00402371      *(uint32_t*)((char*)arg1 + 8) = result;
00402376      return result;
00402330  }

00402377                                                                       90 90 90 90 90 90 90 90 90                         .........

00402380    int32_t sub_402380(void* arg1, int32_t arg2)

00402380  {
0040238b      void* eax = sub_401970(arg1, arg2);
00402390      int32_t ecx = *(uint32_t*)((char*)eax + 8);
0040239b      int32_t ecx_1;
0040239b      
0040239b      if (ecx == 5)
004023b7          ecx_1 = *(uint32_t*)(*(uint32_t*)eax + 8);
0040239b      else if (ecx == 7)
004023b0          ecx_1 = *(uint32_t*)(*(uint32_t*)eax + 8);
004023a0      else
004023a5          ecx_1 = *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + (ecx << 2) + 0x98);
004023a5      
004023bc      if (!ecx_1)
004023c1          return 0;
004023c1      
004023c2      int32_t* eax_3 = *(uint32_t*)((char*)arg1 + 8);
004023c5      *(uint32_t*)eax_3 = ecx_1;
004023c7      eax_3[2] = 5;
004023d4      *(uint32_t*)((char*)arg1 + 8) += 0x10;
004023dd      return 1;
00402380  }

004023de                                                                                            90 90                                ..

004023e0    int32_t sub_4023e0(void* arg1, int32_t arg2)

004023e0  {
004023eb      void* eax = sub_401970(arg1, arg2);
004023f0      int32_t ecx = *(uint32_t*)((char*)eax + 8);
004023f0      
004023fc      if (ecx == 6 || ecx == 7)
004023fc      {
0040243b          int32_t* ecx_6 = *(uint32_t*)((char*)arg1 + 8);
00402441          *(uint32_t*)ecx_6 = *(uint32_t*)(*(uint32_t*)eax + 0xc);
00402443          ecx_6[2] = 5;
0040244d          int32_t eax_10 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00402450          *(uint32_t*)((char*)arg1 + 8) = eax_10;
00402454          return eax_10;
004023fc      }
004023fc      
004023ff      if (ecx != 8)
004023ff      {
00402404          *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) + 8) = 0;
0040240e          int32_t eax_2 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00402411          *(uint32_t*)((char*)arg1 + 8) = eax_2;
00402415          return eax_2;
004023ff      }
004023ff      
00402418      int32_t* ecx_5 = *(uint32_t*)((char*)arg1 + 8);
0040241b      int32_t* eax_4 = *(uint32_t*)eax + 0x48;
00402420      *(uint32_t*)ecx_5 = *(uint32_t*)eax_4;
00402425      ecx_5[1] = eax_4[1];
0040242b      ecx_5[2] = eax_4[2];
00402431      int32_t eax_7 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00402434      *(uint32_t*)((char*)arg1 + 8) = eax_7;
00402438      return eax_7;
004023e0  }

00402455                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00402460    int32_t sub_402460(void* arg1, int32_t arg2)

00402460  {
0040246b      void* eax = sub_401970(arg1, arg2);
00402470      void* ecx = *(uint32_t*)((char*)arg1 + 8);
0040247d      sub_408b60(arg1, eax, (char*)ecx - 0x20, (char*)ecx - 0x10);
00402488      int32_t result = *(uint32_t*)((char*)arg1 + 8) - 0x20;
0040248b      *(uint32_t*)((char*)arg1 + 8) = result;
0040248f      return result;
00402460  }


00402490    int32_t sub_402490(void* arg1, int32_t arg2, char* arg3)

00402490  {
004024a0      void* eax_1 = sub_401970(arg1, arg2);
004024ab      char* edi = arg3;
004024ad      int32_t i = 0xffffffff;
004024ad      
004024b2      while (i)
004024b2      {
004024b2          bool cond:0_1 = 0 != *(uint8_t*)edi;
004024b2          edi = &edi[1];
004024b2          i -= 1;
004024b2          
004024b2          if (!cond:0_1)
004024b2              break;
004024b2      }
004024b2      
004024ba      void** eax_2 = sub_405f60(arg1, arg3, ~i - 1);
004024c6      int32_t* ecx_3 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
004024c9      void** var_10 = eax_2;
004024d1      int32_t var_8 = 4;
004024d9      sub_408b60(arg1, eax_1, &var_10, ecx_3);
004024e4      int32_t result = *(uint32_t*)((char*)arg1 + 8) - 0x10;
004024e7      *(uint32_t*)((char*)arg1 + 8) = result;
004024f0      return result;
00402490  }

004024f1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00402500    int32_t sub_402500(void* arg1, int32_t arg2)

00402500  {
0040250d      void* eax = sub_401970(arg1, arg2);
00402512      void* edi = *(uint32_t*)((char*)arg1 + 8);
0040251f      void* eax_1 = sub_407d70(arg1, *(uint32_t*)eax, (char*)edi - 0x20);
0040252a      *(uint32_t*)eax_1 = *(uint32_t*)((char*)edi - 0x10);
0040252f      *(uint32_t*)((char*)eax_1 + 4) = *(uint32_t*)((char*)edi - 0xc);
00402535      *(uint32_t*)((char*)eax_1 + 8) = *(uint32_t*)((char*)edi - 8);
00402538      void* eax_2 = *(uint32_t*)((char*)arg1 + 8);
00402538      
0040254c      if (*(uint32_t*)((char*)eax_2 - 8) >= 4
0040254c          && *(uint8_t*)(*(uint32_t*)((char*)eax_2 - 0x10) + 5) & 3)
0040254c      {
0040254e          void* ebx_1 = *(uint32_t*)eax;
0040254e          
00402553          if (*(uint8_t*)((char*)ebx_1 + 5) & 4)
00402557              sub_404ba0(arg1, ebx_1);
0040254c      }
0040254c      
00402563      int32_t result = *(uint32_t*)((char*)arg1 + 8) - 0x20;
00402566      *(uint32_t*)((char*)arg1 + 8) = result;
0040256b      return result;
00402500  }

0040256c                                      90 90 90 90                                                              ....

00402570    int32_t sub_402570(void* arg1, int32_t arg2, int32_t arg3)

00402570  {
0040257d      void* eax = sub_401970(arg1, arg2);
0040258c      int32_t* esi_1 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
00402593      void* eax_1 = sub_408150(arg1, *(uint32_t*)eax, arg3);
0040259d      *(uint32_t*)eax_1 = *(uint32_t*)esi_1;
004025a2      *(uint32_t*)((char*)eax_1 + 4) = esi_1[1];
004025a8      *(uint32_t*)((char*)eax_1 + 8) = esi_1[2];
004025ab      void* eax_2 = *(uint32_t*)((char*)arg1 + 8);
004025ab      
004025bf      if (*(uint32_t*)((char*)eax_2 - 8) >= 4
004025bf          && *(uint8_t*)(*(uint32_t*)((char*)eax_2 - 0x10) + 5) & 3)
004025bf      {
004025c1          void* ebx_1 = *(uint32_t*)eax;
004025c1          
004025c6          if (*(uint8_t*)((char*)ebx_1 + 5) & 4)
004025ca              sub_404ba0(arg1, ebx_1);
004025bf      }
004025bf      
004025d5      int32_t result = *(uint32_t*)((char*)arg1 + 8) - 0x10;
004025d8      *(uint32_t*)((char*)arg1 + 8) = result;
004025de      return result;
00402570  }

004025df                                                                                               90                                 .

004025e0    int32_t sub_4025e0(void* arg1, int32_t arg2)

004025e0  {
004025ec      void* eax = sub_401970(arg1, arg2);
004025f1      void* ecx = *(uint32_t*)((char*)arg1 + 8);
004025fc      void* ecx_1;
004025fc      
004025fc      if (*(uint32_t*)((char*)ecx - 8))
00402602          ecx_1 = *(uint32_t*)((char*)ecx - 0x10);
004025fc      else
004025fe          ecx_1 = nullptr;
004025fe      
00402605      int32_t edx_1 = *(uint32_t*)((char*)eax + 8);
00402605      
0040260d      if (edx_1 == 5)
0040260d      {
00402666          *(uint32_t*)(*(uint32_t*)eax + 8) = ecx_1;
00402666          
0040266f          if (ecx_1 && *(uint8_t*)((char*)ecx_1 + 5) & 3)
0040266f          {
00402671              void* eax_9 = *(uint32_t*)eax;
00402671              
00402677              if (*(uint8_t*)((char*)eax_9 + 5) & 4)
0040267b                  sub_404ba0(arg1, eax_9);
0040266f          }
0040260d      }
0040260d      else
0040260d      {
00402612          if (edx_1 != 7)
00402612          {
00402617              *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + (edx_1 << 2) + 0x98) = ecx_1;
00402624              *(uint32_t*)((char*)arg1 + 8) -= 0x10;
0040262e              return 1;
00402612          }
00402612          
00402633          *(uint32_t*)(*(uint32_t*)eax + 8) = ecx_1;
00402633          
0040263c          if (ecx_1 && *(uint8_t*)((char*)ecx_1 + 5) & 3)
0040263c          {
0040263e              void* eax_5 = *(uint32_t*)eax;
0040263e              
00402644              if (*(uint8_t*)((char*)eax_5 + 5) & 4)
00402644              {
00402649                  sub_404b60(arg1, eax_5, ecx_1);
00402657                  *(uint32_t*)((char*)arg1 + 8) -= 0x10;
00402661                  return 1;
00402644              }
0040263c          }
0040260d      }
0040260d      
00402689      *(uint32_t*)((char*)arg1 + 8) -= 0x10;
00402693      return 1;
004025e0  }

00402694                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

004026a0    int32_t sub_4026a0(void* arg1, int32_t arg2)

004026a0  {
004026ac      int32_t result = 1;
004026b1      void* eax = sub_401970(arg1, arg2);
004026b6      int32_t ecx = *(uint32_t*)((char*)eax + 8);
004026b6      
004026bf      if (ecx == 6)
004026f6          *(uint32_t*)(*(uint32_t*)eax + 0xc) =
004026f6              *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) - 0x10);
004026bf      else if (ecx == 7)
004026e9          *(uint32_t*)(*(uint32_t*)eax + 0xc) =
004026e9              *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) - 0x10);
004026c2      else if (ecx == 8)
004026c5      {
004026d0          int32_t* ecx_5 = *(uint32_t*)eax + 0x48;
004026d6          *(uint32_t*)ecx_5 = *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) - 0x10);
004026d8          ecx_5[2] = 5;
004026c5      }
004026c5      else
004026c7          result = 0;
004026c7      
004026fc      void* ecx_10 = *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) - 0x10);
004026fc      
00402703      if (*(uint8_t*)((char*)ecx_10 + 5) & 3)
00402703      {
00402705          void* eax_1 = *(uint32_t*)eax;
00402705          
0040270b          if (*(uint8_t*)((char*)eax_1 + 5) & 4)
00402710              sub_404b60(arg1, eax_1, ecx_10);
00402703      }
00402703      
0040271e      *(uint32_t*)((char*)arg1 + 8) -= 0x10;
00402725      return result;
004026a0  }

00402726                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00402730    void* sub_402730(void* arg1, int32_t arg2, int32_t arg3)

00402730  {
0040274a      void* result =
0040274a          sub_405a80(arg1, *(uint32_t*)((char*)arg1 + 8) - ((arg2 + 1) << 4), arg3);
0040274a      
00402755      if (arg3 == 0xffffffff)
00402755      {
00402757          result = *(uint32_t*)((char*)arg1 + 0x14);
0040275a          int32_t esi_1 = *(uint32_t*)((char*)arg1 + 8);
0040275a          
00402760          if (esi_1 >= *(uint32_t*)((char*)result + 8))
00402762              *(uint32_t*)((char*)result + 8) = esi_1;
00402755      }
00402755      
00402767      return result;
00402730  }

00402768                          90 90 90 90 90 90 90 90                                                          ........

00402770    int32_t sub_402770(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00402770  {
0040277e      void* ecx;
0040277e      
0040277e      if (arg4)
00402793          ecx = sub_401970(arg1, arg4) - *(uint32_t*)((char*)arg1 + 0x20);
0040277e      else
00402780          ecx = nullptr;
00402780      
004027a7      int32_t eax_6 = *(uint32_t*)((char*)arg1 + 8) - ((arg2 + 1) << 4);
004027a9      int32_t edx_1 = *(uint32_t*)((char*)arg1 + 0x20);
004027ac      int32_t var_8 = eax_6;
004027b8      int32_t var_4 = arg3;
004027c3      int32_t result = sub_405cb0(arg1, sub_4027f0, &var_8, eax_6 - edx_1, ecx);
004027c3      
004027cf      if (arg3 == 0xffffffff)
004027cf      {
004027d1          void* ecx_2 = *(uint32_t*)((char*)arg1 + 0x14);
004027d4          int32_t esi_1 = *(uint32_t*)((char*)arg1 + 8);
004027d4          
004027da          if (esi_1 >= *(uint32_t*)((char*)ecx_2 + 8))
004027dc              *(uint32_t*)((char*)ecx_2 + 8) = esi_1;
004027cf      }
004027cf      
004027e3      return result;
00402770  }

004027e4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

004027f0    void* sub_4027f0(void* arg1, int32_t* arg2)

004027f0  {
00402808      return sub_405a80(arg1, *(uint32_t*)arg2, arg2[1]);
004027f0  }

00402809                             90 90 90 90 90 90 90                                                           .......

00402810    int32_t sub_402810(void* arg1, int32_t arg2, int32_t arg3)

00402810  {
0040281b      int32_t var_8 = arg2;
00402823      int32_t var_4 = arg3;
00402845      return sub_405cb0(arg1, sub_402850, &var_8, 
00402845          *(uint32_t*)((char*)arg1 + 8) - *(uint32_t*)((char*)arg1 + 0x20), 0);
00402810  }

00402846                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00402850    void* sub_402850(void* arg1, int32_t* arg2)

00402850  {
0040285f      int32_t* eax_1 = sub_404d50(arg1, 0, sub_402180(arg1));
0040286c      eax_1[4] = *(uint32_t*)arg2;
0040286f      int32_t** ecx_1 = *(uint32_t*)((char*)arg1 + 8);
00402872      *(uint32_t*)ecx_1 = eax_1;
00402874      ecx_1[2] = 6;
00402883      int32_t* eax_3 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00402885      *(uint32_t*)((char*)arg1 + 8) = eax_3;
0040288b      *(uint32_t*)eax_3 = arg2[1];
0040288d      eax_3[2] = 2;
00402897      void* edx_3 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
0040289b      *(uint32_t*)((char*)arg1 + 8) = edx_3;
004028ac      return sub_405a80(arg1, (char*)edx_3 - 0x20, 0);
00402850  }

004028ad                                         90 90 90                                                               ...

004028b0    int32_t sub_4028b0(void* arg1, int32_t arg2, int32_t arg3, void* arg4)

004028b0  {
004028b5      void* edi = arg4;
004028b5      
004028bb      if (!edi)
004028bd          edi = &data_42b128;
004028bd      
004028d6      void var_14;
004028d6      sub_40a720(arg1, &var_14, arg2, arg3);
004028ef      return sub_405d60(arg1, &var_14, edi);
004028b0  }


004028f0    int32_t sub_4028f0(void* arg1, int32_t arg2, int32_t arg3)

004028f0  {
004028f7      int32_t* eax_1 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
004028f7      
004028fe      if (eax_1[2] == 6)
004028fe      {
00402900          void* eax_2 = *(uint32_t*)eax_1;
00402900          
00402907          if (!*(uint8_t*)((char*)eax_2 + 6))
00402922              return sub_40a820(arg1, *(uint32_t*)((char*)eax_2 + 0x10), arg2, arg3, 0);
004028fe      }
004028fe      
00402928      return 1;
004028f0  }

00402929                             90 90 90 90 90 90 90                                                           .......

00402930    int32_t sub_402930(void* arg1)

00402930  {
00402936      int32_t result;
00402936      (uint8_t)result = *(uint8_t*)((char*)arg1 + 6);
00402939      return result;
00402930  }

0040293a                                                                                90 90 90 90 90 90                            ......

00402940    uint32_t sub_402940(void* arg1, int32_t arg2, int32_t arg3)

00402940  {
0040294d      void* esi = *(uint32_t*)((char*)arg1 + 0x10);
0040294d      
00402953      if (arg2 > 7)
00402a07          return 0xffffffff;
00402a07      
00402953      switch (arg2)
00402953      {
00402962          case 0:
00402962          {
00402962              *(uint32_t*)((char*)esi + 0x40) = 0xfffffffd;
0040296c              return 0;
00402962              break;
00402962          }
00402970          case 1:
00402970          {
00402970              *(uint32_t*)((char*)esi + 0x40) = *(uint32_t*)((char*)esi + 0x44);
00402978              return 0;
00402970              break;
00402970          }
0040297a          case 2:
0040297a          {
0040297a              sub_404ae0(arg1);
00402987              return 0;
0040297a              break;
0040297a          }
00402993          case 3:
00402993          {
00402993              return *(uint32_t*)((char*)esi + 0x44) >> 0xa;
00402993              break;
00402993          }
004029a2          case 4:
004029a2          {
004029a2              return *(uint32_t*)((char*)esi + 0x44) & 0x3ff;
004029a2              break;
004029a2          }
004029a7          case 5:
004029a7          {
004029a7              int32_t ecx_1 = *(uint32_t*)((char*)esi + 0x44);
004029aa              int32_t eax_7 = arg3 << 0xa;
004029aa              
004029af              if (eax_7 > ecx_1)
004029ba                  *(uint32_t*)((char*)esi + 0x40) = 0;
004029af              else
004029b5                  *(uint32_t*)((char*)esi + 0x40) = ecx_1 - eax_7;
004029b5              
004029c0              if (*(uint32_t*)((char*)esi + 0x40) <= ecx_1)
004029c0              {
004029d3                  do
004029c3                      sub_403f70(arg1);
004029d3                   while (*(uint32_t*)((char*)esi + 0x40)
004029d3                       <= *(uint32_t*)((char*)esi + 0x44));
004029c0              }
004029c0              
004029d5              (uint8_t)eax_7 = *(uint8_t*)((char*)esi + 0x15);
004029d5              
004029da              if ((uint8_t)eax_7)
00402a0f                  return 0;
00402a0f              
004029e6              return 1;
004029a7              break;
004029a7          }
004029e7          case 6:
004029e7          {
004029e7              int32_t edi_5 = *(uint32_t*)((char*)esi + 0x50);
004029f0              *(uint32_t*)((char*)esi + 0x50) = arg3;
004029f6              return edi_5;
004029e7              break;
004029e7          }
004029f7          case 7:
004029f7          {
004029f7              int32_t edi_6 = *(uint32_t*)((char*)esi + 0x54);
00402a00              *(uint32_t*)((char*)esi + 0x54) = arg3;
00402a06              return edi_6;
004029f7              break;
004029f7          }
00402953      }
00402940  }

00402a10  uint32_t jump_table_402a10[0x8] = 
00402a10  {
00402a10      [0x0] =  0x00402960
00402a14      [0x1] =  0x0040296d
00402a18      [0x2] =  0x00402979
00402a1c      [0x3] =  0x00402988
00402a20      [0x4] =  0x00402994
00402a24      [0x5] =  0x004029a3
00402a28      [0x6] =  0x004029e7
00402a2c      [0x7] =  0x004029f7
00402a30  }

00402a30    int32_t sub_402a30(void* arg1)

00402a30  {
00402a35      sub_40baf0(arg1);
00402a3f      return 0;
00402a30  }


00402a40    int32_t sub_402a40(void* arg1, int32_t arg2)

00402a40  {
00402a5b      int32_t result = sub_4075a0(arg1, *(uint32_t*)sub_401970(arg1, arg2), 
00402a5b          *(uint32_t*)((char*)arg1 + 8) - 0x10);
00402a60      int32_t ecx_2 = *(uint32_t*)((char*)arg1 + 8);
00402a60      
00402a68      if (!result)
00402a68      {
00402a75          *(uint32_t*)((char*)arg1 + 8) = ecx_2 - 0x10;
00402a79          return result;
00402a68      }
00402a68      
00402a6d      *(uint32_t*)((char*)arg1 + 8) = ecx_2 + 0x10;
00402a71      return result;
00402a40  }

00402a7a                                                                                90 90 90 90 90 90                            ......

00402a80    void sub_402a80(void* arg1, int32_t arg2)

00402a80  {
00402a89      if (arg2 < 2)
00402a89      {
00402ad3          if (!arg2)
00402ad3          {
00402ae1              void*** edi_2 = *(uint32_t*)((char*)arg1 + 8);
00402ae9              *(uint32_t*)edi_2 = sub_405f60(arg1, &data_4307a0, nullptr);
00402aeb              edi_2[2] = 4;
00402afb              *(uint32_t*)((char*)arg1 + 8) += 0x10;
00402ad3          }
00402ad3          
00402b00          return;
00402a89      }
00402a89      
00402a8f      void* eax_1 = *(uint32_t*)((char*)arg1 + 0x10);
00402a8f      
00402a9a      if (*(uint32_t*)((char*)eax_1 + 0x44) >= *(uint32_t*)((char*)eax_1 + 0x40))
00402a9d          sub_403f70(arg1);
00402a9d      
00402ab4      sub_409060(arg1, arg2, 
00402ab4          ((*(uint32_t*)((char*)arg1 + 8) - *(uint32_t*)((char*)arg1 + 0xc)) >> 4) - 1);
00402acb      *(uint32_t*)((char*)arg1 + 8) += 0x10 - (arg2 << 4);
00402a80  }

00402b01     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00402b10    void* sub_402b10(void* arg1, int32_t arg2)

00402b10  {
00402b15      void* eax = *(uint32_t*)((char*)arg1 + 0x10);
00402b15      
00402b20      if (*(uint32_t*)((char*)eax + 0x44) >= *(uint32_t*)((char*)eax + 0x40))
00402b23          sub_403f70(arg1);
00402b23      
00402b38      int32_t* eax_2 = sub_4060c0(arg1, arg2, sub_402180(arg1));
00402b3d      int32_t** ecx_1 = *(uint32_t*)((char*)arg1 + 8);
00402b43      *(uint32_t*)ecx_1 = eax_2;
00402b45      ecx_1[2] = 7;
00402b55      *(uint32_t*)((char*)arg1 + 8) += 0x10;
00402b59      return &eax_2[6];
00402b10  }

00402b5a                                                                                90 90 90 90 90 90                            ......

00402b60    int32_t sub_402b60(void* arg1, int32_t arg2, int32_t* arg3)

00402b60  {
00402b7e      int32_t result = sub_402bb0(sub_401970(arg1, arg2), arg3, &arg3);
00402b7e      
00402b88      if (result)
00402b88      {
00402b8a          int32_t* edx_1 = arg3;
00402b8e          int32_t* ecx = *(uint32_t*)((char*)arg1 + 8);
00402b94          *(uint32_t*)ecx = *(uint32_t*)edx_1;
00402b99          ecx[1] = edx_1[1];
00402b9f          ecx[2] = edx_1[2];
00402ba9          *(uint32_t*)((char*)arg1 + 8) += 0x10;
00402b88      }
00402b88      
00402bad      return result;
00402b60  }

00402bae                                            90 90                                                                ..

00402bb0    int32_t sub_402bb0(int32_t* arg1, int32_t arg2, void** arg3)

00402bb0  {
00402bb9      if (arg1[2] == 6)
00402bb9      {
00402bbb          void* eax = *(uint32_t*)arg1;
00402bbb          
00402bc2          if (!*(uint8_t*)((char*)eax + 6))
00402bc2          {
00402bee              void* edx_2 = *(uint32_t*)((char*)eax + 0x10);
00402bee              
00402bf9              if (arg2 >= 1 && arg2 <= *(uint32_t*)((char*)edx_2 + 0x24))
00402bf9              {
00402c06                  *(uint32_t*)arg3 =
00402c06                      *(uint32_t*)(*(uint32_t*)((char*)eax + (arg2 << 2) + 0x10) + 8);
00402c13                  return *(uint32_t*)(*(uint32_t*)((char*)edx_2 + 0x1c) + (arg2 << 2) - 4)
00402c13                      + 0x10;
00402bf9              }
00402bc2          }
00402bc2          else if (arg2 >= 1)
00402bcb          {
00402bcf              int32_t edx_1;
00402bcf              (uint8_t)edx_1 = *(uint8_t*)((char*)eax + 7);
00402bcf              
00402bd4              if (arg2 <= edx_1)
00402bd4              {
00402be2                  *(uint32_t*)arg3 = (arg2 << 4) + eax + 8;
00402be9                  return &data_4307a0;
00402bd4              }
00402bcb          }
00402bb9      }
00402bb9      
00402c17      return 0;
00402bb0  }

00402c18                                                                          90 90 90 90 90 90 90 90                          ........

00402c20    int32_t sub_402c20(void* arg1, int32_t* arg2, int32_t arg3)

00402c20  {
00402c2d      void* eax = sub_401970(arg1, arg2);
00402c3f      int32_t result = sub_402bb0(eax, arg3, &arg2);
00402c3f      
00402c4b      if (result)
00402c4b      {
00402c50          int32_t* ecx_1 = arg2;
00402c54          int32_t* edx_2 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
00402c59          *(uint32_t*)((char*)arg1 + 8) = edx_2;
00402c5e          *(uint32_t*)ecx_1 = *(uint32_t*)edx_2;
00402c63          ecx_1[1] = edx_2[1];
00402c69          ecx_1[2] = edx_2[2];
00402c6c          int32_t* eax_3 = *(uint32_t*)((char*)arg1 + 8);
00402c6c          
00402c77          if (eax_3[2] >= 4)
00402c77          {
00402c79              void* eax_4 = *(uint32_t*)eax_3;
00402c79              
00402c7f              if (*(uint8_t*)((char*)eax_4 + 5) & 3)
00402c7f              {
00402c81                  void* ecx_2 = *(uint32_t*)eax;
00402c81                  
00402c86                  if (*(uint8_t*)((char*)ecx_2 + 5) & 4)
00402c8b                      sub_404b60(arg1, ecx_2, eax_4);
00402c7f              }
00402c77          }
00402c4b      }
00402c4b      
00402c98      return result;
00402c20  }

00402c99                                                                             90 90 90 90 90 90 90                           .......

00402ca0    int32_t sub_402ca0(void* arg1, int32_t arg2, int32_t arg3)

00402ca0  {
00402cba      void var_64;
00402cba      
00402cba      if (!sub_40ac30(arg1, 0, &var_64))
00402cba      {
00402cc4          int32_t var_6c_1 = arg3;
00402cc5          int32_t __saved_esi = arg2;
00402ccc          sub_402e40(arg1, "bad argument #%d (%s)");
00402cd8          return 0;
00402cba      }
00402cba      
00402cd9      int32_t ebx;
00402cd9      int32_t var_6c_2 = ebx;
00402ce6      sub_40ae20(arg1, U"n", &var_64);
00402ceb      char* var_5c;
00402ceb      char* eax_1 = var_5c;
00402cf2      char* esi = "method";
00402cf7      int32_t eax_3;
00402cf7      
00402cf7      while (true)
00402cf7      {
00402cf7          char edx_2 = *(uint8_t*)eax_1;
00402cf9          (uint8_t)ebx = *(uint8_t*)esi;
00402cfd          bool c_1 = edx_2 < (uint8_t)ebx;
00402cfd          
00402cff          if (edx_2 == (uint8_t)ebx)
00402cff          {
00402d03              if (!edx_2)
00402d03              {
00402d1b                  eax_3 = 0;
00402d1d                  break;
00402d03              }
00402d03              
00402d05              edx_2 = eax_1[1];
00402d08              (uint8_t)ebx = esi[1];
00402d0d              c_1 = edx_2 < (uint8_t)ebx;
00402d0d              
00402d0f              if (edx_2 == (uint8_t)ebx)
00402d0f              {
00402d11                  eax_1 = &eax_1[2];
00402d14                  esi = &esi[2];
00402d14                  
00402d19                  if (edx_2)
00402d19                      continue;
00402d19                  
00402d1b                  eax_3 = 0;
00402d1d                  break;
00402d0f              }
00402cff          }
00402cff          
00402d1f          bool c_2 = /* bool c_2 = unimplemented  {sbb eax, eax} */;
00402d21          eax_3 = eax_1 - eax_1 + 1;
00402d21          break;
00402cf7      }
00402cf7      
00402d28      void* __saved_esi_3;
00402d28      
00402d28      if (!eax_3)
00402d28      {
00402d2e          bool cond:0_1 = arg2 != 1;
00402d2f          arg2 -= 1;
00402d2f          
00402d33          if (!cond:0_1)
00402d33          {
00402d3d              int32_t var_6c_3 = arg3;
00402d3e              void* __saved_esi_1 = __saved_esi_3;
00402d45              sub_402e40(arg1, "calling '%s' on bad self (%s)");
00402d51              return 0;
00402d33          }
00402d28      }
00402d28      
00402d52      void* __saved_esi_4 = __saved_esi_3;
00402d52      
00402d58      if (!__saved_esi_4)
00402d58      {
00402d5a          __saved_esi_4 = &data_42b128;
00402d5f          void* var_60 = &data_42b128;
00402d58      }
00402d58      
00402d67      int32_t var_6c_4 = arg3;
00402d68      void* __saved_esi_2 = __saved_esi_4;
00402d6d      int32_t var_74_2 = arg2;
00402d74      sub_402e40(arg1, "bad argument #%d to '%s' (%s)");
00402d80      return 0;
00402ca0  }

00402d81     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00402d90    int32_t sub_402d90(void* arg1, int32_t arg2, int32_t arg3)

00402d90  {
00402da1      int32_t var_14 = sub_401b60(arg1, arg2);
00402da8      int32_t var_1c = sub_401b90(arg1);
00402dad      int32_t var_20 = arg3;
00402dbc      sub_402ca0(arg1, arg2, sub_4020b0(arg1, "%s expected, got %s"));
00402dc6      return 0;
00402d90  }

00402dc7                       90 90 90 90 90 90 90 90 90                                                         .........

00402dd0    int32_t sub_402dd0(void* arg1, int32_t arg2)

00402dd0  {
00402ded      void var_64;
00402ded      
00402ded      if (sub_40ac30(arg1, arg2, &var_64))
00402ded      {
00402dfa          sub_40ae20(arg1, "Sl", &var_64);
00402e08          int32_t var_50;
00402e08          
00402e08          if (var_50 > 0)
00402e08          {
00402e0a              int32_t var_6c_2 = var_50;
00402e0f              void var_40;
00402e0f              void* var_70_1 = &var_40;
00402e22              return sub_4020b0(arg1, "%s:%d: ");
00402e08          }
00402ded      }
00402ded      
00402e37      return sub_401ff0(arg1, &data_4307a0, nullptr);
00402dd0  }

00402e38                                                                          90 90 90 90 90 90 90 90                          ........

00402e40    int32_t sub_402e40(void* arg1, double* arg2)

00402e40  {
00402e48      sub_402dd0(arg1, 1);
00402e58      void arg_c;
00402e58      sub_402080(arg1, arg2, &arg_c);
00402e60      sub_402a80(arg1, 2);
00402e66      sub_402a30(arg1);
00402e6f      return 0;
00402e40  }


00402e70    int32_t sub_402e70(void* arg1, int32_t arg2, int32_t arg3, int32_t* arg4)

00402e70  {
00402e74      int32_t ebx;
00402e74      int32_t var_4 = ebx;
00402e7c      char* eax_1;
00402e7c      void* esi;
00402e7c      
00402e7c      if (!arg3)
00402e7c      {
00402e97          esi = arg1;
00402e9d          eax_1 = sub_4030b0(esi, arg2, nullptr);
00402e7c      }
00402e7c      else
00402e7c      {
00402e7e          esi = arg1;
00402e89          eax_1 = sub_4030f0(esi, arg2, arg3, nullptr);
00402e7c      }
00402e7c      
00402eab      int32_t result = 0;
00402ead      char* ecx_2 = *(uint32_t*)arg4;
00402ead      
00402eb1      if (ecx_2)
00402eb1      {
00402eb3          int32_t* edi_1 = arg4;
00402eb3          
00402eb5          while (true)
00402eb5          {
00402eb5              char* esi_1 = eax_1;
00402eb7              int32_t ecx_4;
00402eb7              
00402eb7              while (true)
00402eb7              {
00402eb7                  (uint8_t)ebx = *(uint8_t*)ecx_2;
00402eb9                  int32_t* edx;
00402eb9                  (uint8_t)edx = (uint8_t)ebx;
00402ebb                  char temp0_1 = *(uint8_t*)esi_1;
00402ebb                  bool c_1 = (uint8_t)ebx < temp0_1;
00402ebb                  
00402ebd                  if ((uint8_t)ebx == temp0_1)
00402ebd                  {
00402ec1                      if (!(uint8_t)edx)
00402ec1                      {
00402ed7                          ecx_4 = 0;
00402ed9                          break;
00402ec1                      }
00402ec1                      
00402ec3                      (uint8_t)ebx = ecx_2[1];
00402ec6                      (uint8_t)edx = (uint8_t)ebx;
00402ec8                      char temp3_1 = esi_1[1];
00402ec8                      c_1 = (uint8_t)ebx < temp3_1;
00402ec8                      
00402ecb                      if ((uint8_t)ebx == temp3_1)
00402ecb                      {
00402ecd                          ecx_2 = &ecx_2[2];
00402ed0                          esi_1 = &esi_1[2];
00402ed0                          
00402ed5                          if ((uint8_t)edx)
00402ed5                              continue;
00402ed5                          
00402ed7                          ecx_4 = 0;
00402ed9                          break;
00402ecb                      }
00402ebd                  }
00402ebd                  
00402edb                  bool c_2 = /* bool c_2 = unimplemented  {sbb ecx, ecx} */;
00402edd                  ecx_4 = ecx_2 - ecx_2 + 1;
00402edd                  break;
00402eb7              }
00402eb7              
00402ee2              if (!ecx_4)
00402f12                  return result;
00402f12              
00402ee4              ecx_2 = edi_1[1];
00402ee7              edi_1 = &edi_1[1];
00402eea              result += 1;
00402eea              
00402eed              if (!ecx_2)
00402eed                  break;
00402eb5          }
00402eb5          
00402eef          esi = arg1;
00402eb1      }
00402eb1      
00402ef3      char* var_14_1 = eax_1;
00402f06      return sub_402ca0(esi, arg2, sub_4020b0(esi, "invalid option '%s'"));
00402e70  }

00402f13                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00402f20    int32_t sub_402f20(void* arg1, char* arg2)

00402f20  {
00402f31      sub_402250(arg1, 0xffffd8f0, arg2);
00402f31      
00402f43      if (sub_401b60(arg1, 0xffffffff))
00402f49          return 0;
00402f49      
00402f4d      sub_4018d0(arg1, 0xfffffffe);
00402f57      sub_402330(arg1, 0, 0);
00402f5f      sub_401b20(arg1, 0xffffffff);
00402f6b      sub_402490(arg1, 0xffffd8f0, arg2);
00402f7a      return 1;
00402f20  }

00402f7b                                                                                   90 90 90 90 90                             .....

00402f80    int32_t sub_402f80(void* arg1, int32_t arg2, char* arg3)

00402f80  {
00402f8e      int32_t result = sub_401ed0(arg1, arg2);
00402fa0      sub_402250(arg1, 0xffffd8f0, arg3);
00402fa0      
00402faa      if (!result)
00402fce          sub_402d90(arg1, arg2, arg3);
00402faa      else if (!sub_402380(arg1, arg2))
00402fce          sub_402d90(arg1, arg2, arg3);
00402fb8      else if (!sub_401c50(arg1, 0xffffffff, 0xfffffffe))
00402fce          sub_402d90(arg1, arg2, arg3);
00402fce      
00402fd9      sub_4018d0(arg1, 0xfffffffd);
00402fe7      return result;
00402f80  }

00402fe8                          90 90 90 90 90 90 90 90                                                          ........

00402ff0    int32_t sub_402ff0(void* arg1, int32_t arg2, int32_t arg3)

00402ff0  {
00402ffb      int32_t result = sub_4017a0(arg1, arg2);
00402ffb      
00403005      if (result)
0040301b          return result;
0040301b      
0040300b      int32_t var_8_1 = arg3;
00403012      return sub_402e40(arg1, "stack overflow (%s)");
00402ff0  }

0040301c                                                                                      90 90 90 90                              ....

00403020    int32_t sub_403020(void* arg1, int32_t arg2, int32_t arg3)

00403020  {
0040302c      int32_t result = sub_401b60(arg1, arg2);
0040302c      
0040303a      if (result == arg3)
00403049          return result;
00403049      
0040303f      return sub_403050(arg1, arg2, arg3);
00403020  }

0040304a                                90 90 90 90 90 90                                                            ......

00403050    int32_t sub_403050(void* arg1, int32_t arg2, int32_t arg3)

00403050  {
00403059      int32_t var_8 = arg3;
00403067      sub_402d90(arg1, arg2, sub_401b90(arg1));
00403070      return 0;
00403050  }

00403071                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00403080    int32_t sub_403080(void* arg1, int32_t arg2)

00403080  {
0040308c      int32_t result = sub_401b60(arg1, arg2);
0040308c      
00403097      if (result != 0xffffffff)
004030aa          return result;
004030aa      
004030a0      return sub_402ca0(arg1, arg2, "value expected");
00403080  }

004030ab                                   90 90 90 90 90                                                             .....

004030b0    int32_t sub_4030b0(void* arg1, int32_t arg2, int32_t* arg3)

004030b0  {
004030c2      int32_t result = sub_401db0(arg1, arg2, arg3);
004030c2      
004030ce      if (!result)
004030d4          sub_403050(arg1, arg2, 4);
004030d4      
004030e1      return result;
004030b0  }

004030e2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

004030f0    int32_t sub_4030f0(void* arg1, int32_t arg2, int32_t arg3, int32_t* arg4)

004030f0  {
00403106      if (sub_401b60(arg1, arg2) > 0)
00403145          return sub_4030b0(arg1, arg2, arg4);
00403145      
00403112      if (arg4)
00403112      {
00403116          if (arg3)
00403116          {
00403118              int32_t edi_1 = arg3;
0040311a              int32_t i = 0xffffffff;
0040311a              
0040311f              while (i)
0040311f              {
0040311f                  bool cond:0_1 = 0 != *(uint8_t*)edi_1;
0040311f                  edi_1 += 1;
0040311f                  i -= 1;
0040311f                  
0040311f                  if (!cond:0_1)
0040311f                      break;
0040311f              }
0040311f              
00403125              *(uint32_t*)arg4 = ~i - 1;
0040312a              return arg3;
00403116          }
00403116          
0040312d          *(uint32_t*)arg4 = 0;
00403112      }
00403112      
00403133      return arg3;
004030f0  }

00403146                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00403150    long double sub_403150(void* arg1, int32_t arg2)

00403150  {
0040315f      long double result = sub_401cf0(arg1, arg2);
00403164      long double temp0 = (long double)0.0;
00403164      result - temp0;
0040316a      bool c1 = /* bool c1 = unimplemented  {fst qword [esp+0x10], st0} */;
0040316a      
00403176      if (!(*(uint8_t*)((char*)((result < temp0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9
00403176              | (FCMP_UO(result, temp0) ? 1 : 0) << 0xa | (result == temp0 ? 1 : 0) << 0xe
00403176              | 0x3800))[1] & 0x40))
0040319d          return result;
0040319d      
00403186      if (!sub_401be0(arg1, arg2))
0040318c          sub_403050(arg1, arg2, 3);
0040318c      
00403194      return (long double)(double)result;
00403150  }

0040319e                                                                                            90 90                                ..

004031a0    long double sub_4031a0(void* arg1, int32_t arg2, double arg3)

004031a0  {
004031b6      if (sub_401b60(arg1, arg2) > 0)
004031cb          return sub_403150(arg1, arg2);
004031cb      
004031be      return (long double)arg3;
004031a0  }

004031cc                                      90 90 90 90                                                              ....

004031d0    void* sub_4031d0(void* arg1, int32_t arg2)

004031d0  {
004031dd      void* result = sub_401d30(arg1, arg2);
004031dd      
004031e9      if (!result && !sub_401be0(arg1, arg2))
004031fd          sub_403050(arg1, arg2, 3);
004031fd      
0040320a      return result;
004031d0  }

0040320b                                   90 90 90 90 90                                                             .....

00403210    void* sub_403210(void* arg1, int32_t arg2, int32_t arg3)

00403210  {
00403226      if (sub_401b60(arg1, arg2) > 0)
0040323b          return sub_4031d0(arg1, arg2);
0040323b      
0040322e      return arg3;
00403210  }

0040323c                                                                                      90 90 90 90                              ....

00403240    int32_t sub_403240(void* arg1, int32_t arg2, char* arg3)

00403240  {
0040324b      int32_t result = sub_402380(arg1, arg2);
0040324b      
00403255      if (!result)
00403258          return result;
00403258      
0040325f      sub_402040(arg1, arg3);
00403267      sub_4022b0(arg1, 0xfffffffe);
00403267      
00403279      if (sub_401b60(arg1, 0xffffffff))
00403279      {
0040328d          sub_401920(arg1, 0xfffffffe);
0040329b          return 1;
00403279      }
00403279      
0040327e      sub_4018d0(arg1, 0xfffffffd);
00403289      return 0;
00403240  }

0040329c                                                                                      90 90 90 90                              ....

004032a0    int32_t sub_4032a0(void* arg1, int32_t arg2, char* arg3)

004032a0  {
004032a1      int32_t esi = arg2;
004032a1      
004032b4      if (esi <= 0 && esi > 0xffffd8f0)
004032bf          esi = esi + sub_4018c0(arg1) + 1;
004032bf      
004032ca      int32_t result = sub_403240(arg1, esi, arg3);
004032ca      
004032d4      if (!result)
004032d8          return result;
004032d8      
004032db      sub_401b20(arg1, esi);
004032e5      sub_402730(arg1, 1, 1);
004032f4      return 1;
004032a0  }

004032f5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00403300    void* sub_403300(void* arg1, char* arg2, int32_t* arg3)

00403300  {
00403319      return sub_403320(arg1, arg2, arg3, nullptr);
00403300  }

0040331a                                                                                90 90 90 90 90 90                            ......

00403320    void* sub_403320(void* arg1, char* arg2, int32_t* arg3, char* arg4)

00403320  {
00403330      int32_t* edi = arg3;
00403330      
00403336      if (arg2)
00403336      {
0040333d          char* eax_1 = sub_403430(edi);
00403352          sub_403510(arg1, 0xffffd8f0, "_LOADED", eax_1);
0040335b          sub_402250(arg1, 0xffffffff, arg2);
0040335b          
0040336e          if (sub_401b60(arg1, 0xffffffff) != 5)
0040336e          {
00403373              sub_4018d0(arg1, 0xfffffffe);
00403373              
0040338e              if (sub_403510(arg1, 0xffffd8ee, arg2, eax_1))
0040338e              {
00403390                  char* var_14_2 = arg2;
00403397                  sub_402e40(arg1, "name conflict for module '%s'");
0040338e              }
0040338e              
004033a2              sub_401b20(arg1, 0xffffffff);
004033ab              sub_402490(arg1, 0xfffffffd, arg2);
0040336e          }
0040336e          
004033b6          sub_401920(arg1, 0xfffffffe);
004033c2          sub_401a20(arg1, 0xffffffff - arg4);
00403336      }
00403336      
004033cd      if (*(uint32_t*)edi)
004033cd      {
00403417          int32_t i;
00403417          
00403417          do
00403417          {
004033d1              if (arg4 > 0)
004033d1              {
004033d5                  arg2 = arg4;
004033ee                  bool cond:0_1;
004033ee                  
004033ee                  do
004033ee                  {
004033dd                      sub_401b20(arg1, -(arg4));
004033e9                      cond:0_1 = arg2 != 1;
004033ea                      arg2 -= 1;
004033ee                  } while (cond:0_1);
004033d1              }
004033d1              
004033f6              sub_4020e0(arg1, edi[1], arg4);
00403407              sub_402490(arg1, 0xfffffffe - arg4, *(uint32_t*)edi);
0040340c              i = edi[2];
0040340f              edi = &edi[2];
00403417          } while (i);
004033cd      }
004033cd      
0040342c      return sub_4018d0(arg1, 0xffffffff - arg4);
00403320  }

0040342d                                         90 90 90                                                               ...

00403430    int32_t sub_403430(int32_t* arg1)

00403430  {
00403430      int32_t* ecx = arg1;
00403434      int32_t result = 0;
00403434      
00403439      if (*(uint32_t*)ecx)
00403439      {
00403444          int32_t i;
00403444          
00403444          do
00403444          {
0040343b              i = ecx[2];
0040343e              ecx = &ecx[2];
00403441              result += 1;
00403444          } while (i);
00403439      }
00403439      
00403446      return result;
00403430  }

00403447                       90 90 90 90 90 90 90 90 90                                                         .........

00403450    int32_t sub_403450(void* arg1, void* arg2, void* arg3, char* arg4)

00403450  {
00403456      int32_t i = 0xffffffff;
00403466      void* edi = arg3;
00403466      
00403468      while (i)
00403468      {
00403468          bool cond:0_1 = 0 != *(uint8_t*)edi;
00403468          edi += 1;
00403468          i -= 1;
00403468          
00403468          if (!cond:0_1)
00403468              break;
00403468      }
00403468      
0040347c      int32_t var_20c[0x83];
0040347c      sub_403810(arg1, &var_20c);
00403481      void* edi_1 = arg2;
00403481      
00403496      for (char* i_1 = sub_417260(edi_1, arg3); i_1; i_1 = sub_417260(edi_1, arg3))
00403496      {
004034a3          sub_4036d0(&var_20c, edi_1, i_1 - edi_1);
004034b5          sub_403720(&var_20c, arg4);
004034ba          edi_1 = &i_1[~i - 1];
00403496      }
00403496      
004034d3      sub_403720(&var_20c, edi_1);
004034dd      sub_403750(&var_20c);
00403500      return sub_401db0(arg1, 0xffffffff, nullptr);
00403450  }

00403501     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00403510    char* sub_403510(void* arg1, int32_t arg2, char* arg3, int32_t arg4)

00403510  {
0040351e      sub_401b20(arg1, arg2);
00403523      char* result = arg3;
004035ce      void* edi_1;
004035ce      
004035ce      do
004035ce      {
0040352d          void* eax = sub_4172f0(result, 0x2e);
00403532          edi_1 = eax;
00403532          
00403539          if (!edi_1)
00403539          {
0040353b              char* result_1 = result;
0040353d              int32_t i = 0xffffffff;
0040353d              
00403540              while (i)
00403540              {
00403540                  bool cond:0_1 = (uint8_t)eax != *(uint8_t*)result_1;
00403540                  result_1 = &result_1[1];
00403540                  i -= 1;
00403540                  
00403540                  if (!cond:0_1)
00403540                      break;
00403540              }
00403540              
00403547              edi_1 = ~i - 1 + result;
00403539          }
00403539          
0040354b          int32_t* ebp_2 = (char*)edi_1 - result;
00403550          sub_401ff0(arg1, result, ebp_2);
00403558          sub_4022b0(arg1, 0xfffffffe);
00403558          
0040356a          if (sub_401b60(arg1, 0xffffffff))
0040356a          {
004035ba              if (sub_401b60(arg1, 0xffffffff) != 5)
004035ba              {
004035d8                  sub_4018d0(arg1, 0xfffffffd);
004035e6                  return result;
004035ba              }
0040356a          }
0040356a          else
0040356a          {
0040356f              sub_4018d0(arg1, 0xfffffffe);
0040357b              int32_t eax_3 = 1;
0040357b              
00403580              if (*(uint8_t*)edi_1 != 0x2e)
00403582                  eax_3 = arg4;
00403582              
0040358a              sub_402330(arg1, 0, eax_3);
00403592              sub_401ff0(arg1, result, ebp_2);
0040359a              sub_401b20(arg1, 0xfffffffe);
004035a2              sub_402460(arg1, 0xfffffffc);
0040356a          }
0040356a          
004035bf          sub_401920(arg1, 0xfffffffe);
004035cb          result = (char*)edi_1 + 1;
004035ce      } while (*(uint8_t*)edi_1 == 0x2e);
004035ed      return 0;
00403510  }

004035ee                                            90 90                                                                ..

004035f0    void* sub_4035f0(int32_t* arg1)

004035f0  {
00403600      if (sub_403610(arg1))
00403603          sub_403650(arg1);
00403603      
0040360f      return &arg1[3];
004035f0  }


00403610    int32_t sub_403610(int32_t* arg1)

00403610  {
00403617      void* eax_1 = *(uint32_t*)arg1 - arg1;
00403617      
0040361c      if (eax_1 == 0xc)
00403621          return 0;
00403621      
0040362c      sub_401ff0(arg1[2], &arg1[3], (char*)eax_1 - 0xc);
00403637      int32_t eax_6 = arg1[1] + 1;
00403638      *(uint32_t*)arg1 = &arg1[3];
0040363a      arg1[1] = eax_6;
00403644      return 1;
00403610  }

00403645                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00403650    void sub_403650(int32_t arg1)

00403650  {
00403651      int32_t ebp = arg1;
00403656      int32_t esi = 1;
00403656      
0040365e      if (*(uint32_t*)(ebp + 4) <= 1)
0040365e          return;
0040365e      
00403661      void* ebx_1 = *(uint32_t*)(ebp + 8);
00403670      arg1 = sub_401e30(ebx_1, 0xffffffff);
00403674      int32_t edi_1 = 0xfffffffe;
004036a4      int32_t ecx_1;
004036a4      
004036a4      do
004036a4      {
0040367b          int32_t eax_2 = sub_401e30(ebx_1, edi_1);
00403680          ecx_1 = *(uint32_t*)(ebp + 4);
00403680          
00403694          if (ecx_1 - esi + 1 < 0xa && arg1 <= eax_2)
00403694              break;
00403694          
0040369c          esi += 1;
0040369d          edi_1 -= 1;
004036a0          arg1 += eax_2;
004036a4      } while (esi < ecx_1);
004036a8      sub_402a80(ebx_1, esi);
004036bd      *(uint32_t*)(ebp + 4) += 1 - esi;
00403650  }

004036c4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

004036d0    void* sub_4036d0(int32_t* arg1, char* arg2, int32_t arg3)

004036d0  {
004036d6      void* result = arg3 - 1;
004036d6      
004036d9      if (arg3)
004036d9      {
004036e3          char* edi_1 = arg2;
004036ed          void* i_1 = (char*)result + 1;
0040370a          void* i;
0040370a          
0040370a          do
0040370a          {
004036f2              if (*(uint32_t*)arg1 >= &arg1[0x83])
004036f5                  sub_4035f0(arg1);
004036f5              
004036ff              (uint8_t)result = *(uint8_t*)edi_1;
00403701              **(uint8_t**)arg1 = (uint8_t)result;
00403706              edi_1 = &edi_1[1];
00403707              i = i_1;
00403707              i_1 -= 1;
00403708              *(uint32_t*)arg1 += 1;
0040370a          } while (i != 1);
004036d9      }
004036d9      
00403710      return result;
004036d0  }

00403711                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00403720    void* sub_403720(int32_t* arg1, char* arg2)

00403720  {
00403725      char* edi = arg2;
00403727      int32_t i = 0xffffffff;
00403727      
0040372c      while (i)
0040372c      {
0040372c          bool cond:0_1 = 0 != *(uint8_t*)edi;
0040372c          edi = &edi[1];
0040372c          i -= 1;
0040372c          
0040372c          if (!cond:0_1)
0040372c              break;
0040372c      }
0040372c      
00403741      return sub_4036d0(arg1, arg2, ~i - 1);
00403720  }

00403742        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00403750    int32_t sub_403750(int32_t* arg1)

00403750  {
00403756      sub_403610(arg1);
00403763      int32_t result = sub_402a80(arg1[2], arg1[1]);
0040376b      arg1[1] = 1;
00403773      return result;
00403750  }

00403774                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00403780    void* sub_403780(int32_t* arg1)

00403780  {
00403781      int32_t* ebx = arg1;
0040378a      void* ebp = ebx[2];
00403792      int32_t eax = sub_401db0(ebp, 0xffffffff, &arg1);
00403797      int32_t edi = *(uint32_t*)ebx;
00403799      int32_t* ecx = arg1;
00403799      
004037ac      if (ecx <= (char*)ebx - edi + 0x20c)
004037ac      {
004037b8          int32_t esi_1;
004037b8          int32_t edi_1;
004037b8          edi_1 = __builtin_memcpy(edi, eax, ecx >> 2 << 2);
004037c0          __builtin_memcpy(edi_1, esi_1, ecx & 3);
004037ca          *(uint32_t*)ebx += arg1;
004037d8          return sub_4018d0(ebp, 0xfffffffe);
004037ac      }
004037ac      
004037e4      if (sub_403610(ebx))
004037e9          sub_401a20(ebp, 0xfffffffe);
004037e9      
004037f6      ebx[1] += 1;
00403804      return sub_403650(ebx);
00403780  }

00403805                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00403810    int32_t* sub_403810(int32_t arg1, int32_t* arg2)

00403810  {
0040381b      arg2[2] = arg1;
0040381e      *(uint32_t*)arg2 = &arg2[3];
00403820      arg2[1] = 0;
00403827      return arg2;
00403810  }

00403828                          90 90 90 90 90 90 90 90                                                          ........

00403830    int32_t sub_403830(void* arg1, PSTR arg2)

00403830  {
00403853      int32_t ebx_1 = sub_4018c0(arg1) + 1;
00403856      int32_t var_208 = 0;
0040385e      void* var_204;
0040385e      void* eax_1;
0040385e      
0040385e      if (arg2)
0040385e      {
00403896          PSTR var_21c_1 = arg2;
0040389d          sub_4020b0(arg1, 0x42b220);
004038a8          eax_1 = sub_417118(arg2, U"r");
004038b0          var_204 = eax_1;
004038b0          
004038b6          if (!eax_1)
004038b6          {
004038bf              sub_403ab0(arg1, "open", ebx_1);
004038d1              return 6;
004038b6          }
0040385e      }
0040385e      else
0040385e      {
00403868          sub_401ff0(arg1, "=stdin", 6);
0040386d          eax_1 = &data_42cbf0;
00403875          var_204 = &data_42cbf0;
0040385e      }
0040385e      
0040387d      *(uint32_t*)((char*)eax_1 + 4) -= 1;
00403889      uint32_t eax_3;
00403889      
00403889      if (*(uint32_t*)((char*)var_204 + 4) < 0)
004038d3          eax_3 = sub_41741a(var_204);
00403889      else
00403889      {
0040388b          char* edx_1 = *(uint32_t*)var_204;
0040388f          (uint8_t)eax_3 = *(uint8_t*)edx_1;
00403892          *(uint32_t*)var_204 = &edx_1[1];
00403889      }
00403889      
004038de      if (eax_3 == 0x23)
004038de      {
004038e0          var_208 = 1;
004038e0          
004038f0          while (true)
004038f0          {
004038f0              *(uint32_t*)((char*)var_204 + 4) -= 1;
004038f0              
004038fc              if (*(uint32_t*)((char*)var_204 + 4) < 0)
0040390a                  eax_3 = sub_41741a(var_204);
004038fc              else
004038fc              {
004038fe                  char* edx_3 = *(uint32_t*)var_204;
00403902                  (uint8_t)eax_3 = *(uint8_t*)edx_3;
00403905                  *(uint32_t*)var_204 = &edx_3[1];
004038fc              }
004038fc              
00403915              if (eax_3 == 0xffffffff)
00403915                  break;
00403915              
0040391a              if (eax_3 == 0xa)
0040391a              {
00403924                  *(uint32_t*)((char*)var_204 + 4) -= 1;
00403927                  void** ecx_8 = var_204;
00403927                  
00403930                  if (ecx_8[1] < 0)
0040393e                      eax_3 = sub_41741a(ecx_8);
00403930                  else
00403930                  {
00403932                      char* edx_5 = *(uint32_t*)ecx_8;
00403936                      (uint8_t)eax_3 = *(uint8_t*)edx_5;
00403939                      *(uint32_t*)ecx_8 = &edx_5[1];
00403930                  }
00403930                  
00403930                  break;
0040391a              }
004038f0          }
004038de      }
004038de      
0040395f      if (eax_3 == (int32_t)(*(uint8_t*)data_42b214) && var_204 != &data_42cbf0)
0040395f      {
00403962          sub_416e00(var_204);
0040396d          void* eax_8 = sub_417118(arg2, "rb");
00403975          var_204 = eax_8;
00403975          
0040397b          if (!eax_8)
0040397b          {
00403984              sub_403ab0(arg1, "reopen", ebx_1);
00403996              return 6;
0040397b          }
0040397b          
0040399f          while (true)
0040399f          {
0040399f              *(uint32_t*)((char*)eax_8 + 4) -= 1;
0040399f              
004039ab              if (*(uint32_t*)((char*)var_204 + 4) < 0)
004039b9                  eax_3 = sub_41741a(var_204);
004039ab              else
004039ab              {
004039ad                  char* edx_7 = *(uint32_t*)var_204;
004039b1                  (uint8_t)eax_3 = *(uint8_t*)edx_7;
004039b4                  *(uint32_t*)var_204 = &edx_7[1];
004039ab              }
004039ab              
004039c4              if (eax_3 == 0xffffffff)
004039c4                  break;
004039c4              
004039cf              if (eax_3 == (int32_t)(*(uint8_t*)data_42b214))
004039cf                  break;
004039cf              
00403997              eax_8 = var_204;
0040399f          }
0040399f          
004039d1          var_208 = 0;
0040395f      }
0040395f      
004039df      sub_4173ac(eax_3, var_204);
004039fa      int32_t result =
004039fa          sub_4028b0(arg1, sub_403a60, &var_208, sub_401db0(arg1, 0xffffffff, nullptr));
00403a0b      int32_t esi_2 = *(uint32_t*)((char*)var_204 + 0xc) & 0x20;
00403a0b      
00403a13      if (var_204 != &data_42cbf0)
00403a16          sub_416e00(var_204);
00403a16      
00403a22      if (!esi_2)
00403a22      {
00403a43          sub_401920(arg1, ebx_1);
00403a57          return result;
00403a22      }
00403a22      
00403a24      sub_4018d0(arg1, ebx_1);
00403a30      sub_403ab0(arg1, "read", ebx_1);
00403a42      return 6;
00403830  }

00403a58                                                                          90 90 90 90 90 90 90 90                          ........

00403a60    void* sub_403a60(int32_t* arg1, int32_t* arg2)

00403a60  {
00403a67      if (*(uint32_t*)arg1)
00403a67      {
00403a69          *(uint32_t*)arg1 = 0;
00403a73          *(uint32_t*)arg2 = 1;
00403a7e          return &data_42b22c;
00403a67      }
00403a67      
00403a7f      int32_t* ecx = arg1[1];
00403a7f      
00403a86      if (ecx[3] & 0x10)
00403a8a          return 0;
00403a8a      
00403a98      uint32_t eax_3 = sub_416e56(&arg1[2], 1, 0x200, ecx);
00403aa8      *(uint32_t*)arg2 = eax_3;
00403aaf      return (eax_3 - eax_3) & &arg1[2];
00403a60  }


00403ab0    int32_t sub_403ab0(void* arg1, int32_t arg2, int32_t arg3)

00403ab0  {
00403ab9      sub_416fca(data_4307d4);
00403ad6      int32_t var_20 = 0x4307ac;
00403ad7      int32_t var_24 = sub_401db0(arg1, arg3, nullptr) + 1;
00403ad8      int32_t var_28 = arg2;
00403adf      sub_4020b0(arg1, "cannot %s %s: %s");
00403ae6      sub_401920(arg1, arg3);
00403af6      return 6;
00403ab0  }

00403af7                                                                       90 90 90 90 90 90 90 90 90                         .........

00403b00    int32_t sub_403b00(void* arg1, int32_t arg2, int32_t arg3, void* arg4)

00403b00  {
00403b0f      int32_t var_8 = arg2;
00403b17      int32_t var_4 = arg3;
00403b2f      return sub_4028b0(arg1, sub_403b30, &var_8, arg4);
00403b00  }


00403b30    int32_t sub_403b30(int32_t* arg1, int32_t* arg2)

00403b30  {
00403b34      int32_t ecx = arg1[1];
00403b34      
00403b39      if (!ecx)
00403b3d          return 0;
00403b3d      
00403b42      *(uint32_t*)arg2 = ecx;
00403b44      arg1[1] = 0;
00403b4d      return *(uint32_t*)arg1;
00403b30  }

00403b4e                                            90 90                                                                ..

00403b50    int32_t* sub_403b50()

00403b50  {
00403b58      int32_t* result = sub_401520(sub_403b80, nullptr);
00403b58      
00403b64      if (result)
00403b6c          sub_401860(result, sub_403bb0);
00403b6c      
00403b77      return result;
00403b50  }

00403b78                                                                          90 90 90 90 90 90 90 90                          ........

00403b80    void* sub_403b80(int32_t* arg1, int32_t arg2)

00403b80  {
00403b86      if (arg2)
00403b86      {
00403b9c          int32_t var_4_1 = arg2;
00403ba6          int32_t edx;
00403ba6          return sub_4175ac(arg2, edx, arg1, arg1);
00403b86      }
00403b86      
00403b8c      int32_t* var_4 = arg1;
00403b8d      int32_t* ecx;
00403b8d      sub_41784c(ecx);
00403b97      return 0;
00403b80  }

00403ba7                       90 90 90 90 90 90 90 90 90                                                         .........

00403bb0    int32_t sub_403bb0(void* arg1)

00403bb0  {
00403bbe      int32_t var_10 = sub_401db0(arg1, 0xffffffff, nullptr);
00403bc9      sub_4178b5(0x42cc30, "PANIC: unprotected error in call to Lua API (%s)\n");
00403bd3      return 0;
00403bb0  }

00403bd4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00403be0    int32_t (*)(void* arg1) sub_403be0(void* arg1)

00403be0  {
00403be0      int32_t (* i)(void* arg1) = sub_4124c0;
00403be8      void** const esi = &data_4281d0;
00403be8      
00403c1b      do
00403c1b      {
00403bf8          sub_4020e0(arg1, i, 0);
00403c01          sub_402040(arg1, *(uint32_t*)esi);
00403c0b          sub_402730(arg1, 1, 0);
00403c10          i = esi[3];
00403c13          esi = &esi[2];
00403c1b      } while (i);
00403c1b      
00403c1f      return i;
00403be0  }


00403c20    int32_t sub_403c20(int32_t* arg1, int32_t arg2)

00403c20  {
00403c27      void* ebp = arg1[4];
00403c2b      int32_t result = 0;
00403c2d      int32_t* i_1 = *(uint32_t*)((char*)ebp + 0x70);
00403c2d      
00403c34      for (int32_t* i = *(uint32_t*)i_1; i; i = *(uint32_t*)i_1)
00403c34      {
00403c36          int32_t* eax;
00403c36          (uint8_t)eax = *(uint8_t*)((char*)i + 5);
00403c36          
00403c3b          if ((uint8_t)eax & 3)
00403c3b          {
00403c47              if (!((uint8_t)eax & 8))
00403c47                  goto label_403c4d;
00403c47              
00403c49              i_1 = i;
00403c3b          }
00403c3b          else if (!arg2 || (uint8_t)eax & 8)
00403c49              i_1 = i;
00403c47          else
00403c47          {
00403c4d          label_403c4d:
00403c4d              eax = i[2];
00403c4d              
00403c58              if (!eax || *(uint8_t*)((char*)eax + 6) & 4)
00403c58              {
00403c77              label_403c77:
00403c77                  (uint8_t)eax = *(uint8_t*)((char*)i + 5);
00403c7a                  i_1 = i;
00403c7c                  (uint8_t)eax |= 8;
00403c7e                  *(uint8_t*)((char*)i + 5) = (uint8_t)eax;
00403c58              }
00403c58              else
00403c58              {
00403c75                  if (!sub_407510(eax, 2, *(uint32_t*)(arg1[4] + 0xc4)))
00403c75                      goto label_403c77;
00403c75                  
00403c86                  int32_t eax_1 = *(uint32_t*)i;
00403c88                  result = result + i[4] + 0x18;
00403c8c                  int32_t edx_2;
00403c8c                  (uint8_t)edx_2 = *(uint8_t*)((char*)i + 5);
00403c8f                  (uint8_t)edx_2 |= 8;
00403c92                  *(uint8_t*)((char*)i + 5) = (uint8_t)edx_2;
00403c95                  *(uint32_t*)i_1 = eax_1;
00403c97                  eax = *(uint32_t*)((char*)ebp + 0x30);
00403c97                  
00403c9c                  if (eax)
00403c9c                  {
00403ca4                      *(uint32_t*)i = *(uint32_t*)eax;
00403ca9                      **(uint32_t**)((char*)ebp + 0x30) = i;
00403c9c                  }
00403c9c                  else
00403c9e                      *(uint32_t*)i = i;
00403c9e                  
00403cab                  *(uint32_t*)((char*)ebp + 0x30) = i;
00403c58              }
00403c47          }
00403c34      }
00403c34      
00403cba      return result;
00403c20  }

00403cbb                                                                                   90 90 90 90 90                             .....

00403cc0    void* sub_403cc0(void* arg1)

00403cc0  {
00403cc5      void* i = *(uint32_t*)((char*)arg1 + 0x10);
00403cc5      
00403ccd      if (*(uint32_t*)((char*)i + 0x30))
00403ccd      {
00403ce0          do
00403ce0          {
00403cd0              sub_403cf0(arg1);
00403cdb              i = *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 0x30);
00403ce0          } while (i);
00403ccd      }
00403ccd      
00403ce3      return i;
00403cc0  }

00403ce4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00403cf0    int32_t* sub_403cf0(void* arg1)

00403cf0  {
00403cf7      void* edi = *(uint32_t*)((char*)arg1 + 0x10);
00403cfa      int32_t* eax = *(uint32_t*)((char*)edi + 0x30);
00403cfd      int32_t* ebp = *(uint32_t*)eax;
00403cfd      
00403d01      if (ebp != eax)
00403d0f          *(uint32_t*)eax = *(uint32_t*)ebp;
00403d01      else
00403d03          *(uint32_t*)((char*)edi + 0x30) = 0;
00403d03      
00403d16      *(uint32_t*)ebp = **(uint32_t**)((char*)edi + 0x70);
00403d1c      **(uint32_t**)((char*)edi + 0x70) = ebp;
00403d1e      int32_t* edx;
00403d1e      (uint8_t)edx = *(uint8_t*)((char*)edi + 0x14);
00403d21      int32_t eax_1;
00403d21      (uint8_t)eax_1 = *(uint8_t*)((char*)ebp + 5);
00403d24      (uint8_t)edx &= 3;
00403d27      (uint8_t)eax_1 &= 0xf8;
00403d29      (uint8_t)edx |= (uint8_t)eax_1;
00403d2b      int32_t* result = ebp[2];
00403d30      *(uint8_t*)((char*)ebp + 5) = (uint8_t)edx;
00403d30      
00403d39      if (result && !(*(uint8_t*)((char*)result + 6) & 4))
00403d39      {
00403d48          result =
00403d48              sub_407510(result, 2, *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 0xc4));
00403d48          
00403d52          if (result)
00403d52          {
00403d54              void* ecx_4 = *(uint32_t*)((char*)edi + 0x40);
00403d58              int32_t ebx;
00403d58              (uint8_t)ebx = *(uint8_t*)((char*)arg1 + 0x37);
00403d5b              *(uint8_t*)((char*)arg1 + 0x37) = 0;
00403d68              *(uint32_t*)((char*)edi + 0x40) = *(uint32_t*)((char*)edi + 0x44) << 1;
00403d6b              int32_t* ecx_5 = *(uint32_t*)((char*)arg1 + 8);
00403d72              *(uint32_t*)ecx_5 = *(uint32_t*)result;
00403d77              ecx_5[1] = result[1];
00403d7d              ecx_5[2] = result[2];
00403d83              int32_t** eax_4 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00403d86              *(uint32_t*)eax_4 = ebp;
00403d88              eax_4[2] = 7;
00403d92              void* eax_6 = *(uint32_t*)((char*)arg1 + 8) + 0x20;
00403d95              *(uint32_t*)((char*)arg1 + 8) = eax_6;
00403d9d              result = sub_405a80(arg1, (char*)eax_6 - 0x20, 0);
00403da9              *(uint8_t*)((char*)arg1 + 0x37) = (uint8_t)ebx;
00403dac              *(uint32_t*)((char*)edi + 0x40) = ecx_4;
00403d52          }
00403d39      }
00403d39      
00403db3      return result;
00403cf0  }

00403db4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00403dc0    int32_t sub_403dc0(void* arg1)

00403dc0  {
00403dc7      int32_t* esi = *(uint32_t*)((char*)arg1 + 0x10);
00403dcf      esi[5] = 0x43;
00403dd5      sub_403e10(arg1, &esi[7], 0xfffffffd);
00403dda      int32_t result = esi[2];
00403de0      int32_t edi = 0;
00403de0      
00403de4      if (result > 0)
00403de4      {
00403dfd          do
00403dfd          {
00403def              sub_403e10(arg1, *(uint32_t*)esi + (edi << 2), 0xfffffffd);
00403df4              result = esi[2];
00403dfa              edi += 1;
00403dfd          } while (edi < result);
00403de4      }
00403de4      
00403e02      return result;
00403dc0  }

00403e03           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00403e10    int32_t* sub_403e10(void* arg1, int32_t* arg2, int32_t arg3)

00403e10  {
00403e17      void* ebp = *(uint32_t*)((char*)arg1 + 0x10);
00403e1b      int32_t* result = arg2;
00403e21      int32_t ebx;
00403e21      (uint8_t)ebx = *(uint8_t*)((char*)ebp + 0x14);
00403e21      
00403e2b      for (int32_t* i = *(uint32_t*)result; i; i = *(uint32_t*)result)
00403e2b      {
00403e34          bool cond:0_1 = arg3 <= 0;
00403e36          arg3 -= 1;
00403e36          
00403e3a          if (cond:0_1)
00403e3a              break;
00403e3a          
00403e40          if (i[1] == 8)
00403e4d              sub_403e10(arg1, &i[0x1a], 0xfffffffd);
00403e4d          
00403e55          int32_t eax_1;
00403e55          (uint8_t)eax_1 = *(uint8_t*)((char*)i + 5);
00403e55          
00403e65          if (!((ebx ^ 3) & ((uint32_t)(uint8_t)eax_1 ^ 3)))
00403e65          {
00403e7a              *(uint32_t*)result = *(uint32_t*)i;
00403e7a              
00403e81              if (i == *(uint32_t*)((char*)ebp + 0x1c))
00403e85                  *(uint32_t*)((char*)ebp + 0x1c) = *(uint32_t*)i;
00403e85              
00403e8e              sub_403eb0(arg1, i);
00403e65          }
00403e65          else
00403e65          {
00403e6a              (uint8_t)eax_1 &= 0xf8;
00403e6f              result = i;
00403e73              *(uint8_t*)((char*)i + 5) =
00403e73                  (*(uint8_t*)((char*)ebp + 0x14) & 3) | (uint8_t)eax_1;
00403e65          }
00403e2b      }
00403e2b      
00403ea2      return result;
00403e10  }

00403ea3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00403eb0    void* sub_403eb0(void* arg1, void* arg2)

00403eb0  {
00403eb6      int32_t ecx;
00403eb6      (uint8_t)ecx = *(uint8_t*)((char*)arg2 + 4);
00403eb6      
00403ebf      if (ecx - 4 > 6)
00403f52          return arg2;
00403f52      
00403ebf      switch (ecx)
00403ebf      {
00403f1e          case 4:
00403f1e          {
00403f1e              void* ecx_4 = *(uint32_t*)((char*)arg1 + 0x10);
00403f25              *(uint32_t*)((char*)ecx_4 + 4) -= 1;
00403f3a              return sub_404d00(arg1, arg2, *(uint32_t*)((char*)arg2 + 0xc) + 0x11, 0);
00403f1e              break;
00403f1e          }
00403f07          case 5:
00403f07          {
00403f07              return sub_407b90(arg1, arg2);
00403f07              break;
00403f07          }
00403ee9          case 6:
00403ee9          {
00403ee9              return sub_405080(arg1, arg2);
00403ee9              break;
00403ee9          }
00403f4a          case 7:
00403f4a          {
00403f4a              return sub_404d00(arg1, arg2, *(uint32_t*)((char*)arg2 + 0x10) + 0x18, 0);
00403f4a              break;
00403f4a          }
00403f16          case 8:
00403f16          {
00403f16              return sub_4014b0(arg1, arg2);
00403f16              break;
00403f16          }
00403eda          case 9:
00403eda          {
00403eda              return sub_404fe0(arg1, arg2);
00403eda              break;
00403eda          }
00403ef8          case 0xa:
00403ef8          {
00403ef8              return sub_404ec0(arg1, arg2);
00403ef8              break;
00403ef8          }
00403ebf      }
00403eb0  }

00403f53                                                           90                                                         .
00403f54  uint32_t jump_table_403f54[0x7] = 
00403f54  {
00403f54      [0x0] =  0x00403f17
00403f58      [0x1] =  0x00403ef9
00403f5c      [0x2] =  0x00403edb
00403f60      [0x3] =  0x00403f3b
00403f64      [0x4] =  0x00403f08
00403f68      [0x5] =  0x00403ecc
00403f6c      [0x6] =  0x00403eea
00403f70  }

00403f70    int32_t sub_403f70(void* arg1)

00403f70  {
00403f77      void* esi = *(uint32_t*)((char*)arg1 + 0x10);
00403f80      int32_t edi_1 = *(uint32_t*)((char*)esi + 0x54) * 0xa;
00403f80      
00403f82      if (!edi_1)
00403f84          edi_1 = 0x7ffffffe;
00403f84      
00403f97      *(uint32_t*)((char*)esi + 0x4c) +=
00403f97          *(uint32_t*)((char*)esi + 0x44) - *(uint32_t*)((char*)esi + 0x40);
00403f9f      int32_t i = edi_1 - sub_404010(arg1);
00403fa1      int32_t eax_3;
00403fa1      (uint8_t)eax_3 = *(uint8_t*)((char*)esi + 0x15);
00403fa1      
00403fa9      if ((uint8_t)eax_3)
00403fa9      {
00403fad          while (i > 0)
00403fad          {
00403fb5              i -= sub_404010(arg1);
00403fb7              (uint8_t)eax_3 = *(uint8_t*)((char*)esi + 0x15);
00403fb7              
00403fbf              if (!(uint8_t)eax_3)
00403fbf                  break;
00403fad          }
00403fad          
00403fc1          (uint8_t)eax_3 = *(uint8_t*)((char*)esi + 0x15);
00403fc1          
00403fc6          if ((uint8_t)eax_3)
00403fc6          {
00403fc8              int32_t eax_4 = *(uint32_t*)((char*)esi + 0x4c);
00403fc8              
00403fd0              if (eax_4 < 0x400)
00403fd0              {
00403fdc                  *(uint32_t*)((char*)esi + 0x40) = *(uint32_t*)((char*)esi + 0x44) + 0x400;
00403fe1                  return eax_4;
00403fd0              }
00403fd0              
00403fe2              int32_t edx_1 = *(uint32_t*)((char*)esi + 0x44);
00403fea              *(uint32_t*)((char*)esi + 0x4c) = eax_4 - 0x400;
00403fed              *(uint32_t*)((char*)esi + 0x40) = edx_1;
00403ff3              return eax_4 - 0x400;
00403fc6          }
00403fa9      }
00403fa9      
00403ffa      int32_t eax_6;
00403ffa      int32_t edx_2;
00403ffa      edx_2 = HIGHD(0x51eb851f * *(uint32_t*)((char*)esi + 0x48));
00403ffa      eax_6 = LOWD(0x51eb851f * *(uint32_t*)((char*)esi + 0x48));
00404004      *(uint32_t*)((char*)esi + 0x40) = (edx_2 >> 5) * *(uint32_t*)((char*)esi + 0x50);
00404009      return eax_6;
00403f70  }

0040400a                                90 90 90 90 90 90                                                            ......

00404010    int32_t sub_404010(void* arg1)

00404010  {
00404019      int32_t* esi = *(uint32_t*)((char*)arg1 + 0x10);
0040401c      int32_t eax;
0040401c      (uint8_t)eax = *(uint8_t*)((char*)esi + 0x15);
0040401c      
00404028      switch (eax)
00404028      {
00404030          case 0:
00404030          {
00404030              sub_4047e0(arg1);
00404030              break;
00404030          }
00404043          case 1:
00404043          {
00404043              if (esi[9])
00404051                  return sub_404120(esi);
00404051              
00404053              sub_404890(arg1);
00404043              break;
00404043          }
00404061          case 2:
00404061          {
00404061              int32_t eax_5 = esi[6];
00404066              int32_t ebx = esi[0x11];
0040406b              int32_t* ecx_2 = *(uint32_t*)esi + (eax_5 << 2);
00404071              esi[6] = eax_5 + 1;
00404074              sub_403e10(arg1, ecx_2, 0xfffffffd);
00404074              
00404084              if (esi[6] >= esi[2])
00404086                  *(uint8_t*)((char*)esi + 0x15) = 3;
00404086              
0040409a              esi[0x12] += esi[0x11] - ebx;
0040409f              return 0xa;
00404061              break;
00404061          }
004040a3          case 3:
004040a3          {
004040a3              int32_t ebx_1 = esi[0x11];
004040aa              int32_t* eax_11 = sub_403e10(arg1, esi[8], 0x28);
004040af              esi[8] = eax_11;
004040af              
004040b9              if (!*(uint32_t*)eax_11)
004040b9              {
004040bc                  sub_404760(arg1);
004040c4                  *(uint8_t*)((char*)esi + 0x15) = 4;
004040b9              }
004040b9              
004040d3              esi[0x12] += esi[0x11] - ebx_1;
004040dd              return 0x190;
004040a3              break;
004040a3          }
004040e5          case 4:
004040e5          {
004040e5              if (esi[0xc])
004040e5              {
004040e8                  sub_403cf0(arg1);
004040f8                  return 0x64;
004040e5              }
004040e5              
004040f9              *(uint8_t*)((char*)esi + 0x15) = 0;
004040fc              esi[0x13] = 0;
004040e5              break;
004040e5          }
00404028      }
00404028      
00404104      return 0;
00404010  }

00404105                 8d 49 00                                                                               .I.
00404108  uint32_t jump_table_404108[0x5] = 
00404108  {
00404108      [0x0] =  0x0040402f
0040410c      [0x1] =  0x0040403e
00404110      [0x2] =  0x00404061
00404114      [0x3] =  0x004040a0
00404118      [0x4] =  0x004040de
0040411c  }

0040411c                                                                                      90 90 90 90                              ....

00404120    int32_t sub_404120(void* arg1)

00404120  {
00404125      void* esi = *(uint32_t*)((char*)arg1 + 0x24);
0040412e      *(uint8_t*)((char*)esi + 5) |= 4;
00404133      int32_t ecx_1;
00404133      (uint8_t)ecx_1 = *(uint8_t*)((char*)esi + 4);
00404133      
0040413c      if (ecx_1 - 5 <= 4)
0040413c          switch (ecx_1)
0040413c          {
0040414e              case 5:
0040414e              {
0040414e                  *(uint32_t*)((char*)arg1 + 0x24) = *(uint32_t*)((char*)esi + 0x18);
0040414e                  
0040415b                  if (sub_404230(arg1, esi))
0040415d                      *(uint8_t*)((char*)esi + 5) &= 0xfb;
0040415d                  
00404176                  return (*(uint32_t*)((char*)esi + 0x1c)
00404176                      + (1 << *(uint8_t*)((char*)esi + 7) << 1) + 2) << 4;
0040414e                  break;
0040414e              }
0040417c              case 6:
0040417c              {
0040417c                  *(uint32_t*)((char*)arg1 + 0x24) = *(uint32_t*)((char*)esi + 8);
0040417f                  sub_4045b0(arg1, esi);
0040417f                  
0040418c                  if (!*(uint8_t*)((char*)esi + 6))
0040418c                  {
0040419d                      int32_t edx_1;
0040419d                      (uint8_t)edx_1 = *(uint8_t*)((char*)esi + 7);
004041a8                      return (edx_1 << 2) + 0x14;
0040418c                  }
0040418c                  
00404190                  int32_t eax_5;
00404190                  (uint8_t)eax_5 = *(uint8_t*)((char*)esi + 7);
0040419a                  return (eax_5 << 4) + 0x18;
0040417c                  break;
0040417c              }
004041ac              case 8:
004041ac              {
004041ac                  int32_t edx_2 = *(uint32_t*)((char*)arg1 + 0x28);
004041af                  *(uint32_t*)((char*)arg1 + 0x24) = *(uint32_t*)((char*)esi + 0x6c);
004041b2                  *(uint32_t*)((char*)esi + 0x6c) = edx_2;
004041b5                  *(uint32_t*)((char*)arg1 + 0x28) = esi;
004041b8                  int32_t ecx_6;
004041b8                  (uint8_t)ecx_6 = *(uint8_t*)((char*)esi + 5);
004041bb                  (uint8_t)ecx_6 &= 0xfb;
004041c0                  *(uint8_t*)((char*)esi + 5) = (uint8_t)ecx_6;
004041c3                  sub_404650(arg1, esi);
004041de                  return (*(uint32_t*)((char*)esi + 0x2c) << 4)
004041de                      + (*(uint32_t*)((char*)esi + 0x30) + 5) * 0x18;
004041ac                  break;
004041ac              }
004041e4              case 9:
004041e4              {
004041e4                  *(uint32_t*)((char*)arg1 + 0x24) = *(uint32_t*)((char*)esi + 0x44);
004041e7                  sub_4044f0(arg1, esi);
00404210                  void* result = ((*(uint32_t*)((char*)esi + 0x38) * 3
00404210                      + (*(uint32_t*)((char*)esi + 0x28) << 2)
00404210                      + *(uint32_t*)((char*)esi + 0x34) + *(uint32_t*)((char*)esi + 0x30)
00404210                      + *(uint32_t*)((char*)esi + 0x2c) + *(uint32_t*)((char*)esi + 0x24))
00404210                      << 2) + 0x4c;
00404217                  return result;
004041e4                  break;
004041e4              }
0040413c          }
0040413c      
0040421b      return 0;
00404120  }

0040421c  uint32_t jump_table_40421c[0x5] = 
0040421c  {
0040421c      [0x0] =  0x00404149
00404220      [0x1] =  0x00404177
00404224      [0x2] =  0x00404218
00404228      [0x3] =  0x004041a9
0040422c      [0x4] =  0x004041df
00404230  }

00404230    int32_t sub_404230(void* arg1, void* arg2)

00404230  {
00404230      int32_t ecx;
00404230      int32_t var_4_1 = ecx;
00404233      void* ebp = arg2;
00404237      int32_t ebx = 0;
0040423b      void* eax = *(uint32_t*)((char*)ebp + 8);
0040423e      int32_t var_4 = 0;
0040424a      void* edi;
0040424a      
0040424a      if (!eax || !(*(uint8_t*)((char*)eax + 5) & 3))
0040425c          edi = arg1;
0040424a      else
0040424a      {
0040424c          edi = arg1;
00404252          sub_404400(edi, eax);
0040424a      }
0040424a      
00404260      void* eax_1 = *(uint32_t*)((char*)ebp + 8);
00404260      
0040426f      if (!eax_1 || *(uint8_t*)((char*)eax_1 + 6) & 8)
0040426f      {
004042fe      label_4042fe:
004042fe          int32_t i_1 = *(uint32_t*)((char*)ebp + 0x1c);
004042fe          
00404306          if (i_1)
00404306          {
0040430a              int32_t i = i_1;
0040430d              int32_t esi_3 = (i_1 - 1) << 4;
0040430d              
00404337              do
00404337              {
00404313                  int32_t* eax_13 = *(uint32_t*)((char*)ebp + 0xc) + esi_3;
00404313                  
00404319                  if (eax_13[2] >= 4)
00404319                  {
0040431b                      void* eax_14 = *(uint32_t*)eax_13;
0040431b                      
00404321                      if (*(uint8_t*)((char*)eax_14 + 5) & 3)
00404329                          sub_404400(arg1, eax_14);
00404319                  }
00404319                  
00404331                  i -= 1;
00404332                  esi_3 -= 0x10;
00404337              } while (i > 0);
00404306          }
00404306          
00404306          goto label_404339;
0040426f      }
0040426f      
0040427f      void* eax_2;
0040427f      eax_2 = sub_407510(eax_1, 3, *(uint32_t*)((char*)edi + 0xc8));
0040427f      
00404291      if (!eax_2 || *(uint32_t*)((char*)eax_2 + 8) != 4)
0040428b          goto label_4042fe;
0040428b      
0040429b      void* eax_3 = sub_4172f0(*(uint32_t*)eax_2 + 0x10, 0x6b);
004042a4      int32_t ebx_2 = -(eax_3);
004042ae      ebx = -((ebx_2 - ebx_2));
004042b0      void* eax_6;
004042b0      eax_6 = sub_4172f0(*(uint32_t*)eax_2 + 0x10, 0x76);
004042b8      int32_t eax_7 = -(eax_6);
004042bc      int32_t eax_9 = -((eax_7 - eax_7));
004042c0      var_4 = eax_9;
004042c0      
004042c8      if (ebx || eax_9)
004042c8      {
004042cd          (uint8_t)ecx = (uint8_t)eax_9;
004042cf          (uint8_t)ecx <<= 1;
004042d1          (uint8_t)ecx |= (uint8_t)ebx;
004042d6          (uint8_t)ecx <<= 3;
004042d9          (uint8_t)ecx |= *(uint8_t*)((char*)ebp + 5) & 0xe7;
004042db          *(uint8_t*)((char*)ebp + 5) = (uint8_t)ecx;
004042e1          *(uint32_t*)((char*)ebp + 0x18) = *(uint32_t*)((char*)edi + 0x2c);
004042e4          *(uint32_t*)((char*)edi + 0x2c) = ebp;
004042c8      }
004042c8      
004042e9      if (!ebx)
004042e9      {
004042fc          if (!eax_9)
004042fc              goto label_4042fe;
004042fc          
00404339      label_404339:
00404339          (uint8_t)ecx = *(uint8_t*)((char*)ebp + 7);
00404341          int32_t eax_15 = 1 << (uint8_t)ecx;
00404341          
00404348          if (eax_15)
00404348          {
0040434c              int32_t edi_2 = (eax_15 - 1) << 5;
00404350              arg2 = eax_15;
004043c0              bool cond:1_1;
004043c0              
004043c0              do
004043c0              {
00404359                  int32_t* esi_5 = edi_2 + *(uint32_t*)((char*)ebp + 0x10);
00404359                  
00404360                  if (esi_5[2])
00404360                  {
00404375                      if (!ebx && esi_5[6] >= 4)
00404375                      {
00404377                          void* eax_19 = esi_5[4];
00404377                          
0040437e                          if (*(uint8_t*)((char*)eax_19 + 5) & 3)
00404386                              sub_404400(arg1, eax_19);
00404375                      }
00404375                      
0040439a                      if (!var_4 && esi_5[2] >= 4)
0040439a                      {
0040439c                          void* esi_6 = *(uint32_t*)esi_5;
0040439c                          
004043a2                          if (*(uint8_t*)((char*)esi_6 + 5) & 3)
004043aa                              sub_404400(arg1, esi_6);
0040439a                      }
00404360                  }
00404360                  else
00404363                      sub_4043e0(esi_5);
00404363                  
004043b6                  edi_2 -= 0x20;
004043ba                  cond:1_1 = (char*)arg2 - 1 > 0;
004043bc                  arg2 -= 1;
004043c0              } while (cond:1_1);
00404348          }
00404348          
004043d0          if (!ebx && !var_4)
004043dd              return 0;
004042e9      }
004042e9      else if (!eax_9)
004042ed          goto label_4042fe;
004042ed      
004042f9      return 1;
00404230  }

004043de                                                                                            90 90                                ..

004043e0    void* sub_4043e0(void* arg1)

004043e0  {
004043e8      if (*(uint32_t*)((char*)arg1 + 0x18) >= 4)
004043ea          *(uint32_t*)((char*)arg1 + 0x18) = 0xb;
004043ea      
004043f1      return arg1;
004043e0  }

004043f2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00404400    void* sub_404400(void* arg1, void* arg2)

00404400  {
00404401      void* esi = arg2;
00404408      int32_t ecx;
00404408      (uint8_t)ecx = *(uint8_t*)((char*)esi + 4);
0040440b      void* eax;
0040440b      (uint8_t)eax = *(uint8_t*)((char*)esi + 5);
0040440e      int32_t ecx_1 = ecx - 4;
00404411      (uint8_t)eax &= 0xfc;
00404416      *(uint8_t*)((char*)esi + 5) = (uint8_t)eax;
00404416      
00404419      if (ecx_1 <= 6)
00404419      {
00404423          while (true)
00404423              switch (jump_table_4044c8[ecx_1])
00404423              {
0040442a                  case 0x40442a:
0040442a                  {
0040442a                      void* ecx_2 = *(uint32_t*)((char*)esi + 8);
0040442d                      (uint8_t)eax |= 4;
00404431                      *(uint8_t*)((char*)esi + 5) = (uint8_t)eax;
00404431                      
0040443a                      if (ecx_2 && *(uint8_t*)((char*)ecx_2 + 5) & 3)
0040443e                          eax = sub_404400(arg1, ecx_2);
0040443e                      
00404446                      esi = *(uint32_t*)((char*)esi + 0xc);
00404446                      
0040444d                      if (!(*(uint8_t*)((char*)esi + 5) & 3))
0040444d                          break;
0040444d                      
0040444f                      (uint8_t)eax = *(uint8_t*)((char*)esi + 5);
00404454                      int32_t ecx_3;
00404454                      (uint8_t)ecx_3 = *(uint8_t*)((char*)esi + 4);
00404457                      (uint8_t)eax &= 0xfc;
00404459                      ecx_1 = ecx_3 - 4;
0040445c                      *(uint8_t*)((char*)esi + 5) = (uint8_t)eax;
0040445c                      
00404462                      if (ecx_1 > 6)
00404466                          return eax;
00404466                      
00404462                      continue;
0040442a                  }
00404467                  case 0x404467:
00404467                  {
00404467                      int32_t* eax_1 = *(uint32_t*)((char*)esi + 8);
00404467                      
0040446e                      if (eax_1[2] >= 4)
0040446e                      {
00404470                          void* eax_2 = *(uint32_t*)eax_1;
00404470                          
00404476                          if (*(uint8_t*)((char*)eax_2 + 5) & 3)
0040447a                              sub_404400(arg1, eax_2);
0040446e                      }
0040446e                      
00404485                      eax = (char*)esi + 0x10;
00404485                      
0040448a                      if (*(uint32_t*)((char*)esi + 8) != eax)
0040448a                          break;
0040448a                      
0040448c                      (uint8_t)eax = *(uint8_t*)((char*)esi + 5);
00404490                      (uint8_t)eax |= 4;
00404492                      *(uint8_t*)((char*)esi + 5) = (uint8_t)eax;
00404496                      return eax;
00404467                      break;
00404467                  }
0040449a                  case 0x404497:
0040449a                  {
0040449a                      *(uint32_t*)((char*)esi + 8) = *(uint32_t*)((char*)arg1 + 0x24);
0040449d                      *(uint32_t*)((char*)arg1 + 0x24) = esi;
004044a2                      return eax;
0040449a                      break;
0040449a                  }
004044a6                  case 0x4044a3:
004044a6                  {
004044a6                      *(uint32_t*)((char*)esi + 0x18) = *(uint32_t*)((char*)arg1 + 0x24);
004044a9                      *(uint32_t*)((char*)arg1 + 0x24) = esi;
004044ae                      return eax;
004044a6                      break;
004044a6                  }
004044af                  case 0x4044af:
004044af                  {
004044af                      int32_t eax_3 = *(uint32_t*)((char*)arg1 + 0x24);
004044b2                      *(uint32_t*)((char*)esi + 0x6c) = eax_3;
004044b5                      *(uint32_t*)((char*)arg1 + 0x24) = esi;
004044ba                      return eax_3;
004044af                      break;
004044af                  }
004044be                  case 0x4044bb:
004044be                  {
004044be                      *(uint32_t*)((char*)esi + 0x44) = *(uint32_t*)((char*)arg1 + 0x24);
004044c1                      *(uint32_t*)((char*)arg1 + 0x24) = esi;
004044c1                      break;
004044be                      break;
004044be                  }
00404423                  case 0x4044c4:
00404423                  {
00404423                      break;
00404423                      break;
00404423                  }
00404423              }
00404419      }
00404419      
004044c6      return eax;
00404400  }

004044c7                       90                                                                                 .
004044c8  uint32_t jump_table_4044c8[0x7] = 
004044c8  {
004044c8      [0x0] =  0x004044c4
004044cc      [0x1] =  0x004044a3
004044d0      [0x2] =  0x00404497
004044d4      [0x3] =  0x0040442a
004044d8      [0x4] =  0x004044af
004044dc      [0x5] =  0x004044bb
004044e0      [0x6] =  0x00404467
004044e4  }

004044e4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

004044f0    int32_t sub_4044f0(void* arg1, void* arg2)

004044f0  {
004044f5      void* eax = *(uint32_t*)((char*)arg2 + 0x20);
004044f5      
004044fa      if (eax)
004044fc          *(uint8_t*)((char*)eax + 5) &= 0xfc;
004044fc      
00404504      int32_t i = 0;
00404504      
00404509      if (*(uint32_t*)((char*)arg2 + 0x28) > 0)
00404509      {
0040450b          int32_t edi_1 = 0;
0040450b          
00404537          do
00404537          {
00404510              int32_t* eax_3 = *(uint32_t*)((char*)arg2 + 8) + edi_1;
00404510              
00404516              if (eax_3[2] >= 4)
00404516              {
00404518                  void* eax_4 = *(uint32_t*)eax_3;
00404518                  
0040451e                  if (*(uint8_t*)((char*)eax_4 + 5) & 3)
00404526                      sub_404400(arg1, eax_4);
00404516              }
00404516              
00404531              i += 1;
00404532              edi_1 += 0x10;
00404537          } while (i < *(uint32_t*)((char*)arg2 + 0x28));
00404509      }
00404509      
0040453c      int32_t i_1 = 0;
0040453c      
00404540      if (*(uint32_t*)((char*)arg2 + 0x24) > 0)
00404540      {
00404556          do
00404556          {
00404545              void* eax_7 = *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x1c) + (i_1 << 2));
00404545              
0040454a              if (eax_7)
0040454c                  *(uint8_t*)((char*)eax_7 + 5) &= 0xfc;
0040454c              
00404553              i_1 += 1;
00404556          } while (i_1 < *(uint32_t*)((char*)arg2 + 0x24));
00404540      }
00404540      
0040455b      int32_t i_2 = 0;
0040455b      
0040455f      if (*(uint32_t*)((char*)arg2 + 0x34) > 0)
0040455f      {
00404585          do
00404585          {
00404564              void* eax_11 = *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x10) + (i_2 << 2));
00404564              
0040456f              if (eax_11 && *(uint8_t*)((char*)eax_11 + 5) & 3)
00404577                  sub_404400(arg1, eax_11);
00404577              
00404582              i_2 += 1;
00404585          } while (i_2 < *(uint32_t*)((char*)arg2 + 0x34));
0040455f      }
0040455f      
00404587      int32_t result = *(uint32_t*)((char*)arg2 + 0x38);
0040458a      int32_t edx_2 = 0;
0040458a      
00404590      if (result > 0)
00404590      {
00404592          int32_t* ecx_3 = nullptr;
00404592          
004045ab          do
004045ab          {
00404597              void* eax_14 = *(uint32_t*)((char*)ecx_3 + *(uint32_t*)((char*)arg2 + 0x18));
00404597              
0040459c              if (eax_14)
0040459e                  *(uint8_t*)((char*)eax_14 + 5) &= 0xfc;
0040459e              
004045a2              result = *(uint32_t*)((char*)arg2 + 0x38);
004045a5              edx_2 += 1;
004045a6              ecx_3 = &ecx_3[3];
004045ab          } while (edx_2 < result);
00404590      }
00404590      
004045ae      return result;
004044f0  }

004045af                                               90                                                                 .

004045b0    void* sub_4045b0(void* arg1, void* arg2)

004045b0  {
004045bc      void* eax = *(uint32_t*)((char*)arg2 + 0xc);
004045bc      
004045c3      if (*(uint8_t*)((char*)eax + 5) & 3)
004045c7          sub_404400(arg1, eax);
004045c7      
004045cf      (uint8_t)eax = *(uint8_t*)((char*)arg2 + 6);
004045cf      
004045d4      if (!(uint8_t)eax)
004045d4      {
0040460c          eax = *(uint32_t*)((char*)arg2 + 0x10);
0040460c          
00404613          if (*(uint8_t*)((char*)eax + 5) & 3)
00404617              sub_404400(arg1, eax);
00404617          
0040461f          (uint8_t)eax = *(uint8_t*)((char*)arg2 + 7);
00404622          int32_t ebp_1 = 0;
00404622          
00404626          if ((uint8_t)eax > 0)
00404626          {
00404628              void* edi_2 = (char*)arg2 + 0x14;
00404648              int32_t ecx_1;
00404648              
00404648              do
00404648              {
0040462b                  eax = *(uint32_t*)edi_2;
0040462b                  
00404631                  if (*(uint8_t*)((char*)eax + 5) & 3)
00404635                      eax = sub_404400(arg1, eax);
00404635                  
0040463f                  ebp_1 += 1;
00404640                  (uint8_t)ecx_1 = *(uint8_t*)((char*)arg2 + 7);
00404643                  edi_2 += 4;
00404648              } while (ebp_1 < ecx_1);
00404626          }
004045d4      }
004045d4      else
004045d4      {
004045d6          (uint8_t)eax = *(uint8_t*)((char*)arg2 + 7);
004045d9          int32_t ebp = 0;
004045d9          
004045dd          if ((uint8_t)eax > 0)
004045dd          {
004045df              void* edi_1 = (char*)arg2 + 0x18;
00404605              int32_t eax_2;
00404605              
00404605              do
00404605              {
004045e6                  if (*(uint32_t*)((char*)edi_1 + 8) >= 4)
004045e6                  {
004045e8                      void* eax_1 = *(uint32_t*)edi_1;
004045e8                      
004045ee                      if (*(uint8_t*)((char*)eax_1 + 5) & 3)
004045f2                          sub_404400(arg1, eax_1);
004045e6                  }
004045e6                  
004045fc                  ebp += 1;
004045fd                  (uint8_t)eax_2 = *(uint8_t*)((char*)arg2 + 7);
00404600                  edi_1 += 0x10;
00404605              } while (ebp < eax_2);
00404605              
0040460b              return eax_2;
004045dd          }
004045d4      }
004045d4      
0040464e      return eax;
004045b0  }

0040464f                                               90                                                                 .

00404650    int32_t sub_404650(void* arg1, void* arg2)

00404650  {
0040465c      if (*(uint32_t*)((char*)arg2 + 0x50) >= 4)
0040465c      {
0040465e          void* eax_1 = *(uint32_t*)((char*)arg2 + 0x48);
0040465e          
00404665          if (*(uint8_t*)((char*)eax_1 + 5) & 3)
0040466d              sub_404400(arg1, eax_1);
0040465c      }
0040465c      
00404675      void* i = *(uint32_t*)((char*)arg2 + 0x28);
0040467b      int32_t ebx = *(uint32_t*)((char*)arg2 + 8);
00404680      int32_t ebp = ebx;
00404680      
00404682      for (; i <= *(uint32_t*)((char*)arg2 + 0x14); i += 0x18)
00404682      {
00404684          int32_t ecx_1 = *(uint32_t*)((char*)i + 8);
00404684          
00404689          if (ebp < ecx_1)
0040468b              ebp = ecx_1;
00404682      }
00404682      
00404694      int32_t* i_1 = *(uint32_t*)((char*)arg2 + 0x20);
00404694      
00404699      if (i_1 < ebx)
00404699      {
004046bf          do
004046bf          {
0040469f              if (i_1[2] >= 4)
0040469f              {
004046a1                  void* eax_3 = *(uint32_t*)i_1;
004046a1                  
004046a7                  if (*(uint8_t*)((char*)eax_3 + 5) & 3)
004046af                      sub_404400(arg1, eax_3);
0040469f              }
0040469f              
004046ba              i_1 = &i_1[4];
004046bf          } while (i_1 < *(uint32_t*)((char*)arg2 + 8));
00404699      }
00404699      
004046c3      for (; i_1 <= ebp; i_1 = &i_1[4])
004046c7          i_1[2] = 0;
004046c7      
004046df      return sub_4046e0(arg2, ebp);
00404650  }


004046e0    void sub_4046e0(void* arg1, int32_t arg2)

004046e0  {
004046ee      int32_t ebx = *(uint32_t*)((char*)arg1 + 0x30);
004046f3      int32_t edi_2 = (arg2 - *(uint32_t*)((char*)arg1 + 0x20)) >> 4;
004046f3      
004046fc      if (ebx > 0x4e20)
004046fc          return;
004046fc      
0040470b      int32_t eax_1;
0040470b      int32_t edx_2;
0040470b      edx_2 = HIGHD(0x2aaaaaab
0040470b          * (*(uint32_t*)((char*)arg1 + 0x14) - *(uint32_t*)((char*)arg1 + 0x28)));
0040470b      eax_1 = LOWD(0x2aaaaaab
0040470b          * (*(uint32_t*)((char*)arg1 + 0x14) - *(uint32_t*)((char*)arg1 + 0x28)));
0040470d      int32_t edx_3 = edx_2 >> 2;
0040470d      
00404721      if ((edx_3 + (edx_3 >> 0x1f)) << 2 < ebx && ebx > 0x10)
00404721      {
00404725          int32_t eax_5;
00404725          int32_t edx_6;
00404725          edx_6 = HIGHD((int64_t)ebx);
00404725          eax_5 = LOWD((int64_t)ebx);
0040472c          sub_4053e0(arg1, (eax_5 - edx_6) >> 1);
00404721      }
00404721      
00404734      int32_t eax = *(uint32_t*)((char*)arg1 + 0x2c);
00404734      
00404745      if (edi_2 << 2 < eax && eax > 0x5a)
00404745      {
00404747          int32_t eax_8;
00404747          int32_t edx_7;
00404747          edx_7 = HIGHD((int64_t)eax);
00404747          eax_8 = LOWD((int64_t)eax);
0040474e          sub_4052e0(arg1, (eax_8 - edx_7) >> 1);
00404745      }
004046e0  }

0040475a                                                                                90 90 90 90 90 90                            ......

00404760    int32_t sub_404760(void* arg1)

00404760  {
00404766      void* esi = *(uint32_t*)((char*)arg1 + 0x10);
00404769      int32_t ecx = *(uint32_t*)((char*)esi + 8);
0040476e      int32_t eax_1;
0040476e      int32_t edx;
0040476e      edx = HIGHD((int64_t)ecx);
0040476e      eax_1 = LOWD((int64_t)ecx);
0040476e      
00404781      if (*(uint32_t*)((char*)esi + 4) < (eax_1 + (edx & 3)) >> 2 && ecx > 0x40)
00404781      {
00404785          int32_t eax_5;
00404785          int32_t edx_3;
00404785          edx_3 = HIGHD((int64_t)ecx);
00404785          eax_5 = LOWD((int64_t)ecx);
0040478c          sub_405ea0(arg1, (eax_5 - edx_3) >> 1);
00404781      }
00404781      
00404794      int32_t eax_9 = *(uint32_t*)((char*)esi + 0x3c);
00404794      
0040479a      if (eax_9 > 0x40)
0040479a      {
0040479f          uint32_t edi_2 = eax_9 >> 1;
0040479f          
004047a7          if (edi_2 + 1 <= 0xfffffffd)
004047a7          {
004047b0              int32_t eax_8 =
004047b0                  sub_404d00(arg1, *(uint32_t*)((char*)esi + 0x34), eax_9, edi_2);
004047b8              *(uint32_t*)((char*)esi + 0x3c) = edi_2;
004047bb              *(uint32_t*)((char*)esi + 0x34) = eax_8;
004047c1              return eax_8;
004047a7          }
004047a7          
004047c3          eax_9 = sub_404ce0(arg1);
004047cb          *(uint32_t*)((char*)esi + 0x3c) = edi_2;
004047ce          *(uint32_t*)((char*)esi + 0x34) = 0;
0040479a      }
0040479a      
004047d4      return eax_9;
00404760  }

004047d5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

004047e0    void* sub_4047e0(void* arg1)

004047e0  {
004047e8      void* esi = *(uint32_t*)((char*)arg1 + 0x10);
004047eb      *(uint32_t*)((char*)esi + 0x24) = 0;
004047ee      *(uint32_t*)((char*)esi + 0x28) = 0;
004047f1      *(uint32_t*)((char*)esi + 0x2c) = 0;
004047f4      void* eax = *(uint32_t*)((char*)esi + 0x70);
004047f4      
004047fb      if (*(uint8_t*)((char*)eax + 5) & 3)
004047ff          sub_404400(esi, eax);
004047ff      
00404807      void* eax_1 = *(uint32_t*)((char*)esi + 0x70);
00404807      
0040480e      if (*(uint32_t*)((char*)eax_1 + 0x50) >= 4)
0040480e      {
00404810          void* eax_2 = *(uint32_t*)((char*)eax_1 + 0x48);
00404810          
00404817          if (*(uint8_t*)((char*)eax_2 + 5) & 3)
0040481b              sub_404400(esi, eax_2);
0040480e      }
0040480e      
00404823      void* eax_3 = *(uint32_t*)((char*)arg1 + 0x10);
00404823      
0040482a      if (*(uint32_t*)((char*)eax_3 + 0x68) >= 4)
0040482a      {
0040482c          void* eax_4 = *(uint32_t*)((char*)eax_3 + 0x60);
0040482c          
00404833          if (*(uint8_t*)((char*)eax_4 + 5) & 3)
00404837              sub_404400(esi, eax_4);
0040482a      }
0040482a      
00404840      void* result = sub_404850(esi);
00404848      *(uint8_t*)((char*)esi + 0x15) = 1;
0040484e      return result;
004047e0  }

0040484f                                               90                                                                 .

00404850    void* sub_404850(void* arg1)

00404850  {
00404857      int32_t* esi = (char*)arg1 + 0x98;
0040485d      int32_t i_1 = 9;
0040487c      void* result;
0040487c      int32_t i;
0040487c      
0040487c      do
0040487c      {
00404862          result = *(uint32_t*)esi;
00404862          
0040486c          if (result && *(uint8_t*)((char*)result + 5) & 3)
00404870              result = sub_404400(arg1, result);
00404870          
00404878          esi = &esi[1];
0040487b          i = i_1;
0040487b          i_1 -= 1;
0040487c      } while (i != 1);
00404881      return result;
00404850  }

00404882        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00404890    void* sub_404890(int32_t* arg1)

00404890  {
00404896      void* esi = arg1[4];
0040489a      sub_404aa0(esi);
004048a0      sub_404970(esi);
004048a5      int32_t eax = *(uint32_t*)((char*)esi + 0x2c);
004048a8      *(uint32_t*)((char*)esi + 0x2c) = 0;
004048af      *(uint32_t*)((char*)esi + 0x24) = eax;
004048b2      (uint8_t)eax = *(uint8_t*)((char*)arg1 + 5);
004048b2      
004048ba      if ((uint8_t)eax & 3)
004048be          sub_404400(esi, arg1);
004048be      
004048c7      sub_404850(esi);
004048cd      sub_404970(esi);
004048d6      *(uint32_t*)((char*)esi + 0x24) = *(uint32_t*)((char*)esi + 0x28);
004048d9      *(uint32_t*)((char*)esi + 0x28) = 0;
004048e0      sub_404970(esi);
004048e8      int32_t eax_1 = sub_403c20(arg1, 0);
004048f0      sub_404930(esi);
004048f6      sub_404970(esi);
004048ff      sub_404990(*(uint32_t*)((char*)esi + 0x2c));
00404910      *(uint8_t*)((char*)esi + 0x14) ^= 3;
00404916      int32_t ecx_3 = *(uint32_t*)((char*)esi + 0x44) - eax_1;
00404918      *(uint32_t*)((char*)esi + 0x18) = 0;
0040491f      *(uint32_t*)((char*)esi + 0x20) = (char*)esi + 0x1c;
00404922      *(uint8_t*)((char*)esi + 0x15) = 2;
00404926      *(uint32_t*)((char*)esi + 0x48) = ecx_3;
0040492b      return (char*)esi + 0x1c;
00404890  }

0040492c                                      90 90 90 90                                                              ....

00404930    void sub_404930(void* arg1)

00404930  {
00404936      void** i = *(uint32_t*)((char*)arg1 + 0x30);
00404936      
0040493b      if (!i)
0040493b          return;
0040493b      
0040495e      do
0040495e      {
0040493d          i = *(uint32_t*)i;
00404946          int32_t eax;
00404946          (uint8_t)eax = *(uint8_t*)((char*)i + 5);
0040494a          (uint8_t)eax &= 0xf8;
0040494c          (uint8_t)eax |= *(uint8_t*)((char*)arg1 + 0x14) & 3;
0040494e          *(uint8_t*)((char*)i + 5) = (uint8_t)eax;
00404951          sub_404400(arg1, i);
0040495e      } while (i != *(uint32_t*)((char*)arg1 + 0x30));
00404930  }

00404963           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00404970    int32_t sub_404970(void* arg1)

00404970  {
0040497a      int32_t i;
0040497a      
0040497a      for (i = *(uint32_t*)((char*)arg1 + 0x24); i; i = *(uint32_t*)((char*)arg1 + 0x24))
0040497d          sub_404120(arg1);
0040497d      
0040498d      return i;
00404970  }

0040498e                                            90 90                                                                ..

00404990    void sub_404990(void* arg1)

00404990  {
00404997      for (void* i = arg1; i; i = *(uint32_t*)((char*)i + 0x18))
00404997      {
004049a0          void* eax;
004049a0          (uint8_t)eax = *(uint8_t*)((char*)i + 5);
004049a3          int32_t j_3 = *(uint32_t*)((char*)i + 0x1c);
004049af          int32_t ecx;
004049af          
004049af          if ((uint8_t)eax & 0x10 && j_3)
004049af          {
004049b3              int32_t edi_2 = (j_3 - 1) << 4;
004049b6              int32_t j = j_3;
004049b6              
004049da              do
004049da              {
004049bc                  void** esi_2 = edi_2 + *(uint32_t*)((char*)i + 0xc);
004049c1                  int32_t eax_2;
004049c1                  eax_2 = sub_404a50(esi_2, 0);
004049c1                  
004049cb                  if (eax_2)
004049cd                      esi_2[2] = 0;
004049cd                  
004049d4                  j -= 1;
004049d5                  edi_2 -= 0x10;
004049da              } while (j > 0);
004049af          }
004049af          
004049dc          (uint8_t)ecx = *(uint8_t*)((char*)i + 7);
004049e4          int32_t j_2 = 1 << (uint8_t)ecx;
004049e4          
004049eb          if (j_2)
004049eb          {
004049ef              void* j_1 = j_2;
004049f2              int32_t edi_4 = (j_2 - 1) << 5;
004049f2              
00404a37              do
00404a37              {
004049f8                  void** esi_4 = *(uint32_t*)((char*)i + 0x10) + edi_4;
004049f8                  
004049ff                  if (esi_4[2])
004049ff                  {
00404a07                      int32_t eax_3;
00404a07                      eax_3 = sub_404a50(&esi_4[4], 1);
00404a07                      
00404a11                      if (!eax_3)
00404a15                          eax = sub_404a50(esi_4, eax_3);
00404a15                      
00404a1f                      if (eax_3 || eax)
00404a1f                      {
00404a22                          esi_4[2] = 0;
00404a29                          sub_4043e0(esi_4);
00404a1f                      }
004049ff                  }
004049ff                  
00404a31                  j_1 -= 1;
00404a32                  edi_4 -= 0x20;
00404a37              } while (j_1 > 0);
004049eb          }
00404997      }
00404990  }

00404a49                             90 90 90 90 90 90 90                                                           .......

00404a50    int32_t sub_404a50(void** arg1, int32_t arg2)

00404a50  {
00404a54      int32_t eax = arg1[2];
00404a54      
00404a5a      if (eax < 4)
00404a5e          return 0;
00404a5e      
00404a5f      if (eax == 4)
00404a5f      {
00404a61          void* eax_2 = *(uint32_t*)arg1;
00404a63          void** ecx;
00404a63          (uint8_t)ecx = *(uint8_t*)((char*)eax_2 + 5);
00404a66          (uint8_t)ecx &= 0xfc;
00404a69          *(uint8_t*)((char*)eax_2 + 5) = (uint8_t)ecx;
00404a6e          return 0;
00404a5f      }
00404a5f      
00404a71      void* ecx_1;
00404a71      (uint8_t)ecx_1 = *(uint8_t*)(*(uint32_t*)arg1 + 5);
00404a71      
00404a89      if (!((uint8_t)ecx_1 & 3) && (eax != 7 || arg2 || !((uint8_t)ecx_1 & 8)))
00404a8d          return 0;
00404a8d      
00404a93      return 1;
00404a50  }

00404a94                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00404aa0    void sub_404aa0(void* arg1)

00404aa0  {
00404ab2      for (void* i = *(uint32_t*)((char*)arg1 + 0x8c); i != (char*)arg1 + 0x78; 
00404ab2          i = *(uint32_t*)((char*)i + 0x14))
00404ab2      {
00404ab8          if (!(*(uint8_t*)((char*)i + 5) & 7))
00404ab8          {
00404aba              void* eax = *(uint32_t*)((char*)i + 8);
00404aba              
00404ac1              if (*(uint32_t*)((char*)eax + 8) >= 4)
00404ac1              {
00404ac3                  eax = *(uint32_t*)eax;
00404ac3                  
00404ac9                  if (*(uint8_t*)((char*)eax + 5) & 3)
00404acd                      sub_404400(arg1, eax);
00404ac1              }
00404ab8          }
00404ab2      }
00404aa0  }


00404ae0    int32_t sub_404ae0(void* arg1)

00404ae0  {
00404ae6      void* esi = *(uint32_t*)((char*)arg1 + 0x10);
00404ae6      
00404aed      if (*(uint8_t*)((char*)esi + 0x15) <= 1)
00404aed      {
00404af4          *(uint32_t*)((char*)esi + 0x18) = 0;
00404af7          *(uint32_t*)((char*)esi + 0x20) = (char*)esi + 0x1c;
00404afa          *(uint32_t*)((char*)esi + 0x24) = 0;
00404afd          *(uint32_t*)((char*)esi + 0x28) = 0;
00404b00          *(uint32_t*)((char*)esi + 0x2c) = 0;
00404b03          *(uint8_t*)((char*)esi + 0x15) = 2;
00404aed      }
00404aed      
00404b0b      while (*(uint8_t*)((char*)esi + 0x15) != 4)
00404b0e          sub_404010(arg1);
00404b0e      
00404b1e      sub_4047e0(arg1);
00404b1e      
00404b2b      while (*(uint8_t*)((char*)esi + 0x15))
00404b2e          sub_404010(arg1);
00404b2e      
00404b43      int32_t result;
00404b43      int32_t edx;
00404b43      edx = HIGHD(0x51eb851f * *(uint32_t*)((char*)esi + 0x48));
00404b43      result = LOWD(0x51eb851f * *(uint32_t*)((char*)esi + 0x48));
00404b4d      *(uint32_t*)((char*)esi + 0x40) = (edx >> 5) * *(uint32_t*)((char*)esi + 0x50);
00404b51      return result;
00404ae0  }

00404b52                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00404b60    void* sub_404b60(void* arg1, void* arg2, void* arg3)

00404b60  {
00404b64      void* result = *(uint32_t*)((char*)arg1 + 0x10);
00404b64      
00404b6b      if (*(uint8_t*)((char*)result + 0x15) == 1)
00404b7b          return sub_404400(result, arg3);
00404b7b      
00404b83      char edx = *(uint8_t*)((char*)result + 0x14) & 3;
00404b86      (uint8_t)result = *(uint8_t*)((char*)arg2 + 5);
00404b89      (uint8_t)result &= 0xf8;
00404b8d      *(uint8_t*)((char*)arg2 + 5) = edx | (uint8_t)result;
00404b90      return result;
00404b60  }

00404b91                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00404ba0    void* sub_404ba0(void* arg1, void* arg2)

00404ba0  {
00404ba4      void* ecx = *(uint32_t*)((char*)arg1 + 0x10);
00404bb1      *(uint8_t*)((char*)arg2 + 5) &= 0xfb;
00404bb7      *(uint32_t*)((char*)arg2 + 0x18) = *(uint32_t*)((char*)ecx + 0x28);
00404bba      *(uint32_t*)((char*)ecx + 0x28) = arg2;
00404bbd      return arg2;
00404ba0  }

00404bbe                                                                                            90 90                                ..

00404bc0    void* sub_404bc0(void* arg1, int32_t* arg2, char arg3)

00404bc0  {
00404bc8      void* result = *(uint32_t*)((char*)arg1 + 0x10);
00404bce      *(uint32_t*)arg2 = *(uint32_t*)((char*)result + 0x1c);
00404bd0      int32_t edx;
00404bd0      (uint8_t)edx = arg3;
00404bd4      *(uint32_t*)((char*)result + 0x1c) = arg2;
00404bd7      (uint8_t)result = *(uint8_t*)((char*)result + 0x14);
00404bda      (uint8_t)result &= 3;
00404bdc      arg2[1] = (uint8_t)edx;
00404bdf      *(uint8_t*)((char*)arg2 + 5) = (uint8_t)result;
00404be2      return result;
00404bc0  }

00404be3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00404bf0    int32_t* sub_404bf0(void* arg1, int32_t* arg2)

00404bf0  {
00404bfa      void* esi = *(uint32_t*)((char*)arg1 + 0x10);
00404c00      *(uint32_t*)arg2 = *(uint32_t*)((char*)esi + 0x1c);
00404c02      *(uint32_t*)((char*)esi + 0x1c) = arg2;
00404c05      int32_t ecx;
00404c05      (uint8_t)ecx = *(uint8_t*)((char*)arg2 + 5);
00404c05      
00404c0b      if (!((uint8_t)ecx & 7))
00404c0b      {
00404c11          if (*(uint8_t*)((char*)esi + 0x15) != 1)
00404c11          {
00404c40              (uint8_t)ecx &= 0xf8;
00404c48              *(uint8_t*)((char*)arg2 + 5) =
00404c48                  (*(uint8_t*)((char*)esi + 0x14) & 3) | (uint8_t)ecx;
00404c11          }
00404c11          else
00404c11          {
00404c13              void** edx_1 = arg2[2];
00404c16              (uint8_t)ecx |= 4;
00404c19              *(uint8_t*)((char*)arg2 + 5) = (uint8_t)ecx;
00404c19              
00404c20              if (edx_1[2] >= 4)
00404c20              {
00404c22                  void* edx_2 = *(uint32_t*)edx_1;
00404c22                  
00404c2d                  if (*(uint8_t*)((char*)edx_2 + 5) & 3 && (uint8_t)ecx & 4)
00404c3c                      return sub_404b60(arg1, arg2, edx_2);
00404c20              }
00404c11          }
00404c0b      }
00404c0b      
00404c4d      return arg2;
00404bf0  }

00404c4e                                            90 90                                                                ..

00404c50    int32_t sub_404c50(void* arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t arg5, double* arg6)

00404c50  {
00404c52      int32_t esi = arg5;
00404c61      int32_t eax_1;
00404c61      int32_t edx;
00404c61      edx = HIGHD((int64_t)esi);
00404c61      eax_1 = LOWD((int64_t)esi);
00404c62      int32_t ecx = *(uint32_t*)arg3;
00404c62      
00404c6a      if (ecx < (eax_1 - edx) >> 1)
00404c6a      {
00404c80          esi = ecx * 2;
00404c80          
00404c86          if (esi < 4)
00404c88              esi = 4;
00404c6a      }
00404c6a      else if (ecx >= esi)
00404c76          sub_40bb80(arg1, arg6);
00404c76      
00404ca1      if (esi + 1 > COMBINE(0, 0xfffffffd) / arg4)
00404ca1      {
00404cc4          sub_404ce0(arg1);
00404ccc          *(uint32_t*)arg3 = esi;
00404cd1          return 0;
00404ca1      }
00404ca1      
00404cb5      int32_t result = sub_404d00(arg1, arg2, *(uint32_t*)arg3 * arg4, esi * arg4);
00404cbd      *(uint32_t*)arg3 = esi;
00404cc2      return result;
00404c50  }

00404cd2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00404ce0    int32_t sub_404ce0(void* arg1)

00404ce0  {
00404cea      sub_40bb80(arg1, "memory allocation error: block too big");
00404cf4      return 0;
00404ce0  }

00404cf5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00404d00    int32_t sub_404d00(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00404d00  {
00404d0f      void* esi = *(uint32_t*)((char*)arg1 + 0x10);
00404d1e      int32_t result = (*(uint32_t*)((char*)esi + 0xc))(*(uint32_t*)((char*)esi + 0x10), 
00404d1e          arg2, arg3, arg4);
00404d1e      
00404d2c      if (!result && arg4 > 0)
00404d35          sub_4051a0(arg1, 4);
00404d35      
00404d45      *(uint32_t*)((char*)esi + 0x44) += arg4 - arg3;
00404d4d      return result;
00404d00  }

00404d4e                                            90 90                                                                ..

00404d50    int32_t* sub_404d50(void* arg1, int32_t arg2, int32_t arg3)

00404d50  {
00404d69      int32_t* result = sub_404d00(arg1, 0, 0, (arg2 << 4) + 0x18);
00404d74      sub_404bc0(arg1, result, 6);
00404d80      *(uint8_t*)((char*)result + 6) = 1;
00404d84      result[3] = arg3;
00404d87      *(uint8_t*)((char*)result + 7) = (uint8_t)arg2;
00404d8f      return result;
00404d50  }


00404d90    int32_t* sub_404d90(void* arg1, int32_t arg2, int32_t arg3)

00404d90  {
00404da8      int32_t* result = sub_404d00(arg1, 0, 0, (arg2 << 2) + 0x14);
00404db3      sub_404bc0(arg1, result, 6);
00404dbf      *(uint8_t*)((char*)result + 7) = (uint8_t)arg2;
00404dc5      *(uint8_t*)((char*)result + 6) = 0;
00404dcb      result[3] = arg3;
00404dcb      
00404dce      if (arg2)
00404dce      {
00404dd0          void* eax_1 = &result[arg2 + 4];
00404dd4          int32_t i = arg2;
00404dd4          
00404de1          do
00404de1          {
00404dd5              *(uint32_t*)eax_1 = 0;
00404ddb              i -= 1;
00404ddc              eax_1 -= 4;
00404de1          } while (i > 0);
00404dce      }
00404dce      
00404de8      return result;
00404d90  }

00404de9                             90 90 90 90 90 90 90                                                           .......

00404df0    int32_t* sub_404df0(void* arg1)

00404df0  {
00404dfd      int32_t* result = sub_404d00(arg1, 0, 0, 0x20);
00404e08      sub_404bc0(arg1, result, 0xa);
00404e13      result[2] = &result[4];
00404e16      result[6] = 0;
00404e21      return result;
00404df0  }

00404e22        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00404e30    void* sub_404e30(void* arg1, int32_t arg2)

00404e30  {
00404e3a      void* result = *(uint32_t*)((char*)arg1 + 0x68);
00404e3d      void* esi = *(uint32_t*)((char*)arg1 + 0x10);
00404e41      void* result_1 = (char*)arg1 + 0x68;
00404e41      
00404e46      if (!result)
00404e46      {
00404e60      label_404e60:
00404e60          result = sub_404d00(arg1, 0, 0, 0x20);
00404e65          *(uint8_t*)((char*)result + 4) = 0xa;
00404e72          *(uint8_t*)((char*)result + 5) = *(uint8_t*)((char*)esi + 0x14) & 3;
00404e75          *(uint32_t*)((char*)result + 8) = arg2;
00404e7d          *(uint32_t*)result = *(uint32_t*)result_1;
00404e7f          *(uint32_t*)result_1 = result;
00404e81          *(uint32_t*)((char*)result + 0x10) = (char*)esi + 0x78;
00404e84          void* ecx_3 = *(uint32_t*)((char*)esi + 0x8c);
00404e8a          *(uint32_t*)((char*)result + 0x14) = ecx_3;
00404e8d          *(uint32_t*)((char*)ecx_3 + 0x10) = result;
00404e90          *(uint32_t*)((char*)esi + 0x8c) = result;
00404e46      }
00404e46      else
00404e46      {
00404e48          while (true)
00404e48          {
00404e48              int32_t ecx_4 = *(uint32_t*)((char*)result + 8);
00404e48              
00404e4d              if (ecx_4 < arg2)
00404e4d                  goto label_404e60;
00404e4d              
00404e4f              if (ecx_4 == arg2)
00404e4f              {
00404e9a                  (uint8_t)ecx_4 = *(uint8_t*)((char*)result + 5);
00404e9d                  int32_t ebx;
00404e9d                  (uint8_t)ebx = *(uint8_t*)((char*)esi + 0x14);
00404ea0                  void* edx_1;
00404ea0                  (uint8_t)edx_1 = (uint8_t)ecx_4;
00404ea0                  
00404ea9                  if (!((char)~ebx & (uint8_t)edx_1 & 3))
00404ea9                      break;
00404ea9                  
00404eab                  (uint8_t)ecx_4 ^= 3;
00404eb0                  *(uint8_t*)((char*)result + 5) = (uint8_t)ecx_4;
00404eb4                  return result;
00404e4f              }
00404e4f              
00404e51              result_1 = result;
00404e53              result = *(uint32_t*)result;
00404e53              
00404e57              if (!result)
00404e57                  goto label_404e60;
00404e48          }
00404e46      }
00404e46      
00404e99      return result;
00404e30  }

00404eb5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00404ec0    int32_t sub_404ec0(void* arg1, void* arg2)

00404ec0  {
00404ecd      if (*(uint32_t*)((char*)arg2 + 8) != (char*)arg2 + 0x10)
00404ed0          sub_404ef0(arg2);
00404ed0      
00404eeb      return sub_404d00(arg1, arg2, 0x20, 0);
00404ec0  }

00404eec                                      90 90 90 90                                                              ....

00404ef0    void* sub_404ef0(void* arg1)

00404ef0  {
00404efa      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x14) + 0x10) =
00404efa          *(uint32_t*)((char*)arg1 + 0x10);
00404f03      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 0x14) =
00404f03          *(uint32_t*)((char*)arg1 + 0x14);
00404f06      return arg1;
00404ef0  }

00404f07                       90 90 90 90 90 90 90 90 90                                                         .........

00404f10    void sub_404f10(void* arg1, int32_t arg2)

00404f10  {
00404f18      int32_t* esi = *(uint32_t*)((char*)arg1 + 0x68);
00404f1b      void* ebx = *(uint32_t*)((char*)arg1 + 0x10);
00404f1b      
00404f20      if (!esi)
00404f20          return;
00404f20      
00404f29      while (esi[2] >= arg2)
00404f29      {
00404f2e          *(uint32_t*)((char*)arg1 + 0x68) = *(uint32_t*)esi;
00404f34          int32_t edx;
00404f34          (uint8_t)edx = *(uint8_t*)((char*)ebx + 0x14);
00404f3e          int32_t* eax;
00404f3e          
00404f3e          if (!((char)~edx & *(uint8_t*)((char*)esi + 5) & 3))
00404f3e          {
00404f4b              sub_404ef0(esi);
00404f50              int32_t* ecx_2 = esi[2];
00404f5a              esi[4] = *(uint32_t*)ecx_2;
00404f5f              esi[5] = ecx_2[1];
00404f65              esi[6] = ecx_2[2];
00404f68              esi[2] = &esi[4];
00404f6b              eax = sub_404bf0(arg1, esi);
00404f3e          }
00404f3e          else
00404f41              eax = sub_404ec0(arg1, esi);
00404f73          esi = *(uint32_t*)((char*)arg1 + 0x68);
00404f73          
00404f78          if (!esi)
00404f78              break;
00404f29      }
00404f10  }

00404f7f                                                                                               90                                 .

00404f80    int32_t* sub_404f80(void* arg1)

00404f80  {
00404f8e      int32_t* result = sub_404d00(arg1, 0, 0, 0x4c);
00404f99      sub_404bc0(arg1, result, 9);
00404fa1      __builtin_memset(&result[2], 0, 0x3c);
00404fb9      result[0x12] = 0;
00404fbf      *(uint8_t*)((char*)result + 0x49) = 0;
00404fc2      *(uint8_t*)((char*)result + 0x4a) = 0;
00404fc5      *(uint8_t*)((char*)result + 0x4b) = 0;
00404fdf      return result;
00404f80  }


00404fe0    int32_t sub_404fe0(void* arg1, void* arg2)

00404fe0  {
00404ff8      sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 0xc), 
00404ff8          *(uint32_t*)((char*)arg2 + 0x2c) << 2, 0);
0040500b      sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 0x10), 
0040500b          *(uint32_t*)((char*)arg2 + 0x34) << 2, 0);
0040501e      sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 8), 
0040501e          *(uint32_t*)((char*)arg2 + 0x28) << 4, 0);
00405031      sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 0x14), 
00405031          *(uint32_t*)((char*)arg2 + 0x30) << 2, 0);
0040504a      sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 0x18), 
0040504a          *(uint32_t*)((char*)arg2 + 0x38) * 0xc, 0);
0040505d      sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 0x1c), 
0040505d          *(uint32_t*)((char*)arg2 + 0x24) << 2, 0);
00405072      return sub_404d00(arg1, arg2, 0x4c, 0);
00404fe0  }

00405073                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00405080    int32_t sub_405080(void* arg1, void* arg2)

00405080  {
00405089      if (!*(uint8_t*)((char*)arg2 + 6))
00405089      {
004050ac          int32_t eax_5;
004050ac          (uint8_t)eax_5 = *(uint8_t*)((char*)arg2 + 7);
004050c5          return sub_404d00(arg1, arg2, (eax_5 << 2) + 0x14, 0);
00405089      }
00405089      
0040508f      int32_t eax_1;
0040508f      (uint8_t)eax_1 = *(uint8_t*)((char*)arg2 + 7);
004050a7      return sub_404d00(arg1, arg2, (eax_1 << 4) + 0x18, 0);
00405080  }

004050c6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

004050d0    int32_t sub_4050d0(void* arg1, int32_t arg2, int32_t arg3)

004050d0  {
004050d5      int32_t ecx = 0;
004050d7      int32_t edx = *(uint32_t*)((char*)arg1 + 0x38);
004050d7      
004050de      if (edx > 0)
004050de      {
004050e0          void* edi_1 = *(uint32_t*)((char*)arg1 + 0x18);
004050e7          int32_t ebx_1 = arg2;
004050eb          void* eax = (char*)edi_1 + 8;
004050eb          
004050f1          while (*(uint32_t*)((char*)eax - 4) <= arg3)
004050f1          {
004050f5              if (arg3 < *(uint32_t*)eax)
004050f5              {
004050f7                  int32_t temp0_1 = ebx_1;
004050f7                  ebx_1 -= 1;
004050f7                  
004050f8                  if (temp0_1 == 1)
00405114                      return *(uint32_t*)((char*)edi_1 + ecx * 0xc) + 0x10;
004050f5              }
004050f5              
004050fa              ecx += 1;
004050fb              eax += 0xc;
004050fb              
00405100              if (ecx >= edx)
00405100                  break;
004050f1          }
004050de      }
004050de      
00405107      return 0;
004050d0  }

00405115                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00405120    void** sub_405120(void* arg1, int32_t arg2, int32_t* arg3)

00405120  {
00405129      int32_t eax = arg2 - 2;
00405136      char* var_10;
00405136      int32_t* var_c;
00405136      
00405136      switch (eax)
00405136      {
0040516b          case 0:
0040516b          case 1:
0040516b          {
0040516b              int32_t* eax_3 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
00405170              *(uint32_t*)arg3 = *(uint32_t*)eax_3;
00405175              arg3[1] = eax_3[1];
00405178              eax = eax_3[2];
0040517b              arg3[2] = eax;
0040516b              break;
0040516b          }
0040513d          case 2:
0040513d          {
0040513d              var_c = 0x11;
0040513f              var_10 = "not enough memory";
0040514e          label_40514e:
0040514e              void** eax_1 = sub_405f60(arg1, var_10, var_c);
00405156              *(uint32_t*)arg3 = eax_1;
00405158              arg3[2] = 4;
00405162              *(uint32_t*)((char*)arg1 + 8) = &arg3[4];
00405167              return eax_1;
0040513d              break;
0040513d          }
00405146          case 3:
00405146          {
00405146              var_c = 0x17;
00405148              var_10 = "error in error handling";
00405148              goto label_40514e;
00405146          }
00405136      }
00405136      
00405181      *(uint32_t*)((char*)arg1 + 8) = &arg3[4];
00405186      return eax;
00405120  }

00405187                       90                                                                                 .
00405188  uint32_t jump_table_405188[0x4] = 
00405188  {
00405188      [0x0] =  0x00405168
0040518c      [0x1] =  0x00405168
00405190      [0x2] =  0x0040513d
00405194      [0x3] =  0x00405146
00405198  }

00405198                                                                          90 90 90 90 90 90 90 90                          ........

004051a0    int32_t sub_4051a0(int32_t arg1)

004051a0  {
004051a0      int32_t esi;
004051a0      int32_t var_4 = esi;
004051a0      int32_t* esp_1 = &var_4;
004051a1      void* arg_4;
004051a1      void* esi_1 = arg_4;
004051a5      void* eax = *(uint32_t*)((char*)esi_1 + 0x70);
004051a5      
004051aa      if (eax)
004051aa      {
004051b0          *(uint32_t*)((char*)eax + 0x44) = arg1;
004051b9          int32_t var_8_1 = 1;
004051bc          sub_4178e8(*(uint32_t*)((char*)esi_1 + 0x70) + 4, 1);
004051bc          esp_1 = &var_4;
004051aa      }
004051aa      
004051c5      void* ecx_2 = *(uint32_t*)((char*)esi_1 + 0x10);
004051c8      *(uint8_t*)((char*)esi_1 + 6) = (uint8_t)arg1;
004051c8      
004051d0      if (*(uint32_t*)((char*)ecx_2 + 0x58))
004051d0      {
004051d4          sub_4051f0(esi_1, arg1);
004051dd          (*(uint32_t*)(*(uint32_t*)((char*)esi_1 + 0x10) + 0x58))(esi_1);
004051e0          esp_1 = &arg_4;
004051d0      }
004051d0      
004051e3      *(uint32_t*)((char*)esp_1 - 4) = 1;
004051e5      sub_417023();
004051ef      /* tailcall */
004051ef      return sub_4051f0();
004051a0  }


004051f0    int32_t sub_4051f0(void* arg1, int32_t arg2)

004051f0  {
004051f5      int32_t* eax = *(uint32_t*)((char*)arg1 + 0x28);
004051f8      *(uint32_t*)((char*)arg1 + 0x14) = eax;
004051fb      int32_t eax_1 = *(uint32_t*)eax;
004051ff      *(uint32_t*)((char*)arg1 + 0xc) = eax_1;
00405202      sub_404f10(arg1, eax_1);
00405211      sub_405120(arg1, arg2, *(uint32_t*)((char*)arg1 + 0xc));
00405217      *(uint16_t*)((char*)arg1 + 0x34) = 0;
0040521d      *(uint8_t*)((char*)arg1 + 0x37) = 1;
00405221      int32_t result = sub_405240(arg1);
00405229      *(uint32_t*)((char*)arg1 + 0x74) = 0;
00405230      *(uint32_t*)((char*)arg1 + 0x70) = 0;
00405238      return result;
004051f0  }

00405239                                                                             90 90 90 90 90 90 90                           .......

00405240    void sub_405240(void* arg1)

00405240  {
0040524c      if (*(uint32_t*)((char*)arg1 + 0x30) <= 0x4e20)
0040524c          return;
0040524c      
0040525b      int32_t eax_1;
0040525b      int32_t edx_2;
0040525b      edx_2 = HIGHD(0x2aaaaaab
0040525b          * (*(uint32_t*)((char*)arg1 + 0x14) - *(uint32_t*)((char*)arg1 + 0x28)));
0040525b      eax_1 = LOWD(0x2aaaaaab
0040525b          * (*(uint32_t*)((char*)arg1 + 0x14) - *(uint32_t*)((char*)arg1 + 0x28)));
0040525d      int32_t edx_3 = edx_2 >> 2;
0040525d      
0040526f      if (edx_3 + (edx_3 >> 0x1f) + 1 < 0x4e20)
00405277          sub_4053e0(arg1, 0x4e20);
00405240  }

00405281     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00405290    int32_t sub_405290(void* arg1, int32_t arg2, int32_t arg3)

00405290  {
00405297      int32_t result = 0;
004052a6      int32_t ecx = *(uint32_t*)((char*)arg1 + 0x70);
004052a9      int32_t var_4c;
004052a9      *(uint32_t*)((char*)arg1 + 0x70) = &var_4c;
004052af      var_4c = ecx;
004052b3      void var_48;
004052b3      int32_t __saved_ebp;
004052b3      struct _EXCEPTION_REGISTRATION_RECORD* esi;
004052b3      int32_t edi;
004052b3      __setjmp3(&__saved_ebp, esi, edi, &var_48, 0, esi, var_4c);
004052c7      arg2(arg1, arg3);
004052d0      *(uint32_t*)((char*)arg1 + 0x70) = var_4c;
004052da      return result;
00405290  }

004052db                                                                                   90 90 90 90 90                             .....

004052e0    int32_t sub_4052e0(void* arg1, int32_t arg2)

004052e0  {
004052ec      int32_t ebp = *(uint32_t*)((char*)arg1 + 0x20);
004052fa      int32_t eax_1;
004052fa      
004052fa      if (arg2 + 7 > 0xfffffff)
00405316          eax_1 = sub_404ce0(arg1);
004052fa      else
0040530b          eax_1 =
0040530b              sub_404d00(arg1, ebp, *(uint32_t*)((char*)arg1 + 0x2c) << 4, (arg2 + 6) << 4);
0040530b      
00405325      *(uint32_t*)((char*)arg1 + 0x20) = eax_1;
00405328      *(uint32_t*)((char*)arg1 + 0x2c) = arg2 + 6;
0040532b      *(uint32_t*)((char*)arg1 + 0x1c) = (arg2 << 4) + eax_1;
0040533a      return sub_405340(arg1, ebp);
004052e0  }

0040533b                                                                                   90 90 90 90 90                             .....

00405340    int32_t sub_405340(void* arg1, int32_t arg2)

00405340  {
0040535a      *(uint32_t*)((char*)arg1 + 8) = ((*(uint32_t*)((char*)arg1 + 8) - arg2) >> 4 << 4)
0040535a          + *(uint32_t*)((char*)arg1 + 0x20);
0040535a      
00405362      for (void** i = *(uint32_t*)((char*)arg1 + 0x68); i; i = *(uint32_t*)i)
00405374          i[2] = ((i[2] - arg2) >> 4 << 4) + *(uint32_t*)((char*)arg1 + 0x20);
00405374      
0040537d      void* i_1 = *(uint32_t*)((char*)arg1 + 0x28);
0040537d      
00405385      while (i_1 <= *(uint32_t*)((char*)arg1 + 0x14))
00405385      {
0040538d          int32_t esi_8 = *(uint32_t*)((char*)i_1 + 8) - arg2;
0040538f          i_1 += 0x18;
0040539a          *(uint32_t*)((char*)i_1 - 0x10) =
0040539a              (esi_8 >> 4 << 4) + *(uint32_t*)((char*)arg1 + 0x20);
004053ad          *(uint32_t*)((char*)i_1 - 0x18) = ((*(uint32_t*)((char*)i_1 - 0x18) - arg2) >> 4
004053ad              << 4) + *(uint32_t*)((char*)arg1 + 0x20);
004053c0          *(uint32_t*)((char*)i_1 - 0x14) = ((*(uint32_t*)((char*)i_1 - 0x14) - arg2) >> 4
004053c0              << 4) + *(uint32_t*)((char*)arg1 + 0x20);
00405385      }
00405385      
004053d9      int32_t result = ((*(uint32_t*)((char*)arg1 + 0xc) - arg2) >> 4 << 4)
004053d9          + *(uint32_t*)((char*)arg1 + 0x20);
004053dc      *(uint32_t*)((char*)arg1 + 0xc) = result;
004053df      return result;
00405340  }


004053e0    int32_t sub_4053e0(void* arg1, int32_t arg2)

004053e0  {
004053ec      int32_t ebp = *(uint32_t*)((char*)arg1 + 0x28);
004053f7      int32_t eax_2;
004053f7      
004053f7      if (arg2 + 1 > 0xaaaaaaa)
00405417          eax_2 = sub_404ce0(arg1);
004053f7      else
0040540c          eax_2 =
0040540c              sub_404d00(arg1, ebp, *(uint32_t*)((char*)arg1 + 0x30) * 0x18, arg2 * 0x18);
0040540c      
0040542b      int32_t eax_3;
0040542b      int32_t edx_3;
0040542b      edx_3 = HIGHD(0x2aaaaaab * (*(uint32_t*)((char*)arg1 + 0x14) - ebp));
0040542b      eax_3 = LOWD(0x2aaaaaab * (*(uint32_t*)((char*)arg1 + 0x14) - ebp));
0040542d      int32_t edx_4 = edx_3 >> 2;
00405432      *(uint32_t*)((char*)arg1 + 0x30) = arg2;
0040543a      int32_t result = arg2 * 3;
0040543d      *(uint32_t*)((char*)arg1 + 0x28) = eax_2;
0040544b      *(uint32_t*)((char*)arg1 + 0x14) = eax_2 + (edx_4 + (edx_4 >> 0x1f)) * 0x18;
0040544e      *(uint32_t*)((char*)arg1 + 0x24) = eax_2 + (result << 3) - 0x18;
00405454      return result;
004053e0  }

00405455                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00405460    int32_t sub_405460(void* arg1, int32_t arg2)

00405460  {
00405468      int32_t eax = *(uint32_t*)((char*)arg1 + 0x2c);
00405468      
0040546d      if (arg2 > eax)
00405488          return sub_4052e0(arg1, eax + arg2);
00405488      
0040547b      return sub_4052e0(arg1, eax * 2);
00405460  }

00405489                             90 90 90 90 90 90 90                                                           .......

00405490    void* sub_405490(void* arg1, int32_t arg2, int32_t arg3)

00405490  {
00405494      void* esi = arg1;
00405498      void* result = *(uint32_t*)((char*)esi + 0x40);
0040549d      arg1 = result;
0040549d      
004054a1      if (result)
004054a1      {
004054a7          (uint8_t)result = *(uint8_t*)((char*)esi + 0x37);
004054a7          
004054ac          if ((uint8_t)result)
004054ac          {
004054b2              void* eax = *(uint32_t*)((char*)esi + 0x14);
004054b5              int32_t ecx_1 = *(uint32_t*)((char*)esi + 0x20);
004054bd              int32_t ebx_1 = *(uint32_t*)((char*)esi + 8);
004054c7              int32_t ebp_2 = *(uint32_t*)((char*)eax + 8) - ecx_1;
004054d2              int32_t var_64 = arg2;
004054d6              int32_t var_50_1 = arg3;
004054d6              
004054da              if (arg2 != 4)
004054da              {
004054f0                  int32_t eax_2;
004054f0                  int32_t edx_2;
004054f0                  edx_2 =
004054f0                      HIGHD(0x2aaaaaab * ((char*)eax - *(uint32_t*)((char*)esi + 0x28)));
004054f0                  eax_2 = LOWD(0x2aaaaaab * ((char*)eax - *(uint32_t*)((char*)esi + 0x28)));
004054f2                  int32_t edx_3 = edx_2 >> 2;
004054fc                  int32_t var_4_2 = edx_3 + (edx_3 >> 0x1f);
004054da              }
004054da              else
004054dc                  int32_t var_4_1 = 0;
004054dc              
0040550b              if (*(uint32_t*)((char*)esi + 0x1c) - ebx_1 <= 0x140)
00405510                  sub_405460(esi, 0x14);
00405510              
00405529              *(uint32_t*)(*(uint32_t*)((char*)esi + 0x14) + 8) =
00405529                  *(uint32_t*)((char*)esi + 8) + 0x140;
0040552d              *(uint8_t*)((char*)esi + 0x37) = 0;
00405531              arg1(esi, &var_64);
0040553b              void* edx_7 = *(uint32_t*)((char*)esi + 0x14);
0040553e              int32_t ebp_3 = ebp_2 + *(uint32_t*)((char*)esi + 0x20);
00405540              *(uint8_t*)((char*)esi + 0x37) = 1;
00405544              *(uint32_t*)((char*)edx_7 + 8) = ebp_3;
00405547              result = *(uint32_t*)((char*)esi + 0x20);
0040554f              *(uint32_t*)((char*)esi + 8) = ebx_1 - ecx_1 + result;
004054ac          }
004054a1      }
004054a1      
00405559      return result;
00405490  }

0040555a                                                                                90 90 90 90 90 90                            ......

00405560    int32_t sub_405560(void* arg1, void* arg2, int32_t arg3)

00405560  {
00405560      void* eax = arg2;
00405560      
0040556e      if (*(uint32_t*)((char*)eax + 8) != 6)
00405572          eax = sub_405900(arg1, eax);
00405572      
00405582      void* eax_1 = *(uint32_t*)eax;
00405584      void* edi_1 = (char*)eax - *(uint32_t*)((char*)arg1 + 0x20);
00405589      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x14) + 0xc) =
00405589          *(uint32_t*)((char*)arg1 + 0x18);
0040558c      void* ecx;
0040558c      (uint8_t)ecx = *(uint8_t*)((char*)eax_1 + 6);
0040558c      
00405591      if ((uint8_t)ecx)
00405591      {
004056a5          if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= 0x140)
004056aa              sub_405460(arg1, 0x14);
004056aa          
004056b2          void* eax_18 = *(uint32_t*)((char*)arg1 + 0x14);
004056ba          void** eax_19;
004056ba          
004056ba          if (eax_18 != *(uint32_t*)((char*)arg1 + 0x24))
004056ba          {
004056c7              eax_19 = (char*)eax_18 + 0x18;
004056ca              *(uint32_t*)((char*)arg1 + 0x14) = eax_19;
004056ba          }
004056ba          else
004056bd              eax_19 = sub_405740(arg1);
004056bd          
004056d0          void* ecx_13 = (char*)edi_1 + *(uint32_t*)((char*)arg1 + 0x20);
004056d7          eax_19[1] = ecx_13;
004056dd          *(uint32_t*)eax_19 = (char*)ecx_13 + 0x10;
004056df          *(uint32_t*)((char*)arg1 + 0xc) = (char*)ecx_13 + 0x10;
004056e2          int32_t ecx_15 = *(uint32_t*)((char*)arg1 + 8);
004056e5          eax_19[4] = arg3;
004056ee          eax_19[2] = ecx_15 + 0x140;
004056f1          (uint8_t)eax_19 = *(uint8_t*)((char*)arg1 + 0x36);
004056f1          
004056f6          if ((uint8_t)eax_19 & 1)
004056fd              sub_405490(arg1, 0, 0xffffffff);
004056fd          
0040570e          int32_t eax_21 = (
0040570e              *(uint32_t*)(**(uint32_t**)(*(uint32_t*)((char*)arg1 + 0x14) + 4) + 0x10))(arg1);
0040570e          
00405716          if (eax_21 < 0)
0040571f              return 2;
0040571f          
0040572a          sub_4059a0(arg1, *(uint32_t*)((char*)arg1 + 8) - (eax_21 << 4));
00405739          return 1;
00405591      }
00405591      
0040559e      void* ebx = *(uint32_t*)((char*)eax_1 + 0x10);
004055a5      int32_t eax_2;
004055a5      (uint8_t)eax_2 = *(uint8_t*)((char*)ebx + 0x4b);
004055a5      
004055b4      if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= eax_2 << 4)
004055b8          sub_405460(arg1, eax_2);
004055b8      
004055c3      (uint8_t)eax_2 = *(uint8_t*)((char*)ebx + 0x4a);
004055c8      void* ebp_1 = (char*)edi_1 + *(uint32_t*)((char*)arg1 + 0x20);
004055cc      void* ebx_1;
004055cc      void* edi_2;
004055cc      
004055cc      if ((uint8_t)eax_2)
004055cc      {
004055fc          ebx_1 = sub_4057a0(arg1, ebx, ((*(uint32_t*)((char*)arg1 + 8) - ebp_1) >> 4) - 1);
00405606          ebp_1 = (char*)edi_1 + *(uint32_t*)((char*)arg1 + 0x20);
00405608          edi_2 = ebx;
004055cc      }
004055cc      else
004055cc      {
004055ce          edi_2 = ebx;
004055d7          ebx_1 = (char*)ebp_1 + 0x10;
004055da          int32_t eax_3;
004055da          (uint8_t)eax_3 = *(uint8_t*)((char*)edi_2 + 0x49);
004055e0          void* eax_5 = (eax_3 << 4) + ebx_1;
004055e0          
004055e4          if (*(uint32_t*)((char*)arg1 + 8) > eax_5)
004055e6              *(uint32_t*)((char*)arg1 + 8) = eax_5;
004055cc      }
004055cc      
0040560c      void* eax_12 = *(uint32_t*)((char*)arg1 + 0x14);
00405614      void** eax_13;
00405614      
00405614      if (eax_12 != *(uint32_t*)((char*)arg1 + 0x24))
00405614      {
00405621          eax_13 = (char*)eax_12 + 0x18;
00405624          *(uint32_t*)((char*)arg1 + 0x14) = eax_13;
00405614      }
00405614      else
00405617          eax_13 = sub_405740(arg1);
00405617      
00405627      eax_13[1] = ebp_1;
0040562a      *(uint32_t*)eax_13 = ebx_1;
0040562e      *(uint32_t*)((char*)arg1 + 0xc) = ebx_1;
00405631      int32_t ecx_6;
00405631      (uint8_t)ecx_6 = *(uint8_t*)((char*)edi_2 + 0x4b);
00405639      eax_13[2] = (ecx_6 << 4) + ebx_1;
00405643      *(uint32_t*)((char*)arg1 + 0x18) = *(uint32_t*)((char*)edi_2 + 0xc);
00405646      int32_t edi_4 = eax_13[2];
0040564b      eax_13[5] = 0;
0040564e      eax_13[4] = arg3;
00405651      void* i = *(uint32_t*)((char*)arg1 + 8);
00405651      
00405656      if (i < edi_4)
00405656      {
00405663          do
00405663          {
00405658              *(uint32_t*)((char*)i + 8) = 0;
0040565e              i += 0x10;
00405663          } while (i < eax_13[2]);
00405656      }
00405656      
00405668      *(uint32_t*)((char*)arg1 + 8) = eax_13[2];
0040566b      int32_t eax_14;
0040566b      (uint8_t)eax_14 = *(uint8_t*)((char*)arg1 + 0x36);
0040566b      
00405670      if ((uint8_t)eax_14 & 1)
00405670      {
0040567c          *(uint32_t*)((char*)arg1 + 0x18) += 4;
0040567f          sub_405490(arg1, 0, 0xffffffff);
0040568d          *(uint32_t*)((char*)arg1 + 0x18) -= 4;
00405670      }
00405670      
00405696      return 0;
00405560  }

0040573a                                                                                90 90 90 90 90 90                            ......

00405740    int32_t sub_405740(void* arg1)

00405740  {
00405745      int32_t eax = *(uint32_t*)((char*)arg1 + 0x30);
00405745      
0040574d      if (eax > 0x4e20)
0040574d      {
00405752          sub_4051a0(arg1, 5);
0040575d          int32_t eax_2 = *(uint32_t*)((char*)arg1 + 0x14) + 0x18;
00405760          *(uint32_t*)((char*)arg1 + 0x14) = eax_2;
00405764          return eax_2;
0040574d      }
0040574d      
00405769      sub_4053e0(arg1, eax * 2);
00405769      
00405779      if (*(uint32_t*)((char*)arg1 + 0x30) > 0x4e20)
00405781          sub_40bb80(arg1, "stack overflow");
00405781      
0040578c      int32_t eax_6 = *(uint32_t*)((char*)arg1 + 0x14) + 0x18;
0040578f      *(uint32_t*)((char*)arg1 + 0x14) = eax_6;
00405793      return eax_6;
00405740  }

00405794                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

004057a0    int32_t sub_4057a0(int32_t* arg1, void* arg2, int32_t arg3)

004057a0  {
004057aa      void* esi = arg1;
004057b0      int32_t i_3;
004057b0      (uint8_t)i_3 = *(uint8_t*)((char*)arg2 + 0x49);
004057b4      int32_t edi = arg3;
004057b8      int32_t* ebp = nullptr;
004057b8      
004057c0      if (edi < i_3)
004057c0      {
004057c4          int32_t i_2 = i_3 - edi;
004057c6          edi += i_2;
004057c8          arg3 = edi;
004057e0          int32_t i;
004057e0          
004057e0          do
004057e0          {
004057cf              *(uint32_t*)(*(uint32_t*)((char*)esi + 8) + 8) = 0;
004057dc              i = i_2;
004057dc              i_2 -= 1;
004057dd              *(uint32_t*)((char*)esi + 8) += 0x10;
004057e0          } while (i != 1);
004057c0      }
004057c0      
004057e6      if (*(uint8_t*)((char*)arg2 + 0x4a) & 4)
004057e6      {
004057ec          void* eax_2 = *(uint32_t*)((char*)esi + 0x10);
004057f1          int32_t ebp_2 = edi - i_3;
004057f1          
004057ff          if (*(uint32_t*)((char*)eax_2 + 0x44) >= *(uint32_t*)((char*)eax_2 + 0x40))
00405802              sub_403f70(esi);
00405802          
0040580e          int32_t* eax_3 = sub_407b30(esi, ebp_2, 1);
00405813          int32_t ecx_2 = 0;
00405813          
0040581e          if (ebp_2 > 0)
0040581e          {
00405822              arg2 = nullptr;
00405826              int32_t edx_6 = ebp_2 << 4;
00405829              int32_t var_c_1 = edx_6;
00405829              
0040583f              while (true)
0040583f              {
0040583f                  void* eax_6 = (char*)arg2 - edx_6 + *(uint32_t*)((char*)esi + 8);
0040584a                  void* eax_7 = sub_408150(esi, eax_3, ecx_2 + 1);
00405854                  *(uint32_t*)eax_7 = *(uint32_t*)eax_6;
00405859                  *(uint32_t*)((char*)eax_7 + 4) = *(uint32_t*)((char*)eax_6 + 4);
00405863                  *(uint32_t*)((char*)eax_7 + 8) = *(uint32_t*)((char*)eax_6 + 8);
00405866                  ecx_2 += 1;
0040586d                  arg2 += 0x10;
0040586d                  
00405871                  if (ecx_2 >= ebp_2)
00405871                      break;
00405871                  
0040582f                  edx_6 = var_c_1;
0040583f              }
0040583f              
00405877              edi = arg3;
0040581e          }
0040581e          
0040588f          void* eax_9 = sub_4081a0(esi, eax_3, sub_405f60(esi, U"n", 1));
00405898          ebp = eax_3;
0040589f          *(uint32_t*)((char*)eax_9 + 8) = 3;
004058a6          *(uint64_t*)eax_9 = (double)(long double)ebp_2;
004057e6      }
004057e6      
004058a8      int32_t result = *(uint32_t*)((char*)esi + 8);
004058a8      
004058b4      if (i_3 > 0)
004058b4      {
004058b6          void* ecx_7 = result - (edi << 4) + 8;
004058de          int32_t i_1;
004058de          
004058de          do
004058de          {
004058b9              int32_t* edx_13 = *(uint32_t*)((char*)esi + 8);
004058bc              ecx_7 += 0x10;
004058bf              i_1 = i_3;
004058bf              i_3 -= 1;
004058c3              *(uint32_t*)((char*)esi + 8) = &edx_13[4];
004058c9              *(uint32_t*)edx_13 = *(uint32_t*)((char*)ecx_7 - 0x18);
004058ce              edx_13[1] = *(uint32_t*)((char*)ecx_7 - 0x14);
004058d4              edx_13[2] = *(uint32_t*)((char*)ecx_7 - 0x10);
004058d7              *(uint32_t*)((char*)ecx_7 - 0x10) = 0;
004058de          } while (i_1 != 1);
004058b4      }
004058b4      
004058e2      if (ebp)
004058e2      {
004058e4          int32_t** ecx_8 = *(uint32_t*)((char*)esi + 8);
004058ea          *(uint32_t*)((char*)esi + 8) = &ecx_8[4];
004058ed          *(uint32_t*)ecx_8 = ebp;
004058ef          ecx_8[2] = 5;
004058e2      }
004058e2      
004058fd      return result;
004057a0  }

004058fe                                                                                            90 90                                ..

00405900    void* sub_405900(void* arg1, int32_t* arg2)

00405900  {
00405910      void* eax;
00405910      int32_t edx;
00405910      eax = sub_407540(arg1, arg2, 0x10);
00405915      int32_t ecx = *(uint32_t*)((char*)arg1 + 0x20);
0040591f      int32_t eax_1 = *(uint32_t*)((char*)eax + 8);
0040591f      
00405927      if (eax_1 != 6)
00405930          sub_40b960(eax_1, edx, ecx, arg1, arg2, "call");
00405930      
00405938      int32_t* ecx_1 = *(uint32_t*)((char*)arg1 + 8);
00405938      
0040593d      if (ecx_1 > arg2)
0040593d      {
0040593f          int32_t* eax_2 = &ecx_1[-4];
0040593f          
0040595a          do
0040595a          {
00405942              int32_t edx_1 = *(uint32_t*)eax_2;
00405944              eax_2 -= 0x10;
00405947              *(uint32_t*)ecx_1 = edx_1;
0040594c              ecx_1[1] = eax_2[5];
00405952              eax_2[0xa] = eax_2[6];
00405955              ecx_1 -= 0x10;
0040595a          } while (ecx_1 > arg2);
0040593d      }
0040593d      
00405967      if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= 0x10)
0040596c          sub_405460(arg1, 1);
0040596c      
0040597d      void* result = (char*)arg2 - ecx + *(uint32_t*)((char*)arg1 + 0x20);
0040597f      *(uint32_t*)((char*)arg1 + 8) += 0x10;
00405989      *(uint32_t*)result = *(uint32_t*)eax;
0040598e      *(uint32_t*)((char*)result + 4) = *(uint32_t*)((char*)eax + 4);
00405995      *(uint32_t*)((char*)result + 8) = *(uint32_t*)((char*)eax + 8);
00405999      return result;
00405900  }

0040599a                                                                                90 90 90 90 90 90                            ......

004059a0    void* sub_4059a0(void* arg1, int32_t* arg2)

004059a0  {
004059ac      int32_t* i = arg2;
004059ac      
004059b0      if (*(uint8_t*)((char*)arg1 + 0x36) & 2)
004059b4          i = sub_405a20(arg1, i);
004059b4      
004059bc      void* ecx = *(uint32_t*)((char*)arg1 + 0x14);
004059c2      *(uint32_t*)((char*)arg1 + 0x14) = (char*)ecx - 0x18;
004059c5      int32_t* esi = *(uint32_t*)((char*)ecx + 4);
004059ca      int32_t* i_4 = *(uint32_t*)((char*)ecx + 0x10);
004059cd      *(uint32_t*)((char*)arg1 + 0xc) = *(uint32_t*)((char*)ecx - 0x18);
004059d5      arg2 = i_4;
004059d9      *(uint32_t*)((char*)arg1 + 0x18) = *(uint32_t*)((char*)ecx - 0xc);
004059d9      
004059dc      if (i_4)
004059dc      {
004059e1          while (i < *(uint32_t*)((char*)arg1 + 8))
004059e1          {
004059e3              int32_t* i_2 = i;
004059e5              int32_t* edx_2 = esi;
004059e7              i = &i[4];
004059ea              esi = &esi[4];
004059ef              int32_t* i_5 = i_4;
004059ef              i_4 -= 1;
004059f0              *(uint32_t*)edx_2 = *(uint32_t*)i_2;
004059f5              edx_2[1] = i_2[1];
004059fb              edx_2[2] = i_2[2];
004059fb              
004059fe              if (i_5 == 1)
004059fe                  break;
004059e1          }
004059dc      }
004059dc      
00405a05      if (i_4 > 0)
00405a05      {
00405a07          void* i_3 = i_4;
00405a11          void* i_1;
00405a11          
00405a11          do
00405a11          {
00405a0a              esi[2] = 0;
00405a0d              esi = &esi[4];
00405a10              i_1 = i_3;
00405a10              i_3 -= 1;
00405a11          } while (i_1 != 1);
00405a05      }
00405a05      
00405a17      *(uint32_t*)((char*)arg1 + 8) = esi;
00405a1f      return (char*)arg2 + 1;
004059a0  }


00405a20    int32_t sub_405a20(void* arg1, int32_t arg2)

00405a20  {
00405a32      int32_t edi_1 = arg2 - *(uint32_t*)((char*)arg1 + 0x20);
00405a34      sub_405490(arg1, 1, 0xffffffff);
00405a39      void* eax_1 = *(uint32_t*)((char*)arg1 + 0x14);
00405a44      int32_t* ecx;
00405a44      (uint8_t)ecx = *(uint8_t*)(**(uint32_t**)((char*)eax_1 + 4) + 6);
00405a44      
00405a49      if (!(uint8_t)ecx)
00405a49      {
00405a4b          int32_t ecx_1 = *(uint32_t*)((char*)eax_1 + 0x14);
00405a53          *(uint32_t*)((char*)eax_1 + 0x14) = ecx_1 - 1;
00405a53          
00405a56          if (ecx_1)
00405a56          {
00405a73              int32_t i;
00405a73              
00405a73              do
00405a73              {
00405a5d                  sub_405490(arg1, 4, 0xffffffff);
00405a62                  void* eax_2 = *(uint32_t*)((char*)arg1 + 0x14);
00405a68                  i = *(uint32_t*)((char*)eax_2 + 0x14);
00405a70                  *(uint32_t*)((char*)eax_2 + 0x14) = i - 1;
00405a73              } while (i);
00405a56          }
00405a49      }
00405a49      
00405a7e      return edi_1 + *(uint32_t*)((char*)arg1 + 0x20);
00405a20  }

00405a7f                                                                                               90                                 .

00405a80    void* sub_405a80(void* arg1, void* arg2, int32_t arg3)

00405a80  {
00405a85      *(uint16_t*)((char*)arg1 + 0x34) += 1;
00405a89      int16_t eax = *(uint16_t*)((char*)arg1 + 0x34);
00405a89      
00405a93      if (eax == 0xc8)
00405a9b          sub_40bb80(arg1, "C stack overflow");
00405a93      else if (eax >= 0xe1)
00405aab          sub_4051a0(arg1, 5);
00405aab      
00405ac8      if (!sub_405560(arg1, arg2, arg3))
00405acd          sub_409290(arg1, 1);
00405acd      
00405ad5      void* result = *(uint32_t*)((char*)arg1 + 0x10);
00405ad8      *(uint16_t*)((char*)arg1 + 0x34) -= 1;
00405ad8      
00405ae4      if (*(uint32_t*)((char*)result + 0x44) < *(uint32_t*)((char*)result + 0x40))
00405af0          return result;
00405af0      
00405ae7      return sub_403f70(arg1);
00405a80  }

00405af1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00405b00    int32_t sub_405b00(void* arg1, int32_t arg2)

00405b00  {
00405b05      char eax = *(uint8_t*)((char*)arg1 + 6);
00405b05      
00405b0a      if (eax != 1)
00405b0a      {
00405b0e          if (eax)
00405b0e          {
00405b16              sub_405c10(arg1, "cannot resume dead coroutine");
00405b1f              return 2;
00405b0e          }
00405b0e          
00405b28          if (*(uint32_t*)((char*)arg1 + 0x14) != *(uint32_t*)((char*)arg1 + 0x28))
00405b28          {
00405b30              sub_405c10(arg1, "cannot resume non-suspended coroutine");
00405b39              return 2;
00405b28          }
00405b0a      }
00405b0a      
00405b4e      int32_t eax_2 =
00405b4e          sub_405290(arg1, sub_405b90, *(uint32_t*)((char*)arg1 + 8) - (arg2 << 4));
00405b4e      
00405b5a      if (!eax_2)
00405b5a      {
00405b7d          int32_t ebx_1;
00405b7d          (uint8_t)ebx_1 = *(uint8_t*)((char*)arg1 + 6);
00405b84          return ebx_1;
00405b5a      }
00405b5a      
00405b5c      int32_t* eax_3 = *(uint32_t*)((char*)arg1 + 8);
00405b5f      *(uint8_t*)((char*)arg1 + 6) = (uint8_t)eax_2;
00405b65      sub_405120(arg1, eax_2, eax_3);
00405b75      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x14) + 8) = *(uint32_t*)((char*)arg1 + 8);
00405b7a      return eax_2;
00405b00  }

00405b85                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00405b90    int32_t sub_405b90(void* arg1, int32_t* arg2)

00405b90  {
00405b98      int32_t* eax = *(uint32_t*)((char*)arg1 + 0x14);
00405b98      
00405b9e      if (*(uint8_t*)((char*)arg1 + 6) == 1)
00405b9e      {
00405bbe          int32_t* ecx_1;
00405bbe          (uint8_t)ecx_1 = *(uint8_t*)(*(uint32_t*)eax[1] + 6);
00405bbe          
00405bc3          if (!(uint8_t)ecx_1)
00405be4              *(uint32_t*)((char*)arg1 + 0xc) = *(uint32_t*)eax;
00405bc3          else if (sub_4059a0(arg1, arg2))
00405bdd              *(uint32_t*)((char*)arg1 + 8) =
00405bdd                  *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x14) + 8);
00405bdd          
00405bc3          goto label_405bf4;
00405b9e      }
00405b9e      
00405bab      int32_t result = sub_405560(arg1, &arg2[-4], 0xffffffff);
00405bab      
00405bb5      if (!result)
00405bb5      {
00405bf4      label_405bf4:
00405bf4          int32_t eax_6;
00405bf4          int32_t edx_4;
00405bf4          edx_4 = HIGHD(0x2aaaaaab
00405bf4              * (*(uint32_t*)((char*)arg1 + 0x14) - *(uint32_t*)((char*)arg1 + 0x28)));
00405bf4          eax_6 = LOWD(0x2aaaaaab
00405bf4              * (*(uint32_t*)((char*)arg1 + 0x14) - *(uint32_t*)((char*)arg1 + 0x28)));
00405bf6          int32_t edx_5 = edx_4 >> 2;
00405bfb          *(uint8_t*)((char*)arg1 + 6) = 0;
00405c06          int80_t st0_1;
00405c06          st0_1 = sub_409290(arg1, edx_5 + (edx_5 >> 0x1f));
00405bb5      }
00405bb5      
00405c0f      return result;
00405b90  }


00405c10    int32_t sub_405c10(void* arg1, char* arg2)

00405c10  {
00405c1b      char* edi = arg2;
00405c20      int32_t i = 0xffffffff;
00405c23      void*** ebx = **(uint32_t**)((char*)arg1 + 0x14);
00405c27      *(uint32_t*)((char*)arg1 + 8) = ebx;
00405c27      
00405c2a      while (i)
00405c2a      {
00405c2a          bool cond:0_1 = 0 != *(uint8_t*)edi;
00405c2a          edi = &edi[1];
00405c2a          i -= 1;
00405c2a          
00405c2a          if (!cond:0_1)
00405c2a              break;
00405c2a      }
00405c2a      
00405c37      *(uint32_t*)ebx = sub_405f60(arg1, arg2, ~i - 1);
00405c39      ebx[2] = 4;
00405c39      
00405c52      if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= 0x10)
00405c57          sub_405460(arg1, 1);
00405c57      
00405c65      *(uint32_t*)((char*)arg1 + 8) += 0x10;
00405c6f      return 2;
00405c10  }


00405c70    int32_t sub_405c70(void* arg1, int32_t arg2)

00405c70  {
00405c7a      if (*(uint16_t*)((char*)arg1 + 0x34) > 0)
00405c82          sub_40bb80(arg1, "attempt to yield across metamethod/C-call boundary");
00405c82      
00405c94      int32_t ecx_1 = *(uint32_t*)((char*)arg1 + 8) - (arg2 << 4);
00405c96      *(uint8_t*)((char*)arg1 + 6) = 1;
00405c9a      *(uint32_t*)((char*)arg1 + 0xc) = ecx_1;
00405ca1      return 0xffffffff;
00405c70  }

00405ca2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00405cb0    int32_t sub_405cb0(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)

00405cb0  {
00405cb6      void* esi = arg1;
00405cbb      int16_t eax = *(uint16_t*)((char*)esi + 0x34);
00405cc8      int32_t edi = *(uint32_t*)((char*)esi + 0x74);
00405cd4      (uint8_t)arg1 = *(uint8_t*)((char*)esi + 0x37);
00405cdc      int32_t ebx_1 = *(uint32_t*)((char*)esi + 0x14) - *(uint32_t*)((char*)esi + 0x28);
00405ce9      *(uint32_t*)((char*)esi + 0x74) = arg5;
00405cec      int32_t result = sub_405290(esi, arg2, arg3);
00405cec      
00405cf8      if (!result)
00405cf8      {
00405d4f          *(uint32_t*)((char*)esi + 0x74) = edi;
00405d5b          return result;
00405cf8      }
00405cf8      
00405d01      int32_t* edi_2 = *(uint32_t*)((char*)esi + 0x20) + arg4;
00405d05      sub_404f10(esi, edi_2);
00405d0d      sub_405120(esi, result, edi_2);
00405d1a      int32_t* eax_3 = *(uint32_t*)((char*)esi + 0x28) + ebx_1;
00405d1c      *(uint16_t*)((char*)esi + 0x34) = eax;
00405d20      *(uint32_t*)((char*)esi + 0x14) = eax_3;
00405d26      *(uint32_t*)((char*)esi + 0xc) = *(uint32_t*)eax_3;
00405d29      int32_t edx_4 = eax_3[3];
00405d2c      (uint8_t)eax_3 = (uint8_t)arg1;
00405d30      *(uint32_t*)((char*)esi + 0x18) = edx_4;
00405d33      *(uint8_t*)((char*)esi + 0x37) = (uint8_t)eax_3;
00405d36      sub_405240(esi);
00405d42      *(uint32_t*)((char*)esi + 0x74) = edi;
00405d4e      return result;
00405cb0  }

00405d5c                                                                                      90 90 90 90                              ....

00405d60    int32_t sub_405d60(void* arg1, int32_t arg2, int32_t arg3)

00405d60  {
00405d70      int32_t var_14 = arg2;
00405d74      int32_t var_4 = arg3;
00405d91      int32_t var_10 = 0;
00405d99      int32_t var_8 = 0;
00405da1      int32_t result = sub_405cb0(arg1, sub_405dd0, &var_14, 
00405da1          *(uint32_t*)((char*)arg1 + 8) - *(uint32_t*)((char*)arg1 + 0x20), 
00405da1          *(uint32_t*)((char*)arg1 + 0x74));
00405db5      sub_404d00(arg1, var_10, var_8, 0);
00405dc4      return result;
00405d60  }

00405dc5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00405dd0    int32_t sub_405dd0(void* arg1, int32_t* arg2)

00405dd0  {
00405dda      int32_t eax_1 = sub_40a6e0(*(uint32_t*)arg2);
00405de8      void* eax_2 = *(uint32_t*)((char*)arg1 + 0x10);
00405de8      
00405df3      if (*(uint32_t*)((char*)eax_2 + 0x44) >= *(uint32_t*)((char*)eax_2 + 0x40))
00405df6          sub_403f70(arg1);
00405df6      
00405e07      int32_t* (* eax_3)(void* arg1, int32_t arg2, int32_t arg3, char* arg4) = sub_414ef0;
00405e07      
00405e0c      if (eax_1 != (int32_t)(*(uint8_t*)data_42b214))
00405e0e          eax_3 = sub_4127b0;
00405e0e      
00405e1f      void* eax_4 = eax_3(arg1, *(uint32_t*)arg2, &arg2[1], arg2[4]);
00405e29      int32_t eax_5;
00405e29      (uint8_t)eax_5 = *(uint8_t*)((char*)eax_4 + 0x48);
00405e2e      int32_t* eax_6 = sub_404d90(arg1, eax_5, *(uint32_t*)((char*)arg1 + 0x48));
00405e33      eax_6[4] = eax_4;
00405e3c      int32_t ebx_1 = 0;
00405e3c      
00405e44      if (*(uint8_t*)((char*)eax_4 + 0x48) > 0)
00405e44      {
00405e47          int32_t** ebp_1 = &eax_6[5];
00405e61          int32_t ecx_4;
00405e61          
00405e61          do
00405e61          {
00405e55              *(uint32_t*)ebp_1 = sub_404df0(arg1);
00405e58              (uint8_t)ecx_4 = *(uint8_t*)((char*)eax_4 + 0x48);
00405e5b              ebx_1 += 1;
00405e5c              ebp_1 = &ebp_1[1];
00405e61          } while (ebx_1 < ecx_4);
00405e44      }
00405e44      
00405e68      int32_t** ecx_5 = *(uint32_t*)((char*)arg1 + 8);
00405e70      *(uint32_t*)ecx_5 = eax_6;
00405e72      ecx_5[2] = 6;
00405e72      
00405e83      if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= 0x10)
00405e88          sub_405460(arg1, 1);
00405e88      
00405e93      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00405e96      *(uint32_t*)((char*)arg1 + 8) = result;
00405e9b      return result;
00405dd0  }

00405e9c                                                                                      90 90 90 90                              ....

00405ea0    void* sub_405ea0(void* arg1, int32_t arg2)

00405ea0  {
00405ea0      int32_t i_2;
00405ea0      int32_t i_1 = i_2;
00405ea2      void* edi = arg1;
00405ea6      void* result = *(uint32_t*)((char*)edi + 0x10);
00405ea6      
00405ead      if (*(uint8_t*)((char*)result + 0x15) != 2)
00405ead      {
00405eb5          int32_t ebp_1 = arg2;
00405ec3          int32_t eax;
00405ec3          
00405ec3          if (ebp_1 + 1 > 0x3fffffff)
00405edd              eax = sub_404ce0(edi);
00405ec3          else
00405ed2              eax = sub_404d00(edi, 0, 0, ebp_1 << 2);
00405ed2          
00405ee5          int32_t* ebx_1 = *(uint32_t*)((char*)edi + 0x10);
00405ee5          
00405eec          if (ebp_1 > 0)
00405eec          {
00405ef4              __builtin_memset(eax, 0, ebp_1 << 2);
00405ef6              edi = arg1;
00405eec          }
00405eec          
00405efd          int32_t i = 0;
00405f01          i_1 = 0;
00405f01          
00405f05          if (ebx_1[2] > 0)
00405f05          {
00405f3e              do
00405f3e              {
00405f09                  int32_t* j_1 = *(uint32_t*)(*(uint32_t*)ebx_1 + (i << 2));
00405f09                  
00405f0e                  if (j_1)
00405f0e                  {
00405f26                      int32_t* j;
00405f26                      
00405f26                      do
00405f26                      {
00405f16                          j = *(uint32_t*)j_1;
00405f18                          int32_t ecx_3 = j_1[2] & (ebp_1 - 1);
00405f1f                          *(uint32_t*)j_1 = *(uint32_t*)(eax + (ecx_3 << 2));
00405f21                          *(uint32_t*)(eax + (ecx_3 << 2)) = j_1;
00405f24                          j_1 = j;
00405f26                      } while (j);
00405f28                      ebp_1 = arg2;
00405f2c                      i = i_1;
00405f30                      edi = arg1;
00405f0e                  }
00405f0e                  
00405f37                  i += 1;
00405f3a                  i_1 = i;
00405f3e              } while (i < ebx_1[2]);
00405f05          }
00405f05          
00405f4d          result = sub_404d00(edi, *(uint32_t*)ebx_1, ebx_1[2] << 2, 0);
00405f55          *(uint32_t*)ebx_1 = eax;
00405f57          ebx_1[2] = ebp_1;
00405ead      }
00405ead      
00405f5f      return result;
00405ea0  }


00405f60    void** sub_405f60(void* arg1, char* arg2, int32_t* arg3)

00405f60  {
00405f66      char* ebx = arg2;
00405f74      int32_t* edx = arg3;
00405f76      int32_t* i = arg3;
00405f76      
00405f78      if (arg3 >= (arg3 >> 5) + 1)
00405f78      {
00405f94          do
00405f94          {
00405f7e              int32_t ecx_1;
00405f7e              (uint8_t)ecx_1 = *(uint8_t*)(ebx + i - 1);
00405f82              i -= (arg3 >> 5) + 1;
00405f90              edx ^= ecx_1 + (edx << 5) + (edx >> 2);
00405f94          } while (i >= (arg3 >> 5) + 1);
00405f78      }
00405f78      
00405f9a      int32_t* eax_4 = *(uint32_t*)((char*)arg1 + 0x10);
00405f9a      
00405fae      for (void** i_1 = *(uint32_t*)(*(uint32_t*)eax_4 + (((eax_4[2] - 1) & edx) << 2)); 
00405fae          i_1; i_1 = *(uint32_t*)i_1)
00405fae      {
00405fb3          if (i_1[3] == arg3)
00405fb3          {
00405fb5              char* esi = ebx;
00405fb7              int32_t* j = arg3;
00405fb9              void* edi_5 = &i_1[4];
00405fbc              bool cond:2_1 = true;
00405fbc              
00405fbe              while (j)
00405fbe              {
00405fbe                  char temp0_1 = *(uint8_t*)esi;
00405fbe                  char temp1_1 = *(uint8_t*)edi_5;
00405fbe                  cond:2_1 = temp0_1 == temp1_1;
00405fbe                  esi = &esi[1];
00405fbe                  edi_5 += 1;
00405fbe                  j -= 1;
00405fbe                  
00405fbe                  if (temp0_1 != temp1_1)
00405fbe                      break;
00405fbe              }
00405fbe              
00405fc0              if (cond:2_1)
00405fc0              {
00405fe5                  (uint8_t)j = *(uint8_t*)((char*)i_1 + 5);
00405fe8                  (uint8_t)edx = (uint8_t)j;
00405fea                  int32_t ebx_1;
00405fea                  (uint8_t)ebx_1 = eax_4[5];
00405fea                  
00405ff4                  if (!((char)~ebx_1 & (uint8_t)edx & 3))
00405fe0                      return i_1;
00405fe0                  
00405ff7                  (uint8_t)j ^= 3;
00405ffc                  *(uint8_t*)((char*)i_1 + 5) = (uint8_t)j;
00406000                  return i_1;
00405fc0              }
00405fc0              
00405fc2              ebx = arg2;
00405fb3          }
00405fae      }
00405fae      
00405fd4      return sub_406010(arg1, ebx, arg3, edx);
00405f60  }

00406001     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00406010    int32_t* sub_406010(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00406010  {
00406022      if (arg3 + 1 > 0xffffffed)
00406025          sub_404ce0(arg1);
00406025      
00406036      int32_t* result = sub_404d00(arg1, 0, 0, arg3 + 0x11);
00406044      result[3] = arg3;
00406047      result[2] = arg4;
00406054      char ecx_1 = *(uint8_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 0x14);
00406057      result[1] = 4;
0040605e      *(uint8_t*)((char*)result + 6) = 0;
00406062      *(uint8_t*)((char*)result + 5) = ecx_1 & 3;
0040606c      int32_t esi_2;
0040606c      int32_t edi_1;
0040606c      edi_1 = __builtin_memcpy(&result[4], arg2, arg3 >> 2 << 2);
00406073      __builtin_memcpy(edi_1, esi_2, arg3 & 3);
00406079      *(uint8_t*)(arg3 + result + 0x10) = 0;
0040607e      int32_t* eax_3 = *(uint32_t*)((char*)arg1 + 0x10);
00406085      int32_t edx_1 = arg4 & (eax_3[2] - 1);
0040608c      *(uint32_t*)result = *(uint32_t*)(*(uint32_t*)eax_3 + (edx_1 << 2));
00406091      *(uint32_t*)(*(uint32_t*)eax_3 + (edx_1 << 2)) = result;
00406097      int32_t edi_3 = eax_3[1] + 1;
00406098      eax_3[1] = edi_3;
0040609b      int32_t eax_4 = eax_3[2];
0040609b      
004060a9      if (edi_3 > eax_4 && eax_4 <= 0x3ffffffe)
004060b0          sub_405ea0(arg1, eax_4 * 2);
004060b0      
004060be      return result;
00406010  }

004060bf                                                                                               90                                 .

004060c0    int32_t* sub_4060c0(void* arg1, int32_t arg2, int32_t arg3)

004060c0  {
004060cd      if (arg2 > 0xffffffe5)
004060d0          sub_404ce0(arg1);
004060d0      
004060e1      int32_t* result = sub_404d00(arg1, 0, 0, arg2 + 0x18);
004060f6      result[1] = 7;
004060fa      *(uint8_t*)((char*)result + 5) =
004060fa          *(uint8_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 0x14) & 3;
004060fd      result[4] = arg2;
00406100      result[2] = 0;
00406107      result[3] = arg3;
00406113      *(uint32_t*)result = **(uint32_t**)(*(uint32_t*)((char*)arg1 + 0x10) + 0x70);
0040611c      **(uint32_t**)(*(uint32_t*)((char*)arg1 + 0x10) + 0x70) = result;
0040611e      return result;
004060c0  }

0040611f                                                                                               90                                 .

00406120    void** sub_406120(void* arg1)

00406120  {
00406128      int32_t ebx = 0;
00406162      void** result;
00406162      
00406162      for (void* const i = &data_428218; i < 0x42826c; )
00406162      {
0040612f          char* edx_1 = *(uint32_t*)i;
00406131          int32_t j = 0xffffffff;
00406134          char* edi_1 = edx_1;
00406134          
00406138          while (j)
00406138          {
00406138              bool cond:0_1 = 0 != *(uint8_t*)edi_1;
00406138              edi_1 = &edi_1[1];
00406138              j -= 1;
00406138              
00406138              if (!cond:0_1)
00406138                  break;
00406138          }
00406138          
00406140          result = sub_405f60(arg1, edx_1, ~j - 1);
0040614e          i += 4;
00406151          *(uint8_t*)((char*)result + 5) |= 0x20;
00406156          char ecx_3 = (uint8_t)ebx + 1;
00406158          ebx += 1;
0040615f          *(uint8_t*)((char*)result + 6) = ecx_3;
00406162      }
00406162      
00406168      return result;
00406120  }

00406169                             90 90 90 90 90 90 90                                                           .......

00406170    int32_t sub_406170(void* arg1, int32_t arg2)

00406170  {
0040617b      if (arg2 >= 0x101)
004061d9          return *(uint32_t*)((arg2 << 2) + 0x427e14);
004061d9      
00406184      BOOL eax_1;
00406184      
00406184      if (data_42d07c <= 1)
00406184      {
00406198          wchar16 (* eax_2)[0x21];
00406198          (uint8_t)eax_2 = (**(uint528_t**)&data_42ce70)[arg2];
0040619b          eax_1 = eax_2 & 0x20;
00406184      }
00406184      else
00406184      {
00406186          int32_t var_8_1 = 0x20;
00406189          int32_t eax;
00406189          int32_t ecx;
00406189          int32_t edx;
00406189          eax_1 = sub_4179df(eax, edx, ecx, arg2);
00406184      }
00406184      
004061a0      int32_t var_8_2 = arg2;
004061a0      
004061a1      if (!eax_1)
004061d0          return sub_4087a0(*(uint32_t*)((char*)arg1 + 0x34), 0x42b444);
004061d0      
004061b9      return sub_4087a0(*(uint32_t*)((char*)arg1 + 0x34), "char(%d)");
00406170  }

004061da                                                                                90 90 90 90 90 90                            ......

004061e0    int32_t sub_4061e0(void* arg1, int32_t arg2, int32_t arg3)

004061e0  {
004061f7      char var_50[0x50];
004061f7      sub_4087c0(&var_50, *(uint32_t*)((char*)arg1 + 0x40) + 0x10, 0x50);
00406203      int32_t var_68 = arg2;
0040620b      int32_t var_6c = *(uint32_t*)((char*)arg1 + 4);
0040620c      char (* var_70)[0x50] = &var_50;
00406213      int32_t eax_3 = sub_4087a0(*(uint32_t*)((char*)arg1 + 0x34), "%s:%d: %s");
00406213      
00406226      if (arg3)
00406226      {
0040622f          int32_t var_64_1 = sub_406260(arg1, arg3);
00406233          int32_t var_68_1 = eax_3;
0040623a          sub_4087a0(*(uint32_t*)((char*)arg1 + 0x34), "%s near '%s'");
00406226      }
00406226      
00406255      return sub_4051a0(*(uint32_t*)((char*)arg1 + 0x34), 3);
004061e0  }

00406256                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00406260    int32_t sub_406260(void* arg1, int32_t arg2)

00406260  {
00406270      if (arg2 < 0x11c || arg2 > 0x11e)
00406297          return sub_406170(arg1, arg2);
00406297      
0040627a      sub_4062a0(arg1, 0);
00406288      return **(uint32_t**)((char*)arg1 + 0x3c);
00406260  }

00406298                                                                          90 90 90 90 90 90 90 90                          ........

004062a0    int32_t sub_4062a0(void* arg1, char arg2)

004062a0  {
004062a6      int32_t* esi = *(uint32_t*)((char*)arg1 + 0x3c);
004062ac      int32_t eax = esi[2];
004062ac      
004062b2      if (esi[1] + 1 > eax)
004062b2      {
004062b9          if (eax >= 0x7ffffffe)
004062c3              sub_4061e0(arg1, "lexical element too long", 0);
004062c3          
004062cb          int32_t eax_1 = esi[2];
004062cf          int32_t edi_1 = eax_1 * 2;
004062d8          int32_t eax_3;
004062d8          
004062d8          if (edi_1 + 1 > 0xfffffffd)
004062f1              eax_3 = sub_404ce0(*(uint32_t*)((char*)arg1 + 0x34));
004062d8          else
004062e3              eax_3 = sub_404d00(*(uint32_t*)((char*)arg1 + 0x34), *(uint32_t*)esi, eax_1, 
004062e3                  edi_1);
004062e3          
004062f9          esi[2] = edi_1;
004062fc          *(uint32_t*)esi = eax_3;
004062b2      }
004062b2      
00406308      esi[1][*(uint32_t*)esi] = arg2;
0040630e      int32_t result = esi[1] + 1;
0040630f      esi[1] = result;
00406314      return result;
004062a0  }

00406315                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00406320    int32_t sub_406320(void* arg1, int32_t arg2)

00406320  {
00406336      return sub_4061e0(arg1, arg2, *(uint32_t*)((char*)arg1 + 0x10));
00406320  }

00406337                                                                       90 90 90 90 90 90 90 90 90                         .........

00406340    void** sub_406340(void* arg1, char* arg2, int32_t* arg3)

00406340  {
0040634f      void* esi = *(uint32_t*)((char*)arg1 + 0x34);
00406355      void** result = sub_405f60(esi, arg2, arg3);
00406365      void* eax_1 =
00406365          sub_4081a0(esi, *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x30) + 4), result);
00406365      
00406372      if (!*(uint32_t*)((char*)eax_1 + 8))
00406372      {
00406374          *(uint32_t*)eax_1 = 1;
0040637a          *(uint32_t*)((char*)eax_1 + 8) = 1;
00406372      }
00406372      
00406386      return result;
00406340  }

00406387                       90 90 90 90 90 90 90 90 90                                                         .........

00406390    int32_t* sub_406390(void* arg1, int32_t* arg2, int32_t arg3, int32_t arg4)

00406390  {
004063a3      arg2[0xe] = arg3;
004063ab      arg2[1] = 1;
004063ae      arg2[2] = 1;
004063b1      int32_t* eax = arg2[0xf];
004063b4      arg2[0x11] = 0x2e;
004063b8      arg2[0xd] = arg1;
004063bb      arg2[8] = 0x11f;
004063c2      arg2[0xc] = 0;
004063c9      arg2[0x10] = arg4;
004063df      *(uint32_t*)arg2[0xf] = sub_404d00(arg1, *(uint32_t*)eax, eax[2], 0x20);
004063e4      *(uint32_t*)(arg2[0xf] + 8) = 0x20;
004063eb      int32_t* eax_3 = arg2[0xe];
004063ee      int32_t ecx_2 = *(uint32_t*)eax_3;
004063f5      *(uint32_t*)eax_3 = ecx_2 - 1;
004063f7      int32_t* eax_4 = arg2[0xe];
004063f7      
004063fa      if (ecx_2 <= 0)
004063fa      {
0040640c          int32_t eax_5 = sub_40a6a0(eax_4);
00406414          *(uint32_t*)arg2 = eax_5;
00406417          return eax_5;
004063fa      }
004063fa      
004063fc      char* ecx_3 = eax_4[1];
00406401      int32_t edx_4;
00406401      (uint8_t)edx_4 = *(uint8_t*)ecx_3;
00406404      eax_4[1] = &ecx_3[1];
00406407      *(uint32_t*)arg2 = edx_4;
0040640a      return eax_4;
00406390  }

00406418                                                                          90 90 90 90 90 90 90 90                          ........

00406420    void* sub_406420(int32_t* arg1)

00406420  {
00406428      int32_t ecx = arg1[8];
0040642b      arg1[2] = arg1[1];
0040642b      
00406437      if (ecx == 0x11f)
00406437      {
00406461          int32_t result = sub_406470(arg1, &arg1[6]);
00406469          arg1[4] = result;
0040646d          return result;
00406437      }
00406437      
00406440      arg1[4] = arg1[8];
00406445      arg1[5] = arg1[9];
0040644b      arg1[6] = arg1[0xa];
0040644e      int32_t ecx_2 = arg1[0xb];
00406451      arg1[8] = 0x11f;
00406457      arg1[7] = ecx_2;
0040645b      return &arg1[8];
00406420  }

0040646e                                            90 90                                                                ..

00406470    int32_t sub_406470(int32_t* arg1, void*** arg2)

00406470  {
00406482      *(uint32_t*)(arg1[0xf] + 4) = 0;
00406485      BOOL eax_11;
00406485      wchar16 (* ecx_9)[0x21];
00406485      void* edx;
00406485      
00406485      while (true)
00406485      {
00406485          int32_t eax_12 = *(uint32_t*)arg1;
00406485          
0040648d          if (eax_12 + 1 <= 0x7f)
0040648d          {
00406495              (uint8_t)edx = lookup_table_406a88[1 + eax_12];
00406495              
0040649b              switch (edx)
0040649b              {
00406902                  case nullptr:
00406902                  {
00406902                      return 0x11f;
00406902                      break;
00406902                  }
004064a3                  case 1:
004064a3                  {
004064a3                      edx = sub_406b10(arg1);
004064ab                      continue;
004064a3                  }
00406835                  case 2:
00406835                  {
00406835                      sub_4070f0(arg1, *(uint32_t*)arg1, arg2);
00406846                      return 0x11e;
00406835                      break;
00406835                  }
004064ad                  case 3:
004064ad                  {
004064ad                      int32_t* eax_1 = arg1[0xe];
004064b0                      int32_t ecx_2 = *(uint32_t*)eax_1;
004064b7                      *(uint32_t*)eax_1 = ecx_2 - 1;
004064b9                      int32_t eax_2;
004064b9                      
004064b9                      if (ecx_2 <= 0)
004064cf                          eax_2 = sub_40a6a0(arg1[0xe]);
004064b9                      else
004064b9                      {
004064bb                          void* ecx_3 = arg1[0xe];
004064c0                          char* edx_2 = *(uint32_t*)((char*)ecx_3 + 4);
004064c3                          (uint8_t)eax_2 = *(uint8_t*)edx_2;
004064c6                          *(uint32_t*)((char*)ecx_3 + 4) = &edx_2[1];
004064b9                      }
004064b9                      
004064da                      *(uint32_t*)arg1 = eax_2;
004064da                      
004064dc                      if (eax_2 != 0x2d)
004065f7                          return 0x2d;
004065f7                      
004064e2                      int32_t* eax_4 = arg1[0xe];
004064e5                      int32_t ecx_4 = *(uint32_t*)eax_4;
004064ec                      *(uint32_t*)eax_4 = ecx_4 - 1;
004064ee                      int32_t eax_5;
004064ee                      
004064ee                      if (ecx_4 <= 0)
00406504                          eax_5 = sub_40a6a0(arg1[0xe]);
004064ee                      else
004064ee                      {
004064f0                          void* ecx_5 = arg1[0xe];
004064f5                          char* edx_5 = *(uint32_t*)((char*)ecx_5 + 4);
004064f8                          (uint8_t)eax_5 = *(uint8_t*)edx_5;
004064fa                          edx = &edx_5[1];
004064fb                          *(uint32_t*)((char*)ecx_5 + 4) = edx;
004064ee                      }
004064ee                      
0040650f                      *(uint32_t*)arg1 = eax_5;
0040650f                      
00406511                      if (eax_5 == 0x5b)
00406511                      {
00406514                          int32_t eax_7;
00406514                          eax_7 = sub_406df0(arg1);
00406521                          *(uint32_t*)(arg1[0xf] + 4) = 0;
00406521                          
00406524                          if (eax_7 >= 0)
00406524                          {
00406529                              sub_406e90(arg1, nullptr, eax_7);
0040652e                              edx = arg1[0xf];
00406534                              *(uint32_t*)((char*)edx + 4) = 0;
00406537                              continue;
00406524                          }
00406511                      }
00406511                      
0040653f                      if (*(uint32_t*)arg1 == 0xa)
0040653f                          continue;
0040653f                      else
0040653f                      {
00406588                          int32_t i;
00406588                          
00406588                          do
00406588                          {
00406545                              int32_t eax_8 = *(uint32_t*)arg1;
00406545                              
0040654a                              if (eax_8 == 0xd)
0040654a                                  break;
0040654a                              
00406553                              if (eax_8 == 0xffffffff)
00406553                                  break;
00406553                              
00406559                              int32_t* eax_9 = arg1[0xe];
0040655c                              int32_t ecx_7 = *(uint32_t*)eax_9;
00406563                              *(uint32_t*)eax_9 = ecx_7 - 1;
00406563                              
00406565                              if (ecx_7 <= 0)
0040657b                                  i = sub_40a6a0(arg1[0xe]);
00406565                              else
00406565                              {
00406567                                  void* ecx_8 = arg1[0xe];
0040656c                                  char* edx_7 = *(uint32_t*)((char*)ecx_8 + 4);
0040656f                                  (uint8_t)i = *(uint8_t*)edx_7;
00406571                                  edx = &edx_7[1];
00406572                                  *(uint32_t*)((char*)ecx_8 + 4) = edx;
00406565                              }
00406565                              
00406586                              *(uint32_t*)arg1 = i;
00406588                          } while (i != 0xa);
0040654a                          continue;
0040653f                      }
004064ad                      break;
004064ad                  }
0040684b                  case 4:
0040684b                  {
0040684b                      sub_4062a0(arg1, (char)*(uint32_t*)arg1);
00406850                      int32_t* eax_63 = arg1[0xe];
00406856                      int32_t ecx_30 = *(uint32_t*)eax_63;
0040685d                      *(uint32_t*)eax_63 = ecx_30 - 1;
0040685f                      int32_t eax_64;
0040685f                      
0040685f                      if (ecx_30 <= 0)
00406875                          eax_64 = sub_40a6a0(arg1[0xe]);
0040685f                      else
0040685f                      {
00406861                          void* ecx_31 = arg1[0xe];
00406866                          char* edx_36 = *(uint32_t*)((char*)ecx_31 + 4);
00406869                          (uint8_t)eax_64 = *(uint8_t*)edx_36;
0040686c                          *(uint32_t*)((char*)ecx_31 + 4) = &edx_36[1];
0040685f                      }
0040685f                      
00406883                      *(uint32_t*)arg1 = eax_64;
00406885                      void* eax_66;
00406885                      int32_t edx_38;
00406885                      eax_66 = sub_406ba0(arg1, U".");
00406885                      
0040688f                      if (eax_66)
0040688f                      {
00406897                          void* eax_67 = sub_406ba0(arg1, U".");
0040689f                          int32_t eax_68 = -(eax_67);
004068ae                          return -((eax_68 - eax_68)) + 0x116;
0040688f                      }
0040688f                      
004068b5                      BOOL eax_72;
004068b5                      
004068b5                      if (data_42d07c <= 1)
004068b5                      {
004068cd                          wchar16 (* eax_73)[0x21];
004068cd                          (uint8_t)eax_73 = (**(uint528_t**)&data_42ce70)[*(uint32_t*)arg1];
004068d0                          eax_72 = eax_73 & 4;
004068b5                      }
004068b5                      else
004068b5                      {
004068b7                          int32_t ecx_32 = *(uint32_t*)arg1;
004068b9                          int32_t var_14_22 = 4;
004068bc                          eax_72 = sub_4179df(eax_66, edx_38, ecx_32, ecx_32);
004068b5                      }
004068b5                      
004068d5                      if (!eax_72)
004068e0                          return 0x2e;
004068e0                      
004068e7                      sub_406c10(arg1, arg2);
004068f8                      return 0x11c;
0040684b                      break;
0040684b                  }
004066bb                  case 5:
004066bb                  {
004066bb                      int32_t* eax_31 = arg1[0xe];
004066be                      int32_t ecx_17 = *(uint32_t*)eax_31;
004066c5                      *(uint32_t*)eax_31 = ecx_17 - 1;
004066c7                      int32_t eax_32;
004066c7                      
004066c7                      if (ecx_17 <= 0)
004066dd                          eax_32 = sub_40a6a0(arg1[0xe]);
004066c7                      else
004066c7                      {
004066c9                          void* ecx_18 = arg1[0xe];
004066ce                          char* edx_17 = *(uint32_t*)((char*)ecx_18 + 4);
004066d1                          (uint8_t)eax_32 = *(uint8_t*)edx_17;
004066d4                          *(uint32_t*)((char*)ecx_18 + 4) = &edx_17[1];
004066c7                      }
004066c7                      
004066e8                      *(uint32_t*)arg1 = eax_32;
004066e8                      
004066ea                      if (eax_32 != 0x3d)
004066f5                          return 0x3c;
004066f5                      
004066f6                      int32_t* eax_35 = arg1[0xe];
004066f9                      int32_t ecx_19 = *(uint32_t*)eax_35;
00406700                      *(uint32_t*)eax_35 = ecx_19 - 1;
00406700                      
00406702                      if (ecx_19 <= 0)
00406702                      {
0040672a                          *(uint32_t*)arg1 = sub_40a6a0(arg1[0xe]);
00406735                          return 0x11a;
00406702                      }
00406702                      
00406704                      void* ecx_20 = arg1[0xe];
0040670a                      char* edx_20 = *(uint32_t*)((char*)ecx_20 + 4);
0040670d                      int32_t eax_36;
0040670d                      (uint8_t)eax_36 = *(uint8_t*)edx_20;
00406710                      *(uint32_t*)((char*)ecx_20 + 4) = &edx_20[1];
00406713                      *(uint32_t*)arg1 = eax_36;
0040671d                      return 0x11a;
004066bb                      break;
004066bb                  }
00406640                  case 6:
00406640                  {
00406640                  label_406640:
00406640                      int32_t* eax_21 = arg1[0xe];
00406643                      int32_t ecx_13 = *(uint32_t*)eax_21;
0040664a                      *(uint32_t*)eax_21 = ecx_13 - 1;
0040664c                      int32_t eax_22;
0040664c                      
0040664c                      if (ecx_13 <= 0)
00406662                          eax_22 = sub_40a6a0(arg1[0xe]);
0040664c                      else
0040664c                      {
0040664e                          void* ecx_14 = arg1[0xe];
00406653                          char* edx_11 = *(uint32_t*)((char*)ecx_14 + 4);
00406656                          (uint8_t)eax_22 = *(uint8_t*)edx_11;
00406659                          *(uint32_t*)((char*)ecx_14 + 4) = &edx_11[1];
0040664c                      }
0040664c                      
0040666d                      *(uint32_t*)arg1 = eax_22;
0040666d                      
0040666f                      if (eax_22 != 0x3d)
0040667a                          return 0x3d;
0040667a                      
0040667b                      int32_t* eax_25 = arg1[0xe];
0040667e                      int32_t ecx_15 = *(uint32_t*)eax_25;
00406685                      *(uint32_t*)eax_25 = ecx_15 - 1;
00406685                      
00406687                      if (ecx_15 <= 0)
00406687                      {
004066af                          *(uint32_t*)arg1 = sub_40a6a0(arg1[0xe]);
004066ba                          return 0x118;
00406687                      }
00406687                      
00406689                      void* ecx_16 = arg1[0xe];
0040668f                      char* edx_14 = *(uint32_t*)((char*)ecx_16 + 4);
00406692                      int32_t eax_26;
00406692                      (uint8_t)eax_26 = *(uint8_t*)edx_14;
00406695                      *(uint32_t*)((char*)ecx_16 + 4) = &edx_14[1];
00406698                      *(uint32_t*)arg1 = eax_26;
004066a2                      return 0x118;
00406640                      break;
00406640                  }
00406736                  case 7:
00406736                  {
00406736                      int32_t* eax_41 = arg1[0xe];
00406739                      int32_t ecx_21 = *(uint32_t*)eax_41;
00406740                      *(uint32_t*)eax_41 = ecx_21 - 1;
00406742                      int32_t eax_42;
00406742                      
00406742                      if (ecx_21 <= 0)
00406758                          eax_42 = sub_40a6a0(arg1[0xe]);
00406742                      else
00406742                      {
00406744                          void* ecx_22 = arg1[0xe];
00406749                          char* edx_23 = *(uint32_t*)((char*)ecx_22 + 4);
0040674c                          (uint8_t)eax_42 = *(uint8_t*)edx_23;
0040674f                          *(uint32_t*)((char*)ecx_22 + 4) = &edx_23[1];
00406742                      }
00406742                      
00406763                      *(uint32_t*)arg1 = eax_42;
00406763                      
00406765                      if (eax_42 != 0x3d)
00406770                          return 0x3e;
00406770                      
00406771                      int32_t* eax_45 = arg1[0xe];
00406774                      int32_t ecx_23 = *(uint32_t*)eax_45;
0040677b                      *(uint32_t*)eax_45 = ecx_23 - 1;
0040677b                      
0040677d                      if (ecx_23 <= 0)
0040677d                      {
004067a5                          *(uint32_t*)arg1 = sub_40a6a0(arg1[0xe]);
004067b0                          return 0x119;
0040677d                      }
0040677d                      
0040677f                      void* ecx_24 = arg1[0xe];
00406785                      char* edx_26 = *(uint32_t*)((char*)ecx_24 + 4);
00406788                      int32_t eax_46;
00406788                      (uint8_t)eax_46 = *(uint8_t*)edx_26;
0040678b                      *(uint32_t*)((char*)ecx_24 + 4) = &edx_26[1];
0040678e                      *(uint32_t*)arg1 = eax_46;
00406798                      return 0x119;
00406736                      break;
00406736                  }
004065f9                  case 8:
004065f9                  {
004065f9                      int32_t eax_18 = sub_406df0(arg1);
004065f9                      
00406603                      if (eax_18 >= 0)
00406603                      {
0040660c                          sub_406e90(arg1, arg2, eax_18);
0040661d                          return 0x11e;
00406603                      }
00406603                      
00406621                      if (eax_18 == 0xffffffff)
0040662c                          return 0x5b;
0040662c                      
00406638                      sub_4061e0(arg1, "invalid long string delimiter", 0x11e);
00406603                      goto label_406640;
004065f9                  }
004067b1                  case 9:
004067b1                  {
004067b1                      int32_t* eax_51 = arg1[0xe];
004067b4                      int32_t ecx_25 = *(uint32_t*)eax_51;
004067bb                      *(uint32_t*)eax_51 = ecx_25 - 1;
004067bd                      int32_t eax_52;
004067bd                      
004067bd                      if (ecx_25 <= 0)
004067d3                          eax_52 = sub_40a6a0(arg1[0xe]);
004067bd                      else
004067bd                      {
004067bf                          void* ecx_26 = arg1[0xe];
004067c4                          char* edx_29 = *(uint32_t*)((char*)ecx_26 + 4);
004067c7                          (uint8_t)eax_52 = *(uint8_t*)edx_29;
004067ca                          *(uint32_t*)((char*)ecx_26 + 4) = &edx_29[1];
004067bd                      }
004067bd                      
004067de                      *(uint32_t*)arg1 = eax_52;
004067de                      
004067e0                      if (eax_52 != 0x3d)
004067eb                          return 0x7e;
004067eb                      
004067ec                      int32_t* eax_55 = arg1[0xe];
004067ef                      int32_t ecx_27 = *(uint32_t*)eax_55;
004067f6                      *(uint32_t*)eax_55 = ecx_27 - 1;
004067f6                      
004067f8                      if (ecx_27 <= 0)
004067f8                      {
00406820                          *(uint32_t*)arg1 = sub_40a6a0(arg1[0xe]);
0040682b                          return 0x11b;
004067f8                      }
004067f8                      
004067fa                      void* ecx_28 = arg1[0xe];
00406800                      char* edx_32 = *(uint32_t*)((char*)ecx_28 + 4);
00406803                      int32_t eax_56;
00406803                      (uint8_t)eax_56 = *(uint8_t*)edx_32;
00406806                      *(uint32_t*)((char*)ecx_28 + 4) = &edx_32[1];
00406809                      *(uint32_t*)arg1 = eax_56;
00406813                      return 0x11b;
004067b1                      break;
004067b1                  }
0040649b              }
0040648d          }
0040648d          
00406595          if (data_42d07c <= 1)
00406595          {
004065a4              ecx_9 = data_42ce70;
004065aa              (uint8_t)eax_12 = (*(uint528_t*)ecx_9)[eax_12];
004065ad              eax_11 = eax_12 & 8;
00406595          }
00406595          else
00406595          {
00406597              int32_t var_14_7 = 8;
0040659a              eax_11 = sub_4179df(eax_12, edx, eax_12 + 1, eax_12);
00406595          }
00406595          
004065b2          if (!eax_11)
004065b2              break;
004065b2          
004065b8          int32_t* eax_13 = arg1[0xe];
004065bb          int32_t ecx_10 = *(uint32_t*)eax_13;
004065c2          *(uint32_t*)eax_13 = ecx_10 - 1;
004065c2          
004065c4          if (ecx_10 <= 0)
004065c4          {
004065df              int32_t eax_16;
004065df              eax_16 = sub_40a6a0(arg1[0xe]);
004065e7              *(uint32_t*)arg1 = eax_16;
004065c4          }
004065c4          else
004065c4          {
004065c6              void* ecx_11 = arg1[0xe];
004065cb              char* edx_9 = *(uint32_t*)((char*)ecx_11 + 4);
004065ce              int32_t eax_14;
004065ce              (uint8_t)eax_14 = *(uint8_t*)edx_9;
004065d0              edx = &edx_9[1];
004065d1              *(uint32_t*)((char*)ecx_11 + 4) = edx;
004065d4              *(uint32_t*)arg1 = eax_14;
004065c4          }
00406485      }
00406485      
00406909      BOOL eax_77;
00406909      wchar16 (* ecx_34)[0x21];
00406909      
00406909      if (data_42d07c <= 1)
00406909      {
0040691c          ecx_34 = data_42ce70;
00406922          int32_t eax_78;
00406922          (uint8_t)eax_78 = (*(uint528_t*)ecx_34)[*(uint32_t*)arg1];
00406925          eax_77 = eax_78 & 4;
00406909      }
00406909      else
00406909      {
0040690b          int32_t edx_40 = *(uint32_t*)arg1;
0040690d          int32_t var_14_24 = 4;
00406910          eax_77 = sub_4179df(eax_11, edx_40, ecx_9, edx_40);
00406909      }
00406909      
0040692a      if (eax_77)
0040692a      {
00406932          sub_406c10(arg1, arg2);
00406943          return 0x11c;
0040692a      }
0040692a      
0040694a      BOOL eax_81;
0040694a      
0040694a      if (data_42d07c <= 1)
0040694a      {
00406966          (uint16_t)eax_77 = (**(uint528_t**)&data_42ce70)[*(uint32_t*)arg1];
0040696a          eax_81 = eax_77 & 0x103;
0040694a      }
0040694a      else
0040694a      {
0040694c          int32_t eax_80 = *(uint32_t*)arg1;
0040694e          int32_t var_14_26 = 0x103;
00406954          eax_81 = sub_4179df(eax_80, edx, ecx_34, eax_80);
0040694a      }
0040694a      
00406971      if (!eax_81)
00406971      {
00406973          int32_t result = *(uint32_t*)arg1;
00406973          
00406978          if (result != 0x5f)
00406978          {
0040697a              int32_t* eax_82 = arg1[0xe];
0040697d              int32_t ecx_36 = *(uint32_t*)eax_82;
00406984              *(uint32_t*)eax_82 = ecx_36 - 1;
00406984              
00406986              if (ecx_36 <= 0)
00406986              {
004069ab                  *(uint32_t*)arg1 = sub_40a6a0(arg1[0xe]);
004069b3                  return result;
00406986              }
00406986              
00406988              void* ecx_37 = arg1[0xe];
0040698d              char* edx_44 = *(uint32_t*)((char*)ecx_37 + 4);
00406990              int32_t eax_83;
00406990              (uint8_t)eax_83 = *(uint8_t*)edx_44;
00406993              *(uint32_t*)((char*)ecx_37 + 4) = &edx_44[1];
00406996              *(uint32_t*)arg1 = eax_83;
0040699e              return result;
00406978          }
00406971      }
00406971      
004069b8      while (true)
004069b8      {
004069b8          sub_4062a0(arg1, (char)*(uint32_t*)arg1);
004069bd          int32_t* eax_88 = arg1[0xe];
004069c3          int32_t ecx_39 = *(uint32_t*)eax_88;
004069ca          *(uint32_t*)eax_88 = ecx_39 - 1;
004069cc          int32_t eax_89;
004069cc          void* edx_48;
004069cc          
004069cc          if (ecx_39 <= 0)
004069e2              eax_89 = sub_40a6a0(arg1[0xe]);
004069cc          else
004069cc          {
004069ce              void* ecx_40 = arg1[0xe];
004069d3              char* edx_47 = *(uint32_t*)((char*)ecx_40 + 4);
004069d6              (uint8_t)eax_89 = *(uint8_t*)edx_47;
004069d8              edx_48 = &edx_47[1];
004069d9              *(uint32_t*)((char*)ecx_40 + 4) = edx_48;
004069cc          }
004069cc          
004069ea          *(uint32_t*)arg1 = eax_89;
004069ec          int32_t ecx_41 = data_42d07c;
004069f4          BOOL eax_91;
004069f4          
004069f4          if (ecx_41 <= 1)
004069f4          {
00406a0c              (uint16_t)eax_89 = (**(uint528_t**)&data_42ce70)[eax_89];
00406a10              eax_91 = eax_89 & 0x107;
004069f4          }
004069f4          else
004069f4          {
004069f6              int32_t var_14_30 = 0x107;
004069fc              eax_91 = sub_4179df(eax_89, edx_48, ecx_41, eax_89);
004069f4          }
004069f4          
00406a17          if (!eax_91)
00406a17          {
00406a1c              if (*(uint32_t*)arg1 != 0x5f)
00406a1c                  break;
00406a17          }
004069b8      }
004069b8      
00406a1e      int32_t* eax_92 = arg1[0xf];
00406a29      void** eax_94 = sub_406340(arg1, *(uint32_t*)eax_92, eax_92[1]);
00406a2e      char ecx_43 = *(uint8_t*)((char*)eax_94 + 6);
00406a2e      
00406a36      if (ecx_43 > 0)
00406a48          return (uint32_t)ecx_43 + 0x100;
00406a48      
00406a50      *(uint32_t*)arg2 = eax_94;
00406a58      return 0x11d;
00406470  }

00406a59                                                                             8d 49 00                                       .I.
00406a5c  uint32_t jump_table_406a5c[0xb] = 
00406a5c  {
00406a5c      [0x0] =  0x004068f9
00406a60      [0x1] =  0x004064a2
00406a64      [0x2] =  0x0040682c
00406a68      [0x3] =  0x004064ad
00406a6c      [0x4] =  0x00406847
00406a70      [0x5] =  0x004066bb
00406a74      [0x6] =  0x00406640
00406a78      [0x7] =  0x00406736
00406a7c      [0x8] =  0x004065f8
00406a80      [0x9] =  0x004067b1
00406a84      [0xa] =  0x0040658f
00406a88  }
00406a88  uint8_t lookup_table_406a88[0x80] = 
00406a88  {
00406a88      [0x00] =  0x00
00406a89      [0x01] =  0x0a
00406a8a      [0x02] =  0x0a
00406a8b      [0x03] =  0x0a
00406a8c      [0x04] =  0x0a
00406a8d      [0x05] =  0x0a
00406a8e      [0x06] =  0x0a
00406a8f      [0x07] =  0x0a
00406a90      [0x08] =  0x0a
00406a91      [0x09] =  0x0a
00406a92      [0x0a] =  0x0a
00406a93      [0x0b] =  0x01
00406a94      [0x0c] =  0x0a
00406a95      [0x0d] =  0x0a
00406a96      [0x0e] =  0x01
00406a97      [0x0f] =  0x0a
00406a98      [0x10] =  0x0a
00406a99      [0x11] =  0x0a
00406a9a      [0x12] =  0x0a
00406a9b      [0x13] =  0x0a
00406a9c      [0x14] =  0x0a
00406a9d      [0x15] =  0x0a
00406a9e      [0x16] =  0x0a
00406a9f      [0x17] =  0x0a
00406aa0      [0x18] =  0x0a
00406aa1      [0x19] =  0x0a
00406aa2      [0x1a] =  0x0a
00406aa3      [0x1b] =  0x0a
00406aa4      [0x1c] =  0x0a
00406aa5      [0x1d] =  0x0a
00406aa6      [0x1e] =  0x0a
00406aa7      [0x1f] =  0x0a
00406aa8      [0x20] =  0x0a
00406aa9      [0x21] =  0x0a
00406aaa      [0x22] =  0x0a
00406aab      [0x23] =  0x02
00406aac      [0x24] =  0x0a
00406aad      [0x25] =  0x0a
00406aae      [0x26] =  0x0a
00406aaf      [0x27] =  0x0a
00406ab0      [0x28] =  0x02
00406ab1      [0x29] =  0x0a
00406ab2      [0x2a] =  0x0a
00406ab3      [0x2b] =  0x0a
00406ab4      [0x2c] =  0x0a
00406ab5      [0x2d] =  0x0a
00406ab6      [0x2e] =  0x03
00406ab7      [0x2f] =  0x04
00406ab8      [0x30] =  0x0a
00406ab9      [0x31] =  0x0a
00406aba      [0x32] =  0x0a
00406abb      [0x33] =  0x0a
00406abc      [0x34] =  0x0a
00406abd      [0x35] =  0x0a
00406abe      [0x36] =  0x0a
00406abf      [0x37] =  0x0a
00406ac0      [0x38] =  0x0a
00406ac1      [0x39] =  0x0a
00406ac2      [0x3a] =  0x0a
00406ac3      [0x3b] =  0x0a
00406ac4      [0x3c] =  0x0a
00406ac5      [0x3d] =  0x05
00406ac6      [0x3e] =  0x06
00406ac7      [0x3f] =  0x07
00406ac8      [0x40] =  0x0a
00406ac9      [0x41] =  0x0a
00406aca      [0x42] =  0x0a
00406acb      [0x43] =  0x0a
00406acc      [0x44] =  0x0a
00406acd      [0x45] =  0x0a
00406ace      [0x46] =  0x0a
00406acf      [0x47] =  0x0a
00406ad0      [0x48] =  0x0a
00406ad1      [0x49] =  0x0a
00406ad2      [0x4a] =  0x0a
00406ad3      [0x4b] =  0x0a
00406ad4      [0x4c] =  0x0a
00406ad5      [0x4d] =  0x0a
00406ad6      [0x4e] =  0x0a
00406ad7      [0x4f] =  0x0a
00406ad8      [0x50] =  0x0a
00406ad9      [0x51] =  0x0a
00406ada      [0x52] =  0x0a
00406adb      [0x53] =  0x0a
00406adc      [0x54] =  0x0a
00406add      [0x55] =  0x0a
00406ade      [0x56] =  0x0a
00406adf      [0x57] =  0x0a
00406ae0      [0x58] =  0x0a
00406ae1      [0x59] =  0x0a
00406ae2      [0x5a] =  0x0a
00406ae3      [0x5b] =  0x0a
00406ae4      [0x5c] =  0x08
00406ae5      [0x5d] =  0x0a
00406ae6      [0x5e] =  0x0a
00406ae7      [0x5f] =  0x0a
00406ae8      [0x60] =  0x0a
00406ae9      [0x61] =  0x0a
00406aea      [0x62] =  0x0a
00406aeb      [0x63] =  0x0a
00406aec      [0x64] =  0x0a
00406aed      [0x65] =  0x0a
00406aee      [0x66] =  0x0a
00406aef      [0x67] =  0x0a
00406af0      [0x68] =  0x0a
00406af1      [0x69] =  0x0a
00406af2      [0x6a] =  0x0a
00406af3      [0x6b] =  0x0a
00406af4      [0x6c] =  0x0a
00406af5      [0x6d] =  0x0a
00406af6      [0x6e] =  0x0a
00406af7      [0x6f] =  0x0a
00406af8      [0x70] =  0x0a
00406af9      [0x71] =  0x0a
00406afa      [0x72] =  0x0a
00406afb      [0x73] =  0x0a
00406afc      [0x74] =  0x0a
00406afd      [0x75] =  0x0a
00406afe      [0x76] =  0x0a
00406aff      [0x77] =  0x0a
00406b00      [0x78] =  0x0a
00406b01      [0x79] =  0x0a
00406b02      [0x7a] =  0x0a
00406b03      [0x7b] =  0x0a
00406b04      [0x7c] =  0x0a
00406b05      [0x7d] =  0x0a
00406b06      [0x7e] =  0x0a
00406b07      [0x7f] =  0x09
00406b08  }

00406b08                          90 90 90 90 90 90 90 90                                                          ........

00406b10    int32_t sub_406b10(int32_t* arg1)

00406b10  {
00406b16      int32_t* eax = arg1[0xe];
00406b19      int32_t edi = *(uint32_t*)arg1;
00406b1b      int32_t ecx = *(uint32_t*)eax;
00406b22      *(uint32_t*)eax = ecx - 1;
00406b24      int32_t eax_1;
00406b24      
00406b24      if (ecx <= 0)
00406b3a          eax_1 = sub_40a6a0(arg1[0xe]);
00406b24      else
00406b24      {
00406b26          void* ecx_1 = arg1[0xe];
00406b2b          char* edx_1 = *(uint32_t*)((char*)ecx_1 + 4);
00406b2e          (uint8_t)eax_1 = *(uint8_t*)edx_1;
00406b31          *(uint32_t*)((char*)ecx_1 + 4) = &edx_1[1];
00406b24      }
00406b24      
00406b45      *(uint32_t*)arg1 = eax_1;
00406b45      
00406b50      if ((eax_1 == 0xa || eax_1 == 0xd) && eax_1 != edi)
00406b50      {
00406b52          int32_t* eax_3 = arg1[0xe];
00406b55          int32_t ecx_2 = *(uint32_t*)eax_3;
00406b5c          *(uint32_t*)eax_3 = ecx_2 - 1;
00406b5e          int32_t eax_4;
00406b5e          
00406b5e          if (ecx_2 <= 0)
00406b74              eax_4 = sub_40a6a0(arg1[0xe]);
00406b5e          else
00406b5e          {
00406b60              void* ecx_3 = arg1[0xe];
00406b65              char* edx_4 = *(uint32_t*)((char*)ecx_3 + 4);
00406b68              (uint8_t)eax_4 = *(uint8_t*)edx_4;
00406b6b              *(uint32_t*)((char*)ecx_3 + 4) = &edx_4[1];
00406b5e          }
00406b5e          
00406b7c          *(uint32_t*)arg1 = eax_4;
00406b50      }
00406b50      
00406b81      int32_t result = arg1[1] + 1;
00406b84      arg1[1] = result;
00406b84      
00406b8c      if (result < 0x7ffffffd)
00406b9e          return result;
00406b9e      
00406b94      return sub_406320(arg1, "chunk has too many lines");
00406b10  }

00406b9f                                                                                               90                                 .

00406ba0    void* sub_406ba0(int32_t* arg1, char* arg2)

00406ba0  {
00406bad      void* result = sub_4172f0(arg2, (char)*(uint32_t*)arg1);
00406bad      
00406bb7      if (!result)
00406bba          return result;
00406bba      
00406bbf      sub_4062a0(arg1, (char)*(uint32_t*)arg1);
00406bc4      int32_t* eax_1 = arg1[0xe];
00406bca      int32_t ecx = *(uint32_t*)eax_1;
00406bd1      *(uint32_t*)eax_1 = ecx - 1;
00406bd1      
00406bd3      if (ecx <= 0)
00406bd3      {
00406bf8          *(uint32_t*)arg1 = sub_40a6a0(arg1[0xe]);
00406c00          return 1;
00406bd3      }
00406bd3      
00406bd5      void* ecx_1 = arg1[0xe];
00406bda      char* edx_2 = *(uint32_t*)((char*)ecx_1 + 4);
00406bdd      int32_t eax_2;
00406bdd      (uint8_t)eax_2 = *(uint8_t*)edx_2;
00406be0      *(uint32_t*)((char*)ecx_1 + 4) = &edx_2[1];
00406be3      *(uint32_t*)arg1 = eax_2;
00406beb      return 1;
00406ba0  }

00406c01     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00406c10    int32_t sub_406c10(int32_t* arg1, double* arg2)

00406c10  {
00406c1f      while (true)
00406c1f      {
00406c1f          sub_4062a0(arg1, (char)*(uint32_t*)arg1);
00406c24          int32_t* eax_2 = arg1[0xe];
00406c2a          int32_t ecx_1 = *(uint32_t*)eax_2;
00406c31          *(uint32_t*)eax_2 = ecx_1 - 1;
00406c33          int32_t eax_3;
00406c33          void* edx_3;
00406c33          
00406c33          if (ecx_1 <= 0)
00406c49              eax_3 = sub_40a6a0(arg1[0xe]);
00406c33          else
00406c33          {
00406c35              void* ecx_2 = arg1[0xe];
00406c3a              char* edx_2 = *(uint32_t*)((char*)ecx_2 + 4);
00406c3d              (uint8_t)eax_3 = *(uint8_t*)edx_2;
00406c3f              edx_3 = &edx_2[1];
00406c40              *(uint32_t*)((char*)ecx_2 + 4) = edx_3;
00406c33          }
00406c33          
00406c51          *(uint32_t*)arg1 = eax_3;
00406c53          int32_t ecx_3 = data_42d07c;
00406c5b          BOOL eax_5;
00406c5b          
00406c5b          if (ecx_3 <= 1)
00406c5b          {
00406c70              (uint8_t)eax_3 = (**(uint528_t**)&data_42ce70)[eax_3];
00406c73              eax_5 = eax_3 & 4;
00406c5b          }
00406c5b          else
00406c5b          {
00406c5d              int32_t var_c_3 = 4;
00406c60              eax_5 = sub_4179df(eax_3, edx_3, ecx_3, eax_3);
00406c5b          }
00406c5b          
00406c78          if (!eax_5)
00406c78          {
00406c7d              if (*(uint32_t*)arg1 != 0x2e)
00406c7d                  break;
00406c78          }
00406c1f      }
00406c1f      
00406c85      void* eax_6;
00406c85      void* ecx_5;
00406c85      eax_6 = sub_406ba0(arg1, "Ee");
00406c85      
00406c8f      if (eax_6)
00406c97          eax_6 = sub_406ba0(arg1, "+-");
00406c97      
00406ca5      while (true)
00406ca5      {
00406ca5          BOOL eax_7;
00406ca5          
00406ca5          if (data_42d07c <= 1)
00406ca5          {
00406cc1              int32_t eax_8;
00406cc1              (uint16_t)eax_8 = (**(uint528_t**)&data_42ce70)[*(uint32_t*)arg1];
00406cc5              eax_7 = eax_8 & 0x107;
00406ca5          }
00406ca5          else
00406ca5          {
00406ca7              int32_t edx_4 = *(uint32_t*)arg1;
00406ca9              int32_t var_c_4 = 0x107;
00406caf              eax_7 = sub_4179df(eax_6, edx_4, ecx_5, edx_4);
00406ca5          }
00406ca5          
00406cd1          if (!eax_7 && *(uint32_t*)arg1 != 0x5f)
00406cd1          {
00406d12              sub_4062a0(arg1, 0);
00406d1e              sub_406d50(arg1, 0x2e, arg1[0x11]);
00406d2e              int32_t result = sub_4083f0(*(uint32_t*)arg1[0xf], arg2);
00406d2e              
00406d38              if (result)
00406d46                  return result;
00406d46              
00406d3c              return sub_406d80(arg1, arg2);
00406cd1          }
00406cd1          
00406cd7          sub_4062a0(arg1, (char)*(uint32_t*)arg1);
00406cdc          int32_t* eax_9 = arg1[0xe];
00406ce2          int32_t ecx_7 = *(uint32_t*)eax_9;
00406ce9          *(uint32_t*)eax_9 = ecx_7 - 1;
00406ce9          
00406ceb          if (ecx_7 <= 0)
00406ceb          {
00406d03              eax_6 = sub_40a6a0(arg1[0xe]);
00406d0b              *(uint32_t*)arg1 = eax_6;
00406ceb          }
00406ceb          else
00406ceb          {
00406ced              ecx_5 = arg1[0xe];
00406cf2              char* edx_7 = *(uint32_t*)((char*)ecx_5 + 4);
00406cf5              (uint8_t)eax_6 = *(uint8_t*)edx_7;
00406cf8              *(uint32_t*)((char*)ecx_5 + 4) = &edx_7[1];
00406cfb              *(uint32_t*)arg1 = eax_6;
00406ceb          }
00406ca5      }
00406c10  }

00406d47                       90 90 90 90 90 90 90 90 90                                                         .........

00406d50    int32_t sub_406d50(void* arg1, char arg2, char arg3)

00406d50  {
00406d54      int32_t* ecx = *(uint32_t*)((char*)arg1 + 0x3c);
00406d57      int32_t eax = ecx[1];
00406d5a      char* ecx_1 = *(uint32_t*)ecx;
00406d5e      int32_t result = eax - 1;
00406d5e      
00406d61      if (eax)
00406d61      {
00406d63          int32_t edx;
00406d63          (uint8_t)edx = arg3;
00406d68          int32_t ebx;
00406d68          (uint8_t)ebx = arg2;
00406d7a          int32_t i;
00406d7a          
00406d7a          do
00406d7a          {
00406d70              if (ecx_1[result] == (uint8_t)ebx)
00406d72                  ecx_1[result] = (uint8_t)edx;
00406d72              
00406d75              i = result;
00406d77              result -= 1;
00406d7a          } while (i);
00406d61      }
00406d61      
00406d7e      return result;
00406d50  }

00406d7f                                                                                               90                                 .

00406d80    int32_t sub_406d80(void* arg1, double* arg2)

00406d80  {
00406d81      int32_t* eax = sub_417a54();
00406d86      void* esi = arg1;
00406d8f      (uint8_t)arg1 = *(uint8_t*)((char*)esi + 0x44);
00406d93      char eax_1;
00406d93      
00406d93      if (!eax)
00406d9c          eax_1 = 0x2e;
00406d93      else
00406d97          eax_1 = **(uint8_t**)eax;
00406d97      
00406da1      *(uint8_t*)((char*)esi + 0x44) = eax_1;
00406dab      sub_406d50(esi, (uint8_t)arg1, eax_1);
00406dbb      int32_t result = sub_4083f0(**(uint32_t**)((char*)esi + 0x3c), arg2);
00406dbb      
00406dc5      if (result)
00406de7          return result;
00406de7      
00406dce      sub_406d50(esi, *(uint8_t*)((char*)esi + 0x44), 0x2e);
00406dde      return sub_4061e0(esi, "malformed number", 0x11c);
00406d80  }

00406de8                          90 90 90 90 90 90 90 90                                                          ........

00406df0    int32_t sub_406df0(int32_t* arg1)

00406df0  {
00406df7      int32_t result = 0;
00406df9      int32_t ebp = *(uint32_t*)arg1;
00406dfd      sub_4062a0(arg1, (uint8_t)ebp);
00406e02      int32_t* eax = arg1[0xe];
00406e08      int32_t ecx = *(uint32_t*)eax;
00406e0f      *(uint32_t*)eax = ecx - 1;
00406e11      int32_t eax_1;
00406e11      
00406e11      if (ecx <= 0)
00406e27          eax_1 = sub_40a6a0(arg1[0xe]);
00406e11      else
00406e11      {
00406e13          void* ecx_1 = arg1[0xe];
00406e18          char* edx_1 = *(uint32_t*)((char*)ecx_1 + 4);
00406e1b          (uint8_t)eax_1 = *(uint8_t*)edx_1;
00406e1e          *(uint32_t*)((char*)ecx_1 + 4) = &edx_1[1];
00406e11      }
00406e11      
00406e32      *(uint32_t*)arg1 = eax_1;
00406e32      
00406e34      if (eax_1 == 0x3d)
00406e34      {
00406e72          int32_t i;
00406e72          
00406e72          do
00406e72          {
00406e3a              sub_4062a0(arg1, (char)*(uint32_t*)arg1);
00406e3f              int32_t* eax_3 = arg1[0xe];
00406e45              int32_t ecx_3 = *(uint32_t*)eax_3;
00406e4c              *(uint32_t*)eax_3 = ecx_3 - 1;
00406e4c              
00406e4e              if (ecx_3 <= 0)
00406e64                  i = sub_40a6a0(arg1[0xe]);
00406e4e              else
00406e4e              {
00406e50                  void* ecx_4 = arg1[0xe];
00406e55                  char* edx_4 = *(uint32_t*)((char*)ecx_4 + 4);
00406e58                  (uint8_t)i = *(uint8_t*)edx_4;
00406e5b                  *(uint32_t*)((char*)ecx_4 + 4) = &edx_4[1];
00406e4e              }
00406e4e              
00406e6c              result += 1;
00406e70              *(uint32_t*)arg1 = i;
00406e72          } while (i == 0x3d);
00406e34      }
00406e34      
00406e76      if (*(uint32_t*)arg1 != ebp)
00406e86          return 0xffffffff - result;
00406e86      
00406e7d      return result;
00406df0  }

00406e87                       90 90 90 90 90 90 90 90 90                                                         .........

00406e90    void** sub_406e90(int32_t* arg1, void*** arg2, int32_t arg3)

00406e90  {
00406e9b      sub_4062a0(arg1, (char)*(uint32_t*)arg1);
00406ea0      int32_t* eax_1 = arg1[0xe];
00406ea6      int32_t ecx = *(uint32_t*)eax_1;
00406ead      *(uint32_t*)eax_1 = ecx - 1;
00406eaf      int32_t eax_2;
00406eaf      
00406eaf      if (ecx <= 0)
00406ec5          eax_2 = sub_40a6a0(arg1[0xe]);
00406eaf      else
00406eaf      {
00406eb1          void* ecx_1 = arg1[0xe];
00406eb6          char* edx_1 = *(uint32_t*)((char*)ecx_1 + 4);
00406eb9          (uint8_t)eax_2 = *(uint8_t*)edx_1;
00406ebc          *(uint32_t*)((char*)ecx_1 + 4) = &edx_1[1];
00406eaf      }
00406eaf      
00406ed0      *(uint32_t*)arg1 = eax_2;
00406ed0      
00406ed7      if (eax_2 == 0xa || eax_2 == 0xd)
00406eda          sub_406b10(arg1);
00406eda      
00406eea      while (true)
00406eea      {
00406eea          int32_t eax_4 = *(uint32_t*)arg1;
00406eea          
00406ef2          if (eax_4 + 1 <= 0x5e)
00406ef2          {
00406efa              int32_t edx_3;
00406efa              (uint8_t)edx_3 = lookup_table_407088[1 + eax_4];
00406efa              
00406f00              switch (edx_3)
00406f00              {
00406f09                  case 0:
00406f09                  {
00406f09                      char* eax_5 = "unfinished long string";
00406f09                      
00406f0e                      if (!arg2)
00406f10                          eax_5 = "unfinished long comment";
00406f10                      
00406f1c                      sub_4061e0(arg1, eax_5, 0x11f);
00406f24                      continue;
00406f09                  }
00406f9d                  case 1:
00406f9d                  {
00406f9d                      sub_4062a0(arg1, 0xa);
00406fa3                      sub_406b10(arg1);
00406fa3                      
00406fad                      if (arg2)
00406fad                          continue;
00406fad                      else
00406fad                      {
00406fb6                          *(uint32_t*)(arg1[0xf] + 4) = arg2;
00406fb9                          continue;
00406fad                      }
00406f9d                      break;
00406f9d                  }
00406f27                  case 2:
00406f27                  {
00406f31                      if (sub_406df0(arg1) != arg3)
00406f31                          continue;
00406f31                      else
00406f31                      {
00406f37                          sub_4062a0(arg1, (char)*(uint32_t*)arg1);
00406f3c                          int32_t* eax_8 = arg1[0xe];
00406f42                          int32_t ecx_3 = *(uint32_t*)eax_8;
00406f49                          *(uint32_t*)eax_8 = ecx_3 - 1;
00406f4b                          int32_t eax_9;
00406f4b                          
00406f4b                          if (ecx_3 <= 0)
00406f61                              eax_9 = sub_40a6a0(arg1[0xe]);
00406f4b                          else
00406f4b                          {
00406f4d                              void* ecx_4 = arg1[0xe];
00406f52                              char* edx_5 = *(uint32_t*)((char*)ecx_4 + 4);
00406f55                              (uint8_t)eax_9 = *(uint8_t*)edx_5;
00406f58                              *(uint32_t*)((char*)ecx_4 + 4) = &edx_5[1];
00406f4b                          }
00406f4b                          
00406f6b                          *(uint32_t*)arg1 = eax_9;
00406f6b                          
00406f6d                          if (arg3)
00406f6d                              continue;
00406f6d                          else
00406f6d                          {
00406f7b                              sub_4061e0(arg1, "nesting of [[...]] is deprecated", 0x5b);
00406f83                              continue;
00406f6d                          }
00406f31                      }
00406f27                      break;
00406f27                  }
00406f89                  case 3:
00406f89                  {
00406f93                      if (sub_406df0(arg1) == arg3)
00406f93                          break;
00406f93                      
00406f93                      continue;
00406f89                  }
00406f00              }
00406ef2          }
00406ef2          
00406fc0          if (!arg2)
00406fc0          {
00407002              int32_t* eax_16 = arg1[0xe];
00407005              int32_t ecx_8 = *(uint32_t*)eax_16;
0040700c              *(uint32_t*)eax_16 = ecx_8 - 1;
0040700c              
0040700e              if (ecx_8 > 0)
0040700e              {
00406fda              label_406fda:
00406fda                  void* ecx_7 = arg1[0xe];
00406fdf                  char* edx_8 = *(uint32_t*)((char*)ecx_7 + 4);
00406fe2                  int32_t eax_13;
00406fe2                  (uint8_t)eax_13 = *(uint8_t*)edx_8;
00406fe5                  *(uint32_t*)((char*)ecx_7 + 4) = &edx_8[1];
00406fe8                  *(uint32_t*)arg1 = eax_13;
00406fea                  continue;
0040700e              }
00406fc0          }
00406fc0          else
00406fc0          {
00406fc4              sub_4062a0(arg1, (uint8_t)eax_4);
00406fc9              int32_t* eax_12 = arg1[0xe];
00406fcf              int32_t ecx_6 = *(uint32_t*)eax_12;
00406fd6              *(uint32_t*)eax_12 = ecx_6 - 1;
00406fd6              
00406fd8              if (ecx_6 > 0)
00406fd8                  goto label_406fda;
00406fc0          }
00406fc0          
00406ffb          *(uint32_t*)arg1 = sub_40a6a0(arg1[0xe]);
00406eea      }
00406eea      
00407016      sub_4062a0(arg1, (char)*(uint32_t*)arg1);
0040701b      int32_t* eax_17 = arg1[0xe];
00407021      int32_t ecx_10 = *(uint32_t*)eax_17;
00407028      *(uint32_t*)eax_17 = ecx_10 - 1;
0040702a      void** result;
0040702a      
0040702a      if (ecx_10 <= 0)
00407040          result = sub_40a6a0(arg1[0xe]);
0040702a      else
0040702a      {
0040702c          void* ecx_11 = arg1[0xe];
00407031          char* edx_12 = *(uint32_t*)((char*)ecx_11 + 4);
00407034          (uint8_t)result = *(uint8_t*)edx_12;
00407037          *(uint32_t*)((char*)ecx_11 + 4) = &edx_12[1];
0040702a      }
0040702a      
0040704a      *(uint32_t*)arg1 = result;
0040704a      
0040704c      if (arg2)
0040704c      {
0040704e          int32_t* eax_19 = arg1[0xf];
00407066          result =
00407066              sub_406340(arg1, *(uint32_t*)eax_19 + arg3 + 2, eax_19[1] - arg3 * 2 - 4);
0040706e          *(uint32_t*)arg2 = result;
0040704c      }
0040704c      
00407073      return result;
00406e90  }

00407074  uint32_t jump_table_407074[0x5] = 
00407074  {
00407074      [0x0] =  0x00406f07
00407078      [0x1] =  0x00406f9a
0040707c      [0x2] =  0x00406f26
00407080      [0x3] =  0x00406f88
00407084      [0x4] =  0x00406fbe
00407088  }
00407088  uint8_t lookup_table_407088[0x5f] = 
00407088  {
00407088      [0x00] =  0x00
00407089      [0x01] =  0x04
0040708a      [0x02] =  0x04
0040708b      [0x03] =  0x04
0040708c      [0x04] =  0x04
0040708d      [0x05] =  0x04
0040708e      [0x06] =  0x04
0040708f      [0x07] =  0x04
00407090      [0x08] =  0x04
00407091      [0x09] =  0x04
00407092      [0x0a] =  0x04
00407093      [0x0b] =  0x01
00407094      [0x0c] =  0x04
00407095      [0x0d] =  0x04
00407096      [0x0e] =  0x01
00407097      [0x0f] =  0x04
00407098      [0x10] =  0x04
00407099      [0x11] =  0x04
0040709a      [0x12] =  0x04
0040709b      [0x13] =  0x04
0040709c      [0x14] =  0x04
0040709d      [0x15] =  0x04
0040709e      [0x16] =  0x04
0040709f      [0x17] =  0x04
004070a0      [0x18] =  0x04
004070a1      [0x19] =  0x04
004070a2      [0x1a] =  0x04
004070a3      [0x1b] =  0x04
004070a4      [0x1c] =  0x04
004070a5      [0x1d] =  0x04
004070a6      [0x1e] =  0x04
004070a7      [0x1f] =  0x04
004070a8      [0x20] =  0x04
004070a9      [0x21] =  0x04
004070aa      [0x22] =  0x04
004070ab      [0x23] =  0x04
004070ac      [0x24] =  0x04
004070ad      [0x25] =  0x04
004070ae      [0x26] =  0x04
004070af      [0x27] =  0x04
004070b0      [0x28] =  0x04
004070b1      [0x29] =  0x04
004070b2      [0x2a] =  0x04
004070b3      [0x2b] =  0x04
004070b4      [0x2c] =  0x04
004070b5      [0x2d] =  0x04
004070b6      [0x2e] =  0x04
004070b7      [0x2f] =  0x04
004070b8      [0x30] =  0x04
004070b9      [0x31] =  0x04
004070ba      [0x32] =  0x04
004070bb      [0x33] =  0x04
004070bc      [0x34] =  0x04
004070bd      [0x35] =  0x04
004070be      [0x36] =  0x04
004070bf      [0x37] =  0x04
004070c0      [0x38] =  0x04
004070c1      [0x39] =  0x04
004070c2      [0x3a] =  0x04
004070c3      [0x3b] =  0x04
004070c4      [0x3c] =  0x04
004070c5      [0x3d] =  0x04
004070c6      [0x3e] =  0x04
004070c7      [0x3f] =  0x04
004070c8      [0x40] =  0x04
004070c9      [0x41] =  0x04
004070ca      [0x42] =  0x04
004070cb      [0x43] =  0x04
004070cc      [0x44] =  0x04
004070cd      [0x45] =  0x04
004070ce      [0x46] =  0x04
004070cf      [0x47] =  0x04
004070d0      [0x48] =  0x04
004070d1      [0x49] =  0x04
004070d2      [0x4a] =  0x04
004070d3      [0x4b] =  0x04
004070d4      [0x4c] =  0x04
004070d5      [0x4d] =  0x04
004070d6      [0x4e] =  0x04
004070d7      [0x4f] =  0x04
004070d8      [0x50] =  0x04
004070d9      [0x51] =  0x04
004070da      [0x52] =  0x04
004070db      [0x53] =  0x04
004070dc      [0x54] =  0x04
004070dd      [0x55] =  0x04
004070de      [0x56] =  0x04
004070df      [0x57] =  0x04
004070e0      [0x58] =  0x04
004070e1      [0x59] =  0x04
004070e2      [0x5a] =  0x04
004070e3      [0x5b] =  0x04
004070e4      [0x5c] =  0x02
004070e5      [0x5d] =  0x04
004070e6      [0x5e] =  0x03
004070e7  }

004070e7                       90 90 90 90 90 90 90 90 90                                                         .........

004070f0    void** sub_4070f0(int32_t* arg1, int32_t arg2, void*** arg3)

004070f0  {
004070f9      sub_4062a0(arg1, (char)*(uint32_t*)arg1);
004070fe      int32_t* eax_1 = arg1[0xe];
00407104      int32_t ecx = *(uint32_t*)eax_1;
0040710b      *(uint32_t*)eax_1 = ecx - 1;
0040710d      int32_t eax_2;
0040710d      
0040710d      if (ecx <= 0)
00407123          eax_2 = sub_40a6a0(arg1[0xe]);
0040710d      else
0040710d      {
0040710f          void* ecx_1 = arg1[0xe];
00407114          char* edx_1 = *(uint32_t*)((char*)ecx_1 + 4);
00407117          (uint8_t)eax_2 = *(uint8_t*)edx_1;
0040711a          *(uint32_t*)((char*)ecx_1 + 4) = &edx_1[1];
0040710d      }
0040710d      
0040712f      *(uint32_t*)arg1 = eax_2;
0040712f      
00407133      if (eax_2 != arg2)
00407133      {
00407316          do
00407316          {
00407141              int32_t eax_7 = *(uint32_t*)arg1;
00407141              
00407149              if (eax_7 + 1 > 0x5d)
00407149                  goto label_407206;
00407149              
00407151              int32_t edx_3;
00407151              (uint8_t)edx_3 = lookup_table_407388[1 + eax_7];
00407151              
00407157              switch (edx_3)
00407157              {
00407169                  case 0:
00407169                  {
00407169                      sub_4061e0(arg1, "unfinished string", 0x11f);
00407169                      break;
00407169                  }
00407181                  case 1:
00407181                  {
00407181                      sub_4061e0(arg1, "unfinished string", 0x11e);
00407181                      break;
00407181                  }
0040718e                  case 2:
0040718e                  {
0040718e                      int32_t* eax_4 = arg1[0xe];
00407191                      int32_t ecx_4 = *(uint32_t*)eax_4;
00407198                      *(uint32_t*)eax_4 = ecx_4 - 1;
0040719a                      int32_t eax_5;
0040719a                      void* edx_6;
0040719a                      
0040719a                      if (ecx_4 <= 0)
004071b0                          eax_5 = sub_40a6a0(arg1[0xe]);
0040719a                      else
0040719a                      {
0040719c                          void* ecx_5 = arg1[0xe];
004071a1                          char* edx_5 = *(uint32_t*)((char*)ecx_5 + 4);
004071a4                          (uint8_t)eax_5 = *(uint8_t*)edx_5;
004071a6                          edx_6 = &edx_5[1];
004071a7                          *(uint32_t*)((char*)ecx_5 + 4) = edx_6;
0040719a                      }
0040719a                      
004071bb                      *(uint32_t*)arg1 = eax_5;
004071c0                      char var_14_2;
004071c0                      
004071c0                      if (eax_5 + 1 > 0x77)
004071c0                      {
00407225                      label_407225:
00407225                          BOOL eax_8;
00407225                          
00407225                          if (data_42d07c <= 1)
00407225                          {
0040723a                              (uint8_t)eax_5 = (**(uint528_t**)&data_42ce70)[eax_5];
0040723d                              eax_8 = eax_5 & 4;
00407225                          }
00407225                          else
00407225                          {
00407227                              int32_t var_14_3 = 4;
0040722a                              eax_8 = sub_4179df(eax_5, edx_6, eax_5 + 1, eax_5);
00407225                          }
00407225                          
00407242                          if (!eax_8)
00407242                          {
00407246                              var_14_2 = (char)*(uint32_t*)arg1;
00407246                              goto label_407248;
00407242                          }
00407242                          
00407275                          int32_t ebp_1 = 0;
00407277                          int32_t edi_1 = 0;
004072d7                          BOOL j;
004072d7                          
004072d7                          do
004072d7                          {
0040727b                              int32_t* eax_11 = arg1[0xe];
00407281                              edi_1 = *(uint32_t*)arg1 + edi_1 * 0xa - 0x30;
00407285                              int32_t ecx_11 = *(uint32_t*)eax_11;
0040728c                              *(uint32_t*)eax_11 = ecx_11 - 1;
0040728e                              int32_t eax_12;
0040728e                              void* ecx_12;
0040728e                              void* edx_14;
0040728e                              
0040728e                              if (ecx_11 <= 0)
004072a4                                  eax_12 = sub_40a6a0(arg1[0xe]);
0040728e                              else
0040728e                              {
00407290                                  ecx_12 = arg1[0xe];
00407295                                  char* edx_13 = *(uint32_t*)((char*)ecx_12 + 4);
00407298                                  (uint8_t)eax_12 = *(uint8_t*)edx_13;
0040729a                                  edx_14 = &edx_13[1];
0040729b                                  *(uint32_t*)((char*)ecx_12 + 4) = edx_14;
0040728e                              }
0040728e                              
004072ac                              ebp_1 += 1;
004072ad                              *(uint32_t*)arg1 = eax_12;
004072ad                              
004072b2                              if (ebp_1 >= 3)
004072b2                                  break;
004072b2                              
004072ba                              if (data_42d07c <= 1)
004072ba                              {
004072cf                                  (uint8_t)eax_12 = (**(uint528_t**)&data_42ce70)[eax_12];
004072d2                                  j = eax_12 & 4;
004072ba                              }
004072ba                              else
004072ba                              {
004072bc                                  int32_t var_14_5 = 4;
004072bf                                  j = sub_4179df(eax_12, edx_14, ecx_12, eax_12);
004072ba                              }
004072d7                          } while (j);
004072d7                          
004072df                          if (edi_1 > 0xff)
004072ec                              sub_4061e0(arg1, "escape sequence too large", 0x11e);
004072ec                          
004072f6                          sub_4062a0(arg1, (uint8_t)edi_1);
004071c0                      }
004071c0                      else
004071c0                      {
004071c4                          (uint8_t)edx_6 = lookup_table_407410[1 + eax_5];
004071c4                          
004071ca                          switch (edx_6)
004071ca                          {
0040720c                              case 1:
0040720c                              {
0040720c                                  sub_4062a0(arg1, 0xa);
00407212                                  sub_406b10(arg1);
0040720c                                  break;
0040720c                              }
004071d6                              case 2:
004071d6                              {
004071d6                                  var_14_2 = 7;
004071d7                                  goto label_407248;
004071d6                              }
004071de                              case 3:
004071de                              {
004071de                                  var_14_2 = 8;
004071df                                  goto label_407248;
004071de                              }
004071e6                              case 4:
004071e6                              {
004071e6                                  var_14_2 = 0xc;
004071e7                                  goto label_407248;
004071e6                              }
004071ee                              case 5:
004071ee                              {
004071ee                                  var_14_2 = 0xa;
004071ef                                  goto label_407248;
004071ee                              }
004071f6                              case 6:
004071f6                              {
004071f6                                  var_14_2 = 0xd;
004071f7                                  goto label_407248;
004071f6                              }
004071fe                              case 7:
004071fe                              {
004071fe                                  var_14_2 = 9;
004071ff                                  goto label_407248;
004071fe                              }
00407201                              case 8:
00407201                              {
00407201                                  eax_7 = 0xb;
00407206                              label_407206:
00407206                                  var_14_2 = (uint8_t)eax_7;
00407248                              label_407248:
00407248                                  sub_4062a0(arg1, var_14_2);
0040724d                                  int32_t* eax_9 = arg1[0xe];
00407253                                  int32_t ecx_8 = *(uint32_t*)eax_9;
0040725a                                  *(uint32_t*)eax_9 = ecx_8 - 1;
0040725c                                  int32_t eax_10;
0040725c                                  
0040725c                                  if (ecx_8 <= 0)
00407304                                      eax_10 = sub_40a6a0(arg1[0xe]);
0040725c                                  else
0040725c                                  {
00407262                                      void* ecx_9 = arg1[0xe];
00407267                                      char* edx_9 = *(uint32_t*)((char*)ecx_9 + 4);
0040726a                                      (uint8_t)eax_10 = *(uint8_t*)edx_9;
0040726d                                      *(uint32_t*)((char*)ecx_9 + 4) = &edx_9[1];
0040725c                                  }
0040725c                                  
0040730c                                  *(uint32_t*)arg1 = eax_10;
00407201                                  break;
00407201                              }
004071ca                              case 9:
004071ca                              {
004071ca                                  goto label_407225;
004071ca                              }
004071ca                          }
004071c0                      }
0040718e                      break;
0040718e                  }
00407157                  case 3:
00407157                  {
00407157                      goto label_407206;
00407157                  }
00407157              }
00407316          } while (*(uint32_t*)arg1 != arg2);
00407133      }
00407133      
00407323      sub_4062a0(arg1, (char)*(uint32_t*)arg1);
00407328      int32_t* eax_16 = arg1[0xe];
0040732e      int32_t ecx_15 = *(uint32_t*)eax_16;
00407335      *(uint32_t*)eax_16 = ecx_15 - 1;
00407337      int32_t eax_17;
00407337      
00407337      if (ecx_15 <= 0)
0040734d          eax_17 = sub_40a6a0(arg1[0xe]);
00407337      else
00407337      {
00407339          void* ecx_16 = arg1[0xe];
0040733e          char* edx_17 = *(uint32_t*)((char*)ecx_16 + 4);
00407341          (uint8_t)eax_17 = *(uint8_t*)edx_17;
00407344          *(uint32_t*)((char*)ecx_16 + 4) = &edx_17[1];
00407337      }
00407337      
00407355      *(uint32_t*)arg1 = eax_17;
00407357      int32_t* eax_19 = arg1[0xf];
00407366      void** result = sub_406340(arg1, *(uint32_t*)eax_19 + 1, eax_19[1] - 2);
00407372      *(uint32_t*)arg3 = result;
00407375      return result;
004070f0  }

00407376                                                                    8b ff                                                ..
00407378  uint32_t jump_table_407378[0x4] = 
00407378  {
00407378      [0x0] =  0x0040715e
0040737c      [0x1] =  0x00407176
00407380      [0x2] =  0x0040718e
00407384      [0x3] =  0x00407206
00407388  }
00407388  uint8_t lookup_table_407388[0x5e] = 
00407388  {
00407388      [0x00] =  0x00
00407389      [0x01] =  0x03
0040738a      [0x02] =  0x03
0040738b      [0x03] =  0x03
0040738c      [0x04] =  0x03
0040738d      [0x05] =  0x03
0040738e      [0x06] =  0x03
0040738f      [0x07] =  0x03
00407390      [0x08] =  0x03
00407391      [0x09] =  0x03
00407392      [0x0a] =  0x03
00407393      [0x0b] =  0x01
00407394      [0x0c] =  0x03
00407395      [0x0d] =  0x03
00407396      [0x0e] =  0x01
00407397      [0x0f] =  0x03
00407398      [0x10] =  0x03
00407399      [0x11] =  0x03
0040739a      [0x12] =  0x03
0040739b      [0x13] =  0x03
0040739c      [0x14] =  0x03
0040739d      [0x15] =  0x03
0040739e      [0x16] =  0x03
0040739f      [0x17] =  0x03
004073a0      [0x18] =  0x03
004073a1      [0x19] =  0x03
004073a2      [0x1a] =  0x03
004073a3      [0x1b] =  0x03
004073a4      [0x1c] =  0x03
004073a5      [0x1d] =  0x03
004073a6      [0x1e] =  0x03
004073a7      [0x1f] =  0x03
004073a8      [0x20] =  0x03
004073a9      [0x21] =  0x03
004073aa      [0x22] =  0x03
004073ab      [0x23] =  0x03
004073ac      [0x24] =  0x03
004073ad      [0x25] =  0x03
004073ae      [0x26] =  0x03
004073af      [0x27] =  0x03
004073b0      [0x28] =  0x03
004073b1      [0x29] =  0x03
004073b2      [0x2a] =  0x03
004073b3      [0x2b] =  0x03
004073b4      [0x2c] =  0x03
004073b5      [0x2d] =  0x03
004073b6      [0x2e] =  0x03
004073b7      [0x2f] =  0x03
004073b8      [0x30] =  0x03
004073b9      [0x31] =  0x03
004073ba      [0x32] =  0x03
004073bb      [0x33] =  0x03
004073bc      [0x34] =  0x03
004073bd      [0x35] =  0x03
004073be      [0x36] =  0x03
004073bf      [0x37] =  0x03
004073c0      [0x38] =  0x03
004073c1      [0x39] =  0x03
004073c2      [0x3a] =  0x03
004073c3      [0x3b] =  0x03
004073c4      [0x3c] =  0x03
004073c5      [0x3d] =  0x03
004073c6      [0x3e] =  0x03
004073c7      [0x3f] =  0x03
004073c8      [0x40] =  0x03
004073c9      [0x41] =  0x03
004073ca      [0x42] =  0x03
004073cb      [0x43] =  0x03
004073cc      [0x44] =  0x03
004073cd      [0x45] =  0x03
004073ce      [0x46] =  0x03
004073cf      [0x47] =  0x03
004073d0      [0x48] =  0x03
004073d1      [0x49] =  0x03
004073d2      [0x4a] =  0x03
004073d3      [0x4b] =  0x03
004073d4      [0x4c] =  0x03
004073d5      [0x4d] =  0x03
004073d6      [0x4e] =  0x03
004073d7      [0x4f] =  0x03
004073d8      [0x50] =  0x03
004073d9      [0x51] =  0x03
004073da      [0x52] =  0x03
004073db      [0x53] =  0x03
004073dc      [0x54] =  0x03
004073dd      [0x55] =  0x03
004073de      [0x56] =  0x03
004073df      [0x57] =  0x03
004073e0      [0x58] =  0x03
004073e1      [0x59] =  0x03
004073e2      [0x5a] =  0x03
004073e3      [0x5b] =  0x03
004073e4      [0x5c] =  0x03
004073e5      [0x5d] =  0x02
004073e6  }

004073e6                    8b ff                                                                                ..
004073e8  uint32_t jump_table_4073e8[0xa] = 
004073e8  {
004073e8      [0x0] =  0x0040730e
004073ec      [0x1] =  0x00407209
004073f0      [0x2] =  0x004071d1
004073f4      [0x3] =  0x004071d9
004073f8      [0x4] =  0x004071e1
004073fc      [0x5] =  0x004071e9
00407400      [0x6] =  0x004071f1
00407404      [0x7] =  0x004071f9
00407408      [0x8] =  0x00407201
0040740c      [0x9] =  0x0040721f
00407410  }
00407410  uint8_t lookup_table_407410[0x78] = 
00407410  {
00407410      [0x00] =  0x00
00407411      [0x01] =  0x09
00407412      [0x02] =  0x09
00407413      [0x03] =  0x09
00407414      [0x04] =  0x09
00407415      [0x05] =  0x09
00407416      [0x06] =  0x09
00407417      [0x07] =  0x09
00407418      [0x08] =  0x09
00407419      [0x09] =  0x09
0040741a      [0x0a] =  0x09
0040741b      [0x0b] =  0x01
0040741c      [0x0c] =  0x09
0040741d      [0x0d] =  0x09
0040741e      [0x0e] =  0x01
0040741f      [0x0f] =  0x09
00407420      [0x10] =  0x09
00407421      [0x11] =  0x09
00407422      [0x12] =  0x09
00407423      [0x13] =  0x09
00407424      [0x14] =  0x09
00407425      [0x15] =  0x09
00407426      [0x16] =  0x09
00407427      [0x17] =  0x09
00407428      [0x18] =  0x09
00407429      [0x19] =  0x09
0040742a      [0x1a] =  0x09
0040742b      [0x1b] =  0x09
0040742c      [0x1c] =  0x09
0040742d      [0x1d] =  0x09
0040742e      [0x1e] =  0x09
0040742f      [0x1f] =  0x09
00407430      [0x20] =  0x09
00407431      [0x21] =  0x09
00407432      [0x22] =  0x09
00407433      [0x23] =  0x09
00407434      [0x24] =  0x09
00407435      [0x25] =  0x09
00407436      [0x26] =  0x09
00407437      [0x27] =  0x09
00407438      [0x28] =  0x09
00407439      [0x29] =  0x09
0040743a      [0x2a] =  0x09
0040743b      [0x2b] =  0x09
0040743c      [0x2c] =  0x09
0040743d      [0x2d] =  0x09
0040743e      [0x2e] =  0x09
0040743f      [0x2f] =  0x09
00407440      [0x30] =  0x09
00407441      [0x31] =  0x09
00407442      [0x32] =  0x09
00407443      [0x33] =  0x09
00407444      [0x34] =  0x09
00407445      [0x35] =  0x09
00407446      [0x36] =  0x09
00407447      [0x37] =  0x09
00407448      [0x38] =  0x09
00407449      [0x39] =  0x09
0040744a      [0x3a] =  0x09
0040744b      [0x3b] =  0x09
0040744c      [0x3c] =  0x09
0040744d      [0x3d] =  0x09
0040744e      [0x3e] =  0x09
0040744f      [0x3f] =  0x09
00407450      [0x40] =  0x09
00407451      [0x41] =  0x09
00407452      [0x42] =  0x09
00407453      [0x43] =  0x09
00407454      [0x44] =  0x09
00407455      [0x45] =  0x09
00407456      [0x46] =  0x09
00407457      [0x47] =  0x09
00407458      [0x48] =  0x09
00407459      [0x49] =  0x09
0040745a      [0x4a] =  0x09
0040745b      [0x4b] =  0x09
0040745c      [0x4c] =  0x09
0040745d      [0x4d] =  0x09
0040745e      [0x4e] =  0x09
0040745f      [0x4f] =  0x09
00407460      [0x50] =  0x09
00407461      [0x51] =  0x09
00407462      [0x52] =  0x09
00407463      [0x53] =  0x09
00407464      [0x54] =  0x09
00407465      [0x55] =  0x09
00407466      [0x56] =  0x09
00407467      [0x57] =  0x09
00407468      [0x58] =  0x09
00407469      [0x59] =  0x09
0040746a      [0x5a] =  0x09
0040746b      [0x5b] =  0x09
0040746c      [0x5c] =  0x09
0040746d      [0x5d] =  0x09
0040746e      [0x5e] =  0x09
0040746f      [0x5f] =  0x09
00407470      [0x60] =  0x09
00407471      [0x61] =  0x09
00407472      [0x62] =  0x02
00407473      [0x63] =  0x03
00407474      [0x64] =  0x09
00407475      [0x65] =  0x09
00407476      [0x66] =  0x09
00407477      [0x67] =  0x04
00407478      [0x68] =  0x09
00407479      [0x69] =  0x09
0040747a      [0x6a] =  0x09
0040747b      [0x6b] =  0x09
0040747c      [0x6c] =  0x09
0040747d      [0x6d] =  0x09
0040747e      [0x6e] =  0x09
0040747f      [0x6f] =  0x05
00407480      [0x70] =  0x09
00407481      [0x71] =  0x09
00407482      [0x72] =  0x09
00407483      [0x73] =  0x06
00407484      [0x74] =  0x09
00407485      [0x75] =  0x07
00407486      [0x76] =  0x09
00407487      [0x77] =  0x08
00407488  }

00407488                          90 90 90 90 90 90 90 90                                                          ........

00407490    int32_t sub_407490(int32_t* arg1)

00407490  {
0040749a      int32_t result = sub_406470(arg1, &arg1[0xa]);
004074a2      arg1[8] = result;
004074a6      return result;
00407490  }

004074a7                       90 90 90 90 90 90 90 90 90                                                         .........

004074b0    void* sub_4074b0(void* arg1)

004074b0  {
004074fe      void* result;
004074fe      
004074fe      for (int32_t i = 0xbc; i < 0x100; )
004074fe      {
004074c4          char* edx_1 = *(uint32_t*)(&data_428208 + i);
004074c7          int32_t j = 0xffffffff;
004074ca          char* edi_1 = edx_1;
004074ca          
004074ce          while (j)
004074ce          {
004074ce              bool cond:0_1 = 0 != *(uint8_t*)edi_1;
004074ce              edi_1 = &edi_1[1];
004074ce              j -= 1;
004074ce              
004074ce              if (!cond:0_1)
004074ce                  break;
004074ce          }
004074ce          
004074de          i += 4;
004074e4          *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + i - 4) =
004074e4              sub_405f60(arg1, edx_1, ~j - 1);
004074eb          result = *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + i - 4);
004074ef          int32_t edx_2;
004074ef          (uint8_t)edx_2 = *(uint8_t*)((char*)result + 5);
004074f2          (uint8_t)edx_2 |= 0x20;
004074fb          *(uint8_t*)((char*)result + 5) = (uint8_t)edx_2;
004074fe      }
004074fe      
00407504      return result;
004074b0  }

00407505                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00407510    void* sub_407510(void* arg1, char arg2, void* arg3)

00407510  {
0040751b      void* result = sub_407c70(arg1, arg3);
0040751b      
00407528      if (*(uint32_t*)((char*)result + 8))
0040753d          return result;
0040753d      
0040752e      (uint8_t)result = *(uint8_t*)((char*)arg1 + 6);
00407535      (uint8_t)result |= 1 << arg2;
00407537      *(uint8_t*)((char*)arg1 + 6) = (uint8_t)result;
0040753a      return nullptr;
00407510  }

0040753e                                                                                            90 90                                ..

00407540    void* sub_407540(void* arg1, int32_t* arg2, int32_t arg3)

00407540  {
00407549      int32_t eax = arg2[2];
00407551      void* eax_1;
00407551      
00407551      if (eax == 5)
0040756d          eax_1 = *(uint32_t*)(*(uint32_t*)arg2 + 8);
00407551      else if (eax == 7)
00407566          eax_1 = *(uint32_t*)(*(uint32_t*)arg2 + 8);
00407556      else
0040755b          eax_1 = *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + (eax << 2) + 0x98);
0040755b      
00407572      if (!eax_1)
00407594          return &data_428330;
00407594      
0040758d      return sub_407c70(eax_1, 
0040758d          *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + (arg3 << 2) + 0xbc));
00407540  }

00407595                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

004075a0    int32_t sub_4075a0(void* arg1, void* arg2, int32_t arg3)

004075a0  {
004075a6      int32_t* esi = arg3;
004075b2      int32_t eax = sub_407680(arg1, arg2, esi);
004075b7      int32_t ecx = *(uint32_t*)((char*)arg2 + 0x1c);
004075bd      int32_t eax_1 = eax + 1;
004075bd      
004075c0      if (eax_1 < ecx)
004075c0      {
004075ca          int32_t* edx_3 = (eax_1 << 4) + *(uint32_t*)((char*)arg2 + 0xc) + 8;
004075ca          
004075d9          do
004075d9          {
004075d1              if (*(uint32_t*)edx_3)
004075d1              {
00407611                  esi[2] = 3;
00407623                  *(uint64_t*)esi = (double)(long double)(eax_1 + 1);
00407629                  int32_t* eax_5 = (eax_1 << 4) + *(uint32_t*)((char*)arg2 + 0xc);
0040762d                  esi[4] = *(uint32_t*)eax_5;
00407633                  esi[5] = eax_5[1];
00407639                  esi[6] = eax_5[2];
00407643                  return 1;
004075d1              }
004075d1              
004075d3              eax_1 += 1;
004075d4              edx_3 = &edx_3[4];
004075d9          } while (eax_1 < ecx);
004075c0      }
004075c0      
004075db      int32_t eax_2 = eax_1 - ecx;
004075dd      (uint8_t)ecx = *(uint8_t*)((char*)arg2 + 7);
004075e5      int32_t edx_4 = 1 << (uint8_t)ecx;
004075e5      
004075e9      if (eax_2 >= edx_4)
0040767f          return 0;
0040767f      
004075ef      int32_t ecx_1 = *(uint32_t*)((char*)arg2 + 0x10);
004075f7      int32_t* ebx_4 = (eax_2 << 5) + ecx_1 + 8;
004075f7      
00407606      do
00407606      {
004075fe          if (*(uint32_t*)ebx_4)
004075fe          {
00407644              int32_t eax_7 = eax_2 << 5;
0040764b              *(uint32_t*)esi = *(uint32_t*)(ecx_1 + eax_7 + 0x10);
00407651              esi[1] = *(uint32_t*)(ecx_1 + eax_7 + 0x14);
00407658              esi[2] = *(uint32_t*)(ecx_1 + eax_7 + 0x18);
0040765e              int32_t* ecx_7 = *(uint32_t*)((char*)arg2 + 0x10) + eax_7;
00407663              esi[4] = *(uint32_t*)ecx_7;
00407669              esi[5] = ecx_7[1];
0040766f              esi[6] = ecx_7[2];
00407679              return 1;
004075fe          }
004075fe          
00407600          eax_2 += 1;
00407601          ebx_4 = &ebx_4[8];
00407606      } while (eax_2 < edx_4);
00407606      
0040760d      return 0;
004075a0  }


00407680    int32_t sub_407680(void* arg1, void* arg2, int32_t* arg3)

00407680  {
0040768d      if (!arg3[2])
00407696          return 0xffffffff;
00407696      
00407698      int32_t eax_2;
00407698      int80_t st0;
00407698      st0 = sub_407820(arg3);
00407698      
004076ab      if (eax_2 > 0 && eax_2 <= *(uint32_t*)((char*)arg2 + 0x1c))
004076b2          return eax_2 - 1;
004076b2      
004076ba      void* esi = sub_407730(arg2, arg3);
004076bd      double* ebx = (char*)esi + 0x10;
004076bd      
004076cb      if (!sub_408390(ebx, arg3))
004076cb      {
004076df          while (*(uint32_t*)((char*)esi + 0x18) != 0xb || arg3[2] < 4
004076df              || *(uint32_t*)ebx != *(uint32_t*)arg3)
004076df          {
004076e1              esi = *(uint32_t*)((char*)esi + 0x1c);
004076e1              
004076e6              if (!esi)
004076e6              {
00407717                  sub_40bb80(arg1, "invalid key to 'next'");
00407725                  return 0;
004076e6              }
004076e6              
004076e8              ebx = (char*)esi + 0x10;
004076e8              
004076f7              if (sub_408390(ebx, arg3))
004076f7                  break;
004076df          }
004076cb      }
004076cb      
0040770c      return (((char*)esi - *(uint32_t*)((char*)arg2 + 0x10)) >> 5)
0040770c          + *(uint32_t*)((char*)arg2 + 0x1c);
00407680  }

00407726                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00407730    int32_t sub_407730(void* arg1, int32_t* arg2)

00407730  {
0040773f      switch (arg2[2] - 1)
0040773f      {
0040779b          case 0:
0040779b          {
0040779b              return ((((1 << *(uint8_t*)((char*)arg1 + 7)) - 1) & *(uint32_t*)arg2) << 5)
0040779b                  + *(uint32_t*)((char*)arg1 + 0x10);
0040779b              break;
0040779b          }
0040774f          case 2:
0040774f          {
0040774f              int32_t var_c = arg2[1];
0040775c              return sub_4077e0(arg1, *(uint32_t*)arg2);
0040774f              break;
0040774f          }
0040777d          case 3:
0040777d          {
0040777d              return ((((1 << *(uint8_t*)((char*)arg1 + 7)) - 1)
0040777d                  & *(uint32_t*)(*(uint32_t*)arg2 + 8)) << 5)
0040777d                  + *(uint32_t*)((char*)arg1 + 0x10);
0040777d              break;
0040777d          }
0040773f      }
0040773f      
004077c0      return ((COMBINE(0, *(uint32_t*)arg2)
004077c0          % (((1 << *(uint8_t*)((char*)arg1 + 7)) - 1) | 1)) << 5)
004077c0          + *(uint32_t*)((char*)arg1 + 0x10);
00407730  }

004077c1     8d 49 00                                                                                       .I.
004077c4  uint32_t jump_table_4077c4[0x4] = 
004077c4  {
004077c4      [0x0] =  0x0040777e
004077c8      [0x1] =  0x0040779c
004077cc      [0x2] =  0x00407746
004077d0      [0x3] =  0x0040775d
004077d4  }

004077d4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

004077e0    int32_t sub_4077e0(void* arg1, double arg2)

004077e0  {
004077f7      arg2 = (double)((long double)arg2 + (long double)1.0);
00407805      int32_t ecx;
00407805      (uint8_t)ecx = *(uint8_t*)((char*)arg1 + 7);
0040781c      return ((COMBINE(0, *(uint32_t*)((char*)arg2)[4] + (uint32_t)arg2)
0040781c          % (((1 << (uint8_t)ecx) - 1) | 1)) << 5) + *(uint32_t*)((char*)arg1 + 0x10);
004077e0  }

0040781d                                                                                         90 90 90                               ...

00407820    void sub_407820(int32_t arg1)

00407820  {
00407820      double* eax = arg1;
00407820      
0040782b      if (eax[1] != 3)
0040782b          return;
0040782b      
0040782d      long double x87_r7_1 = (long double)*(uint64_t*)eax;
00407843      long double x87_r6_3 =
00407843          (long double)(int32_t)(double)(x87_r7_1 + (long double)6755399441055744.0);
00407847      x87_r6_3 - x87_r7_1;
00407849      (uint16_t)eax = (x87_r6_3 < x87_r7_1 ? 1 : 0) << 8
00407849          | (FCMP_UO(x87_r6_3, x87_r7_1) ? 1 : 0) << 0xa
00407849          | (x87_r6_3 == x87_r7_1 ? 1 : 0) << 0xe | 0x3800;
00407820  }

0040785f                                                                                               90                                 .

00407860    void* sub_407860(void* arg1, int32_t arg2, int32_t arg3)

00407860  {
0040786b      int32_t eax;
0040786b      
0040786b      if (*(uint32_t*)(arg2 + 0x10) != 0x428308)
00407879          eax = 1 << *(uint8_t*)(arg2 + 7);
0040786b      else
0040786d          eax = 0;
0040786d      
0040788f      return sub_407890(arg1, arg2, arg3, eax);
00407860  }


00407890    void* sub_407890(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00407890  {
00407894      int32_t ebx = arg3;
0040789a      int32_t esi = arg2;
004078a1      int32_t ebp = *(uint32_t*)(esi + 0x1c);
004078a4      char eax = *(uint8_t*)(esi + 7);
004078a7      int32_t edi = *(uint32_t*)(esi + 0x10);
004078b0      int32_t var_8 = edi;
004078b0      
004078b4      if (ebx > ebp)
004078bd          sub_4079f0(arg1, esi, ebx);
004078bd      
004078d0      sub_407a70(arg1, esi, arg4);
004078d0      
004078da      if (ebx < ebp)
004078da      {
004078e2          *(uint32_t*)(esi + 0x1c) = ebx;
004078e5          int32_t eax_3 = ebx << 4;
004078e8          arg4 = eax_3;
004078ec          arg2 = eax_3;
004078ec          
00407936          do
00407936          {
004078f0              void* ecx_2 = *(uint32_t*)(esi + 0xc);
004078f7              int32_t* edi_1 = (char*)ecx_2 + arg2;
004078f7              
00407900              if (*(uint32_t*)((char*)ecx_2 + arg2 + 8))
00407900              {
0040790c                  void* eax_5 = sub_408150(arg1, esi, ebx + 1);
00407916                  *(uint32_t*)eax_5 = *(uint32_t*)edi_1;
0040791b                  *(uint32_t*)((char*)eax_5 + 4) = edi_1[1];
00407921                  *(uint32_t*)((char*)eax_5 + 8) = edi_1[2];
00407924                  eax_3 = arg4;
00407900              }
00407900              
0040792c              ebx += 1;
00407932              arg2 += 0x10;
00407936          } while (ebx < ebp);
00407936          
00407943          int32_t eax_7;
00407943          
00407943          if (arg3 + 1 > 0xfffffff)
00407962              eax_7 = sub_404ce0(arg1);
00407943          else
00407953              eax_7 = sub_404d00(arg1, *(uint32_t*)(esi + 0xc), ebp << 4, eax_3);
00407953          
0040796a          edi = var_8;
0040796e          *(uint32_t*)(esi + 0xc) = eax_7;
004078da      }
004078da      
0040797a      int32_t ebx_1 = 1 << eax;
0040797c      void* result = ebx_1 - 1;
0040797c      
00407981      if (result >= 0)
00407981      {
00407985          void* i_1 = (char*)result + 1;
0040798b          int32_t* edi_2 = (result << 5) + edi + 8;
004079ba          void* i;
004079ba          
004079ba          do
004079ba          {
00407992              if (*(uint32_t*)edi_2)
00407992              {
0040799e                  result = sub_407d70(arg1, esi, &edi_2[2]);
004079a9                  *(uint32_t*)result = edi_2[-2];
004079ae                  *(uint32_t*)((char*)result + 4) = edi_2[-1];
004079b3                  *(uint32_t*)((char*)result + 8) = *(uint32_t*)edi_2;
00407992              }
00407992              
004079b6              edi_2 -= 0x20;
004079b9              i = i_1;
004079b9              i_1 -= 1;
004079ba          } while (i != 1);
004079bc          edi = var_8;
00407981      }
00407981      
004079c6      if (edi == 0x428308)
004079e3          return result;
004079e3      
004079d4      return sub_404d00(arg1, edi, ebx_1 << 5, 0);
00407890  }

004079e4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

004079f0    int32_t sub_4079f0(void* arg1, void* arg2, int32_t arg3)

004079f0  {
00407a02      int32_t eax_2;
00407a02      
00407a02      if (arg3 + 1 > 0xfffffff)
00407a29          eax_2 = sub_404ce0(arg1);
00407a02      else
00407a1a          eax_2 = sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 0xc), 
00407a1a              *(uint32_t*)((char*)arg2 + 0x1c) << 4, arg3 << 4);
00407a1a      
00407a31      int32_t edx_3 = *(uint32_t*)((char*)arg2 + 0x1c);
00407a34      *(uint32_t*)((char*)arg2 + 0xc) = eax_2;
00407a34      
00407a39      if (edx_3 >= arg3)
00407a39      {
00407a5b          *(uint32_t*)((char*)arg2 + 0x1c) = arg3;
00407a60          return eax_2;
00407a39      }
00407a39      
00407a3f      int32_t eax_4 = edx_3 << 4;
00407a42      int32_t i_1 = arg3 - edx_3;
00407a52      int32_t i;
00407a52      
00407a52      do
00407a52      {
00407a4a          eax_4 += 0x10;
00407a4d          i = i_1;
00407a4d          i_1 -= 1;
00407a4e          *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0xc) + eax_4 - 8) = 0;
00407a52      } while (i != 1);
00407a54      *(uint32_t*)((char*)arg2 + 0x1c) = arg3;
00407a5a      return eax_4;
004079f0  }

00407a61     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00407a70    int32_t sub_407a70(void* arg1, void* arg2, int32_t arg3)

00407a70  {
00407a7c      if (!arg3)
00407a7c      {
00407a87          *(uint32_t*)((char*)arg2 + 0x10) = 0x428308;
00407a8e          int32_t eax = *(uint32_t*)((char*)arg2 + 0x10);
00407a94          *(uint32_t*)((char*)arg2 + 0x14) = (arg3 << 5) + eax;
00407a98          *(uint8_t*)((char*)arg2 + 7) = 0;
00407a9d          return eax;
00407a7c      }
00407a7c      
00407aae      int32_t ebx_1 = sub_408360(arg3 - 1) + 1;
00407aae      
00407ab2      if (ebx_1 > 0x1a)
00407aba          sub_40bb80(arg1, "table overflow");
00407aba      
00407ac9      int32_t i_2 = 1 << (uint8_t)ebx_1;
00407ad3      int32_t eax_3;
00407ad3      
00407ad3      if (i_2 + 1 > 0x7ffffff)
00407ae9          eax_3 = sub_404ce0(arg1);
00407ad3      else
00407ade          eax_3 = sub_404d00(arg1, 0, 0, i_2 << 5);
00407ade      
00407af7      *(uint32_t*)((char*)arg2 + 0x10) = eax_3;
00407af7      
00407afa      if (i_2 > 0)
00407afa      {
00407afc          int32_t ecx_3 = 0;
00407afe          int32_t i_1 = i_2;
00407b13          int32_t i;
00407b13          
00407b13          do
00407b13          {
00407b00              void* eax_4 = *(uint32_t*)((char*)arg2 + 0x10);
00407b03              *(uint32_t*)((char*)eax_4 + ecx_3 + 0x1c) = 0;
00407b07              void* eax_5 = (char*)eax_4 + ecx_3;
00407b09              ecx_3 += 0x20;
00407b0c              i = i_1;
00407b0c              i_1 -= 1;
00407b0d              *(uint32_t*)((char*)eax_5 + 0x18) = 0;
00407b10              *(uint32_t*)((char*)eax_5 + 8) = 0;
00407b13          } while (i != 1);
00407afa      }
00407afa      
00407b15      int32_t eax_6 = *(uint32_t*)((char*)arg2 + 0x10);
00407b1e      *(uint8_t*)((char*)arg2 + 7) = (uint8_t)ebx_1;
00407b21      *(uint32_t*)((char*)arg2 + 0x14) = (i_2 << 5) + eax_6;
00407b27      return eax_6;
00407a70  }

00407b28                          90 90 90 90 90 90 90 90                                                          ........

00407b30    int32_t* sub_407b30(void* arg1, int32_t arg2, int32_t arg3)

00407b30  {
00407b3e      int32_t* result = sub_404d00(arg1, 0, 0, 0x20);
00407b49      sub_404bc0(arg1, result, 5);
00407b52      result[2] = 0;
00407b58      *(uint8_t*)((char*)result + 6) = 0xff;
00407b5c      result[3] = 0;
00407b5f      result[7] = 0;
00407b62      *(uint8_t*)((char*)result + 7) = 0;
00407b65      result[4] = 0x428308;
00407b6c      sub_4079f0(arg1, result, arg2);
00407b78      sub_407a70(arg1, result, arg3);
00407b85      return result;
00407b30  }

00407b86                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00407b90    int32_t sub_407b90(void* arg1, void* arg2)

00407b90  {
00407b9a      int32_t eax = *(uint32_t*)((char*)arg2 + 0x10);
00407b9a      
00407ba2      if (eax != 0x428308)
00407bb6          sub_404d00(arg1, eax, 1 << *(uint8_t*)((char*)arg2 + 7) << 5, 0);
00407bb6      
00407bcc      sub_404d00(arg1, *(uint32_t*)((char*)arg2 + 0xc), 
00407bcc          *(uint32_t*)((char*)arg2 + 0x1c) << 4, 0);
00407be1      return sub_404d00(arg1, arg2, 0x20, 0);
00407b90  }

00407be2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00407bf0    void* sub_407bf0(void* arg1, int32_t arg2)

00407bf0  {
00407c08      if (arg2 - 1 < *(uint32_t*)((char*)arg1 + 0x1c))
00407c18          return *(uint32_t*)((char*)arg1 + 0xc) + (arg2 << 4) - 0x10;
00407c18      
00407c1c      double var_10 = (double)(long double)arg2;
00407c28      int32_t var_1c = *(uint32_t*)((char*)var_10)[4];
00407c33      void* i = sub_4077e0(arg1, (uint32_t)var_10);
00407c33      
00407c52      do
00407c52      {
00407c3d          if (*(uint32_t*)((char*)i + 0x18) == 3)
00407c3d          {
00407c3f              long double x87_r7_1 = (long double)*(uint64_t*)((char*)i + 0x10);
00407c42              long double temp0_1 = (long double)var_10;
00407c42              x87_r7_1 - temp0_1;
00407c46              void* eax_4;
00407c46              (uint16_t)eax_4 = (x87_r7_1 < temp0_1 ? 1 : 0) << 8
00407c46                  | (FCMP_UO(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
00407c46                  | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe;
00407c46              
00407c4b              if (*(uint8_t*)((char*)eax_4)[1] & 0x40)
00407c5c                  return i;
00407c3d          }
00407c3d          
00407c4d          i = *(uint32_t*)((char*)i + 0x1c);
00407c52      } while (i);
00407c52      
00407c66      return &data_428330;
00407bf0  }

00407c67                       90 90 90 90 90 90 90 90 90                                                         .........

00407c70    void* const sub_407c70(void* arg1, void* arg2)

00407c70  {
00407c8f      void* const i = ((((1 << *(uint8_t*)((char*)arg1 + 7)) - 1)
00407c8f          & *(uint32_t*)((char*)arg2 + 8)) << 5) + *(uint32_t*)((char*)arg1 + 0x10);
00407c8f      
00407ca5      do
00407ca5      {
00407c9e          if (*(uint32_t*)((char*)i + 0x18) == 4 && *(uint32_t*)((char*)i + 0x10) == arg2)
00407cad              return i;
00407cad          
00407ca0          i = *(uint32_t*)((char*)i + 0x1c);
00407ca5      } while (i);
00407ca5      
00407ca7      return &data_428330;
00407c70  }

00407cae                                            90 90                                                                ..

00407cb0    void* sub_407cb0(void* arg1, int32_t arg2)

00407cb0  {
00407cb5      double* edi = arg2;
00407cb9      int32_t eax = edi[1];
00407cb9      
00407cbf      if (!eax)
00407d60          return &data_428330;
00407d60      
00407cc8      if (eax == 3)
00407cc8      {
00407ceb          int32_t var_8_1 = (int32_t)(double)((long double)*(uint64_t*)edi
00407ceb              + (long double)6755399441055744.0);
00407cf7          long double x87_r7_3 = (long double)var_8_1;
00407cfb          long double temp2_1 = (long double)*(uint64_t*)edi;
00407cfb          x87_r7_3 - temp2_1;
00407cfd          int32_t eax_2;
00407cfd          (uint16_t)eax_2 = (x87_r7_3 < temp2_1 ? 1 : 0) << 8
00407cfd              | (FCMP_UO(x87_r7_3, temp2_1) ? 1 : 0) << 0xa
00407cfd              | (x87_r7_3 == temp2_1 ? 1 : 0) << 0xe;
00407cfd          
00407d02          if (*(uint8_t*)((char*)eax_2)[1] & 0x40)
00407d17              return sub_407bf0(arg1, var_8_1);
00407cc8      }
00407cc8      else if (eax == 4)
00407ce2          return sub_407c70(arg1, *(uint32_t*)edi);
00407ce2      
00407d23      void* result = sub_407730(arg1, edi);
00407d23      
00407d34      if (sub_408390((char*)result + 0x10, edi))
00407d55          return result;
00407d55      
00407d36      while (true)
00407d36      {
00407d36          result = *(uint32_t*)((char*)result + 0x1c);
00407d36          
00407d3b          if (!result)
00407d60              return &data_428330;
00407d60          
00407d4c          if (sub_408390((char*)result + 0x10, edi))
00407d55              return result;
00407d36      }
00407cb0  }

00407d61     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00407d70    void* sub_407d70(void* arg1, int32_t arg2, int32_t* arg3)

00407d70  {
00407d7c      void* result = sub_407cb0(arg2, arg3);
00407d89      *(uint8_t*)(arg2 + 6) = 0;
00407d89      
00407d8d      if (result != &data_428330)
00407db7          return result;
00407db7      
00407d99      if (!arg3[2])
00407da1          sub_40bb80(arg1, "table index is nil");
00407da1      
00407dac      return sub_407dc0(arg1, arg2, arg3);
00407d70  }

00407db8                                                                          90 90 90 90 90 90 90 90                          ........

00407dc0    void* sub_407dc0(void* arg1, int32_t arg2, int32_t* arg3)

00407dc0  {
00407dc7      int32_t esi = arg2;
00407dd3      void* result = sub_407730(esi, arg3);
00407dd3      
00407de5      if (*(uint32_t*)((char*)result + 8) || result == 0x428308)
00407de5      {
00407de8          void* result_1 = sub_408110(esi);
00407de8          
00407df4          if (!result_1)
00407df4          {
00407dfa              int32_t* var_14_2 = arg3;
00407dfd              sub_407ea0(arg1, esi);
00407e11              return sub_407d70(arg1, esi, arg3);
00407df4          }
00407df4          
00407e17          void* i_1 = sub_407730(esi, (char*)result + 0x10);
00407e17          
00407e21          if (i_1 == result)
00407e21          {
00407e50              *(uint32_t*)((char*)result_1 + 0x1c) = *(uint32_t*)((char*)result + 0x1c);
00407e53              *(uint32_t*)((char*)result + 0x1c) = result_1;
00407e56              result = result_1;
00407e21          }
00407e21          else
00407e21          {
00407e28              for (void* i = *(uint32_t*)((char*)i_1 + 0x1c); i != result; 
00407e28                      i = *(uint32_t*)((char*)i_1 + 0x1c))
00407e2a                  i_1 = i;
00407e2a              
00407e3a              *(uint32_t*)((char*)i_1 + 0x1c) = result_1;
00407e3f              __builtin_memcpy(result_1, result, 0x20);
00407e41              esi = arg2;
00407e45              *(uint32_t*)((char*)result + 0x1c) = 0;
00407e48              *(uint32_t*)((char*)result + 8) = 0;
00407e21          }
00407de5      }
00407de5      
00407e5b      *(uint32_t*)((char*)result + 0x10) = *(uint32_t*)arg3;
00407e61      *(uint32_t*)((char*)result + 0x14) = arg3[1];
00407e67      *(uint32_t*)((char*)result + 0x18) = arg3[2];
00407e67      
00407e82      if (arg3[2] >= 4 && *(uint8_t*)(*(uint32_t*)arg3 + 5) & 3 && *(uint8_t*)(esi + 5) & 4)
00407e8a          sub_404ba0(arg1, esi);
00407e8a      
00407e98      return result;
00407dc0  }

00407e99                                                                             90 90 90 90 90 90 90                           .......

00407ea0    void* sub_407ea0(void* arg1, int32_t arg2)

00407ea0  {
00407eb0      void var_6c;
00407eb0      __builtin_memset(&var_6c, 0, 0x6c);
00407eb2      int32_t arg_8;
00407eb2      int32_t edi = arg_8;
00407ebc      int32_t eax = sub_408000(edi, &var_6c);
00407ecc      int32_t* var_80 = &arg_8;
00407ecd      void* var_84 = &var_6c;
00407ecf      arg_8 = eax;
00407ee4      int32_t esi_1 = eax + sub_408090(edi, var_84, var_80);
00407eec      int32_t eax_2 = sub_407fc0(arg2, &var_6c);
00407f05      int32_t* var_94 = &arg_8;
00407f06      int32_t* var_98 = &var_6c;
00407f07      arg_8 += eax_2;
00407f0e      int32_t eax_3 = sub_407f40(var_98, var_94);
00407f35      return sub_407890(arg1, edi, arg_8, esi_1 - eax_3 + 1);
00407ea0  }

00407f36                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00407f40    int32_t sub_407f40(int32_t* arg1, int32_t* arg2)

00407f40  {
00407f40      int32_t* eax_12 = arg2;
00407f48      int32_t i = *(uint32_t*)eax_12;
00407f4a      int32_t result_1 = 0;
00407f4c      int32_t result = 0;
00407f4e      int32_t ebx = 0;
00407f50      int32_t ecx = 1;
00407f50      
00407f57      if (i > 0)
00407f57      {
00407f96          int32_t eax_9;
00407f96          int32_t edx_3;
00407f96          
00407f96          do
00407f96          {
00407f65              int32_t eax_1 = *(uint32_t*)arg1;
00407f65              
00407f69              if (eax_1 > 0)
00407f69              {
00407f6b                  result_1 += eax_1;
00407f6f                  int32_t eax_3;
00407f6f                  int32_t edx_2;
00407f6f                  edx_2 = HIGHD((int64_t)ecx);
00407f6f                  eax_3 = LOWD((int64_t)ecx);
00407f6f                  
00407f76                  if (result_1 > (eax_3 - edx_2) >> 1)
00407f76                  {
00407f78                      ebx = ecx;
00407f7a                      result = result_1;
00407f76                  }
00407f69              }
00407f69              
00407f7e              if (result_1 == i)
00407f7e              {
00407fad                  *(uint32_t*)arg2 = ebx;
00407fb1                  return result;
00407f7e              }
00407f7e              
00407f84              ecx *= 2;
00407f89              arg1 = &arg1[1];
00407f8f              edx_3 = HIGHD((int64_t)ecx);
00407f8f              eax_9 = LOWD((int64_t)ecx);
00407f96          } while ((eax_9 - edx_3) >> 1 < i);
00407f98          eax_12 = arg2;
00407f57      }
00407f57      
00407f9c      *(uint32_t*)eax_12 = ebx;
00407fa4      return result;
00407f40  }

00407fb2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00407fc0    int32_t sub_407fc0(int32_t arg1, int32_t arg2)

00407fc0  {
00407fc5      int32_t eax;
00407fc5      int80_t st0;
00407fc5      st0 = sub_407820(arg1);
00407fc5      
00407fd6      if (eax <= 0 || eax > 0x4000000)
00407ff7          return 0;
00407ff7      
00407fe6      int32_t* eax_3 = arg2 + (sub_408360(eax - 1) << 2) + 4;
00407fed      *(uint32_t*)eax_3 += 1;
00407ff4      return 1;
00407fc0  }

00407ff8                                                                          90 90 90 90 90 90 90 90                          ........

00408000    int32_t sub_408000(void* arg1, int32_t* arg2)

00408000  {
00408007      int32_t* ebp = arg2;
0040800b      int32_t ebx = 1;
00408011      int32_t result = 0;
00408015      int32_t var_4 = 0;
00408019      void* eax = arg1;
0040801e      int32_t edx = 1;
0040807b      bool cond:0_1;
0040807b      
0040807b      do
0040807b      {
00408020          int32_t esi_1 = *(uint32_t*)((char*)eax + 0x1c);
00408023          int32_t edi_1 = 0;
00408027          int32_t ecx_1 = edx;
00408027          
00408029          if (edx > esi_1)
00408029          {
0040802b              ecx_1 = esi_1;
0040802b              
0040802f              if (ebx > ecx_1)
0040802f                  break;
0040802f              
0040802f              goto label_408041;
00408029          }
00408029          
00408035          if (ebx <= edx)
00408035          {
00408041          label_408041:
00408041              int32_t i_1 = ecx_1 - ebx + 1;
00408042              int32_t* esi_4 = (ebx << 4) + *(uint32_t*)((char*)eax + 0xc) - 8;
00408046              ebx += i_1;
00408052              int32_t i;
00408052              
00408052              do
00408052              {
0040804b                  if (*(uint32_t*)esi_4)
0040804d                      edi_1 += 1;
0040804d                  
0040804e                  esi_4 = &esi_4[4];
00408051                  i = i_1;
00408051                  i_1 -= 1;
00408052              } while (i != 1);
00408054              eax = arg1;
00408035          }
00408035          
00408063          result += edi_1;
0040806b          *(uint32_t*)ebp += edi_1;
0040806f          ebp = &ebp[1];
00408072          edx *= 2;
00408074          cond:0_1 = var_4 + 1 <= 0x1a;
00408077          var_4 += 1;
0040807b      } while (cond:0_1);
00408088      return result;
00408000  }

00408089                             90 90 90 90 90 90 90                                                           .......

00408090    int32_t sub_408090(void* arg1, int32_t arg2, int32_t* arg3)

00408090  {
0040809b      void* ecx;
0040809b      (uint8_t)ecx = *(uint8_t*)((char*)arg1 + 7);
0040809e      int32_t result = 0;
004080a0      int32_t i_1 = 1 << (uint8_t)ecx;
004080a2      int32_t edi = 0;
004080a2      
004080a9      if (!i_1)
004080a9      {
004080fe          *(uint32_t*)arg3 = *(uint32_t*)arg3;
00408103          return 0;
004080a9      }
004080a9      
004080af      int32_t i = i_1;
004080b2      int32_t esi_1 = (i_1 - 1) << 5;
004080b2      
004080e2      do
004080e2      {
004080bb          int32_t edx_1 = *(uint32_t*)((char*)arg1 + 0x10);
004080bb          
004080c6          if (*(uint32_t*)(esi_1 + edx_1 + 8))
004080c6          {
004080d9              edi += sub_407fc0(esi_1 + edx_1 + 0x10, arg2);
004080db              result += 1;
004080c6          }
004080c6          
004080dc          i -= 1;
004080dd          esi_1 -= 0x20;
004080e2      } while (i > 0);
004080e2      
004080ef      *(uint32_t*)arg3 += edi;
004080f4      return result;
00408090  }

00408104              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00408110    int32_t sub_408110(void* arg1)

00408110  {
00408115      void* esi = *(uint32_t*)((char*)arg1 + 0x14);
00408118      int32_t edx = *(uint32_t*)((char*)arg1 + 0x10);
0040811d      void* eax = (char*)esi - 0x20;
00408120      *(uint32_t*)((char*)arg1 + 0x14) = eax;
00408120      
00408123      if (esi > edx)
00408123      {
00408136          void* esi_2;
00408136          
00408136          do
00408136          {
0040812a              if (!*(uint32_t*)((char*)eax + 0x18))
00408140                  return *(uint32_t*)((char*)arg1 + 0x14);
00408140              
0040812c              esi_2 = eax;
0040812e              eax -= 0x20;
00408133              *(uint32_t*)((char*)arg1 + 0x14) = eax;
00408136          } while (esi_2 > edx);
00408123      }
00408123      
0040813b      return 0;
00408110  }

00408141     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00408150    void* sub_408150(void* arg1, int32_t arg2, int32_t arg3)

00408150  {
0040815e      void* result = sub_407bf0(arg2, arg3);
0040815e      
0040816b      if (result != &data_428330)
00408194          return result;
00408194      
0040817b      double var_10 = (double)(long double)arg3;
00408180      int32_t var_8_1 = 3;
00408188      return sub_407dc0(arg1, arg2, &var_10);
00408150  }

00408195                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

004081a0    void* sub_4081a0(void* arg1, int32_t arg2, void* arg3)

004081a0  {
004081af      void* result = sub_407c70(arg2, arg3);
004081af      
004081bc      if (result != &data_428330)
004081e2          return result;
004081e2      
004081c9      void* var_10 = arg3;
004081cd      int32_t var_8_1 = 4;
004081d5      return sub_407dc0(arg1, arg2, &var_10);
004081a0  }

004081e3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

004081f0    int32_t sub_4081f0(void* arg1)

004081f0  {
004081f6      int32_t eax = *(uint32_t*)((char*)arg1 + 0x1c);
004081f6      
004081fb      if (eax > 0)
004081fb      {
004081fd          int32_t esi_1 = *(uint32_t*)((char*)arg1 + 0xc);
004081fd          
0040820b          if (!*(uint32_t*)((eax << 4) + esi_1 - 8))
0040820b          {
0040820d              uint32_t edx_3 = 0;
0040820d              
00408212              if (eax > 1)
00408212              {
00408234                  do
00408234                  {
00408218                      uint32_t ecx_1 = (edx_3 + eax) >> 1;
00408218                      
00408225                      if (*(uint32_t*)((ecx_1 << 4) + esi_1 - 8))
0040822b                          edx_3 = ecx_1;
00408225                      else
00408227                          eax = ecx_1;
00408234                  } while (eax - edx_3 > 1);
00408212              }
00408212              
0040823b              return edx_3;
0040820b          }
004081fb      }
004081fb      
00408243      if (*(uint32_t*)((char*)arg1 + 0x10) == 0x428308)
00408251          return eax;
00408251      
00408247      return sub_408260(arg1, eax);
004081f0  }

00408252                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00408260    int32_t sub_408260(void* arg1, int32_t arg2)

00408260  {
0040826b      int32_t result = arg2;
0040826d      int32_t result_1 = arg2 + 1;
0040826d      
0040827d      if (*(uint32_t*)(sub_407bf0(arg1, result_1) + 8))
0040827d      {
0040829a          int32_t i;
0040829a          
0040829a          do
0040829a          {
0040827f              result = result_1;
00408281              result_1 *= 2;
00408281              
00408289              if (result_1 > 0x7ffffffd)
00408289              {
004082c0                  int32_t esi_1 = 1;
004082c0                  
004082d4                  if (*(uint32_t*)(sub_407bf0(arg1, 1) + 8))
004082d4                  {
004082e6                      int32_t j;
004082e6                      
004082e6                      do
004082e6                      {
004082d6                          esi_1 += 1;
004082de                          j = *(uint32_t*)(sub_407bf0(arg1, esi_1) + 8);
004082e6                      } while (j);
004082d4                  }
004082d4                  
004082ee                  return esi_1 - 1;
00408289              }
00408289              
00408292              i = *(uint32_t*)(sub_407bf0(arg1, result_1) + 8);
0040829a          } while (i);
0040827d      }
0040827d      
004082a3      while (result_1 - result > 1)
004082a3      {
004082a9          uint32_t result_2 = (result + result_1) >> 1;
004082a9          
004082ba          if (*(uint32_t*)(sub_407bf0(arg1, result_2) + 8))
004082ef              result = result_2;
004082ba          else
004082bc              result_1 = result_2;
004082a3      }
004082a3      
00408300      return result;
00408260  }

00408301     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00408310    uint32_t sub_408310(uint32_t arg1) __pure

00408310  {
00408310      uint32_t i = arg1;
00408314      int32_t eax = 0;
00408314      
00408319      while (i >= 0x10)
00408319      {
0040831c          i = (i + 1) >> 1;
0040831e          eax += 1;
00408319      }
00408319      
00408327      if (i >= 8)
00408338          return ((eax << 3) + 8) | (i - 8);
00408338      
0040832b      return i;
00408310  }

00408339                                                                             90 90 90 90 90 90 90                           .......

00408340    int32_t sub_408340(int32_t arg1) __pure

00408340  {
00408349      int32_t ecx_2 = arg1 >> 3 & 0x1f;
00408349      
0040834c      if (!ecx_2)
00408357          return arg1;
00408357      
00408355      return ((arg1 & 7) + 8) << ((uint8_t)ecx_2 - 1);
00408340  }

00408358                                                                          90 90 90 90 90 90 90 90                          ........

00408360    int32_t sub_408360(uint32_t arg1)

00408360  {
00408360      uint32_t i = arg1;
00408364      int32_t ecx = 0xffffffff;
00408364      
0040836c      while (i >= 0x100)
0040836c      {
0040836e          i u>>= 8;
00408371          ecx += 8;
0040836c      }
0040836c      
0040837d      int32_t edx;
0040837d      (uint8_t)edx = *(uint8_t*)(i + 0x428340);
00408387      return edx + ecx;
00408360  }

00408388                          90 90 90 90 90 90 90 90                                                          ........

00408390    int32_t sub_408390(double* arg1, double* arg2)

00408390  {
00408399      int32_t edx = arg1[1];
00408399      
004083a1      if (edx == arg2[1])
004083ac          switch (edx)
004083ac          {
004083c4              case 0:
004083c4              {
004083c4                  return 1;
004083c4                  break;
004083c4              }
004083b3              case 3:
004083b3              {
004083b3                  long double x87_r7_1 = (long double)*(uint64_t*)arg1;
004083b5                  long double temp0_1 = (long double)*(uint64_t*)arg2;
004083b5                  x87_r7_1 - temp0_1;
004083b7                  double* eax_1;
004083b7                  (uint16_t)eax_1 = (x87_r7_1 < temp0_1 ? 1 : 0) << 8
004083b7                      | (FCMP_UO(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
004083b7                      | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe;
004083b7                  
004083bc                  if (*(uint8_t*)((char*)eax_1)[1] & 0x40)
004083c4                      return 1;
004083b3                  break;
004083b3              }
004083ac              default:
004083ac              {
004083cd                  int32_t result;
004083cd                  (uint8_t)result = *(uint32_t*)arg1 == *(uint32_t*)arg2;
004083d3                  return result;
004083ac              }
004083ac          }
004083ac      
004083a6      return 0;
00408390  }

004083d4  uint32_t jump_table_4083d4[0x4] = 
004083d4  {
004083d4      [0x0] =  0x004083be
004083d8      [0x1] =  0x004083c5
004083dc      [0x2] =  0x004083c5
004083e0      [0x3] =  0x004083b3
004083e4  }

004083e4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

004083f0    int32_t sub_4083f0(char* arg1, double* arg2)

004083f0  {
004083f8      void* esi = arg1;
004083ff      int32_t eax;
004083ff      long double st0;
004083ff      st0 = sub_417c90(esi, &arg1);
00408408      char* ecx = arg1;
00408411      *(uint64_t*)arg2 = (double)st0;
00408411      
00408413      if (ecx == esi)
0040841c          return 0;
0040841c      
0040841d      (uint8_t)eax = *(uint8_t*)ecx;
0040841d      
00408425      if ((uint8_t)eax == 0x78 || (uint8_t)eax == 0x58)
00408425      {
0040842f          eax = sub_417c79(esi, &arg1, 0x10);
00408434          ecx = arg1;
0040843c          int32_t var_4_1 = 0;
0040844b          *(uint64_t*)arg2 = (double)(long double)eax;
00408425      }
00408425      
00408450      if (!*(uint8_t*)ecx)
0040845c          return 1;
0040845c      
00408464      wchar16 (* edx_2)[0x21];
00408464      
00408464      while (true)
00408464      {
00408464          if (data_42d07c <= 1)
00408464          {
00408483              int32_t eax_3;
00408483              (uint8_t)eax_3 = *(uint8_t*)ecx;
00408485              (uint8_t)eax_3 = (**(uint528_t**)&data_42ce70)[eax_3];
00408488              eax = eax_3 & 8;
00408464          }
00408464          else
00408464          {
00408468              int32_t var_14_1 = 8;
0040846a              int32_t edx_1;
0040846a              (uint8_t)edx_1 = *(uint8_t*)ecx;
0040846d              eax = sub_4179df(eax, edx_1, ecx, edx_1);
00408472              ecx = arg1;
00408464          }
00408464          
0040848d          if (!eax)
0040848d              break;
0040848d          
0040848f          ecx = &ecx[1];
00408490          arg1 = ecx;
00408464      }
00408464      
00408496      (uint8_t)edx_2 = *(uint8_t*)ecx;
0040849e      int32_t result;
0040849e      (uint8_t)result = !(uint8_t)edx_2;
004084a4      return result;
004083f0  }

004084a5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

004084b0    int32_t sub_4084b0(void* arg1, double* arg2)

004084b0  {
004084b5      void* esi = arg1;
004084ba      int32_t edi = 1;
004084c5      int32_t var_1c = 1;
004084c9      sub_408740(esi, &data_4307a0);
004084ce      void* arg_8;
004084ce      void* ebp = arg_8;
004084d5      void* eax = sub_4172f0(ebp, 0x25);
004084dd      void* var_20 = eax;
004084dd      
004084e3      if (eax)
004084e3      {
004084ee          void* edi_1 = (char*)arg2 - 4;
004084f4          arg2 = &arg2[-1];
004084f4          
004084fe          while (true)
004084fe          {
004084fe              void*** ebx_1 = *(uint32_t*)((char*)esi + 8);
0040850b              *(uint32_t*)ebx_1 = sub_405f60(esi, ebp, (char*)eax - ebp);
0040850d              ebx_1[2] = 4;
0040850d              
00408522              if (*(uint32_t*)((char*)esi + 0x1c) - *(uint32_t*)((char*)esi + 8) <= 0x10)
00408527                  sub_405460(esi, 1);
00408527              
00408532              double* ebx_3 = *(uint32_t*)((char*)esi + 8) + 0x10;
00408535              *(uint32_t*)((char*)esi + 8) = ebx_3;
0040853e              char ecx_3 = *(uint8_t*)((char*)var_20 + 1);
0040853e              
0040854a              if ((int32_t)ecx_3 - 0x25 > 0x4e)
0040854a              {
0040864e              label_40864e:
0040864e                  *(uint8_t*)((char*)arg_8)[1] = ecx_3;
00408652                  (uint8_t)arg_8 = 0x25;
00408657                  *(uint8_t*)((char*)arg_8)[2] = 0;
00408662                  sub_408740(esi, &arg_8);
0040854a              }
0040854a              else
0040854a              {
00408552                  int32_t edx_3;
00408552                  (uint8_t)edx_3 = *(uint8_t*)((int32_t)ecx_3 + 0x4086cb);
00408552                  
00408558                  switch (edx_3)
00408558                  {
00408647                      case 0:
00408647                      {
00408662                          sub_408740(esi, U"%");
00408647                          break;
00408647                      }
00408583                      case 1:
00408583                      {
00408583                          *(uint8_t*)((char*)arg1)[1] = 0;
0040858b                          edi_1 += 4;
0040858e                          arg2 += 4;
00408596                          void* eax_8;
00408596                          (uint8_t)eax_8 = *(uint8_t*)edi_1;
00408598                          (uint8_t)arg1 = (uint8_t)eax_8;
00408662                          sub_408740(esi, &arg1);
00408583                          break;
00408583                      }
004085a1                      case 2:
004085a1                      {
004085a1                          long double x87_r7_1 =
004085a1                              (long double)*(uint32_t*)((char*)edi_1 + 4);
004085a4                          edi_1 += 4;
004085ab                          ebx_3[1] = 3;
004085b5                          *(uint64_t*)ebx_3 = (double)x87_r7_1;
004085bf                          arg2 += 4;
004085bf                          
004085c6                          if (*(uint32_t*)((char*)esi + 0x1c) - *(uint32_t*)((char*)esi + 8)
004085c6                                  > 0x10)
00408610                              *(uint32_t*)((char*)esi + 8) += 0x10;
004085c6                          else
004085c6                          {
004085cb                              sub_405460(esi, 1);
004085d9                              *(uint32_t*)((char*)esi + 8) += 0x10;
004085c6                          }
004085a1                          break;
004085a1                      }
004085e5                      case 3:
004085e5                      {
004085e5                          edi_1 += 8;
004085e8                          double* ecx_7 = &arg2[1];
004085eb                          arg2 = ecx_7;
004085f1                          *(uint64_t*)ebx_3 = (double)(long double)*(uint64_t*)ecx_7;
004085f3                          ebx_3[1] = 3;
004085f3                          
00408603                          if (*(uint32_t*)((char*)esi + 0x1c) - *(uint32_t*)((char*)esi + 8)
00408603                                  <= 0x10)
00408608                              sub_405460(esi, 1);
00408608                          
00408610                          *(uint32_t*)((char*)esi + 8) += 0x10;
004085e5                          break;
004085e5                      }
00408616                      case 4:
00408616                      {
00408616                          int32_t ecx_8 = *(uint32_t*)((char*)edi_1 + 4);
0040861d                          edi_1 += 4;
00408620                          int32_t var_34_3 = ecx_8;
0040862e                          arg2 += 4;
00408632                          void var_18;
00408632                          sub_417d2a(&var_18, 0x42b670);
0040863d                          sub_408740(esi, &var_18);
00408616                          break;
00408616                      }
00408563                      case 5:
00408563                      {
00408563                          void** eax_6 = *(uint32_t*)((char*)edi_1 + 4);
00408566                          edi_1 += 4;
0040856e                          arg2 += 4;
0040856e                          
00408572                          if (!eax_6)
00408574                              eax_6 = "(null)";
00408574                          
00408662                          sub_408740(esi, eax_6);
00408563                          break;
00408563                      }
00408558                      case 6:
00408558                      {
00408558                          goto label_40864e;
00408558                      }
00408558                  }
0040854a              }
0040854a              
0040866e              ebp = (char*)var_20 + 2;
00408677              var_1c += 2;
0040867b              void* eax_15 = sub_4172f0(ebp, 0x25);
00408683              var_20 = eax_15;
00408683              
00408689              if (!eax_15)
00408689                  break;
00408689              
004084fa              eax = var_20;
004084fe          }
004084fe          
0040868f          edi = var_1c;
004084e3      }
004084e3      
00408696      sub_408740(esi, ebp);
004086ad      sub_409060(esi, edi + 1, 
004086ad          ((*(uint32_t*)((char*)esi + 8) - *(uint32_t*)((char*)esi + 0xc)) >> 4) - 1);
004086bd      void* edx_11 = *(uint32_t*)((char*)esi + 8) + (-(edi) << 4);
004086c0      *(uint32_t*)((char*)esi + 8) = edx_11;
004086d0      return *(uint32_t*)((char*)edx_11 - 0x10) + 0x10;
004084b0  }

004086d1                                                     8d 49 00                                                       .I.
004086d4  uint32_t jump_table_4086d4[0x7] = 
004086d4  {
004086d4      [0x0] =  0x00408647
004086d8      [0x1] =  0x0040857f
004086dc      [0x2] =  0x004085a1
004086e0      [0x3] =  0x004085e1
004086e4      [0x4] =  0x00408616
004086e8      [0x5] =  0x0040855f
004086ec      [0x6] =  0x0040864e
004086f0  }
004086f0  uint8_t lookup_table_4086f0[0x4f] = 
004086f0  {
004086f0      [0x00] =  0x00
004086f1      [0x01] =  0x06
004086f2      [0x02] =  0x06
004086f3      [0x03] =  0x06
004086f4      [0x04] =  0x06
004086f5      [0x05] =  0x06
004086f6      [0x06] =  0x06
004086f7      [0x07] =  0x06
004086f8      [0x08] =  0x06
004086f9      [0x09] =  0x06
004086fa      [0x0a] =  0x06
004086fb      [0x0b] =  0x06
004086fc      [0x0c] =  0x06
004086fd      [0x0d] =  0x06
004086fe      [0x0e] =  0x06
004086ff      [0x0f] =  0x06
00408700      [0x10] =  0x06
00408701      [0x11] =  0x06
00408702      [0x12] =  0x06
00408703      [0x13] =  0x06
00408704      [0x14] =  0x06
00408705      [0x15] =  0x06
00408706      [0x16] =  0x06
00408707      [0x17] =  0x06
00408708      [0x18] =  0x06
00408709      [0x19] =  0x06
0040870a      [0x1a] =  0x06
0040870b      [0x1b] =  0x06
0040870c      [0x1c] =  0x06
0040870d      [0x1d] =  0x06
0040870e      [0x1e] =  0x06
0040870f      [0x1f] =  0x06
00408710      [0x20] =  0x06
00408711      [0x21] =  0x06
00408712      [0x22] =  0x06
00408713      [0x23] =  0x06
00408714      [0x24] =  0x06
00408715      [0x25] =  0x06
00408716      [0x26] =  0x06
00408717      [0x27] =  0x06
00408718      [0x28] =  0x06
00408719      [0x29] =  0x06
0040871a      [0x2a] =  0x06
0040871b      [0x2b] =  0x06
0040871c      [0x2c] =  0x06
0040871d      [0x2d] =  0x06
0040871e      [0x2e] =  0x06
0040871f      [0x2f] =  0x06
00408720      [0x30] =  0x06
00408721      [0x31] =  0x06
00408722      [0x32] =  0x06
00408723      [0x33] =  0x06
00408724      [0x34] =  0x06
00408725      [0x35] =  0x06
00408726      [0x36] =  0x06
00408727      [0x37] =  0x06
00408728      [0x38] =  0x06
00408729      [0x39] =  0x06
0040872a      [0x3a] =  0x06
0040872b      [0x3b] =  0x06
0040872c      [0x3c] =  0x06
0040872d      [0x3d] =  0x06
0040872e      [0x3e] =  0x01
0040872f      [0x3f] =  0x02
00408730      [0x40] =  0x06
00408731      [0x41] =  0x03
00408732      [0x42] =  0x06
00408733      [0x43] =  0x06
00408734      [0x44] =  0x06
00408735      [0x45] =  0x06
00408736      [0x46] =  0x06
00408737      [0x47] =  0x06
00408738      [0x48] =  0x06
00408739      [0x49] =  0x06
0040873a      [0x4a] =  0x06
0040873b      [0x4b] =  0x04
0040873c      [0x4c] =  0x06
0040873d      [0x4d] =  0x06
0040873e      [0x4e] =  0x05
0040873f  }

0040873f                                                                                               90                                 .

00408740    int32_t sub_408740(void* arg1, char* arg2)

00408740  {
00408747      char* edi = arg2;
00408749      int32_t i = 0xffffffff;
00408749      
00408752      while (i)
00408752      {
00408752          bool cond:0_1 = 0 != *(uint8_t*)edi;
00408752          edi = &edi[1];
00408752          i -= 1;
00408752          
00408752          if (!cond:0_1)
00408752              break;
00408752      }
00408752      
00408754      void*** ebx = *(uint32_t*)((char*)arg1 + 8);
00408762      *(uint32_t*)ebx = sub_405f60(arg1, arg2, ~i - 1);
00408764      ebx[2] = 4;
00408764      
0040877d      if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= 0x10)
00408782          sub_405460(arg1, 1);
00408782      
0040878d      int32_t result = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00408790      *(uint32_t*)((char*)arg1 + 8) = result;
00408795      return result;
00408740  }

00408796                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

004087a0    int32_t sub_4087a0(void* arg1, double* arg2)

004087a0  {
004087ac      void arg_c;
004087ac      void* var_4 = &arg_c;
004087b7      return sub_4084b0(arg1, arg2);
004087a0  }

004087b8                                                                          90 90 90 90 90 90 90 90                          ........

004087c0    char* sub_4087c0(char* arg1, char* arg2, int32_t arg3)

004087c0  {
004087c7      char eax = *(uint8_t*)arg2;
004087c7      
004087cc      if (eax == 0x3d)
004087cc      {
004087da          char* result = sub_417ef0(arg1, &arg2[1], arg3);
004087e2          arg1[arg3 - 1] = 0;
004087eb          return result;
004087cc      }
004087cc      
004087ee      char* ebp;
004087ee      void* edi_12;
004087ee      
004087ee      if (eax != 0x40)
004087ee      {
0040884f          char* eax_2 = sub_417eb0(arg2, "\n\r");
0040884f          
00408860          if (eax_2 > arg3 - 0x11)
00408862              eax_2 = arg3 - 0x11;
00408862          
00408864          ebp = arg1;
00408870          *(uint32_t*)ebp = data_42b680[0];
00408878          *(uint32_t*)(ebp + 4) = data_42b680[4][0];
0040887b          int32_t edx_3;
0040887b          (uint16_t)edx_3 = data_42b680[8][0];
00408882          *(uint16_t*)(ebp + 8) = (uint16_t)edx_3;
00408886          char* ecx_10;
00408886          (uint8_t)ecx_10 = *(uint8_t*)(eax_2 + arg2);
0040888b          char* edi_7;
0040888b          
0040888b          if (!(uint8_t)ecx_10)
0040889f              edi_7 = arg2;
0040888b          else
0040888b          {
00408890              sub_417d80(ebp, arg2, eax_2);
00408898              edi_7 = &data_42b3b4;
0040888b          }
0040888b          
004088a1          int32_t i = 0xffffffff;
004088a1          
004088a6          while (i)
004088a6          {
004088a6              bool cond:5_1 = 0 != *(uint8_t*)edi_7;
004088a6              edi_7 = &edi_7[1];
004088a6              i -= 1;
004088a6              
004088a6              if (!cond:5_1)
004088a6                  break;
004088a6          }
004088a6          
004088a8          int32_t ecx_11 = ~i;
004088b0          char* edi_9 = ebp;
004088b2          int32_t i_1 = 0xffffffff;
004088b2          
004088b5          while (i_1)
004088b5          {
004088b5              bool cond:6_1 = 0 != *(uint8_t*)edi_9;
004088b5              edi_9 = &edi_9[1];
004088b5              i_1 -= 1;
004088b5              
004088b5              if (!cond:6_1)
004088b5                  break;
004088b5          }
004088b5          
004088bd          int32_t esi_6;
004088bd          int32_t edi_11;
004088bd          edi_11 = __builtin_memcpy(edi_9 - 1, edi_7 - ecx_11, ecx_11 >> 2 << 2);
004088c4          __builtin_memcpy(edi_11, esi_6, ecx_11 & 3);
004088c6          edi_12 = &data_42b67c;
004087ee      }
004087ee      else
004087ee      {
004087f4          void* ebx_2 = &arg2[1];
004087f5          void* edi_1 = ebx_2;
004087f7          int32_t i_2 = 0xffffffff;
004087f7          
004087ff          while (i_2)
004087ff          {
004087ff              bool cond:0_1 = 0 != *(uint8_t*)edi_1;
004087ff              edi_1 += 1;
004087ff              i_2 -= 1;
004087ff              
004087ff              if (!cond:0_1)
004087ff                  break;
004087ff          }
004087ff          
00408801          ebp = arg1;
0040880d          *(uint8_t*)ebp = data_4307a0;
0040880d          
00408812          if (~i_2 - 1 > arg3 - 8)
00408812          {
00408816              void* edi_2 = &data_42b3b4;
0040881b              ebx_2 += ~i_2 - 1 - (arg3 - 8);
0040881d              int32_t i_3 = 0xffffffff;
0040881d              
00408822              while (i_3)
00408822              {
00408822                  bool cond:1_1 = 0 != *(uint8_t*)edi_2;
00408822                  edi_2 += 1;
00408822                  i_3 -= 1;
00408822                  
00408822                  if (!cond:1_1)
00408822                      break;
00408822              }
00408822              
00408824              int32_t ecx_3 = ~i_3;
0040882c              char* edi_4 = ebp;
0040882e              int32_t i_4 = 0xffffffff;
0040882e              
00408831              while (i_4)
00408831              {
00408831                  bool cond:2_1 = 0 != *(uint8_t*)edi_4;
00408831                  edi_4 = &edi_4[1];
00408831                  i_4 -= 1;
00408831                  
00408831                  if (!cond:2_1)
00408831                      break;
00408831              }
00408831              
00408839              int32_t esi_4;
00408839              int32_t edi_6;
00408839              edi_6 = __builtin_memcpy(edi_4 - 1, (char*)edi_2 - ecx_3, ecx_3 >> 2 << 2);
00408840              __builtin_memcpy(edi_6, esi_4, ecx_3 & 3);
00408812          }
00408812          
00408842          edi_12 = ebx_2;
004087ee      }
004087ee      
004088cb      int32_t i_5 = 0xffffffff;
004088cb      
004088d0      while (i_5)
004088d0      {
004088d0          bool cond:3_1 = 0 != *(uint8_t*)edi_12;
004088d0          edi_12 += 1;
004088d0          i_5 -= 1;
004088d0          
004088d0          if (!cond:3_1)
004088d0              break;
004088d0      }
004088d0      
004088d2      int32_t ecx_16 = ~i_5;
004088da      char* edi_14 = ebp;
004088dc      int32_t i_6 = 0xffffffff;
004088dc      
004088df      while (i_6)
004088df      {
004088df          bool cond:4_1 = 0 != *(uint8_t*)edi_14;
004088df          edi_14 = &edi_14[1];
004088df          i_6 -= 1;
004088df          
004088df          if (!cond:4_1)
004088df              break;
004088df      }
004088df      
004088e7      int32_t esi_8;
004088e7      int32_t edi_16;
004088e7      edi_16 = __builtin_memcpy(edi_14 - 1, (char*)edi_12 - ecx_16, ecx_16 >> 2 << 2);
004088ee      __builtin_memcpy(edi_16, esi_8, ecx_16 & 3);
004088f4      return 0;
004087c0  }

004088f5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00408900    int32_t* sub_408900(int32_t* arg1, double* arg2)

00408900  {
00408907      int32_t ecx = arg1[2];
00408907      
0040890d      if (ecx == 3)
00408945          return arg1;
00408945      
00408912      double var_8;
00408912      
00408912      if (ecx == 4 && sub_4083f0(*(uint32_t*)arg1 + 0x10, &var_8))
00408912      {
00408933          *(uint64_t*)arg2 = (double)(long double)var_8;
00408935          arg2[1] = 3;
0040893f          return arg2;
00408912      }
00408912      
00408940      return nullptr;
00408900  }

00408946                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00408950    int32_t sub_408950(void* arg1, int32_t* arg2)

00408950  {
0040895c      if (arg2[2] != 3)
00408964          return 0;
00408964      
0040896f      double var_30 = (double)(long double)*(uint64_t*)arg2;
00408978      void var_20;
00408978      sub_417d2a(&var_20, "%.14g");
0040897d      void* edi = &var_20;
00408981      int32_t i = 0xffffffff;
00408981      
0040898a      while (i)
0040898a      {
0040898a          bool cond:0_1 = 0 != *(uint8_t*)edi;
0040898a          edi += 1;
0040898a          i -= 1;
0040898a          
0040898a          if (!cond:0_1)
0040898a              break;
0040898a      }
0040898a      
0040899e      *(uint32_t*)arg2 = sub_405f60(arg1, &var_20, ~i - 1);
004089a0      arg2[2] = 4;
004089b1      return 1;
00408950  }

004089b2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

004089c0    int32_t* sub_4089c0(void* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)

004089c0  {
004089c0      int32_t ecx;
004089c0      int32_t var_4_1 = ecx;
004089c9      int32_t* edi = arg2;
004089cd      int32_t var_4 = 0;
00408a56      bool cond:0_1;
00408a56      
00408a56      do
00408a56      {
004089d9          void* esi_3;
004089d9          
004089d9          if (edi[2] != 5)
004089d9          {
00408a22              void* eax_5;
00408a22              int32_t ecx_2;
00408a22              int32_t edx_2;
00408a22              eax_5 = sub_407540(arg1, edi, 0);
00408a27              esi_3 = eax_5;
00408a2c              int32_t eax_6 = *(uint32_t*)((char*)esi_3 + 8);
00408a2c              
00408a31              if (!eax_6)
00408a3a                  sub_40b960(eax_6, edx_2, ecx_2, arg1, edi, "index");
004089d9          }
004089d9          else
004089d9          {
004089df              void* esi_1 = *(uint32_t*)edi;
004089e3              void* eax_2 = sub_407cb0(esi_1, arg3);
004089e3              
004089f2              if (*(uint32_t*)((char*)eax_2 + 8))
004089f2              {
00408a66              label_408a66:
00408a66                  *(uint32_t*)arg4 = *(uint32_t*)eax_2;
00408a6b                  arg4[1] = *(uint32_t*)((char*)eax_2 + 4);
00408a72                  arg4[2] = *(uint32_t*)((char*)eax_2 + 8);
00408a77                  return arg4;
004089f2              }
004089f2              
004089f4              void* esi_2 = *(uint32_t*)((char*)esi_1 + 8);
004089f4              
004089ff              if (!esi_2 || *(uint8_t*)((char*)esi_2 + 6) & 1)
004089f9                  goto label_408a66;
004089f9              
00408a13              esi_3 = sub_407510(esi_2, 0, 
00408a13                  *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 0xbc));
00408a13              
00408a1a              if (!esi_3)
00408a1a                  goto label_408a66;
004089d9          }
004089d9          
00408a46          if (*(uint32_t*)((char*)esi_3 + 8) == 6)
00408a92              return sub_408ab0(arg1, arg4, esi_3, edi, arg3);
00408a92          
00408a4c          edi = esi_3;
00408a4f          cond:0_1 = var_4 + 1 >= 0x64;
00408a52          var_4 += 1;
00408a56      } while (!cond:0_1);
00408aa6      return sub_40bb80(arg1, "loop in gettable");
004089c0  }

00408aa7                       90 90 90 90 90 90 90 90 90                                                         .........

00408ab0    int32_t sub_408ab0(void* arg1, int32_t arg2, int32_t* arg3, int32_t* arg4, int32_t* arg5)

00408ab0  {
00408ac1      int32_t* eax = *(uint32_t*)((char*)arg1 + 8);
00408ac4      void* edi_1 = arg2 - *(uint32_t*)((char*)arg1 + 0x20);
00408ac8      *(uint32_t*)eax = *(uint32_t*)arg3;
00408acd      eax[1] = arg3[1];
00408ad3      eax[2] = arg3[2];
00408add      int32_t* eax_2 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00408ae2      *(uint32_t*)eax_2 = *(uint32_t*)arg4;
00408ae7      eax_2[1] = arg4[1];
00408aed      eax_2[2] = arg4[2];
00408af7      int32_t* eax_4 = *(uint32_t*)((char*)arg1 + 8) + 0x20;
00408afc      *(uint32_t*)eax_4 = *(uint32_t*)arg5;
00408b01      eax_4[1] = arg5[1];
00408b07      eax_4[2] = arg5[2];
00408b07      
00408b13      if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= 0x30)
00408b18          sub_405460(arg1, 3);
00408b18      
00408b25      void* edx_10 = *(uint32_t*)((char*)arg1 + 8) + 0x30;
00408b2a      *(uint32_t*)((char*)arg1 + 8) = edx_10;
00408b32      sub_405a80(arg1, (char*)edx_10 - 0x30, 1);
00408b3d      int32_t* edx_12 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
00408b40      int32_t* edi_2 = (char*)edi_1 + *(uint32_t*)((char*)arg1 + 0x20);
00408b44      *(uint32_t*)((char*)arg1 + 8) = edx_12;
00408b4c      *(uint32_t*)edi_2 = *(uint32_t*)edx_12;
00408b51      edi_2[1] = edx_12[1];
00408b54      int32_t result = edx_12[2];
00408b57      edi_2[2] = result;
00408b5c      return result;
00408ab0  }

00408b5d                                                                                         90 90 90                               ...

00408b60    int32_t* sub_408b60(void* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)

00408b60  {
00408b60      int32_t ecx;
00408b60      int32_t var_4_1 = ecx;
00408b69      int32_t* edi = arg2;
00408b6d      int32_t var_4 = 0;
00408bfb      bool cond:0_1;
00408bfb      
00408bfb      do
00408bfb      {
00408b79          void* esi_1;
00408b79          
00408b79          if (edi[2] != 5)
00408b79          {
00408bc7              void* eax_6;
00408bc7              int32_t ecx_3;
00408bc7              int32_t edx_2;
00408bc7              eax_6 = sub_407540(arg1, edi, 1);
00408bcc              esi_1 = eax_6;
00408bd1              int32_t eax_7 = *(uint32_t*)((char*)esi_1 + 8);
00408bd1              
00408bd6              if (!eax_7)
00408bdf                  sub_40b960(eax_7, edx_2, ecx_3, arg1, edi, "index");
00408b79          }
00408b79          else
00408b79          {
00408b7f              int32_t ebx_1 = *(uint32_t*)edi;
00408b89              void* ecx_1 = sub_407d70(arg1, ebx_1, arg3);
00408b89              
00408b97              if (*(uint32_t*)((char*)ecx_1 + 8))
00408b97              {
00408c06              label_408c06:
00408c06                  int32_t* result = arg4;
00408c0c                  *(uint32_t*)ecx_1 = *(uint32_t*)result;
00408c11                  *(uint32_t*)((char*)ecx_1 + 4) = result[1];
00408c17                  *(uint32_t*)((char*)ecx_1 + 8) = result[2];
00408c17                  
00408c24                  if (result[2] >= 4)
00408c24                  {
00408c26                      result = *(uint32_t*)result;
00408c26                      
00408c31                      if (*(uint8_t*)((char*)result + 5) & 3 && *(uint8_t*)(ebx_1 + 5) & 4)
00408c42                          return sub_404ba0(arg1, ebx_1);
00408c24                  }
00408c24                  
00408c71                  return result;
00408b97              }
00408b97              
00408b99              void* eax_4 = *(uint32_t*)(ebx_1 + 8);
00408b99              
00408ba4              if (!eax_4 || *(uint8_t*)((char*)eax_4 + 6) & 2)
00408b9e                  goto label_408c06;
00408b9e              
00408bb8              esi_1 = sub_407510(eax_4, 1, 
00408bb8                  *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + 0xc0));
00408bb8              
00408bbf              if (!esi_1)
00408bbf                  goto label_408c06;
00408b79          }
00408b79          
00408beb          if (*(uint32_t*)((char*)esi_1 + 8) == 6)
00408c5d              return sub_408c80(arg1, esi_1, edi, arg3, arg4);
00408c5d          
00408bf1          edi = esi_1;
00408bf4          cond:0_1 = var_4 + 1 >= 0x64;
00408bf7          var_4 += 1;
00408bfb      } while (!cond:0_1);
00408c64      return sub_40bb80(arg1, "loop in settable");
00408b60  }

00408c72                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00408c80    void* sub_408c80(void* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, int32_t* arg5)

00408c80  {
00408c8b      int32_t* eax = *(uint32_t*)((char*)arg1 + 8);
00408c8e      *(uint32_t*)eax = *(uint32_t*)arg2;
00408c93      eax[1] = arg2[1];
00408c99      eax[2] = arg2[2];
00408ca3      int32_t* eax_2 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
00408ca8      *(uint32_t*)eax_2 = *(uint32_t*)arg3;
00408cad      eax_2[1] = arg3[1];
00408cb3      eax_2[2] = arg3[2];
00408cbd      int32_t* eax_4 = *(uint32_t*)((char*)arg1 + 8) + 0x20;
00408cc2      *(uint32_t*)eax_4 = *(uint32_t*)arg4;
00408cc7      eax_4[1] = arg4[1];
00408ccd      eax_4[2] = arg4[2];
00408cd7      int32_t* eax_6 = *(uint32_t*)((char*)arg1 + 8) + 0x30;
00408cdc      *(uint32_t*)eax_6 = *(uint32_t*)arg5;
00408ce1      eax_6[1] = arg5[1];
00408ce7      eax_6[2] = arg5[2];
00408ce7      
00408cf3      if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= 0x40)
00408cf8          sub_405460(arg1, 4);
00408cf8      
00408d05      void* edx_11 = *(uint32_t*)((char*)arg1 + 8) + 0x40;
00408d0a      *(uint32_t*)((char*)arg1 + 8) = edx_11;
00408d1b      return sub_405a80(arg1, (char*)edx_11 - 0x40, 0);
00408c80  }

00408d1c                                                                                      90 90 90 90                              ....

00408d20    int32_t sub_408d20(void* arg1, double* arg2, double* arg3)

00408d20  {
00408d2b      int32_t eax = arg2[1];
00408d2b      
00408d31      if (eax != arg3[1])
00408d31      {
00408d3a          sub_40ba90(arg1, arg2, arg3);
00408d45          return 0;
00408d31      }
00408d31      
00408d49      if (eax == 3)
00408d49      {
00408d4b          long double x87_r7 = (long double)*(uint64_t*)arg2;
00408d4d          long double temp0 = (long double)*(uint64_t*)arg3;
00408d4d          x87_r7 - temp0;
00408d4f          (uint16_t)eax = (x87_r7 < temp0 ? 1 : 0) << 8
00408d4f              | (FCMP_UO(x87_r7, temp0) ? 1 : 0) << 0xa | (x87_r7 == temp0 ? 1 : 0) << 0xe;
00408d4f          
00408d54          if (!(*(uint8_t*)((char*)eax)[1] & 1))
00408d64              return 0;
00408d64          
00408d5e          return 1;
00408d49      }
00408d49      
00408d68      if (eax == 4)
00408d68      {
00408d7c          int32_t ecx_1;
00408d7c          (uint8_t)ecx_1 = sub_408e40(*(uint32_t*)arg2, *(uint32_t*)arg3) < 0;
00408d84          return ecx_1;
00408d68      }
00408d68      
00408d8e      int32_t eax_6 = sub_408db0(arg1, arg2, arg3, 0xd);
00408d8e      
00408d99      if (eax_6 != 0xffffffff)
00408da9          return eax_6;
00408da9      
00408d9e      return sub_40ba90(arg1, arg2, arg3);
00408d20  }

00408daa                                90 90 90 90 90 90                                                            ......

00408db0    int32_t sub_408db0(void* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4)

00408db0  {
00408dc3      void* eax = sub_407540(arg1, arg2, arg4);
00408dc3      
00408dd2      if (!*(uint32_t*)((char*)eax + 8))
00408ddb          return 0xffffffff;
00408ddb      
00408df4      if (!sub_408390(eax, sub_407540(arg1, arg3, arg4)))
00408dfd          return 0xffffffff;
00408dfd      
00408e06      sub_408ab0(arg1, *(uint32_t*)((char*)arg1 + 8), eax, arg2, arg3);
00408e0b      int32_t* esi_1 = *(uint32_t*)((char*)arg1 + 8);
00408e11      int32_t eax_7 = esi_1[2];
00408e11      
00408e20      if (eax_7 && (eax_7 != 1 || *(uint32_t*)esi_1))
00408e2b          return 1;
00408e2b      
00408e32      return 0;
00408db0  }

00408e33                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00408e40    int32_t sub_408e40(void* arg1, void* arg2)

00408e40  {
00408e47      void* esi = (char*)arg1 + 0x10;
00408e4d      arg1 = *(uint32_t*)((char*)arg1 + 0xc);
00408e56      int32_t ebp = *(uint32_t*)((char*)arg2 + 0xc);
00408e59      void* ebx = (char*)arg2 + 0x10;
00408e5e      int32_t eax_2 = sub_417fee(esi, ebx);
00408e5e      
00408e68      if (eax_2)
00408eb9          return eax_2;
00408eb9      
00408e9b      int32_t i;
00408e9b      
00408e9b      do
00408e9b      {
00408e6a          void* edi_1 = esi;
00408e6c          int32_t j = 0xffffffff;
00408e6c          
00408e71          while (j)
00408e71          {
00408e71              bool cond:0_1 = 0 != *(uint8_t*)edi_1;
00408e71              edi_1 += 1;
00408e71              j -= 1;
00408e71              
00408e71              if (!cond:0_1)
00408e71                  break;
00408e71          }
00408e71          
00408e78          if (~j - 1 == ebp)
00408e78          {
00408ead              int32_t eax_5;
00408ead              (uint8_t)eax_5 = ~j - 1 != arg1;
00408eb1              return eax_5;
00408e78          }
00408e78          
00408e80          if (~j - 1 == arg1)
00408eb2              return 0xffffffff;
00408eb2          
00408e83          ebx += ~j;
00408e85          esi += ~j;
00408e8b          arg1 -= ~j;
00408e8f          ebp -= ~j;
00408e91          i = sub_417fee(esi, ebx);
00408e9b      } while (!i);
00408e9b      
00408ea1      return i;
00408e40  }

00408eba                                                                                90 90 90 90 90 90                            ......

00408ec0    int32_t sub_408ec0(void* arg1, int32_t* arg2, int32_t* arg3)

00408ec0  {
00408ed3      void* eax_5;
00408ed3      void* ecx_2;
00408ed3      int32_t* ebx_1;
00408ed3      
00408ed3      switch (arg2[2])
00408ed3      {
00408f7e          case 0:
00408f7e          {
00408f7e              return 1;
00408f7e              break;
00408f7e          }
00408f00          case 2:
00408f00          {
00408f00              int32_t ecx_1;
00408f00              (uint8_t)ecx_1 = *(uint32_t*)arg2 == *(uint32_t*)arg3;
00408f06              return ecx_1;
00408f00              break;
00408f00          }
00408ede          case 3:
00408ede          {
00408ede              long double x87_r7_1 = (long double)*(uint64_t*)arg2;
00408ee0              long double temp0_1 = (long double)*(uint64_t*)arg3;
00408ee0              x87_r7_1 - temp0_1;
00408ee2              double* eax_1;
00408ee2              (uint16_t)eax_1 = (x87_r7_1 < temp0_1 ? 1 : 0) << 8
00408ee2                  | (FCMP_UO(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
00408ee2                  | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe;
00408ee2              
00408ee7              if (*(uint8_t*)((char*)eax_1)[1] & 0x40)
00408ef1                  return 1;
00408ef1              
00408f51              return 0;
00408ede              break;
00408ede          }
00408f1c          case 5:
00408f1c          {
00408f1c              ebx_1 = arg3;
00408f20              eax_5 = *(uint32_t*)arg2;
00408f22              ecx_2 = *(uint32_t*)ebx_1;
00408f22              
00408f26              if (eax_5 == ecx_2)
00408f30                  return 1;
00408f30              
00408f26              goto label_408f40;
00408f1c          }
00408f07          case 7:
00408f07          {
00408f07              ebx_1 = arg3;
00408f0b              eax_5 = *(uint32_t*)arg2;
00408f0d              ecx_2 = *(uint32_t*)ebx_1;
00408f0d              
00408f11              if (eax_5 == ecx_2)
00408f1b                  return 1;
00408f1b              
00408f40          label_408f40:
00408f40              void* eax_8 = sub_408fc0(arg1, *(uint32_t*)((char*)eax_5 + 8), 
00408f40                  *(uint32_t*)((char*)ecx_2 + 8), 4);
00408f40              
00408f4a              if (!eax_8)
00408f51                  return 0;
00408f51              
00408f5a              sub_408ab0(arg1, *(uint32_t*)((char*)arg1 + 8), eax_8, arg2, ebx_1);
00408f5f              int32_t* esi_3 = *(uint32_t*)((char*)arg1 + 8);
00408f65              int32_t eax_11 = esi_3[2];
00408f65              
00408f74              if (!eax_11 || (eax_11 == 1 && !*(uint32_t*)esi_3))
00408f51                  return 0;
00408f51              
00408f7e              return 1;
00408f07              break;
00408f07          }
00408ed3      }
00408ed3      
00408f8d      int32_t eax_13;
00408f8d      (uint8_t)eax_13 = *(uint32_t*)arg2 == *(uint32_t*)arg3;
00408f91      return eax_13;
00408ec0  }

00408f92                                                        8b ff                                                        ..
00408f94  uint32_t jump_table_408f94[0x8] = 
00408f94  {
00408f94      [0x0] =  0x00408f76
00408f98      [0x1] =  0x00408f7f
00408f9c      [0x2] =  0x00408ef2
00408fa0      [0x3] =  0x00408eda
00408fa4      [0x4] =  0x00408f7f
00408fa8      [0x5] =  0x00408f1c
00408fac      [0x6] =  0x00408f7f
00408fb0      [0x7] =  0x00408f07
00408fb4  }

00408fb4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00408fc0    void* sub_408fc0(void* arg1, int32_t arg2, void* arg3, int32_t arg4)

00408fc0  {
00408fca      if (arg2)
00408fca      {
00408fd7          int32_t eax_1 = 1 << (uint8_t)arg4;
00408fd7          
00408fe0          if (!(*(uint8_t*)(arg2 + 6) & (uint8_t)eax_1))
00408fe0          {
00408ff3              void* result = sub_407510(arg2, (uint8_t)arg4, 
00408ff3                  *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + (arg4 << 2) + 0xbc));
00408ff3              
00408fff              if (result)
00408fff              {
0040900e                  if (arg2 == arg3)
00409016                      return result;
00409016                  
00409024                  if (arg3 && !((uint8_t)eax_1 & *(uint8_t*)((char*)arg3 + 6)))
00409024                  {
00409033                      double* eax_6 = sub_407510(arg3, (uint8_t)arg4, 
00409033                          *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + (arg4 << 2)
00409033                              + 0xbc));
00409033                      
0040903d                      if (eax_6)
0040903d                      {
00409048                          int32_t eax_8 = sub_408390(result, eax_6);
00409050                          int32_t eax_9 = -(eax_8);
0040905a                          return (eax_9 - eax_9) & result;
0040903d                      }
00409024                  }
00408fff              }
00408fe0          }
00408fca      }
00408fca      
00409007      return 0;
00408fc0  }

0040905b                                                                                   90 90 90 90 90                             .....

00409060    int32_t sub_409060(void* arg1, int32_t arg2, int32_t arg3)

00409060  {
00409216      int32_t i;
00409216      
00409216      do
00409216      {
0040906b          void* ebx_1 = arg1;
00409074          int32_t edi_1 = 2;
00409082          void* ebp_3 = ((arg3 + 1) << 4) + *(uint32_t*)((char*)ebx_1 + 0xc);
00409087          int32_t eax_2;
00409087          
00409087          if (*(uint32_t*)((char*)ebp_3 - 0x18) != 4)
0040908e              eax_2 = sub_408950(ebx_1, (char*)ebp_3 - 0x20);
0040908e          
00409098          int32_t eax_3;
00409098          
00409098          if ((*(uint32_t*)((char*)ebp_3 - 0x18) == 4 || eax_2)
00409098                  && *(uint32_t*)((char*)ebp_3 - 8) != 4)
004090a4              eax_3 = sub_408950(ebx_1, (char*)ebp_3 - 0x10);
004090a4          
004090ae          if ((*(uint32_t*)((char*)ebp_3 - 0x18) == 4 || eax_2)
004090ae              && (*(uint32_t*)((char*)ebp_3 - 8) == 4 || eax_3))
004090ae          {
004090df              int32_t eax_6 = *(uint32_t*)(*(uint32_t*)((char*)ebp_3 - 0x10) + 0xc);
004090df              
004090e4              if (eax_6 > 0)
004090e4              {
004090ea                  int32_t var_10_1 = eax_6;
004090f2                  int32_t esi_2 = 1;
004090f9                  int32_t var_c_1 = 1;
004090f9                  
004090fd                  if (arg2 > 1)
004090fd                  {
004090ff                      void* edi_2 = (char*)ebp_3 - 0x20;
004090ff                      
00409154                      do
00409154                      {
00409106                          if (*(uint32_t*)((char*)edi_2 + 8) != 4
00409106                                  && !sub_408950(ebx_1, edi_2))
00409114                              break;
00409114                          
0040911d                          int32_t eax_9 = *(uint32_t*)(*(uint32_t*)edi_2 + 0xc);
0040911d                          
0040912c                          if (eax_9 >= 0xfffffffd - var_10_1)
00409134                              sub_40bb80(ebx_1, "string length overflow");
00409134                          
00409144                          edi_2 -= 0x10;
0040914d                          esi_2 += 1;
0040914e                          var_10_1 += eax_9;
00409154                      } while (esi_2 < arg2);
00409154                      
00409156                      var_c_1 = esi_2;
004090fd                  }
004090fd                  
00409167                  char* eax_12 =
00409167                      sub_40a7c0(ebx_1, *(uint32_t*)((char*)ebx_1 + 0x10) + 0x34, var_10_1);
00409173                  int32_t* eax_13 = nullptr;
00409173                  
00409177                  if (esi_2 > 0)
00409177                  {
00409180                      void* ecx_10 = (char*)ebp_3 - (esi_2 << 4);
00409182                      int32_t var_8_1 = esi_2;
00409186                      void* var_10_2 = ecx_10;
00409186                      
00409190                      while (true)
00409190                      {
00409190                          void* edx_5 = *(uint32_t*)ecx_10;
00409192                          int32_t ebx_2 = *(uint32_t*)((char*)edx_5 + 0xc);
004091a6                          int32_t esi_4;
004091a6                          int32_t edi_4;
004091a6                          edi_4 = __builtin_memcpy(eax_12 + eax_13, (char*)edx_5 + 0x10, 
004091a6                              ebx_2 >> 2 << 2);
004091b1                          eax_13 += ebx_2;
004091b3                          __builtin_memcpy(edi_4, esi_4, ebx_2 & 3);
004091bc                          bool cond:2_1 = var_8_1 != 1;
004091bd                          var_10_2 += 0x10;
004091c1                          var_8_1 -= 1;
004091c1                          
004091c5                          if (!cond:2_1)
004091c5                              break;
004091c5                          
0040918c                          ecx_10 = var_10_2;
00409190                      }
00409190                      
004091c7                      ebx_1 = arg1;
004091cb                      esi_2 = var_c_1;
00409177                  }
00409177                  
004091d9                  void*** ebp_5 = (char*)ebp_3 - (esi_2 << 4);
004091e0                  edi_1 = var_c_1;
004091e7                  *(uint32_t*)ebp_5 = sub_405f60(ebx_1, eax_12, eax_13);
004091ea                  ebp_5[2] = 4;
004090e4              }
004090ae          }
004090ae          else if (!sub_409230(ebx_1, (char*)ebp_3 - 0x20, (char*)ebp_3 - 0x10, 
004090ae                  (char*)ebp_3 - 0x20, 0xf))
004090cf              sub_40ba20(ebx_1, (char*)ebp_3 - 0x20, (char*)ebp_3 - 0x10);
004090cf          
00409207          i = arg2 + 1 - edi_1;
0040920e          arg2 = i;
00409212          arg3 += 1 - edi_1;
00409216      } while (i > 1);
00409216      
00409223      return i;
00409060  }

00409224              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00409230    int32_t sub_409230(void* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4, int32_t arg5)

00409230  {
00409243      void* eax = sub_407540(arg1, arg2, arg5);
00409243      
00409254      if (!*(uint32_t*)((char*)eax + 8))
00409259          eax = sub_407540(arg1, arg3, arg5);
00409259      
00409265      if (*(uint32_t*)((char*)eax + 8) != 6)
0040926d          return 0;
0040926d      
00409277      sub_408ab0(arg1, arg4, eax, arg2, arg3);
00409288      return 1;
00409230  }

00409289                             90 90 90 90 90 90 90                                                           .......

00409290    void sub_409290(void* arg1, int32_t arg2)

00409290  {
004092a5      while (true)
004092a5      {
004092a5          void* var_64_1 = *(uint32_t*)((char*)arg1 + 0x18);
004092af          double* var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
004092b3          void* eax_2 = **(uint32_t**)(*(uint32_t*)((char*)arg1 + 0x14) + 4);
004092bf          double* var_5c_1 = *(uint32_t*)(*(uint32_t*)((char*)eax_2 + 0x10) + 8);
004092bf          
004092c7          while (true)
004092c7          {
004092c7              int32_t* edi_1 = var_64_1;
004092cb              double* eax_3;
004092cb              (uint8_t)eax_3 = *(uint8_t*)((char*)arg1 + 0x36);
004092ce              int32_t esi_1 = *(uint32_t*)edi_1;
004092d5              var_64_1 = &edi_1[1];
004092d5              
004092d9              if (!((uint8_t)eax_3 & 0xc))
004092d9                  goto label_40930d;
004092d9              
004092db              int32_t ecx_3 = *(uint32_t*)((char*)arg1 + 0x3c);
004092df              *(uint32_t*)((char*)arg1 + 0x3c) = ecx_3 - 1;
004092df              
004092e6              if (ecx_3 != 1 && !((uint8_t)eax_3 & 4))
004092e2                  goto label_40930d;
004092e2              
004092ea              sub_40a3d0(arg1, &edi_1[1]);
004092ea              
004092f7              if (*(uint8_t*)((char*)arg1 + 6) == 1)
0040a327                  *(uint32_t*)((char*)arg1 + 0x18) = edi_1;
004092f7              else
004092f7              {
00409300                  var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
0040930d              label_40930d:
0040930d                  uint32_t eax_7 = (uint32_t)(uint8_t)(esi_1 >> 6);
0040931d                  void** edi_3 = &var_60_1[eax_7 * 2];
00409322                  eax_3 = esi_1 & 0x3f;
00409328                  int32_t var_74_10;
00409328                  double* eax_10;
00409328                  int32_t eax_89;
00409328                  int32_t esi_3;
00409328                  void* esi_38;
00409328                  
00409328                  if (eax_3 > 0x25)
00409328                      continue;
00409328                  else
0040932a                      switch (eax_3)
0040932a                      {
00409331                          case nullptr:
00409331                          {
00409331                              eax_10 = var_60_1;
00409338                              esi_3 = esi_1 >> 0x17 << 4;
00409347                          label_409347:
00409347                              void* esi_5 = esi_3 + eax_10;
0040934b                              *(uint32_t*)edi_3 = *(uint32_t*)esi_5;
00409350                              edi_3[1] = *(uint32_t*)((char*)esi_5 + 4);
00409356                              edi_3[2] = *(uint32_t*)((char*)esi_5 + 8);
00409359                              continue;
00409331                          }
0040933d                          case 1:
0040933d                          {
0040933d                              eax_10 = var_5c_1;
00409344                              esi_3 = esi_1 >> 0xe << 4;
00409344                              goto label_409347;
0040933d                          }
00409360                          case 2:
00409360                          {
00409360                              edi_3[2] = 1;
00409370                              *(uint32_t*)edi_3 = esi_1 >> 0x17;
00409370                              
00409372                              if (!(esi_1 & 0x7fc000))
00409372                                  continue;
00409372                              else
00409372                              {
00409378                                  var_64_1 += 4;
0040937d                                  continue;
00409372                              }
00409360                              break;
00409360                          }
0040938c                          case 3:
0040938c                          {
0040938c                              void* esi_8 = &var_60_1[(esi_1 >> 0x17) * 2];
0040938c                              
00409398                              do
00409398                              {
00409390                                  *(uint32_t*)((char*)esi_8 + 8) = 0;
00409393                                  esi_8 -= 0x10;
00409398                              } while (esi_8 >= edi_3);
00409398                              
00409398                              continue;
0040938c                          }
004093aa                          case 4:
004093aa                          {
004093aa                              int32_t* eax_13 = *(uint32_t*)(
004093aa                                  *(uint32_t*)((char*)eax_2 + (esi_1 >> 0x17 << 2) + 0x14)
004093aa                                  + 8);
004093af                              *(uint32_t*)edi_3 = *(uint32_t*)eax_13;
004093b4                              edi_3[1] = eax_13[1];
004093ba                              edi_3[2] = eax_13[2];
004093bd                              continue;
004093aa                          }
004093cd                          case 5:
004093cd                          {
004093cd                              int32_t edx_7 = *(uint32_t*)((char*)eax_2 + 0xc);
004093d0                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
004093e4                              int32_t var_28 = edx_7;
004093e8                              int32_t var_20_1 = 5;
004093f0                              sub_4089c0(arg1, &var_28, &var_5c_1[(esi_1 >> 0xe) * 2], 
004093f0                                  edi_3);
004093fb                              var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
004093ff                              continue;
004093cd                          }
00409408                          case 6:
00409408                          {
00409408                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409413                              int32_t eax_20;
00409413                              double* ecx_10;
00409413                              
00409413                              if (!(esi_1 & &__dos_header))
00409413                              {
00409426                                  ecx_10 = var_60_1;
00409432                                  eax_20 = (esi_1 >> 0xe & 0x1ff) << 4;
00409413                              }
00409413                              else
00409413                              {
00409415                                  ecx_10 = var_5c_1;
00409421                                  eax_20 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
00409413                              }
00409413                              
00409447                              sub_4089c0(arg1, &var_60_1[(esi_1 >> 0x17) * 2], 
00409447                                  eax_20 + ecx_10, edi_3);
00409452                              var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
00409456                              continue;
00409408                          }
0040946a                          case 7:
0040946a                          {
0040946a                              int32_t var_18 = *(uint32_t*)((char*)eax_2 + 0xc);
0040947e                              int32_t var_10_1 = 5;
00409486                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409489                              sub_408b60(arg1, &var_18, &var_5c_1[(esi_1 >> 0xe) * 2], 
00409489                                  edi_3);
00409494                              var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
00409498                              continue;
0040946a                          }
004094a6                          case 8:
004094a6                          {
004094a6                              void* esi_20 =
004094a6                                  *(uint32_t*)((char*)eax_2 + (esi_1 >> 0x17 << 2) + 0x14);
004094aa                              void** eax_26 = *(uint32_t*)((char*)esi_20 + 8);
004094ad                              *(uint32_t*)eax_26 = *(uint32_t*)edi_3;
004094b2                              eax_26[1] = edi_3[1];
004094b8                              eax_26[2] = edi_3[2];
004094b8                              
004094c1                              if (edi_3[2] < 4)
004094c1                                  continue;
004094c1                              else
004094c1                              {
004094c7                                  void* edi_5 = *(uint32_t*)edi_3;
004094c7                                  
004094cd                                  if (!(*(uint8_t*)((char*)edi_5 + 5) & 3))
004094cd                                      continue;
004094cd                                  else if (!(*(uint8_t*)((char*)esi_20 + 5) & 4))
004094d7                                      continue;
004094d7                                  else
004094d7                                  {
004094e0                                      sub_404b60(arg1, esi_20, edi_5);
004094e8                                      continue;
004094d7                                  }
004094c1                              }
004094a6                              break;
004094a6                          }
004094f1                          case 9:
004094f1                          {
004094f1                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
004094fc                              int32_t eax_31;
004094fc                              double* ecx_15;
004094fc                              
004094fc                              if (!(esi_1 & &__dos_header))
004094fc                              {
0040950f                                  ecx_15 = var_60_1;
0040951b                                  eax_31 = (esi_1 >> 0xe & 0x1ff) << 4;
004094fc                              }
004094fc                              else
004094fc                              {
004094fe                                  ecx_15 = var_5c_1;
0040950a                                  eax_31 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
004094fc                              }
004094fc                              
00409526                              double* ecx_16;
00409526                              int32_t esi_23;
00409526                              
00409526                              if (!(esi_1 & 0x80000000))
00409526                              {
0040953a                                  ecx_16 = var_60_1;
00409541                                  esi_23 = esi_1 >> 0x17 << 4;
00409526                              }
00409526                              else
00409526                              {
00409528                                  ecx_16 = var_5c_1;
00409535                                  esi_23 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
00409526                              }
00409526                              
0040954a                              sub_408b60(arg1, edi_3, esi_23 + ecx_16, eax_31 + ecx_15);
00409555                              var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
00409559                              continue;
004094f1                          }
0040956a                          case 0xa:
0040956a                          {
0040956a                              int32_t eax_35 = sub_408340(esi_1 >> 0xe & 0x1ff);
00409586                              *(uint32_t*)edi_3 =
00409586                                  sub_407b30(arg1, sub_408340(esi_1 >> 0x17), eax_35);
0040958c                              edi_3[2] = 5;
00409596                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
0040a121                          label_40a121:
0040a121                              eax_3 = *(uint32_t*)((char*)arg1 + 0x10);
0040a121                              
0040a12c                              if (*(uint32_t*)((char*)eax_3 + 0x44) >= eax_3[8])
0040a12f                                  sub_403f70(arg1);
0040a12f                              
0040a13a                              var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
0040a13e                              continue;
0040956a                          }
0040959e                          case 0xb:
0040959e                          {
0040959e                              double* ecx_18 = var_60_1;
004095aa                              void* eax_42 = &ecx_18[(esi_1 >> 0x17) * 2];
004095b4                              edi_3[4] = *(uint32_t*)eax_42;
004095ba                              edi_3[5] = *(uint32_t*)((char*)eax_42 + 4);
004095c0                              edi_3[6] = *(uint32_t*)((char*)eax_42 + 8);
004095c7                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
004095ca                              int32_t esi_29;
004095ca                              
004095ca                              if (!(esi_1 & &__dos_header))
004095e7                                  esi_29 = (esi_1 >> 0xe & 0x1ff) << 4;
004095ca                              else
004095ca                              {
004095cc                                  ecx_18 = var_5c_1;
004095d9                                  esi_29 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
004095ca                              }
004095ca                              
004095f0                              sub_4089c0(arg1, eax_42, esi_29 + ecx_18, edi_3);
004095fb                              var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
004095ff                              continue;
0040959e                          }
0040960c                          case 0xc:
0040960c                          {
0040960c                              int32_t eax_46;
0040960c                              double* ecx_19;
0040960c                              
0040960c                              if (!(esi_1 & 0x80000000))
0040960c                              {
0040961f                                  ecx_19 = var_60_1;
00409626                                  eax_46 = esi_1 >> 0x17 << 4;
0040960c                              }
0040960c                              else
0040960c                              {
0040960e                                  ecx_19 = var_5c_1;
0040961a                                  eax_46 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
0040960c                              }
0040960c                              
00409629                              eax_3 = eax_46 + ecx_19;
00409631                              double* ecx_20;
00409631                              int32_t esi_35;
00409631                              
00409631                              if (!(esi_1 & &__dos_header))
00409631                              {
00409645                                  ecx_20 = var_60_1;
00409652                                  esi_35 = (esi_1 >> 0xe & 0x1ff) << 4;
00409631                              }
00409631                              else
00409631                              {
00409633                                  ecx_20 = var_5c_1;
00409640                                  esi_35 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
00409631                              }
00409631                              
00409658                              esi_38 = esi_35 + ecx_20;
00409658                              
00409666                              if (eax_3[1] == 3 && *(uint32_t*)((char*)esi_38 + 8) == 3)
00409666                              {
0040966a                                  long double x87_r7_3 = (long double)*(uint64_t*)esi_38
0040966a                                      + (long double)*(uint64_t*)eax_3;
0040966c                                  edi_3[2] = 3;
0040966f                                  *(uint64_t*)edi_3 = (double)x87_r7_3;
00409671                                  continue;
00409666                              }
00409666                              
0040967a                              var_74_10 = 5;
0040967c                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409957                          label_409957:
00409957                              sub_40a510(arg1, edi_3, eax_3, esi_38, var_74_10);
00409962                              var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
00409966                              continue;
0040960c                          }
0040968c                          case 0xd:
0040968c                          {
0040968c                              int32_t eax_51;
0040968c                              double* ecx_22;
0040968c                              
0040968c                              if (!(esi_1 & 0x80000000))
0040968c                              {
0040969f                                  ecx_22 = var_60_1;
004096a6                                  eax_51 = esi_1 >> 0x17 << 4;
0040968c                              }
0040968c                              else
0040968c                              {
0040968e                                  ecx_22 = var_5c_1;
0040969a                                  eax_51 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
0040968c                              }
0040968c                              
004096a9                              eax_3 = eax_51 + ecx_22;
004096b1                              double* ecx_23;
004096b1                              int32_t esi_41;
004096b1                              
004096b1                              if (!(esi_1 & &__dos_header))
004096b1                              {
004096c5                                  ecx_23 = var_60_1;
004096d2                                  esi_41 = (esi_1 >> 0xe & 0x1ff) << 4;
004096b1                              }
004096b1                              else
004096b1                              {
004096b3                                  ecx_23 = var_5c_1;
004096c0                                  esi_41 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
004096b1                              }
004096b1                              
004096d8                              esi_38 = esi_41 + ecx_23;
004096d8                              
004096e6                              if (eax_3[1] != 3 || *(uint32_t*)((char*)esi_38 + 8) != 3)
004096e6                              {
004096fa                                  var_74_10 = 6;
004096fc                                  *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
004096ff                                  goto label_409957;
004096e6                              }
004096e6                              
004096ea                              long double x87_r7_5 = (long double)*(uint64_t*)eax_3
004096ea                                  - (long double)*(uint64_t*)esi_38;
004096ec                              edi_3[2] = 3;
004096ef                              *(uint64_t*)edi_3 = (double)x87_r7_5;
004096f1                              continue;
0040968c                          }
0040970c                          case 0xe:
0040970c                          {
0040970c                              int32_t eax_56;
0040970c                              double* ecx_25;
0040970c                              
0040970c                              if (!(esi_1 & 0x80000000))
0040970c                              {
0040971f                                  ecx_25 = var_60_1;
00409726                                  eax_56 = esi_1 >> 0x17 << 4;
0040970c                              }
0040970c                              else
0040970c                              {
0040970e                                  ecx_25 = var_5c_1;
0040971a                                  eax_56 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
0040970c                              }
0040970c                              
00409729                              eax_3 = eax_56 + ecx_25;
00409731                              double* ecx_26;
00409731                              int32_t esi_46;
00409731                              
00409731                              if (!(esi_1 & &__dos_header))
00409731                              {
00409745                                  ecx_26 = var_60_1;
00409752                                  esi_46 = (esi_1 >> 0xe & 0x1ff) << 4;
00409731                              }
00409731                              else
00409731                              {
00409733                                  ecx_26 = var_5c_1;
00409740                                  esi_46 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
00409731                              }
00409731                              
00409758                              esi_38 = esi_46 + ecx_26;
00409758                              
00409766                              if (eax_3[1] != 3 || *(uint32_t*)((char*)esi_38 + 8) != 3)
00409766                              {
0040977a                                  var_74_10 = 7;
0040977c                                  *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
0040977f                                  goto label_409957;
00409766                              }
00409766                              
0040976a                              long double x87_r7_7 = (long double)*(uint64_t*)esi_38
0040976a                                  * (long double)*(uint64_t*)eax_3;
0040976c                              edi_3[2] = 3;
0040976f                              *(uint64_t*)edi_3 = (double)x87_r7_7;
00409771                              continue;
0040970c                          }
0040978c                          case 0xf:
0040978c                          {
0040978c                              int32_t eax_61;
0040978c                              double* ecx_28;
0040978c                              
0040978c                              if (!(esi_1 & 0x80000000))
0040978c                              {
0040979f                                  ecx_28 = var_60_1;
004097a6                                  eax_61 = esi_1 >> 0x17 << 4;
0040978c                              }
0040978c                              else
0040978c                              {
0040978e                                  ecx_28 = var_5c_1;
0040979a                                  eax_61 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
0040978c                              }
0040978c                              
004097a9                              eax_3 = eax_61 + ecx_28;
004097b1                              double* ecx_29;
004097b1                              int32_t esi_51;
004097b1                              
004097b1                              if (!(esi_1 & &__dos_header))
004097b1                              {
004097c5                                  ecx_29 = var_60_1;
004097d2                                  esi_51 = (esi_1 >> 0xe & 0x1ff) << 4;
004097b1                              }
004097b1                              else
004097b1                              {
004097b3                                  ecx_29 = var_5c_1;
004097c0                                  esi_51 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
004097b1                              }
004097b1                              
004097d8                              esi_38 = esi_51 + ecx_29;
004097d8                              
004097e6                              if (eax_3[1] != 3 || *(uint32_t*)((char*)esi_38 + 8) != 3)
004097e6                              {
004097fa                                  var_74_10 = 8;
004097fc                                  *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
004097ff                                  goto label_409957;
004097e6                              }
004097e6                              
004097ea                              long double x87_r7_9 = (long double)*(uint64_t*)eax_3
004097ea                                  / (long double)*(uint64_t*)esi_38;
004097ec                              edi_3[2] = 3;
004097ef                              *(uint64_t*)edi_3 = (double)x87_r7_9;
004097f1                              continue;
0040978c                          }
0040980c                          case 0x10:
0040980c                          {
0040980c                              int32_t eax_66;
0040980c                              double* ecx_31;
0040980c                              
0040980c                              if (!(esi_1 & 0x80000000))
0040980c                              {
0040981f                                  ecx_31 = var_60_1;
00409826                                  eax_66 = esi_1 >> 0x17 << 4;
0040980c                              }
0040980c                              else
0040980c                              {
0040980e                                  ecx_31 = var_5c_1;
0040981a                                  eax_66 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
0040980c                              }
0040980c                              
00409829                              int32_t* eax_68 = eax_66 + ecx_31;
00409831                              double* ecx_32;
00409831                              int32_t esi_56;
00409831                              
00409831                              if (!(esi_1 & &__dos_header))
00409831                              {
00409845                                  ecx_32 = var_60_1;
00409852                                  esi_56 = (esi_1 >> 0xe & 0x1ff) << 4;
00409831                              }
00409831                              else
00409831                              {
00409833                                  ecx_32 = var_5c_1;
00409840                                  esi_56 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
00409831                              }
00409831                              
00409858                              void* esi_59 = esi_56 + ecx_32;
00409858                              
00409866                              if (eax_68[2] != 3 || *(uint32_t*)((char*)esi_59 + 8) != 3)
00409866                              {
004098b8                                  *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
004098bb                                  sub_40a510(arg1, edi_3, eax_68, esi_59, 9);
004098c6                                  var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
004098ca                                  continue;
00409866                              }
00409866                              
00409868                              int32_t ecx_33 = *(uint32_t*)eax_68;
0040986d                              int32_t eax_69 = *(uint32_t*)esi_59;
00409876                              int32_t var_34_1 = eax_68[1];
00409882                              int32_t var_3c_1 = *(uint32_t*)((char*)esi_59 + 4);
0040988d                              void* var_78;
0040988d                              var_78 = (double)((long double)ecx_33 / (long double)eax_69);
00409890                              long double st0_1;
00409890                              st0_1 = sub_41803f(var_78);
0040989c                              edi_3[2] = 3;
004098a7                              *(uint64_t*)edi_3 = (double)((long double)ecx_33
004098a7                                  - st0_1 * (long double)eax_69);
004098a9                              continue;
0040980c                          }
004098d7                          case 0x11:
004098d7                          {
004098d7                              uint32_t eax_73;
004098d7                              double* ecx_35;
004098d7                              
004098d7                              if (!(esi_1 & 0x80000000))
004098d7                              {
004098ea                                  ecx_35 = var_60_1;
004098f1                                  eax_73 = esi_1 >> 0x17 << 4;
004098d7                              }
004098d7                              else
004098d7                              {
004098d9                                  ecx_35 = var_5c_1;
004098e5                                  eax_73 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
004098d7                              }
004098d7                              
004098f4                              eax_3 = eax_73 + ecx_35;
004098fc                              double* ecx_36;
004098fc                              int32_t esi_62;
004098fc                              
004098fc                              if (!(esi_1 & &__dos_header))
004098fc                              {
00409910                                  ecx_36 = var_60_1;
0040991d                                  esi_62 = (esi_1 >> 0xe & 0x1ff) << 4;
004098fc                              }
004098fc                              else
004098fc                              {
004098fe                                  ecx_36 = var_5c_1;
0040990b                                  esi_62 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
004098fc                              }
004098fc                              
00409923                              esi_38 = esi_62 + ecx_36;
00409923                              
00409931                              if (eax_3[1] != 3 || *(uint32_t*)((char*)esi_38 + 8) != 3)
00409931                              {
0040994e                                  var_74_10 = 0xa;
00409950                                  *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409950                                  goto label_409957;
00409931                              }
00409931                              
00409937                              long double st0_2;
00409937                              st0_2 = sub_418110((long double)*(uint64_t*)esi_38, 
00409937                                  (long double)*(uint64_t*)eax_3);
0040993c                              *(uint64_t*)edi_3 = (double)st0_2;
0040993e                              edi_3[2] = 3;
00409945                              continue;
004098d7                          }
0040997a                          case 0x12:
0040997a                          {
0040997a                              void* esi_67 = &var_60_1[(esi_1 >> 0x17) * 2];
0040997a                              
0040997f                              if (*(uint32_t*)((char*)esi_67 + 8) != 3)
0040997f                              {
00409999                                  *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
0040999c                                  sub_40a510(arg1, edi_3, esi_67, esi_67, 0xb);
004099a7                                  var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
004099ab                                  continue;
0040997f                              }
0040997f                              else
0040997f                              {
00409985                                  *(uint64_t*)edi_3 =
00409985                                      (double)-((long double)*(uint64_t*)esi_67);
00409987                                  edi_3[2] = 3;
0040998a                                  continue;
0040997f                              }
0040997a                              break;
0040997a                          }
004099ba                          case 0x13:
004099ba                          {
004099ba                              void* esi_70 = &var_60_1[(esi_1 >> 0x17) * 2];
004099bc                              int32_t eax_76 = *(uint32_t*)((char*)esi_70 + 8);
004099bc                              
004099cb                              if (eax_76 && (eax_76 != 1 || *(uint32_t*)esi_70))
004099cb                              {
004099cf                                  edi_3[2] = 1;
004099d6                                  *(uint32_t*)edi_3 = nullptr;
004099d8                                  continue;
004099cb                              }
004099cb                              
004099e2                              *(uint32_t*)edi_3 = 1;
004099e4                              edi_3[2] = 1;
004099e7                              continue;
004099ba                          }
004099f6                          case 0x14:
004099f6                          {
004099f6                              void* esi_73 = &var_60_1[(esi_1 >> 0x17) * 2];
004099f8                              int32_t eax_77 = *(uint32_t*)((char*)esi_73 + 8);
004099f8                              
004099fe                              if (eax_77 == 4)
004099fe                              {
00409a5e                                  int32_t var_2c_1 = 0;
00409a66                                  int32_t ecx_41 = *(uint32_t*)(*(uint32_t*)esi_73 + 0xc);
00409a69                                  edi_3[2] = 3;
00409a78                                  *(uint64_t*)edi_3 = (double)(long double)ecx_41;
00409a7a                                  continue;
004099fe                              }
004099fe                              else if (eax_77 == 5)
00409a01                              {
00409a4a                                  long double x87_r7_19 =
00409a4a                                      (long double)sub_4081f0(*(uint32_t*)esi_73);
00409a4e                                  edi_3[2] = 3;
00409a55                                  *(uint64_t*)edi_3 = (double)x87_r7_19;
00409a57                                  continue;
00409a01                              }
00409a01                              else
00409a01                              {
00409a11                                  *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409a14                                  int32_t ecx_39;
00409a14                                  int32_t edx_31;
00409a14                                  eax_3 =
00409a14                                      sub_409230(arg1, esi_73, &data_428330, edi_3, 0xc);
00409a14                                  
00409a1e                                  if (!eax_3)
00409a27                                      sub_40b960(eax_3, edx_31, ecx_39, arg1, esi_73, 
00409a27                                          "get length of");
00409a27                                  
00409a32                                  var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
00409a36                                  continue;
00409a01                              }
004099f6                              break;
004099f6                          }
00409a88                          case 0x15:
00409a88                          {
00409a88                              int32_t esi_75 = esi_1 >> 0xe & 0x1ff;
00409a8e                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409a91                              uint32_t edi_7 = esi_1 >> 0x17;
00409a9a                              sub_409060(arg1, esi_75 - edi_7 + 1, esi_75);
00409a9f                              void* eax_81 = *(uint32_t*)((char*)arg1 + 0x10);
00409a9f                              
00409aad                              if (*(uint32_t*)((char*)eax_81 + 0x44)
00409aad                                      >= *(uint32_t*)((char*)eax_81 + 0x40))
00409ab0                                  sub_403f70(arg1);
00409ab0                              
00409ab8                              eax_3 = *(uint32_t*)((char*)arg1 + 0xc);
00409ac2                              void* edi_9 = &eax_3[edi_7 * 2];
00409ac4                              var_60_1 = eax_3;
00409aca                              eax_3[eax_7 * 2] = *(uint32_t*)edi_9;
00409ad0                              *(uint32_t*)(&eax_3[eax_7 * 2] + 4) =
00409ad0                                  *(uint32_t*)((char*)edi_9 + 4);
00409ad7                              eax_3[eax_7 * 2 + 1] = *(uint32_t*)((char*)edi_9 + 8);
00409adb                              continue;
00409a88                          }
00409ec5                          case 0x16:
00409ec5                          {
00409ec5                              var_64_1 = (char*)var_64_1 + (esi_1 >> 0xe << 2) - 0x7fffc;
00409ec9                              continue;
00409ec5                          }
00409ae8                          case 0x17:
00409ae8                          {
00409ae8                              uint32_t eax_85;
00409ae8                              double* ecx_44;
00409ae8                              
00409ae8                              if (!(esi_1 & 0x80000000))
00409ae8                              {
00409afb                                  ecx_44 = var_60_1;
00409b02                                  eax_85 = esi_1 >> 0x17 << 4;
00409ae8                              }
00409ae8                              else
00409ae8                              {
00409aea                                  ecx_44 = var_5c_1;
00409af6                                  eax_85 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
00409ae8                              }
00409ae8                              
00409b05                              void* eax_87 = eax_85 + ecx_44;
00409b0d                              double* ecx_45;
00409b0d                              int32_t esi_80;
00409b0d                              
00409b0d                              if (!(esi_1 & &__dos_header))
00409b0d                              {
00409b21                                  ecx_45 = var_60_1;
00409b2e                                  esi_80 = (esi_1 >> 0xe & 0x1ff) << 4;
00409b0d                              }
00409b0d                              else
00409b0d                              {
00409b0f                                  ecx_45 = var_5c_1;
00409b1c                                  esi_80 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
00409b0d                              }
00409b0d                              
00409b35                              int32_t* esi_83 = esi_80 + ecx_45;
00409b37                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409b40                              int32_t eax_88;
00409b40                              
00409b40                              if (*(uint32_t*)((char*)eax_87 + 8) == esi_83[2])
00409b45                                  eax_88 = sub_408ec0(arg1, eax_87, esi_83);
00409b45                              
00409b4f                              if (*(uint32_t*)((char*)eax_87 + 8) != esi_83[2] || !eax_88)
00409b5b                                  eax_89 = 0;
00409b4f                              else
00409b51                                  eax_89 = 1;
00409b51                              
00409b0d                              goto label_409c61;
00409ae8                          }
00409b6e                          case 0x18:
00409b6e                          {
00409b6e                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409b71                              int32_t eax_93;
00409b71                              double* ecx_47;
00409b71                              
00409b71                              if (!(esi_1 & &__dos_header))
00409b71                              {
00409b84                                  ecx_47 = var_60_1;
00409b90                                  eax_93 = (esi_1 >> 0xe & 0x1ff) << 4;
00409b71                              }
00409b71                              else
00409b71                              {
00409b73                                  ecx_47 = var_5c_1;
00409b7f                                  eax_93 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
00409b71                              }
00409b71                              
00409b9b                              double* ecx_48;
00409b9b                              int32_t esi_86;
00409b9b                              
00409b9b                              if (!(esi_1 & 0x80000000))
00409b9b                              {
00409baf                                  ecx_48 = var_60_1;
00409bb6                                  esi_86 = esi_1 >> 0x17 << 4;
00409b9b                              }
00409b9b                              else
00409b9b                              {
00409b9d                                  ecx_48 = var_5c_1;
00409baa                                  esi_86 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
00409b9b                              }
00409b9b                              
00409bcc                              if (sub_408d20(arg1, esi_86 + ecx_48, eax_93 + ecx_47)
00409bcc                                      == eax_7)
00409bde                                  var_64_1 = (char*)var_64_1
00409bde                                      + (*(uint32_t*)var_64_1 >> 0xe << 2) - 0x7fffc;
00409bde                              
00409be5                              var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
00409bf0                              var_64_1 += 4;
00409bf4                              continue;
00409b6e                          }
00409c05                          case 0x19:
00409c05                          {
00409c05                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409c08                              int32_t eax_104;
00409c08                              double* ecx_53;
00409c08                              
00409c08                              if (!(esi_1 & &__dos_header))
00409c08                              {
00409c1b                                  ecx_53 = var_60_1;
00409c27                                  eax_104 = (esi_1 >> 0xe & 0x1ff) << 4;
00409c08                              }
00409c08                              else
00409c08                              {
00409c0a                                  ecx_53 = var_5c_1;
00409c16                                  eax_104 = (uint32_t)(uint8_t)(esi_1 >> 0xe) << 4;
00409c08                              }
00409c08                              
00409c32                              double* ecx_54;
00409c32                              int32_t esi_91;
00409c32                              
00409c32                              if (!(esi_1 & 0x80000000))
00409c32                              {
00409c46                                  ecx_54 = var_60_1;
00409c4d                                  esi_91 = esi_1 >> 0x17 << 4;
00409c32                              }
00409c32                              else
00409c32                              {
00409c34                                  ecx_54 = var_5c_1;
00409c41                                  esi_91 = (uint32_t)(uint8_t)(esi_1 >> 0x17) << 4;
00409c32                              }
00409c32                              
00409c55                              eax_89 = sub_40a460(arg1, esi_91 + ecx_54, eax_104 + ecx_53);
00409c61                          label_409c61:
00409c61                              
00409c61                              if (eax_89 == eax_7)
00409c73                                  var_64_1 = (char*)var_64_1
00409c73                                      + (*(uint32_t*)var_64_1 >> 0xe << 2) - 0x7fffc;
00409c73                              
00409c81                              var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
00409c85                              var_64_1 += 4;
00409c89                              continue;
00409c05                          }
00409c8e                          case 0x1a:
00409c8e                          {
00409c8e                              int32_t eax_111 = edi_3[2];
00409c8e                              
00409c9d                              if (!eax_111 || (eax_111 == 1 && !*(uint32_t*)edi_3))
00409ca3                                  eax_3 = 1;
00409c9d                              else
00409c9f                                  eax_3 = nullptr;
00409c9f                              
00409cb3                              if (eax_3 == (esi_1 >> 0xe & 0x1ff))
00409cb3                              {
00409f6e                                  var_64_1 += 4;
00409f73                                  continue;
00409cb3                              }
00409cb3                              
00409cc2                              void* eax_113 = (char*)var_64_1
00409cc2                                  + (*(uint32_t*)var_64_1 >> 0xe << 2) - 0x7fffc;
00409cc9                              void* var_64_2 = eax_113;
00409cd0                              var_64_1 = (char*)eax_113 + 4;
00409cd4                              continue;
00409c8e                          }
00409ce5                          case 0x1b:
00409ce5                          {
00409ce5                              eax_3 = &var_60_1[(esi_1 >> 0x17) * 2];
00409ce7                              int32_t ecx_57 = eax_3[1];
00409cf6                              int32_t ecx_58;
00409cf6                              
00409cf6                              if (!ecx_57 || (ecx_57 == 1 && !*(uint32_t*)eax_3))
00409cfc                                  ecx_58 = 1;
00409cf6                              else
00409cf8                                  ecx_58 = 0;
00409cf8                              
00409d0c                              if (ecx_58 != (esi_1 >> 0xe & 0x1ff))
00409d0c                              {
00409d10                                  *(uint32_t*)edi_3 = *(uint32_t*)eax_3;
00409d15                                  edi_3[1] = *(uint32_t*)((char*)eax_3 + 4);
00409d1b                                  edi_3[2] = eax_3[1];
00409d1e                                  eax_3 = var_64_1;
00409d2e                                  var_64_1 = (char*)eax_3 + (*(uint32_t*)eax_3 >> 0xe << 2)
00409d2e                                      - 0x7fffc;
00409d0c                              }
00409d0c                              
00409d32                              var_64_1 += 4;
00409d37                              continue;
00409ce5                          }
00409d47                          case 0x1c:
00409d47                          {
00409d47                              uint32_t eax_119 = esi_1 >> 0x17;
00409d47                              
00409d4d                              if (eax_119)
00409d54                                  *(uint32_t*)((char*)arg1 + 8) = &edi_3[eax_119 * 4];
00409d54                              
00409d5e                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409d61                              int32_t eax_123 =
00409d61                                  sub_405560(arg1, edi_3, (esi_1 >> 0xe & 0x1ff) - 1);
00409d61                              
00409d6c                              if (!eax_123)
00409d6c                              {
0040a223                                  arg2 += 1;
0040a226                                  break;
00409d6c                              }
00409d6c                              
00409d73                              if (eax_123 == 1)
00409d73                              {
00409d7b                                  if ((esi_1 >> 0xe & 0x1ff) - 1 >= 0)
00409d83                                      *(uint32_t*)((char*)arg1 + 8) = *
00409d83                                          (uint32_t*)(*(uint32_t*)((char*)arg1 + 0x14) + 8);
00409d83                                  
00409d89                                  var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
00409d8d                                  continue;
00409d73                              }
00409d47                              break;
00409d47                          }
00409d92                          case 0x1d:
00409d92                          {
00409d92                              uint32_t esi_101 = esi_1 >> 0x17;
00409d92                              
00409d95                              if (esi_101)
00409d9c                                  *(uint32_t*)((char*)arg1 + 8) = &edi_3[esi_101 * 4];
00409d9c                              
00409da7                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409daa                              int32_t eax_126 = sub_405560(arg1, edi_3, 0xffffffff);
00409daa                              
00409db5                              if (!eax_126)
00409db5                              {
0040a231                                  int32_t* esi_125 =
0040a231                                      *(uint32_t*)((char*)arg1 + 0x14) - 0x18;
0040a236                                  int32_t ecx_97 = esi_125[1];
0040a239                                  int32_t* i_2 = esi_125[7];
0040a239                                  
0040a240                                  if (*(uint32_t*)((char*)arg1 + 0x68))
0040a246                                      sub_404f10(arg1, *(uint32_t*)esi_125);
0040a246                                  
0040a256                                  int32_t var_54_8 = 0;
0040a264                                  int32_t eax_181 =
0040a264                                      ((esi_125[6] - i_2) >> 4 << 4) + esi_125[1];
0040a266                                  *(uint32_t*)esi_125 = eax_181;
0040a268                                  *(uint32_t*)((char*)arg1 + 0xc) = eax_181;
0040a268                                  
0040a26e                                  if (i_2 < *(uint32_t*)((char*)arg1 + 8))
0040a26e                                  {
0040a274                                      int32_t* i_1 = i_2;
0040a276                                      int32_t* i = i_2;
0040a278                                      int32_t* edx_85 = ecx_97 - i_2;
0040a278                                      
0040a2a0                                      do
0040a2a0                                      {
0040a27c                                          *(uint32_t*)((char*)edx_85 + i) = *(uint32_t*)i_1;
0040a282                                          *(uint32_t*)((char*)edx_85 + i + 4) = i_1[1];
0040a28e                                          *(uint32_t*)((char*)edx_85 + i + 8) = i_1[2];
0040a292                                          var_54_8 += 1;
0040a299                                          i = &i[4];
0040a29e                                          i_1 = i;
0040a2a0                                      } while (i < *(uint32_t*)((char*)arg1 + 8));
0040a26e                                  }
0040a26e                                  
0040a2ad                                  int32_t eax_184 = (var_54_8 << 4) + ecx_97;
0040a2af                                  *(uint32_t*)((char*)arg1 + 8) = eax_184;
0040a2b2                                  int32_t ecx_100 = esi_125[5];
0040a2b5                                  esi_125[2] = eax_184;
0040a2bc                                  esi_125[3] = *(uint32_t*)((char*)arg1 + 0x18);
0040a2bf                                  esi_125[5] = ecx_100 + 1;
0040a2c8                                  *(uint32_t*)((char*)arg1 + 0x14) -= 0x18;
0040a2cb                                  break;
00409db5                              }
00409db5                              
00409dbc                              if (eax_126 == 1)
00409dbc                              {
00409dc5                                  var_60_1 = *(uint32_t*)((char*)arg1 + 0xc);
00409dc9                                  continue;
00409dbc                              }
00409d92                              break;
00409d92                          }
0040a2d0                          case 0x1e:
0040a2d0                          {
0040a2d0                              uint32_t esi_126 = esi_1 >> 0x17;
0040a2d0                              
0040a2d3                              if (esi_126)
0040a2dc                                  *(uint32_t*)((char*)arg1 + 8) = &edi_3[esi_126 * 4 - 4];
0040a2dc                              
0040a2e4                              if (*(uint32_t*)((char*)arg1 + 0x68))
0040a2ec                                  sub_404f10(arg1, var_60_1);
0040a2ec                              
0040a2fa                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
0040a2fd                              void* eax_190 = sub_4059a0(arg1, edi_3);
0040a308                              bool cond:19_1 = arg2 == 1;
0040a309                              arg2 -= 1;
0040a309                              
0040a30c                              if (!cond:19_1)
0040a30c                              {
0040a310                                  if (!eax_190)
0040a310                                      break;
0040a310                                  
0040a31c                                  *(uint32_t*)((char*)arg1 + 8) =
0040a31c                                      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x14) + 8);
0040a31f                                  break;
0040a30c                              }
0040a2d0                              break;
0040a2d0                          }
00409dce                          case 0x1f:
00409dce                          {
00409dce                              long double x87_r7_21 =
00409dce                                  (long double)*(uint64_t*)((char*)edi_3 + 0x20);
00409dd5                              long double x87_r7_1 =
00409dd5                                  x87_r7_21 + (long double)*(uint64_t*)edi_3;
00409dd7                              long double x87_r6_2 =
00409dd7                                  (long double)*(uint64_t*)((char*)edi_3 + 0x10);
00409dda                              long double x87_r5_1 = (long double)0.0;
00409de0                              long double temp2_1 = (long double)(double)x87_r7_21;
00409de0                              x87_r5_1 - temp2_1;
00409de4                              (uint16_t)eax_3 = (x87_r5_1 < temp2_1 ? 1 : 0) << 8
00409de4                                  | (FCMP_UO(x87_r5_1, temp2_1) ? 1 : 0) << 0xa
00409de4                                  | (x87_r5_1 == temp2_1 ? 1 : 0) << 0xe | 0x3000;
00409de4                              
00409de9                              if (!(*(uint8_t*)((char*)eax_3)[1] & 1))
00409de9                              {
00409dfd                                  x87_r6_2 - x87_r7_1;
00409dff                                  (uint16_t)eax_3 = (x87_r6_2 < x87_r7_1 ? 1 : 0) << 8
00409dff                                      | (FCMP_UO(x87_r6_2, x87_r7_1) ? 1 : 0) << 0xa
00409dff                                      | (x87_r6_2 == x87_r7_1 ? 1 : 0) << 0xe | 0x3800;
00409dff                                  
00409e04                                  if (!(*(uint8_t*)((char*)eax_3)[1] & 0x41))
00409e04                                      continue;
00409de9                              }
00409de9                              else
00409de9                              {
00409ded                                  x87_r7_1 - x87_r6_2;
00409def                                  (uint16_t)eax_3 = (x87_r7_1 < x87_r6_2 ? 1 : 0) << 8
00409def                                      | (FCMP_UO(x87_r7_1, x87_r6_2) ? 1 : 0) << 0xa
00409def                                      | (x87_r7_1 == x87_r6_2 ? 1 : 0) << 0xe | 0x3000;
00409df4                                  x87_r7_1 = x87_r6_2;
00409df4                                  
00409df6                                  if (!(*(uint8_t*)((char*)eax_3)[1] & 0x41))
00409df6                                      continue;
00409de9                              }
00409de9                              
00409e0e                              *(uint64_t*)edi_3 = (double)x87_r7_1;
00409e1f                              edi_3[2] = 3;
00409e22                              var_64_1 = (char*)var_64_1 + (esi_1 >> 0xe << 2) - 0x7fffc;
00409e26                              *(uint64_t*)((char*)edi_3 + 0x30) = (double)x87_r7_1;
00409e29                              edi_3[0xe] = 3;
00409e2c                              continue;
00409dce                          }
00409e38                          case 0x20:
00409e38                          {
00409e38                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409e41                              void* var_54_2 = &edi_3[8];
00409e45                              int32_t* eax_131;
00409e45                              
00409e45                              if (edi_3[2] != 3)
00409e49                                  eax_131 = sub_408900(edi_3, edi_3);
00409e49                              
00409e53                              if (edi_3[2] == 3 || eax_131)
00409e53                              {
00409e60                                  int32_t* eax_133;
00409e60                                  
00409e60                                  if (edi_3[6] != 3)
00409e67                                      eax_133 = sub_408900(&edi_3[4], &edi_3[4]);
00409e67                                  
00409e71                                  if (edi_3[6] != 3 && !eax_133)
00409e9e                                      sub_40bb80(arg1, "'for' limit must be a number");
00409e71                                  else if (*(uint32_t*)((char*)var_54_2 + 8) != 3)
00409e82                                  {
00409e88                                      int32_t* eax_135 = sub_408900(var_54_2, var_54_2);
00409e90                                      var_54_2 = eax_135;
00409e90                                      
00409e96                                      if (!eax_135)
00409e9e                                          sub_40bb80(arg1, "'for' step must be a number");
00409e82                                  }
00409e53                              }
00409e53                              else
00409e9e                                  sub_40bb80(arg1, "'for' initial value must be a number");
00409e9e                              
00409eac                              long double x87_r7_23 = (long double)*(uint64_t*)edi_3
00409eac                                  - (long double)*(uint64_t*)var_54_2;
00409eae                              edi_3[2] = 3;
00409eb5                              *(uint64_t*)edi_3 = (double)x87_r7_23;
00409ec5                              var_64_1 = (char*)var_64_1 + (esi_1 >> 0xe << 2) - 0x7fffc;
00409ec9                              continue;
00409e38                          }
00409ed7                          case 0x21:
00409ed7                          {
00409ed7                              edi_3[0x14] = edi_3[8];
00409edd                              edi_3[0x15] = edi_3[9];
00409ee3                              edi_3[0x16] = edi_3[0xa];
00409ee9                              edi_3[0x10] = edi_3[4];
00409eef                              edi_3[0x11] = edi_3[5];
00409ef5                              edi_3[0x12] = edi_3[6];
00409efa                              edi_3[0xc] = *(uint32_t*)edi_3;
00409eff                              edi_3[0xd] = edi_3[1];
00409f0b                              edi_3[0xe] = edi_3[2];
00409f18                              *(uint32_t*)((char*)arg1 + 8) = &edi_3[0x18];
00409f1b                              *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
00409f1e                              sub_405a80(arg1, &edi_3[0xc], esi_1 >> 0xe & 0x1ff);
00409f26                              double* ecx_72 = *(uint32_t*)((char*)arg1 + 0xc);
00409f29                              var_60_1 = ecx_72;
00409f3a                              *(uint32_t*)((char*)arg1 + 8) =
00409f3a                                  *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x14) + 8);
00409f40                              eax_3 = &ecx_72[(eax_7 + 3) * 2];
00409f40                              
00409f47                              if (eax_3[1])
00409f47                              {
00409f4b                                  eax_3[-2] = *(uint32_t*)eax_3;
00409f51                                  *(uint32_t*)((char*)eax_3 - 0xc) =
00409f51                                      *(uint32_t*)((char*)eax_3 + 4);
00409f57                                  eax_3[-1] = eax_3[1];
00409f6a                                  var_64_1 = (char*)var_64_1
00409f6a                                      + (*(uint32_t*)var_64_1 >> 0xe << 2) - 0x7fffc;
00409f47                              }
00409f47                              
00409f6e                              var_64_1 += 4;
00409f73                              continue;
00409ed7                          }
00409f7d                          case 0x22:
00409f7d                          {
00409f7d                              eax_3 = esi_1 >> 0x17;
00409f80                              int32_t esi_109 = esi_1 >> 0xe & 0x1ff;
00409f86                              double* var_54_3 = eax_3;
00409f86                              
00409f8c                              if (!eax_3)
00409f8c                              {
00409f9c                                  eax_3 =
00409f9c                                      ((*(uint32_t*)((char*)arg1 + 8) - edi_3) >> 4) - 1;
00409f9d                                  *(uint32_t*)((char*)arg1 + 8) =
00409f9d                                      *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x14) + 8);
00409fa0                                  var_54_3 = eax_3;
00409f8c                              }
00409f8c                              
00409fa6                              if (!esi_109)
00409fa6                              {
00409fac                                  esi_109 = *(uint32_t*)var_64_1;
00409fb1                                  var_64_1 += 4;
00409fa6                              }
00409fa6                              
00409fb9                              if (edi_3[2] != 5)
00409fb9                                  continue;
00409fb9                              else
00409fb9                              {
00409fc3                                  void* ecx_77 = *(uint32_t*)edi_3;
00409fc5                                  int32_t eax_147 = esi_109 * 5;
00409fd8                                  int32_t var_50_1 = (char*)var_54_3 + eax_147 * 0xa - 0x32;
00409fd8                                  
00409fdc                                  if ((char*)var_54_3 + eax_147 * 0xa - 0x32
00409fdc                                          > *(uint32_t*)((char*)ecx_77 + 0x1c))
00409fe1                                      sub_407860(arg1, ecx_77, 
00409fe1                                          (char*)var_54_3 + eax_147 * 0xa - 0x32);
00409fe1                                  
00409fef                                  if (var_54_3 <= 0)
00409fef                                      continue;
00409fef                                  else
00409fef                                  {
00409ff7                                      double* var_54_4 = var_54_3;
00409ffe                                      void* esi_112 = &edi_3[var_54_3 * 4];
0040a056                                      bool cond:24_1;
0040a056                                      
0040a056                                      do
0040a056                                      {
0040a00b                                          int32_t var_74_24 = var_50_1;
0040a00e                                          var_50_1 -= 1;
0040a012                                          void* eax_151 =
0040a012                                              sub_408150(arg1, ecx_77, var_74_24);
0040a01c                                          *(uint32_t*)eax_151 = *(uint32_t*)esi_112;
0040a021                                          *(uint32_t*)((char*)eax_151 + 4) =
0040a021                                              *(uint32_t*)((char*)esi_112 + 4);
0040a027                                          *(uint32_t*)((char*)eax_151 + 8) =
0040a027                                              *(uint32_t*)((char*)esi_112 + 8);
0040a027                                          
0040a03e                                          if (*(uint32_t*)((char*)esi_112 + 8) >= 4
0040a03e                                                  && *(uint8_t*)(*(uint32_t*)esi_112 + 5)
0040a03e                                                  & 3 && *(uint8_t*)((char*)ecx_77 + 5) & 4)
0040a042                                              sub_404ba0(arg1, ecx_77);
0040a042                                          
0040a04e                                          esi_112 -= 0x10;
0040a051                                          cond:24_1 = var_54_4 != 1;
0040a052                                          var_54_4 -= 1;
0040a056                                      } while (cond:24_1);
0040a056                                      continue;
00409fef                                  }
00409fb9                              }
00409f7d                              break;
00409f7d                          }
0040a05f                          case 0x23:
0040a05f                          {
0040a05f                              sub_404f10(arg1, edi_3);
0040a067                              continue;
0040a05f                          }
0040a07b                          case 0x24:
0040a07b                          {
0040a07b                              void* esi_114 = *(uint32_t*)(
0040a07b                                  *(uint32_t*)(*(uint32_t*)((char*)eax_2 + 0x10) + 0x10)
0040a07b                                  + (esi_1 >> 0xe << 2));
0040a086                              void* ecx_83;
0040a086                              (uint8_t)ecx_83 = *(uint8_t*)((char*)esi_114 + 0x48);
0040a08d                              int32_t* eax_155 = sub_404d90(arg1, ecx_83, 
0040a08d                                  *(uint32_t*)((char*)eax_2 + 0xc));
0040a09f                              eax_155[4] = esi_114;
0040a0a2                              void* esi_116;
0040a0a2                              
0040a0a2                              if (ecx_83 <= 0)
0040a143                                  esi_116 = var_64_1;
0040a0a2                              else
0040a0a2                              {
0040a0aa                                  void* var_50_3 = ecx_83;
0040a0ae                                  esi_116 = var_64_1;
0040a0b5                                  void* var_54_5 = &eax_155[5];
0040a10b                                  bool cond:21_1;
0040a10b                                  
0040a10b                                  do
0040a10b                                  {
0040a0b9                                      int32_t eax_156 = *(uint32_t*)esi_116;
0040a0b9                                      
0040a0c3                                      if (((uint8_t)eax_156 & 0x3f) != 4)
0040a0f2                                          *(uint32_t*)var_54_5 = sub_404e30(arg1, 
0040a0f2                                              &var_60_1[(eax_156 >> 0x17) * 2]);
0040a0c3                                      else
0040a0d4                                          *(uint32_t*)var_54_5 = *(uint32_t*)((char*)eax_2
0040a0d4                                              + (eax_156 >> 0x17 << 2) + 0x14);
0040a0d4                                      
0040a0ff                                      esi_116 += 4;
0040a102                                      cond:21_1 = var_50_3 != 1;
0040a103                                      var_54_5 += 4;
0040a107                                      var_50_3 -= 1;
0040a10b                                  } while (cond:21_1);
0040a10d                                  var_64_1 = esi_116;
0040a0a2                              }
0040a0a2                              
0040a115                              edi_3[2] = 6;
0040a11c                              *(uint32_t*)edi_3 = eax_155;
0040a11e                              *(uint32_t*)((char*)arg1 + 0x18) = esi_116;
0040a11e                              goto label_40a121;
0040a07b                          }
0040a149                          case 0x25:
0040a149                          {
0040a149                              int32_t* ecx_89 = *(uint32_t*)((char*)arg1 + 0x14);
0040a153                              eax_3 = (esi_1 >> 0x17) - 1;
0040a157                              double var_48;
0040a157                              (uint32_t)var_48 = ecx_89;
0040a161                              double* var_50_4 = eax_3;
0040a16d                              int32_t ecx_91;
0040a16d                              (uint8_t)ecx_91 =
0040a16d                                  *(uint8_t*)(*(uint32_t*)((char*)eax_2 + 0x10) + 0x49);
0040a172                              double* esi_123 =
0040a172                                  ((*(uint32_t*)ecx_89 - ecx_89[1]) >> 4) - ecx_91 - 1;
0040a172                              
0040a176                              if (eax_3 == 0xffffffff)
0040a176                              {
0040a187                                  int32_t ecx_93 = *(uint32_t*)((char*)arg1 + 0x1c)
0040a187                                      - *(uint32_t*)((char*)arg1 + 8);
0040a189                                  *(uint32_t*)((char*)arg1 + 0x18) = var_64_1;
0040a189                                  
0040a192                                  if (ecx_93 <= esi_123 << 4)
0040a196                                      sub_405460(arg1, esi_123);
0040a196                                  
0040a19e                                  double* eax_168 = *(uint32_t*)((char*)arg1 + 0xc);
0040a1a9                                  var_60_1 = eax_168;
0040a1ad                                  edi_3 = &eax_168[eax_7 * 2];
0040a1b0                                  eax_3 = esi_123;
0040a1b4                                  var_50_4 = eax_3;
0040a1b8                                  *(uint32_t*)((char*)arg1 + 8) = &edi_3[esi_123 * 4];
0040a176                              }
0040a176                              
0040a1bd                              double* var_54_7 = nullptr;
0040a1bd                              
0040a1c5                              if (eax_3 <= 0)
0040a1c5                                  continue;
0040a1c5                              else
0040a1c5                              {
0040a1d7                                  void* ecx_96 = &edi_3[2];
0040a21c                                  bool cond:22_1;
0040a21c                                  
0040a21c                                  do
0040a21c                                  {
0040a1e2                                      if (var_54_7 >= esi_123)
0040a204                                          *(uint32_t*)ecx_96 = 0;
0040a1e2                                      else
0040a1e2                                      {
0040a1f0                                          int32_t* eax_173 = 0xfffffff8 - edi_3
0040a1f0                                              - (esi_123 << 4) + ecx_96
0040a1f0                                              + *(uint32_t*)(uint32_t)var_48;
0040a1f4                                          *(uint32_t*)((char*)ecx_96 - 8) =
0040a1f4                                              *(uint32_t*)eax_173;
0040a1fa                                          *(uint32_t*)((char*)ecx_96 - 4) = eax_173[1];
0040a200                                          *(uint32_t*)ecx_96 = eax_173[2];
0040a1e2                                      }
0040a1e2                                      
0040a213                                      ecx_96 += 0x10;
0040a216                                      cond:22_1 = (char*)var_54_7 + 1 < var_50_4;
0040a218                                      var_54_7 += 1;
0040a21c                                  } while (cond:22_1);
0040a21c                                  continue;
0040a1c5                              }
0040a149                              break;
0040a149                          }
0040932a                      }
004092f7              }
004092f7              
0040a330              return;
004092c7          }
004092a5      }
00409290  }

0040a331                                                     8d 49 00                                                       .I.
0040a334  uint32_t jump_table_40a334[0x26] = 
0040a334  {
0040a334      [0x00] =  0x00409331
0040a338      [0x01] =  0x0040933d
0040a33c      [0x02] =  0x0040935e
0040a340      [0x03] =  0x00409382
0040a344      [0x04] =  0x0040939f
0040a348      [0x05] =  0x004093c2
0040a34c      [0x06] =  0x00409404
0040a350      [0x07] =  0x0040945b
0040a354      [0x08] =  0x0040949d
0040a358      [0x09] =  0x004094ed
0040a35c      [0x0a] =  0x0040955e
0040a360      [0x0b] =  0x0040959e
0040a364      [0x0c] =  0x00409604
0040a368      [0x0d] =  0x00409684
0040a36c      [0x0e] =  0x00409704
0040a370      [0x0f] =  0x00409784
0040a374      [0x10] =  0x00409804
0040a378      [0x11] =  0x004098cf
0040a37c      [0x12] =  0x0040996b
0040a380      [0x13] =  0x004099b0
0040a384      [0x14] =  0x004099ec
0040a388      [0x15] =  0x00409a7f
0040a38c      [0x16] =  0x00409eb7
0040a390      [0x17] =  0x00409ae0
0040a394      [0x18] =  0x00409b62
0040a398      [0x19] =  0x00409bf9
0040a39c      [0x1a] =  0x00409c8e
0040a3a0      [0x1b] =  0x00409cd9
0040a3a4      [0x1c] =  0x00409d3c
0040a3a8      [0x1d] =  0x00409d92
0040a3ac      [0x1e] =  0x0040a2d0
0040a3b0      [0x1f] =  0x00409dce
0040a3b4      [0x20] =  0x00409e31
0040a3b8      [0x21] =  0x00409ece
0040a3bc      [0x22] =  0x00409f78
0040a3c0      [0x23] =  0x0040a05d
0040a3c4      [0x24] =  0x0040a06c
0040a3c8      [0x25] =  0x0040a149
0040a3cc  }

0040a3cc                                      90 90 90 90                                                              ....

0040a3d0    void sub_40a3d0(void* arg1, int32_t arg2)

0040a3d0  {
0040a3dc      int32_t ebx;
0040a3dc      (uint8_t)ebx = *(uint8_t*)((char*)arg1 + 0x36);
0040a3df      int32_t edi = *(uint32_t*)((char*)arg1 + 0x18);
0040a3e5      *(uint32_t*)((char*)arg1 + 0x18) = arg2;
0040a3e5      
0040a3ef      if ((uint8_t)ebx > 4 && !*(uint32_t*)((char*)arg1 + 0x3c))
0040a3ef      {
0040a3f9          *(uint32_t*)((char*)arg1 + 0x3c) = *(uint32_t*)((char*)arg1 + 0x38);
0040a3fc          sub_405490(arg1, 3, 0xffffffff);
0040a3ef      }
0040a3ef      
0040a407      if (!((uint8_t)ebx & 4))
0040a407          return;
0040a407      
0040a411      void* ecx_2 =
0040a411          *(uint32_t*)(**(uint32_t**)(*(uint32_t*)((char*)arg1 + 0x14) + 4) + 0x10);
0040a416      int32_t edx_2 = *(uint32_t*)((char*)ecx_2 + 0xc);
0040a419      int32_t ecx_3 = *(uint32_t*)((char*)ecx_2 + 0x14);
0040a424      int32_t ebx_1;
0040a424      
0040a424      if (!ecx_3)
0040a42b          ebx_1 = 0;
0040a424      else
0040a426          ebx_1 = *(uint32_t*)(ecx_3 + ((((arg2 - edx_2) >> 2) - 1) << 2));
0040a426      
0040a433      int32_t ecx_4;
0040a433      
0040a433      if ((arg2 - edx_2) >> 2 != 1 && arg2 > edi)
0040a433      {
0040a437          if (!ecx_3)
0040a444              ecx_4 = 0;
0040a437          else
0040a43e              ecx_4 = *(uint32_t*)(ecx_3 + ((edi - edx_2) >> 2 << 2) - 4);
0040a433      }
0040a433      
0040a448      if ((arg2 - edx_2) >> 2 == 1 || arg2 <= edi || ebx_1 != ecx_4)
0040a44e          sub_405490(arg1, 2, ebx_1);
0040a3d0  }

0040a45b                                                                                   90 90 90 90 90                             .....

0040a460    int32_t sub_40a460(void* arg1, double* arg2, double* arg3)

0040a460  {
0040a46b      int32_t eax = arg2[1];
0040a46b      
0040a471      if (eax != arg3[1])
0040a471      {
0040a47a          sub_40ba90(arg1, arg2, arg3);
0040a485          return 0;
0040a471      }
0040a471      
0040a489      if (eax == 3)
0040a489      {
0040a48b          long double x87_r7 = (long double)*(uint64_t*)arg2;
0040a48d          long double temp0 = (long double)*(uint64_t*)arg3;
0040a48d          x87_r7 - temp0;
0040a48f          (uint16_t)eax = (x87_r7 < temp0 ? 1 : 0) << 8
0040a48f              | (FCMP_UO(x87_r7, temp0) ? 1 : 0) << 0xa | (x87_r7 == temp0 ? 1 : 0) << 0xe;
0040a48f          
0040a494          if (!(*(uint8_t*)((char*)eax)[1] & 0x41))
0040a4a4              return 0;
0040a4a4          
0040a49e          return 1;
0040a489      }
0040a489      
0040a4a8      if (eax == 4)
0040a4a8      {
0040a4bc          int32_t ecx_1;
0040a4bc          (uint8_t)ecx_1 = sub_408e40(*(uint32_t*)arg2, *(uint32_t*)arg3) <= 0;
0040a4c4          return ecx_1;
0040a4a8      }
0040a4a8      
0040a4ce      int32_t eax_6 = sub_408db0(arg1, arg2, arg3, 0xe);
0040a4ce      
0040a4d9      if (eax_6 != 0xffffffff)
0040a508          return eax_6;
0040a508      
0040a4e0      int32_t eax_7 = sub_408db0(arg1, arg3, arg2, 0xd);
0040a4e0      
0040a4eb      if (eax_7 == 0xffffffff)
0040a4fd          return sub_40ba90(arg1, arg2, arg3);
0040a4fd      
0040a4f2      int32_t edx_1;
0040a4f2      (uint8_t)edx_1 = !eax_7;
0040a4f9      return edx_1;
0040a460  }

0040a509                             90 90 90 90 90 90 90                                                           .......

0040a510    double* sub_40a510(void* arg1, double* arg2, int32_t* arg3, int32_t* arg4, int32_t arg5)

0040a510  {
0040a525      double var_28[0x2];
0040a525      int32_t* eax = sub_408900(arg3, &var_28);
0040a534      int32_t* eax_1;
0040a534      double var_18[0x2];
0040a534      
0040a534      if (eax)
0040a540          eax_1 = sub_408900(arg4, &var_18);
0040a54a      int32_t eax_3;
0040a54a      
0040a54a      if (!eax || !eax_1)
0040a54a      {
0040a664          eax_3 = sub_409230(arg1, arg3, arg4, arg2, arg5);
0040a664          
0040a66e          if (!eax_3)
0040a673              return sub_40ba50(arg1, arg3, arg4);
0040a54a      }
0040a54a      else
0040a54a      {
0040a550          int32_t edx = *(uint32_t*)eax;
0040a559          int32_t edx_1 = *(uint32_t*)eax_1;
0040a55e          int32_t var_34_1 = eax[1];
0040a565          int32_t var_2c_1 = eax_1[1];
0040a56d          eax_3 = arg5 - 5;
0040a56d          
0040a579          switch (eax_3)
0040a579          {
0040a58b              case 0:
0040a58b              {
0040a58b                  *(uint64_t*)arg2 = (double)((long double)edx_1 + (long double)edx);
0040a58d                  arg2[1] = 3;
0040a59a                  return arg2;
0040a58b                  break;
0040a58b              }
0040a5a6              case 1:
0040a5a6              {
0040a5a6                  *(uint64_t*)arg2 = (double)((long double)edx - (long double)edx_1);
0040a5a8                  arg2[1] = 3;
0040a5b5                  return arg2;
0040a5a6                  break;
0040a5a6              }
0040a5c1              case 2:
0040a5c1              {
0040a5c1                  *(uint64_t*)arg2 = (double)((long double)edx_1 * (long double)edx);
0040a5c3                  arg2[1] = 3;
0040a5d0                  return arg2;
0040a5c1                  break;
0040a5c1              }
0040a5dc              case 3:
0040a5dc              {
0040a5dc                  arg2[1] = 3;
0040a5e3                  *(uint64_t*)arg2 = (double)((long double)edx / (long double)edx_1);
0040a5eb                  return arg2;
0040a5dc                  break;
0040a5dc              }
0040a5f7              case 4:
0040a5f7              {
0040a5f7                  int32_t* var_50_1;
0040a5f7                  var_50_1 = (double)((long double)edx / (long double)edx_1);
0040a609                  long double x87_r7_12 =
0040a609                      (long double)edx - sub_41803f(var_50_1) * (long double)edx_1;
0040a60d                  arg2[1] = 3;
0040a614                  *(uint64_t*)arg2 = (double)x87_r7_12;
0040a61c                  return arg2;
0040a5f7                  break;
0040a5f7              }
0040a62d              case 5:
0040a62d              {
0040a62d                  *(uint64_t*)arg2 =
0040a62d                      (double)sub_418110((long double)edx_1, (long double)edx);
0040a62f                  arg2[1] = 3;
0040a63c                  return arg2;
0040a62d                  break;
0040a62d              }
0040a646              case 6:
0040a646              {
0040a646                  *(uint64_t*)arg2 = (double)-((long double)edx);
0040a648                  arg2[1] = 3;
0040a655                  return arg2;
0040a646                  break;
0040a646              }
0040a579          }
0040a54a      }
0040a54a      
0040a681      return eax_3;
0040a510  }

0040a682        8b ff                                                                                        ..
0040a684  uint32_t jump_table_40a684[0x7] = 
0040a684  {
0040a684      [0x0] =  0x0040a580
0040a688      [0x1] =  0x0040a59b
0040a68c      [0x2] =  0x0040a5b6
0040a690      [0x3] =  0x0040a5d1
0040a694      [0x4] =  0x0040a5ec
0040a698      [0x5] =  0x0040a61d
0040a69c      [0x6] =  0x0040a63d
0040a6a0  }

0040a6a0    int32_t sub_40a6a0(int32_t* arg1)

0040a6a0  {
0040a6a1      int32_t* esi = arg1;
0040a6b2      char* eax_1 = esi[2](esi[4], esi[3], &arg1);
0040a6b2      
0040a6ba      if (eax_1)
0040a6ba      {
0040a6bc          int32_t* ecx_1 = arg1;
0040a6bc          
0040a6c2          if (ecx_1)
0040a6c2          {
0040a6c5              esi[1] = eax_1;
0040a6c8              *(uint32_t*)esi = (char*)ecx_1 - 1;
0040a6cc              int32_t result;
0040a6cc              (uint8_t)result = *(uint8_t*)eax_1;
0040a6cf              esi[1] = &eax_1[1];
0040a6d5              return result;
0040a6c2          }
0040a6ba      }
0040a6ba      
0040a6da      return 0xffffffff;
0040a6a0  }

0040a6db                                                                                   90 90 90 90 90                             .....

0040a6e0    int32_t sub_40a6e0(int32_t* arg1)

0040a6e0  {
0040a6e8      if (!*(uint32_t*)arg1)
0040a6e8      {
0040a6eb          int32_t eax_1 = sub_40a6a0(arg1);
0040a6eb          
0040a6f6          if (eax_1 == 0xffffffff)
0040a6fb              return eax_1;
0040a6fb          
0040a702          int32_t eax_4 = arg1[1] - 1;
0040a703          *(uint32_t*)arg1 += 1;
0040a705          arg1[1] = eax_4;
0040a6e8      }
0040a6e8      
0040a70e      int32_t ecx_3;
0040a70e      (uint8_t)ecx_3 = *(uint8_t*)arg1[1];
0040a712      return ecx_3;
0040a6e0  }

0040a713                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0040a720    int32_t* sub_40a720(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t arg4)

0040a720  {
0040a72c      arg2[4] = arg1;
0040a733      arg2[2] = arg3;
0040a736      arg2[3] = arg4;
0040a739      *(uint32_t*)arg2 = 0;
0040a73f      arg2[1] = 0;
0040a746      return arg2;
0040a720  }

0040a747                       90 90 90 90 90 90 90 90 90                                                         .........

0040a750    int32_t sub_40a750(int32_t* arg1, int32_t arg2, int32_t arg3)

0040a750  {
0040a752      int32_t result = arg3;
0040a752      
0040a75a      if (result)
0040a75a      {
0040a7a7          int32_t result_1;
0040a7a7          int32_t result_2;
0040a7a7          
0040a7a7          do
0040a7a7          {
0040a76c              if (sub_40a6e0(arg1) == 0xffffffff)
0040a7b6                  return result;
0040a7b6              
0040a76e              result_1 = *(uint32_t*)arg1;
0040a76e              
0040a772              if (result <= result_1)
0040a774                  result_1 = result;
0040a774              
0040a784              int32_t esi_2;
0040a784              int32_t edi_2;
0040a784              edi_2 = __builtin_memcpy(arg2, arg1[1], result_1 >> 2 << 2);
0040a791              __builtin_memcpy(edi_2, esi_2, result_1 & 3);
0040a79a              int32_t esi_4 = arg1[1] + result_1;
0040a79c              result_2 = result;
0040a79c              result -= result_1;
0040a79e              *(uint32_t*)arg1 -= result_1;
0040a7a0              arg1[1] = esi_4;
0040a7a3              arg2 += result_1;
0040a7a7          } while (result_2 != result_1);
0040a75a      }
0040a75a      
0040a7af      return 0;
0040a750  }

0040a7b7                                                                       90 90 90 90 90 90 90 90 90                         .........

0040a7c0    int32_t sub_40a7c0(void* arg1, int32_t* arg2, int32_t arg3)

0040a7c0  {
0040a7c1      int32_t esi = arg3;
0040a7ca      int32_t eax = arg2[2];
0040a7ca      
0040a7cf      if (esi > eax)
0040a7cf      {
0040a7d4          if (esi < 0x20)
0040a7d6              esi = 0x20;
0040a7d6          
0040a7e1          if (esi + 1 <= 0xfffffffd)
0040a7e1          {
0040a7ed              int32_t result = sub_404d00(arg1, *(uint32_t*)arg2, eax, esi);
0040a7f5              *(uint32_t*)arg2 = result;
0040a7f7              arg2[2] = esi;
0040a7fc              return result;
0040a7e1          }
0040a7e1          
0040a802          sub_404ce0(arg1);
0040a80a          *(uint32_t*)arg2 = 0;
0040a80c          arg2[2] = esi;
0040a7cf      }
0040a7cf      
0040a813      return *(uint32_t*)arg2;
0040a7c0  }

0040a814                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

0040a820    int32_t sub_40a820(int32_t arg1, void* arg2, int32_t arg3, int32_t arg4, int32_t arg5)

0040a820  {
0040a82f      int32_t var_10 = arg3;
0040a833      int32_t var_14 = arg1;
0040a83f      int32_t var_c = arg4;
0040a844      int32_t var_8 = arg5;
0040a848      int32_t result = 0;
0040a850      sub_40aba0(&var_14);
0040a861      sub_40a870(arg2, 0, &var_14);
0040a86d      return result;
0040a820  }

0040a86e                                            90 90                                                                ..

0040a870    int32_t sub_40a870(void* arg1, int32_t arg2, int32_t* arg3)

0040a870  {
0040a87e      void* eax = *(uint32_t*)((char*)arg1 + 0x20);
0040a87e      
0040a88a      if (eax == arg2 || arg3[3])
0040a88c          eax = nullptr;
0040a88c      
0040a890      sub_40a9a0(eax, arg3);
0040a898      int32_t* var_14 = arg3;
0040a89a      sub_40a950(*(uint32_t*)((char*)arg1 + 0x3c));
0040a8a2      int32_t* var_1c = arg3;
0040a8a4      sub_40a950(*(uint32_t*)((char*)arg1 + 0x40));
0040a8b0      sub_40a900(*(uint8_t*)((char*)arg1 + 0x48), arg3);
0040a8bc      sub_40a900(*(uint8_t*)((char*)arg1 + 0x49), arg3);
0040a8c8      sub_40a900(*(uint8_t*)((char*)arg1 + 0x4a), arg3);
0040a8d4      sub_40a900(*(uint8_t*)((char*)arg1 + 0x4b), arg3);
0040a8e4      sub_40a970(*(uint32_t*)((char*)arg1 + 0xc), *(uint32_t*)((char*)arg1 + 0x2c), 4, 
0040a8e4          arg3);
0040a8ee      sub_40aa00(arg1, arg3);
0040a8ff      return sub_40aae0(arg1, arg3);
0040a870  }


0040a900    int32_t sub_40a900(char arg1, int32_t* arg2)

0040a900  {
0040a910      arg1 = arg1;
0040a91c      return sub_40a920(&arg1, 1, arg2);
0040a900  }

0040a91d                                                                                         90 90 90                               ...

0040a920    int32_t sub_40a920(int32_t arg1, int32_t arg2, int32_t* arg3)

0040a920  {
0040a925      int32_t result = arg3[4];
0040a925      
0040a92a      if (!result)
0040a92a      {
0040a93d          result = arg3[1](*(uint32_t*)arg3, arg1, arg2, arg3[2]);
0040a943          arg3[4] = result;
0040a92a      }
0040a92a      
0040a947      return result;
0040a920  }

0040a948                          90 90 90 90 90 90 90 90                                                          ........

0040a950    int32_t sub_40a950(int32_t* arg1)

0040a950  {
0040a964      void arg_4;
0040a964      return sub_40a920(&arg_4, 4, arg1);
0040a950  }

0040a965                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040a970    int32_t sub_40a970(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t* arg4)

0040a970  {
0040a97a      int32_t* var_c = arg4;
0040a97c      sub_40a950(arg2);
0040a997      return sub_40a920(arg1, arg2 * arg3, arg4);
0040a970  }

0040a998                                                                          90 90 90 90 90 90 90 90                          ........

0040a9a0    int32_t sub_40a9a0(void* arg1, int32_t* arg2)

0040a9a0  {
0040a9a0      void* eax_5 = arg1;
0040a9a0      
0040a9ae      if (!eax_5 || eax_5 == 0xfffffff0)
0040a9ae      {
0040a9e8          arg1 = nullptr;
0040a9f9          return sub_40a920(&arg1, 4, arg2);
0040a9ae      }
0040a9ae      
0040a9c1      arg1 = *(uint32_t*)((char*)eax_5 + 0xc) + 1;
0040a9c5      sub_40a920(&arg1, 4, arg2);
0040a9db      return sub_40a920((char*)eax_5 + 0x10, arg1, arg2);
0040a9a0  }

0040a9fa                                                                                90 90 90 90 90 90                            ......

0040aa00    int32_t sub_40aa00(void* arg1, int32_t* arg2)

0040aa00  {
0040aa06      int32_t ecx;
0040aa06      int32_t var_c = ecx;
0040aa10      int32_t* esi = *(uint32_t*)((char*)arg1 + 0x28);
0040aa13      int32_t* var_1c = arg2;
0040aa15      sub_40a950(esi);
0040aa15      
0040aa1f      if (esi > 0)
0040aa1f      {
0040aa21          int32_t ebx_1 = 0;
0040aa23          int32_t* var_c_1 = esi;
0040aa7f          bool cond:0_1;
0040aa7f          
0040aa7f          do
0040aa7f          {
0040aa2e              int32_t* esi_2 = *(uint32_t*)((char*)arg1 + 8) + ebx_1;
0040aa34              sub_40a900((char)esi_2[2], arg2);
0040aa39              int32_t eax_1 = esi_2[2];
0040aa39              
0040aa40              if (eax_1 == 1)
0040aa6b                  sub_40a900((char)*(uint32_t*)esi_2, arg2);
0040aa40              else if (eax_1 == 3)
0040aa45              {
0040aa5a                  int32_t* var_1c_3 = arg2;
0040aa5b                  int32_t var_20_3 = esi_2[1];
0040aa5d                  sub_40aac0(*(uint32_t*)esi_2);
0040aa45              }
0040aa45              else if (eax_1 == 4)
0040aa4e                  sub_40a9a0(*(uint32_t*)esi_2, arg2);
0040aa4e              
0040aa77              ebx_1 += 0x10;
0040aa7a              cond:0_1 = var_c_1 != 1;
0040aa7b              var_c_1 -= 1;
0040aa7f          } while (cond:0_1);
0040aa1f      }
0040aa1f      
0040aa84      int32_t* var_1c_5 = arg2;
0040aa85      int32_t* ebx_2 = *(uint32_t*)((char*)arg1 + 0x34);
0040aa89      int32_t result = sub_40a950(ebx_2);
0040aa91      int32_t esi_3 = 0;
0040aa91      
0040aa95      if (ebx_2 > 0)
0040aa95      {
0040aab1          do
0040aab1          {
0040aaa6              result = sub_40a870(
0040aaa6                  *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x10) + (esi_3 << 2)), 
0040aaa6                  *(uint32_t*)((char*)arg1 + 0x20), arg2);
0040aaae              esi_3 += 1;
0040aab1          } while (esi_3 < ebx_2);
0040aa95      }
0040aa95      
0040aab9      return result;
0040aa00  }

0040aaba                                                                                90 90 90 90 90 90                            ......

0040aac0    int32_t sub_40aac0(int32_t* arg1)

0040aac0  {
0040aad4      void arg_4;
0040aad4      return sub_40a920(&arg_4, 8, arg1);
0040aac0  }

0040aad5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040aae0    int32_t sub_40aae0(void* arg1, int32_t* arg2)

0040aae0  {
0040aaf1      int32_t* eax_1;
0040aaf1      
0040aaf1      if (!arg2[3])
0040aaf7          eax_1 = *(uint32_t*)((char*)arg1 + 0x30);
0040aaf1      else
0040aaf3          eax_1 = nullptr;
0040aaf3      
0040ab02      sub_40a970(*(uint32_t*)((char*)arg1 + 0x14), eax_1, 4, arg2);
0040ab0f      int32_t* i_1;
0040ab0f      
0040ab0f      if (!arg2[3])
0040ab15          i_1 = *(uint32_t*)((char*)arg1 + 0x38);
0040ab0f      else
0040ab11          i_1 = nullptr;
0040ab11      
0040ab18      int32_t* var_14_1 = arg2;
0040ab1a      sub_40a950(i_1);
0040ab1a      
0040ab24      if (i_1 > 0)
0040ab24      {
0040ab26          int32_t edi_1 = 0;
0040ab58          int32_t* i;
0040ab58          
0040ab58          do
0040ab58          {
0040ab30              sub_40a9a0(*(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x18) + edi_1), arg2);
0040ab38              int32_t* var_1c_1 = arg2;
0040ab3e              sub_40a950(*(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x18) + edi_1 + 4));
0040ab46              int32_t* var_24_1 = arg2;
0040ab4c              sub_40a950(*(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x18) + edi_1 + 8));
0040ab54              edi_1 += 0xc;
0040ab57              i = i_1;
0040ab57              i_1 -= 1;
0040ab58          } while (i != 1);
0040ab24      }
0040ab24      
0040ab5f      int32_t* ebp;
0040ab5f      
0040ab5f      if (!arg2[3])
0040ab65          ebp = *(uint32_t*)((char*)arg1 + 0x24);
0040ab5f      else
0040ab61          ebp = nullptr;
0040ab61      
0040ab68      int32_t* var_14_3 = arg2;
0040ab6a      int32_t result = sub_40a950(ebp);
0040ab72      int32_t edi_2 = 0;
0040ab72      
0040ab76      if (ebp > 0)
0040ab76      {
0040ab8b          do
0040ab8b          {
0040ab80              result = sub_40a9a0(
0040ab80                  *(uint32_t*)(*(uint32_t*)((char*)arg1 + 0x1c) + (edi_2 << 2)), arg2);
0040ab88              edi_2 += 1;
0040ab8b          } while (edi_2 < ebp);
0040ab76      }
0040ab76      
0040ab91      return result;
0040aae0  }

0040ab92                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

0040aba0    int32_t sub_40aba0(int32_t* arg1)

0040aba0  {
0040aba8      void var_c;
0040aba8      sub_4154f0(&var_c);
0040abc1      return sub_40a920(&var_c, 0xc, arg1);
0040aba0  }

0040abc2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0040abd0    int32_t sub_40abd0(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

0040abd0  {
0040abd0      int32_t edx = arg2;
0040abd6      int32_t ecx_1;
0040abd6      
0040abd6      if (edx)
0040abd8          ecx_1 = arg3;
0040abd8      
0040abde      if (!edx || !ecx_1)
0040abde      {
0040abe0          ecx_1 = 0;
0040abe2          edx = 0;
0040abde      }
0040abde      
0040abe8      *(uint32_t*)((char*)arg1 + 0x40) = edx;
0040abef      *(uint32_t*)((char*)arg1 + 0x38) = arg4;
0040abf2      *(uint32_t*)((char*)arg1 + 0x3c) = arg4;
0040abf5      *(uint8_t*)((char*)arg1 + 0x36) = (uint8_t)ecx_1;
0040abfd      return 1;
0040abd0  }

0040abfe                                                                                            90 90                                ..

0040ac00    int32_t sub_40ac00(void* arg1)

0040ac00  {
0040ac07      return *(uint32_t*)((char*)arg1 + 0x40);
0040ac00  }

0040ac08                          90 90 90 90 90 90 90 90                                                          ........

0040ac10    int32_t sub_40ac10(void* arg1)

0040ac10  {
0040ac16      int32_t result;
0040ac16      (uint8_t)result = *(uint8_t*)((char*)arg1 + 0x36);
0040ac19      return result;
0040ac10  }

0040ac1a                                                                                90 90 90 90 90 90                            ......

0040ac20    int32_t sub_40ac20(void* arg1)

0040ac20  {
0040ac27      return *(uint32_t*)((char*)arg1 + 0x38);
0040ac20  }

0040ac28                          90 90 90 90 90 90 90 90                                                          ........

0040ac30    int32_t sub_40ac30(void* arg1, int32_t arg2, void* arg3)

0040ac30  {
0040ac30      int32_t ecx = arg2;
0040ac34      int32_t ebx;
0040ac34      int32_t var_4 = ebx;
0040ac3a      bool cond:1 = ecx;
0040ac3a      bool cond:2 = ecx >= 0;
0040ac3c      void* i = *(uint32_t*)((char*)arg1 + 0x14);
0040ac3c      
0040ac40      if (ecx > 0)
0040ac40      {
0040ac47          while (i > *(uint32_t*)((char*)arg1 + 0x28))
0040ac47          {
0040ac4c              ecx -= 1;
0040ac4f              (uint8_t)ebx = *(uint8_t*)(**(uint32_t**)((char*)i + 4) + 6);
0040ac4f              
0040ac54              if (!(uint8_t)ebx)
0040ac56                  ecx -= *(uint32_t*)((char*)i + 0x14);
0040ac56              
0040ac59              i -= 0x18;
0040ac59              
0040ac5e              if (ecx <= 0)
0040ac5e                  break;
0040ac47          }
0040ac47          
0040ac60          cond:1 = ecx;
0040ac60          cond:2 = ecx >= 0;
0040ac40      }
0040ac40      
0040ac62      if (!cond:1)
0040ac62      {
0040ac64          int32_t ecx_1 = *(uint32_t*)((char*)arg1 + 0x28);
0040ac64          
0040ac69          if (i > ecx_1)
0040ac69          {
0040ac8d              *(uint32_t*)((char*)arg3 + 0x60) = ((char*)i - ecx_1) / 0x18;
0040ac91              return 1;
0040ac69          }
0040ac62      }
0040ac62      else if (!cond:2)
0040ac92      {
0040ac9f          *(uint32_t*)((char*)arg3 + 0x60) = 0;
0040aca7          return 1;
0040ac92      }
0040ac92      
0040acad      return 0;
0040ac30  }

0040acae                                            90 90                                                                ..

0040acb0    int32_t sub_40acb0(void* arg1, void* arg2, int32_t arg3)

0040acb0  {
0040acca      int32_t* ebp =
0040acca          *(uint32_t*)((char*)arg1 + 0x28) + *(uint32_t*)((char*)arg2 + 0x60) * 0x18;
0040accf      int32_t result = sub_40ad00(arg1, ebp, arg3);
0040accf      
0040acdb      if (result)
0040ace9          sub_401770(arg1, (arg3 << 4) + *(uint32_t*)ebp - 0x10);
0040ace9      
0040acf7      return result;
0040acb0  }

0040acf8                                                                          90 90 90 90 90 90 90 90                          ........

0040ad00    int32_t sub_40ad00(void* arg1, int32_t* arg2, int32_t arg3)

0040ad00  {
0040ad09      void* eax = sub_40ada0(arg2);
0040ad09      
0040ad1d      if (eax)
0040ad1d      {
0040ad29          int32_t result = sub_4050d0(eax, arg3, sub_40ad60(arg1, arg2));
0040ad29          
0040ad33          if (result)
0040ad5f              return result;
0040ad1d      }
0040ad1d      
0040ad38      int32_t eax_2;
0040ad38      
0040ad38      if (arg2 != *(uint32_t*)((char*)arg1 + 0x14))
0040ad3f          eax_2 = arg2[7];
0040ad38      else
0040ad3a          eax_2 = *(uint32_t*)((char*)arg1 + 8);
0040ad3a      
0040ad4d      if ((eax_2 - *(uint32_t*)arg2) >> 4 >= arg3 && arg3 > 0)
0040ad58          return "(*temporary)";
0040ad58      
0040ad59      return 0;
0040ad00  }


0040ad60    int32_t sub_40ad60(void* arg1, void* arg2)

0040ad60  {
0040ad65      int32_t* ecx = *(uint32_t*)((char*)arg2 + 4);
0040ad65      
0040ad6c      if (ecx[2] == 6)
0040ad6c      {
0040ad70          int32_t ebx;
0040ad70          (uint8_t)ebx = *(uint8_t*)(*(uint32_t*)ecx + 6);
0040ad70          
0040ad75          if (!(uint8_t)ebx)
0040ad75          {
0040ad7e              if (arg2 == *(uint32_t*)((char*)arg1 + 0x14))
0040ad83                  *(uint32_t*)((char*)arg2 + 0xc) = *(uint32_t*)((char*)arg1 + 0x18);
0040ad83              
0040ad98              return ((*(uint32_t*)((char*)arg2 + 0xc)
0040ad98                  - *(uint32_t*)(*(uint32_t*)(*(uint32_t*)ecx + 0x10) + 0xc)) >> 2) - 1;
0040ad75          }
0040ad6c      }
0040ad6c      
0040ad9d      return 0xffffffff;
0040ad60  }

0040ad9e                                                                                            90 90                                ..

0040ada0    int32_t sub_40ada0(void* arg1)

0040ada0  {
0040ada4      int32_t* eax = *(uint32_t*)((char*)arg1 + 4);
0040ada4      
0040adab      if (eax[2] == 6)
0040adab      {
0040adad          void* eax_1 = *(uint32_t*)eax;
0040adad          
0040adb4          if (!*(uint8_t*)((char*)eax_1 + 6))
0040adb9              return *(uint32_t*)((char*)eax_1 + 0x10);
0040adab      }
0040adab      
0040adbc      return 0;
0040ada0  }

0040adbd                                                                                         90 90 90                               ...

0040adc0    int32_t sub_40adc0(void* arg1, void* arg2, int32_t arg3)

0040adc0  {
0040add9      int32_t* ebx =
0040add9          *(uint32_t*)((char*)arg1 + 0x28) + *(uint32_t*)((char*)arg2 + 0x60) * 0x18;
0040adde      int32_t result = sub_40ad00(arg1, ebx, arg3);
0040adde      
0040ade8      if (result)
0040ade8      {
0040adef          int32_t* ecx_2 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
0040adf5          int32_t* edx_2 = (arg3 << 4) + *(uint32_t*)ebx - 0x10;
0040adfb          *(uint32_t*)edx_2 = *(uint32_t*)ecx_2;
0040ae00          edx_2[1] = ecx_2[1];
0040ae06          edx_2[2] = ecx_2[2];
0040ade8      }
0040ade8      
0040ae0f      *(uint32_t*)((char*)arg1 + 8) -= 0x10;
0040ae15      return result;
0040adc0  }

0040ae16                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040ae20    int32_t sub_40ae20(void* arg1, char* arg2, void* arg3)

0040ae20  {
0040ae25      char* ebx = arg2;
0040ae32      void* edi = nullptr;
0040ae34      void* eax = nullptr;
0040ae34      
0040ae39      if (*(uint8_t*)ebx != 0x3e)
0040ae39      {
0040ae49          int32_t ecx_3 = *(uint32_t*)((char*)arg3 + 0x60);
0040ae49          
0040ae4e          if (ecx_3)
0040ae4e          {
0040ae56              eax = *(uint32_t*)((char*)arg1 + 0x28) + ecx_3 * 0x18;
0040ae5c              edi = **(uint32_t**)((char*)eax + 4);
0040ae4e          }
0040ae39      }
0040ae39      else
0040ae39      {
0040ae3e          ebx = &ebx[1];
0040ae3f          int32_t* ecx_2 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
0040ae42          edi = *(uint32_t*)ecx_2;
0040ae44          *(uint32_t*)((char*)arg1 + 8) = ecx_2;
0040ae39      }
0040ae39      
0040ae63      int32_t result = sub_40af80(arg1, ebx, arg3, edi, eax);
0040ae63      
0040ae77      if (sub_4172f0(ebx, 0x66))
0040ae77      {
0040ae7b          if (edi)
0040ae7b          {
0040ae85              void** eax_3 = *(uint32_t*)((char*)arg1 + 8);
0040ae88              *(uint32_t*)eax_3 = edi;
0040ae8a              eax_3[2] = 6;
0040ae7b          }
0040ae7b          else
0040ae80              *(uint32_t*)(*(uint32_t*)((char*)arg1 + 8) + 8) = edi;
0040ae80          
0040ae9c          if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= 0x10)
0040aea1              sub_405460(arg1, 1);
0040aea1          
0040aea9          *(uint32_t*)((char*)arg1 + 8) += 0x10;
0040ae77      }
0040ae77      
0040aeba      if (sub_4172f0(ebx, 0x4c))
0040aebe          sub_40aed0(arg1, edi);
0040aebe      
0040aecc      return result;
0040ae20  }

0040aecd                                         90 90 90                                                               ...

0040aed0    int32_t sub_40aed0(int32_t* arg1, void* arg2)

0040aed0  {
0040aed7      int32_t i = 0;
0040aee2      void* esi;
0040aee2      
0040aee2      if (!arg2 || *(uint8_t*)((char*)arg2 + 6))
0040aee2      {
0040af42          esi = arg1;
0040af49          *(uint32_t*)(*(uint32_t*)((char*)esi + 8) + 8) = 0;
0040aee2      }
0040aee2      else
0040aee2      {
0040aee4          esi = arg1;
0040aeec          int32_t* eax_1 = sub_407b30(esi, 0, 0);
0040aef5          void* eax_2 = *(uint32_t*)((char*)arg2 + 0x10);
0040aefe          int32_t* ebx_1 = *(uint32_t*)((char*)eax_2 + 0x14);
0040aefe          
0040af03          if (*(uint32_t*)((char*)eax_2 + 0x30) > 0)
0040af03          {
0040af2d              do
0040af2d              {
0040af0e                  void* eax_4 = sub_408150(esi, eax_1, *(uint32_t*)ebx_1);
0040af13                  *(uint32_t*)eax_4 = 1;
0040af19                  *(uint32_t*)((char*)eax_4 + 8) = 1;
0040af26                  i += 1;
0040af27                  ebx_1 = &ebx_1[1];
0040af2d              } while (i < *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x10) + 0x30));
0040af03          }
0040af03          
0040af2f          int32_t** eax_5 = *(uint32_t*)((char*)esi + 8);
0040af37          *(uint32_t*)eax_5 = eax_1;
0040af39          eax_5[2] = 5;
0040aee2      }
0040aee2      
0040af5b      if (*(uint32_t*)((char*)esi + 0x1c) - *(uint32_t*)((char*)esi + 8) <= 0x10)
0040af60          sub_405460(esi, 1);
0040af60      
0040af6b      int32_t result = *(uint32_t*)((char*)esi + 8) + 0x10;
0040af6e      *(uint32_t*)((char*)esi + 8) = result;
0040af73      return result;
0040aed0  }

0040af74                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

0040af80    int32_t sub_40af80(void* arg1, char* arg2, void* arg3, void* arg4, void* arg5)

0040af80  {
0040af80      int32_t ecx;
0040af80      int32_t var_4 = ecx;
0040af81      void* ecx_1 = arg4;
0040af88      int32_t result = 1;
0040af88      
0040af92      if (!ecx_1)
0040af92      {
0040af99          sub_40b170(arg3);
0040afa8          return 1;
0040af92      }
0040af92      
0040afad      void* eax;
0040afad      (uint8_t)eax = *(uint8_t*)arg2;
0040afad      
0040afb1      if ((uint8_t)eax)
0040afb1      {
0040afd5          while (true)
0040afd5          {
0040afd5              if ((int32_t)(uint8_t)eax - 0x4c > 0x29)
0040b040                  result = 0;
0040afd5              else
0040afd5              {
0040afd9                  int32_t edx_1;
0040afd9                  (uint8_t)edx_1 = *(uint8_t*)((int32_t)(uint8_t)eax + 0x40b030);
0040afd9                  
0040afdf                  switch (edx_1)
0040afdf                  {
0040afe8                      case 1:
0040afe8                      {
0040afe8                          sub_40b0f0(arg3, ecx_1);
0040afe8                          break;
0040afe8                      }
0040aff4                      case 2:
0040aff4                      {
0040aff4                          if (!arg5)
0040b008                              *(uint32_t*)((char*)arg3 + 0x14) = 0xffffffff;
0040aff4                          else
0040b000                              *(uint32_t*)((char*)arg3 + 0x14) = sub_40b0b0(arg1, arg5);
0040aff4                          break;
0040aff4                      }
0040b019                      case 3:
0040b019                      {
0040b019                          int32_t eax_7;
0040b019                          
0040b019                          if (!arg5)
0040b02b                              eax_7 = 0;
0040b019                          else
0040b021                              eax_7 = sub_40b740(arg1, arg5, (char*)arg3 + 4);
0040b021                          
0040b02f                          *(uint32_t*)((char*)arg3 + 8) = eax_7;
0040b02f                          
0040b032                          if (!eax_7)
0040b032                          {
0040b034                              *(uint32_t*)((char*)arg3 + 8) = &data_4307a0;
0040b03b                              *(uint32_t*)((char*)arg3 + 4) = 0;
0040b032                          }
0040b019                          break;
0040b019                      }
0040b00f                      case 4:
0040b00f                      {
0040b00f                          int32_t eax_6;
0040b00f                          (uint8_t)eax_6 = *(uint8_t*)((char*)ecx_1 + 7);
0040b012                          *(uint32_t*)((char*)arg3 + 0x18) = eax_6;
0040b00f                          break;
0040b00f                      }
0040b040                      case 5:
0040b040                      {
0040b040                          result = 0;
0040b040                          break;
0040b040                      }
0040afdf                  }
0040afd5              }
0040afd5              
0040b048              eax = &arg2[1];
0040b049              arg2 = eax;
0040b04d              (uint8_t)eax = *(uint8_t*)eax;
0040b04d              
0040b051              if (!(uint8_t)eax)
0040b051                  break;
0040b051              
0040afc8              ecx_1 = arg4;
0040afd5          }
0040afb1      }
0040afb1      
0040b060      return result;
0040af80  }

0040b061     8d 49 00                                                                                       .I.
0040b064  uint32_t jump_table_40b064[0x6] = 
0040b064  {
0040b064      [0x0] =  0x0040b044
0040b068      [0x1] =  0x0040afe6
0040b06c      [0x2] =  0x0040aff2
0040b070      [0x3] =  0x0040b017
0040b074      [0x4] =  0x0040b00d
0040b078      [0x5] =  0x0040b040
0040b07c  }
0040b07c  uint8_t lookup_table_40b07c[0x2a] = 
0040b07c  {
0040b07c      [0x00] =  0x00
0040b07d      [0x01] =  0x05
0040b07e      [0x02] =  0x05
0040b07f      [0x03] =  0x05
0040b080      [0x04] =  0x05
0040b081      [0x05] =  0x05
0040b082      [0x06] =  0x05
0040b083      [0x07] =  0x01
0040b084      [0x08] =  0x05
0040b085      [0x09] =  0x05
0040b086      [0x0a] =  0x05
0040b087      [0x0b] =  0x05
0040b088      [0x0c] =  0x05
0040b089      [0x0d] =  0x05
0040b08a      [0x0e] =  0x05
0040b08b      [0x0f] =  0x05
0040b08c      [0x10] =  0x05
0040b08d      [0x11] =  0x05
0040b08e      [0x12] =  0x05
0040b08f      [0x13] =  0x05
0040b090      [0x14] =  0x05
0040b091      [0x15] =  0x05
0040b092      [0x16] =  0x05
0040b093      [0x17] =  0x05
0040b094      [0x18] =  0x05
0040b095      [0x19] =  0x05
0040b096      [0x1a] =  0x00
0040b097      [0x1b] =  0x05
0040b098      [0x1c] =  0x05
0040b099      [0x1d] =  0x05
0040b09a      [0x1e] =  0x05
0040b09b      [0x1f] =  0x05
0040b09c      [0x20] =  0x02
0040b09d      [0x21] =  0x05
0040b09e      [0x22] =  0x03
0040b09f      [0x23] =  0x05
0040b0a0      [0x24] =  0x05
0040b0a1      [0x25] =  0x05
0040b0a2      [0x26] =  0x05
0040b0a3      [0x27] =  0x05
0040b0a4      [0x28] =  0x05
0040b0a5      [0x29] =  0x04
0040b0a6  }

0040b0a6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

0040b0b0    int32_t sub_40b0b0(void* arg1, void* arg2)

0040b0b0  {
0040b0bb      int32_t eax = sub_40ad60(arg1, arg2);
0040b0bb      
0040b0c5      if (eax < 0)
0040b0cb          return 0xffffffff;
0040b0cb      
0040b0d4      int32_t ecx_2 =
0040b0d4          *(uint32_t*)(*(uint32_t*)(**(uint32_t**)((char*)arg2 + 4) + 0x10) + 0x14);
0040b0d4      
0040b0d9      if (!ecx_2)
0040b0e3          return 0;
0040b0e3      
0040b0df      return *(uint32_t*)(ecx_2 + (eax << 2));
0040b0b0  }

0040b0e4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040b0f0    char* sub_40b0f0(void* arg1, void* arg2)

0040b0f0  {
0040b0fd      if (*(uint8_t*)((char*)arg2 + 6))
0040b0fd      {
0040b102          *(uint32_t*)((char*)arg1 + 0x10) = "=[C]";
0040b109          *(uint32_t*)((char*)arg1 + 0x1c) = 0xffffffff;
0040b10c          *(uint32_t*)((char*)arg1 + 0x20) = 0xffffffff;
0040b10f          char* ecx = *(uint32_t*)((char*)arg1 + 0x10);
0040b112          *(uint32_t*)((char*)arg1 + 0xc) = &data_42b770;
0040b128          return sub_4087c0((char*)arg1 + 0x24, ecx, 0x3c);
0040b0fd      }
0040b0fd      
0040b132      *(uint32_t*)((char*)arg1 + 0x10) =
0040b132          *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x10) + 0x20) + 0x10;
0040b13b      *(uint32_t*)((char*)arg1 + 0x1c) =
0040b13b          *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x10) + 0x3c);
0040b147      bool cond:1 = !*(uint32_t*)((char*)arg1 + 0x1c);
0040b149      *(uint32_t*)((char*)arg1 + 0x20) =
0040b149          *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x10) + 0x40);
0040b14c      char* ecx_3 = "main";
0040b14c      
0040b151      if (!cond:1)
0040b153          ecx_3 = &data_42b764;
0040b153      
0040b158      *(uint32_t*)((char*)arg1 + 0xc) = ecx_3;
0040b16d      return sub_4087c0((char*)arg1 + 0x24, *(uint32_t*)((char*)arg1 + 0x10), 0x3c);
0040b0f0  }

0040b16e                                            90 90                                                                ..

0040b170    char* sub_40b170(void* arg1)

0040b170  {
0040b17c      *(uint32_t*)((char*)arg1 + 8) = &data_4307a0;
0040b17f      *(uint32_t*)((char*)arg1 + 4) = &data_4307a0;
0040b18a      *(uint32_t*)((char*)arg1 + 0x14) = 0xffffffff;
0040b18d      *(uint32_t*)((char*)arg1 + 0x1c) = 0xffffffff;
0040b190      *(uint32_t*)((char*)arg1 + 0x20) = 0xffffffff;
0040b197      *(uint32_t*)((char*)arg1 + 0xc) = "tail";
0040b19e      *(uint32_t*)((char*)arg1 + 0x10) = "=(tail call)";
0040b1a5      char* result = sub_4087c0((char*)arg1 + 0x24, "=(tail call)", 0x3c);
0040b1ad      *(uint32_t*)((char*)arg1 + 0x18) = 0;
0040b1b5      return result;
0040b170  }

0040b1b6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040b1c0    int32_t sub_40b1c0(int32_t arg1) __pure

0040b1c0  {
0040b1c6      int32_t ecx_1 = arg1 & 0x3f;
0040b1c6      
0040b1d6      if (ecx_1 < 0x1c || (ecx_1 > 0x1e && ecx_1 != 0x22))
0040b1e5          return 0;
0040b1e5      
0040b1d8      int32_t eax = arg1 & 0xff800000;
0040b1dd      int32_t eax_1 = -(eax);
0040b1e2      return eax_1 - eax_1 + 1;
0040b1c0  }

0040b1e6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

0040b1f0    int32_t sub_40b1f0(void* arg1)

0040b1f0  {
0040b1fe      int32_t eax = sub_40b210(arg1, *(uint32_t*)((char*)arg1 + 0x2c), 0xff);
0040b206      int32_t eax_1 = -(eax);
0040b20c      return -((eax_1 - eax_1));
0040b1f0  }

0040b20d                                         90 90 90                                                               ...

0040b210    int32_t sub_40b210(void* arg1, int32_t arg2, int32_t arg3)

0040b210  {
0040b214      void* ebx = arg1;
0040b21e      int32_t esi_1 = *(uint32_t*)((char*)ebx + 0x2c) - 1;
0040b220      int32_t var_4 = esi_1;
0040b220      
0040b22e      if (!sub_40b690(ebx))
0040b239          return 0;
0040b239      
0040b23e      int32_t var_c_1 = 0;
0040b23e      
0040b248      if (arg2 > 0)
0040b248      {
0040b613          int32_t edx_5;
0040b613          
0040b613          do
0040b613          {
0040b255              uint32_t esi_2 = 0;
0040b257              uint32_t eax_4 =
0040b257                  *(uint32_t*)(*(uint32_t*)((char*)ebx + 0xc) + (var_c_1 << 2));
0040b25a              int32_t var_8_1 = 0;
0040b265              void* edi_2 = eax_4 & 0x3f;
0040b268              uint32_t ebp_3 = (uint32_t)(uint8_t)(eax_4 >> 6);
0040b268              
0040b271              if (edi_2 >= 0x26)
0040b239                  return 0;
0040b239              
0040b275              int32_t edx_1;
0040b275              (uint8_t)edx_1 = *(uint8_t*)((char*)ebx + 0x4b);
0040b275              
0040b27a              if (ebp_3 >= edx_1)
0040b239                  return 0;
0040b239              
0040b27c              (uint8_t)edx_1 = *(uint8_t*)((char*)edi_2 + 0x428a84);
0040b284              uint32_t ecx_3 = (uint32_t)(uint8_t)edx_1;
0040b28c              int32_t ebx_2 = ecx_3 & 3;
0040b28c              
0040b291              if (!ebx_2)
0040b291              {
0040b31a                  ebx = arg1;
0040b326                  esi_2 = eax_4 >> 0x17;
0040b334                  var_8_1 = eax_4 >> 0xe & 0x1ff;
0040b338                  int32_t eax_9;
0040b338                  int32_t edx_2;
0040b338                  eax_9 = sub_40b6d0(ebx, esi_2, ecx_3 >> 4 & 3);
0040b338                  
0040b342                  if (!eax_9)
0040b239                      return 0;
0040b239                  
0040b348                  (uint8_t)edx_2 = *(uint8_t*)((char*)edi_2 + 0x428a84);
0040b348                  
0040b365                  if (!sub_40b6d0(ebx, var_8_1, edx_2 >> 2 & 3))
0040b239                      return 0;
0040b291              }
0040b291              else if (ebx_2 == 1)
0040b298              {
0040b2fe                  ebx = arg1;
0040b302                  (uint8_t)edx_1 &= 0x30;
0040b30b                  esi_2 = eax_4 >> 0xe;
0040b30b                  
0040b312                  if ((uint8_t)edx_1 == 0x30 && esi_2 >= *(uint32_t*)((char*)ebx + 0x28))
0040b239                      return 0;
0040b298              }
0040b298              else
0040b298              {
0040b29b                  if (ebx_2 == 2)
0040b29b                  {
0040b2a4                      (uint8_t)edx_1 &= 0x30;
0040b2af                      esi_2 = (eax_4 >> 0xe) - 0x1ffff;
0040b29b                  }
0040b29b                  
0040b2b1                  if (ebx_2 != 2 || (uint8_t)edx_1 != 0x20)
0040b36d                      ebx = arg1;
0040b2b1                  else
0040b2b1                  {
0040b2c1                      if (esi_2 + var_c_1 + 1 < 0)
0040b239                          return 0;
0040b239                      
0040b2c7                      ebx = arg1;
0040b2c7                      
0040b2ce                      if (esi_2 + var_c_1 + 1 >= *(uint32_t*)((char*)ebx + 0x2c))
0040b239                          return 0;
0040b239                      
0040b2d6                      if (esi_2 + var_c_1 + 1 > 0)
0040b2d6                      {
0040b2df                          eax_4 = *(uint32_t*)(*(uint32_t*)((char*)ebx + 0xc)
0040b2df                              + ((esi_2 + var_c_1 + 1) << 2) - 4);
0040b2df                          
0040b2f6                          if (((uint8_t)eax_4 & 0x3f) == 0x22 && !(eax_4 & 0x7fc000))
0040b239                              return 0;
0040b2d6                      }
0040b2b1                  }
0040b298              }
0040b298              
0040b371              (uint8_t)eax_4 = *(uint8_t*)((char*)edi_2 + 0x428a84);
0040b377              edx_5 = var_c_1;
0040b37b              int32_t ecx_9 = arg3;
0040b37b              
0040b385              if ((uint8_t)eax_4 & 0x40 && ebp_3 == ecx_9)
0040b387                  var_4 = edx_5;
0040b387              
0040b38d              if ((uint8_t)eax_4 & 0x80)
0040b38d              {
0040b395                  if (edx_5 + 2 >= *(uint32_t*)((char*)ebx + 0x2c))
0040b239                      return 0;
0040b239                  
0040b3a7                  if (((char)*(uint32_t*)(*(uint32_t*)((char*)ebx + 0xc) + (edx_5 << 2) + 4)
0040b3a7                          & 0x3f) != 0x16)
0040b239                      return 0;
0040b38d              }
0040b38d              
0040b3b3              if ((char*)edi_2 - 2 <= 0x23)
0040b3b3              {
0040b3bb                  int32_t eax_15;
0040b3bb                  (uint8_t)eax_15 = *(uint8_t*)((char*)edi_2 +
0040b3bb                      &*(uint32_t*)((char*)jump_table_40b62c[0xe])[2]);
0040b3bb                  
0040b3c1                  switch (eax_15)
0040b3c1                  {
0040b3dc                      case 0:
0040b3dc                      {
0040b3dc                          if (var_8_1 && edx_5 + 2 >= *(uint32_t*)((char*)ebx + 0x2c))
0040b239                              return 0;
0040b3dc                          break;
0040b3dc                      }
0040b3f1                      case 1:
0040b3f1                      {
0040b3f1                          if (ebp_3 <= ecx_9 && ecx_9 <= esi_2)
0040b3f7                              var_4 = edx_5;
0040b3f1                          break;
0040b3f1                      }
0040b402                      case 2:
0040b402                      {
0040b402                          int32_t eax_18;
0040b402                          (uint8_t)eax_18 = *(uint8_t*)((char*)ebx + 0x48);
0040b402                          
0040b407                          if (esi_2 >= eax_18)
0040b239                              return 0;
0040b402                          break;
0040b402                      }
0040b41d                      case 3:
0040b41d                      {
0040b41d                          if (*(uint32_t*)((esi_2 << 4) + *(uint32_t*)((char*)ebx + 8) + 8)
0040b41d                                  != 4)
0040b239                              return 0;
0040b41d                          break;
0040b41d                      }
0040b42b                      case 4:
0040b42b                      {
0040b42b                          int32_t eax_19;
0040b42b                          (uint8_t)eax_19 = *(uint8_t*)((char*)ebx + 0x4b);
0040b42b                          
0040b430                          if (ebp_3 + 1 >= eax_19)
0040b239                              return 0;
0040b239                          
0040b438                          if (ecx_9 == ebp_3 + 1)
0040b43e                              var_4 = edx_5;
0040b42b                          break;
0040b42b                      }
0040b44b                      case 5:
0040b44b                      {
0040b44b                          if (esi_2 >= var_8_1)
0040b239                              return 0;
0040b44b                          break;
0040b44b                      }
0040b498                      case 6:
0040b498                      {
0040b498                      label_40b498:
0040b498                          
0040b4b4                          if (ecx_9 != 0xff && edx_5 < esi_2 + edx_5 + 1
0040b4b4                                  && esi_2 + edx_5 + 1 <= arg2)
0040b4ba                              edx_5 += esi_2;
0040b498                          break;
0040b498                      }
0040b4c3                      case 7:
0040b4c3                      {
0040b4c3                          if (esi_2)
0040b4c3                          {
0040b4cb                              int32_t eax_24;
0040b4cb                              (uint8_t)eax_24 = *(uint8_t*)((char*)ebx + 0x4b);
0040b4cb                              
0040b4d0                              if (esi_2 + ebp_3 - 1 >= eax_24)
0040b239                                  return 0;
0040b4c3                          }
0040b4c3                          
0040b4de                          int32_t var_8_2 = var_8_1 - 1;
0040b4de                          
0040b4e2                          if (!var_8_1)
0040b4e2                          {
0040b4fa                              if (!sub_40b1c0(*(uint32_t*)(*(uint32_t*)((char*)ebx + 0xc)
0040b4fa                                      + (var_c_1 << 2) + 4)))
0040b239                                  return 0;
0040b239                              
0040b500                              ecx_9 = arg3;
0040b504                              edx_5 = var_c_1;
0040b4e2                          }
0040b4e2                          else if (var_8_1 != 1)
0040b50c                          {
0040b514                              int32_t eax_29;
0040b514                              (uint8_t)eax_29 = *(uint8_t*)((char*)ebx + 0x4b);
0040b514                              
0040b519                              if (var_8_1 - 1 + ebp_3 - 1 >= eax_29)
0040b239                                  return 0;
0040b50c                          }
0040b50c                          
0040b521                          if (ecx_9 >= ebp_3)
0040b527                              var_4 = edx_5;
0040b4c3                          break;
0040b4c3                      }
0040b533                      case 8:
0040b533                      {
0040b533                          if (esi_2 - 1 > 0)
0040b533                          {
0040b53f                              int32_t eax_30;
0040b53f                              (uint8_t)eax_30 = *(uint8_t*)((char*)ebx + 0x4b);
0040b53f                              
0040b544                              if (esi_2 - 1 + ebp_3 - 1 >= eax_30)
0040b239                                  return 0;
0040b533                          }
0040b533                          break;
0040b533                      }
0040b48d                      case 9:
0040b48d                      {
0040b48d                          int32_t eax_22;
0040b48d                          (uint8_t)eax_22 = *(uint8_t*)((char*)ebx + 0x4b);
0040b48d                          
0040b492                          if (ebp_3 + 3 >= eax_22)
0040b239                              return 0;
0040b239                          
0040b492                          goto label_40b498;
0040b48d                      }
0040b45d                      case 0xa:
0040b45d                      {
0040b45d                          if (var_8_1 < 1)
0040b239                              return 0;
0040b239                          
0040b469                          int32_t eax_21;
0040b469                          (uint8_t)eax_21 = *(uint8_t*)((char*)ebx + 0x4b);
0040b469                          
0040b46e                          if (var_8_1 + ebp_3 + 2 >= eax_21)
0040b239                              return 0;
0040b239                          
0040b479                          if (ecx_9 >= ebp_3 + 2)
0040b47f                              var_4 = edx_5;
0040b45d                          break;
0040b45d                      }
0040b551                      case 0xb:
0040b551                      {
0040b551                          if (esi_2 > 0)
0040b551                          {
0040b557                              int32_t ecx_14;
0040b557                              (uint8_t)ecx_14 = *(uint8_t*)((char*)ebx + 0x4b);
0040b557                              
0040b55c                              if (esi_2 + ebp_3 >= ecx_14)
0040b239                                  return 0;
0040b551                          }
0040b551                          
0040b568                          if (!var_8_1)
0040b56e                              edx_5 += 1;
0040b551                          break;
0040b551                      }
0040b577                      case 0xc:
0040b577                      {
0040b577                          if (esi_2 >= *(uint32_t*)((char*)ebx + 0x34))
0040b239                              return 0;
0040b239                          
0040b588                          int32_t j_1;
0040b588                          (uint8_t)j_1 = *(uint8_t*)(
0040b588                              *(uint32_t*)(*(uint32_t*)((char*)ebx + 0x10) + (esi_2 << 2))
0040b588                              + 0x48);
0040b58b                          int32_t j = j_1;
0040b58d                          int32_t eax_33 = j + edx_5;
0040b58d                          
0040b592                          if (eax_33 >= *(uint32_t*)((char*)ebx + 0x2c))
0040b239                              return 0;
0040b239                          
0040b59a                          if (j > 0)
0040b59a                          {
0040b59f                              int32_t* esi_12 =
0040b59f                                  *(uint32_t*)((char*)ebx + 0xc) + (eax_33 << 2);
0040b59f                              
0040b5ba                              do
0040b5ba                              {
0040b5a4                                  int32_t eax_35 = *(uint32_t*)esi_12 & 0x3f;
0040b5a4                                  
0040b5ae                                  if (eax_35 != 4 && eax_35)
0040b239                                      return 0;
0040b239                                  
0040b5b4                                  j -= 1;
0040b5b5                                  esi_12 -= 4;
0040b5ba                              } while (j > 0);
0040b59a                          }
0040b577                          break;
0040b577                      }
0040b5be                      case 0xd:
0040b5be                      {
0040b5be                          (uint8_t)eax_15 = *(uint8_t*)((char*)ebx + 0x4a);
0040b5be                          
0040b5c3                          if (!((uint8_t)eax_15 & 2))
0040b239                              return 0;
0040b239                          
0040b5cb                          if ((uint8_t)eax_15 & 4)
0040b239                              return 0;
0040b239                          
0040b5d5                          if (!esi_2)
0040b5d5                          {
0040b5ed                              if (!sub_40b1c0(*(uint32_t*)(*(uint32_t*)((char*)ebx + 0xc)
0040b5ed                                      + (var_c_1 << 2) + 4)))
0040b239                                  return 0;
0040b239                              
0040b5f3                              edx_5 = var_c_1;
0040b5d5                          }
0040b5d5                          
0040b5fd                          int32_t eax_38;
0040b5fd                          (uint8_t)eax_38 = *(uint8_t*)((char*)ebx + 0x4b);
0040b5fd                          
0040b602                          if (esi_2 - 1 + ebp_3 - 1 >= eax_38)
0040b239                              return 0;
0040b5be                          break;
0040b5be                      }
0040b3c1                  }
0040b3b3              }
0040b3b3              
0040b60f              var_c_1 = edx_5 + 1;
0040b613          } while (edx_5 + 1 < arg2);
0040b619          esi_1 = var_4;
0040b248      }
0040b248      
0040b62a      return *(uint32_t*)(*(uint32_t*)((char*)ebx + 0xc) + (esi_1 << 2));
0040b210  }

0040b62b                                   90                                                                         .
0040b62c  uint32_t jump_table_40b62c[0xf] = 
0040b62c  {
0040b62c      [0x0] =  0x0040b3c8
0040b630      [0x1] =  0x0040b3e7
0040b634      [0x2] =  0x0040b400
0040b638      [0x3] =  0x0040b412
0040b63c      [0x4] =  0x0040b428
0040b640      [0x5] =  0x0040b447
0040b644      [0x6] =  0x0040b498
0040b648      [0x7] =  0x0040b4c1
0040b64c      [0x8] =  0x0040b530
0040b650      [0x9] =  0x0040b488
0040b654      [0xa] =  0x0040b456
0040b658      [0xb] =  0x0040b54f
0040b65c      [0xc] =  0x0040b574
0040b660      [0xd] =  0x0040b5be
0040b664      [0xe] =  0x0040b608
0040b668  }
0040b668  uint8_t lookup_table_40b668[0x24] = 
0040b668  {
0040b668      [0x00] =  0x00
0040b669      [0x01] =  0x01
0040b66a      [0x02] =  0x02
0040b66b      [0x03] =  0x03
0040b66c      [0x04] =  0x0e
0040b66d      [0x05] =  0x03
0040b66e      [0x06] =  0x02
0040b66f      [0x07] =  0x0e
0040b670      [0x08] =  0x0e
0040b671      [0x09] =  0x04
0040b672      [0x0a] =  0x0e
0040b673      [0x0b] =  0x0e
0040b674      [0x0c] =  0x0e
0040b675      [0x0d] =  0x0e
0040b676      [0x0e] =  0x0e
0040b677      [0x0f] =  0x0e
0040b678      [0x10] =  0x0e
0040b679      [0x11] =  0x0e
0040b67a      [0x12] =  0x0e
0040b67b      [0x13] =  0x05
0040b67c      [0x14] =  0x06
0040b67d      [0x15] =  0x0e
0040b67e      [0x16] =  0x0e
0040b67f      [0x17] =  0x0e
0040b680      [0x18] =  0x0e
0040b681      [0x19] =  0x0e
0040b682      [0x1a] =  0x07
0040b683      [0x1b] =  0x07
0040b684      [0x1c] =  0x08
0040b685      [0x1d] =  0x09
0040b686      [0x1e] =  0x09
0040b687      [0x1f] =  0x0a
0040b688      [0x20] =  0x0b
0040b689      [0x21] =  0x0e
0040b68a      [0x22] =  0x0c
0040b68b      [0x23] =  0x0d
0040b68c  }

0040b68c                                      90 90 90 90                                                              ....

0040b690    int32_t sub_40b690(void* arg1)

0040b690  {
0040b698      if (*(uint8_t*)((char*)arg1 + 0x4b) > 0xfa)
0040b69c          return 0;
0040b69c      
0040b6a2      int32_t ecx;
0040b6a2      (uint8_t)ecx = *(uint8_t*)((char*)arg1 + 0x48);
0040b6a2      
0040b6a7      if (*(uint32_t*)((char*)arg1 + 0x24) > ecx)
0040b6ab          return 0;
0040b6ab      
0040b6ac      int32_t edx_1 = *(uint32_t*)((char*)arg1 + 0x30);
0040b6af      int32_t ecx_1 = *(uint32_t*)((char*)arg1 + 0x2c);
0040b6af      
0040b6b8      if (edx_1 != ecx_1 && edx_1)
0040b6bc          return 0;
0040b6bc      
0040b6ca      int32_t result;
0040b6ca      (uint8_t)result = (
0040b6ca          (char)*(uint32_t*)(*(uint32_t*)((char*)arg1 + 0xc) + (ecx_1 << 2) - 4) & 0x3f)
0040b6ca          == 0x1e;
0040b6cf      return result;
0040b690  }


0040b6d0    int32_t sub_40b6d0(void* arg1, int32_t arg2, int32_t arg3)

0040b6d0  {
0040b6d7      if (!arg3)
0040b6d7      {
0040b732          if (arg2)
0040b736              return 0;
0040b6d7      }
0040b6d7      else if (arg3 == 2)
0040b6dc      {
0040b71e          int32_t eax_4;
0040b71e          (uint8_t)eax_4 = *(uint8_t*)((char*)arg1 + 0x4b);
0040b71e          
0040b727          if (arg2 >= eax_4)
0040b72b              return 0;
0040b6dc      }
0040b6dc      else if (arg3 == 3)
0040b6df      {
0040b6e8          int32_t result;
0040b6e8          
0040b6e8          if (!(*(uint8_t*)((char*)arg2)[1] & 1))
0040b6e8          {
0040b707              int32_t ecx_1;
0040b707              (uint8_t)ecx_1 = *(uint8_t*)((char*)arg1 + 0x4b);
0040b70e              int32_t result_2;
0040b70e              (uint8_t)result_2 = arg2 < ecx_1;
0040b711              result = result_2;
0040b6e8          }
0040b6e8          else
0040b6e8          {
0040b6ef              int32_t eax_3;
0040b6ef              *(uint8_t*)((char*)eax_3)[1] = *(uint8_t*)((char*)arg2)[1] & 0xfe;
0040b6fa              int32_t result_1;
0040b6fa              (uint8_t)result_1 = eax_3 < *(uint32_t*)((char*)arg1 + 0x28);
0040b6fd              result = result_1;
0040b6e8          }
0040b6e8          
0040b715          if (!result)
0040b717              return result;
0040b6df      }
0040b6df      
0040b73c      return 1;
0040b6d0  }

0040b73d                                                                                         90 90 90                               ...

0040b740    int32_t sub_40b740(void* arg1, void* arg2, int32_t* arg3)

0040b740  {
0040b74b      int32_t* eax = *(uint32_t*)((char*)arg2 + 4);
0040b74b      
0040b761      if (eax[2] != 6 || *(uint8_t*)(*(uint32_t*)eax + 6)
0040b761          || *(uint32_t*)((char*)arg2 + 0x14) <= 0)
0040b761      {
0040b763          int32_t* eax_3 = *(uint32_t*)((char*)arg2 - 0x14);
0040b763          
0040b769          if (eax_3[2] == 6)
0040b769          {
0040b76d              (uint8_t)eax_3 = *(uint8_t*)(*(uint32_t*)eax_3 + 6);
0040b76d              
0040b772              if (!(uint8_t)eax_3)
0040b772              {
0040b77d                  int32_t eax_4 = sub_40ad60(arg1, (char*)arg2 - 0x18);
0040b790                  int32_t eax_5 = *(uint32_t*)(*(uint32_t*)(
0040b790                      *(uint32_t*)(**(uint32_t**)((char*)arg2 - 0x14) + 0x10) + 0xc)
0040b790                      + (eax_4 << 2));
0040b795                  int32_t ecx_5 = eax_5 & 0x3f;
0040b795                  
0040b7a5                  if (ecx_5 == 0x1c || ecx_5 == 0x1d || ecx_5 == 0x21)
0040b7c1                      return sub_40b7d0(arg1, (char*)arg2 - 0x18, 
0040b7c1                          (uint32_t)(uint8_t)(eax_5 >> 6), arg3);
0040b772              }
0040b769          }
0040b761      }
0040b761      
0040b7c6      return 0;
0040b740  }

0040b7c7                       90 90 90 90 90 90 90 90 90                                                         .........

0040b7d0    int32_t sub_40b7d0(void* arg1, void* arg2, uint32_t arg3, int32_t* arg4)

0040b7d0  {
0040b7d8      int32_t* eax = *(uint32_t*)((char*)arg2 + 4);
0040b7d8      
0040b7df      if (eax[2] == 6)
0040b7df      {
0040b7e1          uint32_t ebx_1 = arg3;
0040b7e1          
0040b7e5          while (true)
0040b7e5          {
0040b7e5              void* eax_1 = *(uint32_t*)eax;
0040b7e7              int32_t ecx;
0040b7e7              (uint8_t)ecx = *(uint8_t*)((char*)eax_1 + 6);
0040b7e7              
0040b7ec              if ((uint8_t)ecx)
0040b7ec                  break;
0040b7ec              
0040b7ee              void* esi_1 = *(uint32_t*)((char*)eax_1 + 0x10);
0040b7f7              int32_t eax_3 = sub_40ad60(arg1, arg2);
0040b804              int32_t eax_4 = sub_4050d0(esi_1, ebx_1 + 1, eax_3);
0040b812              *(uint32_t*)arg4 = eax_4;
0040b812              
0040b814              if (eax_4)
0040b864                  return "local";
0040b864              
0040b819              int32_t eax_5 = sub_40b210(esi_1, eax_3, ebx_1);
0040b823              ecx = eax_5 & 0x3f;
0040b823              
0040b829              if (ecx > 0xb)
0040b829                  break;
0040b829              
0040b82d              int32_t edx_2;
0040b82d              (uint8_t)edx_2 = lookup_table_40b918[ecx];
0040b82d              
0040b833              switch (edx_2)
0040b833              {
0040b83f                  case 0:
0040b83f                  {
0040b83f                      ebx_1 = eax_5 >> 0x17;
0040b83f                      
0040b849                      if (ebx_1 >= (uint32_t)(uint8_t)(eax_5 >> 6))
0040b849                          break;
0040b849                      
0040b84b                      eax = *(uint32_t*)((char*)arg2 + 4);
0040b84b                      
0040b852                      if (eax[2] != 6)
0040b852                          break;
0040b852                      
0040b852                      continue;
0040b83f                  }
0040b8a6                  case 1:
0040b8a6                  {
0040b8a6                      int32_t esi_2 = *(uint32_t*)((char*)esi_1 + 0x1c);
0040b8a6                      
0040b8ab                      if (!esi_2)
0040b8ab                      {
0040b8d1                          *(uint32_t*)arg4 = &data_42b128;
0040b8da                          return "upvalue";
0040b8ab                      }
0040b8ab                      
0040b8bd                      *(uint32_t*)arg4 = *(uint32_t*)(esi_2 + (eax_5 >> 0x17 << 2)) + 0x10;
0040b8c5                      return "upvalue";
0040b8a6                      break;
0040b8a6                  }
0040b87c                  case 2:
0040b87c                  {
0040b87c                      *(uint32_t*)arg4 =
0040b87c                          *(uint32_t*)((eax_5 >> 0xe << 4) + *(uint32_t*)((char*)esi_1 + 8))
0040b87c                          + 0x10;
0040b883                      return "global";
0040b87c                      break;
0040b87c                  }
0040b89c                  case 3:
0040b89c                  {
0040b89c                      *(uint32_t*)arg4 = sub_40b930(esi_1, eax_5 >> 0xe & 0x1ff);
0040b8a5                      return "field";
0040b89c                      break;
0040b89c                  }
0040b8f3                  case 4:
0040b8f3                  {
0040b8f3                      *(uint32_t*)arg4 = sub_40b930(esi_1, eax_5 >> 0xe & 0x1ff);
0040b8fc                      return "method";
0040b8f3                      break;
0040b8f3                  }
0040b833                  case 5:
0040b833                  {
0040b833                      break;
0040b833                      break;
0040b833                  }
0040b833              }
0040b7e5          }
0040b7df      }
0040b7df      
0040b85a      return 0;
0040b7d0  }

0040b8fd                                                                                         8d 49 00                               .I.
0040b900  uint32_t jump_table_40b900[0x6] = 
0040b900  {
0040b900      [0x0] =  0x0040b83a
0040b904      [0x1] =  0x0040b8a6
0040b908      [0x2] =  0x0040b865
0040b90c      [0x3] =  0x0040b884
0040b910      [0x4] =  0x0040b8db
0040b914      [0x5] =  0x0040b854
0040b918  }
0040b918  uint8_t lookup_table_40b918[0xc] = 
0040b918  {
0040b918      [0x0] =  0x00
0040b919      [0x1] =  0x05
0040b91a      [0x2] =  0x05
0040b91b      [0x3] =  0x05
0040b91c      [0x4] =  0x01
0040b91d      [0x5] =  0x02
0040b91e      [0x6] =  0x03
0040b91f      [0x7] =  0x05
0040b920      [0x8] =  0x05
0040b921      [0x9] =  0x05
0040b922      [0xa] =  0x05
0040b923      [0xb] =  0x04
0040b924  }

0040b924              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040b930    int32_t sub_40b930(void* arg1, int32_t arg2)

0040b930  {
0040b937      if (*(uint8_t*)((char*)arg2)[1] & 1)
0040b937      {
0040b93d          int32_t eax;
0040b93d          *(uint8_t*)((char*)eax)[1] = *(uint8_t*)((char*)arg2)[1] & 0xfe;
0040b940          int32_t eax_1 = eax << 4;
0040b943          int32_t edx_1 = *(uint32_t*)((char*)arg1 + 8);
0040b943          
0040b94f          if (*(uint32_t*)(eax_1 + edx_1 + 8) == 4)
0040b956              return *(uint32_t*)(eax_1 + edx_1) + 0x10;
0040b937      }
0040b937      
0040b95c      return &data_42b128;
0040b930  }

0040b95d                                                                                         90 90 90                               ...

0040b960    int32_t __convention("regparm") sub_40b960(int32_t arg1, int32_t arg2, int32_t arg3, void* arg4, void* arg5, int32_t arg6)

0040b960  {
0040b960      int32_t var_4 = arg3;
0040b96d      int32_t eax = *(uint32_t*)((char*)arg5 + 8);
0040b970      var_4 = 0;
0040b97b      int32_t ebx = *(uint32_t*)((eax << 2) + &data_428298);
0040b97b      
0040b98d      if (sub_40b9f0(*(uint32_t*)((char*)arg4 + 0x14), arg5))
0040b98d      {
0040b9a2          int32_t eax_3 = sub_40b7d0(arg4, *(uint32_t*)((char*)arg4 + 0x14), 
0040b9a2              ((char*)arg5 - *(uint32_t*)((char*)arg4 + 0xc)) >> 4, &var_4);
0040b9a2          
0040b9ac          if (eax_3)
0040b9ac          {
0040b9b6              int32_t var_14_2 = ebx;
0040b9b7              int32_t var_18_2 = var_4;
0040b9b8              int32_t var_1c_2 = eax_3;
0040b9b9              int32_t var_20_2 = arg6;
0040b9cc              return sub_40bb80(arg4, "attempt to %s %s '%s' (a %s value)");
0040b9ac          }
0040b98d      }
0040b98d      
0040b9d1      int32_t var_14_3 = ebx;
0040b9d2      int32_t var_18_3 = arg6;
0040b9e5      return sub_40bb80(arg4, "attempt to %s a %s value");
0040b960  }

0040b9e6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

0040b9f0    int32_t sub_40b9f0(int32_t* arg1, int32_t arg2)

0040b9f0  {
0040b9fb      for (int32_t i = *(uint32_t*)arg1; i < arg1[2]; i += 0x10)
0040b9fb      {
0040ba03          if (arg2 == i)
0040ba14              return 1;
0040b9fb      }
0040b9fb      
0040ba0e      return 0;
0040b9f0  }

0040ba15                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040ba20    int32_t sub_40ba20(void* arg1, void* arg2, void* arg3)

0040ba20  {
0040ba20      void* eax = arg2;
0040ba20      
0040ba28      if (*(uint32_t*)((char*)eax + 8) == 4)
0040ba2a          eax = arg3;
0040ba2a      
0040ba41      int32_t ecx;
0040ba41      int32_t edx;
0040ba41      return sub_40b960(arg1, edx, ecx, arg1, eax, "concatenate");
0040ba20  }

0040ba42        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0040ba50    int32_t sub_40ba50(void* arg1, int32_t* arg2, int32_t* arg3)

0040ba50  {
0040ba5e      double var_10[0x2];
0040ba5e      int32_t* eax;
0040ba5e      int32_t edx;
0040ba5e      eax = sub_408900(arg2, &var_10);
0040ba68      int32_t* eax_1 = arg2;
0040ba68      
0040ba6a      if (eax)
0040ba6c          eax_1 = arg3;
0040ba6c      
0040ba87      return sub_40b960(eax_1, edx, arg1, arg1, eax_1, "perform arithmetic on");
0040ba50  }

0040ba88                          90 90 90 90 90 90 90 90                                                          ........

0040ba90    int32_t sub_40ba90(void* arg1, void* arg2, void* arg3)

0040ba90  {
0040ba9c      void* __saved_ebx_2 =
0040ba9c          *(uint32_t*)((*(uint32_t*)((char*)arg2 + 8) << 2) + &data_428298);
0040baa6      void* __saved_ebx_3 =
0040baa6          *(uint32_t*)((*(uint32_t*)((char*)arg3 + 8) << 2) + &data_428298);
0040baad      void* edx;
0040baad      (uint8_t)edx = *(uint8_t*)((char*)__saved_ebx_2 + 2);
0040bab0      int32_t ebx;
0040bab0      (uint8_t)ebx = *(uint8_t*)((char*)__saved_ebx_3 + 2);
0040bab0      
0040bab6      if ((uint8_t)edx == (uint8_t)ebx)
0040bab6      {
0040bab8          void* __saved_ebx = __saved_ebx_2;
0040bac3          sub_40bb80(arg1, "attempt to compare two %s values");
0040bacd          return 0;
0040bab6      }
0040bab6      
0040bace      void* __saved_ebx_1 = __saved_ebx_3;
0040bad3      void* __saved_ebx_4 = __saved_ebx_2;
0040bada      sub_40bb80(arg1, "attempt to compare %s with %s");
0040bae4      return 0;
0040ba90  }

0040bae5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040baf0    int32_t sub_40baf0(void* arg1)

0040baf0  {
0040baf5      int32_t eax = *(uint32_t*)((char*)arg1 + 0x74);
0040baf5      
0040bafa      if (eax)
0040bafa      {
0040bb00          int32_t* edi_2 = *(uint32_t*)((char*)arg1 + 0x20) + eax;
0040bb00          
0040bb06          if (edi_2[2] != 6)
0040bb0b              sub_4051a0(arg1, 5);
0040bb0b          
0040bb13          int32_t* eax_1 = *(uint32_t*)((char*)arg1 + 8);
0040bb19          *(uint32_t*)eax_1 = eax_1[-4];
0040bb1e          eax_1[1] = eax_1[-3];
0040bb24          eax_1[2] = eax_1[-2];
0040bb2c          int32_t* eax_3 = *(uint32_t*)((char*)arg1 + 8) - 0x10;
0040bb2f          *(uint32_t*)eax_3 = *(uint32_t*)edi_2;
0040bb34          eax_3[1] = edi_2[1];
0040bb3a          eax_3[2] = edi_2[2];
0040bb3a          
0040bb49          if (*(uint32_t*)((char*)arg1 + 0x1c) - *(uint32_t*)((char*)arg1 + 8) <= 0x10)
0040bb4e              sub_405460(arg1, 1);
0040bb4e          
0040bb5b          void* eax_7 = *(uint32_t*)((char*)arg1 + 8) + 0x10;
0040bb5e          *(uint32_t*)((char*)arg1 + 8) = eax_7;
0040bb66          sub_405a80(arg1, (char*)eax_7 - 0x20, 1);
0040bafa      }
0040bafa      
0040bb7a      return sub_4051a0(arg1, 2);
0040baf0  }

0040bb7b                                                                                   90 90 90 90 90                             .....

0040bb80    int32_t sub_40bb80(void* arg1, double* arg2)

0040bb80  {
0040bb8d      void arg_c;
0040bb8d      void* var_8 = &arg_c;
0040bb97      sub_40bbb0(arg1, sub_4084b0(arg1, arg2));
0040bba6      return sub_40baf0(arg1);
0040bb80  }

0040bba7                       90 90 90 90 90 90 90 90 90                                                         .........

0040bbb0    void** sub_40bbb0(void* arg1, int32_t arg2)

0040bbb0  {
0040bbb9      void* esi = *(uint32_t*)((char*)arg1 + 0x14);
0040bbbc      void** result = *(uint32_t*)((char*)esi + 4);
0040bbbc      
0040bbc3      if (result[2] == 6)
0040bbc3      {
0040bbc5          result = *(uint32_t*)result;
0040bbc5          
0040bbcc          if (!*(uint8_t*)((char*)result + 6))
0040bbcc          {
0040bbd1              int32_t eax = sub_40b0b0(arg1, esi);
0040bbf2              char var_3c[0x3c];
0040bbf2              sub_4087c0(&var_3c, *(uint32_t*)(sub_40ada0(esi) + 0x20) + 0x10, 0x3c);
0040bbff              int32_t var_58_1 = arg2;
0040bc00              int32_t var_5c_1 = eax;
0040bc01              char (* var_60_1)[0x3c] = &var_3c;
0040bc08              return sub_4087a0(arg1, "%s:%d: %s");
0040bbcc          }
0040bbc3      }
0040bbc3      
0040bc16      return result;
0040bbb0  }

0040bc17                                                                       90 90 90 90 90 90 90 90 90                         .........

0040bc20    int32_t sub_40bc20(void* arg1)

0040bc20  {
0040bc2a      sub_401b20(arg1, 0xffffd8f0);
0040bc37      return 1;
0040bc20  }

0040bc38                                                                          90 90 90 90 90 90 90 90                          ........

0040bc40    int32_t sub_40bc40(void* arg1)

0040bc40  {
0040bc48      sub_403080(arg1, 1);
0040bc48      
0040bc5a      if (!sub_402380(arg1, 1))
0040bc5d          sub_401f80(arg1);
0040bc5d      
0040bc6b      return 1;
0040bc40  }

0040bc6c                                      90 90 90 90                                                              ....

0040bc70    int32_t sub_40bc70(void* arg1)

0040bc70  {
0040bc78      int32_t eax = sub_401b60(arg1, 2);
0040bc78      
0040bc87      if (eax && eax != 5)
0040bc91          sub_402ca0(arg1, 2, "nil or table expected");
0040bc91      
0040bc9c      sub_4018d0(arg1, 2);
0040bca4      sub_4025e0(arg1, 1);
0040bcab      sub_4021a0(arg1, 1);
0040bcb9      return 1;
0040bc70  }

0040bcba                                                                                90 90 90 90 90 90                            ......

0040bcc0    int32_t sub_40bcc0(void* arg1)

0040bcc0  {
0040bcc7      sub_4023e0(arg1, 1);
0040bcd4      return 1;
0040bcc0  }

0040bcd5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040bce0    int32_t sub_40bce0(void* arg1)

0040bce0  {
0040bcea      sub_403020(arg1, 2, 5);
0040bcf2      sub_4018d0(arg1, 2);
0040bcf2      
0040bd04      if (!sub_4026a0(arg1, 1))
0040bd0c          sub_402e40(arg1, "'setfenv' cannot change environment of given object");
0040bd0c      
0040bd1a      return 1;
0040bce0  }

0040bd1b                                                                                   90 90 90 90 90                             .....

0040bd20    int32_t sub_40bd20(void* arg1)

0040bd20  {
0040bd29      void* esi = arg1;
0040bd30      void* eax = sub_40bf90(esi, &arg1);
0040bd53      char* edi = sub_4030f0(esi, (char*)arg1 + 2, "flnSu", nullptr);
0040bd62      void var_64;
0040bd62      
0040bd62      if (!sub_401be0(esi, (char*)arg1 + 1))
0040bd62      {
0040bdad          if (sub_401b60(esi, (char*)arg1 + 1) != 6)
0040bdad          {
0040bf4c              sub_402ca0(esi, (char*)arg1 + 1, "function or level expected");
0040bf5a              return 0;
0040bdad          }
0040bdad          
0040bdb3          char* var_74_4 = edi;
0040bdba          sub_4020b0(esi, 0x42b9ec);
0040bdc9          edi = sub_401db0(esi, 0xffffffff, nullptr);
0040bdd5          sub_401b20(esi, (char*)arg1 + 1);
0040bdde          sub_401800(esi, eax, 1);
0040bd62      }
0040bd62      else if (!sub_40ac30(eax, sub_401d30(esi, (char*)arg1 + 1), &var_64))
0040bd84      {
0040bd87          sub_401f80(esi);
0040bd9a          return 1;
0040bd84      }
0040bd84      
0040bdf7      if (!sub_40ae20(eax, edi, &var_64))
0040bdf7      {
0040be07          sub_402ca0(esi, (char*)arg1 + 2, "invalid option");
0040be15          return 0;
0040bdf7      }
0040bdf7      
0040be1b      sub_402330(esi, 0, 2);
0040be1b      
0040be2d      if (sub_4172f0(edi, 0x53))
0040be2d      {
0040be3a          char* var_54;
0040be3a          sub_40bf60(esi, "source", var_54);
0040be4a          void var_40;
0040be4a          sub_40bf60(esi, "short_src", &var_40);
0040be5a          int32_t var_48;
0040be5a          sub_40f040(esi, "linedefined", var_48);
0040be6a          int32_t var_44;
0040be6a          sub_40f040(esi, "lastlinedefined", var_44);
0040be7a          char* var_58;
0040be7a          sub_40bf60(esi, "what", var_58);
0040be2d      }
0040be2d      
0040be8f      int32_t var_50;
0040be8f      
0040be8f      if (sub_4172f0(edi, 0x6c))
0040be9c          sub_40f040(esi, "currentline", var_50);
0040beb1      int32_t var_4c;
0040beb1      
0040beb1      if (sub_4172f0(edi, 0x75))
0040bebe          sub_40f040(esi, "nups", var_4c);
0040bebe      
0040bed3      if (sub_4172f0(edi, 0x6e))
0040bed3      {
0040bee0          char* var_60;
0040bee0          sub_40bf60(esi, "name", var_60);
0040bef0          char* var_5c;
0040bef0          sub_40bf60(esi, "namewhat", var_5c);
0040bed3      }
0040bed3      
0040bf05      if (sub_4172f0(edi, 0x4c))
0040bf0e          sub_40bfd0(esi, eax, "activelines");
0040bf0e      
0040bf23      if (sub_4172f0(edi, 0x66))
0040bf2c          sub_40bfd0(esi, eax, "func");
0040bf2c      
0040bf3f      return 1;
0040bd20  }

0040bf5b                                                                                   90 90 90 90 90                             .....

0040bf60    int32_t sub_40bf60(void* arg1, char* arg2, char* arg3)

0040bf60  {
0040bf6b      sub_402040(arg1, arg3);
0040bf81      return sub_402490(arg1, 0xfffffffe, arg2);
0040bf60  }

0040bf82        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0040bf90    void* sub_40bf90(void* arg1, int32_t* arg2)

0040bf90  {
0040bfa3      if (sub_401b60(arg1, 1) != 8)
0040bfa3      {
0040bfc3          *(uint32_t*)arg2 = 0;
0040bfc9          return arg1;
0040bfa3      }
0040bfa3      
0040bfac      *(uint32_t*)arg2 = 1;
0040bfbb      return sub_401f00(arg1, 1);
0040bf90  }

0040bfca                                90 90 90 90 90 90                                                            ......

0040bfd0    int32_t sub_40bfd0(void* arg1, void* arg2, char* arg3)

0040bfd0  {
0040bfdb      if (arg1 != arg2)
0040bfdb      {
0040c006          sub_401800(arg2, arg1, 1);
0040c01f          return sub_402490(arg1, 0xfffffffe, arg3);
0040bfdb      }
0040bfdb      
0040bfe0      sub_401b20(arg1, 0xfffffffe);
0040bfe8      sub_401920(arg1, 0xfffffffd);
0040c001      return sub_402490(arg1, 0xfffffffe, arg3);
0040bfd0  }


0040c020    int32_t sub_40c020(void* arg1)

0040c020  {
0040c029      void* esi = arg1;
0040c030      void* eax = sub_40bf90(esi, &arg1);
0040c05a      void var_64;
0040c05a      
0040c05a      if (!sub_40ac30(eax, sub_4031d0(esi, (char*)arg1 + 1), &var_64))
0040c05a      {
0040c068          sub_402ca0(esi, (char*)arg1 + 1, "level out of range");
0040c076          return 0;
0040c05a      }
0040c05a      
0040c08c      char* eax_6 = sub_40acb0(eax, &var_64, sub_4031d0(esi, (char*)arg1 + 2));
0040c08c      
0040c098      if (!eax_6)
0040c098      {
0040c0c2          sub_401f80(esi);
0040c0d5          return 1;
0040c098      }
0040c098      
0040c09e      sub_401800(eax, esi, 1);
0040c0a5      sub_402040(esi, eax_6);
0040c0ad      sub_401b20(esi, 0xfffffffe);
0040c0c0      return 2;
0040c020  }

0040c0d6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040c0e0    int32_t sub_40c0e0(void* arg1)

0040c0e0  {
0040c0e8      void* esi = arg1;
0040c0ef      void* eax = sub_40bf90(esi, &arg1);
0040c119      void var_64;
0040c119      
0040c119      if (!sub_40ac30(eax, sub_4031d0(esi, (char*)arg1 + 1), &var_64))
0040c119      {
0040c127          sub_402ca0(esi, (char*)arg1 + 1, "level out of range");
0040c134          return 0;
0040c119      }
0040c119      
0040c13e      sub_403080(esi, (char*)arg1 + 3);
0040c14c      sub_4018d0(esi, (char*)arg1 + 3);
0040c155      sub_401800(esi, eax, 1);
0040c179      sub_402040(esi, sub_40adc0(eax, &var_64, sub_4031d0(esi, (char*)arg1 + 2)));
0040c18b      return 1;
0040c0e0  }

0040c18c                                      90 90 90 90                                                              ....

0040c190    char* sub_40c190(void* arg1)

0040c190  {
0040c19f      return sub_40c1a0(arg1, 1);
0040c190  }


0040c1a0    char* sub_40c1a0(void* arg1, int32_t arg2)

0040c1a0  {
0040c1aa      void* eax = sub_4031d0(arg1, 2);
0040c1b6      sub_403020(arg1, 1, 6);
0040c1b6      
0040c1c8      if (sub_401bb0(arg1, 1))
0040c1cf          return 0;
0040c1cf      
0040c1da      char* result;
0040c1da      
0040c1da      if (!arg2)
0040c1e3          result = sub_402c20(arg1, 1, eax);
0040c1da      else
0040c1dc          result = sub_402b60(arg1, 1, eax);
0040c1dc      
0040c1ed      if (!result)
0040c1f2          return result;
0040c1f2      
0040c1f5      sub_402040(arg1, result);
0040c201      sub_401a20(arg1, 0xffffffff - arg2);
0040c20f      return arg2 + 1;
0040c1a0  }


0040c210    char* sub_40c210(void* arg1)

0040c210  {
0040c218      sub_403080(arg1, 3);
0040c229      return sub_40c1a0(arg1, 0);
0040c210  }

0040c22a                                90 90 90 90 90 90                                                            ......

0040c230    int32_t sub_40c230(void* arg1)

0040c230  {
0040c231      void* esi = arg1;
0040c23c      void* eax = sub_40bf90(esi, &arg1);
0040c23c      
0040c254      if (sub_401b60(esi, (char*)arg1 + 1) > 0)
0040c254      {
0040c280          char* eax_4 = sub_4030b0(esi, (char*)arg1 + 2, nullptr);
0040c292          void* eax_5 = sub_403210(esi, (char*)arg1 + 3, 0);
0040c2a2          sub_403020(esi, (char*)arg1 + 1, 6);
0040c2bc          sub_40abd0(eax, sub_40c300, sub_40c390(eax_4, eax_5), eax_5);
0040c254      }
0040c254      else
0040c254      {
0040c25d          sub_4018d0(esi, (char*)arg1 + 1);
0040c269          sub_40abd0(eax, 0, 0, 0);
0040c254      }
0040c254      
0040c2c7      sub_40c3e0(eax);
0040c2ce      sub_4021d0(eax, eax);
0040c2da      sub_401b20(esi, (char*)arg1 + 1);
0040c2e3      sub_401800(esi, eax, 1);
0040c2eb      sub_402500(eax, 0xfffffffd);
0040c2f3      sub_4018d0(eax, 0xfffffffe);
0040c2ff      return 0;
0040c230  }


0040c300    void* sub_40c300(void* arg1, int32_t* arg2)

0040c300  {
0040c30b      sub_4021d0(arg1, 0x428440);
0040c316      sub_4022b0(arg1, 0xffffd8f0);
0040c31d      sub_4021d0(arg1, arg1);
0040c325      sub_4022b0(arg1, 0xfffffffe);
0040c32d      void* result = sub_401b60(arg1, 0xffffffff);
0040c32d      
0040c338      if (result != 6)
0040c38a          return result;
0040c38a      
0040c34a      sub_402040(arg1, (&data_428444)[*(uint32_t*)arg2]);
0040c34f      int32_t eax_1 = arg2[5];
0040c34f      
0040c358      if (eax_1 < 0)
0040c358      {
0040c374          sub_401f80(arg1);
0040c381          return sub_402730(arg1, 2, 0);
0040c358      }
0040c358      
0040c35c      sub_401fd0(arg1, eax_1);
0040c372      return sub_402730(arg1, 2, 0);
0040c300  }

0040c38b                                   90 90 90 90 90                                                             .....

0040c390    int32_t sub_40c390(char* arg1, int32_t arg2)

0040c390  {
0040c399      int32_t result = 0;
0040c399      
0040c3a5      if (sub_4172f0(arg1, 0x63))
0040c3a7          result = 1;
0040c3a7      
0040c3b9      if (sub_4172f0(arg1, 0x72))
0040c3bb          result |= 2;
0040c3bb      
0040c3cb      if (sub_4172f0(arg1, 0x6c))
0040c3cd          result |= 4;
0040c3cd      
0040c3d6      if (arg2 <= 0)
0040c3df          return result;
0040c3df      
0040c3d8      return result | 8;
0040c390  }


0040c3e0    int32_t sub_40c3e0(void* arg1)

0040c3e0  {
0040c3eb      sub_4021d0(arg1, 0x428440);
0040c3f6      sub_4022b0(arg1, 0xffffd8f0);
0040c3fe      int32_t result = sub_401b60(arg1, 0xffffffff);
0040c3fe      
0040c409      if (result == 5)
0040c43f          return result;
0040c43f      
0040c40e      sub_4018d0(arg1, 0xfffffffe);
0040c418      sub_402330(arg1, 0, 1);
0040c423      sub_4021d0(arg1, 0x428440);
0040c42b      sub_401b20(arg1, 0xfffffffe);
0040c436      return sub_402500(arg1, 0xffffd8f0);
0040c3e0  }


0040c440    int32_t sub_40c440(void* arg1)

0040c440  {
0040c44a      void* edi = arg1;
0040c450      void* eax = sub_40bf90(edi, &arg1);
0040c458      char eax_1 = sub_40ac10(eax);
0040c460      int32_t eax_2 = sub_40ac00(eax);
0040c460      
0040c471      if (!eax_2 || eax_2 == sub_40c300)
0040c471      {
0040c486          sub_40c3e0(eax);
0040c48d          sub_4021d0(eax, eax);
0040c495          sub_4022b0(eax, 0xfffffffe);
0040c49d          sub_401920(eax, 0xfffffffe);
0040c4a6          sub_401800(eax, edi, 1);
0040c471      }
0040c471      else
0040c47b          sub_401ff0(edi, "external hook", 0xd);
0040c47b      
0040c4bb      void var_8;
0040c4bb      sub_402040(edi, sub_40c4e0(eax_1, &var_8));
0040c4c8      sub_401fd0(edi, sub_40ac20(eax));
0040c4db      return 3;
0040c440  }

0040c4dc                                                                                      90 90 90 90                              ....

0040c4e0    char* sub_40c4e0(char arg1, char* arg2)

0040c4e0  {
0040c4e8      char* ecx = nullptr;
0040c4e8      
0040c4ed      if (arg1 & 1)
0040c4ed      {
0040c4ef          *(uint8_t*)arg2 = 0x63;
0040c4f2          ecx = 1;
0040c4ed      }
0040c4ed      
0040c4fa      if (arg1 & 2)
0040c4fa      {
0040c4fc          *(uint8_t*)(ecx + arg2) = 0x72;
0040c500          ecx = &ecx[1];
0040c4fa      }
0040c4fa      
0040c504      if (!(arg1 & 4))
0040c504      {
0040c510          *(uint8_t*)(ecx + arg2) = 0;
0040c514          return arg2;
0040c504      }
0040c504      
0040c506      *(uint8_t*)(ecx + arg2) = 0x6c;
0040c50a      *(uint8_t*)(ecx + arg2 + 1) = 0;
0040c50f      return arg2;
0040c4e0  }

0040c515                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040c520    int32_t sub_40c520(void* arg1)

0040c520  {
0040c526      int32_t ebx;
0040c526      int32_t var_100 = ebx;
0040c534      sub_418384("lua_debug> ", 0x42cc30);
0040c552      char var_fc[0xfc];
0040c552      
0040c552      if (sub_41832d(&var_fc, 0xfa, &data_42cbf0))
0040c552      {
0040c55f          while (true)
0040c55f          {
0040c55f              char* esi_1 = "cont\n";
0040c564              char (* eax_1)[0xfc] = &var_fc;
0040c568              int32_t eax_3;
0040c568              
0040c568              while (true)
0040c568              {
0040c568                  char edx_1 = *(uint8_t*)eax_1;
0040c56a                  (uint8_t)ebx = *(uint8_t*)esi_1;
0040c56e                  bool c_1 = edx_1 < (uint8_t)ebx;
0040c56e                  
0040c570                  if (edx_1 == (uint8_t)ebx)
0040c570                  {
0040c574                      if (!edx_1)
0040c574                      {
0040c58c                          eax_3 = 0;
0040c58e                          break;
0040c574                      }
0040c574                      
0040c576                      edx_1 = (*(uint2016_t*)eax_1)[1];
0040c579                      (uint8_t)ebx = esi_1[1];
0040c57e                      c_1 = edx_1 < (uint8_t)ebx;
0040c57e                      
0040c580                      if (edx_1 == (uint8_t)ebx)
0040c580                      {
0040c582                          eax_1 = &(*(uint2016_t*)eax_1)[2];
0040c585                          esi_1 = &esi_1[2];
0040c585                          
0040c58a                          if (edx_1)
0040c58a                              continue;
0040c58a                          
0040c58c                          eax_3 = 0;
0040c58e                          break;
0040c580                      }
0040c570                  }
0040c570                  
0040c590                  bool c_2 = /* bool c_2 = unimplemented  {sbb eax, eax} */;
0040c592                  eax_3 = (char*)eax_1 - eax_1 + 1;
0040c592                  break;
0040c568              }
0040c568              
0040c597              if (!eax_3)
0040c597                  break;
0040c597              
0040c59d              char (* edi_1)[0xfc] = &var_fc;
0040c5a1              int32_t i = 0xffffffff;
0040c5a1              
0040c5ab              while (i)
0040c5ab              {
0040c5ab                  bool cond:0_1 = 0 != *(uint8_t*)edi_1;
0040c5ab                  edi_1 = &(*(uint2016_t*)edi_1)[1];
0040c5ab                  i -= 1;
0040c5ab                  
0040c5ab                  if (!cond:0_1)
0040c5ab                      break;
0040c5ab              }
0040c5ab              
0040c5b7              int32_t eax_4 = sub_403b00(arg1, &var_fc, ~i - 1, "=(debug command)");
0040c5c1              int32_t eax_5;
0040c5c1              
0040c5c1              if (!eax_4)
0040c5c7                  eax_5 = sub_402770(arg1, eax_4, eax_4, eax_4);
0040c5c7              
0040c5d1              if (eax_4 || eax_5)
0040c5d1              {
0040c5e6                  sub_418384(sub_401db0(arg1, 0xffffffff, nullptr), 0x42cc30);
0040c5f5                  sub_418384(U"\n", 0x42cc30);
0040c5d1              }
0040c5d1              
0040c600              sub_4018d0(arg1, 0);
0040c60f              sub_418384("lua_debug> ", 0x42cc30);
0040c60f              
0040c62d              if (!sub_41832d(&var_fc, 0xfa, &data_42cbf0))
0040c62d                  break;
0040c55f          }
0040c552      }
0040c552      
0040c63f      return 0;
0040c520  }


0040c640    int32_t sub_40c640(void* arg1)

0040c640  {
0040c64a      void* esi = arg1;
0040c651      int32_t edi = 1;
0040c656      void* eax = sub_40bf90(esi, &arg1);
0040c673      void* ebp;
0040c673      
0040c673      if (!sub_401be0(esi, (char*)arg1 + 2))
0040c673      {
0040c696          void* eax_3;
0040c696          (uint8_t)eax_3 = esi == eax;
0040c699          ebp = eax_3;
0040c673      }
0040c673      else
0040c673      {
0040c686          ebp = sub_401d30(esi, (char*)arg1 + 2);
0040c688          sub_4018d0(esi, 0xfffffffe);
0040c673      }
0040c673      
0040c69c      int32_t eax_4 = sub_4018c0(esi);
0040c6a1      void* ecx_2 = arg1;
0040c6aa      char* var_7c_2;
0040c6aa      int32_t* var_78_3;
0040c6aa      
0040c6aa      if (eax_4 != ecx_2)
0040c6aa      {
0040c6c2          if (sub_401c20(esi, (char*)ecx_2 + 1))
0040c6c2          {
0040c6c8              var_78_3 = 1;
0040c6ca              var_7c_2 = &data_42b22c;
0040c6ca              goto label_40c6d0;
0040c6c2          }
0040c6aa      }
0040c6aa      else
0040c6aa      {
0040c6ac          var_78_3 = nullptr;
0040c6ae          var_7c_2 = &data_4307a0;
0040c6d0      label_40c6d0:
0040c6d0          sub_401ff0(esi, var_7c_2, var_78_3);
0040c6e0          sub_401ff0(esi, "stack traceback:", 0x10);
0040c6ee          void* ebp_1 = (char*)ebp + 1;
0040c6f9          void var_64;
0040c6f9          
0040c6f9          if (sub_40ac30(eax, ebp, &var_64))
0040c6f9          {
0040c838              int32_t i;
0040c838              
0040c838              do
0040c838              {
0040c706                  if (ebp_1 <= 0xc || !edi)
0040c706                  {
0040c76a                      sub_401ff0(esi, "\n\t", 2);
0040c77a                      sub_40ae20(eax, "Snl", &var_64);
0040c783                      void var_40;
0040c783                      void* var_90_1 = &var_40;
0040c78a                      sub_4020b0(esi, 0x42ba88);
0040c798                      int32_t var_50;
0040c798                      
0040c798                      if (var_50 > 0)
0040c798                      {
0040c79a                          int32_t var_78_7 = var_50;
0040c7a1                          sub_4020b0(esi, 0x42ba84);
0040c798                      }
0040c798                      
0040c7b0                      char* var_5c;
0040c7b0                      
0040c7b0                      if (!*(uint8_t*)var_5c)
0040c7b0                      {
0040c7c8                          char* var_58;
0040c7c8                          char* eax_11;
0040c7c8                          (uint8_t)eax_11 = *(uint8_t*)var_58;
0040c7c8                          
0040c7cc                          if ((uint8_t)eax_11 == 0x6d)
0040c7d4                              sub_4020b0(esi, " in main chunk");
0040c7cc                          else if ((uint8_t)eax_11 == 0x43 || (uint8_t)eax_11 == 0x74)
0040c808                              sub_401ff0(esi, " ?", 2);
0040c7e4                          else
0040c7e4                          {
0040c7ee                              int32_t var_48;
0040c7ee                              int32_t var_78_9 = var_48;
0040c7ef                              void* var_7c_7 = &var_40;
0040c7f6                              sub_4020b0(esi, " in function <%s:%d>");
0040c7e4                          }
0040c7b0                      }
0040c7b0                      else
0040c7b0                      {
0040c7b6                          int32_t var_60;
0040c7b6                          int32_t var_78_8 = var_60;
0040c7bd                          sub_4020b0(esi, " in function '%s'");
0040c7b0                      }
0040c7b0                      
0040c81c                      sub_402a80(esi, sub_4018c0(esi) - arg1);
0040c706                  }
0040c706                  else
0040c706                  {
0040c70c                      void* edi_1 = (char*)ebp_1 + 0xa;
0040c70c                      
0040c71c                      if (sub_40ac30(eax, edi_1, &var_64))
0040c71c                      {
0040c72e                          sub_401ff0(esi, "\n\t...", 5);
0040c72e                          
0040c744                          if (sub_40ac30(eax, edi_1, &var_64))
0040c744                          {
0040c759                              int32_t j;
0040c759                              
0040c759                              do
0040c759                              {
0040c746                                  ebp_1 += 1;
0040c74b                                  edi_1 += 1;
0040c74f                                  j = sub_40ac30(eax, edi_1, &var_64);
0040c759                              } while (j);
0040c744                          }
0040c744                          
0040c75b                          edi = 0;
0040c71c                      }
0040c71c                      else
0040c71c                      {
0040c71e                          ebp_1 -= 1;
0040c71f                          edi = 0;
0040c71c                      }
0040c706                  }
0040c706                  
0040c82b                  void* var_7c_9 = ebp_1;
0040c82d                  ebp_1 += 1;
0040c82e                  i = sub_40ac30(eax, var_7c_9, &var_64);
0040c838              } while (i);
0040c6f9          }
0040c6f9          
0040c84a          sub_402a80(esi, sub_4018c0(esi) - arg1);
0040c6aa      }
0040c85e      return 1;
0040c640  }

0040c85f                                                                                               90                                 .

0040c860    int32_t sub_40c860(void* arg1)

0040c860  {
0040c86f      sub_403300(arg1, "debug", &data_428458);
0040c87c      return 1;
0040c860  }

0040c87d                                                                                         90 90 90                               ...

0040c880    int32_t sub_40c880(void* arg1)

0040c880  {
0040c88f      void* var_c;
0040c88f      var_c = (double)fabs0f(sub_403150(arg1, 1));
0040c893      sub_401fa0(arg1, var_c);
0040c8a1      return 1;
0040c880  }

0040c8a2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0040c8b0    int32_t sub_40c8b0(void* arg1)

0040c8b0  {
0040c8bd      long double st0_1;
0040c8bd      bool c2;
0040c8bd      st0_1 = __fsin(sub_403150(arg1, 1));
0040c8bf      void* var_c;
0040c8bf      var_c = (double)st0_1;
0040c8c3      sub_401fa0(arg1, var_c);
0040c8d1      return 1;
0040c8b0  }

0040c8d2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

0040c8e0    int32_t sub_40c8e0(void* arg1)

0040c8e0  {
0040c8e8      int80_t st0 = sub_403150(arg1, 1);
0040c8ed      sub_4183e8();
0040c8f2      void* var_c;
0040c8f2      var_c = (double)st0;
0040c8f6      sub_401fa0(arg1, var_c);
0040c904      return 1;
0040c8e0  }

0040c905                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040c910    int32_t sub_40c910(void* arg1)

0040c910  {
0040c91d      long double st0_1;
0040c91d      bool c2;
0040c91d      st0_1 = __fcos(sub_403150(arg1, 1));
0040c91f      void* var_c;
0040c91f      var_c = (double)st0_1;
0040c923      sub_401fa0(arg1, var_c);
0040c931      return 1;
0040c910  }

0040c932                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

0040c940    int32_t sub_40c940(void* arg1)

0040c940  {
0040c948      int80_t st0 = sub_403150(arg1, 1);
0040c94d      sub_4183f2();
0040c952      void* var_c;
0040c952      var_c = (double)st0;
0040c956      sub_401fa0(arg1, var_c);
0040c964      return 1;
0040c940  }

0040c965                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040c970    int32_t sub_40c970(void* arg1)

0040c970  {
0040c97d      long double st0_1;
0040c97d      bool c2;
0040c97d      st0_1 = __fptan(sub_403150(arg1, 1));
0040c97f      /* unimplemented  {fstp st0, st0} */
0040c97f      /* unimplemented  {fstp st0, st0} */
0040c981      void* var_c;
0040c981      var_c = (double)/* var_c.q = fconvert.d(unimplemented  {fstp qword [esp], st0}) */;
0040c981      /* unimplemented  {fstp qword [esp], st0} */
0040c985      sub_401fa0(arg1, var_c);
0040c993      return 1;
0040c970  }

0040c994                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

0040c9a0    int32_t sub_40c9a0(void* arg1)

0040c9a0  {
0040c9a8      int80_t st0 = sub_403150(arg1, 1);
0040c9ad      sub_4183f9();
0040c9b2      void* var_c;
0040c9b2      var_c = (double)st0;
0040c9b6      sub_401fa0(arg1, var_c);
0040c9c4      return 1;
0040c9a0  }

0040c9c5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040c9d0    int32_t sub_40c9d0(void* arg1)

0040c9d0  {
0040c9e2      void* var_c;
0040c9e2      var_c = (double)sub_418400(sub_403150(arg1, 1));
0040c9e6      sub_401fa0(arg1, var_c);
0040c9f4      return 1;
0040c9d0  }

0040c9f5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040ca00    int32_t sub_40ca00(void* arg1)

0040ca00  {
0040ca12      void* var_c;
0040ca12      var_c = (double)sub_4184d0(sub_403150(arg1, 1));
0040ca16      sub_401fa0(arg1, var_c);
0040ca24      return 1;
0040ca00  }

0040ca25                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040ca30    int32_t sub_40ca30(void* arg1)

0040ca30  {
0040ca41      void* var_c;
0040ca41      var_c = (double)__fpatan((long double)1, sub_403150(arg1, 1));
0040ca45      sub_401fa0(arg1, var_c);
0040ca53      return 1;
0040ca30  }

0040ca54                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

0040ca60    int32_t sub_40ca60(void* arg1)

0040ca60  {
0040ca70      double var_8 = (double)sub_403150(arg1, 1);
0040ca87      void* var_14;
0040ca87      var_14 = (double)__fpatan(sub_403150(arg1, 2), (long double)var_8);
0040ca8b      sub_401fa0(arg1, var_14);
0040ca9c      return 1;
0040ca60  }

0040ca9d                                                                                         90 90 90                               ...

0040caa0    int32_t sub_40caa0(void* arg1)

0040caa0  {
0040caad      void* var_c;
0040caad      var_c = (double)sub_403150(arg1, 1);
0040cab5      var_c = (double)sub_41859b(var_c);
0040cab9      sub_401fa0(arg1, var_c);
0040cac7      return 1;
0040caa0  }

0040cac8                          90 90 90 90 90 90 90 90                                                          ........

0040cad0    int32_t sub_40cad0(void* arg1)

0040cad0  {
0040cadd      void* var_c;
0040cadd      var_c = (double)sub_403150(arg1, 1);
0040cae5      var_c = (double)sub_41803f(var_c);
0040cae9      sub_401fa0(arg1, var_c);
0040caf7      return 1;
0040cad0  }

0040caf8                                                                          90 90 90 90 90 90 90 90                          ........

0040cb00    long double sub_40cb00(void* arg1)

0040cb00  {
0040cb10      double var_8 = (double)sub_403150(arg1, 1);
0040cb17      int80_t st0_1 = sub_403150(arg1, 2);
0040cb22      sub_41867a();
0040cb27      void* var_14;
0040cb27      var_14 = (double)st0_1;
0040cb2f      sub_401fa0(arg1, var_14);
0040cb40      return (long double)var_8;
0040cb00  }

0040cb41     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040cb50    int32_t sub_40cb50(void* arg1)

0040cb50  {
0040cb6a      void* var_2c;
0040cb6a      var_2c = (double)sub_403150(arg1, 1);
0040cb7a      int32_t var_18;
0040cb7a      double var_10 = (double)sub_4186a2(var_2c, &var_18);
0040cb81      int32_t var_14;
0040cb81      sub_401fa0(arg1, var_18, var_14);
0040cb91      sub_401fa0(arg1, (uint32_t)var_10, *(uint32_t*)((char*)var_10)[4]);
0040cba2      return 2;
0040cb50  }

0040cba3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0040cbb0    int32_t sub_40cbb0(void* arg1)

0040cbb0  {
0040cbbf      void* var_c;
0040cbbf      var_c = (double)sqrt0f(sub_403150(arg1, 1));
0040cbc3      sub_401fa0(arg1, var_c);
0040cbd1      return 1;
0040cbb0  }

0040cbd2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

0040cbe0    int32_t sub_40cbe0(void* arg1)

0040cbe0  {
0040cbf0      double var_8 = (double)sub_403150(arg1, 1);
0040cc07      void* var_14;
0040cc07      var_14 = (double)sub_418110(sub_403150(arg1, 2), (long double)var_8);
0040cc0f      sub_401fa0(arg1, var_14);
0040cc20      return 1;
0040cbe0  }

0040cc21     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040cc30    int32_t sub_40cc30(void* arg1)

0040cc30  {
0040cc43      void* var_c;
0040cc43      var_c = (double)__fyl2x(sub_403150(arg1, 1), 
0040cc43          (long double)0,69314718048553914.0 + (long double)7,4406171098029793e-11);
0040cc47      sub_401fa0(arg1, var_c);
0040cc55      return 1;
0040cc30  }

0040cc56                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040cc60    int32_t sub_40cc60(void* arg1)

0040cc60  {
0040cc73      void* var_c;
0040cc73      var_c = (double)__fyl2x(sub_403150(arg1, 1), 
0040cc73          (long double)0,30102999560767785.0 + (long double)5,6303348065105986e-11);
0040cc77      sub_401fa0(arg1, var_c);
0040cc85      return 1;
0040cc60  }

0040cc86                    90 90 90 90 90 90 90 90 90 90                                                        ..........

0040cc90    int32_t sub_40cc90(void* arg1)

0040cc90  {
0040cc9f      long double x87_r7_1 = sub_403150(arg1, 1)
0040cc9f          * ((long double)1,4426950407214463.0 + (long double)1,675171316223821e-10);
0040cca3      long double x87_r6_2 = round(x87_r7_1, 1,675171316223821e-10);
0040ccaf      __fscale(__f2xm1(x87_r7_1 - x87_r6_2) + (long double)1, x87_r6_2);
0040ccb3      void* var_c;
0040ccb3      var_c = (double)x87_r6_2;
0040ccb7      sub_401fa0(arg1, var_c);
0040ccc5      return 1;
0040cc90  }

0040ccc6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

0040ccd0    int32_t sub_40ccd0(void* arg1)

0040ccd0  {
0040cce3      void* var_c;
0040cce3      var_c = (double)(sub_403150(arg1, 1) * (long double)57,295779513082323.0);
0040cce7      sub_401fa0(arg1, var_c);
0040ccf5      return 1;
0040ccd0  }

0040ccf6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040cd00    int32_t sub_40cd00(void* arg1)

0040cd00  {
0040cd13      void* var_c;
0040cd13      var_c = (double)(sub_403150(arg1, 1) * (long double)0,017453292519943295.0);
0040cd17      sub_401fa0(arg1, var_c);
0040cd25      return 1;
0040cd00  }

0040cd26                    90 90 90 90 90 90 90 90 90 90                                                        ..........

0040cd30    int32_t sub_40cd30(int32_t arg1)

0040cd30  {
0040cd35      void* esi = arg1;
0040cd42      void* var_10;
0040cd42      var_10 = (double)sub_403150(esi, 1);
0040cd45      sub_4187c3(var_10, &arg1);
0040cd52      sub_401fa0(esi, 1);
0040cd5d      sub_401fd0(esi, arg1);
0040cd6b      return 2;
0040cd30  }

0040cd6c                                      90 90 90 90                                                              ....

0040cd70    int32_t sub_40cd70(void* arg1)

0040cd70  {
0040cd78      void* eax = sub_4031d0(arg1, 2);
0040cd89      void* var_10;
0040cd89      var_10 = (double)sub_403150(arg1, 1);
0040cd8c      int32_t edi;
0040cd8c      sub_418873(edi, var_10, eax);
0040cd99      sub_401fa0(arg1, 1);
0040cda7      return 1;
0040cd70  }

0040cda8                          90 90 90 90 90 90 90 90                                                          ........

0040cdb0    void sub_40cdb0(void* arg1)

0040cdb0  {
0040cdc0      int32_t eax = sub_4018c0(arg1);
0040cdcf      double var_10 = (double)sub_403150(arg1, 1);
0040cdd3      int32_t esi = 2;
0040cdd3      
0040cddd      if (eax >= 2)
0040cddd      {
0040cdff          do
0040cdff          {
0040cde1              long double st0_1 = sub_403150(arg1, esi);
0040cde6              long double temp0_1 = (long double)var_10;
0040cde6              st0_1 - temp0_1;
0040cde6              
0040cdf2              if (*(uint8_t*)((char*)((st0_1 < temp0_1 ? 1 : 0) << 8
0040cdf2                      | (FCMP_UO(st0_1, temp0_1) ? 1 : 0) << 0xa
0040cdf2                      | (st0_1 == temp0_1 ? 1 : 0) << 0xe | 0x3800))[1] & 1)
0040cdf4                  var_10 = (double)st0_1;
0040cdf4              
0040cdfc              esi += 1;
0040cdff          } while (esi <= eax);
0040cddd      }
0040cddd      
0040ce0c      sub_401fa0(arg1, (uint32_t)var_10, *(uint32_t*)((char*)var_10)[4]);
0040cdb0  }


0040ce20    void sub_40ce20(void* arg1)

0040ce20  {
0040ce30      int32_t eax = sub_4018c0(arg1);
0040ce3f      double var_10 = (double)sub_403150(arg1, 1);
0040ce43      int32_t esi = 2;
0040ce43      
0040ce4d      if (eax >= 2)
0040ce4d      {
0040ce6f          do
0040ce6f          {
0040ce51              long double st0_1 = sub_403150(arg1, esi);
0040ce56              long double temp0_1 = (long double)var_10;
0040ce56              st0_1 - temp0_1;
0040ce56              
0040ce62              if (!(*(uint8_t*)((char*)((st0_1 < temp0_1 ? 1 : 0) << 8
0040ce62                      | (FCMP_UO(st0_1, temp0_1) ? 1 : 0) << 0xa
0040ce62                      | (st0_1 == temp0_1 ? 1 : 0) << 0xe | 0x3800))[1] & 0x41))
0040ce64                  var_10 = (double)st0_1;
0040ce64              
0040ce6c              esi += 1;
0040ce6f          } while (esi <= eax);
0040ce4d      }
0040ce4d      
0040ce7c      sub_401fa0(arg1, (uint32_t)var_10, *(uint32_t*)((char*)var_10)[4]);
0040ce20  }


0040ce90    int32_t sub_40ce90(void* arg1)

0040ce90  {
0040cebb      double var_10 = (double)((long double)((int64_t)sub_418a63() % 0x7fff)
0040cebb          * (long double)3,0518509475997192e-05);
0040cebf      int32_t eax_3 = sub_4018c0(arg1);
0040ceca      void* var_30_1;
0040ceca      char* var_2c_1;
0040ceca      
0040ceca      if (!eax_3)
0040ceca      {
0040cf87          var_2c_1 = *(uint32_t*)((char*)var_10)[4];
0040cf88          var_30_1 = (uint32_t)var_10;
0040ceca      }
0040ceca      else if (eax_3 == 1)
0040ced1      {
0040cf3d          var_2c_1 = 1;
0040cf40          void* eax_9 = sub_4031d0(arg1, 1);
0040cf40          
0040cf4f          if (eax_9 < 1)
0040cf4f          {
0040cf51              var_2c_1 = "interval is empty";
0040cf56              var_30_1 = 1;
0040cf59              sub_402ca0(arg1, 1, "interval is empty");
0040cf4f          }
0040cf4f          
0040cf6c          var_30_1 = (double)((long double)eax_9 * (long double)var_10);
0040cf7a          var_30_1 = (double)(sub_41803f(var_30_1) + (long double)1.0);
0040ced1      }
0040ced1      else
0040ced1      {
0040ced4          if (eax_3 != 2)
0040ced4          {
0040cedc              sub_402e40(arg1, "wrong number of arguments");
0040ceea              return 0;
0040ced4          }
0040ced4          
0040ceeb          var_2c_1 = 1;
0040ceee          void* eax_7 = sub_4031d0(arg1, 1);
0040cefc          void* eax_8 = sub_4031d0(arg1, 2);
0040cefc          
0040cf08          if (eax_7 > eax_8)
0040cf08          {
0040cf0a              var_2c_1 = "interval is empty";
0040cf0f              var_30_1 = 2;
0040cf12              sub_402ca0(arg1, 2, "interval is empty");
0040cf08          }
0040cf08          
0040cf2c          var_30_1 =
0040cf2c              (double)((long double)((char*)eax_8 - eax_7 + 1) * (long double)var_10);
0040cf38          var_30_1 = (double)(sub_41803f(var_30_1) + (long double)eax_7);
0040ced1      }
0040ced1      
0040cf8a      sub_401fa0(arg1, var_30_1, var_2c_1);
0040cf9d      return 1;
0040ce90  }

0040cf9e                                                                                            90 90                                ..

0040cfa0    int32_t sub_40cfa0(void* arg1)

0040cfa0  {
0040cfad      sub_418a59(sub_4031d0(arg1, 1));
0040cfb7      return 0;
0040cfa0  }

0040cfb8                                                                          90 90 90 90 90 90 90 90                          ........

0040cfc0    int32_t sub_40cfc0(void* arg1)

0040cfc0  {
0040cfd0      sub_403300(arg1, "math", 0x4284d0);
0040cfe0      sub_401fa0(arg1, 0x54442d18, 0x400921fb);
0040cfed      sub_402490(arg1, 0xfffffffe, "pi");
0040d000      sub_401fa0(arg1, (*(uint32_t*)data_42d168), *(int32_t*)((char*)data_42d168 + 4));
0040d00d      sub_402490(arg1, 0xfffffffe, "huge");
0040d01a      sub_402250(arg1, 0xffffffff, "fmod");
0040d02a      sub_402490(arg1, 0xfffffffe, "mod");
0040d038      return 1;
0040cfc0  }

0040d039                                                                             90 90 90 90 90 90 90                           .......

0040d040    int32_t sub_40d040(int32_t arg1)

0040d040  {
0040d045      void* esi = arg1;
0040d04d      sub_4030b0(esi, 1, &arg1);
0040d058      sub_401fd0(esi, arg1);
0040d066      return 1;
0040d040  }

0040d067                       90 90 90 90 90 90 90 90 90                                                         .........

0040d070    int32_t sub_40d070(void* arg1)

0040d070  {
0040d077      void* edi = arg1;
0040d07f      int32_t eax = sub_4030b0(edi, 1, &arg1);
0040d0a6      int32_t esi = sub_40d110(sub_4031d0(edi, 2), arg1);
0040d0b7      void* eax_4 = sub_40d110(sub_403210(edi, 3, 0xffffffff), arg1);
0040d0b7      
0040d0c2      if (esi < 1)
0040d0c4          esi = 1;
0040d0c4      
0040d0c9      void* ecx_1 = arg1;
0040d0c9      
0040d0cf      if (eax_4 > ecx_1)
0040d0d1          eax_4 = ecx_1;
0040d0d1      
0040d0d5      if (esi > eax_4)
0040d0d5      {
0040d0fa          sub_401ff0(edi, &data_4307a0, nullptr);
0040d10a          return 1;
0040d0d5      }
0040d0d5      
0040d0e1      sub_401ff0(edi, esi + eax - 1, (char*)eax_4 - esi + 1);
0040d0f1      return 1;
0040d070  }

0040d10b                                   90 90 90 90 90                                                             .....

0040d110    int32_t sub_40d110(int32_t arg1, int32_t arg2) __pure

0040d110  {
0040d116      if (arg1 >= 0)
0040d120          return arg1;
0040d120      
0040d11c      return arg1 + arg2 + 1;
0040d110  }

0040d121     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040d130    int32_t sub_40d130(void* arg1)

0040d130  {
0040d147      char* i_1;
0040d147      int32_t eax = sub_4030b0(arg1, 1, &i_1);
0040d154      char* var_20c;
0040d154      sub_403810(arg1, &var_20c);
0040d159      char* i_2 = i_1;
0040d165      i_1 = i_2 - 1;
0040d165      
0040d169      if (i_2)
0040d169      {
0040d1aa          char* i;
0040d1aa          
0040d1aa          do
0040d1aa          {
0040d178              if (var_20c >= &__return_addr)
0040d17f                  sub_4035f0(&var_20c);
0040d17f              
0040d192              *(uint8_t*)var_20c = i_1[eax];
0040d198              i = i_1;
0040d19d              var_20c = &var_20c[1];
0040d1a6              i_1 = i - 1;
0040d1aa          } while (i);
0040d169      }
0040d169      
0040d1b1      sub_403750(&var_20c);
0040d1c6      return 1;
0040d130  }

0040d1c7                       90 90 90 90 90 90 90 90 90                                                         .........

0040d1d0    int32_t sub_40d1d0(void* arg1)

0040d1d0  {
0040d1e7      int32_t var_210;
0040d1e7      int32_t eax = sub_4030b0(arg1, 1, &var_210);
0040d1f4      char* var_20c;
0040d1f4      sub_403810(arg1, &var_20c);
0040d200      char* esi_1 = nullptr;
0040d200      
0040d204      if (var_210 > 0)
0040d204      {
0040d246          int32_t eax_4;
0040d246          
0040d246          do
0040d246          {
0040d213              if (var_20c >= &__return_addr)
0040d21a                  sub_4035f0(&var_20c);
0040d21a              
0040d224              int32_t ecx_1;
0040d224              (uint8_t)ecx_1 = esi_1[eax];
0040d227              int32_t var_21c_2 = ecx_1;
0040d234              *(uint8_t*)var_20c = sub_418a84(ecx_1);
0040d23a              eax_4 = var_210;
0040d23f              esi_1 = &esi_1[1];
0040d240              var_20c = &var_20c[1];
0040d246          } while (esi_1 < eax_4);
0040d204      }
0040d204      
0040d24d      sub_403750(&var_20c);
0040d262      return 1;
0040d1d0  }

0040d263           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0040d270    int32_t sub_40d270(void* arg1)

0040d270  {
0040d287      int32_t var_210;
0040d287      int32_t eax = sub_4030b0(arg1, 1, &var_210);
0040d294      char* var_20c;
0040d294      sub_403810(arg1, &var_20c);
0040d2a0      char* esi_1 = nullptr;
0040d2a0      
0040d2a4      if (var_210 > 0)
0040d2a4      {
0040d2e6          int32_t eax_4;
0040d2e6          
0040d2e6          do
0040d2e6          {
0040d2b3              if (var_20c >= &__return_addr)
0040d2ba                  sub_4035f0(&var_20c);
0040d2ba              
0040d2c4              int32_t ecx_1;
0040d2c4              (uint8_t)ecx_1 = esi_1[eax];
0040d2c7              int32_t var_21c_2 = ecx_1;
0040d2d4              *(uint8_t*)var_20c = sub_418b4f(ecx_1);
0040d2da              eax_4 = var_210;
0040d2df              esi_1 = &esi_1[1];
0040d2e0              var_20c = &var_20c[1];
0040d2e6          } while (esi_1 < eax_4);
0040d2a4      }
0040d2a4      
0040d2ed      sub_403750(&var_20c);
0040d302      return 1;
0040d270  }

0040d303           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0040d310    int32_t sub_40d310(void* arg1)

0040d310  {
0040d328      int32_t var_210;
0040d328      char* eax = sub_4030b0(arg1, 1, &var_210);
0040d332      void* i_2 = sub_4031d0(arg1, 2);
0040d33f      int32_t var_20c[0x83];
0040d33f      sub_403810(arg1, &var_20c);
0040d33f      
0040d34c      if (i_2 > 0)
0040d34c      {
0040d34e          void* i_1 = i_2;
0040d363          void* i;
0040d363          
0040d363          do
0040d363          {
0040d35a              sub_4036d0(&var_20c, eax, var_210);
0040d362              i = i_1;
0040d362              i_1 -= 1;
0040d363          } while (i != 1);
0040d34c      }
0040d34c      
0040d36a      sub_403750(&var_20c);
0040d380      return 1;
0040d310  }

0040d381     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040d390    void* sub_40d390(void* arg1)

0040d390  {
0040d390      int32_t ecx;
0040d390      int32_t var_4_1 = ecx;
0040d397      void* ebp = arg1;
0040d39f      int32_t eax = sub_4030b0(ebp, 1, &arg1);
0040d3ca      int32_t ebx = sub_40d110(sub_403210(ebp, 2, 1), arg1);
0040d3da      void* eax_4 = sub_40d110(sub_403210(ebp, 3, ebx), arg1);
0040d3da      
0040d3e4      if (ebx <= 0)
0040d3e6          ebx = 1;
0040d3e6      
0040d3eb      void* ecx_2 = arg1;
0040d3eb      
0040d3f1      if (eax_4 > ecx_2)
0040d3f3          eax_4 = ecx_2;
0040d3f3      
0040d3f7      if (ebx > eax_4)
0040d3fe          return 0;
0040d3fe      
0040d40b      if ((char*)eax_4 - ebx + 1 + ebx <= eax_4)
0040d413          sub_402e40(ebp, "string slice too long");
0040d413      
0040d422      sub_402ff0(ebp, (char*)eax_4 - ebx + 1, "string slice too long");
0040d42a      int32_t i = 0;
0040d42a      
0040d42e      if ((char*)eax_4 - ebx + 1 > 0)
0040d42e      {
0040d44a          do
0040d44a          {
0040d43a              int32_t eax_6;
0040d43a              (uint8_t)eax_6 = (ebx + eax - 1)[i];
0040d43f              sub_401fd0(ebp, eax_6);
0040d447              i += 1;
0040d44a          } while (i < (char*)eax_4 - ebx + 1);
0040d42e      }
0040d42e      
0040d453      return (char*)eax_4 - ebx + 1;
0040d390  }

0040d454                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

0040d460    int32_t sub_40d460(void* arg1)

0040d460  {
0040d471      int32_t eax = sub_4018c0(arg1);
0040d47e      char* var_20c;
0040d47e      sub_403810(arg1, &var_20c);
0040d483      int32_t esi = 1;
0040d483      
0040d48d      if (eax >= 1)
0040d48d      {
0040d4e5          do
0040d4e5          {
0040d492              void* eax_1 = sub_4031d0(arg1, esi);
0040d492              
0040d4a6              if ((uint32_t)(uint8_t)eax_1 != eax_1)
0040d4af                  sub_402ca0(arg1, esi, "invalid value");
0040d4af              
0040d4c4              if (var_20c >= &__return_addr)
0040d4cb                  sub_4035f0(&var_20c);
0040d4cb              
0040d4d7              *(uint8_t*)var_20c = (uint8_t)eax_1;
0040d4de              esi += 1;
0040d4e1              var_20c = &var_20c[1];
0040d4e5          } while (esi <= eax);
0040d48d      }
0040d48d      
0040d4ed      sub_403750(&var_20c);
0040d503      return 1;
0040d460  }

0040d504              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040d510    int32_t sub_40d510(void* arg1)

0040d510  {
0040d523      sub_403020(arg1, 1, 6);
0040d52b      sub_4018d0(arg1, 1);
0040d536      void var_20c;
0040d536      sub_403810(arg1, &var_20c);
0040d536      
0040d550      if (sub_4028f0(arg1, sub_40d580, &var_20c))
0040d558          sub_402e40(arg1, "unable to dump given function");
0040d558      
0040d565      sub_403750(&var_20c);
0040d579      return 1;
0040d510  }

0040d57a                                                                                90 90 90 90 90 90                            ......

0040d580    int32_t sub_40d580(char* arg1, int32_t arg2, int32_t* arg3)

0040d580  {
0040d58f      sub_4036d0(arg3, arg1, arg2);
0040d599      return 0;
0040d580  }

0040d59a                                                                                90 90 90 90 90 90                            ......

0040d5a0    int32_t sub_40d5a0(void* arg1)

0040d5a0  {
0040d5af      return sub_40d5b0(arg1, 1);
0040d5a0  }


0040d5b0    int32_t sub_40d5b0(void* arg1, int32_t arg2)

0040d5b0  {
0040d5c9      void* var_120;
0040d5c9      int32_t eax = sub_4030b0(arg1, 1, &var_120);
0040d5d8      int32_t var_118;
0040d5d8      char* eax_1 = sub_4030b0(arg1, 2, &var_118);
0040d5ec      void* var_11c = eax_1;
0040d5f9      int32_t eax_3 = sub_40d110(sub_403210(arg1, 3, 1), var_120);
0040d600      void* eax_4 = var_120;
0040d607      void* esi_1 = eax_3 - 1;
0040d607      
0040d608      if (eax_3 - 1 < 0)
0040d60a          esi_1 = nullptr;
0040d608      else if (esi_1 > eax_4)
0040d612          esi_1 = eax_4;
0040d612      
0040d61d      if (arg2)
0040d61d      {
0040d622          int32_t eax_5 = sub_401d80(arg1, 4);
0040d62c          void* eax_6;
0040d62c          
0040d62c          if (!eax_5)
0040d634              eax_6 = sub_418c20(eax_1, "^$*+?.([%-");
0040d634          
0040d63e          if (eax_5 || !eax_6)
0040d63e          {
0040d650              void* eax_8 =
0040d650                  sub_40e0b0((char*)esi_1 + eax, (char*)var_120 - esi_1, eax_1, var_118);
0040d650              
0040d65a              if (!eax_8)
0040d65a              {
0040d770              label_40d770:
0040d770                  sub_401f80(arg1);
0040d787                  return 1;
0040d65a              }
0040d65a              
0040d662              void* esi_4 = (char*)eax_8 - eax;
0040d669              sub_401fd0(arg1, (char*)esi_4 + 1);
0040d676              sub_401fd0(arg1, (char*)esi_4 + var_118);
0040d68d              return 2;
0040d63e          }
0040d63e          
0040d68e          eax_4 = var_120;
0040d61d      }
0040d61d      
0040d695      int32_t var_114_1;
0040d695      
0040d695      if (*(uint8_t*)eax_1 != 0x5e)
0040d6a6          var_114_1 = 0;
0040d695      else
0040d695      {
0040d698          var_114_1 = 1;
0040d6a0          var_11c = &eax_1[1];
0040d695      }
0040d695      
0040d6b2      void* edi_2 = (char*)esi_1 + eax;
0040d6be      void* var_108_1 = arg1;
0040d6c2      int32_t var_110 = eax;
0040d6ca      int32_t var_104_1 = 0;
0040d6de      char* i;
0040d6de      
0040d6de      for (i = sub_40d790(&var_110, edi_2, var_11c); !i; 
0040d6de          i = sub_40d790(&var_110, edi_2, var_11c))
0040d6de      {
0040d6e4          void* eax_13 = edi_2;
0040d6e6          edi_2 += 1;
0040d6e6          
0040d6e9          if (eax_13 >= (char*)eax_4 + eax)
0040d6e9              goto label_40d770;
0040d6e9          
0040d6f5          if (var_114_1)
0040d6f5              goto label_40d770;
0040d6f5          
0040d702          int32_t var_104_2 = 0;
0040d6de      }
0040d6de      
0040d721      if (!arg2)
0040d76e          return sub_40e120(&var_110, edi_2, i);
0040d76e      
0040d728      sub_401fd0(arg1, (char*)edi_2 - eax + 1);
0040d731      sub_401fd0(arg1, i - eax);
0040d754      return sub_40e120(&var_110, nullptr, 0) + 2;
0040d5b0  }

0040d788                          90 90 90 90 90 90 90 90                                                          ........

0040d790    char* sub_40d790(int32_t* arg1, char* arg2, void* arg3)

0040d790  {
0040d791      int32_t* ebx = arg1;
0040d797      char* esi = arg3;
0040d79c      char* edi = arg2;
0040d7a0      int32_t ecx_1;
0040d7a0      
0040d7a0      while (true)
0040d7a0      {
0040d7a0          int32_t eax_1 = (int32_t)*(uint8_t*)esi;
0040d7a6          int32_t edx;
0040d7a6          
0040d7a6          if (eax_1 > 0x29)
0040d7a6          {
0040d8c6          label_40d8c6:
0040d8c6              void* eax_13;
0040d8c6              eax_13 = sub_40da50(ebx, esi);
0040d8d5              BOOL eax_16;
0040d8d5              
0040d8d5              if (edi < ebx[1])
0040d8d5              {
0040d8da                  BOOL eax_15;
0040d8da                  (uint8_t)eax_15 = *(uint8_t*)edi;
0040d8de                  eax_16 = sub_40ddf0(eax_15, esi, eax_13);
0040d8d5              }
0040d8d5              
0040d8e8              int32_t ecx_5;
0040d8e8              
0040d8e8              if (edi >= ebx[1] || !eax_16)
0040d8f1                  ecx_5 = 0;
0040d8e8              else
0040d8ea                  ecx_5 = 1;
0040d8ea              
0040d8f7              int32_t eax_18 = (int32_t)*(uint8_t*)eax_13 - 0x2a;
0040d8f7              
0040d8fd              if (eax_18 > 0x15)
0040d8fd              {
0040d933              label_40d933:
0040d933                  
0040d935                  if (ecx_5)
0040d935                  {
0040d93b                      edi = &edi[1];
0040d93c                      esi = eax_13;
0040d93e                      continue;
0040d935                  }
0040d8fd              }
0040d8fd              else
0040d8fd              {
0040d901                  (uint8_t)edx = lookup_table_40da38[eax_18];
0040d901                  
0040d907                  switch (edx)
0040d907                  {
0040d9af                      case 0:
0040d9af                      {
0040d9af                          return sub_40dec0(ebx, edi, esi, eax_13);
0040d9af                          break;
0040d9af                      }
0040d9b2                      case 1:
0040d9b2                      {
0040d9b2                          if (ecx_5)
0040d9c5                              return sub_40dec0(ebx, &edi[1], esi, eax_13);
0040d9b2                          break;
0040d9b2                      }
0040d9d6                      case 2:
0040d9d6                      {
0040d9d6                          return sub_40df20(ebx, edi, esi, eax_13);
0040d9d6                          break;
0040d9d6                      }
0040d910                      case 3:
0040d910                      {
0040d910                          if (ecx_5)
0040d910                          {
0040d91b                              int32_t eax_20;
0040d91b                              eax_20 = sub_40d790(ebx, &edi[1], (char*)eax_13 + 1);
0040d91b                              
0040d925                              if (eax_20)
0040d9dd                                  return eax_20;
0040d910                          }
0040d910                          
0040d92b                          esi = (char*)eax_13 + 1;
0040d92e                          continue;
0040d910                      }
0040d907                      case 4:
0040d907                      {
0040d907                          goto label_40d933;
0040d907                      }
0040d907                  }
0040d8fd              }
0040d8fd              
0040d9d7              return 0;
0040d7a6          }
0040d7a6          
0040d7ae          (uint8_t)ecx_1 = lookup_table_40d9f8[eax_1];
0040d7ae          
0040d7b4          switch (ecx_1)
0040d7b4          {
0040d98c              case 0:
0040d98c              {
0040d98c                  return edi;
0040d98c                  break;
0040d98c              }
0040d8b9              case 1:
0040d8b9              {
0040d8b9                  (uint8_t)eax_1 = esi[1];
0040d8b9                  
0040d8be                  if ((uint8_t)eax_1)
0040d8be                      goto label_40d8c6;
0040d8be                  
0040d994                  int32_t eax_26;
0040d994                  (uint8_t)eax_26 = edi != ebx[1];
0040d99e                  return (eax_26 - 1) & edi;
0040d8b9                  break;
0040d8b9              }
0040d7bb              case 2:
0040d7bb              {
0040d7bb                  (uint8_t)eax_1 = esi[1];
0040d7bb                  
0040d7c0                  if ((uint8_t)eax_1 == 0x62)
0040d7c0                  {
0040d89f                      void* eax_12;
0040d89f                      eax_12 = sub_40de50(ebx, edi, &esi[2]);
0040d8a4                      edi = eax_12;
0040d8a4                      
0040d8ab                      if (!edi)
0040d9d7                          return 0;
0040d9d7                      
0040d8b1                      esi = &esi[4];
0040d8b4                      continue;
0040d7c0                  }
0040d7c0                  
0040d7c8                  if ((uint8_t)eax_1 != 0x66)
0040d7c8                  {
0040d7d1                      BOOL eax_3;
0040d7d1                      
0040d7d1                      if (data_42d07c <= 1)
0040d7d1                      {
0040d7f0                          int32_t eax_4;
0040d7f0                          (uint8_t)eax_4 = (**(uint528_t**)&data_42ce70)[eax_1 & 0xff];
0040d7f3                          eax_3 = eax_4 & 4;
0040d7d1                      }
0040d7d1                      else
0040d7d1                      {
0040d7d3                          int32_t eax_2 = eax_1 & 0xff;
0040d7d8                          int32_t var_14_1 = 4;
0040d7db                          eax_3 = sub_4179df(eax_2, edx, ecx_1, eax_2);
0040d7d1                      }
0040d7d1                      
0040d7f8                      if (!eax_3)
0040d7f8                          goto label_40d8c6;
0040d7f8                      
0040d800                      int32_t eax_5;
0040d800                      (uint8_t)eax_5 = esi[1];
0040d806                      void* eax_6;
0040d806                      eax_6 = sub_40e040(ebx, edi, eax_5);
0040d80b                      edi = eax_6;
0040d80b                      
0040d812                      if (edi)
0040d812                      {
0040d818                          esi = &esi[2];
0040d81b                          continue;
0040d812                      }
0040d812                      
0040d9d7                      return 0;
0040d7c8                  }
0040d7c8                  
0040d81d                  (uint8_t)eax_1 = esi[2];
0040d81d                  
0040d825                  if ((uint8_t)eax_1 != 0x5b)
0040d830                      sub_402e40(ebx[2], "missing '[' after '%%f' in pattern");
0040d830                  
0040d83a                  void* eax_7 = sub_40da50(ebx, &esi[2]);
0040d83a                  
0040d84a                  if (edi != *(uint32_t*)ebx)
0040d856                      (uint8_t)arg1 = edi[0xffffffff];
0040d84a                  else
0040d84c                      (uint8_t)arg1 = 0;
0040d84c                  
0040d873                  if (!sub_40dac0((uint32_t)(uint8_t)arg1, &esi[2], (char*)eax_7 - 1))
0040d873                  {
0040d87c                      BOOL ecx_4;
0040d87c                      (uint8_t)ecx_4 = *(uint8_t*)edi;
0040d880                      int32_t eax_11;
0040d880                      eax_11 = sub_40dac0(ecx_4, &esi[2], (char*)eax_7 - 1);
0040d880                      
0040d88a                      if (eax_11)
0040d88a                      {
0040d890                          esi = eax_7;
0040d894                          continue;
0040d88a                      }
0040d873                  }
0040d873                  
0040d9d7                  return 0;
0040d7bb                  break;
0040d7bb              }
0040d7b4              case 3:
0040d7b4              {
0040d7b4                  break;
0040d7b4                  break;
0040d7b4              }
0040d985              case 4:
0040d985              {
0040d985                  return sub_40dfd0(ebx, edi, &esi[1]);
0040d985                  break;
0040d985              }
0040d7b4              case 5:
0040d7b4              {
0040d7b4                  goto label_40d8c6;
0040d7b4              }
0040d7b4          }
0040d7a0      }
0040d7a0      
0040d943      (uint8_t)ecx_1 = esi[1];
0040d943      
0040d94c      if ((uint8_t)ecx_1 != 0x29)
0040d974          return sub_40df80(ebx, edi, &esi[1], 0xffffffff);
0040d974      
0040d962      return sub_40df80(ebx, edi, &esi[2], 0xfffffffe);
0040d790  }

0040d9de                                                                                            8b ff                                ..
0040d9e0  uint32_t jump_table_40d9e0[0x6] = 
0040d9e0  {
0040d9e0      [0x0] =  0x0040d986
0040d9e4      [0x1] =  0x0040d8b9
0040d9e8      [0x2] =  0x0040d7bb
0040d9ec      [0x3] =  0x0040d943
0040d9f0      [0x4] =  0x0040d975
0040d9f4      [0x5] =  0x0040d8c4
0040d9f8  }
0040d9f8  uint8_t lookup_table_40d9f8[0x2a] = 
0040d9f8  {
0040d9f8      [0x00] =  0x00
0040d9f9      [0x01] =  0x05
0040d9fa      [0x02] =  0x05
0040d9fb      [0x03] =  0x05
0040d9fc      [0x04] =  0x05
0040d9fd      [0x05] =  0x05
0040d9fe      [0x06] =  0x05
0040d9ff      [0x07] =  0x05
0040da00      [0x08] =  0x05
0040da01      [0x09] =  0x05
0040da02      [0x0a] =  0x05
0040da03      [0x0b] =  0x05
0040da04      [0x0c] =  0x05
0040da05      [0x0d] =  0x05
0040da06      [0x0e] =  0x05
0040da07      [0x0f] =  0x05
0040da08      [0x10] =  0x05
0040da09      [0x11] =  0x05
0040da0a      [0x12] =  0x05
0040da0b      [0x13] =  0x05
0040da0c      [0x14] =  0x05
0040da0d      [0x15] =  0x05
0040da0e      [0x16] =  0x05
0040da0f      [0x17] =  0x05
0040da10      [0x18] =  0x05
0040da11      [0x19] =  0x05
0040da12      [0x1a] =  0x05
0040da13      [0x1b] =  0x05
0040da14      [0x1c] =  0x05
0040da15      [0x1d] =  0x05
0040da16      [0x1e] =  0x05
0040da17      [0x1f] =  0x05
0040da18      [0x20] =  0x05
0040da19      [0x21] =  0x05
0040da1a      [0x22] =  0x05
0040da1b      [0x23] =  0x05
0040da1c      [0x24] =  0x01
0040da1d      [0x25] =  0x02
0040da1e      [0x26] =  0x05
0040da1f      [0x27] =  0x05
0040da20      [0x28] =  0x03
0040da21      [0x29] =  0x04
0040da22  }

0040da22        8b ff                                                                                        ..
0040da24  uint32_t jump_table_40da24[0x5] = 
0040da24  {
0040da24      [0x0] =  0x0040d99f
0040da28      [0x1] =  0x0040d9b0
0040da2c      [0x2] =  0x0040d9c6
0040da30      [0x3] =  0x0040d90e
0040da34      [0x4] =  0x0040d933
0040da38  }
0040da38  uint8_t lookup_table_40da38[0x16] = 
0040da38  {
0040da38      [0x00] =  0x00
0040da39      [0x01] =  0x01
0040da3a      [0x02] =  0x04
0040da3b      [0x03] =  0x02
0040da3c      [0x04] =  0x04
0040da3d      [0x05] =  0x04
0040da3e      [0x06] =  0x04
0040da3f      [0x07] =  0x04
0040da40      [0x08] =  0x04
0040da41      [0x09] =  0x04
0040da42      [0x0a] =  0x04
0040da43      [0x0b] =  0x04
0040da44      [0x0c] =  0x04
0040da45      [0x0d] =  0x04
0040da46      [0x0e] =  0x04
0040da47      [0x0f] =  0x04
0040da48      [0x10] =  0x04
0040da49      [0x11] =  0x04
0040da4a      [0x12] =  0x04
0040da4b      [0x13] =  0x04
0040da4c      [0x14] =  0x04
0040da4d      [0x15] =  0x03
0040da4e  }

0040da4e                                            90 90                                                                ..

0040da50    void* sub_40da50(void* arg1, char* arg2)

0040da50  {
0040da55      int32_t eax = (int32_t)*(uint8_t*)arg2;
0040da58      void* result = &arg2[1];
0040da58      
0040da5c      if (eax == 0x25)
0040da5c      {
0040daa4          if (!*(uint8_t*)result)
0040dab3              sub_402e40(*(uint32_t*)((char*)arg1 + 8), 
0040dab3                  "malformed pattern (ends with '%%')");
0040dab3          
0040dabf          return (char*)result + 1;
0040da5c      }
0040da5c      
0040da61      if (eax != 0x5b)
0040da66          return result;
0040da66      
0040da6a      if (*(uint8_t*)result == 0x5e)
0040da6c          result += 1;
0040da6c      
0040da99      do
0040da99      {
0040da75          if (!*(uint8_t*)result)
0040da80              sub_402e40(*(uint32_t*)((char*)arg1 + 8), "malformed pattern (missing ']')");
0040da80          
0040da88          char ecx = *(uint8_t*)result;
0040da8a          result += 1;
0040da8a          
0040da93          if (ecx == 0x25 && *(uint8_t*)result)
0040da95              result += 1;
0040da99      } while (*(uint8_t*)result != 0x5d);
0040da99      
0040daa0      return (char*)result + 1;
0040da50  }


0040dac0    int32_t sub_40dac0(BOOL arg1, void* arg2, int32_t arg3)

0040dac0  {
0040dac0      int32_t ecx;
0040dac0      int32_t var_4_1 = ecx;
0040dac4      void* esi = arg2;
0040dac9      int32_t var_4 = 1;
0040dac9      
0040dad5      if (*(uint8_t*)((char*)esi + 1) == 0x5e)
0040dad5      {
0040dad7          var_4 = 0;
0040dadf          esi += 1;
0040dad5      }
0040dad5      
0040dae4      void* esi_1 = (char*)esi + 1;
0040dae4      
0040dae7      if (esi_1 < arg3)
0040dae7      {
0040daed          void* ebp_1 = (char*)esi_1 + 2;
0040daed          
0040db3c          do
0040db3c          {
0040daf0              BOOL eax;
0040daf0              (uint8_t)eax = *(uint8_t*)esi_1;
0040daf0              
0040daf4              if ((uint8_t)eax == 0x25)
0040daf4              {
0040daf6                  esi_1 += 1;
0040daf9                  ebp_1 += 1;
0040dafa                  int32_t eax_1;
0040dafa                  (uint8_t)eax_1 = *(uint8_t*)esi_1;
0040dafa                  
0040db08                  if (sub_40db60(arg1, eax_1))
0040db58                      return var_4;
0040daf4              }
0040daf4              else if (*(uint8_t*)((char*)esi_1 + 1) == 0x2d && ebp_1 < arg3)
0040db14              {
0040db16                  esi_1 += 2;
0040db1b                  ebp_1 += 2;
0040db1e                  int32_t ecx_1;
0040db1e                  (uint8_t)ecx_1 = *(uint8_t*)((char*)esi_1 - 2);
0040db1e                  
0040db23                  if (ecx_1 <= arg1)
0040db23                  {
0040db27                      int32_t edx_1;
0040db27                      (uint8_t)edx_1 = *(uint8_t*)esi_1;
0040db27                      
0040db2b                      if (arg1 <= edx_1)
0040db58                          return var_4;
0040db23                  }
0040db14              }
0040db14              else if ((eax & 0xff) == arg1)
0040db58                  return var_4;
0040db58              
0040db38              esi_1 += 1;
0040db39              ebp_1 += 1;
0040db3c          } while (esi_1 < arg3);
0040dae7      }
0040dae7      
0040db4a      int32_t eax_2;
0040db4a      (uint8_t)eax_2 = !var_4;
0040db4e      return eax_2;
0040dac0  }

0040db59                                                                             90 90 90 90 90 90 90                           .......

0040db60    BOOL sub_40db60(BOOL arg1, int32_t arg2)

0040db60  {
0040db67      int32_t var_10 = arg2;
0040db68      uint32_t eax;
0040db68      int32_t ecx;
0040db68      BOOL edx;
0040db68      eax = sub_418a84(ecx);
0040db68      
0040db76      if (eax - 0x61 <= 0x19)
0040db76      {
0040db83          int32_t ecx_1;
0040db83          (uint8_t)ecx_1 = *(uint8_t*)(eax + 0x40dd73);
0040db89          int32_t eax_1;
0040db89          BOOL eax_2;
0040db89          BOOL ecx_2;
0040db89          int32_t esi;
0040db89          BOOL esi_1;
0040db89          
0040db89          switch (ecx_1)
0040db89          {
0040db96              case 0:
0040db96              {
0040db96                  if (data_42d07c > 1)
0040db96                  {
0040db9c                      int32_t var_10_1 = 0x103;
0040dba2                      eax_2 = sub_4179df(eax - 0x61, arg1, ecx_1, arg1);
0040dbaa                      goto label_40dd5f;
0040db96                  }
0040db96                  
0040dbaf                  eax_2 = arg1;
0040dbb3                  ecx_2 = data_42ce70;
0040dbb9                  (uint16_t)esi = *(uint16_t*)(ecx_2 + (eax_2 << 1));
0040dbbd                  esi_1 = esi & 0x103;
0040dd67              label_40dd67:
0040dd67                  BOOL eax_5;
0040dd67                  
0040dd67                  if (data_42d07c <= 1)
0040dd67                  {
0040dd7c                      (uint8_t)eax_2 = (**(uint528_t**)&data_42ce70)[arg2];
0040dd7f                      eax_5 = eax_2 & 2;
0040dd67                  }
0040dd67                  else
0040dd67                  {
0040dd69                      int32_t var_10_10 = 2;
0040dd6c                      eax_5 = sub_4179df(eax_2, edx, ecx_2, arg2);
0040dd67                  }
0040dd67                  
0040dd84                  if (eax_5)
0040dd8b                      return esi_1;
0040dd8b                  
0040dd93                  int32_t eax_7;
0040dd93                  (uint8_t)eax_7 = !esi_1;
0040dd96                  return eax_7;
0040db96                  break;
0040db96              }
0040dbce              case 1:
0040dbce              {
0040dbce                  if (data_42d07c > 1)
0040dbce                  {
0040dbd4                      int32_t var_10_2 = 0x20;
0040dbd7                      eax_2 = sub_4179df(eax - 0x61, arg1, ecx_1, arg1);
0040dbdf                      goto label_40dd5f;
0040dbce                  }
0040dbce                  
0040dbe4                  eax_2 = arg1;
0040dbe8                  ecx_2 = data_42ce70;
0040dbee                  (uint8_t)edx = *(uint8_t*)(ecx_2 + (eax_2 << 1));
0040dbf1                  edx &= 0x20;
0040dbf4                  esi_1 = edx;
0040dbf6                  goto label_40dd67;
0040dbce              }
0040dc01              case 2:
0040dc01              {
0040dc01                  if (data_42d07c <= 1)
0040dc01                  {
0040dc17                      ecx_2 = arg1;
0040dc1b                      edx = data_42ce70;
0040dc21                      (uint8_t)eax_1 = *(uint8_t*)(edx + (ecx_2 << 1));
0040dc24                      eax_2 = eax_1 & 4;
0040dc01                  }
0040dc01                  else
0040dc01                  {
0040dc07                      int32_t var_10_3 = 4;
0040dc0a                      eax_2 = sub_4179df(arg1, edx, ecx_1, arg1);
0040dc01                  }
0040dc01                  
0040dc01                  goto label_40dd5f;
0040dc01              }
0040dc32              case 3:
0040dc32              {
0040dc32                  if (data_42d07c > 1)
0040dc32                  {
0040dc38                      int32_t var_10_4 = 2;
0040dc3b                      eax_2 = sub_4179df(eax - 0x61, edx, arg1, arg1);
0040dc43                      goto label_40dd5f;
0040dc32                  }
0040dc32                  
0040dc48                  edx = arg1;
0040dc4c                  eax_2 = data_42ce70;
0040dc51                  (uint8_t)ecx_1 = *(uint8_t*)(eax_2 + (edx << 1));
0040dc54                  ecx_2 = ecx_1 & 2;
0040dc57                  esi_1 = ecx_2;
0040dc59                  goto label_40dd67;
0040dc32              }
0040dc64              case 4:
0040dc64              {
0040dc64                  if (data_42d07c > 1)
0040dc64                  {
0040dc6a                      int32_t var_10_5 = 0x10;
0040dc6d                      eax_2 = sub_4179df(eax - 0x61, arg1, ecx_1, arg1);
0040dc75                      goto label_40dd5f;
0040dc64                  }
0040dc64                  
0040dc7a                  eax_2 = arg1;
0040dc7e                  ecx_2 = data_42ce70;
0040dc84                  (uint8_t)edx = *(uint8_t*)(ecx_2 + (eax_2 << 1));
0040dc87                  edx &= 0x10;
0040dc8a                  esi_1 = edx;
0040dc8c                  goto label_40dd67;
0040dc64              }
0040dc97              case 5:
0040dc97              {
0040dc97                  if (data_42d07c <= 1)
0040dc97                  {
0040dcad                      ecx_2 = arg1;
0040dcb1                      edx = data_42ce70;
0040dcb7                      (uint8_t)eax_1 = *(uint8_t*)(edx + (ecx_2 << 1));
0040dcba                      eax_2 = eax_1 & 8;
0040dc97                  }
0040dc97                  else
0040dc97                  {
0040dc9d                      int32_t var_10_6 = 8;
0040dca0                      eax_2 = sub_4179df(arg1, edx, ecx_1, arg1);
0040dc97                  }
0040dc97                  
0040dc97                  goto label_40dd5f;
0040dc97              }
0040dcc8              case 6:
0040dcc8              {
0040dcc8                  if (data_42d07c > 1)
0040dcc8                  {
0040dcce                      int32_t var_10_7 = 1;
0040dcd0                      eax_2 = sub_4179df(eax - 0x61, edx, arg1, arg1);
0040dcd8                      goto label_40dd5f;
0040dcc8                  }
0040dcc8                  
0040dcdd                  edx = arg1;
0040dce1                  eax_2 = data_42ce70;
0040dce6                  (uint8_t)ecx_1 = *(uint8_t*)(eax_2 + (edx << 1));
0040dce9                  ecx_2 = ecx_1 & 1;
0040dceb                  esi_1 = ecx_2;
0040dced                  goto label_40dd67;
0040dcc8              }
0040dcf5              case 7:
0040dcf5              {
0040dcf5                  if (data_42d07c > 1)
0040dcf5                  {
0040dcfb                      int32_t var_10_8 = 0x107;
0040dd01                      eax_2 = sub_4179df(eax - 0x61, arg1, ecx_1, arg1);
0040dd09                      goto label_40dd5f;
0040dcf5                  }
0040dcf5                  
0040dd0b                  eax_2 = arg1;
0040dd0f                  ecx_2 = data_42ce70;
0040dd15                  (uint16_t)esi = *(uint16_t*)(ecx_2 + (eax_2 << 1));
0040dd19                  esi_1 = esi & 0x107;
0040dd1f                  goto label_40dd67;
0040dcf5              }
0040dd27              case 8:
0040dd27              {
0040dd27                  if (data_42d07c > 1)
0040dd27                  {
0040dd2d                      int32_t var_10_9 = 0x80;
0040dd33                      eax_2 = sub_4179df(eax - 0x61, arg1, ecx_1, arg1);
0040dd3b                      goto label_40dd5f;
0040dd27                  }
0040dd27                  
0040dd3d                  eax_2 = arg1;
0040dd41                  ecx_2 = data_42ce70;
0040dd47                  (uint8_t)edx = *(uint8_t*)(ecx_2 + (eax_2 << 1));
0040dd4a                  edx &= 0x80;
0040dd50                  esi_1 = edx;
0040dd52                  goto label_40dd67;
0040dd27              }
0040dd54              case 9:
0040dd54              {
0040dd54                  ecx_2 = arg1;
0040dd5c                  (uint8_t)eax_2 = !ecx_2;
0040dd5f              label_40dd5f:
0040dd5f                  esi_1 = eax_2;
0040dd5f                  goto label_40dd67;
0040dd54              }
0040db89          }
0040db76      }
0040db76      
0040dda2      int32_t eax_8;
0040dda2      (uint8_t)eax_8 = arg2 == arg1;
0040dda5      return eax_8;
0040db60  }

0040dda6                    8b ff                                                                                ..
0040dda8  uint32_t jump_table_40dda8[0xb] = 
0040dda8  {
0040dda8      [0x0] =  0x0040db90
0040ddac      [0x1] =  0x0040dbc8
0040ddb0      [0x2] =  0x0040dbfb
0040ddb4      [0x3] =  0x0040dc2c
0040ddb8      [0x4] =  0x0040dc5e
0040ddbc      [0x5] =  0x0040dc91
0040ddc0      [0x6] =  0x0040dcc2
0040ddc4      [0x7] =  0x0040dcef
0040ddc8      [0x8] =  0x0040dd21
0040ddcc      [0x9] =  0x0040dd54
0040ddd0      [0xa] =  0x0040dd97
0040ddd4  }
0040ddd4  uint8_t lookup_table_40ddd4[0x1a] = 
0040ddd4  {
0040ddd4      [0x00] =  0x00
0040ddd5      [0x01] =  0x0a
0040ddd6      [0x02] =  0x01
0040ddd7      [0x03] =  0x02
0040ddd8      [0x04] =  0x0a
0040ddd9      [0x05] =  0x0a
0040ddda      [0x06] =  0x0a
0040dddb      [0x07] =  0x0a
0040dddc      [0x08] =  0x0a
0040dddd      [0x09] =  0x0a
0040ddde      [0x0a] =  0x0a
0040dddf      [0x0b] =  0x03
0040dde0      [0x0c] =  0x0a
0040dde1      [0x0d] =  0x0a
0040dde2      [0x0e] =  0x0a
0040dde3      [0x0f] =  0x04
0040dde4      [0x10] =  0x0a
0040dde5      [0x11] =  0x0a
0040dde6      [0x12] =  0x05
0040dde7      [0x13] =  0x0a
0040dde8      [0x14] =  0x06
0040dde9      [0x15] =  0x0a
0040ddea      [0x16] =  0x07
0040ddeb      [0x17] =  0x08
0040ddec      [0x18] =  0x0a
0040dded      [0x19] =  0x09
0040ddee  }

0040ddee                                            90 90                                                                ..

0040ddf0    BOOL sub_40ddf0(BOOL arg1, char* arg2, int32_t arg3)

0040ddf0  {
0040ddf4      char eax = *(uint8_t*)arg2;
0040ddf4      
0040ddf8      if (eax == 0x25)
0040ddf8      {
0040de36          int32_t edx_3;
0040de36          (uint8_t)edx_3 = arg2[1];
0040de43          return sub_40db60(arg1, edx_3);
0040ddf8      }
0040ddf8      
0040ddfc      if (eax == 0x2e)
0040de2f          return 1;
0040de2f      
0040de00      if (eax == 0x5b)
0040de29          return sub_40dac0(arg1, arg2, arg3 - 1);
0040de29      
0040de0f      int32_t result;
0040de0f      (uint8_t)result = (uint32_t)eax == arg1;
0040de14      return result;
0040ddf0  }

0040de44              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040de50    void* sub_40de50(void* arg1, char* arg2, char* arg3)

0040de50  {
0040de66      if (!*(uint8_t*)arg3 || !arg3[1])
0040de71          sub_402e40(*(uint32_t*)((char*)arg1 + 8), "unbalanced pattern");
0040de71      
0040de7d      char ecx = *(uint8_t*)arg3;
0040de7d      
0040de81      if (*(uint8_t*)arg2 == ecx)
0040de81      {
0040de86          void* i = &arg2[1];
0040de8d          int32_t ebx_1 = 1;
0040de8d          
0040de95          for (; i < *(uint32_t*)((char*)arg1 + 4); i += 1)
0040de95          {
0040de97              int32_t ecx_1 = (int32_t)*(uint8_t*)i;
0040de97              
0040de9c              if (ecx_1 == (int32_t)arg3[1])
0040de9c              {
0040de9e                  int32_t temp0_1 = ebx_1;
0040de9e                  ebx_1 -= 1;
0040de9e                  
0040de9f                  if (temp0_1 == 1)
0040deb9                      return (char*)i + 1;
0040de9c              }
0040de9c              else if (ecx_1 == (int32_t)ecx)
0040dea7                  ebx_1 += 1;
0040de95          }
0040de81      }
0040de81      
0040deb3      return 0;
0040de50  }

0040deba                                                                                90 90 90 90 90 90                            ......

0040dec0    char* sub_40dec0(int32_t* arg1, char* arg2, char* arg3, void* arg4)

0040dec0  {
0040decb      char* i = arg2;
0040ded3      int32_t i_1 = 0;
0040ded3      
0040ded7      if (i >= arg1[1])
0040ded7          goto label_40df02;
0040ded7      
0040def7      do
0040def7      {
0040dedf          BOOL ecx_1;
0040dedf          (uint8_t)ecx_1 = *(uint8_t*)i;
0040dedf          
0040deee          if (!sub_40ddf0(ecx_1, arg3, arg4))
0040deee              break;
0040deee          
0040def3          i_1 += 1;
0040def4          i = &i[1];
0040def7      } while (i < arg1[1]);
0040def7      
0040defb      if (i_1 >= 0)
0040defb      {
0040defd          i = arg2;
0040df02      label_40df02:
0040df02          void* esi = &i[i_1];
0040df02          
0040df17          do
0040df17          {
0040df07              char* result = sub_40d790(arg1, esi, (char*)arg4 + 1);
0040df07              
0040df11              if (result)
0040df1f                  return result;
0040df1f              
0040df13              i_1 -= 1;
0040df14              esi -= 1;
0040df17          } while (i_1 >= 0);
0040defb      }
0040defb      
0040df19      return nullptr;
0040dec0  }


0040df20    char* sub_40df20(int32_t* arg1, char* arg2, char* arg3, void* arg4)

0040df20  {
0040df2b      char* esi = arg2;
0040df36      char* eax = sub_40d790(arg1, esi, (char*)arg4 + 1);
0040df36      
0040df40      if (eax)
0040df79          return eax;
0040df79      
0040df45      char* eax_3;
0040df45      
0040df45      while (true)
0040df45      {
0040df45          if (esi < arg1[1])
0040df45          {
0040df4d              BOOL ecx_1;
0040df4d              (uint8_t)ecx_1 = *(uint8_t*)esi;
0040df4d              
0040df5c              if (sub_40ddf0(ecx_1, arg3, arg4))
0040df5c              {
0040df5e                  esi = &esi[1];
0040df62                  eax_3 = sub_40d790(arg1, esi, (char*)arg4 + 1);
0040df62                  
0040df6c                  if (eax_3)
0040df6c                      break;
0040df6c                  
0040df6c                  continue;
0040df5c              }
0040df45          }
0040df45          
0040df73          return nullptr;
0040df45      }
0040df45      
0040df72      return eax_3;
0040df20  }

0040df7a                                                                                90 90 90 90 90 90                            ......

0040df80    char* sub_40df80(int32_t* arg1, char* arg2, void* arg3, int32_t arg4)

0040df80  {
0040df86      int32_t edi = arg1[3];
0040df86      
0040df8c      if (edi >= 0x20)
0040df97          sub_402e40(arg1[2], "too many captures");
0040df97      
0040dfab      arg1[edi * 2 + 4] = arg2;
0040dfaf      arg1[edi * 2 + 5] = arg4;
0040dfb7      arg1[3] = edi + 1;
0040dfba      char* result = sub_40d790(arg1, arg2, arg3);
0040dfba      
0040dfc4      if (!result)
0040dfc6          arg1[3] -= 1;
0040dfc6      
0040dfcb      return result;
0040df80  }

0040dfcc                                      90 90 90 90                                                              ....

0040dfd0    char* sub_40dfd0(int32_t* arg1, char* arg2, void* arg3)

0040dfd0  {
0040dfd7      int32_t eax = sub_40e010(arg1);
0040dff1      arg1[eax * 2 + 5] = arg2 - arg1[eax * 2 + 4];
0040dff5      char* result = sub_40d790(arg1, arg2, arg3);
0040dff5      
0040dfff      if (!result)
0040e001          arg1[eax * 2 + 5] = 0xffffffff;
0040e001      
0040e00b      return result;
0040dfd0  }

0040e00c                                      90 90 90 90                                                              ....

0040e010    int32_t sub_40e010(void* arg1)

0040e010  {
0040e014      int32_t eax = *(uint32_t*)((char*)arg1 + 0xc);
0040e017      int32_t i = eax - 1;
0040e017      
0040e018      if (eax - 1 >= 0)
0040e018      {
0040e01a          void* ecx_1 = (char*)arg1 + (i << 3) + 0x14;
0040e01a          
0040e029          do
0040e029          {
0040e021              if (*(uint32_t*)ecx_1 == 0xffffffff)
0040e03c                  return i;
0040e03c              
0040e023              i -= 1;
0040e024              ecx_1 -= 8;
0040e029          } while (i >= 0);
0040e018      }
0040e018      
0040e034      return sub_402e40(*(uint32_t*)((char*)arg1 + 8), "invalid pattern capture");
0040e010  }

0040e03d                                                                                         90 90 90                               ...

0040e040    void* sub_40e040(void* arg1, char* arg2, int32_t arg3)

0040e040  {
0040e04c      int32_t eax = sub_40e080(arg1, arg3);
0040e058      void* i_1 = *(uint32_t*)((char*)arg1 + (eax << 3) + 0x14);
0040e058      
0040e063      if (*(uint32_t*)((char*)arg1 + 4) - arg2 >= i_1)
0040e063      {
0040e065          char* esi_1 = *(uint32_t*)((char*)arg1 + (eax << 3) + 0x10);
0040e06a          void* i = i_1;
0040e06c          char* edi_1 = arg2;
0040e06e          bool cond:1_1 = false;
0040e06e          
0040e070          while (i)
0040e070          {
0040e070              char temp0_1 = *(uint8_t*)esi_1;
0040e070              char temp1_1 = *(uint8_t*)edi_1;
0040e070              cond:1_1 = temp0_1 != temp1_1;
0040e070              esi_1 = &esi_1[1];
0040e070              edi_1 = &edi_1[1];
0040e070              i -= 1;
0040e070              
0040e070              if (temp0_1 != temp1_1)
0040e070                  break;
0040e070          }
0040e070          
0040e073          if (!cond:1_1)
0040e07a              return (char*)i_1 + arg2;
0040e063      }
0040e063      
0040e07f      return 0;
0040e040  }


0040e080    int32_t sub_40e080(void* arg1, int32_t arg2)

0040e080  {
0040e088      int32_t result = arg2 - 0x31;
0040e088      
0040e097      if (arg2 - 0x31 >= 0 && result < *(uint32_t*)((char*)arg1 + 0xc)
0040e097              && *(uint32_t*)((char*)arg1 + (result << 3) + 0x14) != 0xffffffff)
0040e0aa          return result;
0040e0aa      
0040e0a2      return sub_402e40(*(uint32_t*)((char*)arg1 + 8), "invalid capture index");
0040e080  }

0040e0ab                                   90 90 90 90 90                                                             .....

0040e0b0    void* sub_40e0b0(void* arg1, int32_t arg2, char* arg3, int32_t arg4)

0040e0b0  {
0040e0ba      if (!arg4)
0040e0c4          return arg1;
0040e0c4      
0040e0cb      if (arg4 <= arg2)
0040e0cb      {
0040e0cd          int32_t i_1 = arg4 - 1;
0040e0ce          int32_t ebp_1 = arg2 - i_1;
0040e0d0          arg4 = i_1;
0040e0d0          
0040e0d4          if (arg2 != i_1)
0040e0d4          {
0040e0d6              void* ebx_1 = arg1;
0040e0d6              
0040e0ea              while (true)
0040e0ea              {
0040e0ea                  void* eax_3 = sub_418c60(ebx_1, *(uint8_t*)arg3, ebp_1);
0040e0ea                  
0040e0f4                  if (!eax_3)
0040e0f4                      break;
0040e0f4                  
0040e0f7                  int32_t i = i_1;
0040e0f9                  void* edi_1 = &arg3[1];
0040e0fc                  void* esi_2 = (char*)eax_3 + 1;
0040e0fe                  bool cond:2_1 = true;
0040e0fe                  
0040e100                  while (i)
0040e100                  {
0040e100                      char temp1_1 = *(uint8_t*)esi_2;
0040e100                      char temp2_1 = *(uint8_t*)edi_1;
0040e100                      cond:2_1 = temp1_1 == temp2_1;
0040e100                      esi_2 += 1;
0040e100                      edi_1 += 1;
0040e100                      i -= 1;
0040e100                      
0040e100                      if (temp1_1 != temp2_1)
0040e100                          break;
0040e100                  }
0040e100                  
0040e102                  if (cond:2_1)
0040e118                      return eax_3;
0040e118                  
0040e104                  int32_t ebx_2 = (char*)ebx_1 - ((char*)eax_3 + 1);
0040e106                  int32_t temp3_1 = ebp_1;
0040e106                  ebp_1 += ebx_2;
0040e108                  ebx_1 = (char*)eax_3 + 1;
0040e108                  
0040e10a                  if (temp3_1 == -(ebx_2))
0040e10a                      break;
0040e10a                  
0040e0dc                  i_1 = arg4;
0040e0ea              }
0040e0d4          }
0040e0cb      }
0040e0cb      
0040e112      return 0;
0040e0b0  }

0040e119                                                                             90 90 90 90 90 90 90                           .......

0040e120    int32_t sub_40e120(int32_t* arg1, char* arg2, int32_t arg3)

0040e120  {
0040e127      int32_t result = arg1[3];
0040e127      
0040e134      if (!result && arg2)
0040e136          result = 1;
0040e136      
0040e145      sub_402ff0(arg1[2], result, "too many captures");
0040e14d      int32_t esi = 0;
0040e14d      
0040e151      if (result <= 0)
0040e179          return result;
0040e179      
0040e16b      do
0040e16b      {
0040e160          sub_40e180(arg1, esi, arg2, arg3);
0040e168          esi += 1;
0040e16b      } while (esi < result);
0040e16b      
0040e173      return result;
0040e120  }

0040e17a                                                                                90 90 90 90 90 90                            ......

0040e180    void* sub_40e180(int32_t* arg1, int32_t arg2, char* arg3, int32_t arg4)

0040e180  {
0040e18e      if (arg2 >= arg1[3])
0040e18e      {
0040e192          if (arg2)
0040e192          {
0040e1b9              sub_402e40(arg1[2], "invalid capture index");
0040e1c4              return 0;
0040e192          }
0040e192          
0040e1af          return sub_401ff0(arg1[2], arg3, arg4 - arg3);
0040e18e      }
0040e18e      
0040e1c5      int32_t* ebx = arg1[arg2 * 2 + 5];
0040e1c5      
0040e1cc      if (ebx == 0xffffffff)
0040e1d7          sub_402e40(arg1[2], "unfinished capture");
0040e1cc      else if (ebx == 0xfffffffe)
0040e213          return sub_401fd0(arg1[2], arg1[arg2 * 2 + 4] - *(uint32_t*)arg1 + 1);
0040e213      
0040e1f4      return sub_401ff0(arg1[2], arg1[arg2 * 2 + 4], ebx);
0040e180  }

0040e214                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

0040e220    int32_t sub_40e220(void* arg1)

0040e220  {
0040e22f      return sub_40d5b0(arg1, 0);
0040e220  }


0040e230    int32_t sub_40e230(void* arg1)

0040e230  {
0040e23a      sub_4030b0(arg1, 1, nullptr);
0040e244      sub_4030b0(arg1, 2, nullptr);
0040e24c      sub_4018d0(arg1, 2);
0040e254      sub_401fd0(arg1, 0);
0040e261      sub_4020e0(arg1, sub_40e270, 3);
0040e26f      return 1;
0040e230  }


0040e270    int32_t sub_40e270(void* arg1)

0040e270  {
0040e28c      int32_t var_114;
0040e28c      int32_t eax = sub_401db0(arg1, 0xffffd8ed, &var_114);
0040e29b      void* eax_1 = sub_401db0(arg1, 0xffffd8ec, nullptr);
0040e2a9      int32_t ecx_1 = var_114 + eax;
0040e2b0      void* var_108 = arg1;
0040e2b4      int32_t var_110 = eax;
0040e2b4      
0040e2ce      for (void* i = sub_401d30(arg1, 0xffffd8eb) + eax; i <= ecx_1; i += 1)
0040e2ce      {
0040e2db          int32_t var_104_1 = 0;
0040e2e3          char* eax_4 = sub_40d790(&var_110, i, eax_1);
0040e2e3          
0040e2ef          if (eax_4)
0040e2ef          {
0040e309              void* eax_8 = eax_4 - eax;
0040e309              
0040e30d              if (eax_4 == i)
0040e30f                  eax_8 += 1;
0040e30f              
0040e312              sub_401fd0(arg1, eax_8);
0040e31d              sub_401a70(arg1, 0xffffd8eb);
0040e33b              return sub_40e120(&var_110, i, eax_4);
0040e2ef          }
0040e2ce      }
0040e2ce      
0040e306      return 0;
0040e270  }

0040e33c                                                                                      90 90 90 90                              ....

0040e340    int32_t sub_40e340(void* arg1)

0040e340  {
0040e34a      sub_402e40(arg1, "'string.gfind' was renamed to 'string.gmatch'");
0040e352      return 0;
0040e340  }

0040e353                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0040e360    int32_t sub_40e360(void* arg1)

0040e360  {
0040e37e      int32_t ebp = 0;
0040e380      void* var_320;
0040e380      char* esi = sub_4030b0(arg1, 1, &var_320);
0040e38f      char* edi = sub_4030b0(arg1, 2, nullptr);
0040e392      char* var_324 = edi;
0040e39f      void* var_328 = sub_403210(arg1, 4, (char*)var_320 + 1);
0040e3a3      void* eax_2;
0040e3a3      (uint8_t)eax_2 = *(uint8_t*)edi;
0040e3aa      int32_t var_32c;
0040e3aa      
0040e3aa      if ((uint8_t)eax_2 != 0x5e)
0040e3bb          var_32c = 0;
0040e3aa      else
0040e3aa      {
0040e3ac          edi = &edi[1];
0040e3ad          var_32c = 1;
0040e3b5          var_324 = edi;
0040e3aa      }
0040e3aa      
0040e3c8      int32_t var_20c[0x83];
0040e3c8      sub_403810(arg1, &var_20c);
0040e3d8      void* eax_4 = (char*)var_320 + esi;
0040e3dc      void* var_314 = arg1;
0040e3e0      char* var_31c = esi;
0040e3e4      void* var_318 = eax_4;
0040e3e4      
0040e3e8      if (var_328 > 0)
0040e3e8      {
0040e3fb          while (true)
0040e3fb          {
0040e3fb              int32_t var_310_1 = 0;
0040e403              char* eax_5 = sub_40d790(&var_31c, esi, edi);
0040e403              
0040e40f              if (eax_5)
0040e40f              {
0040e420                  ebp += 1;
0040e421                  sub_40e4d0(&var_31c, &var_20c, esi, eax_5);
0040e40f              }
0040e40f              
0040e42b              if (!eax_5 || eax_5 <= esi)
0040e42b              {
0040e431                  eax_4 = var_318;
0040e431                  
0040e437                  if (esi >= eax_4)
0040e437                      break;
0040e437                  
0040e449                  if (var_20c[0] >= &__return_addr)
0040e453                      sub_4035f0(&var_20c);
0040e453                  
0040e462                  void* eax_6;
0040e462                  (uint8_t)eax_6 = *(uint8_t*)esi;
0040e464                  *(uint8_t*)var_20c[0] = (uint8_t)eax_6;
0040e46e                  esi = &esi[1];
0040e46f                  var_20c[0] += 1;
0040e42b              }
0040e42b              else
0040e42d                  esi = eax_5;
0040e42d              
0040e482              if (!var_32c && ebp < var_328)
0040e482              {
0040e3f0                  edi = var_324;
0040e3f0                  continue;
0040e482              }
0040e482              
0040e488              eax_4 = var_318;
0040e488              break;
0040e3fb          }
0040e3e8      }
0040e3e8      
0040e498      sub_4036d0(&var_20c, esi, (char*)eax_4 - esi);
0040e4a5      sub_403750(&var_20c);
0040e4ac      sub_401fd0(arg1, ebp);
0040e4c3      return 2;
0040e360  }

0040e4c4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040e4d0    void* sub_40e4d0(int32_t* arg1, int32_t* arg2, char* arg3, int32_t arg4)

0040e4d0  {
0040e4da      void* esi = arg1[2];
0040e4e3      int32_t eax_1 = sub_401b60(esi, 3) - 3;
0040e4e3      
0040e4ec      if (eax_1 > 3)
0040e4ec      {
0040e5d6          sub_402ca0(esi, 3, "string/function/table expected");
0040e5e2          return 0;
0040e4ec      }
0040e4ec      
0040e4f2      char* ebx;
0040e4f2      int32_t edi;
0040e4f2      
0040e4f2      switch (eax_1)
0040e4f2      {
0040e515          case 0:
0040e515          case 1:
0040e515          {
0040e515              return sub_40e600(arg4, arg2, arg3, arg1, arg2, arg3, arg4);
0040e515              break;
0040e515          }
0040e53c          case 2:
0040e53c          {
0040e53c              edi = arg4;
0040e540              ebx = arg3;
0040e549              sub_40e180(arg1, 0, ebx, edi);
0040e551              sub_402220(esi, 3);
0040e556              goto label_40e55c;
0040e53c          }
0040e519          case 3:
0040e519          {
0040e519              sub_401b20(esi, 3);
0040e51e              edi = arg4;
0040e522              ebx = arg3;
0040e532              sub_402730(esi, sub_40e120(arg1, ebx, edi), 1);
0040e55c          label_40e55c:
0040e55c              
0040e566              if (!sub_401d80(esi, 0xffffffff))
0040e566              {
0040e56b                  sub_4018d0(esi, 0xfffffffe);
0040e575                  sub_401ff0(esi, ebx, edi - ebx);
0040e58e                  return sub_403780(arg2);
0040e566              }
0040e566              
0040e59c              if (!sub_401c20(esi, 0xffffffff))
0040e59c              {
0040e5a6                  int32_t var_1c_4 = sub_401b60(esi, 0xffffffff);
0040e5ad                  int32_t var_24_3 = sub_401b90(esi);
0040e5b4                  sub_402e40(esi, "invalid replacement value (a %s)");
0040e59c              }
0040e59c              
0040e5cd              return sub_403780(arg2);
0040e519              break;
0040e519          }
0040e4f2      }
0040e4d0  }

0040e5e3           90                                                                                         .
0040e5e4  uint32_t jump_table_40e5e4[0x4] = 
0040e5e4  {
0040e5e4      [0x0] =  0x0040e4f9
0040e5e8      [0x1] =  0x0040e4f9
0040e5ec      [0x2] =  0x0040e53c
0040e5f0      [0x3] =  0x0040e516
0040e5f4  }

0040e5f4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

0040e600    int32_t __convention("regparm") sub_40e600(int32_t arg1, int32_t arg2, int32_t arg3, int32_t* arg4, int32_t* arg5, char* arg6, int32_t arg7)

0040e600  {
0040e600      int32_t result_1 = arg3;
0040e612      int32_t eax;
0040e612      char* ecx_1;
0040e612      wchar16 (* edx_1)[0x21];
0040e612      eax = sub_401db0(arg4[2], 3, &result_1);
0040e619      int32_t result = result_1;
0040e620      char* edi = nullptr;
0040e620      
0040e624      if (result > 0)
0040e624      {
0040e6d0          do
0040e6d0          {
0040e638              if (edi[eax] == 0x25)
0040e638              {
0040e662                  edi = &edi[1];
0040e666                  BOOL eax_6;
0040e666                  
0040e666                  if (data_42d07c <= 1)
0040e666                  {
0040e682                      int32_t ecx_3;
0040e682                      (uint8_t)ecx_3 = edi[eax];
0040e685                      int32_t eax_4;
0040e685                      (uint8_t)eax_4 = (**(uint528_t**)&data_42ce70)[ecx_3];
0040e688                      eax_6 = eax_4 & 4;
0040e666                  }
0040e666                  else
0040e666                  {
0040e66a                      int32_t var_18_2 = 4;
0040e66c                      int32_t eax_5;
0040e66c                      (uint8_t)eax_5 = edi[eax];
0040e670                      eax_6 = sub_4179df(eax_5, edx_1, ecx_1, eax_5);
0040e666                  }
0040e666                  
0040e68d                  if (!eax_6)
0040e68d                      goto label_40e644;
0040e68d                  
0040e68f                  (uint8_t)eax_6 = edi[eax];
0040e68f                  
0040e694                  if ((uint8_t)eax_6 != 0x30)
0040e694                  {
0040e6bb                      sub_40e180(arg4, (int32_t)(uint8_t)eax_6 - 0x31, arg6, arg7);
0040e6c1                      ecx_1 = sub_403780(arg5);
0040e694                  }
0040e694                  else
0040e69f                      ecx_1 = sub_4036d0(arg5, arg6, arg7 - arg6);
0040e638              }
0040e638              else
0040e638              {
0040e644              label_40e644:
0040e644                  
0040e644                  if (*(uint32_t*)arg5 >= &arg5[0x83])
0040e647                      sub_4035f0(arg5);
0040e647                  
0040e64f                  ecx_1 = *(uint32_t*)arg5;
0040e651                  (uint8_t)edx_1 = edi[eax];
0040e654                  *(uint8_t*)ecx_1 = (uint8_t)edx_1;
0040e659                  *(uint32_t*)arg5 += 1;
0040e638              }
0040e638              
0040e6c9              result = result_1;
0040e6cd              edi = &edi[1];
0040e6d0          } while (edi < result);
0040e624      }
0040e624      
0040e6db      return result;
0040e600  }

0040e6dc                                                                                      90 90 90 90                              ....

0040e6e0    int32_t sub_40e6e0(void* arg1)

0040e6e0  {
0040e6f6      void* edi = 1;
0040e707      void* var_41c;
0040e707      char* esi = sub_4030b0(arg1, 1, &var_41c);
0040e70d      char* ecx_1 = (char*)var_41c + esi;
0040e715      int32_t var_414[0x83];
0040e715      sub_403810(arg1, &var_414);
0040e715      
0040e723      while (esi < ecx_1)
0040e723      {
0040e72c          char var_208[0x200];
0040e72c          
0040e72c          if (*(uint8_t*)esi == 0x25)
0040e72c          {
0040e761              char* eax_1;
0040e761              (uint8_t)eax_1 = esi[1];
0040e761              
0040e767              if ((uint8_t)eax_1 != 0x25)
0040e767              {
0040e7a0                  edi += 1;
0040e7a8                  void var_430;
0040e7a8                  void* eax_2 = sub_40ead0(arg1, &esi[1], &var_430);
0040e7b5                  int32_t eax_4 = (int32_t)*(uint8_t*)eax_2 - 0x45;
0040e7b8                  esi = (char*)eax_2 + 1;
0040e7b8                  
0040e7bc                  if (eax_4 > 0x33)
0040e7bc                  {
0040e90c                      sub_402e40(arg1, "invalid option to 'format'");
0040e91a                      return 0;
0040e7bc                  }
0040e7bc                  
0040e7c4                  int32_t ecx_8;
0040e7c4                  (uint8_t)ecx_8 = lookup_table_40e934[eax_4];
0040e7c4                  
0040e7ca                  switch (ecx_8)
0040e7ca                  {
0040e830                      case 0:
0040e830                      {
0040e830                          void* var_450_4;
0040e830                          var_450_4 = (double)sub_403150(arg1, edi);
0040e840                          sub_417d2a(&var_208, &var_430);
0040e848                          goto label_40e8b8;
0040e830                      }
0040e7fd                      case 1:
0040e7fd                      {
0040e7fd                          sub_40ec50(&var_430);
0040e804                          int16_t x87control_2;
0040e804                          long double st0_2;
0040e804                          st0_2 = sub_403150(arg1, edi);
0040e80e                          int32_t var_458_2 = __ftol(x87control_2, st0_2);
0040e81c                          sub_417d2a(&var_208, &var_430);
0040e824                          goto label_40e8b8;
0040e7fd                      }
0040e7d3                      case 2:
0040e7d3                      {
0040e7d3                          int16_t x87control_1;
0040e7d3                          long double st0_1;
0040e7d3                          st0_1 = sub_403150(arg1, edi);
0040e7dd                          int32_t var_454_2 = __ftol(x87control_1, st0_1);
0040e7eb                          sub_417d2a(&var_208, &var_430);
0040e8b8                      label_40e8b8:
0040e8b8                          char (* edi_1)[0x200] = &var_208;
0040e8bf                          int32_t i = 0xffffffff;
0040e8bf                          
0040e8c8                          while (i)
0040e8c8                          {
0040e8c8                              bool cond:0_1 = 0 != *(uint8_t*)edi_1;
0040e8c8                              edi_1 = &(*(uint4096_t*)edi_1)[1];
0040e8c8                              i -= 1;
0040e8c8                              
0040e8c8                              if (!cond:0_1)
0040e8c8                                  break;
0040e8c8                          }
0040e8c8                          
0040e8d7                          sub_4036d0(&var_414, &var_208, ~i - 1);
0040e7d3                          break;
0040e7d3                      }
0040e851                      case 3:
0040e851                      {
0040e851                          sub_40e970(arg1, &var_414, edi);
0040e851                          break;
0040e851                      }
0040e865                      case 4:
0040e865                      {
0040e865                          int32_t var_418;
0040e865                          int32_t eax_7 = sub_4030b0(arg1, edi, &var_418);
0040e865                          
0040e886                          if (sub_4172f0(&var_430, 0x2e) || var_418 < 0x64)
0040e886                          {
0040e8a6                              int32_t var_44c_10 = eax_7;
0040e8b0                              sub_417d2a(&var_208, &var_430);
0040e8b5                              goto label_40e8b8;
0040e886                          }
0040e886                          
0040e88a                          sub_401b20(arg1, edi);
0040e894                          sub_403780(&var_414);
0040e865                          break;
0040e865                      }
0040e90c                      case 5:
0040e90c                      {
0040e90c                          sub_402e40(arg1, "invalid option to 'format'");
0040e91a                          return 0;
0040e90c                          break;
0040e90c                      }
0040e7ca                  }
0040e767              }
0040e767              else
0040e767              {
0040e776                  if (var_414[0] >= &var_208)
0040e77d                      sub_4035f0(&var_414);
0040e77d                  
0040e789                  (uint8_t)eax_1 = esi[1];
0040e78b                  *(uint8_t*)var_414[0] = (uint8_t)eax_1;
0040e792                  esi = &esi[2];
0040e793                  var_414[0] += 1;
0040e767              }
0040e72c          }
0040e72c          else
0040e72c          {
0040e73b              if (var_414[0] >= &var_208)
0040e742                  sub_4035f0(&var_414);
0040e742              
0040e750              *(uint8_t*)var_414[0] = *(uint8_t*)esi;
0040e757              esi = &esi[1];
0040e758              var_414[0] += 1;
0040e72c          }
0040e723      }
0040e723      
0040e8f2      sub_403750(&var_414);
0040e905      return 1;
0040e6e0  }

0040e91b                                                                                   90                                         .
0040e91c  uint32_t jump_table_40e91c[0x6] = 
0040e91c  {
0040e91c      [0x0] =  0x0040e829
0040e920      [0x1] =  0x0040e7f8
0040e924      [0x2] =  0x0040e7d1
0040e928      [0x3] =  0x0040e84a
0040e92c      [0x4] =  0x0040e85e
0040e930      [0x5] =  0x0040e906
0040e934  }
0040e934  uint8_t lookup_table_40e934[0x34] = 
0040e934  {
0040e934      [0x00] =  0x00
0040e935      [0x01] =  0x05
0040e936      [0x02] =  0x00
0040e937      [0x03] =  0x05
0040e938      [0x04] =  0x05
0040e939      [0x05] =  0x05
0040e93a      [0x06] =  0x05
0040e93b      [0x07] =  0x05
0040e93c      [0x08] =  0x05
0040e93d      [0x09] =  0x05
0040e93e      [0x0a] =  0x05
0040e93f      [0x0b] =  0x05
0040e940      [0x0c] =  0x05
0040e941      [0x0d] =  0x05
0040e942      [0x0e] =  0x05
0040e943      [0x0f] =  0x05
0040e944      [0x10] =  0x05
0040e945      [0x11] =  0x05
0040e946      [0x12] =  0x05
0040e947      [0x13] =  0x01
0040e948      [0x14] =  0x05
0040e949      [0x15] =  0x05
0040e94a      [0x16] =  0x05
0040e94b      [0x17] =  0x05
0040e94c      [0x18] =  0x05
0040e94d      [0x19] =  0x05
0040e94e      [0x1a] =  0x05
0040e94f      [0x1b] =  0x05
0040e950      [0x1c] =  0x05
0040e951      [0x1d] =  0x05
0040e952      [0x1e] =  0x02
0040e953      [0x1f] =  0x01
0040e954      [0x20] =  0x00
0040e955      [0x21] =  0x00
0040e956      [0x22] =  0x00
0040e957      [0x23] =  0x05
0040e958      [0x24] =  0x01
0040e959      [0x25] =  0x05
0040e95a      [0x26] =  0x05
0040e95b      [0x27] =  0x05
0040e95c      [0x28] =  0x05
0040e95d      [0x29] =  0x05
0040e95e      [0x2a] =  0x01
0040e95f      [0x2b] =  0x05
0040e960      [0x2c] =  0x03
0040e961      [0x2d] =  0x05
0040e962      [0x2e] =  0x04
0040e963      [0x2f] =  0x05
0040e964      [0x30] =  0x01
0040e965      [0x31] =  0x05
0040e966      [0x32] =  0x05
0040e967      [0x33] =  0x01
0040e968  }

0040e968                          90 90 90 90 90 90 90 90                                                          ........

0040e970    int32_t sub_40e970(void* arg1, int32_t* arg2, void* arg3)

0040e970  {
0040e98b      char* ebx = sub_4030b0(arg1, arg3, &arg3);
0040e98b      
0040e99a      if (*(uint32_t*)arg2 >= &arg2[0x83])
0040e99d          sub_4035f0(arg2);
0040e99d      
0040e9a7      **(uint8_t**)arg2 = 0x22;
0040e9ad      *(uint32_t*)arg2 += 1;
0040e9af      char* eax_5 = arg3;
0040e9b8      arg3 = eax_5 - 1;
0040e9b8      
0040e9bc      if (eax_5)
0040e9bc      {
0040ea38          void* i;
0040ea38          
0040ea38          do
0040ea38          {
0040e9be              int32_t eax_7 = (int32_t)*(uint8_t*)ebx;
0040e9be              
0040e9c4              if (eax_7 > 0x5c)
0040e9c4              {
0040ea17              label_40ea17:
0040ea17                  
0040ea17                  if (*(uint32_t*)arg2 >= &arg2[0x83])
0040ea1a                      sub_4035f0(arg2);
0040ea1a                  
0040ea24                  char* ecx;
0040ea24                  (uint8_t)ecx = *(uint8_t*)ebx;
0040ea26                  **(uint8_t**)arg2 = (uint8_t)ecx;
0040ea28                  *(uint32_t*)arg2 += 1;
0040e9c4              }
0040e9c4              else
0040e9c4              {
0040e9c8                  int32_t edx_1;
0040e9c8                  (uint8_t)edx_1 = lookup_table_40ea64[eax_7];
0040e9c8                  
0040e9ce                  switch (edx_1)
0040e9ce                  {
0040ea0b                      case 0:
0040ea0b                      {
0040ea0b                          sub_4036d0(arg2, "\000", 4);
0040ea0b                          break;
0040ea0b                      }
0040e9d7                      case 1:
0040e9d7                      {
0040e9d7                          if (*(uint32_t*)arg2 >= &arg2[0x83])
0040e9da                              sub_4035f0(arg2);
0040e9da                          
0040e9e4                          **(uint8_t**)arg2 = 0x5c;
0040e9e9                          int32_t ecx_2 = *(uint32_t*)arg2 + 1;
0040e9ec                          *(uint32_t*)arg2 = ecx_2;
0040e9ec                          
0040e9f0                          if (ecx_2 >= &arg2[0x83])
0040e9f3                              sub_4035f0(arg2);
0040e9f3                          
0040e9fd                          (uint8_t)edx_1 = *(uint8_t*)ebx;
0040e9ff                          **(uint8_t**)arg2 = (uint8_t)edx_1;
0040ea28                          *(uint32_t*)arg2 += 1;
0040e9d7                          break;
0040e9d7                      }
0040e9ce                      case 2:
0040e9ce                      {
0040e9ce                          goto label_40ea17;
0040e9ce                      }
0040e9ce                  }
0040e9c4              }
0040e9c4              
0040ea2a              i = arg3;
0040ea2e              ebx = &ebx[1];
0040ea34              arg3 = (char*)i - 1;
0040ea38          } while (i);
0040e9bc      }
0040e9bc      
0040ea3c      if (*(uint32_t*)arg2 >= &arg2[0x83])
0040ea3f          sub_4035f0(arg2);
0040ea3f      
0040ea4a      **(uint8_t**)arg2 = 0x22;
0040ea4f      int32_t result = *(uint32_t*)arg2 + 1;
0040ea50      *(uint32_t*)arg2 = result;
0040ea54      return result;
0040e970  }

0040ea55                                                                 8d 49 00                                               .I.
0040ea58  uint32_t jump_table_40ea58[0x3] = 
0040ea58  {
0040ea58      [0x0] =  0x0040ea03
0040ea5c      [0x1] =  0x0040e9d5
0040ea60      [0x2] =  0x0040ea15
0040ea64  }
0040ea64  uint8_t lookup_table_40ea64[0x5d] = 
0040ea64  {
0040ea64      [0x00] =  0x00
0040ea65      [0x01] =  0x02
0040ea66      [0x02] =  0x02
0040ea67      [0x03] =  0x02
0040ea68      [0x04] =  0x02
0040ea69      [0x05] =  0x02
0040ea6a      [0x06] =  0x02
0040ea6b      [0x07] =  0x02
0040ea6c      [0x08] =  0x02
0040ea6d      [0x09] =  0x02
0040ea6e      [0x0a] =  0x01
0040ea6f      [0x0b] =  0x02
0040ea70      [0x0c] =  0x02
0040ea71      [0x0d] =  0x02
0040ea72      [0x0e] =  0x02
0040ea73      [0x0f] =  0x02
0040ea74      [0x10] =  0x02
0040ea75      [0x11] =  0x02
0040ea76      [0x12] =  0x02
0040ea77      [0x13] =  0x02
0040ea78      [0x14] =  0x02
0040ea79      [0x15] =  0x02
0040ea7a      [0x16] =  0x02
0040ea7b      [0x17] =  0x02
0040ea7c      [0x18] =  0x02
0040ea7d      [0x19] =  0x02
0040ea7e      [0x1a] =  0x02
0040ea7f      [0x1b] =  0x02
0040ea80      [0x1c] =  0x02
0040ea81      [0x1d] =  0x02
0040ea82      [0x1e] =  0x02
0040ea83      [0x1f] =  0x02
0040ea84      [0x20] =  0x02
0040ea85      [0x21] =  0x02
0040ea86      [0x22] =  0x01
0040ea87      [0x23] =  0x02
0040ea88      [0x24] =  0x02
0040ea89      [0x25] =  0x02
0040ea8a      [0x26] =  0x02
0040ea8b      [0x27] =  0x02
0040ea8c      [0x28] =  0x02
0040ea8d      [0x29] =  0x02
0040ea8e      [0x2a] =  0x02
0040ea8f      [0x2b] =  0x02
0040ea90      [0x2c] =  0x02
0040ea91      [0x2d] =  0x02
0040ea92      [0x2e] =  0x02
0040ea93      [0x2f] =  0x02
0040ea94      [0x30] =  0x02
0040ea95      [0x31] =  0x02
0040ea96      [0x32] =  0x02
0040ea97      [0x33] =  0x02
0040ea98      [0x34] =  0x02
0040ea99      [0x35] =  0x02
0040ea9a      [0x36] =  0x02
0040ea9b      [0x37] =  0x02
0040ea9c      [0x38] =  0x02
0040ea9d      [0x39] =  0x02
0040ea9e      [0x3a] =  0x02
0040ea9f      [0x3b] =  0x02
0040eaa0      [0x3c] =  0x02
0040eaa1      [0x3d] =  0x02
0040eaa2      [0x3e] =  0x02
0040eaa3      [0x3f] =  0x02
0040eaa4      [0x40] =  0x02
0040eaa5      [0x41] =  0x02
0040eaa6      [0x42] =  0x02
0040eaa7      [0x43] =  0x02
0040eaa8      [0x44] =  0x02
0040eaa9      [0x45] =  0x02
0040eaaa      [0x46] =  0x02
0040eaab      [0x47] =  0x02
0040eaac      [0x48] =  0x02
0040eaad      [0x49] =  0x02
0040eaae      [0x4a] =  0x02
0040eaaf      [0x4b] =  0x02
0040eab0      [0x4c] =  0x02
0040eab1      [0x4d] =  0x02
0040eab2      [0x4e] =  0x02
0040eab3      [0x4f] =  0x02
0040eab4      [0x50] =  0x02
0040eab5      [0x51] =  0x02
0040eab6      [0x52] =  0x02
0040eab7      [0x53] =  0x02
0040eab8      [0x54] =  0x02
0040eab9      [0x55] =  0x02
0040eaba      [0x56] =  0x02
0040eabb      [0x57] =  0x02
0040eabc      [0x58] =  0x02
0040eabd      [0x59] =  0x02
0040eabe      [0x5a] =  0x02
0040eabf      [0x5b] =  0x02
0040eac0      [0x5c] =  0x01
0040eac1  }

0040eac1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040ead0    void* sub_40ead0(void* arg1, char* arg2, char* arg3)

0040ead0  {
0040ead8      void* result = arg2;
0040eae4      void* eax_1;
0040eae4      int32_t ecx;
0040eae4      eax_1 = sub_4172f0("-+ #0", *(uint8_t*)arg2);
0040eae4      
0040eaee      if (eax_1)
0040eaee      {
0040eb05          void* i;
0040eb05          
0040eb05          do
0040eb05          {
0040eaf0              char ecx_1 = *(uint8_t*)((char*)result + 1);
0040eaf4              result += 1;
0040eafb              i = sub_4172f0("-+ #0", ecx_1);
0040eb05          } while (i);
0040eaee      }
0040eaee      
0040eb0d      int32_t edx_1 = (char*)result - arg2;
0040eb0d      
0040eb12      if (edx_1 >= 6)
0040eb1a          ecx = sub_402e40(arg1, "invalid format (repeated flags)");
0040eb1a      
0040eb2e      BOOL eax_3;
0040eb2e      int32_t ecx_2;
0040eb2e      wchar16 (* edx_2)[0x21];
0040eb2e      
0040eb2e      if (data_42d07c <= 1)
0040eb2e      {
0040eb41          edx_2 = data_42ce70;
0040eb49          (uint8_t)ecx_2 = *(uint8_t*)result;
0040eb4b          int32_t eax_4;
0040eb4b          (uint8_t)eax_4 = (*(uint528_t*)edx_2)[ecx_2];
0040eb4e          eax_3 = eax_4 & 4;
0040eb2e      }
0040eb2e      else
0040eb2e      {
0040eb32          int32_t var_14_2 = 4;
0040eb34          int32_t eax_2;
0040eb34          (uint8_t)eax_2 = *(uint8_t*)result;
0040eb37          eax_3 = sub_4179df(eax_2, edx_1, ecx, eax_2);
0040eb2e      }
0040eb2e      
0040eb53      if (eax_3)
0040eb55          result += 1;
0040eb55      
0040eb5c      BOOL eax_6;
0040eb5c      int32_t ecx_3;
0040eb5c      wchar16 (* edx_3)[0x21];
0040eb5c      
0040eb5c      if (data_42d07c <= 1)
0040eb5c      {
0040eb6f          edx_3 = data_42ce70;
0040eb77          (uint8_t)ecx_3 = *(uint8_t*)result;
0040eb79          (uint8_t)eax_3 = (*(uint528_t*)edx_3)[ecx_3];
0040eb7c          eax_6 = eax_3 & 4;
0040eb5c      }
0040eb5c      else
0040eb5c      {
0040eb60          int32_t var_14_3 = 4;
0040eb62          int32_t eax_5;
0040eb62          (uint8_t)eax_5 = *(uint8_t*)result;
0040eb65          eax_6 = sub_4179df(eax_5, edx_2, ecx_2, eax_5);
0040eb5c      }
0040eb5c      
0040eb81      if (eax_6)
0040eb83          result += 1;
0040eb83      
0040eb87      if (*(uint8_t*)result == 0x2e)
0040eb87      {
0040eb8e          result += 1;
0040eb91          BOOL eax_9;
0040eb91          int32_t ecx_4;
0040eb91          wchar16 (* edx_4)[0x21];
0040eb91          
0040eb91          if (data_42d07c <= 1)
0040eb91          {
0040eba4              edx_4 = data_42ce70;
0040ebac              (uint8_t)ecx_4 = *(uint8_t*)result;
0040ebae              int32_t eax_7;
0040ebae              (uint8_t)eax_7 = (*(uint528_t*)edx_4)[ecx_4];
0040ebb1              eax_9 = eax_7 & 4;
0040eb91          }
0040eb91          else
0040eb91          {
0040eb95              int32_t var_14_4 = 4;
0040eb97              int32_t eax_8;
0040eb97              (uint8_t)eax_8 = *(uint8_t*)result;
0040eb9a              eax_9 = sub_4179df(eax_8, edx_3, ecx_3, eax_8);
0040eb91          }
0040eb91          
0040ebb6          if (eax_9)
0040ebb8              result += 1;
0040ebb8          
0040ebbf          if (data_42d07c <= 1)
0040ebbf          {
0040ebd2              edx_3 = data_42ce70;
0040ebda              (uint8_t)ecx_3 = *(uint8_t*)result;
0040ebdc              (uint8_t)eax_9 = (*(uint528_t*)edx_3)[ecx_3];
0040ebdf              eax_6 = eax_9 & 4;
0040ebbf          }
0040ebbf          else
0040ebbf          {
0040ebc3              int32_t var_14_5 = 4;
0040ebc5              int32_t eax_10;
0040ebc5              (uint8_t)eax_10 = *(uint8_t*)result;
0040ebc8              eax_6 = sub_4179df(eax_10, edx_4, ecx_4, eax_10);
0040ebbf          }
0040ebbf          
0040ebe4          if (eax_6)
0040ebe6              result += 1;
0040eb87      }
0040eb87      
0040ebed      BOOL eax_12;
0040ebed      
0040ebed      if (data_42d07c <= 1)
0040ebed      {
0040ec08          int32_t ecx_5;
0040ec08          (uint8_t)ecx_5 = *(uint8_t*)result;
0040ec0a          (uint8_t)eax_6 = (**(uint528_t**)&data_42ce70)[ecx_5];
0040ec0d          eax_12 = eax_6 & 4;
0040ebed      }
0040ebed      else
0040ebed      {
0040ebf1          int32_t var_14_6 = 4;
0040ebf3          int32_t eax_11;
0040ebf3          (uint8_t)eax_11 = *(uint8_t*)result;
0040ebf6          eax_12 = sub_4179df(eax_11, edx_3, ecx_3, eax_11);
0040ebed      }
0040ebed      
0040ec12      if (eax_12)
0040ec1a          sub_402e40(arg1, "invalid format (width or precision too long)");
0040ec1a      
0040ec28      int32_t ebx_1 = (char*)result - arg2;
0040ec2a      *(uint8_t*)arg3 = 0x25;
0040ec34      sub_417ef0(&arg3[1], arg2, ebx_1 + 1);
0040ec3c      arg3[ebx_1 + 2] = 0;
0040ec47      return result;
0040ead0  }

0040ec48                          90 90 90 90 90 90 90 90                                                          ........

0040ec50    int32_t sub_40ec50(int32_t arg1)

0040ec50  {
0040ec56      int32_t edi = arg1;
0040ec58      int32_t i = 0xffffffff;
0040ec58      
0040ec5d      while (i)
0040ec5d      {
0040ec5d          bool cond:0_1 = 0 != *(uint8_t*)edi;
0040ec5d          edi += 1;
0040ec5d          i -= 1;
0040ec5d          
0040ec5d          if (!cond:0_1)
0040ec5d              break;
0040ec5d      }
0040ec5d      
0040ec5f      int32_t esi;
0040ec5f      (uint16_t)esi = data_42be2c;
0040ec6a      char result = (~i - 1)[arg1 - 1];
0040ec6e      *(uint16_t*)(~i - 1 + arg1 - 1) = (uint16_t)esi;
0040ec73      (~i - 1)[arg1] = result;
0040ec76      (~i - 1)[arg1 + 1] = 0;
0040ec7c      return result;
0040ec50  }

0040ec7d                                                                                         90 90 90                               ...

0040ec80    int32_t sub_40ec80(void* arg1)

0040ec80  {
0040ec90      sub_403300(arg1, "string", &data_4285d0);
0040ec9d      sub_402250(arg1, 0xffffffff, "gmatch");
0040ecaa      sub_402490(arg1, 0xfffffffe, "gfind");
0040ecb0      sub_40ecc0(arg1);
0040ecbe      return 1;
0040ec80  }

0040ecbf                                                                                               90                                 .

0040ecc0    void* sub_40ecc0(void* arg1)

0040ecc0  {
0040ecca      sub_402330(arg1, 0, 1);
0040ecd7      sub_401ff0(arg1, &data_4307a0, nullptr);
0040ecdf      sub_401b20(arg1, 0xfffffffe);
0040ece7      sub_4025e0(arg1, 0xfffffffe);
0040ecef      sub_4018d0(arg1, 0xfffffffe);
0040ecf7      sub_401b20(arg1, 0xfffffffe);
0040ed04      sub_402490(arg1, 0xfffffffe, "__index");
0040ed18      return sub_4018d0(arg1, 0xfffffffe);
0040ecc0  }

0040ed19                                                                             90 90 90 90 90 90 90                           .......

0040ed20    int32_t sub_40ed20(void* arg1)

0040ed20  {
0040ed39      sub_401fd0(arg1, sub_418d2f(sub_4030f0(arg1, 1, 0, nullptr)));
0040ed47      return 1;
0040ed20  }

0040ed48                          90 90 90 90 90 90 90 90                                                          ........

0040ed50    int32_t sub_40ed50(void* arg1)

0040ed50  {
0040ed5a      PSTR eax = sub_4030b0(arg1, 1, nullptr);
0040ed64      int32_t eax_1 = sub_418dc5(eax);
0040ed6c      int32_t eax_2 = -(eax_1);
0040ed7c      return sub_40f590(arg1, eax_2 - eax_2 + 1, eax);
0040ed50  }

0040ed7d                                                                                         90 90 90                               ...

0040ed80    int32_t sub_40ed80(void* arg1)

0040ed80  {
0040ed8b      PSTR eax = sub_4030b0(arg1, 1, nullptr);
0040eda2      int32_t eax_2 = sub_418def(eax, sub_4030b0(arg1, 2, nullptr));
0040edaa      int32_t eax_3 = -(eax_2);
0040edbb      return sub_40f590(arg1, eax_3 - eax_3 + 1, eax);
0040ed80  }

0040edbc                                                                                      90 90 90 90                              ....

0040edc0    int32_t sub_40edc0(void* arg1)

0040edc0  {
0040edd2      void var_10;
0040edd2      
0040edd2      if (sub_418e1d(&var_10))
0040edd2      {
0040edf4          sub_402040(arg1, &var_10);
0040ee04          return 1;
0040edd2      }
0040edd2      
0040edde      sub_402e40(arg1, "unable to generate a unique filename");
0040ede9      return 0;
0040edc0  }

0040ee05                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040ee10    int32_t sub_40ee10(void* arg1)

0040ee10  {
0040ee27      sub_402040(arg1, sub_418fca(sub_4030b0(arg1, 1, nullptr)));
0040ee35      return 1;
0040ee10  }

0040ee36                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040ee40    int32_t sub_40ee40(void* arg1)

0040ee40  {
0040ee40      int32_t ecx;
0040ee40      int32_t var_4_1 = ecx;
0040ee41      uint32_t eax = sub_419047(ecx);
0040ee5f      sub_401fa0(arg1, (double)((long double)eax * (long double)0,001.0), eax);
0040ee6c      return 1;
0040ee40  }

0040ee6d                                         90 90 90                                                               ...

0040ee70    int32_t sub_40ee70(void* arg1)

0040ee70  {
0040ee92      char* ebx = sub_4030f0(arg1, 1, 0x42b444, nullptr);
0040ee9e      int32_t eax_2;
0040ee9e      
0040ee9e      if (sub_401b60(arg1, 2) > 0)
0040ee9e      {
0040eeaf          int16_t x87control_1;
0040eeaf          long double st0_1;
0040eeaf          st0_1 = sub_403150(arg1, 2);
0040eeb7          eax_2 = __ftol(x87control_1, st0_1);
0040ee9e      }
0040ee9e      else
0040eea2          eax_2 = sub_419bbf(nullptr);
0040eea2      
0040eebc      int32_t var_104 = eax_2;
0040eec0      (uint8_t)eax_2 = *(uint8_t*)ebx;
0040eec4      int32_t* ebp;
0040eec4      
0040eec4      if ((uint8_t)eax_2 != 0x21)
0040eee5          ebp = sub_419966(&var_104);
0040eec4      else
0040eec4      {
0040eed3          ebp = sub_419ac6(&var_104);
0040eed5          ebx = &ebx[1];
0040eec4      }
0040eec4      
0040eee9      if (!ebp)
0040eee9      {
0040eeec          sub_401f80(arg1);
0040ef02          return 1;
0040eee9      }
0040eee9      
0040ef04      void* edi = &data_42bf3c;
0040ef09      char* eax_6 = ebx;
0040ef0b      int32_t eax_8;
0040ef0b      
0040ef0b      while (true)
0040ef0b      {
0040ef0b          char edx_1 = *(uint8_t*)eax_6;
0040ef0f          char temp0_1 = *(uint8_t*)edi;
0040ef0f          bool c_1 = edx_1 < temp0_1;
0040ef0f          
0040ef11          if (edx_1 == temp0_1)
0040ef11          {
0040ef15              if (!edx_1)
0040ef15              {
0040ef2b                  eax_8 = 0;
0040ef2d                  break;
0040ef15              }
0040ef15              
0040ef17              edx_1 = eax_6[1];
0040ef1c              char temp3_1 = *(uint8_t*)((char*)edi + 1);
0040ef1c              c_1 = edx_1 < temp3_1;
0040ef1c              
0040ef1f              if (edx_1 == temp3_1)
0040ef1f              {
0040ef21                  eax_6 = &eax_6[2];
0040ef24                  edi += 2;
0040ef24                  
0040ef29                  if (edx_1)
0040ef29                      continue;
0040ef29                  
0040ef2b                  eax_8 = 0;
0040ef2d                  break;
0040ef1f              }
0040ef11          }
0040ef11          
0040ef2f          bool c_2 = /* bool c_2 = unimplemented  {sbb eax, eax} */;
0040ef31          eax_8 = eax_6 - eax_6 + 1;
0040ef31          break;
0040ef0b      }
0040ef0b      
0040ef37      if (eax_8)
0040ef37      {
0040f001          void var_100;
0040f001          
0040f001          if (!sub_4190bf(&var_100, 0x100, ebx, ebp))
0040f001          {
0040f026              sub_402e40(arg1, "'date' format too long");
0040f037              return 0;
0040f001          }
0040f001          
0040f009          sub_402040(arg1, &var_100);
0040f01f          return 1;
0040ef37      }
0040ef37      
0040ef41      sub_402330(arg1, eax_8, 9);
0040ef50      sub_40f040(arg1, "sec", *(uint32_t*)ebp);
0040ef5f      sub_40f040(arg1, "min", ebp[1]);
0040ef6e      sub_40f040(arg1, "hour", ebp[2]);
0040ef7d      sub_40f040(arg1, "day", ebp[3]);
0040ef8d      sub_40f040(arg1, "month", ebp[4] + 1);
0040efa5      sub_40f040(arg1, "year", ebp[5] + 0x76c);
0040efb5      sub_40f040(arg1, "wday", ebp[6] + 1);
0040efc5      sub_40f040(arg1, "yday", ebp[7] + 1);
0040efd4      sub_40f070(arg1, "isdst", ebp[8]);
0040efea      return 1;
0040ee70  }

0040f038                                                                          90 90 90 90 90 90 90 90                          ........

0040f040    int32_t sub_40f040(void* arg1, char* arg2, int32_t arg3)

0040f040  {
0040f04b      sub_401fd0(arg1, arg3);
0040f061      return sub_402490(arg1, 0xfffffffe, arg2);
0040f040  }

0040f062        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0040f070    int32_t sub_40f070(void* arg1, char* arg2, int32_t arg3)

0040f070  {
0040f076      if (arg3 < 0)
0040f095          return arg3;
0040f095      
0040f07f      sub_4021a0(arg1, arg3);
0040f08c      return sub_402490(arg1, 0xfffffffe, arg2);
0040f070  }

0040f096                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040f0a0    int32_t sub_40f0a0(int32_t arg1)

0040f0a0  {
0040f0a4      void* esi = arg1;
0040f0b5      char* var_30;
0040f0b5      int32_t var_2c;
0040f0b5      int32_t eax_1;
0040f0b5      
0040f0b5      if (sub_401b60(esi, 1) > 0)
0040f0b5      {
0040f0cb          sub_403020(esi, 1, 5);
0040f0d3          sub_4018d0(esi, 1);
0040f0ed          void* var_24 = sub_40f200(esi, "sec", nullptr);
0040f0fe          void* var_20_1 = sub_40f200(esi, "min", nullptr);
0040f10f          void* var_1c_1 = sub_40f200(esi, "hour", 0xc);
0040f11b          void* var_18_1 = sub_40f200(esi, "day", 0xffffffff);
0040f11f          var_2c = 0xffffffff;
0040f121          var_30 = "month";
0040f135          void* var_14_1 = sub_40f200(esi, "month", 0xffffffff) - 1;
0040f149          void* var_10_1 = sub_40f200(esi, "year", 0xffffffff) - 0x76c;
0040f152          int32_t var_4_1 = sub_40f1a0(esi, "isdst");
0040f15b          eax_1 = sub_419c9b(&var_24);
0040f0b5      }
0040f0b5      else
0040f0b5      {
0040f0b7          var_2c = 0;
0040f0b9          eax_1 = sub_419bbf(nullptr);
0040f0b5      }
0040f0b5      
0040f16a      if (eax_1 == 0xffffffff)
0040f16a      {
0040f16d          sub_401f80(esi);
0040f17e          return 1;
0040f16a      }
0040f16a      
0040f186      var_30 = (double)(long double)eax_1;
0040f18a      sub_401fa0(esi, var_30, var_2c);
0040f19b      return 1;
0040f0a0  }

0040f19c                                                                                      90 90 90 90                              ....

0040f1a0    int32_t sub_40f1a0(void* arg1, char* arg2)

0040f1a0  {
0040f1ae      sub_402250(arg1, 0xffffffff, arg2);
0040f1ae      
0040f1c0      if (!sub_401b60(arg1, 0xffffffff))
0040f1c0      {
0040f1c8          sub_4018d0(arg1, 0xfffffffe);
0040f1d4          return 0xffffffff;
0040f1c0      }
0040f1c0      
0040f1d8      int32_t result = sub_401d80(arg1, 0xffffffff);
0040f1e5      sub_4018d0(arg1, 0xfffffffe);
0040f1f1      return result;
0040f1a0  }

0040f1f2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

0040f200    void* sub_40f200(void* arg1, char* arg2, void* arg3)

0040f200  {
0040f20f      sub_402250(arg1, 0xffffffff, arg2);
0040f221      void* result;
0040f221      
0040f221      if (!sub_401be0(arg1, 0xffffffff))
0040f221      {
0040f241          result = arg3;
0040f241          
0040f247          if (result < 0)
0040f247          {
0040f249              char* var_10_1 = arg2;
0040f250              sub_402e40(arg1, "field '%s' missing in date table");
0040f25b              return 0;
0040f247          }
0040f221      }
0040f221      else
0040f22e          result = sub_401d30(arg1, 0xffffffff);
0040f22e      
0040f233      sub_4018d0(arg1, 0xfffffffe);
0040f240      return result;
0040f200  }

0040f25c                                                                                      90 90 90 90                              ....

0040f260    int32_t sub_40f260(void* arg1)

0040f260  {
0040f265      int32_t var_8 = 0;
0040f26c      int16_t x87control;
0040f26c      long double st0;
0040f26c      st0 = sub_4031a0(arg1, 2, 0f);
0040f274      int32_t eax = __ftol(x87control, st0);
0040f27d      int16_t x87control_1;
0040f27d      long double st0_1;
0040f27d      st0_1 = sub_403150(arg1, 1);
0040f290      int32_t var_c;
0040f290      var_c = (double)sub_419e8d(__ftol(x87control_1, st0_1), eax);
0040f294      sub_401fa0(arg1, var_c);
0040f2a2      return 1;
0040f260  }

0040f2a3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0040f2b0    int32_t sub_40f2b0(void* arg1)

0040f2b0  {
0040f2bc      void* eax = sub_401db0(arg1, 1, nullptr);
0040f2d0      int32_t eax_1 = sub_402e70(arg1, 2, 0x42beb4, 0x428668);
0040f2d0      
0040f2dc      if (!eax && sub_401b60(arg1, 1) > 0)
0040f2f5          sub_402ca0(arg1, 1, "string expected");
0040f2f5      
0040f30d      sub_402040(arg1, sub_419e9e(*(uint32_t*)((eax_1 << 2) + &data_428650), eax));
0040f31d      return 1;
0040f2b0  }

0040f31e                                                                                            90 90                                ..

0040f320    int32_t sub_40f320(void* arg1)

0040f320  {
0040f332      sub_417023(sub_403210(arg1, 1, 0));
0040f34f      sub_403300(__return_addr, "os", &data_428688);
0040f35c      return 1;
0040f320  }

0040f35d                                                                                         90 90 90                               ...

0040f360    int32_t sub_40f360(void* arg1)

0040f360  {
0040f369      sub_403080(arg1, 1);
0040f371      int32_t* eax = sub_401ed0(arg1, 1);
0040f383      sub_402250(arg1, 0xffffd8f0, "FILE*");
0040f383      
0040f38d      if (eax && sub_402380(arg1, 1) && sub_401c50(arg1, 0xfffffffe, 0xffffffff))
0040f38d      {
0040f3b2          if (*(uint32_t*)eax)
0040f3b2          {
0040f3d4              sub_401ff0(arg1, "file", 4);
0040f3e3              return 1;
0040f3b2          }
0040f3b2          
0040f3bc          sub_401ff0(arg1, "closed file", 0xb);
0040f3cb          return 1;
0040f38d      }
0040f38d      
0040f3e5      sub_401f80(arg1);
0040f3f4      return 1;
0040f360  }

0040f3f5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040f400    int32_t sub_40f400(void* arg1)

0040f400  {
0040f413      if (sub_401b60(arg1, 1) == 0xffffffff)
0040f41d          sub_4022f0(arg1, 0xffffd8ef, 2);
0040f41d      
0040f426      sub_40f440(arg1);
0040f435      return sub_40f470(arg1);
0040f400  }

0040f436                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040f440    int32_t sub_40f440(void* arg1)

0040f440  {
0040f44e      int32_t* eax = sub_402f80(arg1, 1, "FILE*");
0040f44e      
0040f45b      if (!*(uint32_t*)eax)
0040f463          sub_402e40(arg1, "attempt to use a closed file");
0040f463      
0040f46f      return *(uint32_t*)eax;
0040f440  }


0040f470    int32_t sub_40f470(void* arg1)

0040f470  {
0040f478      sub_4023e0(arg1, 1);
0040f485      sub_402250(arg1, 0xffffffff, "__close");
0040f49f      return sub_401ea0(arg1, 0xffffffff)(arg1);
0040f470  }


0040f4a0    int32_t sub_40f4a0(void* arg1)

0040f4a0  {
0040f4b2      int32_t eax_1 = *(uint32_t*)sub_402f80(arg1, 1, "FILE*");
0040f4b2      
0040f4ce      if (eax_1 && eax_1 != &data_42cbf0 && eax_1 != 0x42cc10 && eax_1 != 0x42cc30)
0040f4d1          sub_40f470(arg1);
0040f4d1      
0040f4dc      return 0;
0040f4a0  }

0040f4dd                                                                                         90 90 90                               ...

0040f4e0    int32_t sub_40f4e0(void* arg1)

0040f4e0  {
0040f4f2      int32_t eax_1 = *(uint32_t*)sub_402f80(arg1, 1, "FILE*");
0040f4f2      
0040f4f9      if (!eax_1)
0040f4f9      {
0040f501          sub_402040(arg1, "file (closed)");
0040f50f          return 1;
0040f4f9      }
0040f4f9      
0040f510      int32_t var_8 = eax_1;
0040f517      sub_4020b0(arg1, "file (%p)");
0040f525      return 1;
0040f4e0  }

0040f526                    90 90 90 90 90 90 90 90 90 90                                                        ..........

0040f530    int32_t sub_40f530(void* arg1)

0040f530  {
0040f53d      PSTR eax = sub_4030b0(arg1, 1, nullptr);
0040f54e      char* eax_1 = sub_4030f0(arg1, 2, 0x42b21c, nullptr);
0040f556      void* eax_2 = sub_40f620(arg1);
0040f55f      int32_t* eax_3 = sub_417118(eax, eax_1);
0040f567      *(uint32_t*)eax_2 = eax_3;
0040f567      
0040f56c      if (eax_3)
0040f587          return 1;
0040f587      
0040f57d      return sub_40f590(arg1, eax_3, eax);
0040f530  }

0040f588                          90 90 90 90 90 90 90 90                                                          ........

0040f590    int32_t sub_40f590(void* arg1, int32_t arg2, int32_t arg3)

0040f590  {
0040f595      int32_t edi = data_4307d4;
0040f595      
0040f59d      if (arg2)
0040f59d      {
0040f5a6          sub_4021a0(arg1, 1);
0040f5b4          return 1;
0040f59d      }
0040f59d      
0040f5bc      sub_401f80(arg1);
0040f5bc      
0040f5cb      if (!arg3)
0040f5cb      {
0040f5f5          sub_416fca(edi);
0040f5fa          int32_t var_14_2 = 0x4307ac;
0040f601          sub_4020b0(arg1, 0x42beb8);
0040f60b          sub_401fd0(arg1, edi);
0040f61b          return 3;
0040f5cb      }
0040f5cb      
0040f5cd      sub_416fca(edi);
0040f5d2      int32_t var_14 = 0x4307ac;
0040f5d3      int32_t var_18 = arg3;
0040f5da      sub_4020b0(arg1, "%s: %s");
0040f5e4      sub_401fd0(arg1, edi);
0040f5f4      return 3;
0040f590  }

0040f61c                                                                                      90 90 90 90                              ....

0040f620    void* sub_40f620(void* arg1)

0040f620  {
0040f629      void* result = sub_402b10(arg1, 4);
0040f63b      *(uint32_t*)result = 0;
0040f641      sub_402250(arg1, 0xffffd8f0, "FILE*");
0040f649      sub_4025e0(arg1, 0xfffffffe);
0040f655      return result;
0040f620  }

0040f656                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040f660    int32_t sub_40f660(void* arg1)

0040f660  {
0040f66d      int32_t eax = sub_4030b0(arg1, 1, nullptr);
0040f67e      char* eax_1 = sub_4030f0(arg1, 2, 0x42b21c, nullptr);
0040f686      void* eax_2 = sub_40f620(arg1);
0040f68f      int32_t* eax_3 = sub_41a4d7(eax, eax_1);
0040f697      *(uint32_t*)eax_2 = eax_3;
0040f697      
0040f69c      if (eax_3)
0040f6b7          return 1;
0040f6b7      
0040f6ad      return sub_40f590(arg1, eax_3, eax);
0040f660  }

0040f6b8                                                                          90 90 90 90 90 90 90 90                          ........

0040f6c0    int32_t sub_40f6c0(void* arg1)

0040f6c0  {
0040f6c7      void* eax = sub_40f620(arg1);
0040f6d1      int32_t* eax_1 = sub_418e6c();
0040f6d8      *(uint32_t*)eax = eax_1;
0040f6d8      
0040f6da      if (eax_1)
0040f6f1          return 1;
0040f6f1      
0040f6e9      return sub_40f590(arg1, eax_1, eax_1);
0040f6c0  }

0040f6f2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

0040f700    int32_t sub_40f700(void* arg1)

0040f700  {
0040f70c      sub_40f720(arg1, 1, U"r");
0040f714      return 1;
0040f700  }

0040f715                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040f720    int32_t sub_40f720(void* arg1, int32_t arg2, char* arg3)

0040f720  {
0040f737      if (sub_401b60(arg1, 1) > 0)
0040f737      {
0040f73f          PSTR eax_1 = sub_401db0(arg1, 1, nullptr);
0040f73f          
0040f74b          if (!eax_1)
0040f74b          {
0040f777              sub_40f440(arg1);
0040f77f              sub_401b20(arg1, 1);
0040f74b          }
0040f74b          else
0040f74b          {
0040f74f              void* eax_2 = sub_40f620(arg1);
0040f75c              int32_t* eax_4 = sub_417118(eax_1, arg3);
0040f764              *(uint32_t*)eax_2 = eax_4;
0040f764              
0040f769              if (!eax_4)
0040f76f                  sub_40f7b0(arg1, 1, eax_1);
0040f74b          }
0040f74b          
0040f78e          sub_402570(arg1, 0xffffd8ef, arg2);
0040f737      }
0040f737      
0040f79e      sub_4022f0(arg1, 0xffffd8ef, arg2);
0040f7ad      return 1;
0040f720  }

0040f7ae                                            90 90                                                                ..

0040f7b0    int32_t sub_40f7b0(void* arg1, int32_t arg2, int32_t arg3)

0040f7b0  {
0040f7b7      sub_416fca(data_4307d4);
0040f7c4      int32_t var_c = 0x4307ac;
0040f7c5      int32_t var_10 = arg3;
0040f7cc      sub_4020b0(arg1, "%s: %s");
0040f7e2      sub_402ca0(arg1, arg2, sub_401db0(arg1, 0xffffffff, nullptr));
0040f7eb      return 0;
0040f7b0  }

0040f7ec                                      90 90 90 90                                                              ....

0040f7f0    int32_t sub_40f7f0(void* arg1)

0040f7f0  {
0040f7fc      sub_40f720(arg1, 2, U"w");
0040f804      return 1;
0040f7f0  }

0040f805                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040f810    int32_t sub_40f810(void* arg1)

0040f810  {
0040f816      sub_40f440(arg1);
0040f820      sub_40f830(arg1, 1, 0);
0040f82e      return 1;
0040f810  }

0040f82f                                               90                                                                 .

0040f830    int32_t sub_40f830(void* arg1, int32_t arg2, int32_t arg3)

0040f830  {
0040f83b      sub_401b20(arg1, arg2);
0040f846      sub_4021a0(arg1, arg3);
0040f85c      return sub_4020e0(arg1, sub_40fd00, 2);
0040f830  }

0040f85d                                                                                         90 90 90                               ...

0040f860    int32_t sub_40f860(void* arg1)

0040f860  {
0040f872      if (sub_401b60(arg1, 1) <= 0)
0040f872      {
0040f87c          sub_4022f0(arg1, 0xffffd8ef, 1);
0040f882          sub_40f810(arg1);
0040f88b          return 1;
0040f872      }
0040f872      
0040f893      PSTR eax_1 = sub_4030b0(arg1, 1, nullptr);
0040f89b      void* eax_2 = sub_40f620(arg1);
0040f8a8      int32_t* eax_3 = sub_417118(eax_1, U"r");
0040f8b0      *(uint32_t*)eax_2 = eax_3;
0040f8b0      
0040f8b4      if (!eax_3)
0040f8ba          sub_40f7b0(arg1, 1, eax_1);
0040f8ba      
0040f8cf      sub_40f830(arg1, sub_4018c0(arg1), 1);
0040f8df      return 1;
0040f860  }


0040f8e0    int32_t sub_40f8e0(void* arg1)

0040f8e0  {
0040f8fd      return sub_40f950(arg1, sub_40f900(arg1, 1), 1);
0040f8e0  }

0040f8fe                                                                                            90 90                                ..

0040f900    int32_t sub_40f900(void* arg1, int32_t arg2)

0040f900  {
0040f912      sub_4022f0(arg1, 0xffffd8ef, arg2);
0040f91f      int32_t result = *(uint32_t*)sub_401ed0(arg1, 0xffffffff);
0040f91f      
0040f926      if (!result)
0040f926      {
0040f92f          int32_t var_10_1 = "MbP?"[arg2];
0040f936          sub_402e40(arg1, "standard %s file is closed");
0040f926      }
0040f926      
0040f943      return result;
0040f900  }

0040f944              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040f950    int32_t sub_40f950(void* arg1, int32_t* arg2, int32_t arg3)

0040f950  {
0040f953      void* esi = arg1;
0040f965      int32_t edi_1 = sub_4018c0(esi) - 1;
0040f966      sub_41a8e7(arg2);
0040f970      int32_t i;
0040f970      int32_t ebx;
0040f970      
0040f970      if (edi_1)
0040f970      {
0040f9a9          sub_402ff0(esi, edi_1 + 0x14, "too many arguments");
0040f9ae          ebx = arg3;
0040f9b5          void* edi_2 = edi_1 - 1;
0040f9b6          i = 1;
0040f9bb          arg1 = edi_2;
0040f9bb          
0040f9c1          while (i)
0040f9c1          {
0040f9d0              if (sub_401b60(esi, ebx) != 3)
0040f9d0              {
0040f9fd                  char* eax_4 = sub_401db0(esi, ebx, nullptr);
0040f9fd                  
0040fa0e                  if (!eax_4 || *(uint8_t*)eax_4 != 0x2a)
0040fa17                      sub_402ca0(esi, ebx, "invalid option");
0040fa17                  
0040fa1f                  int32_t eax_5 = (int32_t)eax_4[1];
0040fa1f                  
0040fa26                  if (eax_5 == 0x61)
0040fa26                  {
0040fa4e                      sub_40fc30(esi, arg2, 0xffffffff);
0040fa56                      i = 1;
0040fa26                  }
0040fa26                  else if (eax_5 == 0x6c)
0040fa40                      i = sub_40fb50(esi, arg2);
0040fa2b                  else
0040fa2b                  {
0040fa30                      if (eax_5 != 0x6e)
0040fa30                      {
0040fa7b                          sub_402ca0(esi, ebx, "invalid format");
0040fa87                          return 0;
0040fa30                      }
0040fa30                      
0040fa34                      i = sub_40fab0(esi, arg2);
0040fa2b                  }
0040fa2b                  
0040fa5b                  edi_2 = arg1;
0040f9d0              }
0040f9d0              else
0040f9d0              {
0040f9d4                  void* eax_3 = sub_401d30(esi, ebx);
0040f9d4                  
0040f9de                  if (eax_3)
0040f9ef                      i = sub_40fc30(esi, arg2, eax_3);
0040f9de                  else
0040f9e2                      i = sub_40fb00(esi, arg2);
0040f9d0              }
0040f9d0              
0040fa5f              ebx += 1;
0040fa60              void* ecx_2 = edi_2;
0040fa62              edi_2 -= 1;
0040fa65              arg1 = edi_2;
0040fa65              
0040fa69              if (!ecx_2)
0040fa69                  break;
0040f9c1          }
0040f970      }
0040f970      else
0040f970      {
0040f974          i = sub_40fb50(esi, arg2);
0040f980          ebx = arg3 + 1;
0040f970      }
0040f970      
0040f987      if (arg2[3] & 0x20)
0040f99e          return sub_40f590(esi, 0, 0);
0040f99e      
0040fa8a      if (!i)
0040fa8a      {
0040fa8f          sub_4018d0(esi, 0xfffffffe);
0040fa95          sub_401f80(esi);
0040fa8a      }
0040fa8a      
0040faa9      return ebx - arg3;
0040f950  }

0040faaa                                90 90 90 90 90 90                                                            ......

0040fab0    int32_t sub_40fab0(void* arg1, int32_t* arg2)

0040fab0  {
0040fabb      int32_t var_8;
0040fabb      int32_t* var_c = &var_8;
0040fabb      
0040facd      if (sub_41a915(arg2, "%lf") != 1)
0040faf4          return 0;
0040faf4      
0040fade      int32_t var_4;
0040fade      sub_401fa0(arg1, var_8, var_4);
0040faee      return 1;
0040fab0  }

0040faf5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040fb00    int32_t sub_40fb00(void* arg1, int32_t* arg2)

0040fb00  {
0040fb06      int32_t eax = arg2[1];
0040fb0a      arg2[1] = eax - 1;
0040fb0d      uint32_t edi;
0040fb0d      
0040fb0d      if (eax - 1 < 0)
0040fb25          edi = sub_41741a(arg2);
0040fb0d      else
0040fb0d      {
0040fb0f          char* eax_2 = *(uint32_t*)arg2;
0040fb13          uint32_t ecx_1;
0040fb13          (uint8_t)ecx_1 = *(uint8_t*)eax_2;
0040fb16          edi = ecx_1;
0040fb18          *(uint32_t*)arg2 = &eax_2[1];
0040fb0d      }
0040fb0d      
0040fb29      sub_4173ac(edi, arg2);
0040fb37      sub_401ff0(arg1, nullptr, nullptr);
0040fb46      int32_t result;
0040fb46      (uint8_t)result = edi != 0xffffffff;
0040fb49      return result;
0040fb00  }

0040fb4a                                90 90 90 90 90 90                                                            ......

0040fb50    int32_t sub_40fb50(void* arg1, int32_t* arg2)

0040fb50  {
0040fb67      int32_t var_20c;
0040fb67      sub_403810(arg1, &var_20c);
0040fb7d      void* esi = sub_4035f0(&var_20c);
0040fb7d      
0040fb90      if (sub_41832d(esi, 0x200, arg2))
0040fb90      {
0040fbce          char* i;
0040fbce          
0040fbce          do
0040fbce          {
0040fb92              void* edi_1 = esi;
0040fb94              int32_t j = 0xffffffff;
0040fb94              
0040fb99              while (j)
0040fb99              {
0040fb99                  bool cond:0_1 = 0 != *(uint8_t*)edi_1;
0040fb99                  edi_1 += 1;
0040fb99                  j -= 1;
0040fb99                  
0040fb99                  if (!cond:0_1)
0040fb99                      break;
0040fb99              }
0040fb99              
0040fb9b              int32_t ecx_1 = ~j;
0040fb9b              
0040fba5              if (ecx_1 != 1 && *(uint8_t*)(ecx_1 - 1 + esi - 1) == 0xa)
0040fba5              {
0040fc05                  var_20c = var_20c + ecx_1 - 1 - 1;
0040fc09                  sub_403750(&var_20c);
0040fc20                  return 1;
0040fba5              }
0040fba5              
0040fbb2              var_20c += ecx_1 - 1;
0040fbbb              esi = sub_4035f0(&var_20c);
0040fbc4              i = sub_41832d(esi, 0x200, arg2);
0040fbce          } while (i);
0040fb90      }
0040fb90      
0040fbd5      sub_403750(&var_20c);
0040fbdd      int32_t eax_3 = sub_401e30(arg1, 0xffffffff);
0040fbf7      return -((eax_3 - eax_3));
0040fb50  }

0040fc21     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040fc30    int32_t sub_40fc30(void* arg1, int32_t* arg2, uint32_t arg3)

0040fc30  {
0040fc47      int32_t var_20c;
0040fc47      sub_403810(arg1, &var_20c);
0040fc53      uint32_t edi = arg3;
0040fc5d      uint32_t esi = 0x200;
0040fc92      uint32_t eax_2;
0040fc92      
0040fc92      do
0040fc92      {
0040fc67          void* eax_1 = sub_4035f0(&var_20c);
0040fc67          
0040fc71          if (esi > edi)
0040fc73              esi = edi;
0040fc73          
0040fc7a          eax_2 = sub_416e56(eax_1, 1, esi, arg2);
0040fc88          uint32_t temp0_1 = edi;
0040fc88          edi -= eax_2;
0040fc8a          var_20c += eax_2;
0040fc8a          
0040fc8e          if (temp0_1 == eax_2)
0040fc8e              break;
0040fc92      } while (eax_2 == esi);
0040fc99      sub_403750(&var_20c);
0040fc99      
0040fca3      if (edi && sub_401e30(arg1, 0xffffffff) <= 0)
0040fcc0          return 0;
0040fcc0      
0040fcd0      return 1;
0040fc30  }

0040fcd1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

0040fce0    int32_t sub_40fce0(void* arg1)

0040fce0  {
0040fcfb      return sub_40f950(arg1, sub_40f440(arg1), 2);
0040fce0  }

0040fcfc                                                                                      90 90 90 90                              ....

0040fd00    int32_t sub_40fd00(void* arg1)

0040fd00  {
0040fd11      int32_t* edi = *(uint32_t*)sub_401ed0(arg1, 0xffffd8ed);
0040fd11      
0040fd18      if (!edi)
0040fd20          sub_402e40(arg1, "file is already closed");
0040fd20      
0040fd2a      int32_t eax_1 = sub_40fb50(arg1, edi);
0040fd2a      
0040fd38      if (edi[3] & 0x20)
0040fd38      {
0040fd40          sub_416fca(data_4307d4);
0040fd45          int32_t var_10_3 = 0x4307ac;
0040fd4c          sub_402e40(arg1, 0x42beb8);
0040fd56          return 0;
0040fd38      }
0040fd38      
0040fd59      if (eax_1)
0040fd62          return 1;
0040fd62      
0040fd73      if (sub_401d80(arg1, 0xffffd8ec))
0040fd73      {
0040fd78          sub_4018d0(arg1, 0);
0040fd83          sub_401b20(arg1, 0xffffd8ed);
0040fd89          sub_40f470(arg1);
0040fd73      }
0040fd73      
0040fd95      return 0;
0040fd00  }

0040fd96                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040fda0    int32_t sub_40fda0(void* arg1)

0040fda0  {
0040fdbd      return sub_40fdc0(arg1, sub_40f900(arg1, 2), 1);
0040fda0  }

0040fdbe                                                                                            90 90                                ..

0040fdc0    int32_t sub_40fdc0(void* arg1, int32_t* arg2, int32_t arg3)

0040fdc0  {
0040fdd8      int32_t eax_1 = sub_4018c0(arg1) - 1;
0040fdde      int32_t esi = 1;
0040fdde      
0040fde3      if (eax_1)
0040fde3      {
0040fde9          int32_t edi_1 = arg3;
0040fded          int32_t var_c_1 = eax_1;
0040fe6c          bool cond:1_1;
0040fe6c          
0040fe6c          do
0040fe6c          {
0040fdfe              if (sub_401b60(arg1, edi_1) != 3)
0040fdfe              {
0040fe31                  uint32_t var_10;
0040fe31                  char* eax_6 = sub_4030b0(arg1, edi_1, &var_10);
0040fe31                  
0040fe3b                  if (!esi)
0040fe60                      esi = 0;
0040fe3b                  else if (sub_41a92b(eax_6, 1, var_10, arg2) != var_10)
0040fe60                      esi = 0;
0040fe57                  else
0040fe59                      esi = 1;
0040fdfe              }
0040fdfe              else if (!esi)
0040fe60                  esi = 0;
0040fe02              else
0040fe02              {
0040fe0b                  void* var_28_2;
0040fe0b                  var_28_2 = (double)sub_401cf0(arg1, edi_1);
0040fe0b                  
0040fe21                  if (sub_4178b5(arg2, "%.14g") <= 0)
0040fe60                      esi = 0;
0040fe21                  else
0040fe23                      esi = 1;
0040fe02              }
0040fe02              
0040fe66              edi_1 += 1;
0040fe67              cond:1_1 = var_c_1 != 1;
0040fe68              var_c_1 -= 1;
0040fe6c          } while (cond:1_1);
0040fde3      }
0040fde3      
0040fe80      return sub_40f590(arg1, esi, 0);
0040fdc0  }

0040fe81     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040fe90    int32_t sub_40fe90(void* arg1)

0040fe90  {
0040feab      return sub_40fdc0(arg1, sub_40f440(arg1), 2);
0040fe90  }

0040feac                                      90 90 90 90                                                              ....

0040feb0    int32_t sub_40feb0(void* arg1)

0040feb0  {
0040feb8      int32_t* eax = sub_40f440(arg1);
0040fecc      int32_t eax_1 = sub_402e70(arg1, 2, 0x42bfcc, 0x428704);
0040fecc      
0040fef1      if (sub_416f3e(eax, sub_403210(arg1, 3, 0), 
0040fef1              *(uint32_t*)((eax_1 << 2) + &data_4286f8)))
0040ff03          return sub_40f590(arg1, 0, 0);
0040ff03      
0040ff0c      sub_401fd0(arg1, sub_41aa35(eax));
0040ff1c      return 1;
0040feb0  }

0040ff1d                                                                                         90 90 90                               ...

0040ff20    int32_t sub_40ff20(void* arg1)

0040ff20  {
0040ff28      int32_t* eax = sub_40f440(arg1);
0040ff39      int32_t eax_1 = sub_402e70(arg1, 2, 0, 0x428720);
0040ff48      void* eax_2 = sub_403210(arg1, 3, 0x200);
0040ff64      int32_t ecx;
0040ff64      (uint8_t)ecx =
0040ff64          !sub_41ab8d(eax, nullptr, *(uint32_t*)((eax_1 << 2) + &data_428714), eax_2);
0040ff74      return sub_40f590(arg1, ecx, 0);
0040ff20  }

0040ff75                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040ff80    int32_t sub_40ff80(void* arg1)

0040ff80  {
0040ff90      int32_t eax_1 = sub_41ac2e(sub_40f900(arg1, 2));
0040ff98      int32_t eax_2 = -(eax_1);
0040ffa8      return sub_40f590(arg1, eax_2 - eax_2 + 1, 0);
0040ff80  }

0040ffa9                             90 90 90 90 90 90 90                                                           .......

0040ffb0    int32_t sub_40ffb0(void* arg1)

0040ffb0  {
0040ffbe      int32_t eax_1 = sub_41ac2e(sub_40f440(arg1));
0040ffc6      int32_t eax_2 = -(eax_1);
0040ffd6      return sub_40f590(arg1, eax_2 - eax_2 + 1, 0);
0040ffb0  }

0040ffd7                                                                       90 90 90 90 90 90 90 90 90                         .........

0040ffe0    int32_t sub_40ffe0(void* arg1)

0040ffe0  {
0040ffe6      sub_410150(arg1);
0040fff0      sub_402330(arg1, 2, 1);
0040fffb      sub_401a70(arg1, 0xffffd8ef);
0041000b      sub_403300(arg1, "io", &data_428730);
0041001d      sub_410190(arg1, &data_42cbf0, 1, "stdin");
0041002f      sub_410190(arg1, 0x42cc10, 2, "stdout");
00410044      sub_410190(arg1, 0x42cc30, 0, "stderr");
00410051      sub_402250(arg1, 0xffffffff, "popen");
0041005b      sub_402330(arg1, 0, 1);
00410068      sub_4020e0(arg1, sub_4100c0, 0);
00410075      sub_402490(arg1, 0xfffffffe, "__close");
00410080      sub_4026a0(arg1, 0xfffffffe);
00410088      sub_4018d0(arg1, 0xfffffffe);
00410095      sub_4020e0(arg1, sub_410110, 0);
004100a5      sub_402490(arg1, 0xffffd8ef, "__close");
004100b3      return 1;
0040ffe0  }

004100b4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

004100c0    int32_t sub_4100c0(void* arg1)

004100c0  {
004100ce      int32_t* eax;
004100ce      int32_t ecx;
004100ce      int32_t edx;
004100ce      eax = sub_402f80(arg1, 1, "FILE*");
004100d5      int32_t* eax_1 = *(uint32_t*)eax;
004100e5      int32_t ecx_1;
004100e5      (uint8_t)ecx_1 = sub_41a836(eax_1, edx, ecx, eax_1) != 0xffffffff;
004100e5      
004100ec      if (ecx_1)
004100ee          *(uint32_t*)eax = 0;
004100ee      
00410102      return sub_40f590(arg1, ecx_1, 0);
004100c0  }

00410103           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00410110    int32_t sub_410110(void* arg1)

00410110  {
0041011e      int32_t* eax = sub_402f80(arg1, 1, "FILE*");
00410128      int32_t eax_2 = sub_416e00(*(uint32_t*)eax);
00410130      int32_t eax_3 = -(eax_2);
00410132      int32_t eax_4 = eax_3 - eax_3;
00410132      
00410135      if (eax_4 != 0xffffffff)
00410137          *(uint32_t*)eax = 0;
00410137      
0041014b      return sub_40f590(arg1, eax_4 + 1, 0);
00410110  }

0041014c                                      90 90 90 90                                                              ....

00410150    void* sub_410150(void* arg1)

00410150  {
0041015b      sub_402f20(arg1, "FILE*");
00410163      sub_401b20(arg1, 0xffffffff);
00410170      sub_402490(arg1, 0xfffffffe, "__index");
00410186      return sub_403300(arg1, nullptr, &data_428790);
00410150  }

00410187                       90 90 90 90 90 90 90 90 90                                                         .........

00410190    int32_t sub_410190(void* arg1, int32_t arg2, int32_t arg3, char* arg4)

00410190  {
004101a7      *(uint32_t*)sub_40f620(arg1) = arg2;
004101a7      
004101ab      if (arg3 > 0)
004101ab      {
004101b0          sub_401b20(arg1, 0xffffffff);
004101bc          sub_402570(arg1, 0xffffd8ef, arg3);
004101ab      }
004101ab      
004101d6      return sub_402490(arg1, 0xfffffffe, arg4);
00410190  }

004101d7                                                                       90 90 90 90 90 90 90 90 90                         .........

004101e0    int32_t sub_4101e0(void* arg1)

004101e0  {
004101ec      sub_403020(arg1, 1, 5);
004101f4      int32_t eax = sub_401e30(arg1, 1);
00410200      sub_403020(arg1, 2, 6);
00410205      int32_t edi = 1;
00410205      
0041020f      if (eax >= 1)
0041020f      {
00410250          do
00410250          {
00410214              sub_401b20(arg1, 2);
0041021b              sub_401fd0(arg1, edi);
00410224              sub_4022f0(arg1, 1, edi);
0041022e              sub_402730(arg1, 2, 1);
0041022e              
00410240              if (sub_401b60(arg1, 0xffffffff))
00410260                  return 1;
00410260              
00410245              sub_4018d0(arg1, 0xfffffffe);
0041024d              edi += 1;
00410250          } while (edi <= eax);
0041020f      }
0041020f      
00410257      return 0;
004101e0  }

00410261     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00410270    int32_t sub_410270(void* arg1)

00410270  {
0041027a      sub_403020(arg1, 1, 5);
00410284      sub_403020(arg1, 2, 6);
0041028a      sub_401f80(arg1);
0041028a      
0041029c      if (sub_402a40(arg1, 1))
0041029c      {
004102e4          int32_t i;
004102e4          
004102e4          do
004102e4          {
004102a1              sub_401b20(arg1, 2);
004102a9              sub_401b20(arg1, 0xfffffffd);
004102b1              sub_401b20(arg1, 0xfffffffd);
004102bb              sub_402730(arg1, 2, 1);
004102bb              
004102cd              if (sub_401b60(arg1, 0xffffffff))
004102f0                  return 1;
004102f0              
004102d2              sub_4018d0(arg1, 0xfffffffd);
004102da              i = sub_402a40(arg1, 1);
004102e4          } while (i);
0041029c      }
0041029c      
004102e9      return 0;
00410270  }

004102f1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00410300    void sub_410300(void* arg1)

00410300  {
00410312      int32_t var_10 = 0;
00410322      sub_403020(arg1, 1, 5);
00410328      sub_401f80(arg1);
00410328      
0041033a      if (sub_402a40(arg1, 1))
0041033a      {
0041037f          int32_t i;
0041037f          
0041037f          do
0041037f          {
0041033f              sub_4018d0(arg1, 0xfffffffe);
0041033f              
00410352              if (sub_401b60(arg1, 0xffffffff) == 3)
00410352              {
00410357                  long double st0_1 = sub_401cf0(arg1, 0xffffffff);
0041035c                  long double temp0_1 = (long double)0.0;
0041035c                  st0_1 - temp0_1;
0041035c                  
00410368                  if (!(*(uint8_t*)((char*)((st0_1 < temp0_1 ? 1 : 0) << 8
00410368                          | (FCMP_UO(st0_1, temp0_1) ? 1 : 0) << 0xa
00410368                          | (st0_1 == temp0_1 ? 1 : 0) << 0xe | 0x3800))[1] & 0x41))
0041036a                      var_10 = (double)st0_1;
00410352              }
00410352              
00410375              i = sub_402a40(arg1, 1);
0041037f          } while (i);
0041033a      }
0041033a      
0041038c      sub_401fa0(arg1, 0, 0);
00410300  }

0041039e                                                                                            90 90                                ..

004103a0    int32_t sub_4103a0(void* arg1)

004103a0  {
004103aa      sub_403020(arg1, 1, 5);
004103b9      sub_401fd0(arg1, sub_401e30(arg1, 1));
004103c7      return 1;
004103a0  }

004103c8                          90 90 90 90 90 90 90 90                                                          ........

004103d0    int32_t sub_4103d0(void* arg1)

004103d0  {
004103da      sub_403020(arg1, 1, 5);
004103e5      sub_402e40(arg1, "'setn' is obsolete");
004103ed      sub_401b20(arg1, 1);
004103fb      return 1;
004103d0  }

004103fc                                                                                      90 90 90 90                              ....

00410400    int32_t sub_410400(void* arg1)

00410400  {
0041040c      sub_403020(arg1, 1, 5);
0041041c      void* esi_1 = sub_401e30(arg1, 1) + 1;
0041041d      int32_t eax_1 = sub_4018c0(arg1);
00410428      void* ebp;
00410428      
00410428      if (eax_1 == 2)
00410488          ebp = esi_1;
00410428      else
00410428      {
0041042b          if (eax_1 != 3)
0041042b          {
00410433              sub_402e40(arg1, "wrong number of arguments to 'insert'");
0041043e              return 0;
0041042b          }
0041042b          
00410447          ebp = sub_4031d0(arg1, 2);
0041044c          bool cond:0_1 = esi_1 <= ebp;
0041044c          
0041044e          if (esi_1 < ebp)
0041044e          {
00410450              esi_1 = ebp;
00410452              cond:0_1 = esi_1 <= ebp;
0041044e          }
0041044e          
00410454          if (!cond:0_1)
00410454          {
00410473              do
00410473              {
0041045e                  sub_4022f0(arg1, 1, (char*)esi_1 - 1);
00410467                  sub_402570(arg1, 1, esi_1);
0041046c                  esi_1 -= 1;
00410473              } while (esi_1 > ebp);
00410473              
0041047a              sub_402570(arg1, 1, ebp);
00410487              return 0;
00410454          }
00410428      }
00410428      
0041048e      sub_402570(arg1, 1, ebp);
0041049b      return 0;
00410400  }

0041049c                                                                                      90 90 90 90                              ....

004104a0    int32_t sub_4104a0(void* arg1)

004104a0  {
004104ac      sub_403020(arg1, 1, 5);
004104b4      int32_t eax = sub_401e30(arg1, 1);
004104c7      void* esi = sub_403210(arg1, 2, eax);
004104c7      
004104cb      if (!eax)
004104d2          return 0;
004104d2      
004104d7      sub_4022f0(arg1, 1, esi);
004104d7      
004104e1      if (esi < eax)
004104e1      {
004104e4          void* ebp_1 = (char*)esi + 1;
004104e4          
00410500          do
00410500          {
004104eb              sub_4022f0(arg1, 1, ebp_1);
004104f4              sub_402570(arg1, 1, esi);
004104fc              esi += 1;
004104fd              ebp_1 += 1;
00410500          } while (esi < eax);
004104e1      }
004104e1      
00410504      sub_401f80(arg1);
0041050d      sub_402570(arg1, 1, eax);
0041051d      return 1;
004104a0  }

0041051e                                                                                            90 90                                ..

00410520    int32_t sub_410520(void* arg1)

00410520  {
0041053e      int32_t var_210;
0041053e      char* eax = sub_4030f0(arg1, 2, &data_4307a0, &var_210);
0041054a      sub_403020(arg1, 1, 5);
0041055c      void* i = sub_403210(arg1, 3, 1);
00410568      int32_t eax_3;
00410568      
00410568      if (sub_401b60(arg1, 4) > 0)
00410577          eax_3 = sub_4031d0(arg1, 4);
00410568      else
0041056d          eax_3 = sub_401e30(arg1, 1);
0041056d      
00410587      int32_t var_20c[0x83];
00410587      sub_403810(arg1, &var_20c);
00410587      
00410591      for (; i <= eax_3; i += 1)
00410591      {
00410597          sub_4022f0(arg1, 1, i);
00410597          
004105a9          if (!sub_401c20(arg1, 0xffffffff))
004105b3              sub_402ca0(arg1, 1, "table contains non-strings");
004105b3          
004105c0          sub_403780(&var_20c);
004105c0          
004105ca          if (i != eax_3)
004105d7              sub_4036d0(&var_20c, eax, var_210);
00410591      }
00410591      
004105e9      sub_403750(&var_20c);
00410600      return 1;
00410520  }

00410601     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00410610    int32_t sub_410610(void* arg1)

00410610  {
0041061b      sub_403020(arg1, 1, 5);
00410623      int32_t eax = sub_401e30(arg1, 1);
00410632      sub_402ff0(arg1, 0x28, &data_4307a0);
00410632      
00410644      if (sub_401b60(arg1, 2) > 0)
0041064b          sub_403020(arg1, 2, 6);
0041064b      
00410656      sub_4018d0(arg1, 2);
0041065f      sub_410670(arg1, 1, eax);
0041066b      return 0;
00410610  }

0041066c                                      90 90 90 90                                                              ....

00410670    void sub_410670(void* arg1, int32_t arg2, int32_t arg3)

00410670  {
00410671      int32_t ebx = arg2;
00410676      int32_t ebp = arg3;
00410676      
0041067e      if (ebx >= ebp)
0041067e          return;
0041067e      
00410692      while (true)
00410692      {
00410692          sub_4022f0(arg1, 1, ebx);
0041069b          sub_4022f0(arg1, 1, ebp);
0041069b          
004106af          if (!sub_4108e0(arg1, 0xffffffff, 0xfffffffe))
004106c1              sub_4018d0(arg1, 0xfffffffd);
004106af          else
004106b4              sub_4108b0(arg1, ebx, ebp);
004106b4          
004106cb          int32_t eax = ebp - ebx;
004106cb          
004106d4          if (eax == 1)
004106d4              break;
004106d4          
004106dd          int32_t eax_4;
004106dd          int32_t edx_1;
004106dd          edx_1 = HIGHD((int64_t)(ebx + ebp));
004106dd          eax_4 = LOWD((int64_t)(ebx + ebp));
004106e2          int32_t edi_2 = (eax_4 - edx_1) >> 1;
004106e8          sub_4022f0(arg1, 1, edi_2);
004106f1          sub_4022f0(arg1, 1, ebx);
004106f1          
00410705          if (!sub_4108e0(arg1, 0xfffffffe, 0xffffffff))
00410705          {
00410717              sub_4018d0(arg1, 0xfffffffe);
00410720              sub_4022f0(arg1, 1, ebp);
00410720              
00410734              if (!sub_4108e0(arg1, 0xffffffff, 0xfffffffe))
00410746                  sub_4018d0(arg1, 0xfffffffd);
00410734              else
00410739                  sub_4108b0(arg1, edi_2, ebp);
00410705          }
00410705          else
0041070a              sub_4108b0(arg1, edi_2, ebx);
0041070a          
00410753          if (eax == 2)
00410753              break;
00410753          
0041075d          sub_4022f0(arg1, 1, edi_2);
00410765          sub_401b20(arg1, 0xffffffff);
0041076a          int32_t ebx_1 = ebp - 1;
00410771          sub_4022f0(arg1, 1, ebx_1);
00410779          sub_4108b0(arg1, edi_2, ebx_1);
0041077e          int32_t edi_3 = arg2;
0041077e          
00410785          while (true)
00410785          {
00410785              edi_3 += 1;
0041078a              sub_4022f0(arg1, 1, edi_3);
0041078a              
0041079e              if (sub_4108e0(arg1, 0xffffffff, 0xfffffffe))
0041079e              {
004107d3                  int32_t i;
004107d3                  
004107d3                  do
004107d3                  {
004107a2                      if (edi_3 > ebp)
004107aa                          sub_402e40(arg1, "invalid order function for sorting");
004107aa                      
004107b5                      sub_4018d0(arg1, 0xfffffffe);
004107ba                      edi_3 += 1;
004107bf                      sub_4022f0(arg1, 1, edi_3);
004107c9                      i = sub_4108e0(arg1, 0xffffffff, 0xfffffffe);
004107d3                  } while (i);
0041079e              }
0041079e              
004107d5              ebx_1 -= 1;
004107da              sub_4022f0(arg1, 1, ebx_1);
004107da              
004107ee              if (sub_4108e0(arg1, 0xfffffffd, 0xffffffff))
004107ee              {
00410825                  int32_t i_1;
00410825                  
00410825                  do
00410825                  {
004107f4                      if (ebx_1 < arg2)
004107fc                          sub_402e40(arg1, "invalid order function for sorting");
004107fc                      
00410807                      sub_4018d0(arg1, 0xfffffffe);
0041080c                      ebx_1 -= 1;
00410811                      sub_4022f0(arg1, 1, ebx_1);
0041081b                      i_1 = sub_4108e0(arg1, 0xfffffffd, 0xffffffff);
00410825                  } while (i_1);
004107ee              }
004107ee              
00410829              if (ebx_1 < edi_3)
00410829                  break;
00410829              
0041082e              sub_4108b0(arg1, edi_3, ebx_1);
00410785          }
00410785          
0041083e          sub_4018d0(arg1, 0xfffffffc);
0041084a          sub_4022f0(arg1, 1, ebp - 1);
00410853          sub_4022f0(arg1, 1, edi_3);
0041085b          sub_4108b0(arg1, ebp - 1, edi_3);
00410860          int32_t ebx_3 = arg2;
00410871          int32_t eax_12;
00410871          int32_t edi_4;
00410871          
00410871          if (edi_3 - ebx_3 >= ebp - edi_3)
00410871          {
00410881              eax_12 = edi_3 + 1;
00410884              edi_4 = ebp;
00410886              ebp = eax_12 - 2;
00410871          }
00410871          else
00410871          {
00410873              edi_4 = edi_3 - 1;
00410874              eax_12 = ebx_3;
00410879              arg2 = edi_4 + 2;
0041087d              ebx_3 = edi_4 + 2;
00410871          }
00410871          
0041088c          sub_410670(arg1, eax_12, edi_4);
0041088c          
00410896          if (ebx_3 >= ebp)
00410896              break;
00410896          
0041068a          ebx = arg2;
00410692      }
00410670  }

004108a1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

004108b0    int32_t sub_4108b0(void* arg1, int32_t arg2, int32_t arg3)

004108b0  {
004108bd      sub_402570(arg1, 1, arg2);
004108d3      return sub_402570(arg1, 1, arg3);
004108b0  }

004108d4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

004108e0    int32_t sub_4108e0(void* arg1, int32_t arg2, int32_t arg3)

004108e0  {
004108f2      if (!sub_401b60(arg1, 2))
0041094f          return sub_401ca0(arg1, arg2, arg3);
0041094f      
004108f8      sub_401b20(arg1, 2);
00410904      sub_401b20(arg1, arg2 - 1);
00410912      sub_401b20(arg1, arg3 - 2);
0041091c      sub_402730(arg1, 2, 1);
00410924      int32_t result = sub_401d80(arg1, 0xffffffff);
0041092e      sub_4018d0(arg1, 0xfffffffe);
0041093a      return result;
004108e0  }


00410950    int32_t sub_410950(void* arg1)

00410950  {
0041095f      sub_403300(arg1, "table", &data_4287e0);
0041096c      return 1;
00410950  }

0041096d                                         90 90 90                                                               ...

00410970    int32_t sub_410970(void* arg1)

00410970  {
0041098f      int32_t eax_2 =
0041098f          sub_4109e0(arg1, sub_4030b0(arg1, 1, nullptr), sub_4030b0(arg1, 2, nullptr));
0041098f      
0041099b      if (!eax_2)
004109a4          return 1;
004109a4      
004109a6      sub_401f80(arg1);
004109ae      sub_401a20(arg1, 0xfffffffe);
004109b9      char* eax_4 = "open";
004109b9      
004109be      if (eax_2 != 1)
004109c0          eax_4 = "init";
004109c0      
004109c7      sub_402040(arg1, eax_4);
004109d6      return 3;
00410970  }

004109d7                                                                       90 90 90 90 90 90 90 90 90                         .........

004109e0    int32_t sub_4109e0(void* arg1, PSTR arg2, PSTR arg3)

004109e0  {
004109ed      void* eax = sub_410b20(arg1, arg2);
004109ed      
004109fa      if (!*(uint32_t*)eax)
00410a06          *(uint32_t*)eax = sub_410a50(arg1, arg2);
00410a06      
00410a08      HMODULE esi_1 = *(uint32_t*)eax;
00410a08      
00410a0c      if (!esi_1)
00410a16          return 1;
00410a16      
00410a1e      int32_t eax_4 = sub_410af0(arg1, esi_1, arg3);
00410a1e      
00410a28      if (!eax_4)
00410a32          return 2;
00410a32      
00410a37      sub_4020e0(arg1, eax_4, 0);
00410a44      return 0;
004109e0  }

00410a45                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00410a50    HMODULE sub_410a50(void* arg1, PSTR arg2)

00410a50  {
00410a56      HMODULE result = LoadLibraryA(arg2);
00410a56      
00410a60      if (!result)
00410a67          sub_410a80(arg1);
00410a67      
00410a72      return result;
00410a50  }

00410a73                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00410a80    void* sub_410a80(void* arg1)

00410a80  {
00410a87      enum WIN32_ERROR dwMessageId = GetLastError();
00410aad      void buffer;
00410aad      
00410aad      if (FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
00410aad              nullptr, dwMessageId, 0, &buffer, 0x80, nullptr))
00410acb          return sub_402040(arg1, &buffer);
00410acb      
00410ad3      enum WIN32_ERROR dwMessageId_1 = dwMessageId;
00410ae9      return sub_4020b0(arg1, "system error %d\n");
00410a80  }

00410aea                                90 90 90 90 90 90                                                            ......

00410af0    int32_t sub_410af0(void* arg1, HMODULE arg2, PSTR arg3)

00410af0  {
00410afb      int32_t result = GetProcAddress(arg2, arg3);
00410afb      
00410b05      if (!result)
00410b0c          sub_410a80(arg1);
00410b0c      
00410b17      return result;
00410af0  }

00410b18                                                                          90 90 90 90 90 90 90 90                          ........

00410b20    void* sub_410b20(void* arg1, int32_t arg2)

00410b20  {
00410b2a      int32_t __saved_edi = arg2;
00410b2b      char* var_10 = "LOADLIB: ";
00410b36      sub_4020b0(arg1, "%s%s");
00410b41      sub_402220(arg1, 0xffffd8f0);
00410b41      
00410b53      if (sub_401b60(arg1, 0xffffffff))
00410b62          return sub_401ed0(arg1, 0xffffffff);
00410b62      
00410b67      sub_4018d0(arg1, 0xfffffffe);
00410b6f      void* result = sub_402b10(arg1, 4);
00410b81      *(uint32_t*)result = 0;
00410b87      sub_402250(arg1, 0xffffd8f0, "_LOADLIB");
00410b8f      sub_4025e0(arg1, 0xfffffffe);
00410b94      int32_t var_34 = arg2;
00410b95      char* var_38 = "LOADLIB: ";
00410ba0      sub_4020b0(arg1, "%s%s");
00410ba8      sub_401b20(arg1, 0xfffffffe);
00410bb3      sub_402460(arg1, 0xffffd8f0);
00410bc0      return result;
00410b20  }

00410bc1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00410bd0    int32_t sub_410bd0(void* arg1)

00410bd0  {
00410be7      PSTR eax_1 = sub_410c20(arg1, sub_4030b0(arg1, 1, nullptr), "path");
00410be7      
00410bf3      if (eax_1 && sub_403830(arg1, eax_1))
00410c05          sub_410d80(arg1, eax_1);
00410c05      
00410c14      return 1;
00410bd0  }

00410c15                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00410c20    PSTR sub_410c20(void* arg1, void* arg2, char* arg3)

00410c20  {
00410c38      char* eax = sub_403450(arg1, arg2, &data_42b48c, U"\;");
00410c4a      sub_402250(arg1, 0xffffd8ef, arg3);
00410c54      char* eax_1 = sub_401db0(arg1, 0xffffffff, nullptr);
00410c54      
00410c60      if (!eax_1)
00410c60      {
00410c62          char* var_14_1 = arg3;
00410c69          sub_402e40(arg1, "'package.%s' must be a string");
00410c60      }
00410c60      
00410c77      sub_402040(arg1, &data_4307a0);
00410c77      
00410c8a      for (void* i = sub_410d20(arg1, eax_1); i; i = sub_410d20(arg1, i))
00410c8a      {
00410ca1          PSTR result =
00410ca1              sub_403450(arg1, sub_401db0(arg1, 0xffffffff, nullptr), &data_42b128, eax);
00410ca1          
00410cb3          if (sub_410cf0(result))
00410cee              return result;
00410cee          
00410cb8          sub_4018d0(arg1, 0xfffffffd);
00410cbd          PSTR result_1 = result;
00410cc4          sub_4087a0(arg1, "\n\tno file '%s'");
00410ccc          sub_402a80(arg1, 2);
00410c8a      }
00410c8a      
00410ce7      return 0;
00410c20  }

00410cef                                               90                                                                 .

00410cf0    int32_t* sub_410cf0(PSTR arg1)

00410cf0  {
00410cfa      int32_t* result = sub_417118(arg1, U"r");
00410cfa      
00410d04      if (!result)
00410d06          return result;
00410d06      
00410d08      sub_416e00(result);
00410d15      return 1;
00410cf0  }

00410d16                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00410d20    void* sub_410d20(void* arg1, char* arg2)

00410d20  {
00410d20      char eax = data_42c214;
00410d26      char* esi = arg2;
00410d26      
00410d2c      if (*(uint8_t*)esi == eax)
00410d2c      {
00410d34          char ecx;
00410d34          
00410d34          do
00410d34          {
00410d2e              ecx = esi[1];
00410d31              esi = &esi[1];
00410d34          } while (ecx == eax);
00410d2c      }
00410d2c      
00410d39      if (!*(uint8_t*)esi)
00410d3e          return 0;
00410d3e      
00410d45      void* result_1 = sub_4172f0(esi, eax);
00410d4a      void* result = result_1;
00410d4a      
00410d51      if (!result)
00410d51      {
00410d53          char* edi = esi;
00410d55          int32_t i = 0xffffffff;
00410d55          
00410d58          while (i)
00410d58          {
00410d58              bool cond:0_1 = (uint8_t)result_1 != *(uint8_t*)edi;
00410d58              edi = &edi[1];
00410d58              i -= 1;
00410d58              
00410d58              if (!cond:0_1)
00410d58                  break;
00410d58          }
00410d58          
00410d5f          result = ~i - 1 + esi;
00410d51      }
00410d51      
00410d6c      sub_401ff0(arg1, esi, (char*)result - esi);
00410d78      return result;
00410d20  }

00410d79                                                                             90 90 90 90 90 90 90                           .......

00410d80    int32_t sub_410d80(void* arg1, int32_t arg2)

00410d80  {
00410d92      int32_t var_8 = sub_401db0(arg1, 0xffffffff, nullptr);
00410d97      int32_t var_c = arg2;
00410da5      int32_t var_10_1 = sub_401db0(arg1, 1, nullptr);
00410dac      sub_402e40(arg1, "error loading module '%s' from file '%s':\n\t%s");
00410db5      return 0;
00410d80  }

00410db6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00410dc0    int32_t sub_410dc0(void* arg1)

00410dc0  {
00410dcc      void* eax = sub_4030b0(arg1, 1, nullptr);
00410dda      PSTR eax_1 = sub_410c20(arg1, eax, "cpath");
00410dda      
00410de6      if (eax_1 && sub_4109e0(arg1, eax_1, sub_410e20(arg1, eax)))
00410e00          sub_410d80(arg1, eax_1);
00410e00      
00410e10      return 1;
00410dc0  }

00410e11                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00410e20    int32_t sub_410e20(void* arg1, void* arg2)

00410e20  {
00410e28      void* esi = arg2;
00410e2f      void* eax = sub_4172f0(esi, data_42c260);
00410e2f      
00410e39      if (eax)
00410e3b          esi = (char*)eax + 1;
00410e3b      
00410e53      int32_t var_1c = sub_403450(arg1, esi, &data_42b48c, U"_-");
00410e5a      int32_t result = sub_4020b0(arg1, "luaopen_%s");
00410e64      sub_401920(arg1, 0xfffffffe);
00410e70      return result;
00410e20  }

00410e71                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00410e80    void* sub_410e80(void* arg1)

00410e80  {
00410e8c      char* eax = sub_4030b0(arg1, 1, nullptr);
00410e96      void* result = sub_4172f0(eax, 0x2e);
00410e96      
00410ea0      if (!result)
00410ea5          return result;
00410ea5      
00410eab      sub_401ff0(arg1, eax, (char*)result - eax);
00410ec7      PSTR eax_3 = sub_410c20(arg1, sub_401db0(arg1, 0xffffffff, nullptr), "cpath");
00410ec7      
00410ed3      if (eax_3)
00410ed3      {
00410edf          int32_t eax_5 = sub_4109e0(arg1, eax_3, sub_410e20(arg1, eax));
00410edf          
00410ee9          if (eax_5)
00410ee9          {
00410eee              if (eax_5 != 2)
00410ef2                  sub_410d80(arg1, eax_3);
00410ef2              
00410efa              PSTR var_10_3 = eax_3;
00410efb              char* var_14_4 = eax;
00410f02              sub_4087a0(arg1, "\n\tno module '%s' in file '%s'");
00410ee9          }
00410ed3      }
00410ed3      
00410f12      return 1;
00410e80  }

00410f13                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00410f20    int32_t sub_410f20(void* arg1)

00410f20  {
00410f2b      char* eax = sub_4030b0(arg1, 1, nullptr);
00410f3d      sub_402250(arg1, 0xffffd8ef, "preload");
00410f3d      
00410f50      if (sub_401b60(arg1, 0xffffffff) != 5)
00410f58          sub_402e40(arg1, "'package.preload' must be a table");
00410f58      
00410f64      sub_402250(arg1, 0xffffffff, eax);
00410f64      
00410f76      if (!sub_401b60(arg1, 0xffffffff))
00410f76      {
00410f78          char* var_c_1 = eax;
00410f7f          sub_4087a0(arg1, "\n\tno field package.preload['%s']");
00410f76      }
00410f76      
00410f8e      return 1;
00410f20  }

00410f8f                                               90                                                                 .

00410f90    int32_t sub_410f90(void* arg1)

00410f90  {
00410f9b      char* __saved_ebx_4 = sub_4030b0(arg1, 1, nullptr);
00410fa5      sub_4018d0(arg1, 1);
00410fb5      sub_402250(arg1, 0xffffd8f0, "_LOADED");
00410fbe      sub_402250(arg1, 2, __saved_ebx_4);
00410fbe      
00410fd0      if (!sub_401d80(arg1, 0xffffffff))
00410fd0      {
0041100a          sub_402250(arg1, 0xffffd8ef, "loaders");
0041100a          
0041101d          if (sub_401b60(arg1, 0xffffffff) != 5)
00411025              sub_402e40(arg1, "'package.loaders' must be a table");
00411025          
00411034          sub_402040(arg1, &data_4307a0);
0041103c          int32_t ebx_1 = 1;
0041103c          
00411045          while (true)
00411045          {
00411045              sub_4022f0(arg1, 0xfffffffe, ebx_1);
0041104d              int32_t* eax_4 = sub_401b60(arg1, 0xffffffff);
0041104d              
00411057              if (!eax_4)
00411057              {
00411062                  int32_t var_1c_2 = sub_401db0(arg1, 0xfffffffe, eax_4);
00411063                  char* __saved_ebx_5 = __saved_ebx_4;
0041106a                  sub_402e40(arg1, "module '%s' not found:%s");
00411057              }
00411057              
00411074              sub_402040(arg1, __saved_ebx_4);
0041107e              sub_402730(arg1, 1, 1);
0041107e              
00411091              if (sub_401b60(arg1, 0xffffffff) == 6)
00411091                  break;
00411091              
004110a0              if (!sub_401c20(arg1, 0xffffffff))
004110a0              {
004110b3                  sub_4018d0(arg1, 0xfffffffe);
004110bb                  ebx_1 += 1;
004110a0              }
004110a0              else
004110a0              {
004110a5                  sub_402a80(arg1, 2);
004110ad                  ebx_1 += 1;
004110a0              }
00411045          }
00411045          
004110c4          sub_4021d0(arg1, 0x428830);
004110cd          sub_402490(arg1, 2, __saved_ebx_4);
004110d4          sub_402040(arg1, __saved_ebx_4);
004110de          sub_402730(arg1, 1, 1);
004110de          
004110f1          if (sub_401b60(arg1, 0xffffffff))
004110f7              sub_402490(arg1, 2, __saved_ebx_4);
004110f7          
00411103          sub_402250(arg1, 2, __saved_ebx_4);
00411103          
00411118          if (sub_401ed0(arg1, 0xffffffff) == 0x428830)
00411118          {
0041111d              sub_4021a0(arg1, 1);
00411125              sub_401b20(arg1, 0xffffffff);
0041112e              sub_402490(arg1, 2, __saved_ebx_4);
00411118          }
00410fd0      }
00410fd0      else if (sub_401ed0(arg1, 0xffffffff) == 0x428830)
00410fe2      {
00410fe8          char* __saved_ebx_1 = __saved_ebx_4;
00410fef          sub_402e40(arg1, "loop or previous error loading module '%s'");
00410fe2      }
00410fe2      
0041113d      return 1;
00410f90  }

0041113e                                                                                            90 90                                ..

00411140    int32_t sub_411140(void* arg1)

00411140  {
0041114c      char* eax = sub_4030b0(arg1, 1, nullptr);
00411166      int32_t edi_1 = sub_4018c0(arg1) + 1;
00411167      sub_402250(arg1, 0xffffd8f0, "_LOADED");
0041116f      sub_402250(arg1, edi_1, eax);
0041116f      
00411182      if (sub_401b60(arg1, 0xffffffff) != 5)
00411182      {
00411187          sub_4018d0(arg1, 0xfffffffe);
00411187          
0041119f          if (sub_403510(arg1, 0xffffd8ee, eax, 1))
0041119f          {
004111a1              char* var_10 = eax;
004111a8              sub_402e40(arg1, "name conflict for module '%s'");
004111b3              return 0;
0041119f          }
0041119f          
004111b7          sub_401b20(arg1, 0xffffffff);
004111bf          sub_402490(arg1, edi_1, eax);
00411182      }
00411182      
004111cf      sub_402250(arg1, 0xffffffff, "_NAME");
004111cf      
004111e4      if (!sub_401b60(arg1, 0xffffffff))
004111e4      {
004111f0          sub_4018d0(arg1, 0xfffffffe);
004111f7          sub_4112b0(arg1, eax);
004111e4      }
004111e4      else
004111e6          sub_4018d0(arg1, 0xfffffffe);
004111e6      
00411202      sub_401b20(arg1, 0xffffffff);
00411208      sub_411220(arg1);
00411210      sub_411270(arg1, edi_1 - 1);
0041121d      return 0;
00411140  }

0041121e                                                                                            90 90                                ..

00411220    void* sub_411220(void* arg1)

00411220  {
00411230      void var_64;
00411230      sub_40ac30(arg1, 1, &var_64);
00411240      sub_40ae20(arg1, U"f", &var_64);
00411248      sub_401b20(arg1, 0xfffffffe);
00411250      sub_4026a0(arg1, 0xfffffffe);
00411264      return sub_4018d0(arg1, 0xfffffffe);
00411220  }

00411265                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00411270    void sub_411270(void* arg1, int32_t arg2)

00411270  {
00411276      int32_t esi = 2;
00411276      
0041127d      if (arg2 < 2)
0041127d          return;
0041127d      
004112a3      do
004112a3      {
00411286          sub_401b20(arg1, esi);
0041128e          sub_401b20(arg1, 0xfffffffe);
00411298          sub_402730(arg1, 1, 0);
004112a0          esi += 1;
004112a3      } while (esi <= arg2);
00411270  }

004112a9                             90 90 90 90 90 90 90                                                           .......

004112b0    int32_t sub_4112b0(void* arg1, char* arg2)

004112b0  {
004112b9      sub_401b20(arg1, 0xffffffff);
004112c6      sub_402490(arg1, 0xfffffffe, "_M");
004112d1      sub_402040(arg1, arg2);
004112de      sub_402490(arg1, 0xfffffffe, "_NAME");
004112e6      char* eax = sub_41ad40(arg2, 0x2e);
004112f0      void* eax_1;
004112f0      
004112f0      if (eax)
004112f6          eax_1 = &eax[1];
004112f0      else
004112f2          eax_1 = arg2;
004112f2      
004112fc      sub_401ff0(arg1, arg2, (char*)eax_1 - arg2);
00411313      return sub_402490(arg1, 0xfffffffe, "_PACKAGE");
004112b0  }

00411314                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00411320    int32_t sub_411320(void* arg1)

00411320  {
0041132a      sub_403020(arg1, 1, 5);
00411332      int32_t eax = sub_402380(arg1, 1);
00411332      
0041133c      if (!eax)
0041133c      {
00411342          sub_402330(arg1, eax, 1);
0041134a          sub_401b20(arg1, 0xffffffff);
00411352          sub_4025e0(arg1, 1);
0041133c      }
0041133c      
00411360      sub_401b20(arg1, 0xffffd8ee);
0041136d      sub_402490(arg1, 0xfffffffe, "__index");
00411378      return 0;
00411320  }

00411379                                                                             90 90 90 90 90 90 90                           .......

00411380    int32_t sub_411380(void* arg1)

00411380  {
0041138b      sub_402f20(arg1, "_LOADLIB");
00411398      sub_4020e0(arg1, sub_4114d0, 0);
004113a5      sub_402490(arg1, 0xfffffffe, "__gc");
004113b5      sub_403300(arg1, "package", &data_428838);
004113bd      sub_401b20(arg1, 0xffffffff);
004113c8      sub_401a70(arg1, 0xffffd8ef);
004113d2      sub_402330(arg1, 0, 4);
004113d7      int32_t (* i)(void* arg1) = sub_410f20;
004113e5      int32_t edi_1 = 1;
004113ea      void** const ebx_1 = &data_428868;
004113ea      
0041140d      do
0041140d      {
004113f3          sub_4020e0(arg1, i, 0);
004113fc          sub_402570(arg1, 0xfffffffe, edi_1);
00411401          i = ebx_1[1];
00411404          ebx_1 = &ebx_1[1];
0041140a          edi_1 += 1;
0041140d      } while (i);
0041140d      
00411419      sub_402490(arg1, 0xfffffffe, "loaders");
0041142e      sub_411510(arg1, "path", "LUA_PATH", 
0041142e          ".\?.lua;!\lua\?.lua;!\lua\?\init.lua;!\?.lua;!\?\init.lua");
00411443      sub_411510(arg1, "cpath", "LUA_CPATH", ".\?.dll;!\?.dll;!\loadall.dll");
0041144e      sub_402040(arg1, "\\n;\n?\n!\n-");
0041145b      sub_402490(arg1, 0xfffffffe, "config");
00411470      sub_403510(arg1, 0xffffd8f0, "_LOADED", 2);
0041147d      sub_402490(arg1, 0xfffffffe, "loaded");
00411487      sub_402330(arg1, 0, 0);
00411494      sub_402490(arg1, 0xfffffffe, "preload");
0041149f      sub_401b20(arg1, 0xffffd8ee);
004114ac      sub_403300(arg1, nullptr, &data_428850);
004114b7      sub_4018d0(arg1, 0xfffffffe);
004114c5      return 1;
00411380  }

004114c6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

004114d0    int32_t sub_4114d0(void* arg1)

004114d0  {
004114dd      int32_t* eax = sub_402f80(arg1, 1, "_LOADLIB");
004114e7      HMODULE eax_1 = *(uint32_t*)eax;
004114e7      
004114eb      if (eax_1)
004114ee          sub_411500(eax_1);
004114ee      
004114f6      *(uint32_t*)eax = 0;
004114ff      return 0;
004114d0  }


00411500    BOOL sub_411500(HMODULE arg1)

00411500  {
0041150b      return FreeLibrary(arg1);
00411500  }

0041150c                                      90 90 90 90                                                              ....

00411510    int32_t sub_411510(void* arg1, char* arg2, uint8_t* arg3, char* arg4)

00411510  {
00411516      void* eax = sub_418fca(arg3);
00411520      void* esi;
00411520      
00411520      if (eax)
00411520      {
00411536          esi = arg1;
00411557          sub_403450(esi, sub_403450(esi, eax, 0x42c3f8, 0x42c3fc), 0x42c3f4, arg4);
0041155f          sub_401920(esi, 0xfffffffe);
00411520      }
00411520      else
00411520      {
00411526          esi = arg1;
0041152c          sub_402040(esi, arg4);
00411520      }
00411520      
00411568      sub_411580(esi);
0041157e      return sub_402490(esi, 0xfffffffe, arg2);
00411510  }

0041157f                                                                                               90                                 .

00411580    int32_t sub_411580(void* arg1)

00411580  {
00411592      void filename;
00411592      uint32_t eax = GetModuleFileNameA(nullptr, &filename, 0x105);
00411592      
004115a1      if (eax && eax != 0x105)
004115a1      {
004115aa          char* eax_1 = sub_41ad40(&filename, 0x5c);
004115aa          
004115b4          if (eax_1)
004115b4          {
004115cd              *(uint8_t*)eax_1 = 0;
004115da              sub_403450(arg1, sub_401db0(arg1, 0xffffffff, nullptr), 0x42c420, &filename);
004115f1              return sub_401920(arg1, 0xfffffffe);
004115b4          }
004115a1      }
004115a1      
004115ff      sub_402e40(arg1, "unable to get ModuleFileName");
0041160d      return 0;
00411580  }

0041160e                                            90 90                                                                ..

00411610    int32_t sub_411610(void* arg1)

00411610  {
00411619      int32_t eax = sub_4018c0(arg1);
0041162b      sub_402250(arg1, 0xffffd8ee, "tostring");
00411630      int32_t edi = 1;
00411630      
0041163a      if (eax >= 1)
0041163a      {
00411698          do
00411698          {
0041163f              sub_401b20(arg1, 0xffffffff);
00411646              sub_401b20(arg1, edi);
00411650              sub_402730(arg1, 1, 1);
0041165a              char* eax_1 = sub_401db0(arg1, 0xffffffff, nullptr);
0041165a              
00411666              if (!eax_1)
00411666              {
004116b9                  sub_402e40(arg1, "'tostring' must return a string to 'print'");
004116c5                  return 0;
00411666              }
00411666              
0041166b              if (edi > 1)
00411677                  sub_418384(U"\t", 0x42cc10);
00411677              
00411685              sub_418384(eax_1, 0x42cc10);
0041168d              sub_4018d0(arg1, 0xfffffffe);
00411695              edi += 1;
00411698          } while (edi <= eax);
0041163a      }
0041163a      
004116a4      sub_418384(U"\n", 0x42cc10);
004116b2      return 0;
00411610  }

004116c6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

004116d0    int32_t sub_4116d0(int32_t arg1 @ edi, void* arg2)

004116d0  {
004116d4      void* ebx = arg2;
004116de      void* eax = sub_403210(ebx, 2, 0xa);
004116de      
004116eb      if (eax != 0xa)
004116eb      {
00411727          int32_t __saved_edi_1 = arg1;
0041172d          void* eax_3 = sub_4030b0(ebx, 1, nullptr);
0041172d          
0041173f          if (eax < 2 || eax > 0x24)
00411749              sub_402ca0(ebx, 2, "base out of range");
00411749          
00411758          BOOL eax_4 = sub_417c79(eax_3, &arg2, eax);
0041175d          void* ecx_1 = arg2;
00411766          BOOL esi_1 = eax_4;
00411766          
00411769          if (eax_3 != ecx_1)
00411769          {
00411772              while (true)
00411772              {
00411772                  if (data_42d07c <= 1)
00411772                  {
00411791                      int32_t eax_5;
00411791                      (uint8_t)eax_5 = *(uint8_t*)ecx_1;
00411793                      (uint8_t)eax_5 = (**(uint528_t**)&data_42ce70)[eax_5];
00411796                      eax_4 = eax_5 & 8;
00411772                  }
00411772                  else
00411772                  {
00411776                      __saved_edi_1 = 8;
00411778                      void* edx_1;
00411778                      (uint8_t)edx_1 = *(uint8_t*)ecx_1;
0041177b                      eax_4 = sub_4179df(eax_4, edx_1, ecx_1, edx_1);
00411780                      ecx_1 = arg2;
00411772                  }
00411772                  
0041179b                  if (!eax_4)
0041179b                      break;
0041179b                  
0041179d                  ecx_1 += 1;
0041179e                  arg2 = ecx_1;
00411772              }
00411772              
004117a7              if (!*(uint8_t*)ecx_1)
004117a7              {
004117ad                  int32_t var_4 = 0;
004117bc                  void* var_18_2;
004117bc                  var_18_2 = (double)(long double)esi_1;
004117c0                  sub_401fa0(ebx, var_18_2, __saved_edi_1);
004117d2                  return 1;
004117a7              }
00411769          }
004116eb      }
004116eb      else
004116eb      {
004116f0          sub_403080(ebx, 1);
004116f0          
00411702          if (sub_401be0(ebx, 1))
00411702          {
00411710              void* var_18_1;
00411710              var_18_1 = (double)sub_401cf0(ebx, 1);
00411714              sub_401fa0(ebx, var_18_1);
00411726              return 1;
00411702          }
004116eb      }
004116eb      
004117d4      sub_401f80(ebx);
004117e6      return 1;
004116d0  }

004117e7                       90 90 90 90 90 90 90 90 90                                                         .........

004117f0    int32_t sub_4117f0(void* arg1)

004117f0  {
004117fb      void* eax = sub_403210(arg1, 2, 1);
00411805      sub_4018d0(arg1, 1);
00411805      
0041181b      if (sub_401c20(arg1, 1) && eax > 0)
0041181b      {
0041181f          sub_402dd0(arg1, eax);
00411827          sub_401b20(arg1, 1);
0041182f          sub_402a80(arg1, 2);
0041181b      }
0041181b      
00411838      sub_402a30(arg1);
00411842      return 0;
004117f0  }

00411843           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00411850    int32_t sub_411850(void* arg1)

00411850  {
00411858      sub_403080(arg1, 1);
00411858      
0041186a      if (sub_402380(arg1, 1))
0041186a      {
00411884          sub_403240(arg1, 1, "__metatable");
00411892          return 1;
0041186a      }
0041186a      
0041186d      sub_401f80(arg1);
0041187b      return 1;
00411850  }

00411893                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

004118a0    int32_t sub_4118a0(void* arg1)

004118a0  {
004118a9      int32_t eax = sub_401b60(arg1, 2);
004118b5      sub_403020(arg1, 1, 5);
004118b5      
004118c4      if (eax && eax != 5)
004118ce          sub_402ca0(arg1, 2, "nil or table expected");
004118ce      
004118e8      if (sub_403240(arg1, 1, "__metatable"))
004118f0          sub_402e40(arg1, "cannot change a protected metatable");
004118f0      
004118fb      sub_4018d0(arg1, 2);
00411903      sub_4025e0(arg1, 1);
00411912      return 1;
004118a0  }

00411913                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00411920    int32_t sub_411920(void* arg1)

00411920  {
00411926      sub_411970(arg1);
00411926      
00411938      if (!sub_401bb0(arg1, 0xffffffff))
00411938      {
00411952          sub_4023e0(arg1, 0xffffffff);
00411960          return 1;
00411938      }
00411938      
00411940      sub_401b20(arg1, 0xffffd8ee);
0041194e      return 1;
00411920  }

00411961     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00411970    int32_t sub_411970(void* arg1)

00411970  {
00411989      if (sub_401b60(arg1, 1) == 6)
00411999          return sub_401b20(arg1, 1);
00411999      
0041199d      void* eax_2 = sub_403210(arg1, 1, 1);
0041199d      
004119a9      if (eax_2 < 0)
004119b3          sub_402ca0(arg1, 1, "level must be non-negative");
004119b3      
004119cc      void var_64;
004119cc      
004119cc      if (!sub_40ac30(arg1, eax_2, &var_64))
004119d6          sub_402ca0(arg1, 1, "invalid level");
004119d6      
004119e9      sub_40ae20(arg1, U"f", &var_64);
004119f1      int32_t result = sub_401b60(arg1, 0xffffffff);
004119f1      
004119fb      if (result)
00411a11          return result;
00411a11      
004119fd      void* var_70_2 = eax_2;
00411a04      return sub_402e40(arg1, "no function environment for tail call at level %d");
00411970  }

00411a12                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00411a20    int32_t sub_411a20(void* arg1)

00411a20  {
00411a2a      sub_403020(arg1, 2, 5);
00411a30      sub_411970(arg1);
00411a38      sub_401b20(arg1, 2);
00411a38      
00411a4a      if (sub_401be0(arg1, 1))
00411a4a      {
00411a4f          long double st0_1 = sub_401cf0(arg1, 1);
00411a54          long double temp0_1 = (long double)0.0;
00411a54          st0_1 - temp0_1;
00411a54          
00411a62          if (*(uint8_t*)((char*)((st0_1 < temp0_1 ? 1 : 0) << 8
00411a62              | (FCMP_UO(st0_1, temp0_1) ? 1 : 0) << 0xa
00411a62              | (st0_1 == temp0_1 ? 1 : 0) << 0xe))[1] & 0x40)
00411a62          {
00411a65              sub_4021f0(arg1);
00411a6d              sub_401a20(arg1, 0xfffffffe);
00411a75              sub_4026a0(arg1, 0xfffffffe);
00411a80              return 0;
00411a62          }
00411a4a      }
00411a4a      
00411a84      int32_t eax_3 = sub_401bb0(arg1, 0xfffffffe);
00411a8e      int32_t eax_4;
00411a8e      
00411a8e      if (!eax_3)
00411a93          eax_4 = sub_4026a0(arg1, 0xfffffffe);
00411a93      
00411a9d      if (eax_3 || !eax_4)
00411aa5          sub_402e40(arg1, "'setfenv' cannot change environment of given object");
00411aa5      
00411ab3      return 1;
00411a20  }

00411ab4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00411ac0    int32_t sub_411ac0(void* arg1)

00411ac0  {
00411ac8      sub_403080(arg1, 1);
00411ad0      sub_403080(arg1, 2);
00411ae1      sub_4021a0(arg1, sub_401c50(arg1, 1, 2));
00411aef      return 1;
00411ac0  }


00411af0    int32_t sub_411af0(void* arg1)

00411af0  {
00411afa      sub_403020(arg1, 1, 5);
00411b02      sub_403080(arg1, 2);
00411b0a      sub_4018d0(arg1, 2);
00411b12      sub_4022b0(arg1, 1);
00411b20      return 1;
00411af0  }

00411b21     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00411b30    int32_t sub_411b30(void* arg1)

00411b30  {
00411b3a      sub_403020(arg1, 1, 5);
00411b42      sub_403080(arg1, 2);
00411b4a      sub_403080(arg1, 3);
00411b52      sub_4018d0(arg1, 3);
00411b5a      sub_402500(arg1, 1);
00411b68      return 1;
00411b30  }

00411b69                             90 90 90 90 90 90 90                                                           .......

00411b70    int32_t sub_411b70(void* arg1)

00411b70  {
00411b81      sub_401fd0(arg1, sub_402940(arg1, 3, 0));
00411b8f      return 1;
00411b70  }


00411b90    int32_t sub_411b90(uint32_t arg1)

00411b90  {
00411b90      int32_t ecx;
00411b90      int32_t var_4 = ecx;
00411b92      void* esi = arg1;
00411b97      char (** const var_10)[0x5] = &data_428880;
00411b9c      char* var_14 = "collect";
00411ba4      int32_t eax = sub_402e70(esi, 1, "collect", &data_428880);
00411bb0      void* eax_1 = sub_403210(esi, 2, 0);
00411bbf      uint32_t eax_3 = sub_402940(esi, *(uint32_t*)((eax << 2) + &data_4288a0), eax_1);
00411bc4      int32_t edi_1 = *(uint32_t*)((eax << 2) + &data_4288a0);
00411bd5      long double x87_r7;
00411bd5      
00411bd5      if (edi_1 == 3)
00411bd5      {
00411bf8          var_10 = nullptr;
00411bfa          var_14 = 4;
00411c13          x87_r7 = (long double)sub_402940(esi, 4, 0) * (long double)0,0009765625.0
00411c13              + (long double)eax_3;
00411bd5      }
00411bd5      else
00411bd5      {
00411bda          if (edi_1 == 5)
00411bda          {
00411be7              sub_4021a0(esi, eax_3);
00411bf7              return 1;
00411bda          }
00411bda          
00411bdc          x87_r7 = (long double)eax_3;
00411bd5      }
00411bd5      
00411c17      var_14 = (double)x87_r7;
00411c1b      sub_401fa0(esi, var_14, var_10);
00411c2b      return 1;
00411b90  }

00411c2c                                      90 90 90 90                                                              ....

00411c30    int32_t sub_411c30(void* arg1)

00411c30  {
00411c38      sub_403080(arg1, 1);
00411c45      int32_t var_18 = sub_401b60(arg1, 1);
00411c4e      sub_402040(arg1, sub_401b90(arg1));
00411c5c      return 1;
00411c30  }

00411c5d                                                                                         90 90 90                               ...

00411c60    int32_t sub_411c60(void* arg1)

00411c60  {
00411c6a      sub_403020(arg1, 1, 5);
00411c72      sub_4018d0(arg1, 2);
00411c72      
00411c84      if (sub_402a40(arg1, 1))
00411c8c          return 2;
00411c8c      
00411c8e      sub_401f80(arg1);
00411c9c      return 1;
00411c60  }

00411c9d                                                                                         90 90 90                               ...

00411ca0    int32_t sub_411ca0(void* arg1)

00411ca0  {
00411ca1      void* esi = arg1;
00411cae      int32_t eax = sub_4030b0(esi, 1, &arg1);
00411cbb      void* eax_1 = sub_4030f0(esi, 2, eax, nullptr);
00411cd9      return sub_411ce0(esi, sub_403b00(esi, eax, arg1, eax_1));
00411ca0  }

00411cda                                                                                90 90 90 90 90 90                            ......

00411ce0    int32_t sub_411ce0(void* arg1, int32_t arg2)

00411ce0  {
00411ce6      if (!arg2)
00411ced          return 1;
00411ced      
00411cf4      sub_401f80(arg1);
00411cfc      sub_401a20(arg1, 0xfffffffe);
00411d0a      return 2;
00411ce0  }

00411d0b                                   90 90 90 90 90                                                             .....

00411d10    int32_t sub_411d10(void* arg1)

00411d10  {
00411d33      return sub_411ce0(arg1, sub_403830(arg1, sub_4030f0(arg1, 1, 0, nullptr)));
00411d10  }

00411d34                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00411d40    int32_t sub_411d40(void* arg1)

00411d40  {
00411d50      void* eax = sub_4030f0(arg1, 2, "=(load)", nullptr);
00411d5c      sub_403020(arg1, 1, 6);
00411d64      sub_4018d0(arg1, 3);
00411d83      return sub_411ce0(arg1, sub_4028b0(arg1, sub_411d90, 0, eax));
00411d40  }

00411d84              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00411d90    int32_t sub_411d90(void* arg1, int32_t* arg2)

00411d90  {
00411d9d      sub_402ff0(arg1, 2, "too many nested functions");
00411da5      sub_401b20(arg1, 1);
00411daf      sub_402730(arg1, 0, 1);
00411daf      
00411dc1      if (!sub_401b60(arg1, 0xffffffff))
00411dc1      {
00411dc8          *(uint32_t*)arg2 = 0;
00411dd0          return 0;
00411dc1      }
00411dc1      
00411dde      if (!sub_401c20(arg1, 0xffffffff))
00411dde      {
00411e00          sub_402e40(arg1, "reader function must return a string");
00411e0b          return 0;
00411dde      }
00411dde      
00411de3      sub_401a70(arg1, 3);
00411df9      return sub_401db0(arg1, 3, arg2);
00411d90  }

00411e0c                                      90 90 90 90                                                              ....

00411e10    int32_t sub_411e10(void* arg1)

00411e10  {
00411e1e      PSTR eax = sub_4030f0(arg1, 1, 0, nullptr);
00411e26      int32_t eax_1 = sub_4018c0(arg1);
00411e26      
00411e39      if (sub_403830(arg1, eax))
00411e3c          sub_402a30(arg1);
00411e3c      
00411e49      sub_402730(arg1, 0, 0xffffffff);
00411e5c      return sub_4018c0(arg1) - eax_1;
00411e10  }

00411e5d                                                                                         90 90 90                               ...

00411e60    int32_t sub_411e60(void* arg1)

00411e60  {
00411e68      sub_403080(arg1, 1);
00411e70      int32_t* eax = sub_401d80(arg1, 1);
00411e70      
00411e7a      if (eax)
00411ea5          return sub_4018c0(arg1);
00411ea5      
00411e8a      int32_t var_18 = sub_4030f0(arg1, 2, "assertion failed!", eax);
00411e91      sub_402e40(arg1, 0x42beb8);
00411e9a      return 0;
00411e60  }

00411ea6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00411eb0    void* sub_411eb0(void* arg1)

00411eb0  {
00411ebd      sub_403020(arg1, 1, 5);
00411ecf      void* i = sub_403210(arg1, 2, 1);
00411edb      int32_t eax_2;
00411edb      
00411edb      if (sub_401b60(arg1, 3) > 0)
00411eea          eax_2 = sub_4031d0(arg1, 3);
00411edb      else
00411ee0          eax_2 = sub_401e30(arg1, 1);
00411ee0      
00411ef8      void* result = eax_2 - i + 1;
00411ef8      
00411efb      if (result <= 0)
00411f03          return 0;
00411f03      
00411f0b      sub_402ff0(arg1, result, "table too big to unpack");
00411f0b      
00411f15      for (; i <= eax_2; i += 1)
00411f1b          sub_4022f0(arg1, 1, i);
00411f1b      
00411f2e      return result;
00411eb0  }

00411f2f                                               90                                                                 .

00411f30    void* sub_411f30(void* arg1)

00411f30  {
00411f37      int32_t eax = sub_4018c0(arg1);
00411f37      
00411f4c      if (sub_401b60(arg1, 1) == 4 && *(uint8_t*)sub_401db0(arg1, 1, nullptr) == 0x23)
00411f4c      {
00411f65          sub_401fd0(arg1, eax - 1);
00411f74          return 1;
00411f4c      }
00411f4c      
00411f7e      void* esi = sub_4031d0(arg1, 1);
00411f7e      
00411f85      if (esi < 0)
00411f87          esi += eax;
00411f85      else if (esi > eax)
00411f8f          esi = eax;
00411f8f      
00411f94      if (esi < 1)
00411f9e          sub_402ca0(arg1, 1, "index out of range");
00411f9e      
00411fad      return eax - esi;
00411f30  }

00411fae                                            90 90                                                                ..

00411fb0    int32_t sub_411fb0(void* arg1)

00411fb0  {
00411fb8      sub_403080(arg1, 1);
00411fd9      int32_t ecx;
00411fd9      (uint8_t)ecx = !sub_402770(arg1, sub_4018c0(arg1) - 1, 0xffffffff, 0);
00411fde      sub_4021a0(arg1, ecx);
00411fe6      sub_401a20(arg1, 1);
00411ff5      return sub_4018c0(arg1);
00411fb0  }

00411ff6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00412000    int32_t sub_412000(void* arg1)

00412000  {
00412008      sub_403080(arg1, 2);
00412010      sub_4018d0(arg1, 2);
00412018      sub_401a20(arg1, 1);
0041202d      int32_t ecx;
0041202d      (uint8_t)ecx = !sub_402770(arg1, 0, 0xffffffff, 1);
00412032      sub_4021a0(arg1, ecx);
0041203a      sub_401a70(arg1, 1);
00412049      return sub_4018c0(arg1);
00412000  }

0041204a                                90 90 90 90 90 90                                                            ......

00412050    int32_t sub_412050(void* arg1)

00412050  {
00412058      sub_403080(arg1, 1);
00412058      
0041206f      if (!sub_4032a0(arg1, 1, "__tostring"))
0041206f      {
00412085          switch (sub_401b60(arg1, 1))
00412085          {
004120eb              case 0:
004120eb              {
004120eb                  sub_401ff0(arg1, "nil", 3);
004120f9                  return 1;
004120eb                  break;
004120eb              }
004120c4              case 1:
004120c4              {
004120c6                  char* eax_6 = "true";
004120c6                  
004120cb                  if (!sub_401d80(arg1, 1))
004120cd                      eax_6 = "false";
004120cd                  
004120d4                  sub_402040(arg1, eax_6);
004120e2                  return 1;
004120c4                  break;
004120c4              }
00412098              case 3:
00412098              {
00412098                  sub_402040(arg1, sub_401db0(arg1, 1, nullptr));
004120a6                  return 1;
00412098                  break;
00412098              }
004120aa              case 4:
004120aa              {
004120aa                  sub_401b20(arg1, 1);
004120b8                  return 1;
004120aa                  break;
004120aa              }
00412085          }
00412085          
00412105          int32_t var_8_2 = sub_401f20(arg1, 1);
0041210e          int32_t var_14_2 = sub_401b60(arg1, 1);
00412118          int32_t var_c_6 = sub_401b90(arg1);
0041211f          sub_4020b0(arg1, "%s: %p");
0041206f      }
0041206f      
0041212d      return 1;
00412050  }

0041212e                                            8b ff                                                                ..
00412130  uint32_t jump_table_412130[0x5] = 
00412130  {
00412130      [0x0] =  0x004120e3
00412134      [0x1] =  0x004120b9
00412138      [0x2] =  0x004120fa
0041213c      [0x3] =  0x0041208c
00412140      [0x4] =  0x004120a7
00412144  }

00412144    int32_t sub_412144(void* arg1)

00412144  {
00412159      void* eax = sub_401f00(arg1, 1);
00412159      
00412165      if (!eax)
0041216f          sub_402ca0(arg1, 1, "coroutine expected");
0041216f      
00412181      int32_t eax_3 = sub_4121d0(arg1, eax, sub_4018c0(arg1) - 1);
00412181      
0041218d      if (eax_3 >= 0)
0041218d      {
004121ad          sub_4021a0(arg1, 1);
004121b9          sub_401a20(arg1, 0xffffffff - eax_3);
004121c6          return eax_3 + 1;
0041218d      }
0041218d      
00412192      sub_4021a0(arg1, 0);
0041219a      sub_401a20(arg1, 0xfffffffe);
004121a9      return 2;
00412144  }

004121c7                       90 90 90 90 90 90 90 90 90                                                         .........

004121d0    int32_t sub_4121d0(void* arg1, void* arg2, int32_t arg3)

004121d0  {
004121eb      if (!sub_4017a0(arg2, arg3))
004121f3          sub_402e40(arg1, "too many arguments to resume");
004121f3      
00412206      if (!sub_402930(arg2) && !sub_4018c0(arg2))
00412206      {
0041221d          sub_401ff0(arg1, "cannot resume dead coroutine", 0x1c);
0041222b          return 0xffffffff;
00412206      }
00412206      
0041222f      sub_401800(arg1, arg2, arg3);
00412236      int32_t eax_4 = sub_405b00(arg2, arg3);
00412236      
00412245      if (eax_4 && eax_4 != 1)
00412245      {
0041224b          sub_401800(arg2, arg1, 1);
00412259          return 0xffffffff;
00412245      }
00412245      
0041225b      int32_t result = sub_4018c0(arg2);
0041225b      
0041226e      if (!sub_4017a0(arg1, result))
00412276          sub_402e40(arg1, "too many results to resume");
00412276      
00412281      sub_401800(arg2, arg1, result);
0041228e      return result;
004121d0  }

0041228f                                               90                                                                 .

00412290    int32_t sub_412290(void* arg1)

00412290  {
00412297      int32_t* eax = sub_401880(arg1);
004122a1      int32_t eax_1 = sub_401b60(arg1, 1);
004122ac      int32_t eax_2;
004122ac      
004122ac      if (eax_1 == 6)
004122b1          eax_2 = sub_401bb0(arg1, 1);
004122b1      
004122bb      if (eax_1 != 6 || eax_2)
004122c5          sub_402ca0(arg1, 1, "Lua function expected");
004122c5      
004122d0      sub_401b20(arg1, 1);
004122d9      sub_401800(arg1, eax, 1);
004122e8      return 1;
00412290  }

004122e9                             90 90 90 90 90 90 90                                                           .......

004122f0    int32_t sub_4122f0(void* arg1)

004122f0  {
004122f6      sub_412290(arg1);
00412303      sub_4020e0(arg1, sub_412320, 1);
00412311      return 1;
004122f0  }

00412312                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00412320    int32_t sub_412320(void* arg1)

00412320  {
0041233c      int32_t result = sub_4121d0(arg1, sub_401f00(arg1, 0xffffd8ed), sub_4018c0(arg1));
0041233c      
00412348      if (result < 0)
00412348      {
00412357          if (sub_401c20(arg1, 0xffffffff))
00412357          {
0041235c              sub_402dd0(arg1, 1);
00412364              sub_401a20(arg1, 0xfffffffe);
0041236c              sub_402a80(arg1, 2);
00412357          }
00412357          
00412375          sub_402a30(arg1);
00412348      }
00412348      
00412381      return result;
00412320  }

00412382        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00412390    int32_t sub_412390(void* arg1)

00412390  {
0041239d      sub_405c70(arg1, sub_4018c0(arg1));
004123a6      return 0xffffffff;
00412390  }

004123a7                       90 90 90 90 90 90 90 90 90                                                         .........

004123b0    int32_t sub_4123b0(void* arg1)

004123b0  {
004123bc      void* eax = sub_401f00(arg1, 1);
004123bc      
004123c8      if (!eax)
004123d2          sub_402ca0(arg1, 1, "coroutine expected");
004123d2      
004123dc      if (arg1 == eax)
004123dc      {
004123e6          sub_401ff0(arg1, "running", 7);
004123f8          return 1;
004123dc      }
004123dc      
004123fa      int32_t eax_2 = sub_402930(eax);
004123fa      
00412405      if (!eax_2)
00412405      {
00412437          void var_64;
00412437          
00412437          if (sub_40ac30(eax, 0, &var_64) > 0)
00412437          {
00412441              sub_401ff0(arg1, "normal", 6);
00412453              return 1;
00412437          }
00412437          
0041245f          if (!sub_4018c0(eax))
0041245f          {
00412469              sub_401ff0(arg1, "dead", 4);
0041247b              return 1;
0041245f          }
00412405      }
00412405      else if (eax_2 != 1)
00412408      {
00412412          sub_401ff0(arg1, "dead", 4);
00412424          return 1;
00412408      }
00412408      
00412484      sub_401ff0(arg1, "suspended", 9);
00412496      return 1;
004123b0  }

00412497                                                                       90 90 90 90 90 90 90 90 90                         .........

004124a0    int32_t sub_4124a0(void* arg1)

004124a0  {
004124a5      int32_t eax = sub_4021f0(arg1);
004124ad      int32_t eax_1 = -(eax);
004124b2      return eax_1 - eax_1 + 1;
004124a0  }

004124b3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

004124c0    int32_t sub_4124c0(void* arg1)

004124c0  {
004124c6      sub_4124f0(arg1);
004124d6      sub_403300(arg1, "coroutine", &data_428988);
004124e4      return 2;
004124c0  }

004124e5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

004124f0    int32_t sub_4124f0(void* arg1)

004124f0  {
004124fb      sub_401b20(arg1, 0xffffd8ee);
0041250b      sub_402490(arg1, 0xffffd8ee, "_G");
0041251b      sub_403300(arg1, "_G", &data_4288c0);
00412528      sub_401ff0(arg1, "Lua 5.1", 7);
00412538      sub_402490(arg1, 0xffffd8ee, "_VERSION");
0041254d      sub_412770(arg1, "ipairs", sub_412650, sub_412610);
00412565      sub_412770(arg1, "pairs", sub_4125d0, sub_411c60);
0041256f      sub_402330(arg1, 0, 1);
00412577      sub_401b20(arg1, 0xffffffff);
0041257f      sub_4025e0(arg1, 0xfffffffe);
0041258c      sub_401ff0(arg1, "kv", 2);
00412599      sub_402490(arg1, 0xfffffffe, "__mode");
004125a9      sub_4020e0(arg1, sub_412690, 1);
004125c2      return sub_402490(arg1, 0xffffd8ee, "newproxy");
004124f0  }

004125c3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

004125d0    int32_t sub_4125d0(void* arg1)

004125d0  {
004125da      sub_403020(arg1, 1, 5);
004125e5      sub_401b20(arg1, 0xffffd8ed);
004125ed      sub_401b20(arg1, 1);
004125f3      sub_401f80(arg1);
00412601      return 3;
004125d0  }

00412602        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00412610    int32_t sub_412610(void* arg1)

00412610  {
00412619      void* eax = sub_4031d0(arg1, 2);
00412625      sub_403020(arg1, 1, 5);
0041262d      sub_401fd0(arg1, (char*)eax + 1);
00412636      sub_4022f0(arg1, 1, (char*)eax + 1);
0041263e      int32_t eax_1 = sub_401b60(arg1, 0xffffffff);
00412646      int32_t eax_2 = -(eax_1);
0041264f      return (eax_2 - eax_2) & 2;
00412610  }


00412650    int32_t sub_412650(void* arg1)

00412650  {
0041265a      sub_403020(arg1, 1, 5);
00412665      sub_401b20(arg1, 0xffffd8ed);
0041266d      sub_401b20(arg1, 1);
00412675      sub_401fd0(arg1, 0);
00412683      return 3;
00412650  }

00412684              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00412690    int32_t sub_412690(void* arg1)

00412690  {
00412698      sub_4018d0(arg1, 1);
004126a0      sub_402b10(arg1, 0);
004126a0      
004126b2      if (sub_401d80(arg1, 1))
004126b2      {
004126c6          if (sub_401b60(arg1, 1) == 1)
004126c6          {
004126cd              sub_402330(arg1, 0, 0);
004126d5              sub_401b20(arg1, 0xffffffff);
004126dd              sub_4021a0(arg1, 1);
004126e8              sub_402500(arg1, 0xffffd8ed);
004126f3              sub_4025e0(arg1, 2);
00412701              return 1;
004126c6          }
004126c6          
00412705          int32_t eax_3 = sub_402380(arg1, 1);
0041270f          int32_t eax_4;
0041270f          
0041270f          if (eax_3)
0041270f          {
00412718              sub_4022b0(arg1, 0xffffd8ed);
00412720              eax_4 = sub_401d80(arg1, 0xffffffff);
0041272a              sub_4018d0(arg1, 0xfffffffe);
0041270f          }
0041270f          
00412735          if (!eax_3 || !eax_4)
0041273f              sub_402ca0(arg1, 1, "boolean or proxy expected");
0041273f          
0041274a          sub_402380(arg1, 1);
00412755          sub_4025e0(arg1, 2);
004126b2      }
004126b2      
00412763      return 1;
00412690  }

00412764              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00412770    int32_t sub_412770(void* arg1, char* arg2, int32_t arg3, int32_t arg4)

00412770  {
0041277d      sub_4020e0(arg1, arg4, 0);
0041278a      sub_4020e0(arg1, arg3, 1);
004127a0      return sub_402490(arg1, 0xfffffffe, arg2);
00412770  }

004127a1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

004127b0    int32_t* sub_4127b0(void* arg1, int32_t arg2, int32_t arg3, char* arg4)

004127b0  {
004127c6      int32_t var_248 = arg3;
004127ca      char* edi = arg4;
004127cc      int32_t i = 0xffffffff;
004127cc      
004127d1      while (i)
004127d1      {
004127d1          bool cond:0_1 = 0 != *(uint8_t*)edi;
004127d1          edi = &edi[1];
004127d1          i -= 1;
004127d1          
004127d1          if (!cond:0_1)
004127d1              break;
004127d1      }
004127d1      
004127f4      void var_284;
004127f4      sub_406390(arg1, &var_284, arg2, sub_405f60(arg1, arg4, ~i - 1));
00412803      int32_t* result;
00412803      sub_4128a0(&var_284, &result);
00412811      *(uint8_t*)((char*)result + 0x4a) = 2;
00412815      sub_406420(&var_284);
0041281f      sub_412bb0(&var_284);
0041282e      sub_412850(&var_284, 0x11f);
00412838      sub_412960(&var_284);
0041284f      return result;
004127b0  }


00412850    int32_t sub_412850(void* arg1, int32_t arg2)

00412850  {
0041285b      if (*(uint32_t*)((char*)arg1 + 0x10) == arg2)
00412867          return arg2;
00412867      
0041285f      return sub_412870(arg1, arg2);
00412850  }

00412868                          90 90 90 90 90 90 90 90                                                          ........

00412870    int32_t sub_412870(void* arg1, int32_t arg2)

00412870  {
00412883      int32_t var_10 = sub_406170(arg1, arg2);
0041289a      return sub_406320(arg1, 
0041289a          sub_4087a0(*(uint32_t*)((char*)arg1 + 0x34), "'%s' expected"));
00412870  }

0041289b                                                                                   90 90 90 90 90                             .....

004128a0    int32_t sub_4128a0(void* arg1, int32_t** arg2)

004128a0  {
004128a8      void* edi = *(uint32_t*)((char*)arg1 + 0x34);
004128ac      int32_t* eax = sub_404f80(edi);
004128ba      *(uint32_t*)arg2 = eax;
004128bf      arg2[2] = *(uint32_t*)((char*)arg1 + 0x30);
004128c2      arg2[3] = arg1;
004128c5      arg2[4] = edi;
004128ca      *(uint32_t*)((char*)arg1 + 0x30) = arg2;
004128cd      arg2[6] = 0;
004128d0      arg2[7] = 0xffffffff;
004128d3      arg2[8] = 0xffffffff;
004128d6      arg2[9] = 0;
004128d9      arg2[0xa] = 0;
004128dc      arg2[0xb] = 0;
004128df      arg2[0xc] = 0;
004128e3      *(uint8_t*)((char*)arg2 + 0x32) = 0;
004128e6      arg2[5] = 0;
004128ef      eax[8] = *(uint32_t*)((char*)arg1 + 0x40);
004128f2      *(uint8_t*)((char*)eax + 0x4b) = 2;
004128f6      int32_t* eax_2 = sub_407b30(edi, 0, 0);
004128fb      arg2[1] = eax_2;
004128fe      int32_t** ecx_1 = *(uint32_t*)((char*)edi + 8);
00412909      *(uint32_t*)ecx_1 = eax_2;
0041290b      ecx_1[2] = 5;
0041290b      
0041291c      if (*(uint32_t*)((char*)edi + 0x1c) - *(uint32_t*)((char*)edi + 8) <= 0x10)
00412921          sub_405460(edi, 1);
00412921      
0041292c      int32_t** ebx_2 = *(uint32_t*)((char*)edi + 8) + 0x10;
00412930      *(uint32_t*)((char*)edi + 8) = ebx_2;
00412933      *(uint32_t*)ebx_2 = eax;
00412935      ebx_2[2] = 9;
00412935      
00412946      if (*(uint32_t*)((char*)edi + 0x1c) - *(uint32_t*)((char*)edi + 8) <= 0x10)
0041294b          sub_405460(edi, 1);
0041294b      
00412956      int32_t result = *(uint32_t*)((char*)edi + 8) + 0x10;
00412958      *(uint32_t*)((char*)edi + 8) = result;
0041295f      return result;
004128a0  }


00412960    void** sub_412960(void* arg1)

00412960  {
0041296a      int32_t* edi = *(uint32_t*)((char*)arg1 + 0x30);
0041296d      void* ebx = *(uint32_t*)((char*)arg1 + 0x34);
00412971      void* esi = *(uint32_t*)edi;
00412973      sub_412b50(arg1, 0);
0041297d      sub_4155f0(edi, 0, 0);
00412982      int32_t eax = edi[6];
00412991      int32_t eax_3;
00412991      
00412991      if (eax + 1 > 0x3fffffff)
004129b2          eax_3 = sub_404ce0(ebx);
00412991      else
004129a7          eax_3 = sub_404d00(ebx, *(uint32_t*)((char*)esi + 0xc), 
004129a7              *(uint32_t*)((char*)esi + 0x2c) << 2, eax << 2);
004129a7      
004129ba      *(uint32_t*)((char*)esi + 0xc) = eax_3;
004129c0      *(uint32_t*)((char*)esi + 0x2c) = edi[6];
004129c3      int32_t eax_4 = edi[6];
004129cf      int32_t eax_7;
004129cf      
004129cf      if (eax_4 + 1 > 0x3fffffff)
004129f0          eax_7 = sub_404ce0(ebx);
004129cf      else
004129e5          eax_7 = sub_404d00(ebx, *(uint32_t*)((char*)esi + 0x14), 
004129e5              *(uint32_t*)((char*)esi + 0x30) << 2, eax_4 << 2);
004129e5      
004129f8      *(uint32_t*)((char*)esi + 0x14) = eax_7;
004129fe      *(uint32_t*)((char*)esi + 0x30) = edi[6];
00412a01      int32_t eax_8 = edi[0xa];
00412a0d      int32_t eax_11;
00412a0d      
00412a0d      if (eax_8 + 1 > 0xfffffff)
00412a2a          eax_11 = sub_404ce0(ebx);
00412a0d      else
00412a1f          eax_11 = sub_404d00(ebx, *(uint32_t*)((char*)esi + 8), 
00412a1f              *(uint32_t*)((char*)esi + 0x28) << 4, eax_8 << 4);
00412a1f      
00412a32      *(uint32_t*)((char*)esi + 8) = eax_11;
00412a38      *(uint32_t*)((char*)esi + 0x28) = edi[0xa];
00412a3b      int32_t eax_12 = edi[0xb];
00412a47      int32_t eax_14;
00412a47      
00412a47      if (eax_12 + 1 > 0x3fffffff)
00412a64          eax_14 = sub_404ce0(ebx);
00412a47      else
00412a59          eax_14 = sub_404d00(ebx, *(uint32_t*)((char*)esi + 0x10), 
00412a59              *(uint32_t*)((char*)esi + 0x34) << 2, eax_12 << 2);
00412a59      
00412a6c      *(uint32_t*)((char*)esi + 0x10) = eax_14;
00412a72      *(uint32_t*)((char*)esi + 0x34) = edi[0xb];
00412a75      int32_t eax_16 = (int32_t)edi[0xc];
00412a82      int32_t eax_20;
00412a82      
00412a82      if (eax_16 + 1 > 0x15555555)
00412aa5          eax_20 = sub_404ce0(ebx);
00412a82      else
00412a9a          eax_20 = sub_404d00(ebx, *(uint32_t*)((char*)esi + 0x18), 
00412a9a              *(uint32_t*)((char*)esi + 0x38) * 0xc, eax_16 * 0xc);
00412a9a      
00412aad      *(uint32_t*)((char*)esi + 0x18) = eax_20;
00412ab2      int32_t eax_21;
00412ab2      (uint8_t)eax_21 = *(uint8_t*)((char*)esi + 0x48);
00412abc      *(uint32_t*)((char*)esi + 0x38) = (int32_t)edi[0xc];
00412ac5      int32_t eax_24;
00412ac5      
00412ac5      if (eax_21 + 1 > 0x3fffffff)
00412ae6          eax_24 = sub_404ce0(ebx);
00412ac5      else
00412adb          eax_24 = sub_404d00(ebx, *(uint32_t*)((char*)esi + 0x1c), 
00412adb              *(uint32_t*)((char*)esi + 0x24) << 2, eax_21 << 2);
00412adb      
00412af0      *(uint32_t*)((char*)esi + 0x1c) = eax_24;
00412af3      int32_t edx_13;
00412af3      (uint8_t)edx_13 = *(uint8_t*)((char*)esi + 0x48);
00412af6      *(uint32_t*)((char*)esi + 0x24) = edx_13;
00412af9      void** result = edi[2];
00412afc      *(uint32_t*)((char*)arg1 + 0x30) = result;
00412b07      *(uint32_t*)((char*)ebx + 8) -= 0x20;
00412b07      
00412b0a      if (!edi)
00412b19          return result;
00412b19      
00412b0d      return sub_412b20(arg1);
00412960  }

00412b1a                                                                                90 90 90 90 90 90                            ......

00412b20    void** sub_412b20(void* arg1)

00412b20  {
00412b24      void** result = *(uint32_t*)((char*)arg1 + 0x10);
00412b24      
00412b33      if (result != 0x11d && result != 0x11e)
00412b49          return result;
00412b49      
00412b35      void* eax = *(uint32_t*)((char*)arg1 + 0x18);
00412b41      return sub_406340(arg1, (char*)eax + 0x10, *(uint32_t*)((char*)eax + 0xc));
00412b20  }

00412b4a                                90 90 90 90 90 90                                                            ......

00412b50    void* sub_412b50(void* arg1, int32_t arg2)

00412b50  {
00412b59      int32_t* ecx = *(uint32_t*)((char*)arg1 + 0x30);
00412b5c      void* result;
00412b5c      (uint8_t)result = *(uint8_t*)((char*)ecx + 0x32);
00412b5c      
00412b69      while ((uint32_t)(uint8_t)result > arg2)
00412b69      {
00412b6c          (uint8_t)result -= 1;
00412b70          *(uint8_t*)((char*)ecx + 0x32) = (uint8_t)result;
00412b7b          int32_t edx_2;
00412b7b          (uint16_t)edx_2 = *(uint16_t*)((char*)ecx + ((result & 0xff) << 1) + 0xac);
00412b8b          *(uint32_t*)(*(uint32_t*)(*(uint32_t*)ecx + 0x18) + edx_2 * 0xc + 8) = ecx[6];
00412b8f          (uint8_t)result = *(uint8_t*)((char*)ecx + 0x32);
00412b69      }
00412b69      
00412ba0      return result;
00412b50  }

00412ba1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00412bb0    void* sub_412bb0(int32_t* arg1)

00412bb0  {
00412bb7      sub_412c30(arg1);
00412bef      void* result;
00412bef      int32_t i;
00412bef      
00412bef      do
00412bef      {
00412bc3          result = sub_412c60(arg1[4]);
00412bc3          
00412bcd          if (result)
00412bcd              break;
00412bcd          
00412bd0          i = sub_412cb0(arg1);
00412bda          sub_412c00(arg1, 0x3b);
00412bdf          result = arg1[0xc];
00412be7          int32_t ecx_1;
00412be7          (uint8_t)ecx_1 = *(uint8_t*)((char*)result + 0x32);
00412bec          *(uint32_t*)((char*)result + 0x24) = ecx_1;
00412bef      } while (!i);
00412bf1      void* esi_1 = arg1[0xd];
00412bf5      *(uint16_t*)((char*)esi_1 + 0x34) -= 1;
00412bfa      return result;
00412bb0  }

00412bfb                                                                                   90 90 90 90 90                             .....

00412c00    int32_t sub_412c00(int32_t* arg1, int32_t arg2)

00412c00  {
00412c0d      if (arg1[4] != arg2)
00412c20          return 0;
00412c20      
00412c10      sub_406420(arg1);
00412c1d      return 1;
00412c00  }

00412c21     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00412c30    void* sub_412c30(void* arg1)

00412c30  {
00412c34      void* eax = *(uint32_t*)((char*)arg1 + 0x34);
00412c37      *(uint16_t*)((char*)eax + 0x34) += 1;
00412c3b      void* result = *(uint32_t*)((char*)arg1 + 0x34);
00412c3b      
00412c44      if (*(uint16_t*)((char*)result + 0x34) <= 0xc8)
00412c56          return result;
00412c56      
00412c4e      return sub_4061e0(arg1, "chunk has too many syntax levels", 0);
00412c30  }

00412c57                                                                       90 90 90 90 90 90 90 90 90                         .........

00412c60    int32_t sub_412c60(int32_t arg1)

00412c60  {
00412c6c      if (arg1 - 0x104 <= 0x1b)
00412c6c      {
00412c70          int32_t ecx_1;
00412c70          (uint8_t)ecx_1 = *(uint8_t*)(arg1 + sub_412b50+0x3c);
00412c70          
00412c76          switch (ecx_1)
00412c76          {
00412c82              case 0:
00412c82              {
00412c82                  return 1;
00412c82                  break;
00412c82              }
00412c76          }
00412c6c      }
00412c6c      
00412c85      return 0;
00412c60  }

00412c86                    8b ff                                                                                ..
00412c88  uint32_t jump_table_412c88[0x2] = 
00412c88  {
00412c88      [0x0] =  0x00412c7d
00412c8c      [0x1] =  0x00412c83
00412c90  }
00412c90  uint8_t lookup_table_412c90[0x1c] = 
00412c90  {
00412c90      [0x00] =  0x00
00412c91      [0x01] =  0x00
00412c92      [0x02] =  0x00
00412c93      [0x03] =  0x01
00412c94      [0x04] =  0x01
00412c95      [0x05] =  0x01
00412c96      [0x06] =  0x01
00412c97      [0x07] =  0x01
00412c98      [0x08] =  0x01
00412c99      [0x09] =  0x01
00412c9a      [0x0a] =  0x01
00412c9b      [0x0b] =  0x01
00412c9c      [0x0c] =  0x01
00412c9d      [0x0d] =  0x01
00412c9e      [0x0e] =  0x01
00412c9f      [0x0f] =  0x01
00412ca0      [0x10] =  0x00
00412ca1      [0x11] =  0x01
00412ca2      [0x12] =  0x01
00412ca3      [0x13] =  0x01
00412ca4      [0x14] =  0x01
00412ca5      [0x15] =  0x01
00412ca6      [0x16] =  0x01
00412ca7      [0x17] =  0x01
00412ca8      [0x18] =  0x01
00412ca9      [0x19] =  0x01
00412caa      [0x1a] =  0x01
00412cab      [0x1b] =  0x00
00412cac  }

00412cac                                      90 90 90 90                                                              ....

00412cb0    int32_t sub_412cb0(int32_t* arg1)

00412cb0  {
00412cb9      int32_t edi = arg1[1];
00412cbc      int32_t eax_1 = arg1[4] - 0x102;
00412cbc      
00412cc4      if (eax_1 <= 0x13)
00412cc4      {
00412ccc          int32_t ecx_1;
00412ccc          (uint8_t)ecx_1 = lookup_table_412ddc[eax_1];
00412ccc          
00412cd2          switch (ecx_1)
00412cd2          {
00412d8e              case 0:
00412d8e              {
00412d8e                  sub_406420(arg1);
00412d94                  sub_412f20(arg1);
00412da3                  return 1;
00412d8e                  break;
00412d8e              }
00412cf8              case 1:
00412cf8              {
00412cf8                  sub_406420(arg1);
00412cfe                  sub_412e60(arg1);
00412d0f                  sub_412df0(arg1, 0x106, 0x103, edi);
00412d1b                  return 0;
00412cf8                  break;
00412cf8              }
00412d1e              case 2:
00412d1e              {
00412d1e                  sub_414520(arg1, edi);
00412d2a                  return 0;
00412d1e                  break;
00412d1e              }
00412d3c              case 3:
00412d3c              {
00412d3c                  sub_414b40(arg1, edi);
00412d48                  return 0;
00412d3c                  break;
00412d3c              }
00412cdb              case 4:
00412cdb              {
00412cdb                  sub_414940(arg1, edi);
00412ce7                  return 0;
00412cdb                  break;
00412cdb              }
00412d4a              case 5:
00412d4a              {
00412d4a                  sub_406420(arg1);
00412d4a                  
00412d60                  if (!sub_412c00(arg1, 0x109))
00412d60                  {
00412d6f                      sub_414ac0(arg1);
00412d7b                      return 0;
00412d60                  }
00412d60                  
00412d62                  sub_414a30(arg1);
00412d6e                  return 0;
00412d4a                  break;
00412d4a              }
00412d2d              case 6:
00412d2d              {
00412d2d                  sub_414450(arg1, edi);
00412d39                  return 0;
00412d2d                  break;
00412d2d              }
00412d7d              case 7:
00412d7d              {
00412d7d                  sub_414df0(arg1);
00412d8c                  return 1;
00412d7d                  break;
00412d7d              }
00412cea              case 8:
00412cea              {
00412cea                  sub_412f90(arg1, edi);
00412cf6                  return 0;
00412cea                  break;
00412cea              }
00412cd2          }
00412cc4      }
00412cc4      
00412da5      sub_414c00(arg1);
00412db1      return 0;
00412cb0  }

00412db2                                                        8b ff                                                        ..
00412db4  uint32_t jump_table_412db4[0xa] = 
00412db4  {
00412db4      [0x0] =  0x00412d8d
00412db8      [0x1] =  0x00412cf7
00412dbc      [0x2] =  0x00412d1c
00412dc0      [0x3] =  0x00412d3a
00412dc4      [0x4] =  0x00412cd9
00412dc8      [0x5] =  0x00412d49
00412dcc      [0x6] =  0x00412d2b
00412dd0      [0x7] =  0x00412d7c
00412dd4      [0x8] =  0x00412ce8
00412dd8      [0x9] =  0x00412da4
00412ddc  }
00412ddc  uint8_t lookup_table_412ddc[0x14] = 
00412ddc  {
00412ddc      [0x00] =  0x00
00412ddd      [0x01] =  0x01
00412dde      [0x02] =  0x09
00412ddf      [0x03] =  0x09
00412de0      [0x04] =  0x09
00412de1      [0x05] =  0x09
00412de2      [0x06] =  0x02
00412de3      [0x07] =  0x03
00412de4      [0x08] =  0x04
00412de5      [0x09] =  0x09
00412de6      [0x0a] =  0x05
00412de7      [0x0b] =  0x09
00412de8      [0x0c] =  0x09
00412de9      [0x0d] =  0x09
00412dea      [0x0e] =  0x06
00412deb      [0x0f] =  0x07
00412dec      [0x10] =  0x09
00412ded      [0x11] =  0x09
00412dee      [0x12] =  0x09
00412def      [0x13] =  0x08
00412df0  }

00412df0    int32_t sub_412df0(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00412df0  {
00412dfc      int32_t result = sub_412c00(arg1, arg2);
00412dfc      
00412e06      if (result)
00412e55          return result;
00412e55      
00412e11      if (arg4 == arg1[1])
00412e1f          return sub_412870(arg1, arg2);
00412e1f      
00412e20      int32_t var_c_2 = arg4;
00412e2f      int32_t var_10_3 = sub_406170(arg1, arg3);
00412e3d      int32_t var_14_3 = sub_406170(arg1, arg2);
00412e4b      return sub_406320(arg1, 
00412e4b          sub_4087a0(arg1[0xd], "'%s' expected (to close '%s' at line %d)"));
00412df0  }

00412e56                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00412e60    int32_t sub_412e60(int32_t* arg1)

00412e60  {
00412e70      int32_t* esi = arg1[0xc];
00412e74      void var_c;
00412e74      sub_412e90(esi, &var_c, 0);
00412e7a      sub_412bb0(arg1);
00412e8d      return sub_412ec0(esi);
00412e60  }

00412e8e                                            90 90                                                                ..

00412e90    int32_t* sub_412e90(void* arg1, int32_t* arg2, char arg3)

00412e90  {
00412e98      *(uint8_t*)((char*)arg2 + 0xa) = arg3;
00412e9f      arg2[1] = 0xffffffff;
00412ea6      char edx = *(uint8_t*)((char*)arg1 + 0x32);
00412ea9      *(uint8_t*)((char*)arg2 + 9) = 0;
00412ead      arg2[2] = edx;
00412eb3      *(uint32_t*)arg2 = *(uint32_t*)((char*)arg1 + 0x14);
00412eb5      *(uint32_t*)((char*)arg1 + 0x14) = arg2;
00412eb8      return arg2;
00412e90  }

00412eb9                                                                             90 90 90 90 90 90 90                           .......

00412ec0    int32_t sub_412ec0(int32_t* arg1)

00412ec0  {
00412ec8      int32_t* edi = arg1[5];
00412ecb      void* edx = arg1[3];
00412ed0      arg1[5] = *(uint32_t*)edi;
00412ed3      int32_t ecx;
00412ed3      (uint8_t)ecx = edi[2];
00412ed8      sub_412b50(edx, ecx);
00412ed8      
00412ee5      if (*(uint8_t*)((char*)edi + 9))
00412ee5      {
00412eeb          int32_t eax_2;
00412eeb          (uint8_t)eax_2 = edi[2];
00412ef4          sub_416bf0(arg1, 0x23, eax_2, 0, 0);
00412ee5      }
00412ee5      
00412efe      int32_t ecx_1;
00412efe      (uint8_t)ecx_1 = *(uint8_t*)((char*)arg1 + 0x32);
00412f01      arg1[9] = ecx_1;
00412f13      return sub_4157e0(arg1, edi[1]);
00412ec0  }

00412f14                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00412f20    int32_t sub_412f20(void* arg1)

00412f20  {
00412f27      int32_t* ebx = *(uint32_t*)((char*)arg1 + 0x30);
00412f2a      int32_t edi = 0;
00412f2c      void** esi = ebx[5];
00412f2c      
00412f31      if (!esi)
00412f31      {
00412f53      label_412f53:
00412f53          sub_406320(arg1, "no loop to break");
00412f31      }
00412f31      else
00412f31      {
00412f33          while (true)
00412f33          {
00412f33              int32_t ecx;
00412f33              (uint8_t)ecx = *(uint8_t*)((char*)esi + 0xa);
00412f33              
00412f38              if ((uint8_t)ecx)
00412f38                  break;
00412f38              
00412f3c              (uint8_t)ecx = *(uint8_t*)((char*)esi + 9);
00412f3f              esi = *(uint32_t*)esi;
00412f41              edi |= ecx;
00412f41              
00412f45              if (!esi)
00412f45                  goto label_412f53_1;
00412f33          }
00412f33          
00412f4b          if (!esi)
00412f4b          {
00412f53          label_412f53_1:
00412f53              sub_406320(arg1, "no loop to break");
00412f4b          }
00412f31      }
00412f31      
00412f5d      if (edi)
00412f5d      {
00412f63          int32_t edx_1;
00412f63          (uint8_t)edx_1 = esi[2];
00412f6c          sub_416bf0(ebx, 0x23, edx_1, 0, 0);
00412f5d      }
00412f5d      
00412f8b      return sub_415800(ebx, &esi[1], sub_4155b0(ebx));
00412f20  }

00412f8c                                      90 90 90 90                                                              ....

00412f90    int32_t sub_412f90(int32_t* arg1, int32_t arg2)

00412f90  {
00412f9c      int32_t* esi = arg1[0xc];
00412f9f      sub_406420(arg1);
00412fa5      int32_t eax = sub_415610(esi);
00412fad      int32_t eax_1 = sub_413040(arg1);
00412fbc      void var_c;
00412fbc      sub_412e90(esi, &var_c, 1);
00412fc7      sub_413020(arg1, 0x103);
00412fcd      sub_412e60(arg1);
00412fe1      sub_415620(esi, sub_4155b0(esi), eax);
00412ff6      sub_412df0(arg1, 0x106, 0x115, arg2);
00412ffc      sub_412ec0(esi);
00413012      return sub_4157e0(esi, eax_1);
00412f90  }

00413013                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00413020    void* sub_413020(int32_t* arg1, int32_t arg2)

00413020  {
0041302b      sub_412850(arg1, arg2);
0041303a      return sub_406420(arg1);
00413020  }

0041303b                                                                                   90 90 90 90 90                             .....

00413040    int32_t sub_413040(int32_t* arg1)

00413040  {
0041304e      int32_t var_18;
0041304e      sub_413090(arg1, &var_18);
0041304e      
0041305d      if (var_18 == 1)
0041305f          var_18 = 3;
0041305f      
00413070      sub_4161f0(arg1[0xc], &var_18);
00413080      int32_t result;
00413080      return result;
00413040  }

00413081     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00413090    int32_t* sub_413090(int32_t* arg1, int32_t* arg2)

00413090  {
004130a4      return sub_4130b0(arg1, arg2, 0);
00413090  }

004130a5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

004130b0    int32_t* sub_4130b0(int32_t* arg1, int32_t* arg2, int32_t arg3)

004130b0  {
004130bc      sub_412c30(arg1);
004130c5      int32_t eax_1 = sub_414260(arg1[4]);
004130d2      int32_t* ebp;
004130d2      
004130d2      if (eax_1 == 3)
004130d2      {
004130f7          ebp = arg2;
004130fd          sub_413180(arg1, ebp);
004130d2      }
004130d2      else
004130d2      {
004130d5          sub_406420(arg1);
004130da          ebp = arg2;
004130e2          sub_4130b0(arg1, ebp, 8);
004130ed          sub_4163d0(arg1[0xc], eax_1, ebp);
004130d2      }
004130d2      
0041310e      int32_t* result = sub_414290(arg1[4]);
0041310e      
00413116      if (result != 0xf)
00413116      {
00413169          int32_t* i;
00413169          
00413169          do
00413169          {
0041311e              int32_t eax_3;
0041311e              (uint8_t)eax_3 = *(uint8_t*)((result << 1) + &data_4289c8);
0041311e              
00413127              if (eax_3 <= arg3)
00413127                  break;
00413127              
0041312a              sub_406420(arg1);
00413135              sub_4167a0(arg1[0xc], result, ebp);
00413140              int32_t edx_1;
00413140              (uint8_t)edx_1 = *(uint8_t*)((result << 1) + &data_4289c9);
0041314a              void var_18;
0041314a              i = sub_4130b0(arg1, &var_18, edx_1);
0041315c              sub_4168a0(arg1[0xc], result, ebp, &var_18);
00413167              result = i;
00413169          } while (i != 0xf);
00413116      }
00413116      
0041316b      void* esi_1 = arg1[0xd];
00413171      *(uint16_t*)((char*)esi_1 + 0x34) -= 1;
0041317b      return result;
004130b0  }

0041317c                                                                                      90 90 90 90                              ....

00413180    void* sub_413180(int32_t* arg1, int32_t* arg2)

00413180  {
00413189      int32_t eax_1 = arg1[4] - 0x7b;
00413189      
00413191      if (eax_1 <= 0xa3)
00413191      {
00413199          int32_t ecx_1;
00413199          (uint8_t)ecx_1 = lookup_table_4132f8[eax_1];
00413199          
0041319f          switch (ecx_1)
0041319f          {
004132a3              case 0:
004132a3              {
004132a3                  return sub_4133f0(arg1, arg2);
004132a3                  break;
004132a3              }
00413230              case 1:
00413230              {
00413230                  sub_4133a0(arg2, 3, 0);
00413243                  return sub_406420(arg1);
00413230                  break;
00413230              }
004132a5              case 2:
004132a5              {
004132a5                  sub_406420(arg1);
004132c0                  return sub_413820(arg1, arg2, 0, arg1[1]);
004132a5                  break;
004132a5              }
004131f6              case 3:
004131f6              {
004131f6                  sub_4133a0(arg2, 1, 0);
00413209                  return sub_406420(arg1);
004131f6                  break;
004131f6              }
00413213              case 4:
00413213              {
00413213                  sub_4133a0(arg2, 2, 0);
00413226                  return sub_406420(arg1);
00413213                  break;
00413213              }
00413244              case 5:
00413244              {
00413244                  int32_t* edi_1 = arg1[0xc];
00413249                  (uint8_t)ecx_1 = *(uint8_t*)(*(uint32_t*)edi_1 + 0x4a);
00413249                  
0041324e                  if (!(uint8_t)ecx_1)
00413256                      sub_406320(arg1, "cannot use '...' outside a vararg function");
00413256                  
0041325e                  void* eax_10 = *(uint32_t*)edi_1;
0041326f                  *(uint8_t*)((char*)eax_10 + 0x4a) &= 0xfb;
0041327f                  sub_4133a0(arg2, 0xe, sub_416bf0(edi_1, 0x25, 0, 1, 0));
00413292                  return sub_406420(arg1);
00413244                  break;
00413244              }
004131af              case 6:
004131af              {
004131af                  sub_4133a0(arg2, 5, 0);
004131ba                  arg2[2] = arg1[6];
004131c1                  arg2[3] = arg1[7];
004131ce                  return sub_406420(arg1);
004131af                  break;
004131af              }
004131d9              case 7:
004131d9              {
004131d9                  sub_4133c0(arg1, arg2, arg1[6]);
004131ec                  return sub_406420(arg1);
004131d9                  break;
004131d9              }
0041319f          }
00413191      }
00413191      
004132d1      return sub_413be0(arg1, arg2);
00413180  }

004132d2                                                        8b ff                                                        ..
004132d4  uint32_t jump_table_4132d4[0x9] = 
004132d4  {
004132d4      [0x0] =  0x00413293
004132d8      [0x1] =  0x00413227
004132dc      [0x2] =  0x004132a4
004132e0      [0x3] =  0x004131ed
004132e4      [0x4] =  0x0041320a
004132e8      [0x5] =  0x00413244
004132ec      [0x6] =  0x004131a6
004132f0      [0x7] =  0x004131cf
004132f4      [0x8] =  0x004132c1
004132f8  }
004132f8  uint8_t lookup_table_4132f8[0xa4] = 
004132f8  {
004132f8      [0x00] =  0x00
004132f9      [0x01] =  0x08
004132fa      [0x02] =  0x08
004132fb      [0x03] =  0x08
004132fc      [0x04] =  0x08
004132fd      [0x05] =  0x08
004132fe      [0x06] =  0x08
004132ff      [0x07] =  0x08
00413300      [0x08] =  0x08
00413301      [0x09] =  0x08
00413302      [0x0a] =  0x08
00413303      [0x0b] =  0x08
00413304      [0x0c] =  0x08
00413305      [0x0d] =  0x08
00413306      [0x0e] =  0x08
00413307      [0x0f] =  0x08
00413308      [0x10] =  0x08
00413309      [0x11] =  0x08
0041330a      [0x12] =  0x08
0041330b      [0x13] =  0x08
0041330c      [0x14] =  0x08
0041330d      [0x15] =  0x08
0041330e      [0x16] =  0x08
0041330f      [0x17] =  0x08
00413310      [0x18] =  0x08
00413311      [0x19] =  0x08
00413312      [0x1a] =  0x08
00413313      [0x1b] =  0x08
00413314      [0x1c] =  0x08
00413315      [0x1d] =  0x08
00413316      [0x1e] =  0x08
00413317      [0x1f] =  0x08
00413318      [0x20] =  0x08
00413319      [0x21] =  0x08
0041331a      [0x22] =  0x08
0041331b      [0x23] =  0x08
0041331c      [0x24] =  0x08
0041331d      [0x25] =  0x08
0041331e      [0x26] =  0x08
0041331f      [0x27] =  0x08
00413320      [0x28] =  0x08
00413321      [0x29] =  0x08
00413322      [0x2a] =  0x08
00413323      [0x2b] =  0x08
00413324      [0x2c] =  0x08
00413325      [0x2d] =  0x08
00413326      [0x2e] =  0x08
00413327      [0x2f] =  0x08
00413328      [0x30] =  0x08
00413329      [0x31] =  0x08
0041332a      [0x32] =  0x08
0041332b      [0x33] =  0x08
0041332c      [0x34] =  0x08
0041332d      [0x35] =  0x08
0041332e      [0x36] =  0x08
0041332f      [0x37] =  0x08
00413330      [0x38] =  0x08
00413331      [0x39] =  0x08
00413332      [0x3a] =  0x08
00413333      [0x3b] =  0x08
00413334      [0x3c] =  0x08
00413335      [0x3d] =  0x08
00413336      [0x3e] =  0x08
00413337      [0x3f] =  0x08
00413338      [0x40] =  0x08
00413339      [0x41] =  0x08
0041333a      [0x42] =  0x08
0041333b      [0x43] =  0x08
0041333c      [0x44] =  0x08
0041333d      [0x45] =  0x08
0041333e      [0x46] =  0x08
0041333f      [0x47] =  0x08
00413340      [0x48] =  0x08
00413341      [0x49] =  0x08
00413342      [0x4a] =  0x08
00413343      [0x4b] =  0x08
00413344      [0x4c] =  0x08
00413345      [0x4d] =  0x08
00413346      [0x4e] =  0x08
00413347      [0x4f] =  0x08
00413348      [0x50] =  0x08
00413349      [0x51] =  0x08
0041334a      [0x52] =  0x08
0041334b      [0x53] =  0x08
0041334c      [0x54] =  0x08
0041334d      [0x55] =  0x08
0041334e      [0x56] =  0x08
0041334f      [0x57] =  0x08
00413350      [0x58] =  0x08
00413351      [0x59] =  0x08
00413352      [0x5a] =  0x08
00413353      [0x5b] =  0x08
00413354      [0x5c] =  0x08
00413355      [0x5d] =  0x08
00413356      [0x5e] =  0x08
00413357      [0x5f] =  0x08
00413358      [0x60] =  0x08
00413359      [0x61] =  0x08
0041335a      [0x62] =  0x08
0041335b      [0x63] =  0x08
0041335c      [0x64] =  0x08
0041335d      [0x65] =  0x08
0041335e      [0x66] =  0x08
0041335f      [0x67] =  0x08
00413360      [0x68] =  0x08
00413361      [0x69] =  0x08
00413362      [0x6a] =  0x08
00413363      [0x6b] =  0x08
00413364      [0x6c] =  0x08
00413365      [0x6d] =  0x08
00413366      [0x6e] =  0x08
00413367      [0x6f] =  0x08
00413368      [0x70] =  0x08
00413369      [0x71] =  0x08
0041336a      [0x72] =  0x08
0041336b      [0x73] =  0x08
0041336c      [0x74] =  0x08
0041336d      [0x75] =  0x08
0041336e      [0x76] =  0x08
0041336f      [0x77] =  0x08
00413370      [0x78] =  0x08
00413371      [0x79] =  0x08
00413372      [0x7a] =  0x08
00413373      [0x7b] =  0x08
00413374      [0x7c] =  0x08
00413375      [0x7d] =  0x08
00413376      [0x7e] =  0x08
00413377      [0x7f] =  0x08
00413378      [0x80] =  0x08
00413379      [0x81] =  0x08
0041337a      [0x82] =  0x08
0041337b      [0x83] =  0x08
0041337c      [0x84] =  0x08
0041337d      [0x85] =  0x08
0041337e      [0x86] =  0x08
0041337f      [0x87] =  0x08
00413380      [0x88] =  0x08
00413381      [0x89] =  0x08
00413382      [0x8a] =  0x08
00413383      [0x8b] =  0x08
00413384      [0x8c] =  0x01
00413385      [0x8d] =  0x08
00413386      [0x8e] =  0x02
00413387      [0x8f] =  0x08
00413388      [0x90] =  0x08
00413389      [0x91] =  0x08
0041338a      [0x92] =  0x03
0041338b      [0x93] =  0x08
0041338c      [0x94] =  0x08
0041338d      [0x95] =  0x08
0041338e      [0x96] =  0x08
0041338f      [0x97] =  0x08
00413390      [0x98] =  0x04
00413391      [0x99] =  0x08
00413392      [0x9a] =  0x08
00413393      [0x9b] =  0x08
00413394      [0x9c] =  0x05
00413395      [0x9d] =  0x08
00413396      [0x9e] =  0x08
00413397      [0x9f] =  0x08
00413398      [0xa0] =  0x08
00413399      [0xa1] =  0x06
0041339a      [0xa2] =  0x08
0041339b      [0xa3] =  0x07
0041339c  }

0041339c                                                                                      90 90 90 90                              ....

004133a0    int32_t* sub_4133a0(int32_t* arg1, int32_t arg2, int32_t arg3)

004133a0  {
004133ab      arg1[4] = 0xffffffff;
004133ae      arg1[5] = 0xffffffff;
004133b5      arg1[2] = arg3;
004133b8      *(uint32_t*)arg1 = arg2;
004133ba      return arg1;
004133a0  }

004133bb                                                                                   90 90 90 90 90                             .....

004133c0    int32_t* sub_4133c0(void* arg1, int32_t* arg2, int32_t arg3)

004133c0  {
004133e2      return sub_4133a0(arg2, 4, sub_4158b0(*(uint32_t*)((char*)arg1 + 0x30), arg3));
004133c0  }

004133e3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

004133f0    int32_t sub_4133f0(int32_t* arg1, int32_t* arg2)

004133f0  {
004133fd      int32_t* edi = arg1[0xc];
00413400      int32_t* eax = arg1[1];
0041340d      int32_t eax_1 = sub_416bf0(edi, 0xa, 0, 0, 0);
0041341e      int32_t var_4 = 0;
00413422      uint32_t var_c = 0;
00413426      uint32_t var_8 = 0;
0041342a      int32_t* var_10 = arg2;
0041342e      sub_4133a0(arg2, 0xb, eax_1);
0041343a      int32_t var_28[0x6];
0041343a      sub_4133a0(&var_28, 0, 0);
00413444      sub_415c00(arg1[0xc], arg2);
0041344c      sub_413020(arg1, 0x7b);
0041344c      
0041345e      while (arg1[4] != 0x7d)
0041345e      {
0041346f          sub_413700(edi, &var_28);
00413474          int32_t eax_3 = arg1[4];
00413474          
0041347d          if (eax_3 == 0x5b)
004134bd              sub_413560(arg1, &var_28);
0041347d          else if (eax_3 == 0x11d)
00413484          {
00413494              sub_407490(arg1);
00413494              
004134a1              if (arg1[8] == 0x3d)
004134bd                  sub_413560(arg1, &var_28);
004134a1              else
004134a9                  sub_4137d0(arg1, &var_28);
00413484          }
00413484          else
0041348c              sub_4137d0(arg1, &var_28);
0041348c          
004134d2          if (!sub_412c00(arg1, 0x2c) && !sub_412c00(arg1, 0x3b))
004134e1              break;
0041345e      }
0041345e      
004134f1      sub_412df0(arg1, 0x7d, 0x7b, eax);
004134fc      sub_413750(edi, &var_28);
0041350f      int32_t* esi_1 = *(uint32_t*)(*(uint32_t*)edi + 0xc) + (eax_1 << 2);
00413524      *(uint32_t*)esi_1 = sub_408310(var_8) << 0x17 | (*(uint32_t*)esi_1 & 0x7fffff);
00413530      int32_t* esi_2 = *(uint32_t*)(*(uint32_t*)edi + 0xc) + (eax_1 << 2);
0041354b      int32_t result =
0041354b          (sub_408310(var_c) & 0x1ff) << 0xe | (*(uint32_t*)esi_2 & 0xff803fff);
0041354d      *(uint32_t*)esi_2 = result;
00413556      return result;
004133f0  }

00413557                                                                       90 90 90 90 90 90 90 90 90                         .........

00413560    int32_t sub_413560(int32_t* arg1, void* arg2)

00413560  {
0041356f      int32_t* esi = arg1[0xc];
0041357a      int32_t ebp = esi[9];
0041357d      void var_30;
0041357d      
0041357d      if (arg1[4] != 0x11d)
004135ae          sub_4136d0(arg1, &var_30);
0041357d      else
0041357d      {
00413586          if (*(uint32_t*)((char*)arg2 + 0x1c) > 0x7ffffffd)
00413593              sub_413620(esi, 0x7ffffffd, "items in a constructor");
00413593          
004135a1          sub_413680(arg1, &var_30);
0041357d      }
0041357d      
004135bd      *(uint32_t*)((char*)arg2 + 0x1c) += 1;
004135c0      sub_413020(arg1, 0x3d);
004135cb      sub_415f90(esi, &var_30);
004135d6      void var_18;
004135d6      sub_413090(arg1, &var_18);
004135e1      int32_t eax_1 = sub_415f90(esi, &var_18);
004135f0      int32_t eax_2 = sub_415f90(esi, &var_30);
00413603      int32_t result = sub_416bf0(esi, 9, 
00413603          *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x18) + 8), eax_2, eax_1);
0041360b      esi[9] = ebp;
00413615      return result;
00413560  }

00413616                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00413620    int32_t sub_413620(int32_t* arg1, int32_t arg2, int32_t arg3)

00413620  {
0041362d      int32_t var_8 = arg3;
0041362e      int32_t var_c = arg2;
00413631      int32_t eax_1 = *(uint32_t*)(*(uint32_t*)arg1 + 0x3c);
00413631      
00413636      if (!eax_1)
00413636      {
00413641          int32_t eax_3 = sub_4087a0(arg1[4], "main function has more than %d %s");
00413659          return sub_4061e0(arg1[3], eax_3, 0);
00413636      }
00413636      
0041365a      int32_t var_10_1 = eax_1;
00413664      int32_t eax_6 = sub_4087a0(arg1[4], "function at line %d has more than %d %s");
0041367c      return sub_4061e0(arg1[3], eax_6, 0);
00413620  }

0041367d                                                                                         90 90 90                               ...

00413680    int32_t* sub_413680(int32_t* arg1, int32_t* arg2)

00413680  {
0041369b      return sub_4133c0(arg1, arg2, sub_4136a0(arg1));
00413680  }

0041369c                                                                                      90 90 90 90                              ....

004136a0    int32_t sub_4136a0(int32_t* arg1)

004136a0  {
004136ac      sub_412850(arg1, 0x11d);
004136b1      int32_t result = arg1[6];
004136b5      sub_406420(arg1);
004136c1      return result;
004136a0  }

004136c2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

004136d0    void* sub_4136d0(int32_t* arg1, int32_t* arg2)

004136d0  {
004136d7      sub_406420(arg1);
004136e2      sub_413090(arg1, arg2);
004136ec      sub_415f60(arg1[0xc], arg2);
004136fe      return sub_413020(arg1, 0x5d);
004136d0  }

004136ff                                                                                               90                                 .

00413700    void sub_413700(int32_t* arg1, int32_t* arg2)

00413700  {
00413709      if (!*(uint32_t*)arg2)
00413709          return;
00413709      
00413711      sub_415c00(arg1, arg2);
0041371c      bool cond:0_1 = arg2[9] != 0x32;
0041371f      *(uint32_t*)arg2 = 0;
0041371f      
00413725      if (!cond:0_1)
00413725      {
00413735          sub_416d30(arg1, *(uint32_t*)(arg2[6] + 8), arg2[8], 0x32);
0041373d          arg2[9] = 0;
00413725      }
00413700  }

00413747                       90 90 90 90 90 90 90 90 90                                                         .........

00413750    int32_t sub_413750(int32_t* arg1, int32_t* arg2)

00413750  {
00413756      int32_t result = arg2[9];
00413756      
0041375b      if (result)
0041375b      {
0041375d          int32_t eax = *(uint32_t*)arg2;
0041375d          
00413767          if (eax != 0xd && eax != 0xe)
00413767          {
0041376f              if (eax)
00413773                  sub_415c00(arg1, arg2);
00413773              
00413795              return sub_416d30(arg1, *(uint32_t*)(arg2[6] + 8), arg2[8], arg2[9]);
00413767          }
00413767          
0041379e          sub_415a10(arg1, arg2, 0xffffffff);
004137b1          sub_416d30(arg1, *(uint32_t*)(arg2[6] + 8), arg2[8], 0xffffffff);
004137bc          result = arg2[8] - 1;
004137bd          arg2[8] = result;
0041375b      }
0041375b      
004137c2      return result;
00413750  }

004137c3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

004137d0    int32_t sub_4137d0(int32_t* arg1, int32_t* arg2)

004137d0  {
004137dc      sub_413090(arg1, arg2);
004137dc      
004137ec      if (arg2[8] > 0x3ffff)
004137fc          sub_413620(arg1[0xc], 0x3ffff, "items in a constructor");
004137fc      
0041380b      int32_t result = arg2[9] + 1;
0041380c      arg2[8] += 1;
0041380f      arg2[9] = result;
00413814      return result;
004137d0  }

00413815                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00413820    void* sub_413820(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4)

00413820  {
00413835      void* var_23c;
00413835      sub_4128a0(arg1, &var_23c);
00413848      *(uint32_t*)((char*)var_23c + 0x3c) = arg4;
0041384b      sub_413020(arg1, 0x28);
0041384b      
0041385c      if (arg3)
0041385c      {
00413872          sub_4138e0(arg1, sub_406340(arg1, "self", 4), 0);
0041387a          sub_4139e0(arg1, 1);
0041385c      }
0041385c      
00413883      sub_413b20(arg1);
0041388b      sub_413020(arg1, 0x29);
00413891      sub_412bb0(arg1);
004138a9      *(uint32_t*)((char*)var_23c + 0x40) = arg1[1];
004138ac      sub_412df0(arg1, 0x106, 0x109, arg4);
004138b2      sub_412960(arg1);
004138d5      return sub_413a30(arg1, &var_23c, arg2);
00413820  }

004138d6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

004138e0    int32_t sub_4138e0(void* arg1, void* arg2, int32_t arg3)

004138e0  {
004138ed      int32_t* esi = *(uint32_t*)((char*)arg1 + 0x30);
004138f0      int32_t eax;
004138f0      (uint8_t)eax = *(uint8_t*)((char*)esi + 0x32);
004138f0      
004138fd      if (eax + arg3 + 1 > 0xc8)
0041390a          sub_413620(esi, 0xc8, "local variables");
0041390a      
00413918      int16_t result = sub_413940(arg1, arg2);
00413922      int32_t ecx_1;
00413922      (uint8_t)ecx_1 = *(uint8_t*)((char*)esi + 0x32);
00413928      *(uint16_t*)((char*)esi + ((ecx_1 + arg3) << 1) + 0xac) = result;
00413932      return result;
004138e0  }

00413933                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00413940    int32_t sub_413940(void* arg1, void* arg2)

00413940  {
00413940      void* ecx = arg1;
00413947      int32_t* ebp = *(uint32_t*)((char*)ecx + 0x30);
0041394b      void* edi = *(uint32_t*)ebp;
00413952      int32_t i = *(uint32_t*)((char*)edi + 0x38);
00413952      
0041395b      if ((int32_t)ebp[0xc] + 1 > i)
0041395b      {
00413972          int32_t eax_3 = sub_404c50(*(uint32_t*)((char*)ecx + 0x34), 
00413972              *(uint32_t*)((char*)edi + 0x18), (char*)edi + 0x38, 0xc, 0x7fff, 
00413972              "too many local variables");
00413977          ecx = arg1;
0041397e          *(uint32_t*)((char*)edi + 0x18) = eax_3;
0041395b      }
0041395b      
00413983      if (i < *(uint32_t*)((char*)edi + 0x38))
00413983      {
00413988          int32_t eax_5 = i * 0xc;
00413988          
0041399d          do
0041399d          {
0041398e              i += 1;
0041398f              *(uint32_t*)(*(uint32_t*)((char*)edi + 0x18) + eax_5) = 0;
00413998              eax_5 += 0xc;
0041399d          } while (i < *(uint32_t*)((char*)edi + 0x38));
00413983      }
00413983      
004139ad      *(uint32_t*)(*(uint32_t*)((char*)edi + 0x18) + (int32_t)ebp[0xc] * 0xc) = arg2;
004139b0      int32_t edx_4;
004139b0      (uint8_t)edx_4 = *(uint8_t*)((char*)arg2 + 5);
004139b0      
004139bc      if ((uint8_t)edx_4 & 3 && *(uint8_t*)((char*)edi + 5) & 4)
004139c4          sub_404b60(*(uint32_t*)((char*)ecx + 0x34), edi, arg2);
004139c4      
004139cc      (uint16_t)ecx = ebp[0xc];
004139d6      ebp[0xc] = (uint16_t)ecx + 1;
004139dc      return (int32_t)(uint16_t)ecx;
00413940  }

004139dd                                                                                         90 90 90                               ...

004139e0    void* sub_4139e0(void* arg1, int32_t arg2)

004139e0  {
004139e4      int32_t i_1 = arg2;
004139e8      int32_t* ecx = *(uint32_t*)((char*)arg1 + 0x30);
004139eb      void* result;
004139eb      (uint8_t)result = *(uint8_t*)((char*)ecx + 0x32);
004139ee      (uint8_t)result += (uint8_t)i_1;
004139f2      *(uint8_t*)((char*)ecx + 0x32) = (uint8_t)result;
004139f2      
004139f5      if (i_1)
004139f5      {
00413a1c          int32_t i;
00413a1c          
00413a1c          do
00413a1c          {
004139fe              int32_t eax;
004139fe              (uint8_t)eax = *(uint8_t*)((char*)ecx + 0x32);
00413a05              int32_t esi_2 = eax - i_1;
00413a07              i = i_1;
00413a07              i_1 -= 1;
00413a08              int32_t eax_1;
00413a08              (uint16_t)eax_1 = *(uint16_t*)((char*)ecx + (esi_2 << 1) + 0xac);
00413a15              result = eax_1 * 3;
00413a18              *(uint32_t*)(*(uint32_t*)(*(uint32_t*)ecx + 0x18) + (result << 2) + 4) =
00413a18                  ecx[6];
00413a1c          } while (i != 1);
004139f5      }
004139f5      
00413a20      return result;
004139e0  }

00413a21     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00413a30    void* sub_413a30(void* arg1, void** arg2, int32_t* arg3)

00413a30  {
00413a30      void* ecx = arg1;
00413a38      int32_t* edi = *(uint32_t*)((char*)ecx + 0x30);
00413a3b      void* ebx = *(uint32_t*)edi;
00413a41      int32_t i = *(uint32_t*)((char*)ebx + 0x34);
00413a41      
00413a49      if (edi[0xb] + 1 > i)
00413a49      {
00413a60          int32_t eax_3 = sub_404c50(*(uint32_t*)((char*)ecx + 0x34), 
00413a60              *(uint32_t*)((char*)ebx + 0x10), (char*)ebx + 0x34, 4, 0x3ffff, 
00413a60              "constant table overflow");
00413a65          ecx = arg1;
00413a6c          *(uint32_t*)((char*)ebx + 0x10) = eax_3;
00413a49      }
00413a49      
00413a72      while (i < *(uint32_t*)((char*)ebx + 0x34))
00413a72      {
00413a77          i += 1;
00413a78          *(uint32_t*)(*(uint32_t*)((char*)ebx + 0x10) + (i << 2) - 4) = 0;
00413a72      }
00413a72      
00413a94      *(uint32_t*)(*(uint32_t*)((char*)ebx + 0x10) + (edi[0xb] << 2)) = *(uint32_t*)arg2;
00413a9b      edi[0xb] += 1;
00413a9e      void* eax_6 = *(uint32_t*)arg2;
00413a9e      
00413aab      if (*(uint8_t*)((char*)eax_6 + 5) & 3 && *(uint8_t*)((char*)ebx + 5) & 4)
00413ab3          sub_404b60(*(uint32_t*)((char*)ecx + 0x34), ebx, eax_6);
00413ab3      
00413ad2      sub_4133a0(arg3, 0xb, sub_416d00(edi, 0x24, 0, edi[0xb] - 1));
00413ad7      void* result = *(uint32_t*)arg2;
00413add      int32_t ebx_1 = 0;
00413add      
00413ae4      if (*(uint8_t*)((char*)result + 0x48) > 0)
00413ae4      {
00413ae6          void* esi_3 = (char*)arg2 + 0x33;
00413b17          int32_t ecx_5;
00413b17          
00413b17          do
00413b17          {
00413ae9              int32_t edx_5;
00413ae9              (uint8_t)edx_5 = *(uint8_t*)esi_3;
00413aed              int32_t ecx_4;
00413aed              (uint8_t)ecx_4 = *(uint8_t*)((char*)esi_3 + 1);
00413af0              (uint8_t)edx_5 -= 6;
00413af3              char temp0_1 = (uint8_t)edx_5;
00413af3              (uint8_t)edx_5 = -((uint8_t)edx_5);
00413b01              sub_416bf0(edi, (edx_5 - edx_5) & 4, 0, ecx_4, 0);
00413b06              result = *(uint32_t*)arg2;
00413b0e              ebx_1 += 1;
00413b0f              (uint8_t)ecx_5 = *(uint8_t*)((char*)result + 0x48);
00413b12              esi_3 += 2;
00413b17          } while (ebx_1 < ecx_5);
00413ae4      }
00413ae4      
00413b1d      return result;
00413a30  }

00413b1e                                                                                            90 90                                ..

00413b20    int32_t sub_413b20(int32_t* arg1)

00413b20  {
00413b28      int32_t edi = 0;
00413b2a      int32_t* ebx = arg1[0xc];
00413b2d      void* ebp = *(uint32_t*)ebx;
00413b2f      *(uint8_t*)((char*)ebp + 0x4a) = 0;
00413b2f      
00413b39      if (arg1[4] != 0x29)
00413b39      {
00413bb2          int32_t i;
00413bb2          
00413bb2          do
00413bb2          {
00413b3b              int32_t eax_1 = arg1[4];
00413b3b              
00413b43              if (eax_1 == 0x117)
00413b43              {
00413b74                  sub_406420(arg1);
00413b7c                  int32_t eax_7 = edi;
00413b7e                  edi += 1;
00413b92                  sub_4138e0(arg1, sub_406340(arg1, "arg", 3), eax_7);
00413b9a                  *(uint8_t*)((char*)ebp + 0x4a) = 7;
00413b43              }
00413b43              else if (eax_1 == 0x11d)
00413b48              {
00413b5a                  int32_t eax_5 = edi;
00413b5c                  edi += 1;
00413b69                  sub_4138e0(arg1, sub_4136a0(arg1), eax_5);
00413b48              }
00413b48              else
00413b50                  sub_406320(arg1, "<name> or '...' expected");
00413b50              
00413ba3              if (*(uint8_t*)((char*)ebp + 0x4a))
00413ba3                  break;
00413ba3              
00413ba8              i = sub_412c00(arg1, 0x2c);
00413bb2          } while (i);
00413b39      }
00413b39      
00413bb6      sub_4139e0(arg1, edi);
00413bc7      *(uint8_t*)((char*)ebp + 0x49) =
00413bc7          *(uint8_t*)((char*)ebx + 0x32) - (*(uint8_t*)((char*)ebp + 0x4a) & 1);
00413bca      int32_t edx;
00413bca      (uint8_t)edx = *(uint8_t*)((char*)ebx + 0x32);
00413bdb      return sub_415890(ebx, edx);
00413b20  }

00413bdc                                                                                      90 90 90 90                              ....

00413be0    int32_t sub_413be0(int32_t* arg1, int32_t* arg2)

00413be0  {
00413bee      int32_t* ebx = arg1[0xc];
00413bf3      sub_413f60(arg1, arg2);
00413c06      int32_t i;
00413c06      
00413c06      for (i = arg1[4] - 0x28; i <= 0xf6; i = arg1[4] - 0x28)
00413c06      {
00413c0e          int32_t ecx_1;
00413c0e          (uint8_t)ecx_1 = lookup_table_413cb0[i];
00413c0e          
00413c14          switch (ecx_1)
00413c14          {
00413c75              case 0:
00413c75              {
00413c75                  sub_415c00(ebx, arg2);
00413c7c                  sub_413df0(arg1, arg2);
00413c75                  break;
00413c75              }
00413c1d              case 1:
00413c1d              {
00413c1d                  sub_413db0(arg1, arg2);
00413c1d                  break;
00413c1d              }
00413c4b              case 2:
00413c4b              {
00413c4b                  sub_406420(arg1);
00413c56                  void var_18;
00413c56                  sub_413680(arg1, &var_18);
00413c62                  sub_416190(ebx, arg2, &var_18);
00413c69                  sub_413df0(arg1, arg2);
00413c4b                  break;
00413c4b              }
00413c29              case 3:
00413c29              {
00413c29                  sub_415f00(ebx, arg2);
00413c34                  void var_30;
00413c34                  sub_4136d0(arg1, &var_30);
00413c40                  sub_4163b0(ebx, arg2, &var_30);
00413c29                  break;
00413c29              }
00413c14              case 4:
00413c14              {
00413c14                  break;
00413c14                  break;
00413c14              }
00413c14          }
00413c06      }
00413c06      
00413c9b      return i;
00413be0  }

00413c9c  uint32_t jump_table_413c9c[0x5] = 
00413c9c  {
00413c9c      [0x0] =  0x00413c73
00413ca0      [0x1] =  0x00413c1b
00413ca4      [0x2] =  0x00413c4a
00413ca8      [0x3] =  0x00413c27
00413cac      [0x4] =  0x00413c95
00413cb0  }
00413cb0  uint8_t lookup_table_413cb0[0xf7] = 
00413cb0  {
00413cb0      [0x00] =  0x00
00413cb1      [0x01] =  0x04
00413cb2      [0x02] =  0x04
00413cb3      [0x03] =  0x04
00413cb4      [0x04] =  0x04
00413cb5      [0x05] =  0x04
00413cb6      [0x06] =  0x01
00413cb7      [0x07] =  0x04
00413cb8      [0x08] =  0x04
00413cb9      [0x09] =  0x04
00413cba      [0x0a] =  0x04
00413cbb      [0x0b] =  0x04
00413cbc      [0x0c] =  0x04
00413cbd      [0x0d] =  0x04
00413cbe      [0x0e] =  0x04
00413cbf      [0x0f] =  0x04
00413cc0      [0x10] =  0x04
00413cc1      [0x11] =  0x04
00413cc2      [0x12] =  0x02
00413cc3      [0x13] =  0x04
00413cc4      [0x14] =  0x04
00413cc5      [0x15] =  0x04
00413cc6      [0x16] =  0x04
00413cc7      [0x17] =  0x04
00413cc8      [0x18] =  0x04
00413cc9      [0x19] =  0x04
00413cca      [0x1a] =  0x04
00413ccb      [0x1b] =  0x04
00413ccc      [0x1c] =  0x04
00413ccd      [0x1d] =  0x04
00413cce      [0x1e] =  0x04
00413ccf      [0x1f] =  0x04
00413cd0      [0x20] =  0x04
00413cd1      [0x21] =  0x04
00413cd2      [0x22] =  0x04
00413cd3      [0x23] =  0x04
00413cd4      [0x24] =  0x04
00413cd5      [0x25] =  0x04
00413cd6      [0x26] =  0x04
00413cd7      [0x27] =  0x04
00413cd8      [0x28] =  0x04
00413cd9      [0x29] =  0x04
00413cda      [0x2a] =  0x04
00413cdb      [0x2b] =  0x04
00413cdc      [0x2c] =  0x04
00413cdd      [0x2d] =  0x04
00413cde      [0x2e] =  0x04
00413cdf      [0x2f] =  0x04
00413ce0      [0x30] =  0x04
00413ce1      [0x31] =  0x04
00413ce2      [0x32] =  0x04
00413ce3      [0x33] =  0x03
00413ce4      [0x34] =  0x04
00413ce5      [0x35] =  0x04
00413ce6      [0x36] =  0x04
00413ce7      [0x37] =  0x04
00413ce8      [0x38] =  0x04
00413ce9      [0x39] =  0x04
00413cea      [0x3a] =  0x04
00413ceb      [0x3b] =  0x04
00413cec      [0x3c] =  0x04
00413ced      [0x3d] =  0x04
00413cee      [0x3e] =  0x04
00413cef      [0x3f] =  0x04
00413cf0      [0x40] =  0x04
00413cf1      [0x41] =  0x04
00413cf2      [0x42] =  0x04
00413cf3      [0x43] =  0x04
00413cf4      [0x44] =  0x04
00413cf5      [0x45] =  0x04
00413cf6      [0x46] =  0x04
00413cf7      [0x47] =  0x04
00413cf8      [0x48] =  0x04
00413cf9      [0x49] =  0x04
00413cfa      [0x4a] =  0x04
00413cfb      [0x4b] =  0x04
00413cfc      [0x4c] =  0x04
00413cfd      [0x4d] =  0x04
00413cfe      [0x4e] =  0x04
00413cff      [0x4f] =  0x04
00413d00      [0x50] =  0x04
00413d01      [0x51] =  0x04
00413d02      [0x52] =  0x04
00413d03      [0x53] =  0x00
00413d04      [0x54] =  0x04
00413d05      [0x55] =  0x04
00413d06      [0x56] =  0x04
00413d07      [0x57] =  0x04
00413d08      [0x58] =  0x04
00413d09      [0x59] =  0x04
00413d0a      [0x5a] =  0x04
00413d0b      [0x5b] =  0x04
00413d0c      [0x5c] =  0x04
00413d0d      [0x5d] =  0x04
00413d0e      [0x5e] =  0x04
00413d0f      [0x5f] =  0x04
00413d10      [0x60] =  0x04
00413d11      [0x61] =  0x04
00413d12      [0x62] =  0x04
00413d13      [0x63] =  0x04
00413d14      [0x64] =  0x04
00413d15      [0x65] =  0x04
00413d16      [0x66] =  0x04
00413d17      [0x67] =  0x04
00413d18      [0x68] =  0x04
00413d19      [0x69] =  0x04
00413d1a      [0x6a] =  0x04
00413d1b      [0x6b] =  0x04
00413d1c      [0x6c] =  0x04
00413d1d      [0x6d] =  0x04
00413d1e      [0x6e] =  0x04
00413d1f      [0x6f] =  0x04
00413d20      [0x70] =  0x04
00413d21      [0x71] =  0x04
00413d22      [0x72] =  0x04
00413d23      [0x73] =  0x04
00413d24      [0x74] =  0x04
00413d25      [0x75] =  0x04
00413d26      [0x76] =  0x04
00413d27      [0x77] =  0x04
00413d28      [0x78] =  0x04
00413d29      [0x79] =  0x04
00413d2a      [0x7a] =  0x04
00413d2b      [0x7b] =  0x04
00413d2c      [0x7c] =  0x04
00413d2d      [0x7d] =  0x04
00413d2e      [0x7e] =  0x04
00413d2f      [0x7f] =  0x04
00413d30      [0x80] =  0x04
00413d31      [0x81] =  0x04
00413d32      [0x82] =  0x04
00413d33      [0x83] =  0x04
00413d34      [0x84] =  0x04
00413d35      [0x85] =  0x04
00413d36      [0x86] =  0x04
00413d37      [0x87] =  0x04
00413d38      [0x88] =  0x04
00413d39      [0x89] =  0x04
00413d3a      [0x8a] =  0x04
00413d3b      [0x8b] =  0x04
00413d3c      [0x8c] =  0x04
00413d3d      [0x8d] =  0x04
00413d3e      [0x8e] =  0x04
00413d3f      [0x8f] =  0x04
00413d40      [0x90] =  0x04
00413d41      [0x91] =  0x04
00413d42      [0x92] =  0x04
00413d43      [0x93] =  0x04
00413d44      [0x94] =  0x04
00413d45      [0x95] =  0x04
00413d46      [0x96] =  0x04
00413d47      [0x97] =  0x04
00413d48      [0x98] =  0x04
00413d49      [0x99] =  0x04
00413d4a      [0x9a] =  0x04
00413d4b      [0x9b] =  0x04
00413d4c      [0x9c] =  0x04
00413d4d      [0x9d] =  0x04
00413d4e      [0x9e] =  0x04
00413d4f      [0x9f] =  0x04
00413d50      [0xa0] =  0x04
00413d51      [0xa1] =  0x04
00413d52      [0xa2] =  0x04
00413d53      [0xa3] =  0x04
00413d54      [0xa4] =  0x04
00413d55      [0xa5] =  0x04
00413d56      [0xa6] =  0x04
00413d57      [0xa7] =  0x04
00413d58      [0xa8] =  0x04
00413d59      [0xa9] =  0x04
00413d5a      [0xaa] =  0x04
00413d5b      [0xab] =  0x04
00413d5c      [0xac] =  0x04
00413d5d      [0xad] =  0x04
00413d5e      [0xae] =  0x04
00413d5f      [0xaf] =  0x04
00413d60      [0xb0] =  0x04
00413d61      [0xb1] =  0x04
00413d62      [0xb2] =  0x04
00413d63      [0xb3] =  0x04
00413d64      [0xb4] =  0x04
00413d65      [0xb5] =  0x04
00413d66      [0xb6] =  0x04
00413d67      [0xb7] =  0x04
00413d68      [0xb8] =  0x04
00413d69      [0xb9] =  0x04
00413d6a      [0xba] =  0x04
00413d6b      [0xbb] =  0x04
00413d6c      [0xbc] =  0x04
00413d6d      [0xbd] =  0x04
00413d6e      [0xbe] =  0x04
00413d6f      [0xbf] =  0x04
00413d70      [0xc0] =  0x04
00413d71      [0xc1] =  0x04
00413d72      [0xc2] =  0x04
00413d73      [0xc3] =  0x04
00413d74      [0xc4] =  0x04
00413d75      [0xc5] =  0x04
00413d76      [0xc6] =  0x04
00413d77      [0xc7] =  0x04
00413d78      [0xc8] =  0x04
00413d79      [0xc9] =  0x04
00413d7a      [0xca] =  0x04
00413d7b      [0xcb] =  0x04
00413d7c      [0xcc] =  0x04
00413d7d      [0xcd] =  0x04
00413d7e      [0xce] =  0x04
00413d7f      [0xcf] =  0x04
00413d80      [0xd0] =  0x04
00413d81      [0xd1] =  0x04
00413d82      [0xd2] =  0x04
00413d83      [0xd3] =  0x04
00413d84      [0xd4] =  0x04
00413d85      [0xd5] =  0x04
00413d86      [0xd6] =  0x04
00413d87      [0xd7] =  0x04
00413d88      [0xd8] =  0x04
00413d89      [0xd9] =  0x04
00413d8a      [0xda] =  0x04
00413d8b      [0xdb] =  0x04
00413d8c      [0xdc] =  0x04
00413d8d      [0xdd] =  0x04
00413d8e      [0xde] =  0x04
00413d8f      [0xdf] =  0x04
00413d90      [0xe0] =  0x04
00413d91      [0xe1] =  0x04
00413d92      [0xe2] =  0x04
00413d93      [0xe3] =  0x04
00413d94      [0xe4] =  0x04
00413d95      [0xe5] =  0x04
00413d96      [0xe6] =  0x04
00413d97      [0xe7] =  0x04
00413d98      [0xe8] =  0x04
00413d99      [0xe9] =  0x04
00413d9a      [0xea] =  0x04
00413d9b      [0xeb] =  0x04
00413d9c      [0xec] =  0x04
00413d9d      [0xed] =  0x04
00413d9e      [0xee] =  0x04
00413d9f      [0xef] =  0x04
00413da0      [0xf0] =  0x04
00413da1      [0xf1] =  0x04
00413da2      [0xf2] =  0x04
00413da3      [0xf3] =  0x04
00413da4      [0xf4] =  0x04
00413da5      [0xf5] =  0x04
00413da6      [0xf6] =  0x00
00413da7  }

00413da7                       90 90 90 90 90 90 90 90 90                                                         .........

00413db0    int32_t sub_413db0(int32_t* arg1, int32_t* arg2)

00413db0  {
00413dbf      int32_t* edi = arg1[0xc];
00413dc3      sub_415f00(edi, arg2);
00413dc9      sub_406420(arg1);
00413dd4      void var_18;
00413dd4      sub_413680(arg1, &var_18);
00413dee      return sub_4163b0(edi, arg2, &var_18);
00413db0  }

00413def                                               90                                                                 .

00413df0    int32_t sub_413df0(int32_t* arg1, int32_t* arg2)

00413df0  {
00413dfa      int32_t eax = arg1[4];
00413dfd      int32_t* edi = arg1[0xc];
00413e00      int32_t ebx = arg1[1];
00413e06      int32_t var_18;
00413e06      
00413e06      if (eax == 0x28)
00413e06      {
00413e53          if (ebx != arg1[2])
00413e5b              sub_406320(arg1, "ambiguous syntax (function call x new statement)");
00413e5b          
00413e64          sub_406420(arg1);
00413e64          
00413e72          if (arg1[4] != 0x29)
00413e72          {
00413e84              sub_413f10(arg1, &var_18);
00413e91              sub_415a10(edi, &var_18, 0xffffffff);
00413e72          }
00413e72          else
00413e74              var_18 = 0;
00413e74          
00413e9f          sub_412df0(arg1, 0x29, 0x28, ebx);
00413e06      }
00413e06      else if (eax == 0x7b)
00413e46          sub_4133f0(arg1, &var_18);
00413e0b      else
00413e0b      {
00413e12          if (eax != 0x11e)
00413e28              return sub_406320(arg1, "function arguments expected");
00413e28          
00413e33          sub_4133c0(arg1, &var_18, arg1[6]);
00413e39          sub_406420(arg1);
00413e0b      }
00413e0b      
00413ea7      int32_t eax_4 = var_18;
00413eb3      int32_t esi_1 = arg2[2];
00413ebb      int32_t eax_7;
00413ebb      
00413ebb      if (eax_4 == 0xd || eax_4 == 0xe)
00413ed7          eax_7 = 0xffffffff;
00413ebb      else
00413ebb      {
00413ebf          if (eax_4)
00413ec7              sub_415c00(edi, &var_18);
00413ec7          
00413ed4          eax_7 = edi[9] - esi_1 - 1;
00413ebb      }
00413ebb      
00413eeb      sub_4133a0(arg2, 0xd, sub_416bf0(edi, 0x1c, esi_1, eax_7 + 1, 2));
00413ef2      int32_t result = sub_416bd0(edi, ebx);
00413efb      edi[9] = esi_1 + 1;
00413f05      return result;
00413df0  }

00413f06                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00413f10    int32_t sub_413f10(int32_t* arg1, int32_t* arg2)

00413f10  {
00413f1b      int32_t result = 1;
00413f22      sub_413090(arg1, arg2);
00413f22      
00413f34      if (sub_412c00(arg1, 0x2c))
00413f34      {
00413f55          int32_t i;
00413f55          
00413f55          do
00413f55          {
00413f3b              sub_415c00(arg1[0xc], arg2);
00413f42              sub_413090(arg1, arg2);
00413f4a              result += 1;
00413f4b              i = sub_412c00(arg1, 0x2c);
00413f55          } while (i);
00413f34      }
00413f34      
00413f5c      return result;
00413f10  }

00413f5d                                                                                         90 90 90                               ...

00413f60    int32_t* sub_413f60(int32_t* arg1, int32_t* arg2)

00413f60  {
00413f65      int32_t eax = arg1[4];
00413f65      
00413f6b      if (eax == 0x28)
00413f6b      {
00413f96          int32_t edi = arg1[1];
00413f9a          sub_406420(arg1);
00413fa5          sub_413090(arg1, arg2);
00413fb0          sub_412df0(arg1, 0x29, 0x28, edi);
00413fc5          return sub_415b00(arg1[0xc], arg2);
00413f6b      }
00413f6b      
00413f72      if (eax == 0x11d)
00413f93          return sub_413fd0(arg1, arg2);
00413f93      
00413f83      return sub_406320(arg1, "unexpected symbol");
00413f60  }

00413fc6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00413fd0    int32_t sub_413fd0(int32_t* arg1, int32_t* arg2)

00413fd0  {
00413fd8      void* eax = sub_4136a0(arg1);
00413fe1      void* edi_1 = arg1[0xc];
00413feb      int32_t result = sub_414010(edi_1, eax, arg2, 1);
00413feb      
00413ff6      if (result == 8)
00413ff6      {
00413ffa          result = sub_4158b0(edi_1, eax);
00414002          arg2[2] = result;
00413ff6      }
00413ff6      
00414008      return result;
00413fd0  }

00414009                             90 90 90 90 90 90 90                                                           .......

00414010    int32_t sub_414010(int32_t* arg1, void* arg2, int32_t* arg3, int32_t arg4)

00414010  {
00414019      if (!arg1)
00414019      {
00414027          sub_4133a0(arg3, 8, 0xff);
00414037          return 8;
00414019      }
00414019      
0041403e      int32_t eax_2 = sub_4141f0(arg1, arg2);
0041403e      
0041404a      if (eax_2 >= 0)
0041404a      {
00414054          sub_4133a0(arg3, 6, eax_2);
00414054          
00414062          if (!arg4)
00414066              sub_414230(arg1, eax_2);
00414066          
00414076          return 6;
0041404a      }
0041404a      
00414083      int32_t result = sub_414010(arg1[2], arg2, arg3, 0);
00414083      
0041408e      if (result == 8)
00414093          return result;
00414093      
0041409f      arg3[2] = sub_4140c0(arg1, arg2, arg3);
004140a2      *(uint32_t*)arg3 = 7;
004140b0      return 7;
00414010  }

004140b1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

004140c0    uint32_t sub_4140c0(int32_t* arg1, void* arg2, int32_t* arg3)

004140c0  {
004140c3      int32_t* ecx = arg1;
004140ca      void* esi = *(uint32_t*)ecx;
004140cf      int32_t ebp = 0;
004140d1      int32_t edx;
004140d1      (uint8_t)edx = *(uint8_t*)((char*)esi + 0x48);
004140d4      int32_t i = *(uint32_t*)((char*)esi + 0x24);
004140d4      
004140e0      if (edx > 0)
004140e0      {
004140e6          void* ecx_1 = &ecx[0xd];
004140e6          
00414113          do
00414113          {
004140f5              int32_t eax_3;
004140f5              (uint8_t)eax_3 = *(uint8_t*)((char*)ecx_1 - 1);
004140f5              
004140fa              if (eax_3 == *(uint32_t*)arg3)
004140fa              {
00414102                  int32_t eax_4;
00414102                  (uint8_t)eax_4 = *(uint8_t*)ecx_1;
00414102                  
00414107                  if (eax_4 == arg3[2])
004141e9                      return ebp;
004140fa              }
004140fa              
0041410d              ebp += 1;
0041410e              ecx_1 += 2;
00414113          } while (ebp < edx);
00414113          
00414119          ecx = arg1;
004140e0      }
004140e0      
00414121      if (edx + 1 > 0x3c)
00414121      {
0041412b          sub_413620(ecx, 0x3c, "upvalues");
00414130          ecx = arg1;
00414121      }
00414121      
0041413b      int32_t edx_2;
0041413b      (uint8_t)edx_2 = *(uint8_t*)((char*)esi + 0x48);
0041413b      
00414141      if (edx_2 + 1 > *(uint32_t*)((char*)esi + 0x24))
00414141      {
00414158          int32_t eax_7 = sub_404c50(ecx[4], *(uint32_t*)((char*)esi + 0x1c), 
00414158              (char*)esi + 0x24, 4, 0x7ffffffd, &data_4307a0);
0041415d          ecx = arg1;
00414164          *(uint32_t*)((char*)esi + 0x1c) = eax_7;
00414141      }
00414141      
00414169      while (i < *(uint32_t*)((char*)esi + 0x24))
00414169      {
0041416e          i += 1;
0041416f          *(uint32_t*)(*(uint32_t*)((char*)esi + 0x1c) + (i << 2) - 4) = 0;
00414169      }
00414169      
00414182      int32_t eax_9;
00414182      (uint8_t)eax_9 = *(uint8_t*)((char*)esi + 0x48);
0041418b      *(uint32_t*)(*(uint32_t*)((char*)esi + 0x1c) + (eax_9 << 2)) = arg2;
0041418e      int32_t edx_5;
0041418e      (uint8_t)edx_5 = *(uint8_t*)((char*)arg2 + 5);
0041418e      
0041419a      if ((uint8_t)edx_5 & 3 && *(uint8_t*)((char*)esi + 5) & 4)
0041419a      {
004141a2          sub_404b60(ecx[4], esi, arg2);
004141a7          ecx = arg1;
0041419a      }
0041419a      
004141b4      int32_t edx_6;
004141b4      (uint8_t)edx_6 = *(uint8_t*)((char*)esi + 0x48);
004141b8      (uint8_t)i = *(uint8_t*)arg3;
004141ba      *(uint8_t*)((char*)ecx + (edx_6 << 1) + 0x33) = (uint8_t)i;
004141be      int32_t* eax_12;
004141be      (uint8_t)eax_12 = arg3[2];
004141c3      int32_t edx_7;
004141c3      (uint8_t)edx_7 = *(uint8_t*)((char*)esi + 0x48);
004141c6      *(uint8_t*)((char*)ecx + (edx_7 << 1) + 0x34) = (uint8_t)eax_12;
004141ca      (uint8_t)ecx = *(uint8_t*)((char*)esi + 0x48);
004141cf      uint32_t eax_14 = (uint32_t)(uint8_t)ecx;
004141d4      (uint8_t)ecx += 1;
004141d6      *(uint8_t*)((char*)esi + 0x48) = (uint8_t)ecx;
004141df      return eax_14;
004140c0  }

004141ea                                90 90 90 90 90 90                                                            ......

004141f0    int32_t sub_4141f0(int32_t* arg1, int32_t arg2)

004141f0  {
004141f7      int32_t eax;
004141f7      (uint8_t)eax = *(uint8_t*)((char*)arg1 + 0x32);
004141fb      int32_t i = eax - 1;
004141fb      
004141fc      if (eax - 1 >= 0)
004141fc      {
00414207          void* edx_2 = (char*)arg1 + (i << 1) + 0xac;
00414207          
00414221          do
00414221          {
00414210              int32_t ecx;
00414210              (uint16_t)ecx = *(uint16_t*)edx_2;
00414210              
00414219              if (arg2 == *(uint32_t*)(*(uint32_t*)(*(uint32_t*)arg1 + 0x18) + ecx * 0xc))
00414228                  return i;
00414228              
0041421b              i -= 1;
0041421c              edx_2 -= 2;
00414221          } while (i >= 0);
004141fc      }
004141fc      
00414223      return 0xffffffff;
004141f0  }

00414229                             90 90 90 90 90 90 90                                                           .......

00414230    void** sub_414230(void* arg1, int32_t arg2)

00414230  {
00414234      void** result = *(uint32_t*)((char*)arg1 + 0x14);
00414234      
00414239      if (result)
00414239      {
00414241          while (true)
00414241          {
00414241              int32_t edx_1;
00414241              (uint8_t)edx_1 = result[2];
00414241              
00414246              if (edx_1 <= arg2)
00414246                  break;
00414246              
00414248              result = *(uint32_t*)result;
00414248              
0041424c              if (!result)
0041424e                  return result;
00414241          }
00414241          
00414251          if (result)
00414253              *(uint8_t*)((char*)result + 9) = 1;
00414239      }
00414239      
00414257      return result;
00414230  }

00414258                                                                          90 90 90 90 90 90 90 90                          ........

00414260    int32_t sub_414260(int32_t arg1) __pure

00414260  {
00414267      if (arg1 == 0x23)
00414284          return 2;
00414284      
0041426c      if (arg1 == 0x2d)
0041427e          return 0;
0041427e      
00414273      int32_t eax_1 = -((arg1 - 0x10e));
0041427b      return ((eax_1 - eax_1) & 2) + 1;
00414260  }

00414285                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00414290    int32_t sub_414290(int32_t arg1)

00414290  {
0041429c      if (arg1 - 0x25 <= 0xf6)
0041429c      {
004142a0          int32_t ecx_1;
004142a0          (uint8_t)ecx_1 =
004142a0              *(uint8_t*)(arg1 + &*(uint32_t*)((char*)jump_table_41430c[6])[3]);
004142a0          
004142a6          switch (ecx_1)
004142a6          {
004142c7              case 0:
004142c7              {
004142c7                  return 4;
004142c7                  break;
004142c7              }
004142bb              case 1:
004142bb              {
004142bb                  return 2;
004142bb                  break;
004142bb              }
004142af              case 2:
004142af              {
004142af                  return 0;
004142af                  break;
004142af              }
004142b5              case 3:
004142b5              {
004142b5                  return 1;
004142b5                  break;
004142b5              }
004142c1              case 4:
004142c1              {
004142c1                  return 3;
004142c1                  break;
004142c1              }
004142e5              case 5:
004142e5              {
004142e5                  return 9;
004142e5                  break;
004142e5              }
004142f1              case 6:
004142f1              {
004142f1                  return 0xb;
004142f1                  break;
004142f1              }
004142cd              case 7:
004142cd              {
004142cd                  return 5;
004142cd                  break;
004142cd              }
004142fd              case 8:
004142fd              {
004142fd                  return 0xd;
004142fd                  break;
004142fd              }
00414303              case 9:
00414303              {
00414303                  return 0xe;
00414303                  break;
00414303              }
004142d3              case 0xa:
004142d3              {
004142d3                  return 6;
004142d3                  break;
004142d3              }
004142df              case 0xb:
004142df              {
004142df                  return 8;
004142df                  break;
004142df              }
004142f7              case 0xc:
004142f7              {
004142f7                  return 0xc;
004142f7                  break;
004142f7              }
004142eb              case 0xd:
004142eb              {
004142eb                  return 0xa;
004142eb                  break;
004142eb              }
004142d9              case 0xe:
004142d9              {
004142d9                  return 7;
004142d9                  break;
004142d9              }
004142a6          }
0041429c      }
0041429c      
00414309      return 0xf;
00414290  }

0041430a                                8b ff                                                                        ..
0041430c  uint32_t jump_table_41430c[0x10] = 
0041430c  {
0041430c      [0x0] =  0x004142c2
00414310      [0x1] =  0x004142b6
00414314      [0x2] =  0x004142ad
00414318      [0x3] =  0x004142b0
0041431c      [0x4] =  0x004142bc
00414320      [0x5] =  0x004142e0
00414324      [0x6] =  0x004142ec
00414328      [0x7] =  0x004142c8
0041432c      [0x8] =  0x004142f8
00414330      [0x9] =  0x004142fe
00414334      [0xa] =  0x004142ce
00414338      [0xb] =  0x004142da
0041433c      [0xc] =  0x004142f2
00414340      [0xd] =  0x004142e6
00414344      [0xe] =  0x004142d4
00414348      [0xf] =  0x00414304
0041434c  }
0041434c  uint8_t lookup_table_41434c[0xf7] = 
0041434c  {
0041434c      [0x00] =  0x00
0041434d      [0x01] =  0x0f
0041434e      [0x02] =  0x0f
0041434f      [0x03] =  0x0f
00414350      [0x04] =  0x0f
00414351      [0x05] =  0x01
00414352      [0x06] =  0x02
00414353      [0x07] =  0x0f
00414354      [0x08] =  0x03
00414355      [0x09] =  0x0f
00414356      [0x0a] =  0x04
00414357      [0x0b] =  0x0f
00414358      [0x0c] =  0x0f
00414359      [0x0d] =  0x0f
0041435a      [0x0e] =  0x0f
0041435b      [0x0f] =  0x0f
0041435c      [0x10] =  0x0f
0041435d      [0x11] =  0x0f
0041435e      [0x12] =  0x0f
0041435f      [0x13] =  0x0f
00414360      [0x14] =  0x0f
00414361      [0x15] =  0x0f
00414362      [0x16] =  0x0f
00414363      [0x17] =  0x05
00414364      [0x18] =  0x0f
00414365      [0x19] =  0x06
00414366      [0x1a] =  0x0f
00414367      [0x1b] =  0x0f
00414368      [0x1c] =  0x0f
00414369      [0x1d] =  0x0f
0041436a      [0x1e] =  0x0f
0041436b      [0x1f] =  0x0f
0041436c      [0x20] =  0x0f
0041436d      [0x21] =  0x0f
0041436e      [0x22] =  0x0f
0041436f      [0x23] =  0x0f
00414370      [0x24] =  0x0f
00414371      [0x25] =  0x0f
00414372      [0x26] =  0x0f
00414373      [0x27] =  0x0f
00414374      [0x28] =  0x0f
00414375      [0x29] =  0x0f
00414376      [0x2a] =  0x0f
00414377      [0x2b] =  0x0f
00414378      [0x2c] =  0x0f
00414379      [0x2d] =  0x0f
0041437a      [0x2e] =  0x0f
0041437b      [0x2f] =  0x0f
0041437c      [0x30] =  0x0f
0041437d      [0x31] =  0x0f
0041437e      [0x32] =  0x0f
0041437f      [0x33] =  0x0f
00414380      [0x34] =  0x0f
00414381      [0x35] =  0x0f
00414382      [0x36] =  0x0f
00414383      [0x37] =  0x0f
00414384      [0x38] =  0x0f
00414385      [0x39] =  0x07
00414386      [0x3a] =  0x0f
00414387      [0x3b] =  0x0f
00414388      [0x3c] =  0x0f
00414389      [0x3d] =  0x0f
0041438a      [0x3e] =  0x0f
0041438b      [0x3f] =  0x0f
0041438c      [0x40] =  0x0f
0041438d      [0x41] =  0x0f
0041438e      [0x42] =  0x0f
0041438f      [0x43] =  0x0f
00414390      [0x44] =  0x0f
00414391      [0x45] =  0x0f
00414392      [0x46] =  0x0f
00414393      [0x47] =  0x0f
00414394      [0x48] =  0x0f
00414395      [0x49] =  0x0f
00414396      [0x4a] =  0x0f
00414397      [0x4b] =  0x0f
00414398      [0x4c] =  0x0f
00414399      [0x4d] =  0x0f
0041439a      [0x4e] =  0x0f
0041439b      [0x4f] =  0x0f
0041439c      [0x50] =  0x0f
0041439d      [0x51] =  0x0f
0041439e      [0x52] =  0x0f
0041439f      [0x53] =  0x0f
004143a0      [0x54] =  0x0f
004143a1      [0x55] =  0x0f
004143a2      [0x56] =  0x0f
004143a3      [0x57] =  0x0f
004143a4      [0x58] =  0x0f
004143a5      [0x59] =  0x0f
004143a6      [0x5a] =  0x0f
004143a7      [0x5b] =  0x0f
004143a8      [0x5c] =  0x0f
004143a9      [0x5d] =  0x0f
004143aa      [0x5e] =  0x0f
004143ab      [0x5f] =  0x0f
004143ac      [0x60] =  0x0f
004143ad      [0x61] =  0x0f
004143ae      [0x62] =  0x0f
004143af      [0x63] =  0x0f
004143b0      [0x64] =  0x0f
004143b1      [0x65] =  0x0f
004143b2      [0x66] =  0x0f
004143b3      [0x67] =  0x0f
004143b4      [0x68] =  0x0f
004143b5      [0x69] =  0x0f
004143b6      [0x6a] =  0x0f
004143b7      [0x6b] =  0x0f
004143b8      [0x6c] =  0x0f
004143b9      [0x6d] =  0x0f
004143ba      [0x6e] =  0x0f
004143bb      [0x6f] =  0x0f
004143bc      [0x70] =  0x0f
004143bd      [0x71] =  0x0f
004143be      [0x72] =  0x0f
004143bf      [0x73] =  0x0f
004143c0      [0x74] =  0x0f
004143c1      [0x75] =  0x0f
004143c2      [0x76] =  0x0f
004143c3      [0x77] =  0x0f
004143c4      [0x78] =  0x0f
004143c5      [0x79] =  0x0f
004143c6      [0x7a] =  0x0f
004143c7      [0x7b] =  0x0f
004143c8      [0x7c] =  0x0f
004143c9      [0x7d] =  0x0f
004143ca      [0x7e] =  0x0f
004143cb      [0x7f] =  0x0f
004143cc      [0x80] =  0x0f
004143cd      [0x81] =  0x0f
004143ce      [0x82] =  0x0f
004143cf      [0x83] =  0x0f
004143d0      [0x84] =  0x0f
004143d1      [0x85] =  0x0f
004143d2      [0x86] =  0x0f
004143d3      [0x87] =  0x0f
004143d4      [0x88] =  0x0f
004143d5      [0x89] =  0x0f
004143d6      [0x8a] =  0x0f
004143d7      [0x8b] =  0x0f
004143d8      [0x8c] =  0x0f
004143d9      [0x8d] =  0x0f
004143da      [0x8e] =  0x0f
004143db      [0x8f] =  0x0f
004143dc      [0x90] =  0x0f
004143dd      [0x91] =  0x0f
004143de      [0x92] =  0x0f
004143df      [0x93] =  0x0f
004143e0      [0x94] =  0x0f
004143e1      [0x95] =  0x0f
004143e2      [0x96] =  0x0f
004143e3      [0x97] =  0x0f
004143e4      [0x98] =  0x0f
004143e5      [0x99] =  0x0f
004143e6      [0x9a] =  0x0f
004143e7      [0x9b] =  0x0f
004143e8      [0x9c] =  0x0f
004143e9      [0x9d] =  0x0f
004143ea      [0x9e] =  0x0f
004143eb      [0x9f] =  0x0f
004143ec      [0xa0] =  0x0f
004143ed      [0xa1] =  0x0f
004143ee      [0xa2] =  0x0f
004143ef      [0xa3] =  0x0f
004143f0      [0xa4] =  0x0f
004143f1      [0xa5] =  0x0f
004143f2      [0xa6] =  0x0f
004143f3      [0xa7] =  0x0f
004143f4      [0xa8] =  0x0f
004143f5      [0xa9] =  0x0f
004143f6      [0xaa] =  0x0f
004143f7      [0xab] =  0x0f
004143f8      [0xac] =  0x0f
004143f9      [0xad] =  0x0f
004143fa      [0xae] =  0x0f
004143fb      [0xaf] =  0x0f
004143fc      [0xb0] =  0x0f
004143fd      [0xb1] =  0x0f
004143fe      [0xb2] =  0x0f
004143ff      [0xb3] =  0x0f
00414400      [0xb4] =  0x0f
00414401      [0xb5] =  0x0f
00414402      [0xb6] =  0x0f
00414403      [0xb7] =  0x0f
00414404      [0xb8] =  0x0f
00414405      [0xb9] =  0x0f
00414406      [0xba] =  0x0f
00414407      [0xbb] =  0x0f
00414408      [0xbc] =  0x0f
00414409      [0xbd] =  0x0f
0041440a      [0xbe] =  0x0f
0041440b      [0xbf] =  0x0f
0041440c      [0xc0] =  0x0f
0041440d      [0xc1] =  0x0f
0041440e      [0xc2] =  0x0f
0041440f      [0xc3] =  0x0f
00414410      [0xc4] =  0x0f
00414411      [0xc5] =  0x0f
00414412      [0xc6] =  0x0f
00414413      [0xc7] =  0x0f
00414414      [0xc8] =  0x0f
00414415      [0xc9] =  0x0f
00414416      [0xca] =  0x0f
00414417      [0xcb] =  0x0f
00414418      [0xcc] =  0x0f
00414419      [0xcd] =  0x0f
0041441a      [0xce] =  0x0f
0041441b      [0xcf] =  0x0f
0041441c      [0xd0] =  0x0f
0041441d      [0xd1] =  0x0f
0041441e      [0xd2] =  0x0f
0041441f      [0xd3] =  0x0f
00414420      [0xd4] =  0x0f
00414421      [0xd5] =  0x0f
00414422      [0xd6] =  0x0f
00414423      [0xd7] =  0x0f
00414424      [0xd8] =  0x0f
00414425      [0xd9] =  0x0f
00414426      [0xda] =  0x0f
00414427      [0xdb] =  0x0f
00414428      [0xdc] =  0x08
00414429      [0xdd] =  0x0f
0041442a      [0xde] =  0x0f
0041442b      [0xdf] =  0x0f
0041442c      [0xe0] =  0x0f
0041442d      [0xe1] =  0x0f
0041442e      [0xe2] =  0x0f
0041442f      [0xe3] =  0x0f
00414430      [0xe4] =  0x0f
00414431      [0xe5] =  0x0f
00414432      [0xe6] =  0x0f
00414433      [0xe7] =  0x0f
00414434      [0xe8] =  0x0f
00414435      [0xe9] =  0x0f
00414436      [0xea] =  0x09
00414437      [0xeb] =  0x0f
00414438      [0xec] =  0x0f
00414439      [0xed] =  0x0f
0041443a      [0xee] =  0x0f
0041443b      [0xef] =  0x0f
0041443c      [0xf0] =  0x0f
0041443d      [0xf1] =  0x0a
0041443e      [0xf2] =  0x0f
0041443f      [0xf3] =  0x0b
00414440      [0xf4] =  0x0c
00414441      [0xf5] =  0x0d
00414442      [0xf6] =  0x0e
00414443  }

00414443           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00414450    int32_t sub_414450(int32_t* arg1, int32_t arg2)

00414450  {
0041445b      int32_t* edi = arg1[0xc];
0041445f      int32_t eax = sub_415610(edi);
0041446e      void var_c;
0041446e      sub_412e90(edi, &var_c, 1);
0041447b      void var_18;
0041447b      sub_412e90(edi, &var_18, 0);
00414481      sub_406420(arg1);
00414487      sub_412bb0(arg1);
0041449c      sub_412df0(arg1, 0x114, 0x110, arg2);
004144a7      int32_t ebp = sub_413040(arg1);
004144a9      char var_f;
004144a9      int32_t eax_1;
004144a9      (uint8_t)eax_1 = var_f;
004144a9      
004144b2      if (!(uint8_t)eax_1)
004144b2      {
004144b5          sub_412ec0(edi);
004144c0          sub_415620(arg1[0xc], ebp, eax);
004144d8          return sub_412ec0(edi);
004144b2      }
004144b2      
004144da      sub_412f20(arg1);
004144e4      sub_4157e0(arg1[0xc], ebp);
004144ea      sub_412ec0(edi);
004144f4      int32_t* eax_4 = sub_4155b0(edi);
00414501      sub_415620(arg1[0xc], eax_4, eax);
00414519      return sub_412ec0(edi);
00414450  }

0041451a                                                                                90 90 90 90 90 90                            ......

00414520    int32_t sub_414520(int32_t* arg1, int32_t arg2)

00414520  {
00414531      int32_t* edi = arg1[0xc];
00414535      void var_c;
00414535      sub_412e90(edi, &var_c, 1);
0041453b      sub_406420(arg1);
00414541      void* eax = sub_4136a0(arg1);
00414546      int32_t ecx = arg1[4];
00414546      
00414553      if (ecx == 0x2c)
0041457e          sub_4147c0(arg1, eax);
00414553      else if (ecx == 0x3d)
00414572          sub_4145b0(arg1, eax, arg2);
00414558      else if (ecx == 0x10b)
0041457e          sub_4147c0(arg1, eax);
00414560      else
00414568          sub_406320(arg1, "'=' or 'in' expected");
00414568      
00414592      sub_412df0(arg1, 0x106, 0x108, arg2);
004145a6      return sub_412ec0(edi);
00414520  }

004145a7                       90 90 90 90 90 90 90 90 90                                                         .........

004145b0    int32_t sub_4145b0(int32_t* arg1, void* arg2, int32_t arg3)

004145b0  {
004145bb      void* edi = arg1[0xc];
004145c4      int32_t ebx = *(uint32_t*)((char*)edi + 0x24);
004145d1      sub_4138e0(arg1, sub_406340(arg1, "(for index)", 0xb), 0);
004145ed      sub_4138e0(arg1, sub_406340(arg1, "(for limit)", 0xb), 1);
00414609      sub_4138e0(arg1, sub_406340(arg1, "(for step)", 0xa), 2);
00414616      sub_4138e0(arg1, arg2, 3);
0041461e      sub_413020(arg1, 0x3d);
00414624      sub_414690(arg1);
0041462c      sub_413020(arg1, 0x2c);
00414632      sub_414690(arg1);
00414632      
00414644      if (!sub_412c00(arg1, 0x2c))
00414644      {
00414659          int32_t eax_5 = sub_4159d0(edi, 0, 0x3ff00000);
00414666          sub_416d00(edi, 1, *(uint32_t*)((char*)edi + 0x24), eax_5);
0041466e          sub_415890(edi, 1);
00414644      }
00414644      else
00414647          sub_414690(arg1);
00414647      
0041468c      return sub_4146d0(arg1, ebx, arg3, 1, 1);
004145b0  }

0041468d                                         90 90 90                                                               ...

00414690    int32_t sub_414690(int32_t* arg1)

00414690  {
0041469f      int32_t result_1;
0041469f      sub_413090(arg1, &result_1);
004146a7      int32_t result = result_1;
004146b1      sub_415c00(arg1[0xc], &result_1);
004146c0      return result;
00414690  }

004146c1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

004146d0    int32_t sub_4146d0(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)

004146d0  {
004146de      int32_t* esi = arg1[0xc];
004146e1      sub_4139e0(arg1, 3);
004146ec      sub_413020(arg1, 0x103);
004146fe      int32_t* eax_1;
004146fe      
004146fe      if (!arg5)
00414714          eax_1 = sub_4155b0(esi);
004146fe      else
00414709          eax_1 = sub_416d00(esi, 0x20, arg2, 0x1fffe);
00414709      
00414728      void var_c;
00414728      sub_412e90(esi, &var_c, 0);
00414733      sub_4139e0(arg1, arg4);
0041473a      sub_415890(esi, arg4);
00414740      sub_412e60(arg1);
00414746      sub_412ec0(esi);
00414751      sub_4157e0(esi, eax_1);
0041475f      int32_t* eax_3;
0041475f      
0041475f      if (!arg5)
0041477b          eax_3 = sub_416bf0(esi, 0x21, arg2, 0, arg4);
0041475f      else
0041476a          eax_3 = sub_416d00(esi, 0x1f, arg2, 0x1fffe);
0041476a      
0041478b      sub_416bd0(esi, arg3);
00414799      int32_t* eax_5;
00414799      
00414799      if (!arg5)
004147a0          eax_5 = sub_4155b0(esi);
00414799      else
0041479b          eax_5 = eax_3;
0041479b      
004147bf      return sub_415620(esi, eax_5, (char*)eax_1 + 1);
004146d0  }


004147c0    int32_t sub_4147c0(int32_t* arg1, void* arg2)

004147c0  {
004147cd      int32_t* ebx = arg1[0xc];
004147d8      int32_t* eax = ebx[9];
004147e9      sub_4138e0(arg1, sub_406340(arg1, "(for generator)", 0xf), 0);
00414805      sub_4138e0(arg1, sub_406340(arg1, "(for state)", 0xb), 1);
00414821      sub_4138e0(arg1, sub_406340(arg1, "(for control)", 0xd), 2);
0041482e      int32_t edi = 4;
00414833      sub_4138e0(arg1, arg2, 3);
00414833      
00414845      if (sub_412c00(arg1, 0x2c))
00414845      {
00414868          int32_t i;
00414868          
00414868          do
00414868          {
00414847              int32_t eax_5 = edi;
00414849              edi += 1;
00414856              sub_4138e0(arg1, sub_4136a0(arg1), eax_5);
0041485e              i = sub_412c00(arg1, 0x2c);
00414868          } while (i);
00414845      }
00414845      
00414870      sub_413020(arg1, 0x10b);
00414875      int32_t ebp = arg1[1];
00414892      void var_18;
00414892      sub_4148c0(arg1, 3, sub_413f10(arg1, &var_18), &var_18);
0041489a      sub_415850(ebx, 3);
004148bb      return sub_4146d0(arg1, eax, ebp, edi - 3, 0);
004147c0  }

004148bc                                                                                      90 90 90 90                              ....

004148c0    int32_t* sub_4148c0(void* arg1, int32_t arg2, int32_t arg3, int32_t* arg4)

004148c0  {
004148d3      int32_t* edi = *(uint32_t*)((char*)arg1 + 0x30);
004148d6      int32_t* result = *(uint32_t*)arg4;
004148d8      int32_t esi_1 = arg2 - arg3;
004148d8      
004148e2      if (result == 0xd || result == 0xe)
004148e2      {
0041490f          int32_t esi_2 = esi_1 + 1;
0041490f          
00414910          if (esi_1 + 1 < 0)
00414912              esi_2 = 0;
00414912          
00414917          result = sub_415a10(edi, arg4, esi_2);
00414917          
00414922          if (esi_2 > 1)
00414927              return sub_415890(edi, esi_2 - 1);
004148e2      }
004148e2      else
004148e2      {
004148e6          if (result)
004148ea              result = sub_415c00(edi, arg4);
004148ea          
004148f4          if (esi_1 > 0)
004148f4          {
004148f6              int32_t ebx_1 = edi[9];
004148fb              sub_415890(edi, esi_1);
0041490e              return sub_415520(edi, ebx_1, esi_1);
004148f4          }
004148e2      }
004148e2      
00414932      return result;
004148c0  }

00414933                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00414940    int32_t sub_414940(int32_t* arg1, int32_t arg2)

00414940  {
00414943      int32_t* edi = arg1;
00414948      arg1 = 0xffffffff;
00414950      int32_t* esi = edi[0xc];
00414958      int32_t ebx = sub_414a00(edi);
00414958      
00414965      while (edi[4] == 0x105)
00414965      {
00414974          sub_415800(esi, &arg1, sub_4155b0(esi));
0041497b          sub_4157e0(esi, ebx);
00414986          ebx = sub_414a00(edi);
00414965      }
00414965      
0041499c      if (edi[4] != 0x104)
004149cf          sub_415800(esi, &arg1, ebx);
0041499c      else
0041499c      {
004149ab          sub_415800(esi, &arg1, sub_4155b0(esi));
004149b2          sub_4157e0(esi, ebx);
004149b8          sub_406420(edi);
004149be          sub_412e60(edi);
0041499c      }
0041499c      
004149dd      sub_4157e0(esi, arg1);
004149fd      return sub_412df0(edi, 0x106, 0x10a, arg2);
00414940  }

004149fe                                                                                            90 90                                ..

00414a00    int32_t sub_414a00(int32_t* arg1)

00414a00  {
00414a07      sub_406420(arg1);
00414a0d      int32_t result = sub_413040(arg1);
00414a1a      sub_413020(arg1, 0x112);
00414a20      sub_412e60(arg1);
00414a2c      return result;
00414a00  }

00414a2d                                         90 90 90                                                               ...

00414a30    int32_t sub_414a30(int32_t* arg1)

00414a30  {
00414a3c      int32_t* esi = arg1[0xc];
00414a49      sub_4138e0(arg1, sub_4136a0(arg1), 0);
00414a59      void var_18;
00414a59      sub_4133a0(&var_18, 6, esi[9]);
00414a61      sub_415890(esi, 1);
00414a69      sub_4139e0(arg1, 1);
00414a7a      void var_30;
00414a7a      sub_413820(arg1, &var_30, 0, arg1[1]);
00414a8a      sub_4160d0(esi, &var_18, &var_30);
00414a94      int32_t eax_2;
00414a94      (uint8_t)eax_2 = *(uint8_t*)((char*)esi + 0x32);
00414a9c      int32_t eax_3;
00414a9c      (uint16_t)eax_3 = *(uint16_t*)((char*)esi + (eax_2 << 1) + 0xaa);
00414aac      int32_t result = esi[6];
00414ab0      *(uint32_t*)(*(uint32_t*)(*(uint32_t*)esi + 0x18) + eax_3 * 0xc + 4) = result;
00414ab7      return result;
00414a30  }

00414ab8                                                                          90 90 90 90 90 90 90 90                          ........

00414ac0    void* sub_414ac0(int32_t* arg1)

00414ac0  {
00414ac9      int32_t edi = 0;
00414aec      int32_t i;
00414aec      
00414aec      do
00414aec      {
00414acb          int32_t eax_1 = edi;
00414acd          edi += 1;
00414ada          sub_4138e0(arg1, sub_4136a0(arg1), eax_1);
00414ae2          i = sub_412c00(arg1, 0x2c);
00414aec      } while (i);
00414afb      int32_t var_18;
00414afb      int32_t eax_4;
00414afb      
00414afb      if (!sub_412c00(arg1, 0x3d))
00414afb      {
00414b0d          var_18 = 0;
00414b15          eax_4 = 0;
00414afb      }
00414afb      else
00414b03          eax_4 = sub_413f10(arg1, &var_18);
00414b03      
00414b1f      sub_4148c0(arg1, edi, eax_4, &var_18);
00414b33      return sub_4139e0(arg1, edi);
00414ac0  }

00414b34                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00414b40    int32_t sub_414b40(int32_t* arg1, int32_t arg2)

00414b40  {
00414b4a      sub_406420(arg1);
00414b66      void var_30;
00414b66      void var_18;
00414b66      sub_413820(arg1, &var_30, sub_414ba0(arg1, &var_18), arg2);
00414b79      sub_4160d0(arg1[0xc], &var_18, &var_30);
00414b90      return sub_416bd0(arg1[0xc], arg2);
00414b40  }

00414b91                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00414ba0    int32_t sub_414ba0(int32_t* arg1, int32_t* arg2)

00414ba0  {
00414bb0      sub_413fd0(arg1, arg2);
00414bb0      
00414bc2      while (arg1[4] == 0x2e)
00414bc6          sub_413db0(arg1, arg2);
00414bc6      
00414bd9      if (arg1[4] != 0x3a)
00414bf7          return 0;
00414bf7      
00414be2      sub_413db0(arg1, arg2);
00414bf0      return 1;
00414ba0  }

00414bf8                                                                          90 90 90 90 90 90 90 90                          ........

00414c00    int32_t* sub_414c00(int32_t* arg1)

00414c00  {
00414c0e      int32_t* edi = arg1[0xc];
00414c12      int32_t var_18;
00414c12      sub_413be0(arg1, &var_18);
00414c12      
00414c21      if (var_18 != 0xd)
00414c21      {
00414c4b          void* const var_20 = nullptr;
00414c60          return sub_414c70(arg1, &var_20, 1);
00414c21      }
00414c21      
00414c2b      int32_t edx = *(uint32_t*)(*(uint32_t*)edi + 0xc);
00414c37      int32_t var_10;
00414c37      int32_t* result = edx + (var_10 << 2);
00414c3a      int32_t ecx_2;
00414c3a      *(uint8_t*)((char*)ecx_2)[1] =
00414c3a          *(uint8_t*)((char*)(*(uint32_t*)(edx + (var_10 << 2)) & 0xff807fff))[1] | 0x40;
00414c3d      *(uint32_t*)result = ecx_2;
00414c42      return result;
00414c00  }

00414c61     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00414c70    int32_t* sub_414c70(int32_t* arg1, void** arg2, int32_t arg3)

00414c70  {
00414c7f      int32_t eax = arg2[2];
00414c7f      
00414c8d      if (eax < 6 || eax > 9)
00414c95          sub_406320(arg1, "syntax error");
00414c95      
00414caa      void var_38;
00414caa      
00414caa      if (!sub_412c00(arg1, 0x2c))
00414caa      {
00414cef          sub_413020(arg1, 0x3d);
00414cfa          int32_t eax_3 = sub_413f10(arg1, &var_38);
00414d0e          int32_t* var_4c_3 = &var_38;
00414d0e          
00414d0f          if (eax_3 == arg3)
00414d0f          {
00414d5a              sub_415aa0(arg1[0xc], var_4c_3);
00414d78              return sub_4160d0(arg1[0xc], &arg2[2], &var_38);
00414d0f          }
00414d0f          
00414d14          sub_4148c0(arg1, arg3, eax_3, var_4c_3);
00414d14          
00414d1e          if (eax_3 > arg3)
00414d1e          {
00414d20              void* eax_4 = arg1[0xc];
00414d25              *(uint32_t*)((char*)eax_4 + 0x24) += arg3 - eax_3;
00414d1e          }
00414caa      }
00414caa      else
00414caa      {
00414cb0          void** var_20 = arg2;
00414cb6          int32_t var_18;
00414cb6          sub_413be0(arg1, &var_18);
00414cb6          
00414cc5          if (var_18 == 6)
00414cce              sub_414d80(arg1, arg2, &var_18);
00414cce          
00414ce2          sub_414c70(arg1, &var_20, arg3 + 1);
00414caa      }
00414caa      
00414d37      sub_4133a0(&var_38, 0xc, *(uint32_t*)(arg1[0xc] + 0x24) - 1);
00414d55      return sub_4160d0(arg1[0xc], &arg2[2], &var_38);
00414c70  }

00414d79                                                                             90 90 90 90 90 90 90                           .......

00414d80    void** sub_414d80(void* arg1, void** arg2, void* arg3)

00414d80  {
00414d85      int32_t ecx = 0;
00414d88      int32_t* esi = *(uint32_t*)((char*)arg1 + 0x30);
00414d8b      void** i = arg2;
00414d91      int32_t edx = esi[9];
00414d91      
00414d94      if (i)
00414d94      {
00414dc5          do
00414dc5          {
00414d9f              if (i[2] == 9)
00414d9f              {
00414da7                  if (i[4] == *(uint32_t*)((char*)arg3 + 8))
00414da7                  {
00414da9                      ecx = 1;
00414dae                      i[4] = edx;
00414da7                  }
00414da7                  
00414db7                  if (i[5] == *(uint32_t*)((char*)arg3 + 8))
00414db7                  {
00414db9                      ecx = 1;
00414dbe                      i[5] = edx;
00414db7                  }
00414d9f              }
00414d9f              
00414dc1              i = *(uint32_t*)i;
00414dc5          } while (i);
00414dc5          
00414dca          if (ecx)
00414dca          {
00414dd7              sub_416bf0(esi, i, esi[9], *(uint32_t*)((char*)arg3 + 8), i);
00414ddf              return sub_415890(esi, 1);
00414dca          }
00414d94      }
00414d94      
00414de9      return i;
00414d80  }

00414dea                                90 90 90 90 90 90                                                            ......

00414df0    int32_t sub_414df0(int32_t* arg1)

00414df0  {
00414dfa      int32_t* esi = arg1[0xc];
00414dfd      sub_406420(arg1);
00414dfd      
00414e1a      if (sub_412c60(arg1[4]) || arg1[4] == 0x3b)
00414ee8          return sub_4155f0(esi, 0, 0);
00414ee8      
00414e26      int32_t var_18;
00414e26      int32_t eax_2 = sub_413f10(arg1, &var_18);
00414e2d      int32_t eax_3 = var_18;
00414e2d      
00414e3c      if (eax_3 != 0xd && eax_3 != 0xe)
00414e3c      {
00414e41          if (eax_2 == 1)
00414e61              return sub_4155f0(esi, sub_415f00(esi, &var_18), eax_2);
00414e61          
00414e68          sub_415c00(esi, &var_18);
00414e72          int32_t eax_6;
00414e72          (uint8_t)eax_6 = *(uint8_t*)((char*)esi + 0x32);
00414e85          return sub_4155f0(esi, eax_6, eax_2);
00414e3c      }
00414e3c      
00414e8e      sub_415a10(esi, &var_18, 0xffffffff);
00414e8e      
00414ea2      if (var_18 == 0xd && eax_2 == 1)
00414ea2      {
00414eaa          int32_t eax_9 = *(uint32_t*)(*(uint32_t*)esi + 0xc);
00414eb9          int32_t var_10;
00414eb9          *(uint32_t*)(eax_9 + (var_10 << 2)) =
00414eb9              (*(uint32_t*)(eax_9 + (var_10 << 2)) & 0xffffffdd) | 0x1d;
00414ea2      }
00414ea2      
00414ec0      int32_t eax_11;
00414ec0      (uint8_t)eax_11 = *(uint8_t*)((char*)esi + 0x32);
00414ed3      return sub_4155f0(esi, eax_11, 0xffffffff);
00414df0  }

00414ee9                             90 90 90 90 90 90 90                                                           .......

00414ef0    int32_t* sub_414ef0(void* arg1, int32_t arg2, int32_t arg3, char* arg4)

00414ef0  {
00414ef7      char eax = *(uint8_t*)arg4;
00414ef7      
00414eff      if (eax == 0x40 || eax == 0x3d)
00414f14          char* var_4_1 = &arg4[1];
00414eff      else if (eax != (*(uint8_t*)data_42b214))
00414f14          var_4_1 = arg4;
00414f07      else
00414f09          char* var_4 = "binary string";
00414f09      
00414f29      void* var_10 = arg1;
00414f2e      int32_t var_c = arg2;
00414f32      int32_t var_8 = arg3;
00414f36      sub_4154a0(&var_10);
00414f5a      return sub_414f60(&var_10, sub_405f60(arg1, "=?", 2));
00414ef0  }

00414f5b                                                                                   90 90 90 90 90                             .....

00414f60    int32_t* sub_414f60(int32_t* arg1, int32_t arg2)

00414f60  {
00414f69      int32_t* result = sub_404f80(*(uint32_t*)arg1);
00414f75      int32_t** eax_1 = *(uint32_t*)(*(uint32_t*)arg1 + 8);
00414f78      *(uint32_t*)eax_1 = result;
00414f7a      eax_1[2] = 9;
00414f81      void* eax_2 = *(uint32_t*)arg1;
00414f81      
00414f8e      if (*(uint32_t*)((char*)eax_2 + 0x1c) - *(uint32_t*)((char*)eax_2 + 8) <= 0x10)
00414f93          sub_405460(eax_2, 1);
00414f93      
00414f9b      void* eax_3 = *(uint32_t*)arg1;
00414f9e      *(uint32_t*)((char*)eax_3 + 8) += 0x10;
00414fa2      void** eax_4 = sub_4150f0(arg1);
00414faa      result[8] = eax_4;
00414faa      
00414faf      if (!eax_4)
00414fb5          result[8] = arg2;
00414fb5      
00414fbf      result[0xf] = sub_4150b0(arg1);
00414fc8      result[0x10] = sub_4150b0(arg1);
00414fd1      result[0x12] = sub_415060(arg1);
00414fda      *(uint8_t*)((char*)result + 0x49) = sub_415060(arg1);
00414fe3      *(uint8_t*)((char*)result + 0x4a) = sub_415060(arg1);
00414fed      *(uint8_t*)((char*)result + 0x4b) = sub_415060(arg1);
00414ff0      sub_415140(arg1, result);
00414ff7      sub_4151a0(arg1, result);
00414ffe      sub_415340(arg1, result);
00414ffe      
0041500e      if (!sub_40b1f0(result))
00415016          sub_415030(arg1, "bad code");
00415016      
0041501e      void* esi_1 = *(uint32_t*)arg1;
00415026      *(uint32_t*)((char*)esi_1 + 8) -= 0x10;
0041502d      return result;
00414f60  }

0041502e                                            90 90                                                                ..

00415030    int32_t sub_415030(int32_t* arg1, int32_t arg2)

00415030  {
00415039      int32_t var_8 = arg2;
0041503f      int32_t var_c = arg1[3];
00415046      sub_4087a0(*(uint32_t*)arg1, "%s: %s in precompiled chunk");
00415059      return sub_4051a0(*(uint32_t*)arg1, 3);
00415030  }

0041505a                                                                                90 90 90 90 90 90                            ......

00415060    int32_t sub_415060(int32_t* arg1)

00415060  {
0041506c      sub_415080(arg1, &arg1, 1);
00415079      return (int32_t)(uint8_t)arg1;
00415060  }

0041507a                                                                                90 90 90 90 90 90                            ......

00415080    int32_t sub_415080(int32_t* arg1, int32_t arg2, int32_t arg3)

00415080  {
00415093      int32_t result = sub_40a750(arg1[1], arg2, arg3);
00415093      
0041509d      if (!result)
004150ae          return result;
004150ae      
004150a5      return sub_415030(arg1, "unexpected end");
00415080  }

004150af                                               90                                                                 .

004150b0    int32_t* sub_4150b0(int32_t* arg1)

004150b0  {
004150b1      int32_t* esi = arg1;
004150bd      sub_415080(esi, &arg1, 4);
004150c2      int32_t* eax = arg1;
004150c2      
004150cb      if (eax >= 0)
004150e0          return eax;
004150e0      
004150d3      sub_415030(esi, "bad integer");
004150d8      return arg1;
004150b0  }

004150e1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

004150f0    void** sub_4150f0(int32_t* arg1)

004150f0  {
004150f1      int32_t* esi = arg1;
004150fd      sub_415080(esi, &arg1, 4);
00415102      int32_t* result = arg1;
00415102      
0041510b      if (!result)
0041510e          return result;
0041510e      
00415118      char* eax = sub_40a7c0(*(uint32_t*)esi, esi[2], result);
00415126      sub_415080(esi, eax, arg1);
0041513f      return sub_405f60(*(uint32_t*)esi, eax, (char*)arg1 - 1);
004150f0  }


00415140    int32_t sub_415140(int32_t* arg1, void* arg2)

00415140  {
00415147      int32_t* eax = sub_4150b0(arg1);
00415159      int32_t eax_2;
00415159      
00415159      if ((char*)eax + 1 > 0x3fffffff)
00415177          eax_2 = sub_404ce0(*(uint32_t*)arg1);
00415159      else
0041516a          eax_2 = sub_404d00(*(uint32_t*)arg1, 0, 0, eax << 2);
0041516a      
00415183      *(uint32_t*)((char*)arg2 + 0xc) = eax_2;
00415186      *(uint32_t*)((char*)arg2 + 0x2c) = eax;
0041519d      return sub_415080(arg1, eax_2, eax << 2);
00415140  }

0041519e                                                                                            90 90                                ..

004151a0    int32_t* sub_4151a0(int32_t* arg1, void* arg2)

004151a0  {
004151a1      int32_t* ebx = arg1;
004151a9      int32_t* i_2 = sub_4150b0(ebx);
004151bb      int32_t eax_1;
004151bb      
004151bb      if ((char*)i_2 + 1 > 0xfffffff)
004151d7          eax_1 = sub_404ce0(*(uint32_t*)ebx);
004151bb      else
004151ca          eax_1 = sub_404d00(*(uint32_t*)ebx, 0, 0, i_2 << 4);
004151ca      
004151e3      void* ebp = nullptr;
004151e7      *(uint32_t*)((char*)arg2 + 8) = eax_1;
004151ea      *(uint32_t*)((char*)arg2 + 0x28) = i_2;
004151ea      
004151ed      if (i_2 > 0)
004151ed      {
004151f3          int32_t eax_3 = 0;
004151f5          int32_t* i_1 = i_2;
00415202          int32_t* i;
00415202          
00415202          do
00415202          {
004151fa              eax_3 += 0x10;
004151fd              i = i_1;
004151fd              i_1 -= 1;
004151fe              *(uint32_t*)(eax_3 + *(uint32_t*)((char*)arg2 + 8) - 8) = 0;
00415202          } while (i != 1);
00415202          
00415206          if (i_2 > 0)
00415206          {
0041520c              arg1 = i_2;
0041528b              bool cond:4_1;
0041528b              
0041528b              do
0041528b              {
00415216                  void*** esi_2 = (char*)ebp + *(uint32_t*)((char*)arg2 + 8);
00415216                  
00415225                  switch (sub_415060(ebx))
00415225                  {
0041522c                      case 0:
0041522c                      {
0041522c                          esi_2[2] = 0;
0041522c                          break;
0041522c                      }
0041523e                      case 1:
0041523e                      {
0041523e                          *(uint32_t*)esi_2 = sub_415060(ebx);
00415240                          esi_2[2] = 1;
0041523e                          break;
0041523e                      }
0041524f                      case 3:
0041524f                      {
0041524f                          *(uint64_t*)esi_2 = (double)sub_415320(ebx);
00415254                          esi_2[2] = 3;
0041524f                          break;
0041524f                      }
00415266                      case 4:
00415266                      {
00415266                          *(uint32_t*)esi_2 = sub_4150f0(ebx);
00415268                          esi_2[2] = 4;
00415266                          break;
00415266                      }
00415225                      default:
00415225                      {
00415277                          sub_415030(ebx, "bad constant");
00415225                      }
00415225                  }
00415225                  
00415283                  ebp += 0x10;
00415286                  cond:4_1 = arg1 != 1;
00415287                  arg1 -= 1;
0041528b              } while (cond:4_1);
00415206          }
004151ed      }
004151ed      
0041528e      int32_t* eax_9 = sub_4150b0(ebx);
004152a0      int32_t eax_11;
004152a0      
004152a0      if ((char*)eax_9 + 1 > 0x3fffffff)
004152be          eax_11 = sub_404ce0(*(uint32_t*)ebx);
004152a0      else
004152b1          eax_11 = sub_404d00(*(uint32_t*)ebx, 0, 0, eax_9 << 2);
004152b1      
004152c6      *(uint32_t*)((char*)arg2 + 0x10) = eax_11;
004152c9      int32_t* result = nullptr;
004152cd      *(uint32_t*)((char*)arg2 + 0x34) = eax_9;
004152cd      
004152d0      if (eax_9 > 0)
004152d0      {
004152e0          do
004152e0          {
004152d5              result += 1;
004152d8              *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x10) + (result << 2) - 4) = 0;
004152e0          } while (result < eax_9);
004152d0      }
004152d0      
004152e2      int32_t ebp_1 = 0;
004152e2      
004152e6      if (eax_9 > 0)
004152e6      {
004152fe          do
004152fe          {
004152ed              result = sub_414f60(ebx, *(uint32_t*)((char*)arg2 + 0x20));
004152f8              *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x10) + (ebp_1 << 2)) = result;
004152fb              ebp_1 += 1;
004152fe          } while (ebp_1 < eax_9);
004152e6      }
004152e6      
00415304      return result;
004151a0  }

00415305                 8d 49 00                                                                               .I.
00415308  uint32_t jump_table_415308[0x5] = 
00415308  {
00415308      [0x0] =  0x0041522c
0041530c      [0x1] =  0x00415235
00415310      [0x2] =  0x00415271
00415314      [0x3] =  0x00415249
00415318      [0x4] =  0x0041525d
0041531c  }

0041531c                                                                                      90 90 90 90                              ....

00415320    long double sub_415320(int32_t* arg1)

00415320  {
0041532f      double var_8;
0041532f      sub_415080(arg1, &var_8, 8);
0041533b      return (long double)var_8;
00415320  }

0041533c                                                                                      90 90 90 90                              ....

00415340    void** sub_415340(int32_t* arg1, void* arg2)

00415340  {
00415349      int32_t* eax = sub_4150b0(arg1);
0041535b      int32_t eax_2;
0041535b      
0041535b      if ((char*)eax + 1 > 0x3fffffff)
00415379          eax_2 = sub_404ce0(*(uint32_t*)arg1);
0041535b      else
0041536c          eax_2 = sub_404d00(*(uint32_t*)arg1, 0, 0, eax << 2);
0041536c      
0041538f      *(uint32_t*)((char*)arg2 + 0x14) = eax_2;
00415392      *(uint32_t*)((char*)arg2 + 0x30) = eax;
00415395      sub_415080(arg1, eax_2, eax << 2);
004153a0      int32_t* i_3 = sub_4150b0(arg1);
004153ae      int32_t eax_7;
004153ae      
004153ae      if ((char*)i_3 + 1 > 0x15555555)
004153cc          eax_7 = sub_404ce0(*(uint32_t*)arg1);
004153ae      else
004153bf          eax_7 = sub_404d00(*(uint32_t*)arg1, 0, 0, i_3 * 0xc);
004153bf      
004153d6      *(uint32_t*)((char*)arg2 + 0x18) = eax_7;
004153d9      *(uint32_t*)((char*)arg2 + 0x38) = i_3;
004153d9      
004153dc      if (i_3 > 0)
004153dc      {
004153de          int32_t eax_8 = 0;
004153e0          int32_t* i_2 = i_3;
004153f1          int32_t* i;
004153f1          
004153f1          do
004153f1          {
004153e5              eax_8 += 0xc;
004153e8              i = i_2;
004153e8              i_2 -= 1;
004153e9              *(uint32_t*)(eax_8 + *(uint32_t*)((char*)arg2 + 0x18) - 0xc) = 0;
004153f1          } while (i != 1);
004153f1          
004153f5          if (i_3 > 0)
004153f5          {
004153f7              void*** ebx_1 = nullptr;
00415426              int32_t* i_1;
00415426              
00415426              do
00415426              {
00415403                  *(uint32_t*)((char*)ebx_1 + *(uint32_t*)((char*)arg2 + 0x18)) =
00415403                      sub_4150f0(arg1);
0041540f                  *(uint32_t*)((char*)ebx_1 + *(uint32_t*)((char*)arg2 + 0x18) + 4) =
0041540f                      sub_4150b0(arg1);
0041541e                  *(uint32_t*)((char*)ebx_1 + *(uint32_t*)((char*)arg2 + 0x18) + 8) =
0041541e                      sub_4150b0(arg1);
00415422                  ebx_1 = &ebx_1[3];
00415425                  i_1 = i_3;
00415425                  i_3 -= 1;
00415426              } while (i_1 != 1);
004153f5          }
004153dc      }
004153dc      
00415429      int32_t* eax_12 = sub_4150b0(arg1);
0041543c      int32_t eax_14;
0041543c      
0041543c      if ((char*)eax_12 + 1 > 0x3fffffff)
0041545a          eax_14 = sub_404ce0(*(uint32_t*)arg1);
0041543c      else
0041544d          eax_14 = sub_404d00(*(uint32_t*)arg1, 0, 0, eax_12 << 2);
0041544d      
00415462      *(uint32_t*)((char*)arg2 + 0x1c) = eax_14;
00415465      void** result = nullptr;
00415469      *(uint32_t*)((char*)arg2 + 0x24) = eax_12;
00415469      
0041546c      if (eax_12 > 0)
0041546c      {
0041547c          do
0041547c          {
00415471              result += 1;
00415474              *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x1c) + (result << 2) - 4) = 0;
0041547c          } while (result < eax_12);
0041546c      }
0041546c      
0041547e      int32_t ebp = 0;
0041547e      
00415482      if (eax_12 > 0)
00415482      {
00415496          do
00415496          {
00415485              result = sub_4150f0(arg1);
00415490              *(uint32_t*)(*(uint32_t*)((char*)arg2 + 0x1c) + (ebp << 2)) = result;
00415493              ebp += 1;
00415496          } while (ebp < eax_12);
00415482      }
00415482      
0041549c      return result;
00415340  }

0041549d                                                                                         90 90 90                               ...

004154a0    int32_t sub_4154a0(int32_t* arg1)

004154a0  {
004154ab      void var_c;
004154ab      sub_4154f0(&var_c);
004154bc      void var_18;
004154bc      int32_t result = sub_415080(arg1, &var_18, 0xc);
004154c4      int32_t i = 3;
004154c9      void* edi = &var_18;
004154cd      void* esi = &var_c;
004154d1      bool cond:1 = true;
004154d1      
004154d3      while (i)
004154d3      {
004154d3          int32_t temp0_1 = *(uint32_t*)esi;
004154d3          int32_t temp1_1 = *(uint32_t*)edi;
004154d3          cond:1 = temp0_1 == temp1_1;
004154d3          esi += 4;
004154d3          edi += 4;
004154d3          i -= 1;
004154d3          
004154d3          if (temp0_1 != temp1_1)
004154d3              break;
004154d3      }
004154d3      
004154d5      if (cond:1)
004154eb          return result;
004154eb      
004154dd      return sub_415030(arg1, "bad header");
004154a0  }

004154ec                                      90 90 90 90                                                              ....

004154f0    void* sub_4154f0(int32_t* arg1)

004154f0  {
004154fa      *(uint32_t*)arg1 = data_42b214;
004154ff      arg1[1] = 0x51;
00415503      *(uint8_t*)((char*)arg1 + 5) = 0;
00415507      *(uint8_t*)((char*)arg1 + 6) = 1;
0041550b      *(uint8_t*)((char*)arg1 + 7) = 4;
0041550f      arg1[2] = 4;
00415513      *(uint8_t*)((char*)arg1 + 9) = 4;
00415517      *(uint8_t*)((char*)arg1 + 0xa) = 8;
0041551a      *(uint8_t*)((char*)arg1 + 0xb) = 0;
0041551e      return (char*)arg1 + 0xa;
004154f0  }

0041551f                                                                                               90                                 .

00415520    int32_t sub_415520(int32_t* arg1, int32_t arg2, int32_t arg3)

00415520  {
00415527      int32_t eax = arg1[6];
00415527      
00415533      if (eax > arg1[7])
00415533      {
00415537          if (!eax)
004155a8              return eax;
004155a8          
0041553b          int32_t edx_2 = *(uint32_t*)(*(uint32_t*)arg1 + 0xc);
0041553e          int32_t* edi_1 = edx_2 + (eax << 2) - 4;
00415542          eax = *(uint32_t*)(edx_2 + (eax << 2) - 4);
00415542          
0041554e          if (((uint8_t)eax & 0x3f) == 3)
0041554e          {
0041555d              uint32_t edx_6 = eax >> 0x17;
0041555d              
00415569              if ((uint32_t)(uint8_t)(eax >> 6) <= arg2 && arg2 <= edx_6 + 1)
00415569              {
00415575                  if (arg2 + arg3 - 1 <= edx_6)
004155a8                      return eax;
004155a8                  
0041557e                  int32_t eax_1 = eax & 0x7fffff;
00415588                  *(uint32_t*)edi_1 = (arg2 + arg3 + 0x1ff) << 0x17 ^ eax_1;
0041558d                  return eax_1;
00415569              }
0041554e          }
00415533      }
00415533      
0041559d      return sub_416bf0(arg1, 3, arg2, arg2 + arg3 - 1, 0);
00415520  }

004155a9                             90 90 90 90 90 90 90                                                           .......

004155b0    int32_t* sub_4155b0(int32_t* arg1)

004155b0  {
004155b1      int32_t* esi = arg1;
004155bb      int32_t edi = esi[8];
004155c3      esi[8] = 0xffffffff;
004155cf      arg1 = sub_416d00(esi, 0x16, 0, 0x1fffe);
004155da      sub_415800(esi, &arg1, edi);
004155e8      return arg1;
004155b0  }

004155e9                             90 90 90 90 90 90 90                                                           .......

004155f0    int32_t sub_4155f0(int32_t* arg1, int32_t arg2, int32_t arg3)

004155f0  {
0041560c      return sub_416bf0(arg1, 0x1e, arg2, arg3 + 1, 0);
004155f0  }

0041560d                                         90 90 90                                                               ...

00415610    int32_t sub_415610(void* arg1)

00415610  {
00415614      int32_t result = *(uint32_t*)((char*)arg1 + 0x18);
00415617      *(uint32_t*)((char*)arg1 + 0x1c) = result;
0041561a      return result;
00415610  }

0041561b                                                                                   90 90 90 90 90                             .....

00415620    int32_t sub_415620(int32_t* arg1, int32_t arg2, int32_t arg3)

00415620  {
0041562b      if (arg3 != arg1[6])
00415651          return sub_415660(arg1, arg2, arg3, 0xff, arg3);
00415651      
0041563b      return sub_4157e0(arg1, arg2);
00415620  }

00415652                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00415660    void sub_415660(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)

00415660  {
00415661      int32_t i_1 = arg2;
00415661      
00415668      if (i_1 == 0xffffffff)
00415668          return;
00415668      
004156a8      int32_t i;
004156a8      
004156a8      do
004156a8      {
00415677          i = sub_415700(arg1, i_1);
0041568b          int32_t var_14_2;
0041568b          
0041568b          if (!sub_415730(arg1, i_1, arg4))
00415698              var_14_2 = arg5;
0041568b          else
00415691              var_14_2 = arg3;
00415691          
0041569b          sub_4156b0(arg1, i_1, var_14_2);
004156a6          i_1 = i;
004156a8      } while (i != 0xffffffff);
00415660  }

004156af                                               90                                                                 .

004156b0    int32_t sub_4156b0(int32_t* arg1, int32_t arg2, int32_t arg3)

004156b0  {
004156c6      int32_t* edi = *(uint32_t*)(*(uint32_t*)arg1 + 0xc) + (arg2 << 2);
004156cb      int32_t eax_3;
004156cb      int32_t edx_1;
004156cb      edx_1 = HIGHD((int64_t)(arg3 - arg2 - 1));
004156cb      eax_3 = LOWD((int64_t)(arg3 - arg2 - 1));
004156ce      int32_t result = (eax_3 ^ edx_1) - edx_1;
004156ce      
004156d5      if (result > 0x1ffff)
004156e0          result = sub_406320(arg1[3], "control structure too long");
004156e0      
004156fb      *(uint32_t*)edi = (arg3 - arg2 + 0x1fffe) << 0xe ^ (*(uint32_t*)edi & 0x3fff);
004156ff      return result;
004156b0  }


00415700    int32_t sub_415700(int32_t* arg1, int32_t arg2)

00415700  {
00415713      int32_t result = (*(uint32_t*)(*(uint32_t*)(*(uint32_t*)arg1 + 0xc) + (arg2 << 2))
00415713          >> 0xe) - 0x1ffff;
00415713      
0041571b      if (result != 0xffffffff)
00415724          return result + arg2 + 1;
00415724      
0041571f      return result;
00415700  }

00415725                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00415730    int32_t sub_415730(int32_t* arg1, int32_t arg2, int32_t arg3)

00415730  {
0041573a      void* eax = sub_4157b0(arg1, arg2);
0041573f      int32_t ecx_1 = *(uint32_t*)eax;
0041573f      
0041574c      if (((uint8_t)ecx_1 & 0x3f) != 0x1b)
00415750          return 0;
00415750      
00415766      if (arg3 != 0xff && arg3 != ecx_1 >> 0x17)
00415766      {
00415779          *(uint32_t*)eax = (arg3 & 0xff) << 6 | (ecx_1 & 0xffffc03f);
00415780          return 1;
00415766      }
00415766      
0041579a      *(uint32_t*)eax = ((ecx_1 & 0xffb5ffff) | 0x340000) >> 0x11 | (ecx_1 & 0x7fc000);
004157a1      return 1;
00415730  }

004157a2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

004157b0    void* sub_4157b0(int32_t* arg1, int32_t arg2)

004157b0  {
004157c0      void* result = *(uint32_t*)(*(uint32_t*)arg1 + 0xc) + (arg2 << 2);
004157c0      
004157c3      if (arg2 >= 1
004157c3              && *(uint8_t*)((*(uint32_t*)((char*)result - 4) & 0x3f) + 0x428a84) & 0x80)
004157d9          return (char*)result - 4;
004157d9      
004157d7      return result;
004157b0  }

004157da                                                                                90 90 90 90 90 90                            ......

004157e0    int32_t sub_4157e0(int32_t* arg1, int32_t arg2)

004157e0  {
004157e6      sub_415610(arg1);
004157fe      return sub_415800(arg1, &arg1[8], arg2);
004157e0  }

004157ff                                                                                               90                                 .

00415800    void sub_415800(int32_t* arg1, int32_t* arg2, int32_t arg3)

00415800  {
00415809      if (arg3 == 0xffffffff)
00415809          return;
00415809      
0041580f      int32_t i_1 = *(uint32_t*)arg2;
0041580f      
00415814      if (i_1 == 0xffffffff)
00415814      {
00415816          *(uint32_t*)arg2 = arg3;
0041581a          return;
00415814      }
00415814      
0041582d      for (int32_t i = sub_415700(arg1, i_1); i != 0xffffffff; i = sub_415700(arg1, i))
00415831          i_1 = i;
00415831      
00415843      sub_4156b0(arg1, i_1, arg3);
00415800  }

0041584f                                               90                                                                 .

00415850    void* sub_415850(int32_t* arg1, int32_t arg2)

00415850  {
0041585d      void* result = *(uint32_t*)arg1;
0041585f      int32_t ebx_1 = arg1[9] + arg2;
00415863      int32_t ecx;
00415863      (uint8_t)ecx = *(uint8_t*)((char*)result + 0x4b);
00415863      
00415868      if (ebx_1 > ecx)
00415868      {
00415870          if (ebx_1 >= 0xfa)
0041587b              sub_406320(arg1[3], "function or expression too complex");
0041587b          
00415883          result = *(uint32_t*)arg1;
00415885          *(uint8_t*)((char*)result + 0x4b) = (uint8_t)ebx_1;
00415868      }
00415868      
0041588a      return result;
00415850  }

0041588b                                   90 90 90 90 90                                                             .....

00415890    int32_t sub_415890(int32_t* arg1, int32_t arg2)

00415890  {
0041589c      sub_415850(arg1, arg2);
004158a7      int32_t result = arg1[9] + arg2;
004158a9      arg1[9] = result;
004158ae      return result;
00415890  }

004158af                                               90                                                                 .

004158b0    int32_t sub_4158b0(void* arg1, int32_t arg2)

004158b0  {
004158bb      int32_t var_10 = arg2;
004158ca      int32_t var_8 = 4;
004158da      return sub_4158e0(arg1, &var_10, &var_10);
004158b0  }

004158db                                                                                   90 90 90 90 90                             .....

004158e0    int32_t sub_4158e0(void* arg1, int32_t* arg2, void** arg3)

004158e0  {
004158e5      int32_t* ebx = arg1;
004158ef      void* eax = ebx[4];
004158f9      double* eax_1;
004158f9      int16_t x87control;
004158f9      eax_1 = sub_407d70(eax, ebx[1], arg2);
004158fe      void* esi = *(uint32_t*)ebx;
0041590b      int32_t i = *(uint32_t*)((char*)esi + 0x28);
0041590b      
00415913      if (eax_1[1] == 3)
00415920          return __ftol(x87control, (long double)*(uint64_t*)eax_1);
00415920      
00415924      eax_1[1] = 3;
00415927      *(uint64_t*)eax_1 = (double)(long double)ebx[0xa];
00415927      
00415931      if (ebx[0xa] + 1 > *(uint32_t*)((char*)esi + 0x28))
00415951          *(uint32_t*)((char*)esi + 8) = sub_404c50(eax, *(uint32_t*)((char*)esi + 8), 
00415951              (char*)esi + 0x28, 0x10, 0x3ffff, "constant table overflow");
00415951      
00415956      if (i < *(uint32_t*)((char*)esi + 0x28))
00415956      {
0041595a          int32_t eax_7 = i << 4;
0041595a          
0041596e          do
0041596e          {
00415962              i += 1;
00415963              *(uint32_t*)(eax_7 + *(uint32_t*)((char*)esi + 8) + 8) = 0;
00415969              eax_7 += 0x10;
0041596e          } while (i < *(uint32_t*)((char*)esi + 0x28));
00415956      }
00415956      
0041597f      void** eax_10 = (ebx[0xa] << 4) + *(uint32_t*)((char*)esi + 8);
00415981      *(uint32_t*)eax_10 = *(uint32_t*)arg3;
00415986      eax_10[1] = arg3[1];
0041598c      eax_10[2] = arg3[2];
0041598c      
00415999      if (arg3[2] >= 4)
00415999      {
0041599b          void* ecx_3 = *(uint32_t*)arg3;
0041599b          
004159a6          if (*(uint8_t*)((char*)ecx_3 + 5) & 3 && *(uint8_t*)((char*)esi + 5) & 4)
004159af              sub_404b60(eax, esi, ecx_3);
00415999      }
00415999      
004159b7      int32_t result = ebx[0xa];
004159c0      ebx[0xa] = result + 1;
004159c4      return result;
004158e0  }

004159c5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

004159d0    int32_t sub_4159d0(void* arg1, int32_t arg2, int32_t arg3)

004159d0  {
004159db      int32_t var_10 = arg2;
004159e3      int32_t var_c = arg3;
004159f2      int32_t var_8 = 3;
00415a02      return sub_4158e0(arg1, &var_10, &var_10);
004159d0  }

00415a03           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00415a10    int32_t* sub_415a10(int32_t* arg1, int32_t* arg2, int32_t arg3)

00415a10  {
00415a14      int32_t eax = *(uint32_t*)arg2;
00415a14      
00415a19      if (eax == 0xd)
00415a19      {
00415a2c          int32_t* eax_2 = *(uint32_t*)(*(uint32_t*)arg1 + 0xc) + (arg2[2] << 2);
00415a32          int32_t ecx_2 = *(uint32_t*)eax_2;
00415a3e          *(uint32_t*)eax_2 = (((arg3 + 1) << 0xe ^ ecx_2) & 0x7fc000) ^ ecx_2;
00415a40          return eax_2;
00415a19      }
00415a19      
00415a44      if (eax != 0xe)
00415a9d          return eax;
00415a9d      
00415a4a      int32_t edx_8 = arg2[2];
00415a54      int32_t esi_2 = *(uint32_t*)(*(uint32_t*)arg1 + 0xc);
00415a6d      *(uint32_t*)(esi_2 + (edx_8 << 2)) =
00415a6d          (arg3 + 1) << 0x17 ^ (*(uint32_t*)(esi_2 + (edx_8 << 2)) & 0x7fffff);
00415a71      int32_t ecx_3 = arg2[2];
00415a74      int32_t edx_11 = *(uint32_t*)(*(uint32_t*)arg1 + 0xc);
00415a91      *(uint32_t*)(edx_11 + (ecx_3 << 2)) = (uint32_t)(uint8_t)arg1[9] << 6
00415a91          | (*(uint32_t*)(edx_11 + (ecx_3 << 2)) & 0xffffc03f);
00415a93      return sub_415890(arg1, 1);
00415a10  }

00415a9e                                                                                            90 90                                ..

00415aa0    int32_t* sub_415aa0(int32_t* arg1, int32_t* arg2)

00415aa0  {
00415aa4      int32_t ecx = *(uint32_t*)arg2;
00415aa4      
00415aa9      if (ecx == 0xd)
00415aa9      {
00415aaf          int32_t ecx_1 = arg2[2];
00415ab2          *(uint32_t*)arg2 = 0xc;
00415ac9          arg2[2] = (uint32_t)(uint8_t)(
00415ac9              *(uint32_t*)(*(uint32_t*)(*(uint32_t*)arg1 + 0xc) + (ecx_1 << 2)) >> 6);
00415acc          return arg2;
00415aa9      }
00415aa9      
00415ad0      if (ecx == 0xe)
00415ad0      {
00415ade          int32_t* ecx_8 = *(uint32_t*)(*(uint32_t*)arg1 + 0xc) + (arg2[2] << 2);
00415aef          *(uint32_t*)ecx_8 = (*(uint32_t*)ecx_8 & 0x7fffff) | 0x1000000;
00415af1          *(uint32_t*)arg2 = 0xb;
00415ad0      }
00415ad0      
00415af7      return arg2;
00415aa0  }

00415af8                                                                          90 90 90 90 90 90 90 90                          ........

00415b00    int32_t* sub_415b00(int32_t* arg1, int32_t* arg2)

00415b00  {
00415b07      int32_t* eax_1 = *(uint32_t*)arg2 - 6;
00415b07      
00415b13      switch (eax_1)
00415b13      {
00415b1a          case nullptr:
00415b1a          {
00415b1a              *(uint32_t*)arg2 = 0xc;
00415b1a              break;
00415b1a          }
00415b31          case 1:
00415b31          {
00415b31              int32_t eax_3 = sub_416bf0(arg1, 4, 0, arg2[2], 0);
00415b39              arg2[2] = eax_3;
00415b3c              *(uint32_t*)arg2 = 0xb;
00415b43              return eax_3;
00415b31              break;
00415b31          }
00415b51          case 2:
00415b51          {
00415b51              int32_t eax_5 = sub_416d00(arg1, 5, 0, arg2[2]);
00415b59              arg2[2] = eax_5;
00415b5c              *(uint32_t*)arg2 = 0xb;
00415b63              return eax_5;
00415b51              break;
00415b51          }
00415b6e          case 3:
00415b6e          {
00415b6e              sub_415be0(arg1, arg2[3]);
00415b78              sub_415be0(arg1, arg2[2]);
00415b8a              int32_t eax_7 = sub_416bf0(arg1, 6, 0, arg2[2], arg2[3]);
00415b92              arg2[2] = eax_7;
00415b95              *(uint32_t*)arg2 = 0xb;
00415b9d              return eax_7;
00415b6e              break;
00415b6e          }
00415ba4          case 7:
00415ba4          case 8:
00415ba4          {
00415ba4              return sub_415aa0(arg1, arg2);
00415ba4              break;
00415ba4          }
00415b13      }
00415b13      
00415bad      return eax_1;
00415b00  }

00415bae                                            8b ff                                                                ..
00415bb0  uint32_t jump_table_415bb0[0x9] = 
00415bb0  {
00415bb0      [0x0] =  0x00415b1a
00415bb4      [0x1] =  0x00415b22
00415bb8      [0x2] =  0x00415b44
00415bbc      [0x3] =  0x00415b64
00415bc0      [0x4] =  0x00415bac
00415bc4      [0x5] =  0x00415bac
00415bc8      [0x6] =  0x00415bac
00415bcc      [0x7] =  0x00415b9e
00415bd0      [0x8] =  0x00415b9e
00415bd4  }

00415bd4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00415be0    void sub_415be0(void* arg1, int32_t arg2)

00415be0  {
00415be7      if (*(uint8_t*)((char*)arg2)[1] & 1)
00415be7          return;
00415be7      
00415bef      int32_t edx_1;
00415bef      (uint8_t)edx_1 = *(uint8_t*)((char*)arg1 + 0x32);
00415bef      
00415bf4      if (arg2 >= edx_1)
00415bf6          *(uint32_t*)((char*)arg1 + 0x24) -= 1;
00415be0  }

00415bfa                                                                                90 90 90 90 90 90                            ......

00415c00    int32_t sub_415c00(int32_t* arg1, int32_t* arg2)

00415c00  {
00415c0c      sub_415b00(arg1, arg2);
00415c13      sub_415c40(arg1, arg2);
00415c1b      sub_415890(arg1, 1);
00415c27      sub_415c60(arg1, arg2, arg1[9] - 1);
00415c31      return 0xffffffff;
00415c00  }

00415c32                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00415c40    int32_t* sub_415c40(void* arg1, int32_t* arg2)

00415c40  {
00415c47      if (*(uint32_t*)arg2 != 0xc)
00415c5a          return arg2;
00415c5a      
00415c52      return sub_415be0(arg1, arg2[2]);
00415c40  }

00415c5b                                                                                   90 90 90 90 90                             .....

00415c60    int32_t sub_415c60(int32_t* arg1, int32_t* arg2, int32_t arg3)

00415c60  {
00415c61      int32_t ebx = arg3;
00415c6b      int32_t* edi = arg2;
00415c72      sub_415dc0(arg1, edi, ebx);
00415c72      
00415c7f      if (*(uint32_t*)edi == 0xa)
00415c8a          sub_415800(arg1, &edi[4], edi[2]);
00415c8a      
00415c92      int32_t eax_2 = edi[4];
00415c92      
00415c9a      if (eax_2 != edi[5])
00415c9a      {
00415ca1          int32_t* ebp_1 = 0xffffffff;
00415ca6          arg3 = 0xffffffff;
00415caa          arg2 = 0xffffffff;
00415cae          int32_t eax_3 = sub_415d50(arg1, eax_2);
00415cb8          int32_t eax_4;
00415cb8          
00415cb8          if (!eax_3)
00415cbf              eax_4 = sub_415d50(arg1, edi[5]);
00415cbf          
00415cc9          if (eax_3 || eax_4)
00415cc9          {
00415cce              if (*(uint32_t*)edi != 0xa)
00415cd9                  ebp_1 = sub_4155b0(arg1);
00415cd9              
00415cec              arg3 = sub_415d90(arg1, ebx, 0, 1);
00415cf7              arg2 = sub_415d90(arg1, ebx, 1, 0);
00415cfb              sub_4157e0(arg1, ebp_1);
00415cc9          }
00415cc9          
00415d04          int32_t eax_8 = sub_415610(arg1);
00415d17          sub_415660(arg1, edi[5], eax_8, ebx, arg3);
00415d28          sub_415660(arg1, edi[4], eax_8, ebx, arg2);
00415c9a      }
00415c9a      
00415d34      edi[2] = ebx;
00415d37      edi[4] = 0xffffffff;
00415d3a      edi[5] = 0xffffffff;
00415d3d      *(uint32_t*)edi = 0xc;
00415d46      return 0xffffffff;
00415c60  }

00415d47                       90 90 90 90 90 90 90 90 90                                                         .........

00415d50    int32_t sub_415d50(int32_t* arg1, int32_t arg2)

00415d50  {
00415d59      for (int32_t i = arg2; i != 0xffffffff; i = sub_415700(arg1, i))
00415d59      {
00415d70          if (((char)*(uint32_t*)sub_4157b0(arg1, i) & 0x3f) != 0x1b)
00415d8f              return 1;
00415d59      }
00415d59      
00415d87      return 0;
00415d50  }


00415d90    int32_t sub_415d90(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00415d90  {
00415d96      sub_415610(arg1);
00415db6      return sub_416bf0(arg1, 2, arg2, arg3, arg4);
00415d90  }

00415db7                                                                       90 90 90 90 90 90 90 90 90                         .........

00415dc0    int32_t* sub_415dc0(int32_t* arg1, int32_t* arg2, int32_t arg3)

00415dc0  {
00415dcd      sub_415b00(arg1, arg2);
00415dd2      int32_t eax = *(uint32_t*)arg2;
00415ddd      int32_t var_1c_1;
00415ddd      int32_t var_18_2;
00415ddd      int32_t var_14_2;
00415ddd      int32_t esi_2;
00415ddd      
00415ddd      if (eax - 1 <= 0xb)
00415ddd          switch (eax)
00415ddd          {
00415df2              case 1:
00415df2              {
00415df2                  int32_t eax_1 = sub_415520(arg1, arg3, 1);
00415dfa                  arg2[2] = arg3;
00415dfd                  *(uint32_t*)arg2 = 0xc;
00415e06                  return eax_1;
00415df2                  break;
00415df2              }
00415e07              case 2:
00415e07              case 3:
00415e07              {
00415e07                  esi_2 = arg3;
00415e10                  int32_t var_10_1 = 0;
00415e12                  int32_t ecx_1;
00415e12                  (uint8_t)ecx_1 = eax == 2;
00415e15                  var_14_2 = ecx_1;
00415e16                  var_18_2 = esi_2;
00415e17                  var_1c_1 = 2;
00415eb0              label_415eb0:
00415eb0                  eax = sub_416bf0(arg1, var_1c_1, var_18_2, var_14_2, 0);
00415eb8                  arg2[2] = esi_2;
00415ebb                  *(uint32_t*)arg2 = 0xc;
00415e07                  break;
00415e07              }
00415e2a              case 4:
00415e2a              {
00415e2a                  int32_t eax_2 = sub_416d00(arg1, 1, arg3, arg2[2]);
00415e32                  arg2[2] = arg3;
00415e35                  *(uint32_t*)arg2 = 0xc;
00415e3e                  return eax_2;
00415e2a                  break;
00415e2a              }
00415e56              case 5:
00415e56              {
00415e56                  int32_t eax_5 =
00415e56                      sub_416d00(arg1, 1, arg3, sub_4159d0(arg1, arg2[2], arg2[3]));
00415e5e                  arg2[2] = arg3;
00415e61                  *(uint32_t*)arg2 = 0xc;
00415e6a                  return eax_5;
00415e56                  break;
00415e56              }
00415e78              case 0xb:
00415e78              {
00415e78                  int32_t* eax_7 = *(uint32_t*)(*(uint32_t*)arg1 + 0xc) + (arg2[2] << 2);
00415e90                  *(uint32_t*)eax_7 =
00415e90                      (uint32_t)(uint8_t)arg3 << 6 | (*(uint32_t*)eax_7 & 0xffffc03f);
00415e92                  arg2[2] = arg3;
00415e95                  *(uint32_t*)arg2 = 0xc;
00415e9d                  return eax_7;
00415e78                  break;
00415e78              }
00415e9e              case 0xc:
00415e9e              {
00415e9e                  eax = arg2[2];
00415ea1                  esi_2 = arg3;
00415ea1                  
00415ea7                  if (esi_2 != eax)
00415ea7                  {
00415ea9                      int32_t var_10_4 = 0;
00415eab                      var_14_2 = eax;
00415eac                      var_18_2 = esi_2;
00415ead                      var_1c_1 = 0;
00415ead                      goto label_415eb0;
00415ea7                  }
00415ea7                  
00415eb8                  arg2[2] = esi_2;
00415ebb                  *(uint32_t*)arg2 = 0xc;
00415e9e                  break;
00415e9e              }
00415ddd          }
00415ec4      return eax;
00415dc0  }

00415ec5                 8d 49 00                                                                               .I.
00415ec8  uint32_t jump_table_415ec8[0xc] = 
00415ec8  {
00415ec8      [0x0] =  0x00415dea
00415ecc      [0x1] =  0x00415e07
00415ed0      [0x2] =  0x00415e07
00415ed4      [0x3] =  0x00415e1e
00415ed8      [0x4] =  0x00415e3f
00415edc      [0x5] =  0x00415ec1
00415ee0      [0x6] =  0x00415ec1
00415ee4      [0x7] =  0x00415ec1
00415ee8      [0x8] =  0x00415ec1
00415eec      [0x9] =  0x00415ec1
00415ef0      [0xa] =  0x00415e6b
00415ef4      [0xb] =  0x00415e9e
00415ef8  }

00415ef8                                                                          90 90 90 90 90 90 90 90                          ........

00415f00    int32_t sub_415f00(int32_t* arg1, int32_t* arg2)

00415f00  {
00415f0c      sub_415b00(arg1, arg2);
00415f0c      
00415f19      if (*(uint32_t*)arg2 == 0xc)
00415f19      {
00415f23          int32_t result = arg2[2];
00415f23          
00415f26          if (arg2[4] == arg2[5])
00415f51              return result;
00415f51          
00415f2a          int32_t ecx_2;
00415f2a          (uint8_t)ecx_2 = *(uint8_t*)((char*)arg1 + 0x32);
00415f2a          
00415f2f          if (result >= ecx_2)
00415f2f          {
00415f34              sub_415c60(arg1, arg2, result);
00415f41              return arg2[2];
00415f2f          }
00415f19      }
00415f19      
00415f44      sub_415c00(arg1, arg2);
00415f49      return arg2[2];
00415f00  }

00415f52                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00415f60    int32_t* sub_415f60(int32_t* arg1, int32_t* arg2)

00415f60  {
00415f6d      if (arg2[4] == arg2[5])
00415f8a          return sub_415b00(arg1, arg2);
00415f8a      
00415f7c      return sub_415f00(arg1, arg2);
00415f60  }

00415f8b                                   90 90 90 90 90                                                             .....

00415f90    int32_t sub_415f90(int32_t* arg1, int32_t* arg2)

00415f90  {
00415f9c      sub_415f60(arg1, arg2);
00415fa1      int32_t eax = *(uint32_t*)arg2;
00415fa1      
00415fac      if (eax - 1 <= 4)
00415fac          switch (eax)
00415fac          {
00415fc0              case 1:
00415fc0              case 2:
00415fc0              case 3:
00415fc0              case 5:
00415fc0              {
00415fc0                  if (arg1[0xa] <= 0xff)
00415fc0                  {
00415fc5                      if (eax == 1)
00415fc5                      {
00415fc8                          int32_t eax_1 = sub_416090(arg1);
00415fd0                          arg2[2] = eax_1;
00415fd3                          *(uint32_t*)arg2 = 4;
00415fd9                          *(uint8_t*)((char*)eax_1)[1] |= 1;
00415fde                          return eax_1;
00415fc5                      }
00415fc5                      
00415fe2                      if (eax == 5)
00415fe2                      {
00415fed                          int32_t eax_3 = sub_4159d0(arg1, arg2[2], arg2[3]);
00415ff5                          arg2[2] = eax_3;
00415ff8                          *(uint32_t*)arg2 = 4;
00415ffe                          *(uint8_t*)((char*)eax_3)[1] |= 1;
00416003                          return eax_3;
00415fe2                      }
00415fe2                      
00416009                      int32_t edx;
00416009                      (uint8_t)edx = eax == 2;
0041600e                      int32_t eax_4 = sub_416060(arg1, edx);
00416016                      arg2[2] = eax_4;
00416019                      *(uint32_t*)arg2 = 4;
0041601f                      *(uint8_t*)((char*)eax_4)[1] |= 1;
00416024                      return eax_4;
00415fc0                  }
00415fc0                  break;
00415fc0              }
00416025              case 4:
00416025              {
00416025                  int32_t eax_5 = arg2[2];
00416025                  
0041602d                  if (eax_5 <= 0xff)
0041602d                  {
00416030                      *(uint8_t*)((char*)eax_5)[1] |= 1;
00416034                      return eax_5;
0041602d                  }
00416025                  break;
00416025              }
00415fac          }
00415fac      
00416041      return sub_415f00(arg1, arg2);
00415f90  }

00416042        8b ff                                                                                        ..
00416044  uint32_t jump_table_416044[0x5] = 
00416044  {
00416044      [0x0] =  0x00415fb9
00416048      [0x1] =  0x00415fb9
0041604c      [0x2] =  0x00415fb9
00416050      [0x3] =  0x00416025
00416054      [0x4] =  0x00415fb9
00416058  }

00416058                                                                          90 90 90 90 90 90 90 90                          ........

00416060    int32_t sub_416060(void* arg1, int32_t arg2)

00416060  {
0041606b      int32_t var_10 = arg2;
0041607a      int32_t var_8 = 1;
0041608a      return sub_4158e0(arg1, &var_10, &var_10);
00416060  }

0041608b                                   90 90 90 90 90                                                             .....

00416090    int32_t sub_416090(void* arg1)

00416090  {
0041609c      int32_t var_8 = 0;
004160a7      int32_t var_18 = 5;
004160af      int32_t var_20 = *(uint32_t*)((char*)arg1 + 4);
004160c1      void* var_10;
004160c1      return sub_4158e0(arg1, &var_20, &var_10);
00416090  }

004160c2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

004160d0    int32_t* sub_4160d0(int32_t* arg1, int32_t* arg2, int32_t* arg3)

004160d0  {
004160e9      switch (*(uint32_t*)arg2 - 6)
004160e9      {
004160fa          case 0:
004160fa          {
004160fa              sub_415c40(arg1, arg3);
00416105              sub_415c60(arg1, arg3, arg2[2]);
00416110              return 0xffffffff;
004160fa              break;
004160fa          }
00416113          case 1:
00416113          {
0041615b              sub_416bf0(arg1, 8, sub_415f00(arg1, arg3), arg2[2], 0);
00416113              break;
00416113          }
00416132          case 2:
00416132          {
00416132              sub_416d00(arg1, 7, sub_415f00(arg1, arg3), arg2[2]);
00416132              break;
00416132          }
00416152          case 3:
00416152          {
00416152              int32_t var_18_2 = sub_415f90(arg1, arg3);
0041615b              sub_416bf0(arg1, 9, arg2[2], arg2[3], var_18_2);
00416152              break;
00416152          }
004160e9      }
004160e9      
00416170      return sub_415c40(arg1, arg3);
004160d0  }

00416171                                                     8d 49 00                                                       .I.
00416174  uint32_t jump_table_416174[0x4] = 
00416174  {
00416174      [0x0] =  0x004160f0
00416178      [0x1] =  0x00416111
0041617c      [0x2] =  0x00416123
00416180      [0x3] =  0x00416148
00416184  }

00416184              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00416190    int32_t* sub_416190(int32_t* arg1, int32_t* arg2, int32_t* arg3)

00416190  {
0041619e      sub_415f00(arg1, arg2);
004161a5      sub_415c40(arg1, arg2);
004161aa      int32_t ebx = arg1[9];
004161b0      sub_415890(arg1, 2);
004161bb      int32_t eax = sub_415f90(arg1, arg3);
004161c9      sub_416bf0(arg1, 0xb, ebx, arg2[2], eax);
004161d0      int32_t* result = sub_415c40(arg1, arg3);
004161d8      arg2[2] = ebx;
004161db      *(uint32_t*)arg2 = 0xc;
004161e5      return result;
00416190  }

004161e6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

004161f0    int32_t sub_4161f0(int32_t* arg1, int32_t* arg2)

004161f0  {
004161fc      sub_415b00(arg1, arg2);
0041620e      int32_t* eax_2;
0041620e      
0041620e      switch (*(uint32_t*)arg2 - 2)
0041620e      {
00416215          case 0:
00416215          case 2:
00416215          case 3:
00416215          {
00416215              eax_2 = 0xffffffff;
00416215              break;
00416215          }
0041621b          case 1:
0041621b          {
0041621b              eax_2 = sub_4155b0(arg1);
0041621b              break;
0041621b          }
00416227          case 8:
00416227          {
00416227              sub_416290(arg1, arg2);
0041622c              eax_2 = arg2[2];
00416227              break;
00416227          }
0041620e          default:
0041620e          {
00416238              eax_2 = sub_4162d0(arg1, arg2, 0);
0041620e          }
0041620e      }
0041620e      
00416246      sub_415800(arg1, &arg2[5], eax_2);
00416250      int32_t result = sub_4157e0(arg1, arg2[4]);
00416258      arg2[4] = 0xffffffff;
00416261      return result;
004161f0  }

00416262        8b ff                                                                                        ..
00416264  uint32_t jump_table_416264[0x9] = 
00416264  {
00416264      [0x0] =  0x00416215
00416268      [0x1] =  0x0041621a
0041626c      [0x2] =  0x00416215
00416270      [0x3] =  0x00416215
00416274      [0x4] =  0x00416234
00416278      [0x5] =  0x00416234
0041627c      [0x6] =  0x00416234
00416280      [0x7] =  0x00416234
00416284      [0x8] =  0x00416225
00416288  }

00416288                          90 90 90 90 90 90 90 90                                                          ........

00416290    void* sub_416290(int32_t* arg1, void* arg2)

00416290  {
0041629d      void* result = sub_4157b0(arg1, *(uint32_t*)((char*)arg2 + 8));
004162a2      int32_t ecx_1 = *(uint32_t*)result;
004162a9      int32_t edx_2 = ecx_1 & 0x3fc0;
004162af      int32_t edx_3 = -(edx_2);
004162c5      *(uint32_t*)result =
004162c5          (uint32_t)((char)(edx_3 - edx_3) + 1) << 6 | (ecx_1 & 0xffffc03f);
004162c7      return result;
00416290  }

004162c8                          90 90 90 90 90 90 90 90                                                          ........

004162d0    int32_t* sub_4162d0(int32_t* arg1, int32_t* arg2, int32_t arg3)

004162d0  {
004162dd      if (*(uint32_t*)arg2 == 0xb)
004162dd      {
004162e7          int32_t eax_2 =
004162e7              *(uint32_t*)(*(uint32_t*)(*(uint32_t*)arg1 + 0xc) + (arg2[2] << 2));
004162e7          
004162f2          if (((uint8_t)eax_2 & 0x3f) == 0x13)
004162f2          {
00416300              int32_t edx_2;
00416300              (uint8_t)edx_2 = !arg3;
0041630d              arg1[6] -= 1;
0041631a              return sub_416350(arg1, 0x1a, eax_2 >> 0x17, 0, edx_2);
004162f2          }
004162dd      }
004162dd      
0041631d      sub_416380(arg1, arg2);
00416324      sub_415c40(arg1, arg2);
00416344      return sub_416350(arg1, 0x1b, 0xff, arg2[2], arg3);
004162d0  }

00416345                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00416350    int32_t* sub_416350(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)

00416350  {
0041636a      sub_416bf0(arg1, arg2, arg3, arg4, arg5);
00416379      return sub_4155b0(arg1);
00416350  }

0041637a                                                                                90 90 90 90 90 90                            ......

00416380    void sub_416380(int32_t* arg1, int32_t* arg2)

00416380  {
00416388      if (*(uint32_t*)arg2 != 0xc)
00416388      {
00416392          sub_415890(arg1, 1);
0041639e          sub_415dc0(arg1, arg2, arg1[9] - 1);
00416388      }
00416380  }

004163a9                             90 90 90 90 90 90 90                                                           .......

004163b0    int32_t sub_4163b0(int32_t* arg1, int32_t* arg2, int32_t* arg3)

004163b0  {
004163ba      int32_t result = sub_415f90(arg1, arg3);
004163c6      arg2[3] = result;
004163c9      *(uint32_t*)arg2 = 9;
004163cf      return result;
004163b0  }


004163d0    int32_t sub_4163d0(int32_t* arg1, int32_t arg2, int32_t* arg3)

004163d0  {
004163d7      int32_t var_4 = 0xffffffff;
004163db      int32_t var_8 = 0xffffffff;
004163e7      int32_t var_18 = 5;
004163ef      int32_t var_10 = 0;
004163f7      int32_t var_c = 0;
004163f7      
004163ff      if (!arg2)
004163ff      {
00416450          if (*(uint32_t*)arg3 == 4)
00416454              sub_415f00(arg1, arg3);
00416454          
00416465          return sub_416570(arg1, 0x12, arg3, &var_18);
004163ff      }
004163ff      
00416402      if (arg2 == 1)
00416444          return sub_416480(arg1, arg3);
00416444      
00416405      if (arg2 != 2)
00416472          return arg2 - 2;
00416472      
00416411      sub_415f00(arg1, arg3);
0041642c      return sub_416570(arg1, 0x14, arg3, &var_18);
004163d0  }

00416473                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00416480    int32_t sub_416480(int32_t* arg1, int32_t* arg2)

00416480  {
0041648c      sub_415b00(arg1, arg2);
0041648c      
0041649c      switch (*(uint32_t*)arg2 - 1)
0041649c      {
004164a3          case 0:
004164a3          case 2:
004164a3          {
004164a3              *(uint32_t*)arg2 = 2;
004164a3              break;
004164a3          }
004164ab          case 1:
004164ab          case 3:
004164ab          case 4:
004164ab          {
004164ab              *(uint32_t*)arg2 = 3;
004164ab              break;
004164ab          }
004164b5          case 9:
004164b5          {
004164b5              sub_416290(arg1, arg2);
004164b5              break;
004164b5          }
004164c1          case 0xa:
004164c1          case 0xb:
004164c1          {
004164c1              sub_416380(arg1, arg2);
004164c8              sub_415c40(arg1, arg2);
004164e0              arg2[2] = sub_416bf0(arg1, 0x13, 0, arg2[2], 0);
004164e3              *(uint32_t*)arg2 = 0xb;
004164c1              break;
004164c1          }
0041649c      }
0041649c      
004164e9      int32_t ecx = arg2[4];
004164ec      int32_t eax_4 = arg2[5];
004164f1      arg2[5] = ecx;
004164f6      arg2[4] = eax_4;
004164f9      sub_416540(arg1, ecx);
0041650d      return sub_416540(arg1, arg2[4]);
00416480  }

0041650e                                            8b ff                                                                ..
00416510  uint32_t jump_table_416510[0xc] = 
00416510  {
00416510      [0x0] =  0x004164a3
00416514      [0x1] =  0x004164ab
00416518      [0x2] =  0x004164a3
0041651c      [0x3] =  0x004164ab
00416520      [0x4] =  0x004164ab
00416524      [0x5] =  0x004164e9
00416528      [0x6] =  0x004164e9
0041652c      [0x7] =  0x004164e9
00416530      [0x8] =  0x004164e9
00416534      [0x9] =  0x004164b3
00416538      [0xa] =  0x004164bf
0041653c      [0xb] =  0x004164bf
00416540  }

00416540    void sub_416540(int32_t* arg1, int32_t arg2)

00416540  {
00416548      for (int32_t i = arg2; i != 0xffffffff; i = sub_415700(arg1, i))
00416556          sub_415730(arg1, i, 0xff);
00416540  }

0041656f                                               90                                                                 .

00416570    int32_t sub_416570(int32_t* arg1, int32_t arg2, int32_t* arg3, int32_t* arg4)

00416570  {
00416576      int32_t* ebp = arg4;
00416582      int32_t result = sub_4165f0(arg2, arg3, ebp);
00416582      
0041658c      if (!result)
0041658c      {
00416595          int32_t* eax = sub_415f90(arg1, arg3);
004165a9          int32_t ebp_1;
004165a9          
004165a9          if (arg2 == 0x12 || arg2 == 0x14)
004165b9              ebp_1 = 0;
004165a9          else
004165b5              ebp_1 = sub_415f90(arg1, ebp);
004165b5          
004165c1          sub_415c40(arg1, arg4);
004165c8          sub_415c40(arg1, arg3);
004165d7          result = sub_416bf0(arg1, arg2, 0, eax, ebp_1);
004165df          arg3[2] = result;
004165e2          *(uint32_t*)arg3 = 0xb;
0041658c      }
0041658c      
004165ec      return result;
00416570  }

004165ed                                         90 90 90                                                               ...

004165f0    int32_t sub_4165f0(int32_t arg1, void* arg2, void* arg3)

004165f0  {
004165f0      int32_t __saved_ebp_1;
004165f0      int32_t __saved_ebp = __saved_ebp_1;
004165f9      int32_t __saved_esi_1;
004165f9      int32_t __saved_esi = __saved_esi_1;
004165fa      int32_t __saved_edi_1;
004165fa      int32_t __saved_edi = __saved_edi_1;
004165fe      void* var_24 = arg2;
004165fe      
00416609      if (sub_416770())
00416609      {
00416612          void* var_24_1 = arg3;
00416612          
0041661d          if (sub_416770())
0041661d          {
00416623              int32_t eax_2 = *(uint32_t*)((char*)arg2 + 8);
00416629              int32_t edx_1 = *(uint32_t*)((char*)arg3 + 8);
00416633              int32_t var_c_1 = *(uint32_t*)((char*)arg2 + 0xc);
0041663a              int32_t var_14_1 = *(uint32_t*)((char*)arg3 + 0xc);
0041663a              
00416648              if (arg1 - 0xc > 8)
00416648              {
00416739                  *(uint64_t*)((char*)arg2 + 8) = (double)(long double)0.0;
00416741                  return 1;
00416648              }
00416648              
0041664e              int32_t eax_4;
0041664e              
0041664e              switch (arg1)
0041664e              {
00416662                  case 0xc:
00416662                  {
00416662                      *(uint64_t*)((char*)arg2 + 8) =
00416662                          (double)((long double)edx_1 + (long double)eax_2);
0041666a                      return 1;
00416662                      break;
00416662                  }
00416678                  case 0xd:
00416678                  {
00416678                      *(uint64_t*)((char*)arg2 + 8) =
00416678                          (double)((long double)eax_2 - (long double)edx_1);
00416680                      return 1;
00416678                      break;
00416678                  }
0041668e                  case 0xe:
0041668e                  {
0041668e                      *(uint64_t*)((char*)arg2 + 8) =
0041668e                          (double)((long double)edx_1 * (long double)eax_2);
00416696                      return 1;
0041668e                      break;
0041668e                  }
00416697                  case 0xf:
00416697                  {
00416697                      long double x87_r7_7 = (long double)edx_1;
0041669b                      long double temp0_1 = (long double)0.0;
0041669b                      x87_r7_7 - temp0_1;
004166a1                      (uint16_t)eax_4 = (x87_r7_7 < temp0_1 ? 1 : 0) << 8
004166a1                          | (FCMP_UO(x87_r7_7, temp0_1) ? 1 : 0) << 0xa
004166a1                          | (x87_r7_7 == temp0_1 ? 1 : 0) << 0xe;
004166a1                      
004166a6                      if (!(*(uint8_t*)((char*)eax_4)[1] & 0x40))
004166a6                      {
004166b9                          *(uint64_t*)((char*)arg2 + 8) =
004166b9                              (double)((long double)eax_2 / (long double)edx_1);
004166c1                          return 1;
004166a6                      }
00416697                      break;
00416697                  }
004166c2                  case 0x10:
004166c2                  {
004166c2                      long double x87_r7_10 = (long double)edx_1;
004166c6                      long double temp1_1 = (long double)0.0;
004166c6                      x87_r7_10 - temp1_1;
004166cc                      (uint16_t)eax_4 = (x87_r7_10 < temp1_1 ? 1 : 0) << 8
004166cc                          | (FCMP_UO(x87_r7_10, temp1_1) ? 1 : 0) << 0xa
004166cc                          | (x87_r7_10 == temp1_1 ? 1 : 0) << 0xe;
004166cc                      
004166d1                      if (!(*(uint8_t*)((char*)eax_4)[1] & 0x40))
004166d1                      {
004166f6                          *(uint64_t*)((char*)arg2 + 8) = (double)((long double)eax_2 -
004166f6                              sub_41803f((double)((long double)eax_2 / (long double)edx_1))
004166f6                              * (long double)edx_1);
004166fe                          return 1;
004166d1                      }
004166c2                      break;
004166c2                  }
0041670c                  case 0x11:
0041670c                  {
0041670c                      *(uint64_t*)((char*)arg2 + 8) =
0041670c                          (double)sub_418110((long double)edx_1, (long double)eax_2);
00416719                      return 1;
0041670c                      break;
0041670c                  }
00416720                  case 0x12:
00416720                  {
00416720                      *(uint64_t*)((char*)arg2 + 8) = (double)-((long double)eax_2);
0041672d                      return 1;
00416720                      break;
00416720                  }
00416739                  case 0x13:
00416739                  {
00416739                      *(uint64_t*)((char*)arg2 + 8) = (double)(long double)0.0;
00416741                      return 1;
00416739                      break;
00416739                  }
0041664e              }
0041661d          }
00416609      }
00416609      
00416749      return 0;
004165f0  }

0041674a                                8b ff                                                                        ..
0041674c  uint32_t jump_table_41674c[0x9] = 
0041674c  {
0041674c      [0x0] =  0x00416655
00416750      [0x1] =  0x0041666b
00416754      [0x2] =  0x00416681
00416758      [0x3] =  0x00416697
0041675c      [0x4] =  0x004166c2
00416760      [0x5] =  0x004166ff
00416764      [0x6] =  0x0041671a
00416768      [0x7] =  0x0041672e
0041676c      [0x8] =  0x00416742
00416770  }

00416770    int32_t sub_416770(int32_t* arg1)

00416770  {
00416786      if (*(uint32_t*)arg1 == 5 && arg1[4] == 0xffffffff && arg1[5] == 0xffffffff)
0041678d          return 1;
0041678d      
00416790      return 0;
00416770  }

00416791                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

004167a0    int32_t sub_4167a0(int32_t* arg1, int32_t arg2, int32_t* arg3)

004167a0  {
004167a8      if (arg2 == 6)
00416805          return sub_415c00(arg1, arg3);
00416805      
004167ad      if (arg2 == 0xd)
004167fa          return sub_4161f0(arg1, arg3);
004167fa      
004167b0      if (arg2 == 0xe)
004167e6          return sub_416810(arg1, arg3);
004167e6      
004167b2      int32_t* esi_1 = arg3;
004167b7      int32_t result = sub_416770(esi_1);
004167b7      
004167c1      if (result)
0041680e          return result;
0041680e      
004167d2      return sub_415f90(arg1, esi_1);
004167a0  }

0041680f                                               90                                                                 .

00416810    int32_t sub_416810(int32_t* arg1, int32_t* arg2)

00416810  {
0041681c      sub_415b00(arg1, arg2);
00416826      int32_t eax_1 = *(uint32_t*)arg2 - 1;
0041682a      int32_t* eax_2;
0041682a      
0041682a      if (eax_1 > 9)
00416854          eax_2 = sub_4162d0(arg1, arg2, 1);
0041682a      else
0041682a      {
0041682e          int32_t ecx_1;
0041682e          (uint8_t)ecx_1 = lookup_table_416890[eax_1];
0041682e          
00416834          switch (ecx_1)
00416834          {
0041683b              case 0:
0041683b              {
0041683b                  eax_2 = 0xffffffff;
0041683b                  break;
0041683b              }
00416841              case 1:
00416841              {
00416841                  eax_2 = sub_4155b0(arg1);
00416841                  break;
00416841              }
0041684b              case 2:
0041684b              {
0041684b                  eax_2 = arg2[2];
0041684b                  break;
0041684b              }
00416854              case 3:
00416854              {
00416854                  eax_2 = sub_4162d0(arg1, arg2, 1);
00416854                  break;
00416854              }
00416834          }
0041682a      }
0041682a      
00416862      sub_415800(arg1, &arg2[4], eax_2);
0041686c      int32_t result = sub_4157e0(arg1, arg2[5]);
00416874      arg2[5] = 0xffffffff;
0041687d      return result;
00416810  }

0041687e                                                                                            8b ff                                ..
00416880  uint32_t jump_table_416880[0x4] = 
00416880  {
00416880      [0x0] =  0x0041683b
00416884      [0x1] =  0x00416840
00416888      [0x2] =  0x0041684b
0041688c      [0x3] =  0x00416850
00416890  }
00416890  uint8_t lookup_table_416890[0xa] = 
00416890  {
00416890      [0x0] =  0x00
00416891      [0x1] =  0x01
00416892      [0x2] =  0x00
00416893      [0x3] =  0x03
00416894      [0x4] =  0x03
00416895      [0x5] =  0x03
00416896      [0x6] =  0x03
00416897      [0x7] =  0x03
00416898      [0x8] =  0x03
00416899      [0x9] =  0x02
0041689a  }

0041689a                                                                                90 90 90 90 90 90                            ......

004168a0    int32_t* sub_4168a0(int32_t* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)

004168a0  {
004168aa      if (arg2 > 0xe)
00416b1b          return arg2;
00416b1b      
004168b0      switch (arg2)
004168b0      {
004169d0          case nullptr:
004169d0          {
004169d0              return sub_416570(arg1, 0xc, arg3, arg4);
004169d0              break;
004169d0          }
004169ed          case 1:
004169ed          {
004169ed              return sub_416570(arg1, 0xd, arg3, arg4);
004169ed              break;
004169ed          }
00416a0a          case 2:
00416a0a          {
00416a0a              return sub_416570(arg1, 0xe, arg3, arg4);
00416a0a              break;
00416a0a          }
00416a27          case 3:
00416a27          {
00416a27              return sub_416570(arg1, 0xf, arg3, arg4);
00416a27              break;
00416a27          }
00416a44          case 4:
00416a44          {
00416a44              return sub_416570(arg1, 0x10, arg3, arg4);
00416a44              break;
00416a44          }
00416a61          case 5:
00416a61          {
00416a61              return sub_416570(arg1, 0x11, arg3, arg4);
00416a61              break;
00416a61          }
0041693d          case 6:
0041693d          {
0041693d              sub_415f60(arg1, arg4);
0041693d              
0041695c              if (*(uint32_t*)arg4 != 0xb || (
0041695c                  (char)*(uint32_t*)(*(uint32_t*)(*(uint32_t*)arg1 + 0xc) + (arg4[2] << 2))
0041695c                  & 0x3f) != 0x15)
0041695c              {
0041699a                  sub_415c00(arg1, arg4);
004169b3                  return sub_416570(arg1, 0x15, arg3, arg4);
0041695c              }
0041695c              
00416964              sub_415c40(arg1, arg3);
0041696b              int32_t edx_6 = arg4[2];
00416971              int32_t eax_8 = *(uint32_t*)(*(uint32_t*)arg1 + 0xc);
00416989              *(uint32_t*)(eax_8 + (edx_6 << 2)) =
00416989                  (*(uint32_t*)(eax_8 + (edx_6 << 2)) & 0x7fffff) | arg3[2] << 0x17;
0041698b              int32_t eax_10 = *(uint32_t*)arg4;
0041698d              *(uint32_t*)arg3 = eax_10;
00416992              arg3[2] = arg4[2];
00416997              return eax_10;
0041693d              break;
0041693d          }
00416a9f          case 7:
00416a9f          {
00416a9f              return sub_416b60(arg1, 0x17, 0, arg3, arg4);
00416a9f              break;
00416a9f          }
00416a80          case 8:
00416a80          {
00416a80              return sub_416b60(arg1, 0x17, 1, arg3, arg4);
00416a80              break;
00416a80          }
00416abe          case 9:
00416abe          {
00416abe              return sub_416b60(arg1, 0x18, 1, arg3, arg4);
00416abe              break;
00416abe          }
00416add          case 0xa:
00416add          {
00416add              return sub_416b60(arg1, 0x19, 1, arg3, arg4);
00416add              break;
00416add          }
00416afc          case 0xb:
00416afc          {
00416afc              return sub_416b60(arg1, 0x18, 0, arg3, arg4);
00416afc              break;
00416afc          }
00416b10          case 0xc:
00416b10          {
00416b10              return sub_416b60(arg1, 0x19, 0, arg3, arg4);
00416b10              break;
00416b10          }
004168c1          case 0xd:
004168c1          {
004168c1              sub_415b00(arg1, arg4);
004168d3              sub_415800(arg1, &arg3[5], arg4[5]);
004168dd              *(uint32_t*)arg3 = *(uint32_t*)arg4;
004168df              int32_t eax_1 = arg4[2];
004168e2              arg3[2] = eax_1;
004168e8              arg3[3] = arg4[3];
004168ee              arg3[4] = arg4[4];
004168f4              return eax_1;
004168c1              break;
004168c1          }
004168ff          case 0xe:
004168ff          {
004168ff              sub_415b00(arg1, arg4);
00416911              sub_415800(arg1, &arg3[4], arg4[4]);
0041691b              *(uint32_t*)arg3 = *(uint32_t*)arg4;
0041691d              int32_t eax_3 = arg4[2];
00416920              arg3[2] = eax_3;
00416926              arg3[3] = arg4[3];
0041692c              arg3[5] = arg4[5];
00416932              return eax_3;
004168ff              break;
004168ff          }
004168b0      }
004168a0  }

00416b1c  uint32_t jump_table_416b1c[0xf] = 
00416b1c  {
00416b1c      [0x0] =  0x004169b4
00416b20      [0x1] =  0x004169d1
00416b24      [0x2] =  0x004169ee
00416b28      [0x3] =  0x00416a0b
00416b2c      [0x4] =  0x00416a28
00416b30      [0x5] =  0x00416a45
00416b34      [0x6] =  0x00416933
00416b38      [0x7] =  0x00416a81
00416b3c      [0x8] =  0x00416a62
00416b40      [0x9] =  0x00416aa0
00416b44      [0xa] =  0x00416abf
00416b48      [0xb] =  0x00416ade
00416b4c      [0xc] =  0x00416afd
00416b50      [0xd] =  0x004168b7
00416b54      [0xe] =  0x004168f5
00416b58  }

00416b58                                                                          90 90 90 90 90 90 90 90                          ........

00416b60    int32_t* sub_416b60(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t* arg4, int32_t* arg5)

00416b60  {
00416b73      int32_t ebx = sub_415f90(arg1, arg4);
00416b84      int32_t ebp = sub_415f90(arg1, arg5);
00416b88      sub_415c40(arg1, arg5);
00416b8f      sub_415c40(arg1, arg4);
00416b94      int32_t eax_3 = arg3;
00416b94      
00416ba6      if (!eax_3 && arg2 != 0x17)
00416ba6      {
00416ba8          int32_t eax_4 = ebx;
00416baa          ebx = ebp;
00416bac          ebp = eax_4;
00416bae          eax_3 = 1;
00416ba6      }
00416ba6      
00416bb8      int32_t* result = sub_416350(arg1, arg2, eax_3, ebx, ebp);
00416bc0      arg4[2] = result;
00416bc3      *(uint32_t*)arg4 = 0xa;
00416bcd      return result;
00416b60  }

00416bce                                            90 90                                                                ..

00416bd0    int32_t sub_416bd0(int32_t* arg1, int32_t arg2)

00416bd0  {
00416bd9      int32_t result = *(uint32_t*)(*(uint32_t*)arg1 + 0x14);
00416be0      *(uint32_t*)(result + (arg1[6] << 2) - 4) = arg2;
00416be4      return result;
00416bd0  }

00416be5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00416bf0    int32_t sub_416bf0(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)

00416bf0  {
00416c24      return sub_416c30(arg1, ((arg4 << 9 | arg5) << 8 | arg3) << 6 | arg2, 
00416c24          *(uint32_t*)(arg1[3] + 8));
00416bf0  }

00416c25                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00416c30    int32_t sub_416c30(int32_t* arg1, int32_t arg2, int32_t arg3)

00416c30  {
00416c37      void* edi = *(uint32_t*)arg1;
00416c39      sub_416cd0(arg1);
00416c39      
00416c4d      if (arg1[6] + 1 > *(uint32_t*)((char*)edi + 0x2c))
00416c6c          *(uint32_t*)((char*)edi + 0xc) = sub_404c50(arg1[4], 
00416c6c              *(uint32_t*)((char*)edi + 0xc), (char*)edi + 0x2c, 4, 0x7ffffffd, 
00416c6c              "code size overflow");
00416c6c      
00416c79      *(uint32_t*)(*(uint32_t*)((char*)edi + 0xc) + (arg1[6] << 2)) = arg2;
00416c79      
00416c88      if (arg1[6] + 1 > *(uint32_t*)((char*)edi + 0x30))
00416ca7          *(uint32_t*)((char*)edi + 0x14) = sub_404c50(arg1[4], 
00416ca7              *(uint32_t*)((char*)edi + 0x14), (char*)edi + 0x30, 4, 0x7ffffffd, 
00416ca7              "code size overflow");
00416ca7      
00416cb5      *(uint32_t*)(*(uint32_t*)((char*)edi + 0x14) + (arg1[6] << 2)) = arg3;
00416cb8      int32_t result = arg1[6];
00416cbe      arg1[6] = result + 1;
00416cc2      return result;
00416c30  }

00416cc3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00416cd0    int32_t sub_416cd0(int32_t* arg1)

00416cd0  {
00416cd5      int32_t eax = arg1[6];
00416ce4      int32_t result = sub_415660(arg1, arg1[8], eax, 0xff, eax);
00416cec      arg1[8] = 0xffffffff;
00416cf4      return result;
00416cd0  }

00416cf5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00416d00    int32_t sub_416d00(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00416d00  {
00416d2b      return sub_416c30(arg1, (arg4 << 8 | arg3) << 6 | arg2, *(uint32_t*)(arg1[3] + 8));
00416d00  }

00416d2c                                      90 90 90 90                                                              ....

00416d30    int32_t sub_416d30(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00416d30  {
00416d53      int32_t eax_3 = -((arg4 + 1));
00416d57      int32_t eax_5 = (eax_3 - eax_3) & arg4;
00416d57      
00416d5f      if ((arg3 - 1) / 0x32 + 1 <= 0x1ff)
00416d5f      {
00416d6f          int32_t eax_6 = sub_416bf0(arg1, 0x22, arg2, eax_5, (arg3 - 1) / 0x32 + 1);
00416d78          arg1[9] = arg2 + 1;
00416d7d          return eax_6;
00416d5f      }
00416d5f      
00416d8e      sub_416bf0(arg1, 0x22, arg2, eax_5, 0);
00416d9c      int32_t eax_8 = sub_416c30(arg1, (arg3 - 1) / 0x32 + 1, *(uint32_t*)(arg1[3] + 8));
00416da5      arg1[9] = arg2 + 1;
00416dab      return eax_8;
00416d30  }

00416dac                                      90 90 90 90                                                              ....

00416db0    int32_t sub_416db0()

00416db0  {
00416db0      sub_416dc8();
00416dba      data_4307a8 = sub_41adb7();
00416dbf      int32_t result = sub_41ad67();
00416dc4      __fnclex();
00416dc6      return result;
00416db0  }


00416dc7    int32_t sub_416dc7() __pure

00416dc7  {
00416dc7      return;
00416dc7  }


00416dc8    int32_t sub_416dc8()

00416dc8  {
00416dcd      data_42d384 = sub_41ae3a;
00416dd7      data_42d380 = sub_41b1a5;
00416ddc      data_42d388 = sub_41aea0;
00416de6      data_42d38c = sub_41ade0;
00416df0      data_42d390 = sub_41ae88;
00416dfa      data_42d394 = sub_41b1a5;
00416dff      return sub_41b1a5;
00416dc8  }


00416e00    int32_t sub_416e00(int32_t* arg1)

00416e00  {
00416e06      int32_t result_1 = 0xffffffff;
00416e09      char eax = (char)arg1[3];
00416e0e      int32_t result;
00416e0e      
00416e0e      if (!(eax & 0x40))
00416e0e      {
00416e17          if (eax & 0x83)
00416e17          {
00416e20              result_1 = sub_41ac69(arg1);
00416e22              sub_41b2ce(arg1);
00416e2a              int32_t eax_2;
00416e2a              int32_t* ecx_1;
00416e2a              eax_2 = sub_41b21b(arg1[4]);
00416e2a              
00416e34              if (eax_2 >= 0)
00416e34              {
00416e3b                  int32_t eax_3 = arg1[7];
00416e3b                  
00416e40                  if (eax_3)
00416e40                  {
00416e42                      int32_t var_c_2 = eax_3;
00416e43                      sub_41784c(ecx_1);
00416e48                      arg1[7] = 0;
00416e40                  }
00416e34              }
00416e34              else
00416e36                  result_1 = 0xffffffff;
00416e17          }
00416e17          
00416e4d          result = result_1;
00416e0e      }
00416e0e      else
00416e10          result = 0xffffffff;
00416e10      
00416e4f      arg1[3] = 0;
00416e55      return result;
00416e00  }


00416e56    uint32_t sub_416e56(void* arg1, int32_t arg2, uint32_t arg3, int32_t* arg4)

00416e56  {
00416e59      int32_t ecx;
00416e59      int32_t var_8 = ecx;
00416e60      void* edi_1 = arg2 * arg3;
00416e64      char* ebx = arg1;
00416e67      void* ecx_1 = edi_1;
00416e6b      void* var_8_1 = edi_1;
00416e6e      arg1 = ecx_1;
00416e6e      
00416e71      if (!edi_1)
00416e73          return 0;
00416e73      
00416e7a      int32_t* esi_1 = arg4;
00416e7a      
00416e83      if (!(esi_1[3] & 0x10c))
00416e8d          arg4 = 0x1000;
00416e83      else
00416e88          arg4 = esi_1[6];
00416e88      
00416e9f      while (true)
00416e9f      {
00416e9f          void* eax_3;
00416e9f          
00416e9f          if (esi_1[3] & 0x10c)
00416ea1              eax_3 = esi_1[1];
00416ea1          
00416ea6          if (esi_1[3] & 0x10c && eax_3)
00416ea6          {
00416eaa              void* edi_2 = ecx_1;
00416eaa              
00416eac              if (ecx_1 >= eax_3)
00416eae                  edi_2 = eax_3;
00416eae              
00416eb4              sub_41b4f0(ebx, *(uint32_t*)esi_1, edi_2);
00416eb9              arg1 -= edi_2;
00416ebc              esi_1[1] -= edi_2;
00416ebf              *(uint32_t*)esi_1 += edi_2;
00416ec4              ebx += edi_2;
00416ec6              edi_1 = var_8_1;
00416ea6          }
00416ea6          else if (ecx_1 < arg4)
00416ece          {
00416eff              uint32_t eax_7 = sub_41741a(esi_1);
00416eff              
00416f08              if (eax_7 == 0xffffffff)
00416f08                  break;
00416f08              
00416f0a              *(uint8_t*)ebx = (uint8_t)eax_7;
00416f0f              ebx = &ebx[1];
00416f10              arg1 -= 1;
00416f13              arg4 = esi_1[6];
00416ece          }
00416ece          else
00416ece          {
00416ed4              void* eax_4 = ecx_1;
00416ed4              
00416ed6              if (arg4)
00416edf                  eax_4 = (char*)ecx_1 - COMBINE(0, eax_4) % arg4;
00416edf              
00416ee6              void* eax_6 = sub_41b2f9(esi_1[4], ebx, eax_4);
00416ee6              
00416ef0              if (!eax_6)
00416ef0              {
00416f28                  esi_1[3] |= 0x10;
00416f2c                  break;
00416ef0              }
00416ef0              
00416ef5              if (eax_6 == 0xffffffff)
00416ef5              {
00416f2e                  esi_1[3] |= 0x20;
00416f2e                  break;
00416ef5              }
00416ef5              
00416ef7              arg1 -= eax_6;
00416efa              ebx += eax_6;
00416ece          }
00416ece          
00416f1a          if (!arg1)
00416f20              return arg3;
00416f20          
00416e96          ecx_1 = arg1;
00416e9f      }
00416e9f      
00416f27      return COMBINE(0, (char*)edi_1 - arg1) / arg2;
00416e56  }


00416f3e    int32_t sub_416f3e(int32_t* arg1, void* arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)

00416f3e  {
00416f44      int32_t eax = arg1[3];
00416f44      
00416f49      if ((uint8_t)eax & 0x83)
00416f49      {
00416f4b          enum SET_FILE_POINTER_MOVE_METHOD edi_1 = arg3;
00416f4b          
00416f5b          if (!edi_1 || edi_1 == FILE_CURRENT || edi_1 == FILE_END)
00416f5b          {
00416f5d              (uint8_t)eax &= 0xef;
00416f62              arg1[3] = eax;
00416f62              
00416f65              if (edi_1 == FILE_CURRENT)
00416f65              {
00416f6d                  arg2 += sub_41aa35(arg1);
00416f72                  edi_1 = FILE_BEGIN;
00416f65              }
00416f65              
00416f75              sub_41ac69(arg1);
00416f7a              int32_t eax_2 = arg1[3];
00416f7a              
00416f80              if ((uint8_t)eax_2 & 0x80)
00416f80              {
00416f82                  (uint8_t)eax_2 &= 0xfc;
00416f84                  arg1[3] = eax_2;
00416f80              }
00416f80              else if ((uint8_t)eax_2 & 1 && (uint8_t)eax_2 & 8
00416f80                      && !(*(uint8_t*)((char*)eax_2)[1] & 4))
00416f96                  arg1[6] = 0x200;
00416f96              
00416fb2              int32_t ecx_3;
00416fb2              (uint8_t)ecx_3 = sub_41b825(arg1[4], arg2, edi_1) != 0xffffffff;
00416fb6              return ecx_3 - 1;
00416f5b          }
00416f49      }
00416f49      
00416fba      data_4307d4 = 0x16;
00416fc4      return 0xffffffff;
00416f3e  }


00416fca    int32_t sub_416fca(int32_t arg1)

00416fca  {
00416fce      int32_t eax = data_42d450;
00416fce      
00416fd9      if (arg1 >= 0 && arg1 < eax)
00416fdb          eax = arg1;
00416fdb      
00416feb      sub_41b8c0(0x4307ac, (&data_42d3a0)[eax]);
00416ff5      return 0x4307ac;
00416fca  }


00416ff6    int32_t sub_416ff6()

00416ff6  {
00416ff6      void* eax_1 = data_42cbd4;
00416ff6      
00416ffd      if (eax_1)
00416fff          eax_1();
00416fff      
0041700b      sub_4170de(0x42b008, 0x42b018);
00417022      return sub_4170de(0x42b000, 0x42b004);
00416ff6  }


00417023    int32_t sub_417023(uint32_t arg1)

00417023  {
00417033      return sub_417045(arg1, 0, 0);
00417023  }


00417034    int32_t sub_417034(uint32_t arg1)

00417034  {
00417044      return sub_417045(arg1, 1, 0);
00417034  }


00417045    int32_t sub_417045(uint32_t arg1, int32_t arg2, int32_t arg3)

00417045  {
0041704f      if (data_43081c == 1)
0041704f      {
0041705c          TerminateProcess(GetCurrentProcess(), arg1);
0041705c          /* no return */
0041704f      }
0041704f      
0041706c      data_430818 = 1;
00417072      data_430814 = (uint8_t)arg3;
00417072      
00417078      if (!arg2)
00417078      {
0041707a          int32_t eax_2 = data_431f54;
0041707a          
00417081          if (eax_2)
00417081          {
0041708a              int32_t* i = data_431f50 - 4;
0041708a              
0041708f              if (i >= eax_2)
0041708f              {
004170a2                  do
004170a2                  {
00417091                      int32_t eax_3 = *(uint32_t*)i;
00417091                      
00417095                      if (eax_3)
00417097                          eax_3();
00417097                      
00417099                      i -= 4;
004170a2                  } while (i >= data_431f54);
0041708f              }
00417081          }
00417081          
004170af          sub_4170de(0x42b01c, 0x42b028);
00417078      }
00417078      
004170c0      int32_t result = sub_4170de(0x42b02c, 0x42b030);
004170c0      
004170ca      if (arg3)
004170dd          return result;
004170dd      
004170d0      data_43081c = 1;
004170d6      ExitProcess(arg1);
004170d6      /* no return */
00417045  }


004170de    void sub_4170de(int32_t* arg1, int32_t arg2)

004170de  {
004170e7      for (int32_t* i = arg1; i < arg2; i = &i[1])
004170e7      {
004170e9          int32_t eax = *(uint32_t*)i;
004170e9          
004170ed          if (eax)
004170ef              eax();
004170e7      }
004170de  }


004170f8    int32_t* sub_4170f8(PSTR arg1, char* arg2, char arg3)

004170f8  {
004170f8      int32_t* result = sub_41bb20();
004170f8      
004170ff      if (result)
00417117          return sub_41b9b0(arg1, arg2, arg3, result);
00417117      
00417101      return result;
004170f8  }


00417118    int32_t* sub_417118(PSTR arg1, char* arg2)

00417118  {
0041712a      return sub_4170f8(arg1, arg2, 0x40);
00417118  }


0041712b    int32_t _start()

0041712b  {
0041712b      int32_t ebp;
0041712b      int32_t var_4 = ebp;
0041712e      int32_t var_8 = 0xffffffff;
00417130      int32_t var_c = 0x428ab0;
00417135      int32_t var_10 = 0x41c5cc;
00417140      TEB* fsbase;
00417140      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
00417141      fsbase->NtTib.ExceptionList = &ExceptionList;
0041714b      int32_t ebx;
0041714b      int32_t var_28 = ebx;
0041714c      int32_t esi;
0041714c      int32_t var_2c = esi;
0041714d      int32_t edi;
0041714d      int32_t var_30 = edi;
0041714e      int32_t* var_1c = &var_30;
00417151      uint32_t eax_1 = GetVersion();
00417159      int32_t edx;
00417159      (uint8_t)edx = *(uint8_t*)((char*)eax_1)[1];
0041715b      data_4307ec = edx;
00417163      uint32_t ecx_1 = (uint32_t)(uint8_t)eax_1;
00417169      data_4307e8 = ecx_1;
00417174      data_4307e4 = (ecx_1 << 8) + edx;
0041717d      data_4307e0 = eax_1 >> 0x10;
0041717d      
0041718c      if (!sub_41c474(0))
0041718c      {
00417190          sub_41722f(0x1c);
00417190          /* no return */
0041718c      }
0041718c      
00417196      int32_t var_8_1 = 0;
0041719a      sub_41c154();
004171a5      data_431f44 = GetCommandLineA();
004171aa      void* eax_5;
004171aa      int32_t ecx_5;
004171aa      eax_5 = sub_41c022();
004171af      data_430820 = eax_5;
004171b4      sub_41bdd5(ecx_5);
004171b9      sub_41bd1c();
004171be      sub_416ff6();
004171c3      int32_t eax_6 = data_4307fc;
004171c8      data_430800 = eax_6;
004171cd      int32_t var_34 = eax_6;
004171ce      int32_t var_38 = data_4307f4;
004171da      uint32_t eax_7 = sub_401000(data_4307f0);
004171e2      uint32_t var_20 = eax_7;
004171e6      sub_417023(eax_7);
004171f0      int32_t* var_18;
004171f0      int32_t ecx_7 = **(uint32_t**)var_18;
004171f2      int32_t var_24 = ecx_7;
004171fe      return sub_41bb98(ecx_7, var_18);
0041712b  }

00417195                                                                 59                                                     Y
004171ff                                                                                               8b                                 .
00417200  65 e8 ff 75 e0 e8 2a fe ff ff                                                                    e..u..*...

0041720a    int32_t sub_41720a(uint32_t arg1)

0041720a  {
00417211      if (data_430828 != 2)
00417213          sub_41c6a4();
00417213      
0041721c      sub_41c6dd(arg1);
0041722e      return data_42cbe0(0xff);
0041720a  }


0041722f    void sub_41722f(uint32_t arg1) __noreturn

0041722f  {
00417236      if (data_430828 != 2)
00417238          sub_41c6a4();
00417238      
00417241      sub_41c6dd(arg1);
0041724c      ExitProcess(0xff);
0041724c      /* no return */
0041722f  }

00417252                                                        c3 cc cc cc cc cc cc cc cc cc cc cc cc cc                    ..............

00417260    char* sub_417260(char* arg1, void* arg2)

00417260  {
00417260      char* ecx_1 = arg2;
00417267      int16_t edx;
00417267      (uint8_t)edx = *(uint8_t*)ecx_1;
00417269      char* result = arg1;
00417269      
0041726f      if (!(uint8_t)edx)
004172df          return result;
004172df      
00417271      *(uint8_t*)((char*)edx)[1] = ecx_1[1];
00417271      
00417276      if (*(uint8_t*)((char*)edx)[1])
00417276      {
0041727a          while (true)
0041727a          {
0041727a              void* ecx = arg2;
0041727e              int16_t eax;
0041727e              (uint8_t)eax = *(uint8_t*)result;
00417280              void* esi_2 = &result[1];
00417280              
00417283              if ((uint8_t)eax != (uint8_t)edx)
00417283              {
00417287                  if (!(uint8_t)eax)
00417299                      return 0;
00417299                  
00417289                  while (true)
00417289                  {
00417289                      (uint8_t)eax = *(uint8_t*)esi_2;
0041728b                      esi_2 += 1;
0041728c                  label_41728c:
0041728c                      
0041728e                      if ((uint8_t)eax == (uint8_t)edx)
0041728e                          break;
0041728e                      
00417292                      if (!(uint8_t)eax)
00417299                          return 0;
00417289                  }
00417283              }
00417283              
0041729a              (uint8_t)eax = *(uint8_t*)esi_2;
0041729c              esi_2 += 1;
0041729c              
0041729f              if ((uint8_t)eax != *(uint8_t*)((char*)edx)[1])
0041729f                  break;
0041729f              
004172a1              result = (char*)esi_2 - 1;
004172a1              
004172a4              while (true)
004172a4              {
004172a4                  *(uint8_t*)((char*)eax)[1] = *(uint8_t*)((char*)ecx + 2);
004172a4                  
004172a9                  if (*(uint8_t*)((char*)eax)[1])
004172a9                  {
004172ab                      (uint8_t)eax = *(uint8_t*)esi_2;
004172ad                      esi_2 += 2;
004172ad                      
004172b2                      if ((uint8_t)eax != *(uint8_t*)((char*)eax)[1])
004172b2                          break;
004172b2                      
004172b4                      (uint8_t)eax = *(uint8_t*)((char*)ecx + 3);
004172b4                      
004172b9                      if ((uint8_t)eax)
004172b9                      {
004172bb                          *(uint8_t*)((char*)eax)[1] = *(uint8_t*)((char*)esi_2 - 1);
004172be                          ecx += 2;
004172be                          
004172c3                          if ((uint8_t)eax != *(uint8_t*)((char*)eax)[1])
004172c3                              break;
004172c3                          
004172c3                          continue;
004172b9                      }
004172a9                  }
004172a9                  
004172d9                  return &result[0xffffffff];
004172a4              }
0041727a          }
0041727a          
0041729f          goto label_41728c;
00417276      }
00417276      
004172cc      int32_t eax_2;
004172cc      (uint8_t)eax_2 = (uint8_t)edx;
004172f6      int32_t ebx;
004172f6      int32_t var_4_1 = ebx;
004172fc      char* edx_1 = arg1;
004172fc      
00417306      while (edx_1 & 3)
00417306      {
00417308          (uint8_t)ecx_1 = *(uint8_t*)edx_1;
0041730a          edx_1 = &edx_1[1];
0041730a          
0041730d          if ((uint8_t)ecx_1 == (uint8_t)eax_2)
004172e4              return &edx_1[0xffffffff];
004172e4          
00417311          if (!(uint8_t)ecx_1)
00417367              return 0;
00417306      }
00417306      
0041731b      int32_t ebx_7 = eax_2 | eax_2 << 8;
0041731d      int32_t edi;
0041731d      int32_t var_8_1 = edi;
00417323      int32_t esi;
00417323      int32_t var_c_1 = esi;
00417324      int32_t ebx_9 = ebx_7 << 0x10 | ebx_7;
00417324      
00417326      while (true)
00417326      {
00417326          int32_t ecx_2 = *(uint32_t*)edx_1;
00417331          int32_t ecx_3 = ecx_2 ^ ebx_9;
00417341          edx_1 = &edx_1[4];
00417341          
0041734a          if ((ecx_3 ^ 0xffffffff ^ (0x7efefeff + ecx_3)) & 0x81010100)
0041734a          {
00417368              int32_t eax_14 = *(uint32_t*)(edx_1 - 4);
00417368              
0041736d              if ((uint8_t)eax_14 == (uint8_t)ebx_9)
004173ab                  return &edx_1[0xfffffffc];
004173ab              
00417371              if (!(uint8_t)eax_14)
00417371                  break;
00417371              
00417375              if (*(uint8_t*)((char*)eax_14)[1] == (uint8_t)ebx_9)
004173a4                  return &edx_1[0xfffffffd];
004173a4              
00417379              if (!*(uint8_t*)((char*)eax_14)[1])
00417379                  break;
00417379              
0041737b              uint16_t eax_15 = (int16_t)(eax_14 >> 0x10);
0041737b              
00417380              if ((uint8_t)eax_15 == (uint8_t)ebx_9)
0041739d                  return &edx_1[0xfffffffe];
0041739d              
00417384              if (!(uint8_t)eax_15)
00417384                  break;
00417384              
00417388              if (*(uint8_t*)((char*)eax_15)[1] == (uint8_t)ebx_9)
00417396                  return &edx_1[0xffffffff];
00417396              
0041738c              if (!*(uint8_t*)((char*)eax_15)[1])
0041738c                  break;
0041734a          }
0041734a          else
0041734a          {
0041734c              int32_t eax_11 = (ecx_2 ^ 0xffffffff ^ (0x7efefeff + ecx_2)) & 0x81010100;
0041734c              
00417351              if (eax_11)
00417351              {
00417358                  if (eax_11 & 0x1010100)
00417358                      break;
00417358                  
00417360                  if (!((0x7efefeff + ecx_2) & 0x80000000))
00417360                      break;
00417351              }
0041734a          }
00417326      }
00417326      
00417367      return 0;
00417260  }

004172e5                 8d a4 24 00 00 00 00 8d 64 24 00                                                       ..$.....d$.

004172f0    void* sub_4172f0(char* arg1, char arg2)

004172f0  {
004172f2      int32_t eax;
004172f2      (uint8_t)eax = arg2;
004172fc      char* edx = arg1;
004172fc      
00417306      while (edx & 3)
00417306      {
00417308          char ecx = *(uint8_t*)edx;
0041730a          edx = &edx[1];
0041730a          
0041730d          if (ecx == (uint8_t)eax)
004172e4              return &edx[0xffffffff];
004172e4          
00417311          if (!ecx)
00417367              return 0;
00417306      }
00417306      
0041731b      int32_t ebx_1 = eax | eax << 8;
00417324      int32_t ebx_3 = ebx_1 << 0x10 | ebx_1;
00417324      
00417326      while (true)
00417326      {
00417326          int32_t ecx_1 = *(uint32_t*)edx;
00417331          int32_t ecx_2 = ecx_1 ^ ebx_3;
00417341          edx = &edx[4];
00417341          
0041734a          if ((ecx_2 ^ 0xffffffff ^ (0x7efefeff + ecx_2)) & 0x81010100)
0041734a          {
00417368              int32_t eax_9 = *(uint32_t*)(edx - 4);
00417368              
0041736d              if ((uint8_t)eax_9 == (uint8_t)ebx_3)
004173ab                  return &edx[0xfffffffc];
004173ab              
00417371              if (!(uint8_t)eax_9)
00417371                  break;
00417371              
00417375              if (*(uint8_t*)((char*)eax_9)[1] == (uint8_t)ebx_3)
004173a4                  return &edx[0xfffffffd];
004173a4              
00417379              if (!*(uint8_t*)((char*)eax_9)[1])
00417379                  break;
00417379              
0041737b              uint16_t eax_10 = (int16_t)(eax_9 >> 0x10);
0041737b              
00417380              if ((uint8_t)eax_10 == (uint8_t)ebx_3)
0041739d                  return &edx[0xfffffffe];
0041739d              
00417384              if (!(uint8_t)eax_10)
00417384                  break;
00417384              
00417388              if (*(uint8_t*)((char*)eax_10)[1] == (uint8_t)ebx_3)
00417396                  return &edx[0xffffffff];
00417396              
0041738c              if (!*(uint8_t*)((char*)eax_10)[1])
0041738c                  break;
0041734a          }
0041734a          else
0041734a          {
0041734c              int32_t eax_6 = (ecx_1 ^ 0xffffffff ^ (0x7efefeff + ecx_1)) & 0x81010100;
0041734c              
00417351              if (eax_6)
00417351              {
00417358                  if (eax_6 & 0x1010100)
00417358                      break;
00417358                  
00417360                  if (!((0x7efefeff + ecx_1) & 0x80000000))
00417360                      break;
00417351              }
0041734a          }
00417326      }
00417326      
00417367      return 0;
004172f0  }


004173ac    uint32_t sub_4173ac(int32_t arg1, int32_t* arg2)

004173ac  {
004173b5      if (arg1 != 0xffffffff)
004173b5      {
004173bb          char eax_1 = (char)arg2[3];
004173bb          
004173c0          if (eax_1 & 1)
004173c0          {
004173ce          label_4173ce:
004173ce              
004173ce              if (!arg2[2])
004173d1                  sub_41c830(arg2);
004173d1              
004173d7              int32_t eax_2 = *(uint32_t*)arg2;
004173d7              
004173dc              if (eax_2 != arg2[2])
004173dc                  goto label_4173e7;
004173dc              
004173e2              if (!arg2[1])
004173e2              {
004173e5                  *(uint32_t*)arg2 = eax_2 + 1;
004173e7              label_4173e7:
004173e7                  
004173eb                  if (!(arg2[3] & 0x40))
004173eb                  {
004173fe                      *(uint32_t*)arg2 -= 1;
00417402                      **(uint8_t**)arg2 = (uint8_t)arg1;
00417404                  label_417404:
00417404                      int32_t eax_8 = arg2[3];
00417407                      arg2[1] += 1;
0041740a                      (uint8_t)eax_8 &= 0xef;
0041740c                      (uint8_t)eax_8 |= 1;
0041740e                      arg2[3] = eax_8;
00417413                      return (uint32_t)(uint8_t)arg1;
004173eb                  }
004173eb                  
004173ed                  *(uint32_t*)arg2 -= 1;
004173ef                  char* eax_4 = *(uint32_t*)arg2;
004173ef                  
004173f3                  if (*(uint8_t*)eax_4 == (uint8_t)arg1)
004173f3                      goto label_417404;
004173f3                  
004173f6                  *(uint32_t*)arg2 = &eax_4[1];
004173e2              }
004173c0          }
004173c0          else if (eax_1 & 0x80 && !(eax_1 & 2))
004173c8              goto label_4173ce;
004173b5      }
004173b5      
004173f8      return 0xffffffff;
004173ac  }


0041741a    uint32_t sub_41741a(int32_t* arg1)

0041741a  {
0041741f      int32_t eax = arg1[3];
0041741f      
0041742c      if ((uint8_t)eax & 0x83 && !((uint8_t)eax & 0x40))
0041742c      {
00417434          if (!((uint8_t)eax & 2))
00417434          {
00417440              (uint8_t)eax |= 1;
00417446              arg1[3] = eax;
00417446              
00417449              if ((uint16_t)eax & 0x10c)
00417457                  *(uint32_t*)arg1 = arg1[2];
00417449              else
0041744c                  sub_41c830(arg1);
0041744c              
00417462              void* eax_2 = sub_41b2f9(arg1[4], arg1[2], arg1[6]);
0041746a              arg1[1] = eax_2;
0041746a              
00417474              if (eax_2 && eax_2 != 0xffffffff)
00417474              {
00417476                  int32_t edx = arg1[3];
00417476                  
0041747c                  if (!((uint8_t)edx & 0x82))
0041747c                  {
0041747e                      int32_t ecx_2 = arg1[4];
00417485                      void* edi_4;
00417485                      
00417485                      if (ecx_2 == 0xffffffff)
0041749b                          edi_4 = &data_42d4e0;
00417485                      else
00417496                          edi_4 = (&data_430e20)[ecx_2 >> 5] + ((ecx_2 & 0x1f) << 3);
00417496                      
004174a0                      (uint8_t)ecx_2 = *(uint8_t*)((char*)edi_4 + 4);
004174a4                      (uint8_t)ecx_2 &= 0x82;
004174a4                      
004174aa                      if ((uint8_t)ecx_2 == 0x82)
004174aa                      {
004174ac                          *(uint8_t*)((char*)edx)[1] |= 0x20;
004174af                          arg1[3] = edx;
004174aa                      }
0041747c                  }
0041747c                  
004174b9                  if (arg1[6] == 0x200)
004174b9                  {
004174bb                      int16_t ecx_3 = (int16_t)arg1[3];
004174bb                      
004174c6                      if ((uint8_t)ecx_3 & 8 && !(*(uint8_t*)((char*)ecx_3)[1] & 4))
004174c8                          arg1[6] = 0x1000;
004174b9                  }
004174b9                  
004174cf                  char* ecx_4 = *(uint32_t*)arg1;
004174d2                  arg1[1] = (char*)eax_2 - 1;
004174d5                  uint32_t result = (uint32_t)*(uint8_t*)ecx_4;
004174d9                  *(uint32_t*)arg1 = &ecx_4[1];
004174dc                  return result;
00417474              }
00417474              
004174dd              int32_t eax_4 = -(eax_2);
004174e7              arg1[3] |= ((eax_4 - eax_4) & 0x10) + 0x10;
004174ea              arg1[1] = 0;
00417434          }
00417434          else
00417434          {
00417436              (uint8_t)eax |= 0x20;
00417438              arg1[3] = eax;
00417434          }
0041742c      }
0041742c      
004174f2      return 0xffffffff;
0041741a  }


004174f3    int32_t sub_4174f3()

004174f3  {
004174f3      uint32_t eax = data_431f40;
004174f3      
004174fe      if (!eax)
004174fe      {
00417500          eax = 0x200;
0041750d          data_431f40 = eax;
004174fe      }
004174fe      else if (eax < 0x14)
00417509      {
0041750b          eax = 0x14;
0041750d          data_431f40 = eax;
00417509      }
00417509      
00417515      void* eax_1 = sub_41c874(eax, 4);
0041751b      data_430f2c = eax_1;
0041751b      
00417523      if (!eax_1)
00417523      {
00417528          data_431f40 = 0x14;
0041752e          void* eax_2 = sub_41c874(0x14, 4);
00417534          data_430f2c = eax_2;
00417534          
0041753c          if (!eax_2)
00417540              sub_41720a(0x1a);
00417523      }
00417523      
00417546      void** ecx_3 = nullptr;
00417546      
00417561      for (void* i = &data_42cbf0; i < &data_42ce70; )
00417561      {
00417553          *(uint32_t*)((char*)ecx_3 + data_430f2c) = i;
00417556          i += 0x20;
00417559          ecx_3 = &ecx_3[1];
00417561      }
00417561      
00417563      int32_t edx_2 = 0;
00417594      int32_t result;
00417594      
00417594      for (void* i_1 = &data_42cc00; i_1 < 0x42cc60; )
00417594      {
0041757b          result = *(uint32_t*)((&data_430e20)[edx_2 >> 5] + ((edx_2 & 0x1f) << 3));
0041757b          
00417585          if (result == 0xffffffff || !result)
00417587              *(uint32_t*)i_1 = 0xffffffff;
00417587          
0041758a          i_1 += 0x20;
0041758d          edx_2 += 1;
00417594      }
00417594      
00417597      return result;
004174f3  }


00417598    int32_t sub_417598()

00417598  {
00417598      int32_t result = sub_41acc5();
00417598      
004175a4      if (!data_430814)
004175ab          return result;
004175ab      
004175a6      /* tailcall */
004175a6      return sub_41c925();
00417598  }


004175ac    void* __convention("regparm") sub_4175ac(int32_t arg1, int32_t arg2, void** arg3, char* arg4)

004175ac  {
004175af      void** var_8 = arg3;
004175b7      uint32_t dwBytes_1;
004175b7      
004175b7      if (!arg4)
0041784b          return sub_41dbac(dwBytes_1);
0041784b      
004175c7      uint32_t dwBytes = dwBytes_1;
004175c7      
004175cc      if (dwBytes)
004175cc      {
004175dc          int32_t eax_1 = data_430e08;
004175e4          char* edi_1;
004175e4          
004175e4          if (eax_1 == 3)
004175e4          {
004175ea              while (true)
004175ea              {
004175ea                  edi_1 = nullptr;
004175ea                  
004175ef                  if (dwBytes <= 0xffffffe0)
004175ef                  {
004175fd                      void* ebx_1 = sub_41c9c5(arg4);
004175fd                      
00417602                      if (!ebx_1)
00417602                      {
004176a5                      label_4176a5:
004176a5                          
004176a5                          if (!dwBytes)
004176a9                              dwBytes = 1;
004176a9                          
004176ad                          dwBytes = (dwBytes + 0xf) & 0xfffffff0;
004176c2                          edi_1 = HeapReAlloc(data_430e04, HEAP_NONE, arg4, dwBytes);
00417602                      }
00417602                      else
00417602                      {
0041760e                          if (dwBytes > data_430e00)
0041760e                          {
0041765e                          label_41765e:
0041765e                              
0041765e                              if (!dwBytes)
00417662                                  dwBytes = 1;
00417662                              
00417666                              dwBytes = (dwBytes + 0xf) & 0xfffffff0;
00417678                              edi_1 = HeapAlloc(data_430e04, HEAP_NONE, dwBytes);
00417678                              
0041767c                              if (edi_1)
0041767c                              {
00417684                                  uint32_t dwBytes_3 = *(uint32_t*)(arg4 - 4) - 1;
00417684                                  
00417687                                  if (dwBytes_3 >= dwBytes)
00417689                                      dwBytes_3 = dwBytes;
00417689                                  
0041768e                                  sub_41b4f0(edi_1, arg4, dwBytes_3);
00417697                                  sub_41c9f0(ebx_1, arg4);
0041767c                              }
0041760e                          }
0041760e                          else
0041760e                          {
00417610                              edi_1 = arg4;
00417610                              
00417620                              if (!sub_41d1ce(ebx_1, edi_1, dwBytes))
00417620                              {
00417628                                  edi_1 = sub_41cd19(dwBytes);
00417628                                  
0041762d                                  if (!edi_1)
0041762d                                      goto label_41765e;
0041762d                                  
00417635                                  uint32_t dwBytes_2 = *(uint32_t*)(arg4 - 4) - 1;
00417635                                  
00417638                                  if (dwBytes_2 >= dwBytes)
0041763a                                      dwBytes_2 = dwBytes;
0041763a                                  
0041763f                                  sub_41b4f0(edi_1, arg4, dwBytes_2);
0041764d                                  ebx_1 = sub_41c9c5(arg4);
00417650                                  sub_41c9f0(ebx_1, arg4);
00417655                                  goto label_417658;
00417620                              }
00417620                              
00417658                          label_417658:
00417658                              
0041765a                              if (!edi_1)
0041765a                                  goto label_41765e;
0041760e                          }
0041760e                          
004176a1                          if (!ebx_1)
004176a1                              goto label_4176a5;
00417602                      }
00417602                      
004176c6                      if (edi_1)
004176e5                          return edi_1;
004175ef                  }
004175ef                  
004176cf                  if (!data_4309dc)
004176e5                      return edi_1;
004176e5                  
004176da                  if (!sub_41db91(dwBytes))
00417845                      return nullptr;
004175ea              }
004175e4          }
004175e4          else if (eax_1 != 2)
004176ef          {
00417807              while (true)
00417807              {
00417807                  void* eax = nullptr;
00417807                  
0041780c                  if (dwBytes <= 0xffffffe0)
0041780c                  {
00417810                      if (!dwBytes)
00417814                          dwBytes = 1;
00417814                      
00417818                      dwBytes = (dwBytes + 0xf) & 0xfffffff0;
00417827                      eax = HeapReAlloc(data_430e04, HEAP_NONE, arg4, dwBytes);
00417827                      
0041782f                      if (eax)
0041784b                          return eax;
0041780c                  }
0041780c                  
00417838                  if (!data_4309dc)
0041784b                      return eax;
0041784b                  
00417843                  if (!sub_41db91(dwBytes))
00417845                      return nullptr;
00417807              }
004176ef          }
004176ef          else
004176ef          {
004176f8              if (dwBytes <= 0xffffffe0)
004176f8              {
004176fc                  dwBytes = dwBytes <= 0 ? 0x10 : (dwBytes + 0xf) & 0xfffffff0;
004176f8              }
004176f8              
004177ff              bool cond:3_1;
004177ff              
004177ff              do
004177ff              {
00417709                  edi_1 = nullptr;
00417709                  
0041770e                  if (dwBytes > 0xffffffe0)
0041770e                  {
004177e9                  label_4177e9:
004177e9                      
004177f0                      if (!data_4309dc)
004176e5                          return edi_1;
0041770e                  }
0041770e                  else
0041770e                  {
0041771f                      char* eax_11 = sub_41d720(arg4, &var_8, &dwBytes_1);
0041771f                      
0041772b                      if (!eax_11)
004177df                          edi_1 = HeapReAlloc(data_430e04, HEAP_NONE, arg4, dwBytes);
0041772b                      else
0041772b                      {
00417737                          if (dwBytes < data_42f5b4)
00417737                          {
0041773b                              uint32_t edi_3 = dwBytes >> 4;
0041773b                              
00417750                              if (!sub_41dae8(var_8, dwBytes_1, eax_11, edi_3))
00417750                              {
0041775d                                  edi_1 = sub_41d7bc(edi_3);
0041775d                                  
00417762                                  if (edi_1)
00417762                                  {
00417767                                      uint32_t dwBytes_4 = (uint32_t)*(uint8_t*)eax_11 << 4;
00417767                                      
0041776c                                      if (dwBytes_4 >= dwBytes)
0041776e                                          dwBytes_4 = dwBytes;
0041776e                                      
00417775                                      sub_41b4f0(edi_1, arg4, dwBytes_4);
00417781                                      sub_41d777(var_8, dwBytes_1, eax_11);
00417786                                      goto label_417789;
00417762                                  }
00417750                              }
00417750                              else
00417750                              {
00417752                                  edi_1 = arg4;
00417789                              label_417789:
00417789                                  
0041778b                                  if (edi_1)
004176e5                                      return edi_1;
00417750                              }
00417737                          }
00417737                          
004177a0                          edi_1 = HeapAlloc(data_430e04, HEAP_NONE, dwBytes);
004177a0                          
004177a4                          if (!edi_1)
004177a4                              goto label_4177e9;
004177a4                          
004177a9                          uint32_t dwBytes_5 = (uint32_t)*(uint8_t*)eax_11 << 4;
004177a9                          
004177ae                          if (dwBytes_5 >= dwBytes)
004177b0                              dwBytes_5 = dwBytes;
004177b0                          
004177b7                          sub_41b4f0(edi_1, arg4, dwBytes_5);
004177c3                          sub_41d777(var_8, dwBytes_1, eax_11);
0041772b                      }
0041772b                      
004177e3                      if (edi_1 || !data_4309dc)
004176e5                          return edi_1;
0041770e                  }
0041770e                  
004177fc                  cond:3_1 = sub_41db91(dwBytes);
004177ff              } while (cond:3_1);
004176ef          }
004175cc      }
004175cc      else
004175cc      {
004175ce          char* var_18_2 = arg4;
004175d1          sub_41784c(arg3);
004175cc      }
004175cc      
00417845      return nullptr;
004175ac  }


0041784c    void __fastcall sub_41784c(void** arg1)

0041784c  {
0041784f      void** var_8 = arg1;
00417851      int32_t* lpMem_1;
00417851      int32_t* lpMem = lpMem_1;
00417851      
00417856      if (!lpMem)
00417856          return;
00417856      
00417858      int32_t eax_1 = data_430e08;
00417858      
00417860      if (eax_1 != 3)
00417860      {
0041787b          char* eax_3;
0041787b          
0041787b          if (eax_1 == 2)
00417886              eax_3 = sub_41d720(lpMem, &var_8, &lpMem_1);
00417886          
00417890          if (eax_1 != 2 || !eax_3)
004178ac              HeapFree(data_430e04, HEAP_NONE, lpMem);
00417890          else
00417899              sub_41d777(var_8, lpMem_1, eax_3);
00417860      }
00417860      else
00417860      {
00417863          void* eax_2 = sub_41c9c5(lpMem);
00417863          
0041786c          if (!eax_2)
004178ac              HeapFree(data_430e04, HEAP_NONE, lpMem);
0041786c          else
0041786f              sub_41c9f0(eax_2, lpMem);
00417860      }
0041784c  }


004178b5    int32_t sub_4178b5(int32_t* arg1, void* arg2)

004178b5  {
004178bd      int32_t eax = sub_41dc5e(arg1);
004178c7      void arg_c;
004178c7      void* var_14 = &arg_c;
004178ce      int32_t result = sub_41dd28(arg1, arg2);
004178d9      sub_41dceb(eax, arg1);
004178e6      return result;
004178b5  }

004178e7                       cc                                                                                 .

004178e8    int32_t sub_4178e8(int32_t* arg1, int32_t arg2)

004178e8  {
004178ec      void* ebp = *(uint32_t*)arg1;
004178ee      void* esi = arg1[6];
004178f8      TEB* fsbase;
004178f8      
004178f8      if (esi != fsbase->NtTib.ExceptionList)
004178fb          sub_41c4d4(esi);
004178fb      
00417906      if (esi)
00417906      {
0041790b          void* var_4_2 = &arg1[8];
0041790c          sub_41e58f();
0041790c          
0041791d          if (arg1[8] != 0x56433230)
00417930              sub_41c516(esi, arg1[7]);
0041791d          else
0041791d          {
0041791f              int32_t eax_3 = arg1[9];
0041791f              
00417924              if (eax_3)
00417927                  eax_3(arg1);
0041791d          }
00417906      }
00417906      
00417938      int32_t var_4_5 = 0;
0041793d      sub_41c5aa(arg1[5], ebp);
00417944      arg1[1];
00417947      arg1[2];
0041794a      arg1[3];
00417957      arg1[4];
0041795d      /* jump -> *(uint32_t*)((char*)arg1 + 0x14) */
004178e8  }

00417960  c3 cc cc cc                                                                                      ....

00417964    int32_t __setjmp3(int32_t arg1 @ ebp, int32_t arg2 @ esi, int32_t arg3 @ edi, int32_t* arg4, int32_t arg5, struct _EXCEPTION_REGISTRATION_RECORD* arg6, int32_t arg7)

00417964  {
00417968      *(uint32_t*)arg4 = arg1;
0041796a      int32_t entry_ebx;
0041796a      arg4[1] = entry_ebx;
0041796d      arg4[2] = arg3;
00417970      arg4[3] = arg2;
00417973      arg4[4] = &__return_addr;
00417979      arg4[5] = __return_addr;
0041797c      __builtin_strncpy(&arg4[8], "02CV", 8);
0041798a      TEB* fsbase;
0041798a      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
00417990      arg4[6] = ExceptionList;
00417990      
00417996      if (ExceptionList == 0xffffffff)
00417998          arg4[7] = 0xffffffff;
00417996      else if (!arg5)
004179b6          arg4[7] = *(int32_t*)((char*)ExceptionList + 0xc);
004179a7      else
004179a7      {
004179ad          arg4[9] = arg6;
004179ad          
004179b1          if (arg5 != 1)
004179b1          {
004179bf              arg4[7] = arg7;
004179c2              int32_t ecx_4 = arg5 - 2;
004179c2              
004179c3              if (arg5 != 2)
004179c3              {
004179c5                  int32_t var_4_1 = arg2;
004179c6                  int32_t var_8_1 = arg3;
004179c6                  
004179d1                  if (ecx_4 > 6)
004179d3                      ecx_4 = 6;
004179d3                  
004179d8                  void arg_14;
004179d8                  __builtin_memcpy(&arg4[0xa], &arg_14, ecx_4 << 2);
004179c3              }
004179b1          }
004179b1          else
004179b6              arg4[7] = *(int32_t*)((char*)arg6 + 0xc);
004179a7      }
004179a7      
004179de      return 0;
00417964  }


004179df    BOOL __convention("regparm") sub_4179df(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)

004179df  {
004179e2      int32_t var_8 = arg3;
004179e3      int32_t arg_4;
004179e3      int32_t eax = arg_4;
004179ef      uint32_t eax_1;
004179ef      
004179ef      if (eax + 1 > 0x100)
004179ef      {
00417a06          char ecx_3 = (char)(eax >> 8);
00417a12          int32_t __saved_esi_1;
00417a12          
00417a12          if (!(*(uint8_t*)(&(**(uint528_t**)&data_42ce70)[(uint32_t)ecx_3] + 1) & 0x80))
00417a12          {
00417a22              *(uint8_t*)((char*)var_8)[1] = 0;
00417a26              (uint8_t)var_8 = (uint8_t)eax;
00417a29              __saved_esi_1 = 1;
00417a12          }
00417a12          else
00417a12          {
00417a14              *(uint8_t*)((char*)var_8)[2] = 0;
00417a18              (uint8_t)var_8 = ecx_3;
00417a1b              *(uint8_t*)((char*)var_8)[1] = (uint8_t)eax;
00417a1e              __saved_esi_1 = 2;
00417a12          }
00417a12          
00417a3d          BOOL result =
00417a3d              sub_41e5f4(1, &var_8, __saved_esi_1, &*(uint32_t*)((char*)arg_4)[2], 0, 0, 1);
00417a3d          
00417a47          if (!result)
00417a4a              return result;
00417a4a          
00417a4b          eax_1 = (uint32_t)*(uint16_t*)((char*)arg_4)[2];
004179ef      }
004179ef      else
004179f7          eax_1 = (uint32_t)(**(uint528_t**)&data_42ce70)[eax];
004179f7      
00417a53      return eax_1 & arg4;
004179df  }


00417a54    void* sub_417a54()

00417a54  {
00417a59      return data_42d0c0;
00417a54  }


00417a5a    int32_t sub_417a5a(void* arg1, void** arg2, int32_t arg3)

00417a5a  {
00417a70      return sub_417a71(arg1, arg2, arg3, 0);
00417a5a  }


00417a71    int32_t sub_417a71(void* arg1, void** arg2, int32_t arg3, int32_t arg4)

00417a71  {
00417a78      int32_t result = 0;
00417a7e      char* edi = arg1;
00417a81      int32_t ebx;
00417a81      (uint8_t)ebx = *(uint8_t*)edi;
00417a83      void* esi = &edi[1];
00417a86      void* var_8 = esi;
00417a86      
00417a90      while (true)
00417a90      {
00417a90          BOOL eax_2;
00417a90          wchar16 (* ecx)[0x21];
00417a90          
00417a90          if (data_42d07c <= 1)
00417a90          {
00417aa1              ecx = data_42ce70;
00417aaa              uint32_t eax_3;
00417aaa              (uint8_t)eax_3 = (*(uint528_t*)ecx)[(uint32_t)(uint8_t)ebx];
00417aad              eax_2 = eax_3 & 8;
00417a90          }
00417a90          else
00417a90          {
00417a92              uint32_t eax_1 = (uint32_t)(uint8_t)ebx;
00417a98              int32_t edx;
00417a98              eax_2 = sub_4179df(eax_1, edx, ecx, eax_1);
00417a9e              ecx = 8;
00417a90          }
00417a90          
00417ab2          if (!eax_2)
00417ab2              break;
00417ab2          
00417ab4          (uint8_t)ebx = *(uint8_t*)esi;
00417ab6          esi += 1;
00417a90      }
00417a90      
00417abc      void* var_8_1 = esi;
00417abc      
00417abf      if ((uint8_t)ebx == 0x2d)
00417abf      {
00417ac1          arg4 |= 2;
00417acc      label_417acc:
00417acc          (uint8_t)ebx = *(uint8_t*)esi;
00417ace          esi += 1;
00417acf          var_8_1 = esi;
00417abf      }
00417abf      else if ((uint8_t)ebx == 0x2b)
00417aca          goto label_417acc;
00417aca      
00417ae9      if (arg3 < 0 || arg3 == 1 || arg3 > 0x24)
00417ae9      {
00417c69          char** eax_19 = arg2;
00417c69          
00417c6e          if (eax_19)
00417c70              *(uint32_t*)eax_19 = edi;
00417c70          
00417c72          return 0;
00417ae9      }
00417ae9      
00417af3      int32_t ecx_1 = 0x10;
00417af3      
00417af4      if (arg3)
00417af4          goto label_417b1a;
00417af4      
00417af9      if ((uint8_t)ebx == 0x30)
00417af9      {
00417b04          int32_t eax_4;
00417b04          (uint8_t)eax_4 = *(uint8_t*)esi;
00417b04          
00417b0c          if ((uint8_t)eax_4 == 0x78 || (uint8_t)eax_4 == 0x58)
00417b0c          {
00417b17              arg3 = 0x10;
00417b1a          label_417b1a:
00417b1a              
00417b22              if (arg3 == 0x10 && (uint8_t)ebx == 0x30)
00417b22              {
00417b24                  (uint8_t)eax_4 = *(uint8_t*)esi;
00417b24                  
00417b2c                  if ((uint8_t)eax_4 == 0x78 || (uint8_t)eax_4 == 0x58)
00417b2c                  {
00417b2e                      (uint8_t)ebx = *(uint8_t*)((char*)esi + 1);
00417b33                      var_8_1 = (char*)esi + 2;
00417b2c                  }
00417b22              }
00417b0c          }
00417b0c          else
00417b0e              arg3 = 8;
00417af9      }
00417af9      else
00417afb          arg3 = 0xa;
00417afb      
00417b36      int32_t eax_5 = 0xffffffff;
00417b39      int32_t edx_1 = 0;
00417b3b      void* eax_6 = COMBINE(edx_1, eax_5) / arg3;
00417b3b      uint32_t edx_2 = COMBINE(edx_1, eax_5) % arg3;
00417b43      void* var_10_1 = eax_6;
00417b43      
00417b4d      while (true)
00417b4d      {
00417b4d          uint32_t esi_3 = (uint32_t)(uint8_t)ebx;
00417b50          BOOL eax_7;
00417b50          
00417b50          if (data_42d07c <= 1)
00417b50          {
00417b63              wchar16 (* eax_8)[0x21];
00417b63              (uint8_t)eax_8 = (**(uint528_t**)&data_42ce70)[esi_3];
00417b66              eax_7 = eax_8 & 4;
00417b50          }
00417b50          else
00417b50          {
00417b55              eax_7 = sub_4179df(eax_6, edx_2, ecx_1, esi_3);
00417b5b              ecx_1 = 4;
00417b50          }
00417b50          
00417b6b          if (!eax_7)
00417b6b          {
00417b7c              BOOL eax_9;
00417b7c              
00417b7c              if (data_42d07c <= 1)
00417b7c              {
00417b8e                  wchar16 (* eax_10)[0x21];
00417b8e                  (uint16_t)eax_10 = (**(uint528_t**)&data_42ce70)[esi_3];
00417b92                  eax_9 = eax_10 & 0x103;
00417b7c              }
00417b7c              else
00417b7c              {
00417b80                  eax_9 = sub_4179df(eax_7, edx_2, ecx_1, esi_3);
00417b86                  ecx_1 = 0x103;
00417b7c              }
00417b7c              
00417b96              if (!eax_9)
00417b96                  break;
00417b96              
00417b9b              int32_t var_20_1 = (int32_t)(uint8_t)ebx;
00417b9c              uint32_t eax_12;
00417b9c              eax_12 = sub_418b4f(ecx_1);
00417ba4              ecx_1 = eax_12 - 0x37;
00417b6b          }
00417b6b          else
00417b70              ecx_1 = (int32_t)(uint8_t)ebx - 0x30;
00417b70          
00417baa          if (ecx_1 >= arg3)
00417baa              break;
00417baa          
00417baf          arg4 |= 8;
00417baf          
00417bb6          if (result >= var_10_1 && result == var_10_1)
00417bbf              edx_2 = COMBINE(0, 0xffffffff) % arg3;
00417bbf          
00417bc4          if (result < var_10_1 || (result == var_10_1 && ecx_1 <= edx_2))
00417bd2              result = result * arg3 + ecx_1;
00417bc4          else
00417bc6              arg4 |= 4;
00417bc6          
00417bd5          eax_6 = var_8_1;
00417bd8          var_8_1 += 1;
00417bdb          (uint8_t)ebx = *(uint8_t*)eax_6;
00417b4d      }
00417b4d      
00417be5      void* var_8_2 = (char*)var_8_1 - 1;
00417be5      
00417bee      if (!((uint8_t)arg4 & 8))
00417bee      {
00417bf2          if (arg2)
00417bf7              var_8_2 = arg1;
00417bf7          
00417bfa          result = 0;
00417bee      }
00417bee      else if ((uint8_t)arg4 & 4)
00417c08      {
00417c2a      label_417c2a:
00417c2a          data_4307d4 = 0x22;
00417c2a          
00417c34          if (!((uint8_t)arg4 & 1))
00417c34          {
00417c3f              int32_t ecx_6;
00417c3f              (uint8_t)ecx_6 = (uint8_t)arg4 & 2;
00417c42              char temp4_1 = (uint8_t)ecx_6;
00417c42              (uint8_t)ecx_6 = -((uint8_t)ecx_6);
00417c4a              result = -((ecx_6 - ecx_6)) + 0x7fffffff;
00417c34          }
00417c34          else
00417c36              result = 0xffffffff;
00417c08      }
00417c08      else if (!((uint8_t)arg4 & 1))
00417c0d      {
00417c0f          int32_t ecx_5 = arg4 & 2;
00417c0f          
00417c1b          if (ecx_5 && result > 0x80000000)
00417c12              goto label_417c2a;
00417c12          
00417c24          if (!ecx_5 && result > 0x7fffffff)
00417c24              goto label_417c2a;
00417c0d      }
00417c0d      
00417c4f      if (arg2)
00417c54          *(uint32_t*)arg2 = var_8_2;
00417c54      
00417c5a      if (!((uint8_t)arg4 & 2))
00417c64          return result;
00417c64      
00417c61      return -(result);
00417a71  }


00417c79    int32_t sub_417c79(void* arg1, void** arg2, int32_t arg3)

00417c79  {
00417c8f      return sub_417a71(arg1, arg2, arg3, 1);
00417c79  }


00417c90    long double sub_417c90(void* arg1, void** arg2)

00417c90  {
00417c96      char* esi = arg1;
00417c96      
00417c9f      while (true)
00417c9f      {
00417c9f          BOOL eax_2;
00417c9f          wchar16 (* ecx)[0x21];
00417c9f          
00417c9f          if (data_42d07c <= 1)
00417c9f          {
00417cb3              ecx = data_42ce70;
00417cb9              uint32_t eax_3;
00417cb9              (uint8_t)eax_3 = (*(uint528_t*)ecx)[(uint32_t)*(uint8_t*)esi];
00417cbc              eax_2 = eax_3 & 8;
00417c9f          }
00417c9f          else
00417c9f          {
00417ca1              uint32_t eax_1 = (uint32_t)*(uint8_t*)esi;
00417ca7              int32_t edx;
00417ca7              eax_2 = sub_4179df(eax_1, edx, ecx, eax_1);
00417cad              ecx = 8;
00417c9f          }
00417c9f          
00417cc1          if (!eax_2)
00417cc1              break;
00417cc1          
00417cc3          esi = &esi[1];
00417c9f      }
00417c9f      
00417cc6      int32_t var_c = 0;
00417cc8      int32_t var_10_2 = 0;
00417cd1      void* var_14_1 = sub_41e7d0(esi);
00417cd3      int32_t* eax_5 = sub_41e73d(esi);
00417cd3      
00417ce1      if (arg2)
00417ce8          *(uint32_t*)arg2 = &esi[eax_5[1]];
00417ce8      
00417cea      int16_t edx_3 = (int16_t)*(uint32_t*)eax_5;
00417cf1      long double result;
00417cf1      
00417cf1      if (!(edx_3 & 0x240))
00417cf1      {
00417d00          if (!((uint8_t)edx_3 & 0x81))
00417d00          {
00417d1e              if (!(*(uint8_t*)((char*)edx_3)[1] & 1))
00417d24                  return (long double)*(uint64_t*)((char*)eax_5 + 0x10);
00417d24              
00417d20              result = (long double)0;
00417d00          }
00417d00          else
00417d00          {
00417d05              result = (long double)data_42d168;
00417d05              
00417d0b              if (*(uint8_t*)esi == 0x2d)
00417d0d                  result = -(result);
00417d00          }
00417d00          
00417d0f          data_4307d4 = 0x22;
00417cf1      }
00417cf1      else
00417cf1      {
00417cf5          result = (long double)0;
00417cf5          
00417cf7          if (arg2)
00417cf9              *(uint32_t*)arg2 = arg1;
00417cf1      }
00417cf1      
00417d29      return result;
00417c90  }


00417d2a    int32_t sub_417d2a(char* arg1, void* arg2)

00417d2a  {
00417d34      char* var_1c = arg1;
00417d37      char* var_24 = arg1;
00417d3d      int32_t var_18 = 0x42;
00417d44      void arg_c;
00417d44      void* var_2c = &arg_c;
00417d4b      int32_t var_20 = 0x7fffffff;
00417d53      int32_t result = sub_41dd28(&var_24, arg2);
00417d5b      int32_t var_20_1 = var_20 - 1;
00417d5b      
00417d60      if (var_20 - 1 < 0)
00417d60      {
00417d6d          char** var_2c_1 = &var_24;
00417d70          sub_41e84b(nullptr);
00417d60      }
00417d60      else
00417d65          *(uint8_t*)var_24 = 0;
00417d65      
00417d7b      return result;
00417d2a  }

00417d7c                                                                                      cc cc cc cc                              ....

00417d80    char* sub_417d80(char* arg1, char* arg2, int32_t arg3)

00417d80  {
00417d80      int32_t i_3 = arg3;
00417d80      
00417d87      if (i_3)
00417d87      {
00417d8d          char* edi_1 = arg1;
00417d99          void* edi_2;
00417d99          
00417d99          while (edi_1 & 3)
00417d99          {
00417d9b              char eax = *(uint8_t*)edi_1;
00417d9d              edi_1 = &edi_1[1];
00417d9d              
00417da0              if (!eax)
00417da0              {
00417ddb              label_417ddb:
00417ddb                  edi_2 = edi_1 - 1;
00417ddc                  goto label_417deb;
00417da0              }
00417d99          }
00417d99          
00417daa          while (true)
00417daa          {
00417daa              int32_t eax_1 = *(uint32_t*)edi_1;
00417db8              edi_1 = &edi_1[4];
00417db8              
00417dc0              if ((eax_1 ^ 0xffffffff ^ (0x7efefeff + eax_1)) & 0x81010100)
00417dc0              {
00417dc2                  int32_t eax_4 = *(uint32_t*)(edi_1 - 4);
00417dc2                  
00417dc7                  if (!(uint8_t)eax_4)
00417dc7                  {
00417de8                      edi_2 = edi_1 - 4;
00417de8                      break;
00417dc7                  }
00417dc7                  
00417dcb                  if (!*(uint8_t*)((char*)eax_4)[1])
00417dcb                  {
00417de3                      edi_2 = edi_1 - 3;
00417de6                      break;
00417dcb                  }
00417dcb                  
00417dd2                  if (!(eax_4 & 0xff0000))
00417dd2                  {
00417dde                      edi_2 = edi_1 - 2;
00417de1                      break;
00417dd2                  }
00417dd2                  
00417dd9                  if (!(eax_4 & 0xff000000))
00417dd9                      goto label_417ddb;
00417dc0              }
00417daa          }
00417daa          
00417deb      label_417deb:
00417deb          char* esi_1 = arg2;
00417df5          int32_t edx;
00417df5          int32_t i_4;
00417df5          uint32_t i_2;
00417df5          
00417df5          if (esi_1 & 3)
00417df5          {
00417e13              do
00417e13              {
00417e00                  (uint8_t)edx = *(uint8_t*)esi_1;
00417e02                  esi_1 = &esi_1[1];
00417e02                  
00417e05                  if (!(uint8_t)edx)
00417e05                  {
00417e3a                  label_417e3a:
00417e3a                      *(uint8_t*)edi_2 = (uint8_t)edx;
00417e43                      return arg1;
00417e05                  }
00417e05                  
00417e07                  *(uint8_t*)edi_2 = (uint8_t)edx;
00417e09                  edi_2 += 1;
00417e0a                  int32_t i_5 = i_3;
00417e0a                  i_3 -= 1;
00417e0a                  
00417e0b                  if (i_5 == 1)
00417e0b                      goto label_417e30;
00417e13              } while (esi_1 & 3);
00417e13              
00417e15              i_4 = i_3;
00417e17              i_2 = i_3 >> 2;
00417e17              
00417e1a              if (i_2)
00417e1a                  goto label_417e4a;
00417df5          }
00417df5          else
00417df5          {
00417df7              i_4 = i_3;
00417df9              i_2 = i_3 >> 2;
00417df9              
00417dfc              if (i_2)
00417dfc              {
00417e4a              label_417e4a:
00417e4a                  uint32_t i;
00417e4a                  
00417e4a                  do
00417e4a                  {
00417e51                      int32_t eax_7 = *(uint32_t*)esi_1;
00417e5a                      edx = *(uint32_t*)esi_1;
00417e5c                      esi_1 = &esi_1[4];
00417e5c                      
00417e64                      if ((eax_7 ^ 0xffffffff ^ (0x7efefeff + eax_7)) & 0x81010100)
00417e64                      {
00417e68                          if (!(uint8_t)edx)
00417e68                              goto label_417e3a;
00417e68                          
00417e6c                          if (!*(uint8_t*)((char*)edx)[1])
00417e6c                          {
00417e98                              *(uint16_t*)edi_2 = (uint16_t)edx;
00417ea2                              return arg1;
00417e6c                          }
00417e6c                          
00417e74                          if (!(edx & 0xff0000))
00417e74                          {
00417e88                              *(uint16_t*)edi_2 = (uint16_t)edx;
00417e91                              *(uint8_t*)((char*)edi_2 + 2) = 0;
00417e97                              return arg1;
00417e74                          }
00417e74                          
00417e7c                          if (!(edx & 0xff000000))
00417e7c                          {
00417e7e                              *(uint32_t*)edi_2 = edx;
00417e87                              return arg1;
00417e7c                          }
00417e64                      }
00417e64                      
00417e44                      *(uint32_t*)edi_2 = edx;
00417e46                      edi_2 += 4;
00417e49                      i = i_2;
00417e49                      i_2 -= 1;
00417e4a                  } while (i != 1);
00417dfc              }
00417df5          }
00417e1e          i_3 = i_4 & 3;
00417e1e          
00417e21          if (i_3)
00417e21          {
00417e2e              int32_t i_1;
00417e2e              
00417e2e              do
00417e2e              {
00417e23                  (uint8_t)edx = *(uint8_t*)esi_1;
00417e25                  esi_1 = &esi_1[1];
00417e26                  *(uint8_t*)edi_2 = (uint8_t)edx;
00417e28                  edi_2 += 1;
00417e28                  
00417e2b                  if (!(uint8_t)edx)
00417e39                      return arg1;
00417e39                  
00417e2d                  i_1 = i_3;
00417e2d                  i_3 -= 1;
00417e2e              } while (i_1 != 1);
00417e21          }
00417e21          
00417e30      label_417e30:
00417e30          *(uint8_t*)edi_2 = (uint8_t)i_3;
00417d87      }
00417d87      
00417e39      return arg1;
00417d80  }

00417ea3           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

00417eb0    int32_t sub_417eb0(char* arg1, char* arg2)

00417eb0  {
00417ebd      int32_t var_28_1;
00417ebd      __builtin_memset(&var_28_1, 0, 0x20);
00417ebe      char* edx = arg2;
00417ec4      int32_t eax;
00417ec4      
00417ec4      while (true)
00417ec4      {
00417ec4          (uint8_t)eax = *(uint8_t*)edx;
00417ec6          (uint8_t)eax = (uint8_t)eax;
00417ec6          
00417ec8          if (!(uint8_t)eax)
00417ec8              break;
00417ec8          
00417eca          edx = &edx[1];
00417ecb          var_28_1 |= 1 << (eax % 0x20);
00417ec4      }
00417ec4      
00417ed1      char* esi = arg1;
00417ed4      int32_t result = 0xffffffff;
00417ed4      
00417ee4      do
00417ee4      {
00417ed8          result += 1;
00417ed9          (uint8_t)eax = *(uint8_t*)esi;
00417edb          (uint8_t)eax = (uint8_t)eax;
00417edb          
00417edd          if (!(uint8_t)eax)
00417edd              break;
00417edd          
00417edf          esi = &esi[1];
00417ee4      } while (!TEST_BITD(var_28_1, eax));
00417ee4      
00417eed      return result;
00417eb0  }

00417eee                                            cc cc                                                                ..

00417ef0    char* sub_417ef0(char* arg1, char* arg2, int32_t arg3)

00417ef0  {
00417ef0      int32_t ecx = arg3;
00417ef0      
00417ef7      if (!ecx)
00417f78          return arg1;
00417f78      
00417efb      int32_t ebx_1 = ecx;
00417efd      char* esi_1 = arg2;
00417f07      char* edi_1 = arg1;
00417f0b      int32_t eax;
00417f0b      uint32_t i_2;
00417f0b      uint32_t i_3;
00417f0b      
00417f0b      if (esi_1 & 3)
00417f0b      {
00417f27          do
00417f27          {
00417f14              (uint8_t)eax = *(uint8_t*)esi_1;
00417f16              esi_1 = &esi_1[1];
00417f17              *(uint8_t*)edi_1 = (uint8_t)eax;
00417f19              edi_1 = &edi_1[1];
00417f1a              int32_t temp0_1 = ecx;
00417f1a              ecx -= 1;
00417f1a              
00417f1b              if (temp0_1 == 1)
00417f49                  return arg1;
00417f49              
00417f1f              if (!(uint8_t)eax)
00417f1f              {
00417f50                  while (edi_1 & 3)
00417f50                  {
00417f52                      *(uint8_t*)edi_1 = (uint8_t)eax;
00417f54                      edi_1 = &edi_1[1];
00417f55                      int32_t temp2_1 = ecx;
00417f55                      ecx -= 1;
00417f55                      
00417f56                      if (temp2_1 == 1)
00417fed                          return arg1;
00417f50                  }
00417f50                  
00417f64                  ebx_1 = ecx;
00417f66                  i_3 = ecx >> 2;
00417f66                  
00417f69                  if (!i_3)
00417f69                      goto label_417f6b;
00417f69                  
00417fd7              label_417fd7:
00417fd7                  eax = 0;
00417fdf                  uint32_t i;
00417fdf                  
00417fdf                  do
00417fdf                  {
00417fd9                      *(uint32_t*)edi_1 = 0;
00417fdb                      edi_1 = &edi_1[4];
00417fde                      i = i_3;
00417fde                      i_3 -= 1;
00417fdf                  } while (i != 1);
00417fe1              label_417fe1:
00417fe1                  ebx_1 &= 3;
00417fe1                  
00417fe4                  if (ebx_1)
00417fe4                      goto label_417f6b;
00417fe4                  
00417fed                  return arg1;
00417f1f              }
00417f27          } while (esi_1 & 3);
00417f27          
00417f29          ebx_1 = ecx;
00417f2b          i_2 = ecx >> 2;
00417f2b          
00417f2e          if (i_2)
00417f2e              goto label_417f7f;
00417f2e          
00417f30      label_417f30:
00417f30          ebx_1 &= 3;
00417f30          
00417f33          if (ebx_1)
00417f33              goto label_417f35;
00417f0b      }
00417f0b      else
00417f0b      {
00417f0d          i_2 = ecx >> 2;
00417f0d          
00417f10          if (i_2)
00417f10          {
00417f7f          label_417f7f:
00417f7f              uint32_t i_1;
00417f7f              
00417f7f              do
00417f7f              {
00417f86                  int32_t eax_3 = *(uint32_t*)esi_1;
00417f8f                  int32_t edx_2 = *(uint32_t*)esi_1;
00417f91                  esi_1 = &esi_1[4];
00417f91                  
00417f99                  if ((eax_3 ^ 0xffffffff ^ (0x7efefeff + eax_3)) & 0x81010100)
00417f99                  {
00417f9d                      if (!(uint8_t)edx_2)
00417f9d                      {
00417fcd                          *(uint32_t*)edi_1 = 0;
00417fcf                      label_417fcf:
00417fcf                          edi_1 = &edi_1[4];
00417fd2                          eax = 0;
00417fd4                          i_3 = i_2 - 1;
00417fd4                          
00417fd5                          if (i_2 == 1)
00417fd5                              goto label_417fe1;
00417fd5                          
00417fd5                          goto label_417fd7;
00417f9d                      }
00417f9d                      
00417fa1                      if (!*(uint8_t*)((char*)edx_2)[1])
00417fa1                      {
00417fc7                          *(uint32_t*)edi_1 = edx_2 & 0xff;
00417fc9                          goto label_417fcf;
00417fa1                      }
00417fa1                      
00417fa9                      if (!(edx_2 & 0xff0000))
00417fa9                      {
00417fbd                          *(uint32_t*)edi_1 = edx_2 & 0xffff;
00417fbf                          goto label_417fcf;
00417fa9                      }
00417fa9                      
00417fb1                      if (!(edx_2 & 0xff000000))
00417fb1                      {
00417fb3                          *(uint32_t*)edi_1 = edx_2;
00417fb5                          goto label_417fcf;
00417fb1                      }
00417f99                  }
00417f99                  
00417f79                  *(uint32_t*)edi_1 = edx_2;
00417f7b                  edi_1 = &edi_1[4];
00417f7e                  i_1 = i_2;
00417f7e                  i_2 -= 1;
00417f7f              } while (i_1 != 1);
00417f7f              goto label_417f30;
00417f10          }
00417f10          
00417f35      label_417f35:
00417f35          
00417f35          while (true)
00417f35          {
00417f35              (uint8_t)eax = *(uint8_t*)esi_1;
00417f37              esi_1 = &esi_1[1];
00417f38              *(uint8_t*)edi_1 = (uint8_t)eax;
00417f3a              edi_1 = &edi_1[1];
00417f3a              
00417f3d              if (!(uint8_t)eax)
00417f3d              {
00417f6e                  while (true)
00417f6e                  {
00417f6e                      int32_t temp3_1 = ebx_1;
00417f6e                      ebx_1 -= 1;
00417f6e                      
00417f6f                      if (temp3_1 == 1)
00417f78                          return arg1;
00417f78                      
00417f6b                  label_417f6b:
00417f6b                      *(uint8_t*)edi_1 = (uint8_t)eax;
00417f6d                      edi_1 = &edi_1[1];
00417f6e                  }
00417f3d              }
00417f3d              else
00417f3d              {
00417f3f                  int32_t temp4_1 = ebx_1;
00417f3f                  ebx_1 -= 1;
00417f3f                  
00417f40                  if (temp4_1 == 1)
00417f40                      break;
00417f3d              }
00417f35          }
00417f0b      }
00417f49      return arg1;
00417ef0  }


00417fee    int32_t sub_417fee(char* arg1, char* arg2)

00417fee  {
00417fee      uint32_t eax_4 = data_430a10;
00417fee      
00417ff5      if (!eax_4)
00418006          return sub_41ebe0(arg1, arg2);
00418006      
0041801f      enum COMPARESTRING_RESULT eax_1 =
0041801f          sub_41e960(eax_4, 0x1000, arg1, 0xffffffff, arg2, 0xffffffff, data_430a28);
0041801f      
00418029      if (eax_1)
0041803e          return eax_1 - 2;
0041803e      
0041802b      data_4307d4 = 0x16;
0041803a      return 0x7fffffff;
00417fee  }


0041803f    long double sub_41803f(double arg1)

0041803f  {
00418042      int32_t ecx;
00418042      int32_t var_8 = ecx;
00418043      int32_t var_c = ecx;
00418052      int32_t eax;
00418052      int16_t x87control;
00418052      int16_t x87control_1;
00418052      eax = sub_41f590(x87control, data_42d0d0, 0xffff);
0041806e      int32_t var_30;
0041806e      
0041806e      if ((*(uint16_t*)((char*)arg1)[6] & 0x7ff0) != 0x7ff0)
0041806e      {
004180ca          var_c = (double)__frnd(9,18340949e-41f);
004180cd          long double x87_r7_5 = (long double)var_c;
004180d0          long double temp0_1 = (long double)arg1;
004180d0          x87_r7_5 - temp0_1;
004180d0          
004180eb          if (TEST_BITB(
004180eb              *(uint8_t*)((char*)((x87_r7_5 < temp0_1 ? 1 : 0) << 8
004180eb                  | (FCMP_UO(x87_r7_5, temp0_1) ? 1 : 0) << 0xa
004180eb                  | (x87_r7_5 == temp0_1 ? 1 : 0) << 0xe))[1], 
004180eb              6) || (uint8_t)eax & 0x20)
004180eb          {
004180dc              sub_41f590(x87control_1, eax, 0xffff);
0041810d              return (long double)var_c;
004180eb          }
004180eb          
004180f0          int32_t var_18_3 = eax;
004180f3          int32_t var_20_1;
004180f3          var_20_1 = (double)(long double)var_c;
004180fb          int32_t var_28_1;
004180fb          var_28_1 = (double)(long double)arg1;
00418100          __builtin_memcpy(&var_30, 
00418100              "\x10\x00\x00\x00\x0b\x00\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00"
00418100          "ff\xff\x00\x00", 
00418100              0x18);
0041806e      }
0041806e      else
0041806e      {
00418070          int32_t eax_2 = sub_41f458(0xffff, 0xffff);
00418070          
00418079          if (eax_2 > 0)
00418079          {
0041807e              if (eax_2 <= 2)
0041807e              {
0041809c                  sub_41f590(x87control_1, eax, 0xffff);
0041810d                  return (long double)arg1;
0041807e              }
0041807e              
00418083              if (eax_2 == 3)
00418083              {
00418089                  int32_t var_1c_1 = 0xffff;
00418090                  return sub_41ec64(eax_2, 0, 0xffff, 0xb, 9,18340949e-41f, eax);
00418083              }
00418079          }
00418079          
004180b1          int32_t var_18_2 = eax;
004180b4          int32_t var_20;
004180b4          var_20 = (double)((long double)arg1 + (long double)1.0);
004180bc          int32_t var_28;
004180bc          var_28 = (double)(long double)arg1;
004180c1          __builtin_memcpy(&var_30, 
004180c1              "\x08\x00\x00\x00\x0b\x00\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00"
004180c1          "ff\xff\x00\x00", 
004180c1              0x18);
0041806e      }
0041806e      
00418102      return sub_41ed16(var_30, 0xb, 0xffff);
0041803f  }

0041810e                                            cc cc                                                                ..

00418110    int80_t sub_418110(long double arg1 @ st0, long double arg2 @ st1)

00418110  {
00418118      double var_8 = (double)arg1;
00418128      int16_t x87control;
00418128      int16_t x87tag;
00418128      return sub_418132(*(uint32_t*)((char*)var_8)[4], x87control, x87tag, arg1, 
00418128          (double)arg2, var_8);
00418110  }

00418129                             8d 54 24 0c e8 63 79 00 00                                                     .T$..cy..

00418132    long double __convention("regparm") sub_418132(int32_t arg1, int16_t arg2 @ x87control, int16_t arg3 @ x87tag, long double arg4 @ st0, int32_t arg5, int32_t arg6, int32_t arg7, char arg8, int32_t arg9)

00418132  {
00418134      int32_t var_4 = arg1;
00418136      int16_t x87status;
00418136      int16_t temp0;
00418136      temp0 = __fnstcw_memmem16(arg2);
00418136      (uint16_t)var_4 = temp0;
00418136      
0041813f      if ((uint16_t)var_4 != 0x27f)
00418141          arg2 = __load_CW(var_4);
00418141      
00418146      int32_t ecx = arg1 & 0x7ff00000;
00418156      long double result;
00418156      int32_t arg_4;
00418156      int32_t eax_1;
00418156      int32_t ecx_3;
00418156      long double x87_r7;
00418156      
00418156      if (ecx != 0x7ff00000)
00418156      {
0041815c          int32_t eax;
0041815c          long double st0;
0041815c          st0 = __fload_withFB(ecx, &arg_4);
0041815c          x87_r7 = st0;
0041815c          
00418161          if (ecx == 0x7ff00000)
00418161          {
004181f5              ecx_3 = 0;
004181f7              goto label_418220;
00418161          }
00418161          
00418275          if (eax & 0x7ff00000 || (arg5 & 0xfffff) | arg_4)
00418275          {
00418176              char ecx_1 = *(uint8_t*)((char*)arg5)[3] & 0x80;
00418176              
00418179              if (ecx_1)
00418179              {
004182e2                  ecx_1 = _test_whether_TOS_is_int(arg4);
004182e7                  x87_r7 = -(x87_r7);
004182e7                  
004182eb                  if (!ecx_1)
004182eb                  {
004182f5                      result = data_42f760;
004182fb                      eax_1 = 1;
00418300                      goto label_4181aa;
004182eb                  }
00418179              }
00418179              
00418181              result = __twoToTOS(__fyl2x(x87_r7, arg4));
00418181              
00418189              if (ecx_1 == 1)
0041818b                  result = -(result);
0041818b              
00418194              if (!data_4307a4)
00418194              {
0041fb3c                  int864_t var_70;
0041fb3c                  *(uint64_t*)((char*)var_70)[0x64] = (double)result;
0041fb3c                  bool c1 = /* bool c1 = unimplemented  {fst qword [esp], st0} */;
0041fb46                  int32_t eax_14 = *(uint32_t*)((char*)var_70)[0x68] & 0x7ff00000;
0041fb4b                  int32_t eax_15;
0041fb4b                  
0041fb4b                  if (!eax_14)
0041fb4b                  {
0041fb90                      long double result_1 = result;
0041fb90                      result = (long double)1536.0;
0041fb92                      __fscale(result_1, result);
0041fb98                      long double x87_r7_4 = fabsl(result);
0041fb9a                      long double temp1_1 = (long double)2,2250738585072014e-308;
0041fb9a                      x87_r7_4 - temp1_1;
0041fba1                      (uint16_t)eax_14 = (x87_r7_4 < temp1_1 ? 1 : 0) << 8
0041fba1                          | (FCMP_UO(x87_r7_4, temp1_1) ? 1 : 0) << 0xa
0041fba1                          | (x87_r7_4 == temp1_1 ? 1 : 0) << 0xe;
0041fba4                      eax_15 = 4;
0041fba4                      
0041fba9                      if (TEST_BITB(*(uint8_t*)((char*)eax_14)[1], 0))
0041fbab                          result = result * (long double)0.0;
0041fb4b                  }
0041fb4b                  else if (eax_14 == 0x7ff00000)
0041fb52                  {
0041fbb9                      long double result_2 = result;
0041fbb9                      result = (long double)-1536.0;
0041fbbb                      __fscale(result_2, result);
0041fbc1                      long double x87_r7_8 = fabsl(result);
0041fbc3                      long double temp2_1 = (long double)1,7976931348623157e+308;
0041fbc3                      x87_r7_8 - temp2_1;
0041fbca                      (uint16_t)eax_14 = (x87_r7_8 < temp2_1 ? 1 : 0) << 8
0041fbca                          | (FCMP_UO(x87_r7_8, temp2_1) ? 1 : 0) << 0xa
0041fbca                          | (x87_r7_8 == temp2_1 ? 1 : 0) << 0xe;
0041fbcd                      eax_15 = 3;
0041fbcd                      
0041fbd2                      if (!TEST_BITB(*(uint8_t*)((char*)eax_14)[1], 6)
0041fbd2                              && !TEST_BITB(*(uint8_t*)((char*)eax_14)[1], 0))
0041fbd4                          result = result * (long double)inf.0;
0041fb52                  }
0041fb52                  else
0041fb52                  {
0041fb54                      (uint16_t)eax_14 = (uint16_t)var_4;
0041fb54                      
0041fb5c                      if ((uint16_t)eax_14 == 0x27f)
0041fb89                          return result;
0041fb89                      
0041fb5e                      (uint16_t)eax_14 &= 0x20;
0041fb62                      int16_t x87control_3;
0041fb62                      int16_t x87status_3;
0041fb62                      
0041fb62                      if ((uint16_t)eax_14)
0041fb62                      {
0041fb85                          x87control_3 = __fldcw_memmem16((uint16_t)var_4);
0041fb89                          return result;
0041fb62                      }
0041fb62                      
0041fb65                      bool c0;
0041fb65                      bool c2;
0041fb65                      bool c3;
0041fb65                      (uint16_t)eax_14 = (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9
0041fb65                          | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0041fb67                      (uint16_t)eax_14 &= 0x20;
0041fb67                      
0041fb6b                      if (!(uint16_t)eax_14)
0041fb6b                      {
0041fb85                          x87control_3 = __fldcw_memmem16((uint16_t)var_4);
0041fb89                          return result;
0041fb6b                      }
0041fb6b                      
0041fb6d                      eax_15 = 8;
0041fb52                  }
0041fb52                  
0041fb84                  return __startTwoArgErrorHandling(eax_15, 0x1d, result, "pow", var_4, 
0041fb84                      __return_addr, arg_4);
00418194              }
00418275          }
00418275          else if (arg7 & 0x7ff00000)
00418286          {
00418288              _test_whether_TOS_is_int(x87_r7);
0041828d              int16_t ecx_5;
0041828d              *(uint8_t*)((char*)ecx_5)[1] = *(uint8_t*)((char*)arg5)[3];
00418291              *(uint8_t*)((char*)ecx_5)[1] u>>= 7;
00418291              
0041829c              if (arg9 & 0x80)
0041829c              {
0041829e                  result = data_42f6f0;
0041829e                  
004182a6                  if (*(uint8_t*)((char*)ecx_5)[1] & (uint8_t)ecx_5)
004182a8                      result = -(result);
004182a8                  
004182aa                  eax_1 = 2;
004182af                  goto label_4181aa;
0041829c              }
0041829c              
004182b4              result = (long double)0;
004182b4              
004182b8              if (*(uint8_t*)((char*)ecx_5)[1] & (uint8_t)ecx_5)
004182be                  result = -(result);
00418286          }
00418286          else if ((arg7 & 0xfffff) | arg6)
004182d9              result = (long double)0;
004182d0          else
004182d2              result = (long double)1;
00418156      }
00418156      else if ((arg1 & 0xfffff) | arg6)
00418204      {
004181cd          int32_t ecx_2;
004181cd          long double st0_3;
004181cd          st0_3 = __fload_withFB(0, &arg_4);
004181cd          x87_r7 = st0_3;
004181cd          
004181d7          if (!(arg8 & 8))
004181d7          {
004181d9              ecx_3 = ecx_2 + 1;
004181da              goto label_418220;
004181d7          }
004181d7          
004181dc      label_4181dc:
004181dc          result = arg4 + x87_r7;
004181de          eax_1 = 1;
004181aa      label_4181aa:
004181aa          
004181b1          if (!data_4307a4)
004181c8              return __startTwoArgErrorHandling(eax_1, 0x1d, result, "pow", var_4, 
004181c8                  __return_addr, arg_4);
00418204      }
00418204      else
00418204      {
0041820a          long double st0_4;
0041820a          st0_4 = __fload_withFB(0, &arg_4);
0041820a          x87_r7 = st0_4;
00418220      label_418220:
00418220          
0041822b          if ((arg5 & 0x7ff00000) == 0x7ff00000 && (arg5 & 0xfffff) | arg_4)
0041822b          {
004181ea              if (*(uint8_t*)((char*)arg5)[2] & 8)
004181ea                  goto label_4181dc;
004181ea              
004181ea              goto label_4181ec;
0041822b          }
0041822b          
0041822f          if (ecx_3)
0041822f          {
004181ec          label_4181ec:
004181ec              result = arg4 + x87_r7;
004181ee              eax_1 = 7;
004181f3              goto label_4181aa;
0041822f          }
0041822f          
00418236          void var_78;
00418236          double* var_7c_1 = &var_78;
00418242          int16_t x87control;
00418242          int16_t x87status_1;
00418242          int16_t x87tag;
00418242          int16_t temp0_1;
00418242          temp0_1 = __fnsave_memmem108(arg2, arg3, x87status);
00418242          int864_t var_70_1 = temp0_1;
00418245          int32_t eax_6 = sub_41fbdc((double)x87_r7, (double)arg4, var_7c_1);
0041824e          __frstor_memmem108(*(uint864_t*)((char*)var_7c_1 + 8));
00418251          result = (long double)*(uint64_t*)var_7c_1;
00418251          
00418258          if (eax_6)
00418258          {
0041825e              eax_1 = 1;
00418263              goto label_4181aa;
00418258          }
00418204      }
0041faf4      int16_t x87control_2;
0041faf4      int16_t x87status_2;
0041faf4      
0041faf4      if ((uint16_t)var_4 != 0x27f)
0041faf6          x87control_2 = __fldcw_memmem16((uint16_t)var_4);
0041fafa      return result;
00418132  }


00418305    int32_t _test_whether_TOS_is_int(long double arg1 @ st0)

00418305  {
00418307      long double x87_r7 = round(arg1, arg1);
00418309      x87_r7 - arg1;
0041830b      int32_t ecx;
0041830b      (uint8_t)ecx = 0;
0041830e      int16_t result = (x87_r7 < arg1 ? 1 : 0) << 8 | (FCMP_UO(x87_r7, arg1) ? 1 : 0) << 0xa
0041830e          | (x87_r7 == arg1 ? 1 : 0) << 0xe;
0041830e      
00418311      if (!TEST_BITB(*(uint8_t*)((char*)result)[1], 6))
0041832c          return result;
0041832c      
00418313      long double x87_r0 = arg1 * (long double)data_42d0e0;
00418319      (uint8_t)ecx = 1;
0041831d      long double x87_r7_2 = round(x87_r0, arg1);
0041831f      x87_r7_2 - x87_r0;
00418322      result = (x87_r7_2 < x87_r0 ? 1 : 0) << 8 | (FCMP_UO(x87_r7_2, x87_r0) ? 1 : 0) << 0xa
00418322          | (x87_r7_2 == x87_r0 ? 1 : 0) << 0xe | 0x800;
00418322      
00418325      if (TEST_BITB(*(uint8_t*)((char*)result)[1], 6))
00418327          (uint8_t)ecx = 2;
00418327      
00418329      return result;
00418305  }


0041832d    char* sub_41832d(char* arg1, int32_t arg2, int32_t* arg3)

0041832d  {
00418339      char* edi = arg1;
00418339      
0041833b      if (arg2 <= 0)
0041833d          return nullptr;
0041833d      
00418341      int32_t temp0_1 = arg2;
00418341      arg2 -= 1;
00418341      
00418345      if (temp0_1 != 1)
00418345      {
0041836f          int32_t i;
0041836f          
0041836f          do
0041836f          {
0041834a              int32_t temp1_1 = arg3[1];
0041834a              arg3[1] -= 1;
0041834d              uint32_t eax_2;
0041834d              
0041834d              if (temp1_1 - 1 < 0)
0041835a                  eax_2 = sub_41741a(arg3);
0041834d              else
0041834d              {
0041834f                  char* ecx_1 = *(uint32_t*)arg3;
00418351                  eax_2 = (uint32_t)*(uint8_t*)ecx_1;
00418355                  *(uint32_t*)arg3 = &ecx_1[1];
0041834d              }
0041834d              
00418363              if (eax_2 == 0xffffffff)
00418363              {
0041837e                  if (edi == arg1)
00418380                      return nullptr;
00418380                  
0041837e                  break;
00418363              }
00418363              
00418365              *(uint8_t*)edi = (uint8_t)eax_2;
00418367              edi = &edi[1];
00418367              
0041836a              if ((uint8_t)eax_2 == 0xa)
0041836a                  break;
0041836a              
0041836c              i = arg2;
0041836c              arg2 -= 1;
0041836f          } while (i != 1);
00418345      }
00418345      
00418371      *(uint8_t*)edi = 0;
00418374      return arg1;
0041832d  }


00418384    int32_t sub_418384(char* arg1, int32_t* arg2)

00418384  {
0041838d      void* eax = sub_41e7d0(arg1);
00418397      int32_t eax_1 = sub_41dc5e(arg2);
004183a7      uint32_t eax_2 = sub_41a92b(arg1, 1, eax, arg2);
004183b2      sub_41dceb(eax_1, arg2);
004183be      int32_t eax_3;
004183be      (uint8_t)eax_3 = eax_2 == eax;
004183c6      return eax_3 - 1;
00418384  }

004183c7                       cc cc cc cc cc cc cc cc cc                                                         .........

004183d0    int32_t sub_4183d0()

004183d0  {
004183d5      int16_t x87control;
004183d5      /* tailcall */
004183d5      return sub_420065(x87control);
004183d0  }

004183da                                                                                ba ba f7 42 00 eb                            ...B..
004183e0  f4 ba da f7 42 00 eb ed                                                                          ....B...

004183e8    int32_t sub_4183e8()

004183e8  {
004183ed      int16_t x87control;
004183ed      long double x87_r0;
004183ed      /* tailcall */
004183ed      return sub_41febe(x87control, x87_r0);
004183e8  }


004183f2    int32_t sub_4183f2()

004183f2  {
004183ed      int16_t x87control;
004183ed      long double x87_r0;
004183ed      /* tailcall */
004183ed      return sub_41febe(x87control, x87_r0);
004183f2  }


004183f9    int32_t sub_4183f9()

004183f9  {
004183ed      int16_t x87control;
004183ed      long double x87_r0;
004183ed      /* tailcall */
004183ed      return sub_41febe(x87control, x87_r0);
004183f9  }


00418400    int80_t sub_418400(long double arg1 @ st0)

00418400  {
00418413      int32_t ecx;
00418413      int32_t edx;
00418413      int16_t x87control;
00418413      return start(__checkTOS_withFB((int32_t)(double)arg1), x87control, arg1, edx, ecx);
00418400  }


00418414    int80_t sub_418414()

00418414  {
00418414      void arg_4;
00418414      void* edx_1 = &arg_4;
00418418      int32_t eax;
00418418      int32_t ecx;
00418418      int32_t ecx_1;
00418418      long double st0;
00418418      st0 = __fload_withFB(ecx, edx_1);
00418418      int16_t x87control;
00418418      /* tailcall */
00418418      return start(eax, x87control, st0, edx_1, ecx_1);
00418414  }


0041841d    long double __convention("regparm") start(int32_t arg1, int16_t arg2 @ x87control, long double arg3 @ st0, int32_t arg4, int32_t arg5)

0041841d  {
0041841d      int32_t edx;
0041841d      int32_t var_4 = edx;
0041841f      int16_t x87status;
0041841f      int16_t temp0;
0041841f      temp0 = __fnstcw_memmem16(arg2);
0041841f      (uint16_t)var_4 = temp0;
00418422      long double result;
00418422      bool z;
00418422      
00418422      if (z)
00418422      {
0041849d          int32_t eax_2;
0041849d          
0041849d          if (arg1 & 0xfffff || arg4)
0041849d          {
0041848a              long double result_1;
0041848a              result_1 = __convertTOStoQNaN(arg1, arg3);
0041848a              result = result_1;
0041849d          }
0041849d          else
0041849d          {
004184a1          label_4184a1:
004184a1              result = data_42f760;
004184a7              eax_2 = 1;
0041849d          }
0041849d          
004184b3          if (!data_4307a4)
004184ca              return __startOneArgErrorHandling(eax_2, 0xe, result, "asin", var_4);
00418422      }
00418422      else
00418422      {
0041842a          if ((uint16_t)var_4 != 0x27f)
0041842c              __load_CW(var_4);
0041842c          
00418436          bool c1;
00418436          
00418436          if (arg1 >= 0x3ff00000)
00418436          {
00418474              if (arg1 > 0x3ff00000 || (arg5 & 0xfffff) | arg4)
00418463                  goto label_4184a1;
00418463              
0041847e              result = data_42f76a;
0041847e              
00418484              if (arg5 & 0x80000000)
00418484              {
00418486                  result = -(result);
00418486                  c1 = false;
00418484              }
00418436          }
00418436          else
00418436          {
00418444              result =
00418444                  __fpatan(sqrtl(((long double)1 + arg3) * ((long double)1 - arg3)), arg3);
00418444              c1 = /* c1 = unimplemented  {fpatan } */;
00418436          }
00418436          
0041844d          if (!data_4307a4)
0041844d          {
0041fafb              (uint16_t)arg1 = (uint16_t)var_4;
0041fafb              
0041fb03              if ((uint16_t)arg1 != 0x27f)
0041fb03              {
0041fb05                  (uint16_t)arg1 &= 0x20;
0041fb05                  
0041fb09                  if ((uint16_t)arg1)
0041fb09                  {
0041fb0c                      bool c0;
0041fb0c                      bool c2;
0041fb0c                      bool c3;
0041fb0c                      (uint16_t)arg1 = (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9
0041fb0c                          | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0041fb0e                      (uint16_t)arg1 &= 0x20;
0041fb0e                      
0041fb12                      if ((uint16_t)arg1)
0041fb1f                          return __startOneArgErrorHandling(8, 0xe, result, "asin", var_4);
0041fb09                  }
0041fb09                  
0041fb20                  int16_t x87control_1;
0041fb20                  int16_t x87status_2;
0041fb20                  x87control_1 = __fldcw_memmem16((uint16_t)var_4);
0041fb03              }
0041fb03              
0041fb24              return result;
0041844d          }
00418422      }
00418422      
0041faf4      int16_t x87control;
0041faf4      int16_t x87status_1;
0041faf4      
0041faf4      if ((uint16_t)var_4 != 0x27f)
0041faf6          x87control = __fldcw_memmem16((uint16_t)var_4);
0041fafa      return result;
0041841d  }

004184cb                                   cc cc cc cc cc                                                             .....

004184d0    int80_t sub_4184d0(long double arg1 @ st0)

004184d0  {
004184e3      int32_t ecx;
004184e3      int32_t edx;
004184e3      int16_t x87control;
004184e3      return sub_4184ed(__checkTOS_withFB((int32_t)(double)arg1), x87control, arg1, edx, 
004184e3          ecx);
004184d0  }


004184e4    int80_t sub_4184e4()

004184e4  {
004184e4      void arg_4;
004184e4      void* edx_1 = &arg_4;
004184e8      int32_t eax;
004184e8      int32_t ecx;
004184e8      int32_t ecx_1;
004184e8      long double st0;
004184e8      st0 = __fload_withFB(ecx, edx_1);
004184e8      int16_t x87control;
004184e8      /* tailcall */
004184e8      return sub_4184ed(eax, x87control, st0, edx_1, ecx_1);
004184e4  }


004184ed    long double __convention("regparm") sub_4184ed(int32_t arg1, int16_t arg2 @ x87control, long double arg3 @ st0, int32_t arg4, int32_t arg5)

004184ed  {
004184ed      int32_t edx;
004184ed      int32_t var_4 = edx;
004184ef      int16_t x87status;
004184ef      int16_t temp0;
004184ef      temp0 = __fnstcw_memmem16(arg2);
004184ef      (uint16_t)var_4 = temp0;
004184f2      long double result;
004184f2      bool z;
004184f2      
004184f2      if (z)
004184f2      {
0041856d          int32_t eax_2;
0041856d          
0041856d          if (arg1 & 0xfffff || arg4)
0041856d          {
0041855a              long double result_1;
0041855a              result_1 = __convertTOStoQNaN(arg1, arg3);
0041855a              result = result_1;
0041856d          }
0041856d          else
0041856d          {
00418571          label_418571:
00418571              result = data_42f760;
00418577              eax_2 = 1;
0041856d          }
0041856d          
00418583          if (!data_4307a4)
0041859a              return __startOneArgErrorHandling(eax_2, 0xd, result, "acos", var_4);
004184f2      }
004184f2      else
004184f2      {
004184fa          if ((uint16_t)var_4 != 0x27f)
004184fc              __load_CW(var_4);
004184fc          
00418506          bool c1;
00418506          
00418506          if (arg1 >= 0x3ff00000)
00418506          {
00418546              if (arg1 > 0x3ff00000 || (arg5 & 0xfffff) | arg4)
00418535                  goto label_418571;
00418535              
00418550              result = !(arg5 & 0x80000000) ? (long double)0
00418550                  : (long double)3,1415926534682512.0
00418550                  + (long double)1,2154201012607932e-10;
00418506          }
00418506          else
00418506          {
00418516              result =
00418516                  __fpatan(arg3, sqrtl(((long double)1 + arg3) * ((long double)1 - arg3)));
00418516              c1 = /* c1 = unimplemented  {fpatan } */;
00418506          }
00418506          
0041851f          if (!data_4307a4)
0041851f          {
0041fafb              (uint16_t)arg1 = (uint16_t)var_4;
0041fafb              
0041fb03              if ((uint16_t)arg1 != 0x27f)
0041fb03              {
0041fb05                  (uint16_t)arg1 &= 0x20;
0041fb05                  
0041fb09                  if ((uint16_t)arg1)
0041fb09                  {
0041fb0c                      bool c0;
0041fb0c                      bool c2;
0041fb0c                      bool c3;
0041fb0c                      (uint16_t)arg1 = (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9
0041fb0c                          | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0041fb0e                      (uint16_t)arg1 &= 0x20;
0041fb0e                      
0041fb12                      if ((uint16_t)arg1)
0041fb1f                          return __startOneArgErrorHandling(8, 0xd, result, "acos", var_4);
0041fb09                  }
0041fb09                  
0041fb20                  int16_t x87control_1;
0041fb20                  int16_t x87status_2;
0041fb20                  x87control_1 = __fldcw_memmem16((uint16_t)var_4);
0041fb03              }
0041fb03              
0041fb24              return result;
0041851f          }
004184f2      }
004184f2      
0041faf4      int16_t x87control;
0041faf4      int16_t x87status_1;
0041faf4      
0041faf4      if ((uint16_t)var_4 != 0x27f)
0041faf6          x87control = __fldcw_memmem16((uint16_t)var_4);
0041fafa      return result;
004184ed  }


0041859b    long double sub_41859b(double arg1)

0041859b  {
0041859e      int32_t ecx;
0041859e      int32_t var_8 = ecx;
0041859f      int32_t var_c = ecx;
004185ae      int32_t eax;
004185ae      int16_t x87control;
004185ae      int16_t x87control_1;
004185ae      eax = sub_41f590(x87control, data_42d108, 0xffff);
004185ca      int32_t var_30;
004185ca      
004185ca      if ((*(uint16_t*)((char*)arg1)[6] & 0x7ff0) != 0x7ff0)
004185ca      {
00418626          var_c = (double)__frnd(9,18340949e-41f);
00418629          long double x87_r7_5 = (long double)var_c;
0041862c          long double temp0_1 = (long double)arg1;
0041862c          x87_r7_5 - temp0_1;
0041862c          
00418647          if (TEST_BITB(
00418647              *(uint8_t*)((char*)((x87_r7_5 < temp0_1 ? 1 : 0) << 8
00418647                  | (FCMP_UO(x87_r7_5, temp0_1) ? 1 : 0) << 0xa
00418647                  | (x87_r7_5 == temp0_1 ? 1 : 0) << 0xe))[1], 
00418647              6) || (uint8_t)eax & 0x20)
00418647          {
00418638              sub_41f590(x87control_1, eax, 0xffff);
00418669              return (long double)var_c;
00418647          }
00418647          
0041864c          int32_t var_18_3 = eax;
0041864f          int32_t var_20_1;
0041864f          var_20_1 = (double)(long double)var_c;
00418657          int32_t var_28_1;
00418657          var_28_1 = (double)(long double)arg1;
0041865c          __builtin_memcpy(&var_30, 
0041865c              "\x10\x00\x00\x00\x0c\x00\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00"
0041865c          "ff\xff\x00\x00", 
0041865c              0x18);
004185ca      }
004185ca      else
004185ca      {
004185cc          int32_t eax_2 = sub_41f458(0xffff, 0xffff);
004185cc          
004185d5          if (eax_2 > 0)
004185d5          {
004185da              if (eax_2 <= 2)
004185da              {
004185f8                  sub_41f590(x87control_1, eax, 0xffff);
00418669                  return (long double)arg1;
004185da              }
004185da              
004185df              if (eax_2 == 3)
004185df              {
004185e5                  int32_t var_1c_1 = 0xffff;
004185ec                  return sub_41ec64(eax_2, 0, 0xffff, 0xc, 9,18340949e-41f, eax);
004185df              }
004185d5          }
004185d5          
0041860d          int32_t var_18_2 = eax;
00418610          int32_t var_20;
00418610          var_20 = (double)((long double)arg1 + (long double)1.0);
00418618          int32_t var_28;
00418618          var_28 = (double)(long double)arg1;
0041861d          __builtin_memcpy(&var_30, 
0041861d              "\x08\x00\x00\x00\x0c\x00\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00"
0041861d          "ff\xff\x00\x00", 
0041861d              0x18);
004185ca      }
004185ca      
0041865e      return sub_41ed16(var_30, 0xc, 0xffff);
0041859b  }

0041866a                                cc cc cc cc cc cc                                                            ......

00418670    int32_t sub_418670()

00418670  {
00418675      int16_t x87control;
00418675      /* tailcall */
00418675      return sub_41fef4(x87control);
00418670  }


0041867a    int32_t sub_41867a()

0041867a  {
0041867f      int16_t x87control;
0041867f      long double x87_r0;
0041867f      long double x87_r1;
0041867f      /* tailcall */
0041867f      return sub_41fe80(x87control, x87_r0, x87_r1);
0041867a  }


00418684    long double sub_418684(long double arg1 @ st0, long double arg2 @ st1)

00418684  {
00418684      bool c1 = false;
00418684      long double x87_r0 = arg2;
0041869d      bool c0;
0041869d      bool c2;
0041869d      bool c3;
0041869d      
0041869d      do
0041869d      {
0041868d          if (data_4307a8 == 1)
0041868d          {
00418693              int16_t x87control;
00418693              long double st0_2;
00418693              st0_2 = sub_420adc(x87control, x87_r0, arg1);
00418693              x87_r0 = st0_2;
0041868d          }
0041868d          else
0041868d          {
0041868f              long double st0_1;
0041868f              uint8_t temp0;
0041868f              st0_1 = __fprem(x87_r0, arg1);
0041868f              x87_r0 = st0_1;
0041868f              
0041868f              if (!c2)
0041868f              {
0041868f                  c0 = temp0 & 4;
0041868f                  c1 = temp0 & 1;
0041868f                  c3 = temp0 & 2;
0041868f              }
0041868d          }
0041869d      } while (TEST_BITB(
0041869d          *(uint8_t*)((char*)((c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa
0041869d              | (c3 ? 1 : 0) << 0xe))[1], 
0041869d          2));
004186a1      return arg1;
00418684  }


004186a2    long double sub_4186a2(double arg1, int32_t arg2)

004186a2  {
004186a5      int32_t ecx;
004186a5      int32_t var_8 = ecx;
004186a6      int32_t var_c = ecx;
004186ae      int32_t eax;
004186ae      int16_t x87control;
004186ae      int16_t x87control_1;
004186ae      eax = sub_41f590(x87control, 0, 0);
004186c1      int32_t ecx_1;
004186c1      int16_t x87control_2;
004186c1      ecx_1 = sub_41f590(x87control_1, data_42d160, 0xffff);
004186c1      
004186d4      if (((uint16_t)arg2 & 0x7ff0) != 0x7ff0)
004186d4      {
00418777          long double x87_r7_14 = (long double)arg1;
0041877a          long double temp0_1 = (long double)0.0;
0041877a          x87_r7_14 - temp0_1;
00418780          long double x87_r7_15 = (long double)arg1;
00418786          long double x87_r7_16;
00418786          
00418786          if (!TEST_BITB(
00418786              *(uint8_t*)((char*)((x87_r7_14 < temp0_1 ? 1 : 0) << 8
00418786                  | (FCMP_UO(x87_r7_14, temp0_1) ? 1 : 0) << 0xa
00418786                  | (x87_r7_14 == temp0_1 ? 1 : 0) << 0xe | 0x3800))[1], 
00418786              6))
00418786          {
00418792              int32_t var_1c_5 = ecx_1;
00418793              int32_t var_20_5 = ecx_1;
00418794              var_20_5 = (double)x87_r7_15;
0041879c              var_c = (double)__frnd(var_20_5);
004187a7              *(uint64_t*)arg2 = (double)(long double)var_c;
004187ac              x87_r7_16 = (long double)arg1 - (long double)var_c;
00418786          }
00418786          else
00418786          {
0041878b              *(uint64_t*)arg2 = (double)x87_r7_15;
0041878d              x87_r7_16 = (long double)arg1;
00418786          }
00418786          
004187af          var_c = (double)x87_r7_16;
004187b4          sub_41f590(x87control_2, eax, 0xffff);
004186d4      }
004186d4      else
004186d4      {
004186e0          double* edi_1 = arg2;
004186e4          int32_t var_20_1 = ecx_1;
004186e5          *(uint64_t*)edi_1 = (double)(long double)data_42f6b0;
004186ea          var_20_1 = (double)(long double)arg1;
004186ed          int32_t eax_2 = sub_41f458(var_20_1, ecx_1);
004186ed          
004186f6          if (eax_2 <= 0)
004186f6          {
00418750          label_418750:
00418750              int32_t var_1c_4 = eax;
00418751              int32_t var_20_4 = ecx_1;
00418752              int32_t var_24_3 = ecx_1;
00418753              var_c = (double)((long double)arg1 + (long double)1.0);
00418759              *(uint64_t*)edi_1 = (double)(long double)var_c;
0041875e              var_24_3 = (double)(long double)var_c;
00418764              int32_t var_28_2 = ecx_1;
00418765              int32_t var_2c_1 = ecx_1;
00418766              var_2c_1 = (double)(long double)arg1;
0041876d              return sub_41ed16(8, 0x1c, var_2c_1);
004186f6          }
004186f6          
004186fb          if (eax_2 > 2)
004186fb          {
00418700              if (eax_2 != 3)
00418700                  goto label_418750;
00418700              
00418706              int32_t var_20_2 = ecx_1;
00418707              *(uint64_t*)edi_1 = (double)(long double)arg1;
0041870c              int32_t var_24_1 = ecx_1;
0041870d              var_24_1 = (double)(long double)arg1;
00418712              return sub_41ec64(eax_2, 0, ecx_1, 0x1c, var_24_1, eax);
004186fb          }
004186fb          
00418722          int32_t var_1c_3 = ecx_1;
00418723          int32_t var_20_3 = ecx_1;
00418724          *(uint64_t*)edi_1 = (double)(long double)arg1;
00418729          var_20_3 = (double)(long double)arg1;
0041872d          int32_t var_28_1 = ecx_1;
00418730          var_28_1 = (double)(long double)0;
00418738          var_c = (double)sub_420e5b(var_28_1, ecx_1, var_20_3);
0041873d          sub_41f590(x87control_2, eax, 0xffff);
004186d4      }
004186d4      
004187bb      return (long double)var_c;
004186a2  }


004187c3    long double sub_4187c3(double arg1, int32_t arg2)

004187c3  {
004187d3      int32_t eax;
004187d3      int16_t x87control;
004187d3      int16_t x87control_1;
004187d3      eax = sub_41f590(x87control, 0x133f, 0xffff);
004187d3      
004187e7      if (((uint16_t)arg2 & 0x7ff0) != 0x7ff0)
004187e7      {
00418855          int32_t var_14_2 = 0xffff;
0041885f          arg1 = (double)sub_41f4b2(0xffff, 9,18340949e-41f, arg2);
00418864          sub_41f590(x87control_1, eax, 0xffff);
00418869          return (long double)arg1;
004187e7      }
004187e7      
004187f0      *(uint32_t*)arg2 = 0xffffffff;
004187f7      int32_t eax_3 = sub_41f458(0xffff, 0xffff);
00418800      long double x87_r7_1;
00418800      int32_t var_10_2;
00418800      
00418800      if (eax_3 <= 0)
00418800      {
0041882d          x87_r7_1 = (long double)arg1 + (long double)1.0;
00418833          var_10_2 = eax;
00418800      }
00418800      else if (eax_3 <= 2)
00418805      {
00418821          x87_r7_1 = (long double)data_42f6b0;
00418827          int32_t var_10_1 = eax;
00418805      }
00418805      else
00418805      {
0041880a          if (eax_3 == 3)
0041880a          {
00418810              int32_t var_14 = 0xffff;
00418817              return sub_41ec64(eax_3, 0, 0xffff, 0x17, 9,18340949e-41f, eax);
0041880a          }
0041880a          
0041882d          x87_r7_1 = (long double)arg1 + (long double)1.0;
00418833          var_10_2 = eax;
00418805      }
00418834      int32_t var_14_1 = 0xffff;
00418835      int32_t var_18_1 = 0xffff;
00418836      var_18_1 = (double)x87_r7_1;
0041883c      int32_t var_1c_1 = 0xffff;
00418845      return sub_41ed16(8, 0x17, 0xffff);
004187c3  }


00418873    long double sub_418873(int32_t arg1 @ edi, double arg2, int32_t arg3)

00418873  {
00418886      int32_t eax;
00418886      int16_t x87control;
00418886      int16_t x87control_1;
00418886      eax = sub_41f590(x87control, 0x133f, 0xffff);
0041888b      long double x87_r7 = (long double)arg2;
0041889d      int32_t var_3c_1;
0041889d      int32_t var_34;
0041889d      int32_t var_2c;
0041889d      
0041889d      if ((*(uint16_t*)((char*)arg2)[6] & 0x7ff0) != 0x7ff0)
0041889d      {
0041890d          long double temp0_1 = (long double)0.0;
0041890d          x87_r7 - temp0_1;
0041890d          
00418916          if (!TEST_BITB(
00418916              *(uint8_t*)((char*)((x87_r7 < temp0_1 ? 1 : 0) << 8
00418916                  | (FCMP_UO(x87_r7, temp0_1) ? 1 : 0) << 0xa
00418916                  | (x87_r7 == temp0_1 ? 1 : 0) << 0xe))[1], 
00418916              6))
00418916          {
00418930              int32_t var_20_3 = 0xffff;
0041893a              int32_t eax_3 = arg3;
00418940              int32_t var_8;
00418940              double var_10_3 = (double)sub_41f4b2(0xffff, 9,18340949e-41f, &var_8);
00418945              int32_t ecx_2 = eax_3;
00418945              
00418947              if (eax_3 < 0)
00418949                  ecx_2 = -(ecx_2);
00418949              
00418951              if (ecx_2 <= 0x7fffffff)
00418951              {
00418953                  ecx_2 = var_8;
00418956                  eax_3 += ecx_2;
00418951              }
00418951              
0041895d              int32_t ecx_3;
0041895d              long double x87_r7_13;
0041895d              
0041895d              if (eax_3 <= 0xa00)
0041895d              {
004189a1                  if (eax_3 > 0x400)
004189a1                  {
004189ac                      int32_t var_20_5 = ecx_2;
004189ad                      int32_t var_24_2 = ecx_2;
004189ae                      var_24_2 = (double)(long double)var_10_3;
004189b1                      long double st0_4;
004189b1                      st0_4 = sub_41f42f(var_24_2, (uint16_t)eax_3 - 0x600, arg1);
004189bf                      int32_t var_1c_6 = eax;
004189c0                      int32_t var_20_6 = ecx_3;
004189c1                      int32_t var_24_3 = ecx_3;
004189c2                      var_24_3 = (double)(long double)(double)st0_4;
004189cb                      x87_r7_13 = (long double)(double)(long double)arg3;
004189ce                      goto label_418986;
004189a1                  }
004189a1                  
004189d5                  long double x87_r7_21;
004189d5                  
004189d5                  if (eax_3 >= 0xfffff603)
004189d5                  {
004189ef                      if (eax_3 >= 0xfffffc03)
004189ef                      {
00418a3b                          int32_t var_20_10 = ecx_2;
00418a3c                          int32_t var_24_7 = ecx_2;
00418a3d                          var_24_7 = (double)(long double)var_10_3;
00418a45                          double var_10_10 =
00418a45                              (double)sub_41f42f(var_24_7, (uint16_t)eax_3, arg1);
00418a4a                          sub_41f590(x87control_1, eax, 0xffff);
00418a4f                          return (long double)var_10_10;
004189ef                      }
004189ef                      
004189fa                      int32_t var_20_8 = ecx_2;
004189fb                      int32_t var_24_5 = ecx_2;
004189fc                      var_24_5 = (double)(long double)var_10_3;
004189ff                      long double st0_5;
004189ff                      st0_5 = sub_41f42f(var_24_5, (uint16_t)eax_3 + 0x600, arg1);
00418a0d                      int32_t var_1c_9 = eax;
00418a0e                      int32_t var_20_9 = ecx_2;
00418a0f                      int32_t var_24_6 = ecx_2;
00418a10                      var_24_6 = (double)(long double)(double)st0_5;
00418a19                      x87_r7_21 = (long double)(double)(long double)arg3;
004189d5                  }
004189d5                  else
004189d5                  {
004189d7                      int32_t var_1c_7 = eax;
004189d8                      int32_t var_20_7 = ecx_2;
004189db                      int32_t var_24_4 = ecx_2;
004189dc                      var_24_4 = (double)(long double)0;
004189e5                      x87_r7_21 = (long double)(double)(long double)arg3;
004189d5                  }
004189d5                  
00418a1c                  int32_t var_28_4 = ecx_2;
00418a1d                  var_2c = ecx_2;
00418a1e                  var_2c = (double)x87_r7_21;
00418a24                  int32_t var_30_2 = ecx_2;
00418a25                  var_34 = ecx_2;
00418a26                  var_34 = (double)(long double)arg2;
00418a29                  int32_t var_38_2 = 0x19;
00418a2b                  var_3c_1 = 0x12;
0041895d              }
0041895d              else
0041895d              {
00418962                  int32_t var_1c_4 = eax;
00418963                  int32_t var_20_4 = ecx_2;
00418964                  int32_t var_24_1 = ecx_2;
00418965                  var_24_1 = (double)(long double)var_10_3;
0041896f                  int32_t var_2c_1 = ecx_2;
00418970                  var_2c_1 = (double)(long double)data_42f6a8;
00418979                  ecx_3 = ecx_2;
0041897a                  var_24_1 = (double)sub_420e5b(var_2c_1, ecx_2, var_24_1);
00418983                  x87_r7_13 = (long double)(double)(long double)arg3;
00418986              label_418986:
00418986                  int32_t var_28_3 = ecx_3;
00418987                  var_2c = ecx_3;
00418988                  var_2c = (double)x87_r7_13;
0041898e                  int32_t var_30_1 = ecx_3;
0041898f                  var_34 = ecx_3;
00418990                  var_34 = (double)(long double)arg2;
00418993                  int32_t var_38_1 = 0x19;
00418995                  var_3c_1 = 0x11;
0041895d              }
00418a2d              return sub_41edae(var_3c_1, 0x19, var_34, var_2c);
00418916          }
0041889d      }
0041889d      else
0041889d      {
004188a4          int32_t eax_2 = sub_41f458(0xffff, 0xffff);
004188a4          
004188ad          if (eax_2 <= 0)
004188ad          {
004188e8          label_4188e8:
004188e8              int32_t var_1c_2 = eax;
004188eb              int32_t var_24;
004188eb              var_24 = (double)((long double)arg2 + (long double)1.0);
004188f9              var_2c = (double)(long double)(double)(long double)arg3;
00418901              var_34 = (double)(long double)arg2;
00418906              __builtin_memcpy(&var_3c_1, 
00418906                  "\x08\x00\x00\x00\x19\x00\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00"
00418906              "00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00", 
00418906                  0x20);
00418a2d              return sub_41edae(var_3c_1, 0x19, var_34, var_2c);
004188ad          }
004188ad          
004188b2          if (eax_2 > 2)
004188b2          {
004188b7              if (eax_2 != 3)
004188b7                  goto label_4188e8;
004188b7              
004188bd              int32_t var_20_1 = 0xffff;
004188bf              double var_10_1 = (double)(long double)arg3;
004188cb              int32_t var_28_1 = 0xffff;
004188d2              return sub_41ecb7(eax_2, 0, 0xffff, 0x19, 9,18340949e-41f, 9,18340949e-41f, 
004188d2                  eax);
004188b2          }
0041889d      }
0041891a      sub_41f590(x87control_1, eax, 0xffff);
00418a58      return (long double)arg2;
00418873  }


00418a59    int32_t sub_418a59(int32_t arg1)

00418a59  {
00418a5d      data_42d164 = arg1;
00418a62      return arg1;
00418a59  }


00418a63    int32_t sub_418a63()

00418a63  {
00418a6e      int32_t eax_1 = data_42d164 * 0x343fd + 0x269ec3;
00418a73      data_42d164 = eax_1;
00418a80      return eax_1 >> 0x10 & 0x7fff;
00418a63  }

00418a81     cc cc cc                                                                                       ...

00418a84    uint32_t __fastcall sub_418a84(int32_t arg1)

00418a84  {
00418a87      int32_t var_8 = arg1;
00418a92      uint32_t arg_4;
00418a92      
00418a92      if (!data_430a14)
00418a92      {
00418a94          uint32_t eax_1 = arg_4;
00418a94          
00418aa3          if (eax_1 >= 0x41 && eax_1 <= 0x5a)
00418aa9              return eax_1 + 0x20;
00418aa9          
00418b4e          return eax_1;
00418a92      }
00418a92      
00418ab1      uint32_t ebx_1 = arg_4;
00418abe      BOOL eax_2;
00418abe      
00418abe      if (ebx_1 < 0x100)
00418abe      {
00418ac6          int32_t eax;
00418ac6          int32_t edx;
00418ac6          
00418ac6          if (data_42d07c <= 1)
00418ac6          {
00418ad8              wchar16 (* eax_3)[0x21];
00418ad8              (uint8_t)eax_3 = (**(uint528_t**)&data_42ce70)[ebx_1];
00418adb              eax_2 = eax_3 & 1;
00418ac6          }
00418ac6          else
00418aca              eax_2 = sub_4179df(eax, edx, arg1, ebx_1);
00418abe      }
00418abe      
00418adf      if (ebx_1 >= 0x100 || eax_2)
00418adf      {
00418aed          char eax_5 = (char)(ebx_1 >> 8);
00418af8          void* eax_6;
00418af8          
00418af8          if (!(*(uint8_t*)(&(**(uint528_t**)&data_42ce70)[(uint32_t)eax_5] + 1) & 0x80))
00418af8          {
00418b09              *(uint8_t*)((char*)arg_4)[1] = 0;
00418b0d              (uint8_t)arg_4 = (uint8_t)ebx_1;
00418b10              eax_6 = 1;
00418af8          }
00418af8          else
00418af8          {
00418afa              *(uint8_t*)((char*)arg_4)[2] = 0;
00418b00              (uint8_t)arg_4 = eax_5;
00418b03              *(uint8_t*)((char*)arg_4)[1] = (uint8_t)ebx_1;
00418b06              eax_6 = 2;
00418af8          }
00418af8          
00418b27          int32_t eax_7 = sub_420f0e(data_430a14, 0x100, &arg_4, eax_6, &var_8, 3, 0, 1);
00418b27          
00418b31          if (eax_7)
00418b31          {
00418b35              if (eax_7 != 1)
00418b48                  return (uint32_t)*(uint8_t*)((char*)var_8)[1] << 8
00418b48                      | (uint32_t)(uint8_t)var_8;
00418b48              
00418b37              return (uint32_t)(uint8_t)var_8;
00418b31          }
00418adf      }
00418adf      
00418ae1      return ebx_1;
00418a84  }


00418b4f    uint32_t __fastcall sub_418b4f(int32_t arg1)

00418b4f  {
00418b52      int32_t var_8 = arg1;
00418b5b      uint32_t arg_4;
00418b5b      
00418b5b      if (!data_430a14)
00418b5b      {
00418b5d          uint32_t eax_1 = arg_4;
00418b5d          
00418b6c          if (eax_1 >= 0x61 && eax_1 <= 0x7a)
00418b72              return eax_1 - 0x20;
00418b72          
00418c1a          return eax_1;
00418b5b      }
00418b5b      
00418b7a      uint32_t ebx_1 = arg_4;
00418b83      BOOL eax_2;
00418b83      
00418b83      if (ebx_1 < 0x100)
00418b83      {
00418b8c          int32_t eax;
00418b8c          int32_t edx;
00418b8c          
00418b8c          if (data_42d07c <= 1)
00418b8c          {
00418b9f              wchar16 (* eax_3)[0x21];
00418b9f              (uint8_t)eax_3 = (**(uint528_t**)&data_42ce70)[ebx_1];
00418ba2              eax_2 = eax_3 & 2;
00418b8c          }
00418b8c          else
00418b91              eax_2 = sub_4179df(eax, edx, arg1, ebx_1);
00418b83      }
00418b83      
00418ba7      if (ebx_1 >= 0x100 || eax_2)
00418ba7      {
00418bb5          char eax_5 = (char)(ebx_1 >> 8);
00418bc0          void* var_10_1;
00418bc0          
00418bc0          if (!(*(uint8_t*)(&(**(uint528_t**)&data_42ce70)[(uint32_t)eax_5] + 1) & 0x80))
00418bc0          {
00418bd0              *(uint8_t*)((char*)arg_4)[1] = 0;
00418bd4              (uint8_t)arg_4 = (uint8_t)ebx_1;
00418bd7              var_10_1 = 1;
00418bc0          }
00418bc0          else
00418bc0          {
00418bc2              *(uint8_t*)((char*)arg_4)[2] = 0;
00418bc6              (uint8_t)arg_4 = eax_5;
00418bc9              *(uint8_t*)((char*)arg_4)[1] = (uint8_t)ebx_1;
00418bcc              var_10_1 = 2;
00418bc0          }
00418bc0          
00418bf4          int32_t eax_7 = sub_420f0e(data_430a14, 0x200, &arg_4, var_10_1, &var_8, 3, 0, 1);
00418bf4          
00418bfe          if (eax_7)
00418bfe          {
00418c03              if (eax_7 != 1)
00418c16                  return (uint32_t)*(uint8_t*)((char*)var_8)[1] << 8
00418c16                      | (uint32_t)(uint8_t)var_8;
00418c16              
00418c05              return (uint32_t)(uint8_t)var_8;
00418bfe          }
00418ba7      }
00418ba7      
00418ba9      return ebx_1;
00418b4f  }

00418c1b                                                                                   cc cc cc cc cc                             .....

00418c20    void* sub_418c20(char* arg1, char* arg2)

00418c20  {
00418c2d      int32_t var_28_1;
00418c2d      __builtin_memset(&var_28_1, 0, 0x20);
00418c2e      char* edx = arg2;
00418c34      void* result;
00418c34      
00418c34      while (true)
00418c34      {
00418c34          (uint8_t)result = *(uint8_t*)edx;
00418c36          (uint8_t)result = (uint8_t)result;
00418c36          
00418c38          if (!(uint8_t)result)
00418c38              break;
00418c38          
00418c3a          edx = &edx[1];
00418c3b          var_28_1 |= 1 << (result % 0x20);
00418c34      }
00418c34      
00418c41      char* esi = arg1;
00418c41      
00418c4f      do
00418c4f      {
00418c44          (uint8_t)result = *(uint8_t*)esi;
00418c46          (uint8_t)result = (uint8_t)result;
00418c46          
00418c48          if (!(uint8_t)result)
00418c59              return result;
00418c59          
00418c4a          esi = &esi[1];
00418c4f      } while (!TEST_BITD(var_28_1, result));
00418c4f      
00418c51      return &esi[0xffffffff];
00418c20  }

00418c5a                                                                                cc cc cc cc cc cc                            ......

00418c60    void* sub_418c60(char* arg1, char arg2, int32_t arg3)

00418c60  {
00418c60      int32_t result = arg3;
00418c60      
00418c67      if (result)
00418c67      {
00418c69          char* edx_1 = arg1;
00418c6f          int32_t ebx_1;
00418c6f          (uint8_t)ebx_1 = arg2;
00418c79          uint32_t ecx;
00418c79          
00418c79          while (edx_1 & 3)
00418c79          {
00418c7b              (uint8_t)ecx = *(uint8_t*)edx_1;
00418c7d              edx_1 = &edx_1[1];
00418c7e              (uint8_t)ecx ^= (uint8_t)ebx_1;
00418c7e              
00418c80              if (!(uint8_t)ecx)
00418cf2                  return &edx_1[0xffffffff];
00418cf2              
00418c82              int32_t result_1 = result;
00418c82              result -= 1;
00418c82              
00418c83              if (result_1 == 1)
00418cb4                  return result;
00418c79          }
00418c79          
00418c8d          int32_t i_1 = result - 4;
00418c8d          
00418c90          if (result >= 4)
00418c90          {
00418c9f              ebx_1 *= 0x1010101;
00418cb8              int32_t i;
00418cb8              
00418cb8              do
00418cb8              {
00418cbc                  int32_t ecx_2 = *(uint32_t*)edx_1 ^ ebx_1;
00418cca                  edx_1 = &edx_1[4];
00418cca                  
00418cd3                  if ((ecx_2 ^ 0xffffffff ^ (0x7efefeff + ecx_2)) & 0x81010100)
00418cd3                  {
00418cd8                      int32_t ecx_5;
00418cd8                      (uint8_t)ecx_5 = (*(uint32_t*)(edx_1 - 4)) ^ (uint8_t)ebx_1;
00418cd8                      
00418cda                      if (!(uint8_t)ecx_5)
00418d04                          return &edx_1[0xfffffffc];
00418d04                      
00418cdc                      *(uint8_t*)((char*)ecx_5)[1] ^= (uint8_t)ebx_1;
00418cdc                      
00418cde                      if (!*(uint8_t*)((char*)ecx_5)[1])
00418cfe                          return &edx_1[0xfffffffd];
00418cfe                      
00418ce3                      (uint8_t)ecx = (ecx_5 >> 0x10) ^ (uint8_t)ebx_1;
00418ce3                      
00418ce5                      if (!(uint8_t)ecx)
00418cf8                          return &edx_1[0xfffffffe];
00418cf8                      
00418ce7                      *(uint8_t*)((char*)ecx)[1] ^= (uint8_t)ebx_1;
00418ce7                      
00418ce9                      if (!*(uint8_t*)((char*)ecx)[1])
00418cf2                          return &edx_1[0xffffffff];
00418cd3                  }
00418cd3                  
00418cb5                  i = i_1;
00418cb5                  i_1 -= 4;
00418cb8              } while (i >= 4);
00418c90          }
00418c90          
00418ca4          result = i_1 + 4;
00418ca4          
00418ca7          if (i_1 != 0xfffffffc)
00418ca7          {
00418ca9              while (true)
00418ca9              {
00418ca9                  (uint8_t)ecx = *(uint8_t*)edx_1;
00418cab                  edx_1 = &edx_1[1];
00418cac                  (uint8_t)ecx ^= (uint8_t)ebx_1;
00418cac                  
00418cae                  if (!(uint8_t)ecx)
00418cf2                      return &edx_1[0xffffffff];
00418cf2                  
00418cb0                  int32_t result_2 = result;
00418cb0                  result -= 1;
00418cb0                  
00418cb1                  if (result_2 == 1)
00418cb4                      return result;
00418ca9              }
00418ca7          }
00418c67      }
00418c67      
00418cb4      return result;
00418c60  }

00418d05                 cc cc cc                                                                               ...

00418d08    int32_t __ftol(int16_t arg1 @ x87control, long double arg2 @ st0)

00418d08  {
00418d0f      int16_t x87status;
00418d0f      int16_t temp0;
00418d0f      temp0 = __fnstcw_memmem16(arg1);
00418d17      int16_t eax;
00418d17      *(uint8_t*)((char*)eax)[1] = *(uint8_t*)((char*)temp0)[1] | 0xc;
00418d1e      int16_t x87control;
00418d1e      int16_t x87status_1;
00418d1e      x87control = __fldcw_memmem16(eax);
00418d24      int16_t x87control_1;
00418d24      int16_t x87status_2;
00418d24      x87control_1 = __fldcw_memmem16(temp0);
00418d2e      return ((int64_t)arg2);
00418d08  }


00418d2f    char* sub_418d2f(int32_t arg1)

00418d2f  {
00418d3b      void* eax = sub_418fca("COMSPEC");
00418d46      void* var_14 = eax;
00418d46      
00418d4b      if (!arg1)
00418d4b      {
00418d4f          if (eax)
00418d4f          {
00418d57              int32_t eax_1 = sub_42145a(eax, 0);
00418d5c              int32_t eax_2 = -(eax_1);
00418d62              return eax_2 - eax_2 + 1;
00418d4f          }
00418d4f          
00418d51          return nullptr;
00418d4b      }
00418d4b      
00418d67      void* const var_10_1 = &data_428ad0;
00418d6e      int32_t var_c_1 = arg1;
00418d71      int32_t var_8_1 = 0;
00418d71      
00418d74      if (eax)
00418d74      {
00418d7d          char* result = sub_4212c0(0, eax, &var_14, nullptr);
00418d7d          
00418d88          if (result != 0xffffffff)
00418dc4              return result;
00418dc4          
00418d8a          int32_t ecx_2 = data_4307d4;
00418d8a          
00418d98          if (ecx_2 != 2 && ecx_2 != 0xd)
00418dc4              return result;
00418d74      }
00418d74      
00418d9a      bool cond:1_1 = (*(int32_t*)((char*)data_4307e0 + 1)) & 0x80;
00418da1      var_14 = "command.com";
00418da1      
00418da8      if (!cond:1_1)
00418daa          var_14 = "cmd.exe";
00418daa      
00418dba      return sub_42115d(0, var_14, &var_14, nullptr);
00418d2f  }


00418dc5    int32_t sub_418dc5(PSTR arg1)

00418dc5  {
00418dd1      enum WIN32_ERROR eax_1;
00418dd1      
00418dd1      if (DeleteFileA(arg1))
00418ddb          eax_1 = NO_ERROR;
00418dd1      else
00418dd3          eax_1 = GetLastError();
00418dd3      
00418ddf      if (!eax_1)
00418dee          return 0;
00418dee      
00418de2      sub_42149e(eax_1);
00418deb      return 0xffffffff;
00418dc5  }


00418def    int32_t sub_418def(PSTR arg1, PSTR arg2)

00418def  {
00418dff      enum WIN32_ERROR eax_1;
00418dff      
00418dff      if (MoveFileA(arg1, arg2))
00418e09          eax_1 = NO_ERROR;
00418dff      else
00418e01          eax_1 = GetLastError();
00418e01      
00418e0d      if (!eax_1)
00418e1c          return 0;
00418e1c      
00418e10      sub_42149e(eax_1);
00418e19      return 0xffffffff;
00418def  }


00418e1d    char* sub_418e1d(char* arg1)

00418e1d  {
00418e2a      if (!data_430834)
00418e2a      {
00418e2e          sub_418f23(0);
00418e33          goto label_418e3d;
00418e2a      }
00418e2a      
00418e40      bool cond:2_1;
00418e40      
00418e40      do
00418e40      {
00418e4b          if (sub_418f84(&data_430834))
00418e50              return 0;
00418e50          
00418e3d      label_418e3d:
00418e3d          cond:2_1 = sub_42145a(&data_430834, 0);
00418e40      } while (!cond:2_1);
00418e40      
00418e58      if (!arg1)
00418e5a          return &data_430834;
00418e5a      
00418e60      sub_41b8c0(arg1, &data_430834);
00418e6b      return arg1;
00418e1d  }


00418e6c    int32_t* sub_418e6c()

00418e6c  {
00418e7c      if (data_430844)
00418e7c      {
00418e91          if (!sub_418f84(&data_430844))
00418e91              goto label_418e93;
00418e7c      }
00418e7c      else
00418e7c      {
00418e80          sub_418f23(1);
00418e93      label_418e93:
00418e93          int32_t* result = sub_41bb20();
00418e93          
00418e9c          if (result)
00418e9c          {
00418e9e              int32_t var_14_1 = 0x180;
00418eb1              int32_t ebp_1 = sub_421530(&data_430844, 0x8542, 0x40);
00418eb1              
00418eb9              if (ebp_1 != 0xffffffff)
00418eb9              {
00418eed              label_418eed:
00418eed                  char* eax_5 = sub_421505(&data_430844);
00418ef3                  result[7] = eax_5;
00418ef3                  
00418efa                  if (eax_5)
00418efa                  {
00418f07                      result[1] = 0;
00418f0a                      *(uint32_t*)result = 0;
00418f0c                      result[2] = 0;
00418f14                      int32_t eax_6;
00418f14                      (uint8_t)eax_6 = data_430a40 | 0x80;
00418f16                      result[4] = ebp_1;
00418f19                      result[3] = eax_6;
00418f1c                      return result;
00418efa                  }
00418efa                  
00418efd                  sub_41b21b(ebp_1);
00418eb9              }
00418eb9              else
00418eb9              {
00418ec2                  while (data_4307d4 == 0x11)
00418ec2                  {
00418ecd                      if (sub_418f84(&data_430844))
00418ecd                          break;
00418ecd                      
00418ecf                      int32_t var_14_2 = 0x180;
00418edd                      ebp_1 = sub_421530(&data_430844, 0x8542, 0x40);
00418edd                      
00418ee5                      if (ebp_1 != 0xffffffff)
00418ee5                          break;
00418ec2                  }
00418ec2                  
00418eea                  if (ebp_1 != 0xffffffff)
00418eea                      goto label_418eed;
00418eb9              }
00418e9c          }
00418e7c      }
00418e7c      
00418f03      return nullptr;
00418e6c  }


00418f23    char* sub_418f23(int32_t arg1)

00418f23  {
00418f29      char* esi = &data_430834;
00418f29      
00418f2e      if (arg1)
00418f30          esi = &data_430844;
00418f30      
00418f3b      sub_41b8c0(esi, U"\;");
00418f41      void* eax = &esi[1];
00418f45      char ecx = *(uint8_t*)((char*)eax - 1);
00418f45      
00418f50      if (ecx != 0x5c && ecx != 0x2f)
00418f50      {
00418f52          *(uint8_t*)eax = 0x5c;
00418f55          eax += 1;
00418f50      }
00418f50      
00418f5b      if (!arg1)
00418f62          *(uint8_t*)eax = 0x73;
00418f5b      else
00418f5d          *(uint8_t*)eax = 0x74;
00418f5d      
00418f6f      sub_421872(GetCurrentProcessId(), (char*)eax + 1, 0x20);
00418f83      return sub_41b8d0(esi, U".");
00418f23  }


00418f84    int32_t sub_418f84(char* arg1)

00418f84  {
00418f96      void* esi_1 = &sub_421893(arg1, 0x2e)[1];
00418fa2      int32_t eax_2 = sub_417c79(esi_1, nullptr, 0x20) + 1;
00418fa2      
00418fa8      if (eax_2 >= 0x7fff)
00418faa          return 0xffffffff;
00418faa      
00418fbd      sub_41b8c0(esi_1, sub_421872(eax_2, &arg1, 0x20));
00418fc5      return 0;
00418f84  }


00418fca    void* sub_418fca(uint8_t* arg1)

00418fca  {
00418fd3      int32_t* esi = data_4307fc;
00418fd3      
00418fda      if (data_431f48)
00418fda      {
00418fde          if (esi)
00418fde          {
00418fff          label_418fff:
00418fff              
00419001              if (arg1)
00419001              {
00419004                  void* eax_2 = sub_41e7d0(arg1);
00419004                  
0041900c                  while (true)
0041900c                  {
0041900c                      char* eax_3 = *(uint32_t*)esi;
0041900c                      
00419010                      if (!eax_3)
00419010                          break;
00419010                      
0041901b                      if (sub_41e7d0(eax_3) > eax_2)
0041901b                      {
0041901d                          char* eax_5 = *(uint32_t*)esi;
0041901d                          
00419023                          if (*(uint8_t*)(eax_5 + eax_2) == 0x3d
00419023                                  && !sub_42192f(eax_5, arg1, eax_2))
0041903b                              return *(uint32_t*)esi + eax_2 + 1;
0041901b                      }
0041901b                      
00419034                      esi = &esi[1];
0041900c                  }
00419001              }
00418fde          }
00418fde          else if (data_430804 != esi && !sub_42196e())
00418fe6          {
00418ff1              esi = data_4307fc;
00418ff1              
00418ff9              if (esi)
00418ff9                  goto label_418fff;
00418fe6          }
00418fda      }
00418fda      
00419041      return nullptr;
00418fca  }


00419047    uint32_t __fastcall sub_419047(int32_t arg1)

00419047  {
0041904a      FILETIME systemTimeAsFileTime;
0041904a      systemTimeAsFileTime.dwHighDateTime = arg1;
0041904b      systemTimeAsFileTime.dwLowDateTime = arg1;
00419051      GetSystemTimeAsFileTime(&systemTimeAsFileTime);
00419060      int32_t eax;
00419060      int32_t edx;
00419060      eax = __allmul(systemTimeAsFileTime.dwHighDateTime, 0, 0, 1);
00419065      int32_t eax_1 = eax - data_430858;
0041906b      uint32_t dwLowDateTime = systemTimeAsFileTime.dwLowDateTime;
00419089      return __aulldiv(eax_1 + dwLowDateTime, edx - data_43085c + 0, 0x2710, 0);
00419047  }


0041908a    int32_t __fastcall sub_41908a(int32_t arg1)

0041908a  {
0041908d      FILETIME systemTimeAsFileTime;
0041908d      systemTimeAsFileTime.dwHighDateTime = arg1;
0041908e      systemTimeAsFileTime.dwLowDateTime = arg1;
00419094      GetSystemTimeAsFileTime(&systemTimeAsFileTime);
004190a3      int32_t eax;
004190a3      int32_t edx;
004190a3      eax = __allmul(systemTimeAsFileTime.dwHighDateTime, 0, 0, 1);
004190a8      uint32_t dwLowDateTime = systemTimeAsFileTime.dwLowDateTime;
004190ad      int32_t result = eax + dwLowDateTime;
004190b1      data_430858 = result;
004190b6      data_43085c = edx + 0;
004190be      return result;
0041908a  }


004190bf    void* sub_4190bf(char* arg1, char* arg2, int32_t* arg3, void* arg4)

004190bf  {
004190bf      int32_t var_4 = 0;
004190d9      int32_t eax;
004190d9      char* ecx;
004190d9      int32_t edx;
004190d9      return sub_4190da(eax, edx, ecx, arg1, arg2, arg3, arg4);
004190bf  }


004190da    void* __convention("regparm") sub_4190da(int32_t arg1, int32_t arg2, char* arg3, char* arg4, char* arg5, int32_t* arg6, void* arg7)

004190da  {
004190dd      char* i = arg3;
004190e2      void* ebx = arg7;
004190e5      i = arg4;
004190e5      
004190ea      if (!ebx)
004190ec          ebx = data_42d170;
004190ec      
004190f4      if (arg4 > 0)
004190f4      {
004190fb          char* esi_1 = arg5;
0041916e          char* arg_4;
0041916e          
0041916e          do
0041916e          {
004190fe              char* eax;
004190fe              (uint8_t)eax = *(uint8_t*)esi_1;
004190fe              
00419102              if (!(uint8_t)eax)
00419102                  break;
00419102              
00419106              if ((uint8_t)eax == 0x25)
00419106              {
0041913a                  data_430f24 = 0;
00419141                  void* esi_2 = &esi_1[1];
00419141                  
00419145                  if (*(uint8_t*)esi_2 == 0x23)
00419145                  {
00419147                      data_430f24 = 1;
00419151                      esi_2 += 1;
00419145                  }
00419145                  
00419161                  sub_41918a(*(uint8_t*)esi_2, arg6, &arg_4, &i, ebx);
00419169                  esi_1 = (char*)esi_2 + 1;
00419106              }
00419106              else
00419106              {
0041911c                  if (*
0041911c                      (uint8_t*)(&(**(uint528_t**)&data_42ce70)[(uint32_t)(uint8_t)eax] + 1)
0041911c                      & 0x80 && i > 1)
0041911c                  {
00419121                      *(uint8_t*)arg_4 = (uint8_t)eax;
00419123                      arg_4 = &arg_4[1];
00419126                      esi_1 = &esi_1[1];
00419127                      i -= 1;
0041911c                  }
0041911c                  
0041912d                  (uint8_t)eax = *(uint8_t*)esi_1;
0041912f                  *(uint8_t*)arg_4 = (uint8_t)eax;
00419131                  arg_4 = &arg_4[1];
00419134                  esi_1 = &esi_1[1];
00419135                  i -= 1;
00419106              }
0041916e          } while (i > 0);
0041916e          
00419175          if (i > 0)
00419175          {
0041917a              *(uint8_t*)arg_4 = 0;
00419180              return arg4 - i;
00419175          }
004190f4      }
004190f4      
00419185      return nullptr;
004190da  }


0041918a    char* sub_41918a(char arg1, int32_t* arg2, void** arg3, void** arg4, void* arg5)

0041918a  {
0041918d      int32_t eax = (int32_t)arg1;
00419197      int32_t var_20_1;
00419197      int32_t var_1c_1;
00419197      void** var_18_1;
00419197      void** var_14_1;
00419197      char* result;
00419197      
00419197      if (eax <= 0x5a)
00419197      {
0041919d          if (eax == 0x5a)
0041919d          {
004194a8          label_4194a8:
004194a8              sub_421a84();
004194bb              int32_t eax_66;
004194bb              (uint8_t)eax_66 = arg2[8];
0041956c              return sub_419579((&data_42fb6c)[eax_66], arg3, arg4);
0041919d          }
0041919d          
004191a6          if (eax > 0x4d)
004191a6          {
00419277              if (eax == 0x53)
00419277              {
00419350                  var_14_1 = arg4;
00419358                  data_430f28 = data_430f24;
00419360                  var_18_1 = arg3;
00419363                  var_1c_1 = 2;
00419365                  var_20_1 = *(uint32_t*)arg2;
00419277              }
00419277              else
00419277              {
0041927f                  int32_t* eax_35;
0041927f                  int32_t esi_5;
0041927f                  
0041927f                  if (eax == 0x55)
0041927f                  {
00419315                      data_430f28 = data_430f24;
0041931a                      eax_35 = arg2;
0041931d                      esi_5 = eax_35[6];
00419320                  label_419320:
00419320                      int32_t ecx_6 = eax_35[7];
00419325                      int32_t edi_1;
00419325                      
00419325                      if (ecx_6 >= esi_5)
00419325                      {
00419335                          edi_1 = (int64_t)ecx_6 / 7;
00419335                          
0041933f                          if ((int64_t)ecx_6 % 7 >= esi_5)
00419341                              edi_1 += 1;
00419325                      }
00419325                      else
00419327                          edi_1 = 0;
00419327                      
00419342                      var_14_1 = arg4;
00419345                      var_18_1 = arg3;
00419348                      var_1c_1 = 2;
0041934a                      var_20_1 = edi_1;
0041927f                  }
0041927f                  else
0041927f                  {
00419287                      if (eax == 0x57)
00419287                      {
004192f7                          data_430f28 = data_430f24;
004192fc                          eax_35 = arg2;
004192ff                          int32_t ecx_5 = eax_35[6];
004192ff                          
00419304                          esi_5 = ecx_5 ? ecx_5 - 1 : 6;
00419304                          
00419304                          goto label_419320;
00419287                      }
00419287                      
0041928a                      if (eax == 0x58)
0041928a                      {
004192d6                          data_430f24 = 0;
00419510                          return sub_419658(*(uint32_t*)((char*)arg5 + 0xa8), arg2, arg3, 
00419510                              arg4, arg5);
0041928a                      }
0041928a                      
0041928d                      if (eax != 0x59)
00419578                          return eax - 0x59;
00419578                      
00419298                      var_14_1 = arg4;
0041929b                      data_430f28 = data_430f24;
004192a3                      var_18_1 = arg3;
004192a6                      int32_t ecx_4 = arg2[5];
004192a9                      var_1c_1 = 4;
004192c5                      var_20_1 =
004192c5                          ((int64_t)ecx_4 / 0x64 + 0x13) * 0x64 + (int64_t)ecx_4 % 0x64;
0041927f                  }
00419277              }
004191a6          }
004191a6          else if (eax == 0x4d)
004191ac          {
0041925a              var_14_1 = arg4;
00419262              data_430f28 = data_430f24;
0041926a              var_18_1 = arg3;
0041926d              var_1c_1 = 2;
0041926f              var_20_1 = arg2[1];
004191ac          }
004191ac          else
004191ac          {
004191b5              if (eax == 0x25)
004191b5              {
0041924b                  **(uint8_t**)arg3 = 0x25;
0041924e                  *(uint32_t*)arg3 += 1;
00419250                  result = arg4;
00419253                  *(uint32_t*)result -= 1;
00419578                  return result;
004191b5              }
004191b5              
004191be              if (eax == 0x41)
0041956c                  return sub_419579(*(uint32_t*)((char*)arg5 + (arg2[6] << 2) + 0x1c), 
0041956c                      arg3, arg4);
0041956c              
004191c1              if (eax == 0x42)
0041956c                  return sub_419579(*(uint32_t*)((char*)arg5 + (arg2[4] << 2) + 0x68), 
0041956c                      arg3, arg4);
0041956c              
004191c6              if (eax == 0x48)
004191c6              {
004191f9                  var_14_1 = arg4;
00419201                  data_430f28 = data_430f24;
00419209                  var_18_1 = arg3;
0041920c                  var_1c_1 = 2;
0041920e                  var_20_1 = arg2[2];
004191c6              }
004191c6              else
004191c6              {
004191c9                  if (eax != 0x49)
00419578                      return eax - 0x49;
00419578                  
004191d6                  data_430f28 = data_430f24;
004191e3                  int32_t edx_2 = (int64_t)arg2[2] % 0xc;
004191e3                  
004191e7                  if (!edx_2)
004191ea                      edx_2 = 0xc;
004191ea                  
004191eb                  var_14_1 = arg4;
004191ee                  var_18_1 = arg3;
004191f1                  var_1c_1 = 2;
004191f3                  var_20_1 = edx_2;
004191c6              }
004191ac          }
00419197      }
00419197      else if (eax > 0x6d)
0041936f      {
0041948c          if (eax == 0x70)
0041948c          {
0041955c              char* var_1c_2;
0041955c              
0041955c              if (arg2[2] > 0xb)
00419566                  var_1c_2 = *(uint32_t*)((char*)arg5 + 0x9c);
0041955c              else
0041955e                  var_1c_2 = *(uint32_t*)((char*)arg5 + 0x98);
0041955e              
0041956c              return sub_419579(var_1c_2, arg3, arg4);
0041948c          }
0041948c          
00419495          if (eax == 0x77)
00419495          {
0041952f              var_14_1 = arg4;
00419537              data_430f28 = data_430f24;
0041953f              var_18_1 = arg3;
00419542              var_1c_1 = 1;
00419544              var_20_1 = arg2[6];
00419495          }
00419495          else
00419495          {
0041949c              if (eax == 0x78)
0041949c              {
004194f4                  char* var_24_1;
004194f4                  int32_t* var_20_2;
004194f4                  void* var_1c_3;
004194f4                  int32_t* var_18_3;
004194f4                  void* var_14_3;
004194f4                  
004194f4                  if (!data_430f24)
004194f4                  {
0041951d                      var_14_3 = arg5;
0041951e                      var_18_3 = arg4;
00419521                      var_1c_3 = arg3;
00419524                      var_20_2 = arg2;
00419527                      var_24_1 = *(uint32_t*)((char*)arg5 + 0xa0);
004194f4                  }
004194f4                  else
004194f4                  {
004194f9                      data_430f24 = 0;
00419500                      var_14_3 = arg5;
00419501                      var_18_3 = arg4;
00419504                      var_1c_3 = arg3;
00419507                      var_20_2 = arg2;
0041950a                      var_24_1 = *(uint32_t*)((char*)arg5 + 0xa4);
004194f4                  }
004194f4                  
00419510                  return sub_419658(var_24_1, var_20_2, var_1c_3, var_18_3, var_14_3);
0041949c              }
0041949c              
0041949f              if (eax != 0x79)
0041949f              {
004194a2                  if (eax != 0x7a)
00419578                      return eax - 0x7a;
00419578                  
004194a2                  goto label_4194a8;
0041949f              }
0041949f              
004194cf              var_14_1 = arg4;
004194d2              data_430f28 = data_430f24;
004194da              var_18_1 = arg3;
004194e0              var_1c_1 = 2;
004191f3              var_20_1 = (int64_t)arg2[5] % 0x64;
00419495          }
0041936f      }
0041936f      else if (eax == 0x6d)
00419375      {
00419471          var_14_1 = arg4;
00419474          data_430f28 = data_430f24;
0041947c          var_18_1 = arg3;
00419482          var_1c_1 = 2;
004193b3          var_20_1 = arg2[4] + 1;
00419375      }
00419375      else
00419375      {
0041937e          if (eax == 0x61)
0041956c              return sub_419579(*(uint32_t*)((char*)arg5 + (arg2[6] << 2)), arg3, arg4);
0041956c          
00419385          if (eax == 0x62)
0041956c              return sub_419579(*(uint32_t*)((char*)arg5 + (arg2[4] << 2) + 0x38), arg3, 
0041956c                  arg4);
0041956c          
0041938c          if (eax == 0x63)
0041938c          {
004193dd              char* var_24_2;
004193dd              int32_t* var_20_3;
004193dd              void* var_1c_4;
004193dd              int32_t* var_18_4;
004193dd              void* var_14_4;
004193dd              void* ebx_1;
004193dd              int32_t* esi_6;
004193dd              void* edi_2;
004193dd              
004193dd              if (!data_430f24)
004193dd              {
004193fd                  ebx_1 = arg5;
00419400                  esi_6 = arg4;
00419403                  edi_2 = arg3;
00419406                  var_14_4 = ebx_1;
00419407                  var_18_4 = esi_6;
00419408                  var_1c_4 = edi_2;
00419409                  var_20_3 = arg2;
0041940c                  var_24_2 = *(uint32_t*)((char*)ebx_1 + 0xa0);
004193dd              }
004193dd              else
004193dd              {
004193df                  ebx_1 = arg5;
004193e2                  esi_6 = arg4;
004193e5                  edi_2 = arg3;
004193e8                  data_430f24 = 0;
004193ef                  var_14_4 = ebx_1;
004193f0                  var_18_4 = esi_6;
004193f1                  var_1c_4 = edi_2;
004193f2                  var_20_3 = arg2;
004193f5                  var_24_2 = *(uint32_t*)((char*)ebx_1 + 0xa4);
004193dd              }
004193dd              
00419412              result = sub_419658(var_24_2, var_20_3, var_1c_4, var_18_4, var_14_4);
00419412              
0041941d              if (!*(uint32_t*)esi_6)
00419578                  return result;
00419578              
0041942b              **(uint8_t**)edi_2 = 0x20;
0041942e              *(uint32_t*)edi_2 += 1;
00419430              *(uint32_t*)esi_6 -= 1;
00419510              return sub_419658(*(uint32_t*)((char*)ebx_1 + 0xa8), arg2, edi_2, esi_6, 
00419510                  ebx_1);
0041938c          }
0041938c          
0041938f          if (eax == 0x64)
0041938f          {
004193b9              var_14_1 = arg4;
004193c1              data_430f28 = data_430f24;
004193c9              var_18_1 = arg3;
004193cc              var_1c_1 = 2;
004193ce              var_20_1 = arg2[3];
0041938f          }
0041938f          else
0041938f          {
00419394              if (eax != 0x6a)
00419578                  return eax - 0x6a;
00419578              
0041939f              var_14_1 = arg4;
004193a2              data_430f28 = data_430f24;
004193aa              var_18_1 = arg3;
004193b0              var_1c_1 = 3;
004193b3              var_20_1 = arg2[7] + 1;
0041938f          }
00419375      }
004192c6      return sub_4195a0(var_20_1, var_1c_1, var_18_1, var_14_1);
0041918a  }


00419579    void sub_419579(char* arg1, int32_t* arg2, int32_t* arg3)

00419579  {
00419582      if (!*(uint32_t*)arg3)
00419582          return;
00419582      
00419588      char* esi_1 = arg1;
0041959b      int32_t i;
0041959b      
0041959b      do
0041959b      {
0041958c          char edx = *(uint8_t*)esi_1;
0041958c          
00419590          if (!edx)
00419590              break;
00419590          
00419594          **(uint8_t**)arg2 = edx;
00419596          *(uint32_t*)arg2 += 1;
00419598          esi_1 = &esi_1[1];
00419599          i = *(uint32_t*)arg3;
00419599          *(uint32_t*)arg3 -= 1;
0041959b      } while (i != 1);
00419579  }


004195a0    char* sub_4195a0(int32_t arg1, int32_t arg2, void** arg3, void** arg4)

004195a0  {
004195a3      int32_t ecx;
004195a3      int32_t var_8 = ecx;
004195a4      char* result = nullptr;
004195ad      char* result_1 = nullptr;
004195ad      
004195b0      if (data_430f28)
004195bb          return sub_41960f(arg1, arg3, arg4);
004195bb      
004195cd      if (arg2 >= *(uint32_t*)arg4)
0041960a          *(uint32_t*)arg4 = nullptr;
004195cd      else
004195cd      {
004195cf          int32_t i = arg2 - 1;
004195cf          
004195d9          while (i != 0xffffffff)
004195d9          {
004195ea              *(uint8_t*)(*(uint32_t*)arg3 + i) = (char)((int64_t)arg1 % 0xa) + 0x30;
004195f3              result_1 = &result_1[1];
004195f6              i -= 1;
004195fa              arg1 = (int64_t)arg1 / 0xa;
004195d9          }
004195d9          
00419600          result = result_1;
00419603          *(uint32_t*)arg3 += result;
00419605          *(uint32_t*)arg4 -= result;
004195cd      }
004195cd      
0041960e      return result;
004195a0  }


0041960f    char* sub_41960f(int32_t arg1, int32_t* arg2, int32_t* arg3)

0041960f  {
00419612      int32_t ebx;
00419612      int32_t var_8 = ebx;
0041961b      char* ecx = *(uint32_t*)arg2;
0041961b      
00419620      while (*(uint32_t*)arg3 > 1)
00419620      {
00419631          *(uint8_t*)ecx = (char)((int64_t)arg1 % 0xa) + 0x30;
00419633          ecx = &ecx[1];
00419635          int32_t temp0_1 = (int64_t)arg1 / 0xa;
00419637          *(uint32_t*)arg3 -= 1;
0041963b          arg1 = temp0_1;
0041963b          
0041963e          if (temp0_1 <= 0)
0041963e              break;
00419620      }
00419620      
00419640      char* result = *(uint32_t*)arg2;
00419642      *(uint32_t*)arg2 = ecx;
00419644      void* ecx_1 = ecx - 1;
00419644      
00419651      do
00419651      {
00419645          (uint8_t)ebx = *(uint8_t*)result;
00419647          char edx = *(uint8_t*)ecx_1;
00419649          *(uint8_t*)ecx_1 = (uint8_t)ebx;
0041964b          ecx_1 -= 1;
0041964c          *(uint8_t*)result = edx;
0041964e          result = &result[1];
00419651      } while (result < ecx_1);
00419651      
00419657      return result;
0041960f  }


00419658    void sub_419658(char* arg1, int32_t* arg2, void* arg3, int32_t* arg4, void* arg5)

00419658  {
0041965b      int32_t ecx;
0041965b      int32_t var_8 = ecx;
0041965d      char* ebx = arg1;
0041965d      
00419665      if (!*(uint8_t*)ebx)
00419665          return;
00419665      
0041966b      int32_t* edi_1 = arg4;
0041966e      void* esi_1 = arg3;
0041966e      
00419702      do
00419702      {
00419671          char* ecx_1 = nullptr;
00419671          
00419675          if (!*(uint32_t*)edi_1)
00419675              break;
00419675          
0041967b          data_430f28 = 0;
00419681          char* eax;
00419681          (uint8_t)eax = *(uint8_t*)ebx;
00419683          *(uint8_t*)((char*)arg1)[3] = (uint8_t)eax;
0041968c          arg3 = &ebx[1];
0041969d          char* edx;
0041969d          void* eax_2;
0041969d          
0041969d          do
0041969d          {
0041968f              eax_2 = arg3;
00419692              (uint8_t)edx = *(uint8_t*)((char*)arg1)[3];
00419695              ecx_1 = &ecx_1[1];
00419696              arg3 += 1;
00419699              (uint8_t)eax_2 = *(uint8_t*)eax_2;
0041969d          } while ((uint8_t)eax_2 == (uint8_t)edx);
0041969f          arg3 -= 1;
004196a2          eax = (int32_t)(uint8_t)edx;
004196a2          
004196a8          if (eax > 0x64)
004196a8          {
00419825              if (eax == 0x68)
00419825              {
00419936                  if (ecx_1 == 1)
00419936                  {
00419940                      data_430f28 = 1;
0041994a                  label_41994a:
0041994a                      (uint8_t)arg4 = 0x49;
00419959                      eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                      ebx = arg3;
00419936                  }
00419936                  else
00419936                  {
00419939                      if (ecx_1 == 2)
00419939                          goto label_41994a;
00419939                      
004196e7                  label_4196e7:
004196e7                      
004196e7                      if (*(uint8_t*)(
004196e7                          &(**(uint528_t**)&data_42ce70)[(uint32_t)(uint8_t)edx] + 1) & 0x80)
004196e7                      {
004196eb                          ebx = &ebx[1];
004196ee                          **(uint8_t**)esi_1 = (uint8_t)edx;
004196f0                          *(uint32_t*)esi_1 += 1;
004196f2                          *(uint32_t*)edi_1 -= 1;
004196e7                      }
004196e7                      
004196f6                      wchar16 (* ecx_2)[0x21];
004196f6                      (uint8_t)ecx_2 = *(uint8_t*)ebx;
004196f8                      **(uint8_t**)esi_1 = (uint8_t)ecx_2;
004196fa                      *(uint32_t*)esi_1 += 1;
004196fc                      ebx = &ebx[1];
004196fd                      *(uint32_t*)edi_1 -= 1;
00419936                  }
00419825              }
00419825              else if (eax == 0x6d)
0041982e              {
00419919                  if (ecx_1 == 1)
00419923                      data_430f28 = 1;
00419919                  else if (ecx_1 != 2)
0041991c                      goto label_4196e7;
0041991c                  
0041992d                  (uint8_t)arg4 = 0x4d;
00419959                  eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                  ebx = arg3;
0041982e              }
0041982e              else if (eax == 0x73)
00419837              {
004198fc                  if (ecx_1 == 1)
00419906                      data_430f28 = 1;
004198fc                  else if (ecx_1 != 2)
004198ff                      goto label_4196e7;
004198ff                  
00419910                  (uint8_t)arg4 = 0x53;
00419959                  eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                  ebx = arg3;
00419837              }
00419837              else if (eax == 0x74)
0041983e              {
00419873                  if (arg2[2] > 0xb)
0041987d                      eax = *(uint32_t*)((char*)arg5 + 0x9c);
00419873                  else
00419875                      eax = *(uint32_t*)((char*)arg5 + 0x98);
00419875                  
0041988b                  if (ecx_1 != 1 || *(uint32_t*)edi_1 <= 0)
0041988b                  {
004198c1                      while (true)
004198c1                      {
004198c1                          (uint8_t)ecx_1 = *(uint8_t*)eax;
004198c1                          
004198c5                          if (!(uint8_t)ecx_1)
004198c5                              break;
004198c5                          
004198ca                          if (*(uint32_t*)edi_1 <= 0)
004198ca                              break;
004198ca                          
004198e1                          if (*(uint8_t*)(
004198e1                              &(**(uint528_t**)&data_42ce70)[(uint32_t)(uint8_t)ecx_1] + 1)
004198e1                              & 0x80 && *(uint32_t*)edi_1 > 1)
004198e1                          {
004198e5                              **(uint8_t**)esi_1 = (uint8_t)ecx_1;
004198e7                              *(uint32_t*)esi_1 += 1;
004198e9                              eax = &eax[1];
004198ea                              *(uint32_t*)edi_1 -= 1;
004198e1                          }
004198e1                          
004198ee                          (uint8_t)edx = *(uint8_t*)eax;
004198f0                          **(uint8_t**)esi_1 = (uint8_t)edx;
004198f2                          *(uint32_t*)esi_1 += 1;
004198f4                          eax = &eax[1];
004198f5                          *(uint32_t*)edi_1 -= 1;
004198c1                      }
0041988b                  }
0041988b                  else
0041988b                  {
0041988d                      (uint8_t)ecx_1 = *(uint8_t*)eax;
0041988d                      
004198a4                      if (*(uint8_t*)(
004198a4                          &(**(uint528_t**)&data_42ce70)[(uint32_t)(uint8_t)ecx_1] + 1) & 0x80
004198a4                          && *(uint32_t*)edi_1 > 1)
004198a4                      {
004198a8                          **(uint8_t**)esi_1 = (uint8_t)ecx_1;
004198aa                          *(uint32_t*)esi_1 += 1;
004198ac                          eax = &eax[1];
004198ad                          *(uint32_t*)edi_1 -= 1;
004198a4                      }
004198a4                      
004198b1                      (uint8_t)eax = *(uint8_t*)eax;
004198b3                      **(uint8_t**)esi_1 = (uint8_t)eax;
004198b5                      *(uint32_t*)esi_1 += 1;
004198b7                      *(uint32_t*)edi_1 -= 1;
0041988b                  }
0041988b                  
004198b9                  ebx = arg3;
0041983e              }
0041983e              else
0041983e              {
00419843                  if (eax != 0x79)
00419843                      goto label_4196e7;
00419843                  
0041984d                  if (ecx_1 == 2)
0041984d                  {
00419860                      (uint8_t)arg4 = 0x79;
00419959                      eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                      ebx = arg3;
0041984d                  }
0041984d                  else
0041984d                  {
00419851                      if (ecx_1 != 4)
00419851                          goto label_4196e7;
00419851                      
00419857                      (uint8_t)arg4 = 0x59;
00419959                      eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                      ebx = arg3;
0041984d                  }
0041983e              }
004196a8          }
004196a8          else if (eax == 0x64)
004196ae          {
004197ee              if (ecx_1 == 1)
004197ee              {
0041980f                  data_430f28 = 1;
00419819              label_419819:
00419819                  (uint8_t)arg4 = 0x64;
00419959                  eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                  ebx = arg3;
004197ee              }
004197ee              else
004197ee              {
004197f1                  if (ecx_1 == 2)
004197f1                      goto label_419819;
004197f1                  
004197f4                  if (ecx_1 == 3)
004197f4                  {
00419806                      (uint8_t)arg4 = 0x61;
00419959                      eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                      ebx = arg3;
004197f4                  }
004197f4                  else
004197f4                  {
004197f7                      if (ecx_1 != 4)
004197f7                          goto label_4196e7;
004197f7                      
004197fd                      (uint8_t)arg4 = 0x41;
00419959                      eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                      ebx = arg3;
004197f4                  }
004197ee              }
004196ae          }
004196ae          else if (eax == 0x27)
004196b7          {
00419796              if (!((uint8_t)ecx_1 & 1))
004197e4                  ebx += ecx_1;
00419796              else
00419796              {
00419798                  ebx += ecx_1;
00419798                  
0041979a                  while (true)
0041979a                  {
0041979a                      (uint8_t)eax = *(uint8_t*)ebx;
0041979a                      
0041979e                      if (!(uint8_t)eax)
0041979e                          break;
0041979e                      
004197a7                      if (!*(uint32_t*)edi_1)
004197a7                          break;
004197a7                      
004197af                      if ((uint8_t)eax == 0x27)
004197af                      {
004197de                          ebx = &ebx[1];
004197df                          break;
004197af                      }
004197af                      
004197c6                      if (data_42ce70[((uint32_t)(uint8_t)eax << 1) + 1] & 0x80
004197c6                          && *(uint32_t*)edi_1 > 1)
004197c6                      {
004197ca                          **(uint8_t**)esi_1 = (uint8_t)eax;
004197cc                          *(uint32_t*)esi_1 += 1;
004197ce                          ebx = &ebx[1];
004197cf                          *(uint32_t*)edi_1 -= 1;
004197c6                      }
004197c6                      
004197d3                      uint32_t ecx_4;
004197d3                      (uint8_t)ecx_4 = *(uint8_t*)ebx;
004197d5                      **(uint8_t**)esi_1 = (uint8_t)ecx_4;
004197d7                      *(uint32_t*)esi_1 += 1;
004197d9                      ebx = &ebx[1];
004197da                      *(uint32_t*)edi_1 -= 1;
0041979a                  }
00419796              }
004196b7          }
004196b7          else if (eax == 0x41)
004196c0          {
00419763          label_419763:
00419763              int32_t eax_13;
00419763              int32_t edx_1;
00419763              eax_13 = sub_421ff0(eax, edx, ecx_1, ebx, "am/pm");
00419763              
0041976c              if (eax_13)
0041976c              {
00419782                  if (!sub_421ff0(eax_13, edx_1, "am/pm", ebx, "a/p"))
00419787                      arg3 = &ebx[3];
0041976c              }
0041976c              else
00419787                  arg3 = &ebx[5];
00419787              
0041978a              (uint8_t)arg4 = 0x70;
00419959              eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9              ebx = arg3;
004196c0          }
004196c0          else if (eax == 0x48)
004196c9          {
00419743              if (ecx_1 == 1)
0041974a                  data_430f28 = 1;
00419743              else if (ecx_1 != 2)
00419746                  goto label_4196e7;
00419746              
00419754              (uint8_t)arg4 = 0x48;
00419959              eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9              ebx = arg3;
004196c9          }
004196c9          else
004196c9          {
004196ce              if (eax != 0x4d)
004196ce              {
004196d3                  if (eax == 0x61)
004196d3                      goto label_419763;
004196d3                  
004196d3                  goto label_4196e7;
004196ce              }
004196ce              
00419710              if (ecx_1 == 1)
00419710              {
0041972d                  data_430f28 = 1;
00419737              label_419737:
00419737                  (uint8_t)arg4 = 0x6d;
00419959                  eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                  ebx = arg3;
00419710              }
00419710              else
00419710              {
00419713                  if (ecx_1 == 2)
00419713                      goto label_419737;
00419713                  
00419716                  if (ecx_1 == 3)
00419716                  {
00419724                      (uint8_t)arg4 = 0x62;
00419959                      eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                      ebx = arg3;
00419716                  }
00419716                  else
00419716                  {
00419719                      if (ecx_1 != 4)
00419719                          goto label_4196e7;
00419719                      
0041971b                      (uint8_t)arg4 = 0x42;
00419959                      eax = sub_41918a((uint8_t)arg4, arg2, esi_1, edi_1, arg5);
004198b9                      ebx = arg3;
00419716                  }
00419710              }
004196c9          }
00419702      } while (*(uint8_t*)ebx);
00419658  }


00419966    int32_t* sub_419966(int32_t* arg1)

00419966  {
0041996a      int32_t* esi = arg1;
0041996a      
00419970      if (*(uint32_t*)esi < 0)
00419972          return nullptr;
00419972      
00419979      sub_421a84();
0041997e      int32_t eax_1 = *(uint32_t*)esi;
0041998c      int32_t* result;
0041998c      
0041998c      if (eax_1 <= 0x3f480 || eax_1 >= 0x7ffc0b7f)
0041998c      {
004199e5          result = sub_419ac6(esi);
004199ee          bool cond:0_1 = !sub_421cf7(result);
004199f0          int32_t eax_9 = *(uint32_t*)result;
004199f0          
004199f3          if (!cond:0_1)
004199f5              eax_9 -= data_42fae8;
004199f5          
004199fb          int32_t* eax_10 = eax_9 - data_42fae0;
00419a04          arg1 = eax_10;
00419a0b          int32_t temp1_1 = (int64_t)eax_10 % 0x3c;
00419a0f          *(uint32_t*)result = temp1_1;
00419a0f          
00419a11          if (temp1_1 < 0)
00419a11          {
00419a15              *(uint32_t*)result = temp1_1 + 0x3c;
00419a17              arg1 -= 0x3c;
00419a11          }
00419a11          
00419a22          int32_t* eax_16 = (int64_t)arg1 / 0x3c + result[1];
00419a25          arg1 = eax_16;
00419a29          int32_t temp1_2 = (int64_t)eax_16 % 0x3c;
00419a2e          result[1] = temp1_2;
00419a2e          
00419a31          if (temp1_2 < 0)
00419a31          {
00419a36              result[1] = temp1_2 + 0x3c;
00419a39              arg1 -= 0x3c;
00419a31          }
00419a31          
00419a45          int32_t* eax_22 = (int64_t)arg1 / 0x3c + result[2];
00419a48          arg1 = eax_22;
00419a4c          int32_t temp1_3 = (int64_t)eax_22 % 0x18;
00419a50          result[2] = temp1_3;
00419a50          
00419a53          if (temp1_3 < 0)
00419a53          {
00419a57              result[2] = temp1_3 + 0x18;
00419a5a              arg1 -= 0x18;
00419a53          }
00419a53          
00419a64          int32_t temp0_6 = (int64_t)arg1 / 0x18;
00419a6a          arg1 = temp0_6;
00419a6a          
00419a6d          if (temp0_6 > 0)
00419a6d          {
00419a7a              result[6] = (int64_t)(result[6] + temp0_6) % 7;
00419a80              result[3] += arg1;
00419a86              result[7] += arg1;
00419a6d          }
00419a6d          else if (temp0_6 < 0)
00419a8e          {
00419a9d              result[6] = (int64_t)(result[6] + temp0_6 + 7) % 7;
00419aa3              result[3] += arg1;
00419aa6              int32_t eax_37 = result[3];
00419aa6              
00419aab              if (eax_37 > 0)
00419a86                  result[7] += arg1;
00419aab              else
00419aab              {
00419ab0                  result[5] -= 1;
00419ab3                  result[3] = eax_37 + 0x1f;
00419ab6                  result[7] = 0x16c;
00419abd                  result[4] = 0xb;
00419aab              }
00419a8e          }
0041998c      }
0041998c      else
0041998c      {
00419994          arg1 = eax_1 - data_42fae0;
004199a8          result = sub_419ac6(&arg1);
004199a8          
004199aa          if (data_42fae4 && sub_421cf7(result))
004199aa          {
004199c4              arg1 -= data_42fae8;
004199d0              result = sub_419ac6(&arg1);
004199d3              result[8] = 1;
004199aa          }
0041998c      }
0041998c      
00419a89      return result;
00419966  }


00419ac6    int32_t* sub_419ac6(int32_t* arg1)

00419ac6  {
00419acc      int32_t esi = 0;
00419ace      int32_t ecx = *(uint32_t*)arg1;
00419ace      
00419ad3      if (ecx < 0)
00419ad5          return nullptr;
00419ad5      
00419ae6      int32_t temp0_1 = (int64_t)ecx / 0x7861f80;
00419af0      int32_t ecx_1 = ecx + temp0_1 * 0xf879e080;
00419af9      void* eax_4 = (temp0_1 << 2) + 0x46;
00419af9      
00419b00      if (ecx_1 >= 0x1e13380)
00419b00      {
00419b02          ecx_1 -= 0x1e13380;
00419b04          eax_4 += 1;
00419b04          
00419b07          if (ecx_1 >= 0x1e13380)
00419b07          {
00419b09              ecx_1 -= 0x1e13380;
00419b10              eax_4 += 1;
00419b10              
00419b13              if (ecx_1 < 0x1e28500)
00419b1c                  esi = 1;
00419b13              else
00419b13              {
00419b15                  eax_4 += 1;
00419b16                  ecx_1 -= 0x1e28500;
00419b13              }
00419b07          }
00419b00      }
00419b00      
00419b1d      data_430874 = eax_4;
00419b2c      int32_t i = (int64_t)ecx_1 / 0x15180;
00419b30      data_43087c = i;
00419b3b      int32_t ecx_2 = ecx_1 + i * 0xfffeae80;
00419b3f      void* esi_1 = &data_42fba0;
00419b3f      
00419b44      if (!esi)
00419b46          esi_1 = &data_42fbd4;
00419b46      
00419b4d      int32_t* edi_1 = (char*)esi_1 + 4;
00419b50      int32_t edx_7 = 1;
00419b50      
00419b53      while (*(uint32_t*)edi_1 < i)
00419b53      {
00419b55          edx_7 += 1;
00419b56          edi_1 = &edi_1[1];
00419b53      }
00419b53      
00419b5e      data_430870 = edx_7 - 1;
00419b6a      data_43086c = i - *(uint32_t*)((char*)esi_1 + ((edx_7 - 1) << 2));
00419b82      data_430878 = (int64_t)((int64_t)*(uint32_t*)arg1 / 0x15180 + 4) % 7;
00419b89      int32_t temp0_3 = (int64_t)ecx_2 / 0xe10;
00419b8e      data_430868 = temp0_3;
00419b99      int32_t ecx_3 = ecx_2 + temp0_3 * 0xfffff1f0;
00419b9e      int32_t temp0_4 = (int64_t)ecx_3 / 0x3c;
00419ba0      data_430864 = temp0_4;
00419baa      data_430880 = 0;
00419bb1      data_430860 = ecx_3 - temp0_4 * 0x3c;
00419bb7      return &data_430860;
00419ac6  }


00419bbf    int32_t sub_419bbf(int32_t* arg1)

00419bbf  {
00419bcc      SYSTEMTIME systemTime_1;
00419bcc      GetLocalTime(&systemTime_1);
00419bd6      SYSTEMTIME systemTime;
00419bd6      GetSystemTime(&systemTime);
00419c1b      int32_t eax_1;
00419c1b      
00419c1b      if (systemTime.wMinute != data_43089a || systemTime.wHour != data_430898
00419c1b          || systemTime.wDay != data_430896 || systemTime.wMonth != data_430892
00419c1b          || systemTime.wYear != data_430890)
00419c1b      {
00419c2b          TIME_ZONE_INFORMATION timeZoneInformation;
00419c2b          uint32_t eax_2 = GetTimeZoneInformation(&timeZoneInformation);
00419c2b          
00419c34          if (eax_2 == 0xffffffff)
00419c51              eax_1 = 0xffffffff;
00419c34          else if (eax_2 != 2 || !timeZoneInformation.DaylightDate.wMonth
00419c34                  || !timeZoneInformation.DaylightBias)
00419c4d              eax_1 = 0;
00419c46          else
00419c4a              eax_1 = 1;
00419c4a          
00419c5e          data_430890 = systemTime.wYear;
00419c5e          (&data_430890)[1] = systemTime.wMonth;
00419c5e          void* edi_1 = &data_430894;
00419c5e          var_20;
00419c5e          void* esi_1 = &var_20;
00419c5f          *(uint32_t*)edi_1 = *(uint32_t*)esi_1;
00419c5f          void* edi_2 = (char*)edi_1 + 4;
00419c5f          void* esi_2 = (char*)esi_1 + 4;
00419c60          *(uint32_t*)edi_2 = *(uint32_t*)esi_2;
00419c61          *(uint32_t*)((char*)edi_2 + 4) = *(uint32_t*)((char*)esi_2 + 4);
00419c63          data_430888 = eax_1;
00419c1b      }
00419c1b      else
00419c1d          eax_1 = data_430888;
00419c1d      
00419c88      int32_t result = sub_42207c((uint32_t)systemTime_1.wYear, 
00419c88          (uint32_t)systemTime_1.wMonth, (uint32_t)systemTime_1.wDay, 
00419c88          (uint32_t)systemTime_1.wHour, (uint32_t)systemTime_1.wMinute, 
00419c88          (uint32_t)systemTime_1.wSecond, eax_1);
00419c88      
00419c95      if (arg1)
00419c97          *(uint32_t*)arg1 = result;
00419c97      
00419c9a      return result;
00419bbf  }


00419c9b    int32_t* sub_419c9b(int32_t* arg1)

00419c9b  {
00419ca8      return sub_419ca9(arg1, 1);
00419c9b  }


00419ca9    int32_t* sub_419ca9(int32_t* arg1, int32_t arg2)

00419ca9  {
00419cae      int32_t* edi = arg1;
00419cb1      int32_t ecx = edi[5];
00419cb1      
00419cc3      if (ecx >= 0x45 && ecx <= 0x8b)
00419cc3      {
00419cc9          int32_t esi_1 = edi[4];
00419cc9          
00419cd3          if (esi_1 < 0 || esi_1 > 0xb)
00419cd3          {
00419cdf              ecx += (int64_t)esi_1 / 0xc;
00419ce6              int32_t temp1_1 = (int64_t)esi_1 % 0xc;
00419cea              edi[4] = temp1_1;
00419cea              
00419ced              if (temp1_1 < 0)
00419ced              {
00419cf2                  ecx -= 1;
00419cf3                  edi[4] = temp1_1 + 0xc;
00419ced              }
00419ced              
00419d05              if (ecx >= 0x45 && ecx <= 0x8b)
00419d05                  goto label_419d0b;
00419cd3          }
00419cd3          else
00419cd3          {
00419d0b          label_419d0b:
00419d0b              int32_t edx_5 = edi[4];
00419d11              int32_t eax_6 = *(uint32_t*)((edx_5 << 2) + &data_42fbd4);
00419d11              
00419d1d              if (!((uint8_t)ecx & 3) && edx_5 > 1)
00419d1f                  eax_6 += 1;
00419d1f              
00419d35              int32_t ecx_2 = edi[3];
00419d3a              int32_t esi_2 = ecx * 0x16d + eax_6 + ((ecx - 1) >> 2) - 0x63df + ecx_2;
00419d3a              
00419d3d              if (ecx * 0x16d + eax_6 + ((ecx - 1) >> 2) - 0x63df < 0)
00419d3d              {
00419d53                  if (ecx_2 >= 0 || esi_2 < 0)
00419d53                  {
00419d5c                  label_419d5c:
00419d5c                      int32_t ecx_4 = esi_2 * 0x18;
00419d61                      int32_t eax_12;
00419d61                      
00419d61                      if (!esi_2)
00419d74                          eax_12 = 0;
00419d61                      else
00419d61                      {
00419d6d                          int32_t edx_9;
00419d6d                          (uint8_t)edx_9 = (int64_t)ecx_4 / esi_2 != 0x18;
00419d70                          eax_12 = edx_9;
00419d61                      }
00419d61                      
00419d78                      if (!eax_12)
00419d78                      {
00419d7e                          int32_t eax_13 = edi[2];
00419d83                          int32_t esi_3 = eax_13 + ecx_4;
00419d83                          
00419d86                          if (ecx_4 < 0)
00419d86                          {
00419d9c                              if (eax_13 >= 0 || esi_3 < 0)
00419d9c                              {
00419da4                              label_419da4:
00419da4                                  int32_t ecx_6 = esi_3 * 0x3c;
00419da9                                  int32_t eax_17;
00419da9                                  
00419da9                                  if (!esi_3)
00419dbc                                      eax_17 = 0;
00419da9                                  else
00419da9                                  {
00419db5                                      int32_t edx_11;
00419db5                                      (uint8_t)edx_11 = (int64_t)ecx_6 / esi_3 != 0x3c;
00419db8                                      eax_17 = edx_11;
00419da9                                  }
00419da9                                  
00419dc0                                  if (!eax_17)
00419dc0                                  {
00419dc6                                      int32_t eax_18 = edi[1];
00419dcb                                      int32_t esi_4 = eax_18 + ecx_6;
00419dcb                                      
00419dce                                      if (ecx_6 < 0)
00419dce                                      {
00419de4                                          if (eax_18 >= 0 || esi_4 < 0)
00419de4                                          {
00419dec                                          label_419dec:
00419dec                                              int32_t ecx_8 = esi_4 * 0x3c;
00419df1                                              int32_t eax_22;
00419df1                                              
00419df1                                              if (!esi_4)
00419e04                                                  eax_22 = 0;
00419df1                                              else
00419df1                                              {
00419dfd                                                  int32_t edx_13;
00419dfd                                                  (uint8_t)edx_13 =
00419dfd                                                      (int64_t)ecx_8 / esi_4 != 0x3c;
00419e00                                                  eax_22 = edx_13;
00419df1                                              }
00419df1                                              
00419e08                                              if (!eax_22)
00419e08                                              {
00419e0a                                                  void* eax_23 = *(uint32_t*)edi;
00419e0e                                                  int32_t* edx_14 = (char*)eax_23 + ecx_8;
00419e11                                                  arg1 = edx_14;
00419e11                                                  
00419e14                                                  if (ecx_8 < 0)
00419e14                                                  {
00419e26                                                      if (eax_23 >= 0 || edx_14 < 0)
00419e26                                                      {
00419e28                                                      label_419e28:
00419e2c                                                          int32_t* eax_25;
00419e2c                                                          
00419e2c                                                          if (!arg2)
00419e2c                                                          {
00419e70                                                              eax_25 = sub_419ac6(&arg1);
00419e70                                                              
00419e78                                                              if (eax_25)
00419e78                                                              {
00419e7e                                                              label_419e7e:
00419e7e                                                                  int32_t* result = arg1;
00419e82                                                                  __builtin_memcpy(edi, eax_25, 0x24);
00419e8c                                                                  return result;
00419e78                                                              }
00419e2c                                                          }
00419e2c                                                          else
00419e2c                                                          {
00419e2e                                                              sub_421a84();
00419e38                                                              arg1 += data_42fae0;
00419e3f                                                              eax_25 = sub_419966(&arg1);
00419e3f                                                              
00419e47                                                              if (eax_25)
00419e47                                                              {
00419e49                                                                  int32_t ecx_10 = edi[8];
00419e49                                                                  
00419e4e                                                                  if (ecx_10 > 0)
00419e4e                                                                  {
00419e5d                                                                      arg1 += data_42fae8;
00419e64                                                                      eax_25 = sub_419966(&arg1);
00419e4e                                                                  }
00419e4e                                                                  else if (ecx_10 < 0 && eax_25[8] > 0)
00419e56                                                                  {
00419e5d                                                                      arg1 += data_42fae8;
00419e64                                                                      eax_25 = sub_419966(&arg1);
00419e56                                                                  }
00419e56                                                                  
00419e4e                                                                  goto label_419e7e;
00419e47                                                              }
00419e2c                                                          }
00419e26                                                      }
00419e14                                                  }
00419e14                                                  else if (eax_23 < 0 || edx_14 >= 0)
00419e18                                                      goto label_419e28;
00419e08                                              }
00419de4                                          }
00419dce                                      }
00419dce                                      else if (eax_18 < 0 || esi_4 >= 0)
00419dd2                                          goto label_419dec;
00419dc0                                  }
00419d9c                              }
00419d86                          }
00419d86                          else if (eax_13 < 0 || esi_3 >= 0)
00419d8a                              goto label_419da4;
00419d78                      }
00419d53                  }
00419d3d              }
00419d3d              else if (ecx_2 < 0 || esi_2 >= 0)
00419d41                  goto label_419d5c;
00419cd3          }
00419cc3      }
00419cc3      
00419e86      return 0xffffffff;
00419ca9  }


00419e8d    long double sub_419e8d(int32_t arg1, int32_t arg2) __pure

00419e8d  {
00419e9d      return (long double)(arg1 - arg2);
00419e8d  }


00419e9e    char* sub_419e9e(int32_t arg1, void* arg2)

00419e9e  {
00419eab      int32_t ebx = 0;
00419eab      
00419eba      if (arg1 >= 0 && arg1 <= 5)
00419eba      {
00419ec2          if (arg1)
00419ec2          {
00419ec7              if (!arg2)
00419edc                  return (&data_42d334)[arg1 * 3];
00419edc              
0041a09b              return sub_41a0a4(arg1, arg2);
00419ec2          }
00419ec2          
00419ee8          void* edi_1 = arg2;
00419eeb          int32_t var_8_1 = 1;
00419ef4          arg1 = 0;
00419ef4          
00419ef7          if (!edi_1)
0041a096              return sub_41a1bf();
0041a096          
00419f14          char var_8c[0x84];
00419f14          bool cond:6_1;
00419f14          
00419f14          if (*(uint8_t*)edi_1 != 0x4c || *(uint8_t*)((char*)edi_1 + 1) != 0x43
00419f14              || *(uint8_t*)((char*)edi_1 + 2) != 0x5f)
00419f14          {
0041a00d              int32_t var_9c_5 = 0;
0041a01d              char* esi_1 = sub_41a278(edi_1, &var_8c, nullptr, nullptr);
0041a01d              
0041a024              if (!esi_1)
0041a09d                  return esi_1;
0041a09d              
0041a06a              for (int32_t* i = &data_42d334; i <= &data_42d370; )
0041a06a              {
0041a02f                  if (i != &data_42d334)
0041a02f                  {
0041a040                      bool cond:2_1 = !sub_41ebe0(&var_8c, *(uint32_t*)i);
0041a043                      int32_t eax_13;
0041a043                      
0041a043                      if (!cond:2_1)
0041a04d                          eax_13 = sub_41a0a4(ebx, &var_8c);
0041a04d                      
0041a056                      if (cond:2_1 || eax_13)
0041a05d                          arg1 += 1;
0041a056                      else
0041a058                          var_8_1 &= eax_13;
0041a02f                  }
0041a02f                  
0041a060                  i = &i[3];
0041a063                  ebx += 1;
0041a06a              }
0041a06a              
0041a071              if (var_8_1)
0041a071              {
0041a073                  char* eax_14;
0041a073                  void** ecx_8;
0041a073                  eax_14 = sub_41a1bf();
0041a078                  int32_t var_9c_8 = data_42d334;
0041a080                  sub_41784c(ecx_8);
0041a086                  data_42d334 = 0;
0041a09d                  return eax_14;
0041a071              }
0041a071              
0041a08e              cond:6_1 = arg1;
0041a000          label_41a000:
0041a000              
0041a000              if (cond:6_1)
0041a096                  return sub_41a1bf();
0041a096              
0041a006              return nullptr;
00419f14          }
00419f14          
00419f25          void* esi_2 = sub_418c20(edi_1, "=;");
00419f25          
00419f2b          if (esi_2)
00419f2b          {
00419f33              while (true)
00419f33              {
00419f33                  int32_t i_2 = (char*)esi_2 - edi_1;
00419f35                  int32_t i_1 = i_2;
00419f35                  
00419f38                  if (esi_2 == edi_1)
00419ff5                      return nullptr;
00419ff5                  
00419f41                  if (*(uint8_t*)esi_2 == 0x3b)
00419ff5                      return nullptr;
00419ff5                  
00419f47                  arg2 = 1;
00419f4e                  char const (** ebx_1)[0xb] = &data_42d33c;
00419f4e                  
00419f5c                  while (sub_422d40(*(uint32_t*)ebx_1, edi_1, i_2)
00419f5c                      || i_1 != sub_41e7d0(*(uint32_t*)ebx_1))
00419f5c                  {
00419f75                      arg2 += 1;
00419f78                      ebx_1 = &ebx_1[3];
00419f78                      
00419f81                      if (ebx_1 > &data_42d36c)
00419f81                          break;
00419f81                      
00419f55                      i_2 = i_1;
00419f5c                  }
00419f5c                  
00419f8a                  void* eax_7 = sub_417eb0((char*)esi_2 + 1, &data_42c214);
00419f8a                  
00419f9a                  if (!eax_7 && *(uint8_t*)((char*)esi_2 + 1) != 0x3b)
00419ff5                      return nullptr;
00419ff5                  
00419fa0                  if (arg2 <= 5)
00419fa0                  {
00419fab                      sub_417ef0(&var_8c, (char*)esi_2 + 1, eax_7);
00419fb0                      *(uint8_t*)(&var_8c + eax_7) = 0;
00419fb0                      
00419fcc                      if (sub_41a0a4(arg2, &var_8c))
00419fce                          arg1 += 1;
00419fa0                  }
00419fa0                  
00419fd1                  void* edi_3 = (char*)eax_7 + (char*)esi_2 + 1;
00419fd1                  
00419fd6                  if (!*(uint8_t*)edi_3)
00419fd6                      break;
00419fd6                  
00419fd8                  edi_1 = (char*)edi_3 + 1;
00419fd8                  
00419fdc                  if (!*(uint8_t*)edi_1)
00419fdc                      break;
00419fdc                  
00419fe9                  esi_2 = sub_418c20(edi_1, "=;");
00419fe9                  
00419fef                  if (!esi_2)
00419ff5                      return nullptr;
00419f33              }
00419f33              
00419ffc              cond:6_1 = arg1;
00419ffc              goto label_41a000;
00419f2b          }
00419eba      }
00419eba      
00419ff5      return nullptr;
00419e9e  }


0041a0a4    int32_t sub_41a0a4(int32_t arg1, void* arg2)

0041a0a4  {
0041a0b6      int32_t var_b8 = arg1;
0041a0d0      char var_a8[0x84];
0041a0d0      int32_t var_1c;
0041a0d0      int16_t var_14;
0041a0d0      
0041a0d0      if (sub_41a278(arg2, &var_a8, &var_14, &var_1c))
0041a0d0      {
0041a0e4          void* eax_3 = sub_41dbac(sub_41e7d0(&var_a8) + 1);
0041a0e4          
0041a0f0          if (eax_3)
0041a0f0          {
0041a105              int32_t eax_4 = (&data_42d334)[arg1 * 3];
0041a10e              int32_t eax_5 = *(uint32_t*)((arg1 << 2) + &data_430a0c);
0041a125              char var_24;
0041a125              sub_41b4f0(&var_24, arg1 * 6 + &data_430b20, 6);
0041a12a              int32_t eax_8 = data_430a24;
0041a141              (&data_42d334)[arg1 * 3] = sub_41b8c0(eax_3, &var_a8);
0041a14d              *(uint32_t*)((arg1 << 2) + &data_430a0c) = (uint32_t)var_14;
0041a156              sub_41b4f0(arg1 * 6 + &data_430b20, &var_14, 6);
0041a15b              int32_t eax_11 = var_1c;
0041a15b              
0041a164              if (arg1 == 2)
0041a166                  data_430a24 = eax_11;
0041a166              
0041a16e              if (arg1 == 1)
0041a170                  data_430a28 = eax_11;
0041a170              
0041a175              int32_t eax_12;
0041a175              void** ecx_2;
0041a175              eax_12 = (&data_42d338)[arg1 * 3]();
0041a175              
0041a17d              if (!eax_12)
0041a17d              {
0041a1a9                  if (eax_4 != &data_42d224)
0041a1a9                  {
0041a1ab                      int32_t var_b8_3 = eax_4;
0041a1ae                      sub_41784c(ecx_2);
0041a1a9                  }
0041a1a9                  
0041a1b4                  return (&data_42d334)[arg1 * 3];
0041a17d              }
0041a17d              
0041a182              void* var_b8_2 = eax_3;
0041a185              (&data_42d334)[arg1 * 3] = eax_4;
0041a18b              sub_41784c(ecx_2);
0041a194              *(uint32_t*)((arg1 << 2) + &data_430a0c) = eax_5;
0041a199              data_430a24 = eax_8;
0041a0f0          }
0041a0d0      }
0041a0d0      
0041a19e      return 0;
0041a0a4  }


0041a1bf    void* sub_41a1bf()

0041a1bf  {
0041a1bf      void* eax = data_42d334;
0041a1cc      int32_t ebp = 1;
0041a1cc      
0041a1cd      if (!eax)
0041a1cd      {
0041a1d4          eax = sub_41dbac(0x351);
0041a1da          data_42d334 = eax;
0041a1cd      }
0041a1cd      
0041a1df      *(uint8_t*)eax = 0;
0041a1e2      void* var_14 = data_42d340;
0041a1ed      void* const var_18 = &data_428c50;
0041a1ee      char const (* var_1c)[0xb] = data_42d33c;
0041a1fc      sub_41a393(data_42d334, 3);
0041a201      void** i = &data_42d340;
0041a209      void** i_1 = &data_42d340;
0041a24f      void** ecx_2;
0041a24f      
0041a24f      do
0041a24f      {
0041a216          sub_41b8d0(data_42d334, &data_42c214);
0041a21b          char* var_1c_1 = i[3];
0041a21e          i = &i[3];
0041a21e          
0041a22d          if (sub_41ebe0(*(uint32_t*)i_1, var_1c_1))
0041a22f              ebp = 0;
0041a22f          
0041a231          void* var_14_1 = *(uint32_t*)i;
0041a233          i_1 = i;
0041a235          void* const var_18_2 = &data_428c50;
0041a236          int32_t var_1c_2 = i[-1];
0041a241          ecx_2 = sub_41a393(data_42d334, 3);
0041a24f      } while (i < &data_42d370);
0041a24f      
0041a257      if (!ebp)
0041a25e          return data_42d334;
0041a25e      
0041a25f      int32_t __saved_ebx = data_42d334;
0041a265      sub_41784c(ecx_2);
0041a26a      data_42d334 = 0;
0041a277      return data_42d34c;
0041a1bf  }


0041a278    char* sub_41a278(char* arg1, char* arg2, int16_t* arg3, int32_t* arg4)

0041a278  {
0041a28b      if (arg1)
0041a28b      {
0041a299          if (*(uint8_t*)arg1 == 0x43 && !arg1[1])
0041a299          {
0041a2a1              arg2[1] = 0;
0041a2a6              *(uint8_t*)arg2 = 0x43;
0041a2a6              
0041a2a9              if (arg3)
0041a2a9              {
0041a2ab                  *(uint16_t*)arg3 = 0;
0041a2ae                  arg3[1] = 0;
0041a2b2                  arg3[2] = 0;
0041a2a9              }
0041a2a9              
0041a2bb              if (arg4)
0041a2c1                  *(uint32_t*)arg4 = 0;
0041a2c1              
0041a38f              return arg2;
0041a299          }
0041a299          
0041a2d8          if (!sub_41ebe0(&data_42d2ac, arg1))
0041a2d8          {
0041a352          label_41a352:
0041a352              
0041a352              if (arg3)
0041a35e                  sub_41b4f0(arg3, 0x4308a0, 6);
0041a35e              
0041a36a              if (arg4)
0041a376                  sub_41b4f0(arg4, &data_4308a8, 4);
0041a376              
0041a382              sub_41b8c0(arg2, U"C");
0041a38f              return &data_42d2ac;
0041a2d8          }
0041a2d8          
0041a2ea          if (!sub_41ebe0(0x42d228, arg1))
0041a2ea              goto label_41a352;
0041a2ea          
0041a2fd          char var_8c[0x88];
0041a2fd          
0041a2fd          if (!sub_41a3b8(&var_8c, arg1) && sub_422d78(&var_8c, 0x4308a0, &var_8c))
0041a2fd          {
0041a329              data_4308a8 = (uint32_t)data_4308a4;
0041a336              sub_41a484(U"C", &var_8c);
0041a340              char* var_9c_6;
0041a340              
0041a340              if (!*(uint8_t*)arg1)
0041a345                  var_9c_6 = &data_42d2ac;
0041a340              else
0041a342                  var_9c_6 = arg1;
0041a342              
0041a347              sub_41b8c0(U"C", var_9c_6);
0041a34d              goto label_41a352;
0041a2fd          }
0041a28b      }
0041a28b      
0041a31e      return nullptr;
0041a278  }


0041a390    int32_t sub_41a390() __pure

0041a390  {
0041a392      return 0;
0041a390  }


0041a393    void sub_41a393(char* arg1, int32_t arg2)

0041a393  {
0041a394      int32_t i_1 = arg2;
0041a394      
0041a39a      if (i_1 <= 0)
0041a39a          return;
0041a39a      
0041a39d      int32_t* esi_1 = &arg2;
0041a3b3      int32_t i;
0041a3b3      
0041a3b3      do
0041a3b3      {
0041a3a1          char* var_c_1 = esi_1[1];
0041a3a4          esi_1 = &esi_1[1];
0041a3ab          sub_41b8d0(arg1, var_c_1);
0041a3b1          i = i_1;
0041a3b1          i_1 -= 1;
0041a3b3      } while (i != 1);
0041a393  }


0041a3b8    int32_t sub_41a3b8(char* arg1, char* arg2)

0041a3b8  {
0041a3bb      int32_t ebx;
0041a3bb      int32_t var_8 = ebx;
0041a3c9      sub_423620(arg1, 0, 0x88);
0041a3ce      char* esi = arg2;
0041a3d4      char eax = *(uint8_t*)esi;
0041a3d4      
0041a3d8      if (eax)
0041a3d8      {
0041a3e5          if (eax != 0x2e || !esi[1])
0041a3e5          {
0041a3fd              arg2 = nullptr;
0041a3fd              
0041a407              while (true)
0041a407              {
0041a407                  char* eax_2 = sub_417eb0(esi, "_.,");
0041a407                  
0041a410                  if (eax_2)
0041a410                  {
0041a416                      (uint8_t)ebx = *(uint8_t*)(eax_2 + esi);
0041a41c                      char* var_1c_1;
0041a41c                      char* var_18_3;
0041a41c                      char* var_14_2;
0041a41c                      
0041a41c                      if (arg2)
0041a41c                      {
0041a433                          void* eax_4;
0041a433                          
0041a433                          if (arg2 != 1)
0041a433                          {
0041a456                              if (arg2 == 2 && (!(uint8_t)ebx || (uint8_t)ebx == 0x2c))
0041a456                              {
0041a458                                  var_14_2 = eax_2;
0041a45c                                  var_18_3 = esi;
0041a45d                                  eax_4 = &arg1[0x80];
0041a45d                                  goto label_41a462;
0041a456                              }
0041a433                          }
0041a433                          else if (eax_2 < 0x40 && (uint8_t)ebx != 0x5f)
0041a43d                          {
0041a43f                              var_14_2 = eax_2;
0041a443                              var_18_3 = esi;
0041a444                              eax_4 = &arg1[0x40];
0041a462                          label_41a462:
0041a462                              var_1c_1 = eax_4;
0041a462                              goto label_41a463;
0041a43d                          }
0041a41c                      }
0041a41c                      else if (eax_2 < 0x40 && (uint8_t)ebx != 0x2e)
0041a426                      {
0041a428                          var_14_2 = eax_2;
0041a429                          var_18_3 = esi;
0041a42a                          var_1c_1 = arg1;
0041a463                      label_41a463:
0041a463                          sub_417ef0(var_1c_1, var_18_3, var_14_2);
0041a463                          
0041a46e                          if ((uint8_t)ebx == 0x2c)
0041a46e                              break;
0041a46e                          
0041a472                          if (!(uint8_t)ebx)
0041a472                              break;
0041a472                          
0041a474                          arg2 = &arg2[1];
0041a477                          esi = eax_2 + esi + 1;
0041a47a                          continue;
0041a426                      }
0041a410                  }
0041a410                  
0041a47c                  return 0xffffffff;
0041a407              }
0041a3e5          }
0041a3e5          else
0041a3ef              sub_41b8c0(&arg1[0x80], &esi[1]);
0041a3d8      }
0041a3d8      
0041a3f6      return 0;
0041a3b8  }


0041a484    void* sub_41a484(char* arg1, char* arg2)

0041a484  {
0041a48e      sub_41b8c0(arg1, arg2);
0041a48e      
0041a49c      if (arg2[0x40])
0041a49c      {
0041a49e          void* var_8_1 = &arg2[0x40];
0041a49f          void* var_c_1 = &data_42c25c;
0041a4aa          sub_41a393(arg1, 2);
0041a49c      }
0041a49c      
0041a4b9      void* result = &arg2[0x80];
0041a4b9      
0041a4c0      if (!arg2[0x80])
0041a4d6          return result;
0041a4d6      
0041a4c2      void* __saved_esi_1 = result;
0041a4c3      void* var_8_2 = &data_42b48c;
0041a4ce      return sub_41a393(arg1, 2);
0041a484  }


0041a4d7    int32_t* sub_41a4d7(int32_t arg1, char* arg2)

0041a4d7  {
0041a4e0      int32_t ecx = 0;
0041a4e0      
0041a4f2      if (arg1 && arg2)
0041a4f2      {
0041a4f8          char eax = *(uint8_t*)arg2;
0041a4f8          
0041a500          if (eax == 0x77 || eax == 0x72)
0041a500          {
0041a506              eax = arg2[1];
0041a506              
0041a50b              if (eax == 0x74)
0041a50d                  ecx = 0x4000;
0041a50b              else if (eax == 0x62)
0041a518                  ecx = 0x8000;
0041a518              
0041a51d              (uint8_t)ecx |= 0x80;
0041a523              int32_t var_50_1 = ecx;
0041a535              int32_t var_40[0x2];
0041a535              
0041a535              if (sub_423945(&var_40, 0x400) != 0xffffffff)
0041a535              {
0041a53e                  int32_t var_20_1;
0041a53e                  int32_t var_18_1;
0041a53e                  int32_t var_10_1;
0041a53e                  
0041a53e                  if (*(uint8_t*)arg2 != 0x77)
0041a53e                  {
0041a550                      var_18_1 = 0;
0041a554                      var_10_1 = 1;
0041a557                      var_20_1 = 1;
0041a53e                  }
0041a53e                  else
0041a53e                  {
0041a542                      var_10_1 = 0;
0041a546                      var_20_1 = 0;
0041a549                      var_18_1 = 1;
0041a53e                  }
0041a53e                  
0041a55a                  int32_t var_34_1 = 1;
0041a55d                  int32_t var_38 = 1;
0041a560                  HANDLE eax_2 = GetCurrentProcess();
0041a571                  int32_t eax_4 = var_10_1 >> 5;
0041a574                  int32_t esi_4 = (var_10_1 & 0x1f) << 3;
0041a585                  HANDLE hSourceHandle = *(uint32_t*)(esi_4 + (&data_430e20)[eax_4]);
0041a58b                  HANDLE var_1c;
0041a58b                  
0041a58b                  if (hSourceHandle != 0xffffffff && DuplicateHandle(eax_2, hSourceHandle, 
0041a58b                      eax_2, &var_1c, 0, 0, DUPLICATE_SAME_ACCESS))
0041a58b                  {
0041a5b7                      int32_t eax_7;
0041a5b7                      (uint8_t)eax_7 = *(uint8_t*)(esi_4 + (&data_430e20)[eax_4] + 4);
0041a5bd                      char var_5_1 = (uint8_t)eax_7;
0041a5d1                      int32_t __saved_ebp;
0041a5d1                      int32_t eax_10 = (&__saved_ebp)[var_20_1 - 0xf];
0041a5f0                      HANDLE targetHandle;
0041a5f0                      
0041a5f0                      if (DuplicateHandle(eax_2, 
0041a5f0                          *(uint32_t*)((&data_430e20)[eax_10 >> 5]
0041a5f0                              + ((eax_10 & 0x1f) << 3)), 
0041a5f0                          eax_2, &targetHandle, 0, 1, DUPLICATE_SAME_ACCESS))
0041a5f0                      {
0041a5fb                          CloseHandle(*(uint32_t*)(esi_4 + (&data_430e20)[eax_4]));
0041a604                          sub_42388e(var_10_1);
0041a60f                          sub_423817(var_10_1, targetHandle);
0041a614                          int32_t eax_14 = (&__saved_ebp)[var_20_1 - 0xf];
0041a627                          int32_t eax_15;
0041a627                          (uint8_t)eax_15 = *(uint8_t*)((&data_430e20)[eax_14 >> 5]
0041a627                              + ((eax_14 & 0x1f) << 3) + 4);
0041a62b                          *(uint8_t*)(esi_4 + (&data_430e20)[eax_4] + 4) = (uint8_t)eax_15;
0041a631                          sub_41b21b((&__saved_ebp)[var_20_1 - 0xf]);
0041a63c                          (&var_38)[var_20_1] = 0;
0041a64c                          int32_t* result = sub_4236a6(var_40[var_18_1], arg2);
0041a64c                          
0041a659                          if (result)
0041a659                          {
0041a661                              int32_t* eax_18 = sub_41a88a(0);
0041a661                              
0041a66c                              if (eax_18)
0041a66c                              {
0041a672                                  int32_t eax_19 = (&__saved_ebp)[var_18_1 - 0xf];
0041a688                                  int32_t* eax_21 =
0041a688                                      (&data_430e20)[eax_19 >> 5] + ((eax_19 & 0x1f) << 3);
0041a68b                                  int32_t ecx_11 = *(uint32_t*)eax_21;
0041a68d                                  *(uint32_t*)eax_21 = 0xffffffff;
0041a690                                  int32_t eax_22 = (&__saved_ebp)[var_18_1 - 0xf];
0041a6a4                                  char* eax_24 = (&data_430e20)[eax_22 >> 5]
0041a6a4                                      + ((eax_22 & 0x1f) << 3) + 4;
0041a6a8                                  int32_t ecx_14;
0041a6a8                                  (uint8_t)ecx_14 = *(uint8_t*)eax_24;
0041a6aa                                  *(uint8_t*)eax_24 = 0;
0041a6ad                                  *(uint8_t*)((char*)arg2)[3] = (uint8_t)ecx_14;
0041a6b0                                  void* eax_25 = sub_418fca("COMSPEC");
0041a6b8                                  char* var_24_1;
0041a6b8                                  
0041a6b8                                  if (!eax_25)
0041a6b8                                  {
0041a6ee                                  label_41a6ee:
0041a6ee                                      char const* const eax_28 = "command.com";
0041a6ee                                      
0041a6f3                                      if (!((*(int32_t*)((char*)data_4307e0 + 1)) & 0x80))
0041a6f5                                          eax_28 = "cmd.exe";
0041a6f5                                      
0041a6fa                                      int32_t var_50_5 = 0;
0041a6fc                                      int32_t var_54_3 = arg1;
0041a6ff                                      void* const var_58_4 = &data_428ad0;
0041a704                                      char const* const var_5c_5 = eax_28;
0041a710                                      var_24_1 = sub_423678(1, eax_28);
0041a6b8                                  }
0041a6b8                                  else
0041a6b8                                  {
0041a6ba                                      int32_t var_50_4 = 0;
0041a6bc                                      int32_t var_54_2 = arg1;
0041a6bf                                      void* const var_58_3 = &data_428ad0;
0041a6c4                                      void* var_5c_4 = eax_25;
0041a6c8                                      char* eax_26 = sub_42368e(1, eax_25);
0041a6d3                                      var_24_1 = eax_26;
0041a6d3                                      
0041a6d6                                      if (eax_26 == 0xffffffff)
0041a6d6                                      {
0041a6d8                                          int32_t eax_27 = data_4307d4;
0041a6d8                                          
0041a6e5                                          if (eax_27 == 2 || eax_27 == 0xd)
0041a6e0                                              goto label_41a6ee;
0041a6d6                                      }
0041a6b8                                  }
0041a6b8                                  
0041a713                                  int32_t eax_30 = (&__saved_ebp)[var_18_1 - 0xf];
0041a727                                  *(uint32_t*)((&data_430e20)[eax_30 >> 5]
0041a727                                      + ((eax_30 & 0x1f) << 3)) = ecx_11;
0041a72a                                  int32_t ebx_3 = (&__saved_ebp)[var_18_1 - 0xf];
0041a72c                                  int32_t ecx_18;
0041a72c                                  (uint8_t)ecx_18 = *(uint8_t*)((char*)arg2)[3];
0041a73e                                  *(uint8_t*)((&data_430e20)[ebx_3 >> 5]
0041a73e                                      + ((ebx_3 & 0x1f) << 3) + 4) = (uint8_t)ecx_18;
0041a73e                                  
0041a748                                  if (var_24_1 != 0xffffffff)
0041a748                                  {
0041a7f9                                      DuplicateHandle(eax_2, var_1c, eax_2, &targetHandle, 
0041a7f9                                          0, 1, 
0041a7f9                                          DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS);
0041a804                                      CloseHandle(
0041a804                                          *(uint32_t*)(esi_4 + (&data_430e20)[eax_4]));
0041a80d                                      sub_42388e(var_10_1);
0041a818                                      sub_423817(var_10_1, targetHandle);
0041a825                                      *(uint8_t*)(esi_4 + (&data_430e20)[eax_4] + 4) =
0041a825                                          var_5_1;
0041a829                                      int32_t** ecx_24 = eax_18;
0041a82f                                      ecx_24[1] = var_24_1;
0041a832                                      *(uint32_t*)ecx_24 = result;
0041a7e5                                      return result;
0041a748                                  }
0041a748                                  
0041a751                                  *(uint32_t*)eax_18 = 0;
0041a66c                              }
0041a66c                              
0041a757                              sub_416e00(result);
0041a760                              (&var_38)[var_18_1] = 0;
0041a659                          }
0041a659                          
0041a778                          DuplicateHandle(eax_2, var_1c, eax_2, &targetHandle, 0, 1, 
0041a778                              DUPLICATE_SAME_ACCESS);
0041a783                          CloseHandle(*(uint32_t*)(esi_4 + (&data_430e20)[eax_4]));
0041a78c                          sub_42388e(var_10_1);
0041a797                          sub_423817(var_10_1, targetHandle);
0041a7a4                          *(uint8_t*)(esi_4 + (&data_430e20)[eax_4] + 4) = var_5_1;
0041a5f0                      }
0041a5f0                      
0041a7ab                      CloseHandle(var_1c);
0041a58b                  }
0041a58b                  
0041a7bd                  if ((&var_38)[var_20_1])
0041a7c3                      sub_41b21b(var_40[var_20_1]);
0041a7c3                  
0041a7d3                  if ((&var_38)[var_18_1])
0041a7d9                      sub_41b21b(var_40[var_18_1]);
0041a535              }
0041a500          }
0041a4f2      }
0041a4f2      
0041a7df      return nullptr;
0041a4d7  }


0041a836    int32_t __convention("regparm") sub_41a836(int32_t arg1, int32_t arg2, int32_t arg3, int32_t* arg4)

0041a836  {
0041a839      int32_t result_1 = arg3;
0041a83c      int32_t result = 0xffffffff;
0041a83c      
0041a843      if (arg4)
0041a843      {
0041a848          int32_t* eax = sub_41a88a(arg4);
0041a848          
0041a852          if (eax)
0041a852          {
0041a857              sub_416e00(arg4);
0041a85c              int32_t var_18_1 = 1;
0041a85c              
0041a878              if (sub_423ac6(&result_1, eax[1]) != 0xffffffff || data_4307d4 == 4)
0041a87a                  result = result_1;
0041a87a              
0041a87d              *(uint32_t*)eax = 0;
0041a880              eax[1] = 0;
0041a852          }
0041a843      }
0041a843      
0041a889      return result;
0041a836  }


0041a88a    int32_t* sub_41a88a(int32_t arg1)

0041a88a  {
0041a88a      void** result_1 = data_4308b0;
0041a890      int32_t edx = data_4308ac;
0041a897      int32_t* result = result_1;
0041a899      void* esi = &result_1[edx * 2];
0041a899      
0041a8a3      if (result < esi)
0041a8a3      {
0041a8a7          while (*(uint32_t*)result != arg1)
0041a8a7          {
0041a8a9              result = &result[2];
0041a8a9              
0041a8ae              if (result >= esi)
0041a8ae                  break;
0041a8a7          }
0041a8a3      }
0041a8a3      
0041a8b2      if (result < esi)
0041a8e6          return result;
0041a8e6      
0041a8b6      if (!arg1)
0041a8b6      {
0041a8bf          void* var_c_1 = (edx << 3) + 8;
0041a8c1          void* eax_1 = sub_4175ac((edx << 3) + 8, edx, result_1, result_1);
0041a8c1          
0041a8ca          if (eax_1)
0041a8ca          {
0041a8cc              int32_t ecx_1 = data_4308ac;
0041a8d2              data_4308ac += 1;
0041a8d8              data_4308b0 = eax_1;
0041a8dd              return (char*)eax_1 + (ecx_1 << 3);
0041a8ca          }
0041a8b6      }
0041a8b6      
0041a8e2      return nullptr;
0041a88a  }


0041a8e7    void* sub_41a8e7(void* arg1)

0041a8e7  {
0041a8eb      *(uint32_t*)((char*)arg1 + 0xc) &= 0xffffffcf;
0041a8ef      int32_t eax = *(uint32_t*)((char*)arg1 + 0x10);
0041a8f5      void* result;
0041a8f5      
0041a8f5      if (eax == 0xffffffff)
0041a90b          result = &data_42d4e0;
0041a8f5      else
0041a906          result = (&data_430e20)[eax >> 5] + ((eax & 0x1f) << 3);
0041a906      
0041a910      *(uint8_t*)((char*)result + 4) &= 0xfd;
0041a914      return result;
0041a8e7  }


0041a915    int32_t sub_41a915(int32_t* arg1, char* arg2)

0041a915  {
0041a92a      void arg_c;
0041a92a      return sub_423b51(arg1, arg2, &arg_c);
0041a915  }


0041a92b    uint32_t sub_41a92b(char* arg1, int32_t arg2, uint32_t arg3, int32_t* arg4)

0041a92b  {
0041a92e      int32_t ecx;
0041a92e      int32_t var_8 = ecx;
0041a935      uint32_t edi_1 = arg2 * arg3;
0041a93c      uint32_t var_8_1 = edi_1;
0041a944      uint32_t ebx = edi_1;
0041a944      
0041a946      if (!edi_1)
0041a948          return 0;
0041a948      
0041a94f      int32_t* esi_1 = arg4;
0041a94f      
0041a958      if (!(esi_1[3] & 0x10c))
0041a962          arg4 = 0x1000;
0041a958      else
0041a95d          arg4 = esi_1[6];
0041a95d      
0041a96c      uint32_t eax_12;
0041a96c      
0041a96c      while (true)
0041a96c      {
0041a96c          int32_t ecx_2 = esi_1[3] & 0x108;
0041a972          uint32_t eax_3;
0041a972          
0041a972          if (ecx_2)
0041a974              eax_3 = esi_1[1];
0041a974          
0041a979          if (ecx_2 && eax_3)
0041a979          {
0041a97d              uint32_t edi_2 = ebx;
0041a97d              
0041a97f              if (ebx >= eax_3)
0041a981                  edi_2 = eax_3;
0041a981              
0041a989              sub_41b4f0(*(uint32_t*)esi_1, arg1, edi_2);
0041a98e              esi_1[1] -= edi_2;
0041a991              *(uint32_t*)esi_1 += edi_2;
0041a996              ebx -= edi_2;
0041a998              arg1 = &arg1[edi_2];
0041a9e3              edi_1 = var_8_1;
0041a979          }
0041a979          else if (ebx < arg4)
0041a9a0          {
0041a9eb              int32_t* var_18_4 = esi_1;
0041a9eb              
0041a9fa              if (sub_41e84b((int32_t)*(uint8_t*)arg1) == 0xffffffff)
0041a9fa              {
0041aa2a                  eax_12 = edi_1;
0041aa2a                  break;
0041a9fa              }
0041a9fa              
0041a9fc              arg1 = &arg1[1];
0041a9ff              int32_t* eax_11 = esi_1[6];
0041aa02              ebx -= 1;
0041aa03              arg4 = eax_11;
0041aa03              
0041aa08              if (eax_11 <= 0)
0041aa0a                  arg4 = 1;
0041a9a0          }
0041a9a0          else
0041a9a0          {
0041a9a4              bool cond:3_1;
0041a9a4              
0041a9a4              if (ecx_2)
0041a9ac                  cond:3_1 = sub_41ac69(esi_1);
0041a9ac              
0041a9af              if (ecx_2 && cond:3_1)
0041a9af              {
0041aa2a                  eax_12 = edi_1;
0041aa2a                  break;
0041a9af              }
0041a9af              
0041a9b5              uint32_t edi_4;
0041a9b5              
0041a9b5              edi_4 = !arg4 ? ebx : ebx - COMBINE(0, ebx) % arg4;
0041a9b5              
0041a9cd              int32_t eax_7 = sub_424602(esi_1[4], arg1, edi_4);
0041a9cd              
0041a9d8              if (eax_7 != 0xffffffff)
0041a9d8              {
0041a9da                  arg1 = &arg1[eax_7];
0041a9dd                  ebx -= eax_7;
0041a9d8              }
0041a9d8              
0041a9e1              if (eax_7 == 0xffffffff || eax_7 < edi_4)
0041a9e1              {
0041aa21                  esi_1[3] |= 0x20;
0041aa25                  eax_12 = var_8_1;
0041aa28                  break;
0041a9e1              }
0041a9e1              
0041a9e3              edi_1 = var_8_1;
0041a9a0          }
0041a9a0          
0041aa13          if (!ebx)
0041aa19              return arg3;
0041a96c      }
0041a96c      
0041aa20      return COMBINE(0, eax_12 - ebx) / arg2;
0041a92b  }


0041aa35    void* sub_41aa35(int32_t* arg1)

0041aa35  {
0041aa3e      int32_t* edi = arg1;
0041aa43      int32_t esi = edi[4];
0041aa43      
0041aa4c      if (edi[1] < 0)
0041aa4e          edi[1] = 0;
0041aa4e      
0041aa55      uint32_t eax = sub_41b825(esi, 0, FILE_CURRENT);
0041aa5f      uint32_t var_8 = eax;
0041aa5f      
0041aa62      if (eax >= 0)
0041aa62      {
0041aa64          int16_t edx_1 = (int16_t)edi[3];
0041aa64          
0041aa6c          if (!(edx_1 & 0x108))
0041aa6e              return eax - edi[1];
0041aa6e          
0041aa76          int32_t eax_2 = *(uint32_t*)edi;
0041aa78          char* i_2 = edi[2];
0041aa82          void* result = eax_2 - i_2;
0041aa82          
0041aa85          if ((uint8_t)edx_1 & 3)
0041aa85          {
0041aa9d              if (*(uint8_t*)((&data_430e20)[esi >> 5] + ((esi & 0x1f) << 3) + 4) & 0x80)
0041aa9d              {
0041aaa3                  for (char* i = i_2; i < eax_2; i = &i[1])
0041aaa3                  {
0041aaa8                      if (*(uint8_t*)i == 0xa)
0041aaaa                          result += 1;
0041aaa3                  }
0041aa9d              }
0041aa9d              
0041aa9d              goto label_41aac7;
0041aa85          }
0041aa85          
0041aab3          if ((uint8_t)edx_1 & 0x80)
0041aab3          {
0041aac7          label_41aac7:
0041aac7              
0041aacb              if (!var_8)
0041aacd                  return result;
0041aacd              
0041aad9              if (edi[3] & 1)
0041aad9              {
0041aadf                  int32_t edx_5 = edi[1];
0041aadf                  
0041aae4                  if (edx_5)
0041aae4                  {
0041aaf2                      arg1 = eax_2 - i_2 + edx_5;
0041ab04                      int32_t esi_2 = (esi & 0x1f) << 3;
0041ab04                      
0041ab0e                      if (*(uint8_t*)(esi_2 + (&data_430e20)[esi >> 5] + 4) & 0x80)
0041ab0e                      {
0041ab22                          bool cond:3_1;
0041ab22                          
0041ab22                          if (sub_41b825(esi, 0, FILE_END) != var_8)
0041ab22                          {
0041ab49                              sub_41b825(esi, var_8, FILE_BEGIN);
0041ab4e                              int32_t* eax_9 = 0x200;
0041ab59                              int16_t ecx_3;
0041ab59                              
0041ab59                              if (arg1 <= 0x200)
0041ab5b                                  ecx_3 = (int16_t)edi[3];
0041ab5b                              
0041ab66                              if (arg1 > 0x200 || !((uint8_t)ecx_3 & 8)
0041ab66                                      || *(uint8_t*)((char*)ecx_3)[1] & 4)
0041ab68                                  eax_9 = edi[6];
0041ab68                              
0041ab6b                              arg1 = eax_9;
0041ab70                              cond:3_1 =
0041ab70                                  !(*(uint8_t*)(esi_2 + (&data_430e20)[esi >> 5] + 4) & 4);
0041ab22                          }
0041ab22                          else
0041ab22                          {
0041ab24                              char* i_1 = edi[2];
0041ab24                              
0041ab2e                              for (void* ecx_2 = (char*)arg1 + i_1; i_1 < ecx_2; 
0041ab2e                                  i_1 = &i_1[1])
0041ab2e                              {
0041ab33                                  if (*(uint8_t*)i_1 == 0xa)
0041ab35                                      arg1 += 1;
0041ab2e                              }
0041ab2e                              
0041ab3b                              cond:3_1 = !(*(uint8_t*)((char*)edi + 0xd) & 0x20);
0041ab22                          }
0041ab22                          
0041ab75                          if (!cond:3_1)
0041ab77                              arg1 += 1;
0041ab0e                      }
0041ab0e                      
0041ab7d                      var_8 -= arg1;
0041aae4                  }
0041aae4                  else
0041aae6                      result &= edx_5;
0041aad9              }
0041aad9              
0041ab86              return (char*)result + var_8;
0041aab3          }
0041aab3          
0041aab5          data_4307d4 = 0x16;
0041aa62      }
0041aa62      
0041aabf      return 0xffffffff;
0041aa35  }


0041ab8d    int32_t sub_41ab8d(int32_t* arg1, void* arg2, int32_t arg3, int32_t arg4)

0041ab8d  {
0041ab90      int32_t ecx;
0041ab90      int32_t var_8 = ecx;
0041ab90      
0041aba0      if (arg3 != 4)
0041aba0      {
0041abad          if (arg4 < 2 || arg4 > 0x7fffffff)
0041abb8              return 0xffffffff;
0041abb8          
0041abb6          if (arg3 && arg3 != 0x40)
0041abb8              return 0xffffffff;
0041aba0      }
0041aba0      
0041abc2      int32_t* edi_1 = arg4 & 0xfffffffe;
0041abc5      sub_41ac69(arg1);
0041abcb      sub_41b2ce(arg1);
0041abd0      arg1[3] &= 0xc2f3;
0041abd8      int32_t ecx_1 = arg1[3];
0041abde      void* eax_1;
0041abde      
0041abde      if (!((uint8_t)arg3 & 4))
0041abde      {
0041abee          eax_1 = arg2;
0041abee          
0041abf3          if (eax_1)
0041abf3          {
0041ac14              *(uint8_t*)((char*)ecx_1)[1] |= 5;
0041ac17              arg1[3] = ecx_1;
0041abf3          }
0041abf3          else
0041abf3          {
0041abf6              eax_1 = sub_41dbac(edi_1);
0041abf6              
0041abfe              if (!eax_1)
0041abfe              {
0041ac00                  data_43082c += 1;
0041ac06                  return 0xffffffff;
0041abfe              }
0041abfe              
0041ac0c              arg1[3] |= 0x408;
0041abf3          }
0041abde      }
0041abde      else
0041abde      {
0041abe5          arg1[3] = ecx_1 | 4;
0041abe8          eax_1 = &arg1[5];
0041abeb          edi_1 = 2;
0041abde      }
0041abde      
0041ac1a      arg1[1] = 0;
0041ac1e      arg1[6] = edi_1;
0041ac21      arg1[2] = eax_1;
0041ac24      *(uint32_t*)arg1 = eax_1;
0041ac26      return 0;
0041ab8d  }


0041ac2e    int32_t sub_41ac2e(int32_t* arg1)

0041ac2e  {
0041ac35      if (!arg1)
0041ac3f          return sub_41acce(arg1);
0041ac3f      
0041ac49      if (sub_41ac69(arg1))
0041ac4f          return 0xffffffff;
0041ac4f      
0041ac54      if (!(*(uint8_t*)((char*)arg1 + 0xd) & 0x40))
0041ac68          return 0;
0041ac68      
0041ac59      enum WIN32_ERROR eax_3 = sub_4247af(arg1[4]);
0041ac5e      int32_t eax_4 = -(eax_3);
0041ac64      return eax_4 - eax_4;
0041ac2e  }


0041ac69    int32_t sub_41ac69(int32_t* arg1)

0041ac69  {
0041ac6f      int32_t result = 0;
0041ac72      int16_t eax = (int16_t)arg1[3];
0041ac72      
0041ac83      if (((uint8_t)eax & 3) == 2 && eax & 0x108)
0041ac83      {
0041ac85          char* eax_1 = arg1[2];
0041ac8a          uint32_t edi_2 = *(uint32_t*)arg1 - eax_1;
0041ac8a          
0041ac8e          if (edi_2 > 0)
0041ac8e          {
0041ac9f              if (sub_424602(arg1[4], eax_1, edi_2) != edi_2)
0041ac9f              {
0041acaf                  arg1[3] |= 0x20;
0041acb3                  result = 0xffffffff;
0041ac9f              }
0041ac9f              else
0041ac9f              {
0041aca1                  int32_t eax_3 = arg1[3];
0041aca1                  
0041aca6                  if ((uint8_t)eax_3 & 0x80)
0041aca6                  {
0041aca8                      (uint8_t)eax_3 &= 0xfd;
0041acaa                      arg1[3] = eax_3;
0041aca6                  }
0041ac9f              }
0041ac8e          }
0041ac83      }
0041ac83      
0041acb6      int32_t eax_4 = arg1[2];
0041acb9      arg1[1] = 0;
0041acbd      *(uint32_t*)arg1 = eax_4;
0041acc4      return result;
0041ac69  }


0041acc5    int32_t sub_41acc5()

0041acc5  {
0041accd      return sub_41acce(1);
0041acc5  }


0041acce    int32_t sub_41acce(int32_t arg1)

0041acce  {
0041acd1      int32_t i = 0;
0041acd3      int32_t ebx = 0;
0041acd5      int32_t edi = 0;
0041acd5      
0041acdd      if (data_431f40 > 0)
0041acdd      {
0041ad2a          do
0041ad2a          {
0041ace4              int32_t* eax_2 = *(uint32_t*)(data_430f2c + (i << 2));
0041ace4              
0041ace9              if (eax_2)
0041ace9              {
0041aceb                  char ecx_1 = (char)eax_2[3];
0041aceb                  
0041acf1                  if (ecx_1 & 0x83)
0041acf1                  {
0041acf8                      if (arg1 == 1)
0041acf8                      {
0041ad04                          if (sub_41ac2e(eax_2) != 0xffffffff)
0041ad06                              ebx += 1;
0041acf8                      }
0041acf8                      else if (!arg1 && ecx_1 & 2)
0041ad13                      {
0041ad16                          int32_t eax_4 = sub_41ac2e(eax_2);
0041ad16                          
0041ad1f                          if (eax_4 == 0xffffffff)
0041ad21                              edi |= eax_4;
0041ad13                      }
0041acf1                  }
0041ace9              }
0041ace9              
0041ad23              i += 1;
0041ad2a          } while (i < data_431f40);
0041acdd      }
0041acdd      
0041ad33      if (arg1 == 1)
0041ad3a          return ebx;
0041ad3a      
0041ad35      return edi;
0041acce  }

0041ad3b                                                                                   cc cc cc cc cc                             .....

0041ad40    char* sub_41ad40(int32_t arg1, char arg2)

0041ad40  {
0041ad44      int32_t edi = arg1;
0041ad49      int32_t i = 0xffffffff;
0041ad49      
0041ad4c      while (i)
0041ad4c      {
0041ad4c          bool cond:0_1 = 0 != *(uint8_t*)edi;
0041ad4c          edi += 1;
0041ad4c          i -= 1;
0041ad4c          
0041ad4c          if (!cond:0_1)
0041ad4c              break;
0041ad4c      }
0041ad4c      
0041ad4f      int32_t i_1 = -((i + 1));
0041ad51      void* edi_1 = edi - 1;
0041ad51      
0041ad56      while (i_1)
0041ad56      {
0041ad56          bool cond:1_1 = arg2 != *(uint8_t*)edi_1;
0041ad56          edi_1 -= 1;
0041ad56          i_1 -= 1;
0041ad56          
0041ad56          if (!cond:1_1)
0041ad56              break;
0041ad56      }
0041ad56      
0041ad5b      if (*(uint8_t*)((char*)edi_1 + 1) == arg2)
0041ad61          return (char*)edi_1 + 1;
0041ad61      
0041ad5d      return nullptr;
0041ad40  }


0041ad67    int32_t sub_41ad67()

0041ad67  {
0041ad78      return sub_42483b(0x10000, 0x30000);
0041ad67  }


0041ad79    int32_t sub_41ad79() __pure

0041ad79  {
0041ad85      double var_c = (double)(long double)3145727.0;
0041ad8e      double var_14 = (double)(long double)4195835.0;
0041ada0      long double x87_r7_6 = (long double)(double)((long double)var_14
0041ada0          - (long double)var_14 / (long double)var_c * (long double)var_c);
0041ada3      long double temp0 = (long double)1.0;
0041ada3      x87_r7_6 - temp0;
0041ada9      int16_t eax = (x87_r7_6 < temp0 ? 1 : 0) << 8
0041ada9          | (FCMP_UO(x87_r7_6, temp0) ? 1 : 0) << 0xa | (x87_r7_6 == temp0 ? 1 : 0) << 0xe;
0041ada9      
0041adac      if (TEST_BITB(*(uint8_t*)((char*)eax)[1], 6)
0041adac              || TEST_BITB(*(uint8_t*)((char*)eax)[1], 0))
0041adb6          return 0;
0041adb6      
0041adb2      return 1;
0041ad79  }


0041adb7    int32_t sub_41adb7()

0041adb7  {
0041adbc      HMODULE hModule = GetModuleHandleA("KERNEL32");
0041adbc      
0041adc4      if (hModule)
0041adc4      {
0041adcc          int32_t eax = GetProcAddress(hModule, "IsProcessorFeaturePresent");
0041adcc          
0041add4          if (eax)
0041adda              return eax(0);
0041adc4      }
0041adc4      
0041addb      /* tailcall */
0041addb      return sub_41ad79();
0041adb7  }


0041ade0    uint32_t sub_41ade0(char* arg1)

0041ade0  {
0041ade1      char* esi = arg1;
0041ade9      uint32_t i;
0041ade9      int32_t ecx;
0041ade9      int32_t edx;
0041ade9      i = sub_418a84(ecx);
0041adf1      int32_t ecx_1 = (int32_t)*(uint8_t*)esi;
0041adf1      
0041adf2      if (i != 0x65)
0041adf2      {
0041ae1e          do
0041ae1e          {
0041adf4              esi = &esi[1];
0041adf4              
0041adfc              if (data_42d07c <= 1)
0041adfc              {
0041ae10                  ecx_1 = data_42ce70;
0041ae16                  int32_t eax_2;
0041ae16                  (uint8_t)eax_2 = *(uint8_t*)(ecx_1 + ((int32_t)*(uint8_t*)esi << 1));
0041ae19                  i = eax_2 & 4;
0041adfc              }
0041adfc              else
0041adfc              {
0041adfe                  int32_t eax_1 = (int32_t)*(uint8_t*)esi;
0041ae04                  i = sub_4179df(eax_1, edx, ecx_1, eax_1);
0041ae0a                  ecx_1 = 4;
0041adfc              }
0041ae1e          } while (i);
0041adf2      }
0041adf2      
0041ae20      (uint8_t)ecx_1 = data_42d080;
0041ae26      (uint8_t)i = *(uint8_t*)esi;
0041ae28      *(uint8_t*)esi = (uint8_t)ecx_1;
0041ae2a      char* esi_1 = &esi[1];
0041ae2a      
0041ae36      do
0041ae36      {
0041ae2b          (uint8_t)ecx_1 = *(uint8_t*)esi_1;
0041ae2d          *(uint8_t*)esi_1 = (uint8_t)i;
0041ae2f          (uint8_t)i = (uint8_t)ecx_1;
0041ae31          (uint8_t)ecx_1 = *(uint8_t*)esi_1;
0041ae33          esi_1 = &esi_1[1];
0041ae36      } while ((uint8_t)ecx_1);
0041ae36      
0041ae39      return i;
0041ade0  }


0041ae3a    void* sub_41ae3a(char* arg1)

0041ae3a  {
0041ae3a      char* eax = arg1;
0041ae3e      char i = data_42d080;
0041ae44      char ecx = *(uint8_t*)eax;
0041ae44      
0041ae48      if (ecx)
0041ae48      {
0041ae4c          while (ecx != i)
0041ae4c          {
0041ae4e              ecx = eax[1];
0041ae51              eax = &eax[1];
0041ae51              
0041ae54              if (!ecx)
0041ae54                  break;
0041ae4c          }
0041ae48      }
0041ae48      
0041ae58      void* result = &eax[1];
0041ae58      
0041ae5b      if (*(uint8_t*)eax)
0041ae5b      {
0041ae5d          while (true)
0041ae5d          {
0041ae5d              ecx = *(uint8_t*)result;
0041ae5d              
0041ae61              if (!ecx)
0041ae61                  break;
0041ae61              
0041ae66              if (ecx == 0x65)
0041ae66                  break;
0041ae66              
0041ae6b              if (ecx == 0x45)
0041ae6b                  break;
0041ae6b              
0041ae6d              result += 1;
0041ae5d          }
0041ae5d          
0041ae70          void* result_1 = result;
0041ae70          
0041ae76          do
0041ae72              result -= 1;
0041ae76           while (*(uint8_t*)result == 0x30);
0041ae76          
0041ae7a          if (*(uint8_t*)result == i)
0041ae7c              result -= 1;
0041ae7c          
0041ae85          do
0041ae85          {
0041ae7d              i = *(uint8_t*)result_1;
0041ae7f              result += 1;
0041ae80              result_1 += 1;
0041ae83              *(uint8_t*)result = i;
0041ae85          } while (i);
0041ae5b      }
0041ae5b      
0041ae87      return result;
0041ae3a  }


0041ae88    int32_t sub_41ae88(double* arg1)

0041ae88  {
0041ae8c      long double x87_r7 = (long double)*(uint64_t*)arg1;
0041ae8e      long double temp0 = (long double)0.0;
0041ae8e      x87_r7 - temp0;
0041ae94      double* eax;
0041ae94      (uint16_t)eax = (x87_r7 < temp0 ? 1 : 0) << 8
0041ae94          | (FCMP_UO(x87_r7, temp0) ? 1 : 0) << 0xa | (x87_r7 == temp0 ? 1 : 0) << 0xe;
0041ae94      
0041ae97      if (TEST_BITB(*(uint8_t*)((char*)eax)[1], 0))
0041ae9f          return 0;
0041ae9f      
0041ae9c      return 1;
0041ae88  }


0041aea0    int32_t* __convention("regparm") sub_41aea0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t* arg5)

0041aea0  {
0041aea4      int32_t var_c = arg3;
0041aea9      void* arg_c;
0041aea9      void* var_10 = arg_c;
0041aea9      
0041aeac      if (!arg4)
0041aeac      {
0041aecd          sub_424d2b(&arg_c, var_10);
0041aeda          *(uint32_t*)arg5 = arg_c;
0041aedd          return arg5;
0041aeac      }
0041aeac      
0041aeb2      sub_424cfe(&var_c, var_10);
0041aebf      *(uint32_t*)arg5 = var_c;
0041aec4      arg5[1] = arg3;
0041aec8      return arg5;
0041aea0  }


0041aede    char* sub_41aede(double* arg1, char* arg2, void* arg3, int32_t arg4)

0041aede  {
0041aeea      void* ebx;
0041aeea      int32_t* esi;
0041aeea      
0041aeea      if (!data_4308b8)
0041aeea      {
0041af16          int32_t __saved_edi_2;
0041af16          int32_t __saved_edi_1 = __saved_edi_2;
0041af17          int32_t __saved_edi_3 = __saved_edi_2;
0041af1a          __saved_edi_3 = (double)(long double)*(uint64_t*)arg1;
0041af1d          sub_424dcf();
0041af22          ebx = arg3;
0041af25          esi = &data_430b88;
0041af34          int32_t eax_3;
0041af34          (uint8_t)eax_3 = data_430b88 == 0x2d;
0041af3b          void* ecx_4;
0041af3b          (uint8_t)ecx_4 = ebx > 0;
0041af43          sub_424d58((char*)ecx_4 + &arg2[eax_3], (char*)ebx + 1, 0x430b88);
0041aeea      }
0041aeea      else
0041aeea      {
0041aeec          ebx = arg3;
0041aeef          int32_t* eax = data_4308b4;
0041aef6          esi = eax;
0041aefa          int32_t ecx;
0041aefa          (uint8_t)ecx = ebx > 0;
0041af03          void* ecx_1;
0041af03          (uint8_t)ecx_1 = *(uint32_t*)eax == 0x2d;
0041af0a          sub_41b1f6((char*)ecx_1 + arg2, ecx);
0041aeea      }
0041aeea      
0041af4e      char* eax_4 = arg2;
0041af4e      
0041af51      if (*(uint32_t*)esi == 0x2d)
0041af51      {
0041af53          *(uint8_t*)eax_4 = 0x2d;
0041af56          eax_4 = &eax_4[1];
0041af51      }
0041af51      
0041af59      if (ebx > 0)
0041af59      {
0041af62          *(uint8_t*)eax_4 = eax_4[1];
0041af6a          eax_4 = &eax_4[1];
0041af6d          *(uint8_t*)eax_4 = data_42d080;
0041af59      }
0041af59      
0041af7c      void* const ecx_6;
0041af7c      (uint8_t)ecx_6 = !data_4308b8;
0041af84      char* eax_5 = sub_41b8c0((char*)ecx_6 + eax_4 + ebx, "e+000");
0041af84      
0041af91      if (arg4)
0041af93          *(uint8_t*)eax_5 = 0x45;
0041af93      
0041af9d      if (*(uint8_t*)esi[3] != 0x30)
0041af9d      {
0041af9f          int32_t ebx_1 = esi[1];
0041afa2          int32_t ebx_2 = ebx_1 - 1;
0041afa2          
0041afa3          if (ebx_1 - 1 < 0)
0041afa3          {
0041afa5              ebx_2 = -(ebx_2);
0041afa7              eax_5[1] = 0x2d;
0041afa3          }
0041afa3          
0041afae          if (ebx_2 >= 0x64)
0041afae          {
0041afb8              eax_5[2] += (char)((int64_t)ebx_2 / 0x64);
0041afbf              ebx_2 = (int64_t)ebx_2 % 0x64;
0041afae          }
0041afae          
0041afc5          if (ebx_2 >= 0xa)
0041afc5          {
0041afcf              eax_5[3] += (char)((int64_t)ebx_2 / 0xa);
0041afd6              ebx_2 = (int64_t)ebx_2 % 0xa;
0041afc5          }
0041afc5          
0041afd8          eax_5[4] += (uint8_t)ebx_2;
0041af9d      }
0041af9d      
0041afe1      return arg2;
0041aede  }


0041afe2    char* sub_41afe2(double* arg1, char* arg2, int32_t arg3)

0041afe2  {
0041aff1      int32_t ebx;
0041aff1      int32_t* esi;
0041aff1      
0041aff1      if (!data_4308b8)
0041aff1      {
0041b021          int32_t ecx;
0041b021          int32_t var_14_1 = ecx;
0041b022          int32_t var_18_1 = ecx;
0041b025          var_18_1 = (double)(long double)*(uint64_t*)arg1;
0041b028          sub_424dcf();
0041b02d          ebx = arg3;
0041b031          esi = &data_430b88;
0041b03f          void* const eax_5;
0041b03f          (uint8_t)eax_5 = data_430b88 == 0x2d;
0041b045          sub_424d58((char*)eax_5 + arg2, data_430b8c + ebx, 0x430b88);
0041aff1      }
0041aff1      else
0041aff1      {
0041aff3          int32_t eax = data_4308bc;
0041aff8          ebx = arg3;
0041affc          esi = data_4308b4;
0041affc          
0041b004          if (eax == ebx)
0041b004          {
0041b00b              void* ecx_1;
0041b00b              (uint8_t)ecx_1 = *(uint32_t*)esi == 0x2d;
0041b010              char* ecx_3 = (char*)ecx_1 + eax + arg2;
0041b014              *(uint8_t*)ecx_3 = 0x30;
0041b017              ecx_3[1] = 0;
0041b004          }
0041aff1      }
0041aff1      
0041b050      void* edi = arg2;
0041b050      
0041b052      if (*(uint32_t*)esi == 0x2d)
0041b052      {
0041b054          *(uint8_t*)arg2 = 0x2d;
0041b058          edi = &arg2[1];
0041b052      }
0041b052      
0041b05b      int32_t eax_7 = esi[1];
0041b060      void* edi_1;
0041b060      
0041b060      if (eax_7 > 0)
0041b072          edi_1 = (char*)edi + eax_7;
0041b060      else
0041b060      {
0041b065          sub_41b1f6(edi, 1);
0041b06b          *(uint8_t*)edi = 0x30;
0041b06f          edi_1 = (char*)edi + 1;
0041b060      }
0041b060      
0041b076      if (ebx > 0)
0041b076      {
0041b07b          sub_41b1f6(edi_1, 1);
0041b086          *(uint8_t*)edi_1 = data_42d080;
0041b088          int32_t esi_1 = esi[1];
0041b088          
0041b08f          if (esi_1 < 0)
0041b08f          {
0041b098              if (!data_4308b8)
0041b098              {
0041b09e                  int32_t esi_2 = -(esi_1);
0041b09e                  
0041b0a2                  if (ebx >= esi_2)
0041b0a4                      ebx = esi_2;
0041b098              }
0041b098              else
0041b0a4                  ebx = -(esi_1);
0041b0a4              
0041b0a8              sub_41b1f6((char*)edi_1 + 1, ebx);
0041b0b1              sub_423620((char*)edi_1 + 1, 0x30, ebx);
0041b08f          }
0041b076      }
0041b076      
0041b0bf      return arg2;
0041afe2  }


0041b0c0    char* sub_41b0c0(double* arg1, char* arg2, int32_t arg3, int32_t arg4)

0041b0c0  {
0041b0c9      int32_t ecx;
0041b0c9      int32_t var_14 = ecx;
0041b0ca      int32_t var_18 = ecx;
0041b0cd      var_18 = (double)(long double)*(uint64_t*)arg1;
0041b0d0      sub_424dcf();
0041b0d5      data_4308b4 = 0x430b88;
0041b0e1      data_4308bc = data_430b8c - 1;
0041b0ee      void* ecx_3;
0041b0ee      (uint8_t)ecx_3 = data_430b88 == 0x2d;
0041b0f4      char* esi = (char*)ecx_3 + arg2;
0041b0f7      sub_424d58(esi, arg3, 0x430b88);
0041b0fc      void* eax = data_4308b4;
0041b10e      int32_t ecx_6;
0041b10e      (uint8_t)ecx_6 = data_4308bc < *(uint32_t*)((char*)eax + 4) - 1;
0041b111      data_4308c0 = (uint8_t)ecx_6;
0041b11a      int32_t eax_2 = *(uint32_t*)((char*)eax + 4) - 1;
0041b11e      data_4308bc = eax_2;
0041b11e      
0041b127      if (eax_2 < 0xfffffffc || eax_2 >= arg3)
0041b14e          return sub_41b15b(arg1, arg2, arg3, arg4);
0041b14e      
0041b12b      if ((uint8_t)ecx_6)
0041b12b      {
0041b132          do
0041b132          {
0041b12d              (uint8_t)eax_2 = *(uint8_t*)esi;
0041b12f              esi = &esi[1];
0041b132          } while ((uint8_t)eax_2);
0041b132          
0041b134          esi[0xfffffffe] &= (uint8_t)eax_2;
0041b12b      }
0041b12b      
0041b13c      return sub_41b182(arg1, arg2, arg3);
0041b0c0  }


0041b15b    char* sub_41b15b(double* arg1, char* arg2, void* arg3, int32_t arg4)

0041b15b  {
0041b15f      data_4308b8 = 1;
0041b172      char* result = sub_41aede(arg1, arg2, arg3, arg4);
0041b177      data_4308b8 = 0;
0041b181      return result;
0041b15b  }


0041b182    char* sub_41b182(double* arg1, char* arg2, int32_t arg3)

0041b182  {
0041b186      data_4308b8 = 1;
0041b195      char* result = sub_41afe2(arg1, arg2, arg3);
0041b19a      data_4308b8 = 0;
0041b1a4      return result;
0041b182  }


0041b1a5    char* sub_41b1a5(double* arg1, char* arg2, int32_t arg3, int32_t arg4, int32_t arg5)

0041b1a5  {
0041b1b2      if (arg3 == 0x65 || arg3 == 0x45)
0041b1ec          return sub_41aede(arg1, arg2, arg4, arg5);
0041b1ec      
0041b1b8      if (arg3 != 0x66)
0041b1d9          return sub_41b0c0(arg1, arg2, arg4, arg5);
0041b1d9      
0041b1cc      return sub_41afe2(arg1, arg2, arg4);
0041b1a5  }


0041b1f6    void sub_41b1f6(char* arg1, int32_t arg2)

0041b1f6  {
0041b1fd      if (arg2)
0041b210          sub_424ef0(&arg1[arg2], arg1, sub_41e7d0(arg1) + 1);
0041b1f6  }


0041b21b    int32_t sub_41b21b(int32_t arg1)

0041b21b  {
0041b229      int32_t esi_3;
0041b229      
0041b229      if (arg1 < data_430f20)
0041b240          esi_3 = (arg1 & 0x1f) << 3;
0041b240      
0041b24a      if (arg1 >= data_430f20 || !(*(uint8_t*)((&data_430e20)[arg1 >> 5] + esi_3 + 4) & 1))
0041b24a      {
0041b2b5          data_4307d8 = 0;
0041b2bc          data_4307d4 = 9;
0041b24a      }
0041b24a      else
0041b24a      {
0041b256          enum WIN32_ERROR ebp_2;
0041b256          
0041b256          if (sub_423908(arg1) == 0xffffffff)
0041b294              ebp_2 = NO_ERROR;
0041b256          else if (arg1 == 1 || arg1 == 2)
0041b260          {
0041b264              int32_t eax_5 = sub_423908(2);
0041b264              
0041b276              if (sub_423908(1) != eax_5)
0041b276                  goto label_41b280;
0041b276              
0041b294              ebp_2 = NO_ERROR;
0041b260          }
0041b260          else
0041b260          {
0041b280          label_41b280:
0041b280              
0041b288              if (CloseHandle(sub_423908(arg1)))
0041b294                  ebp_2 = NO_ERROR;
0041b288              else
0041b290                  ebp_2 = GetLastError();
0041b260          }
0041b260          
0041b297          sub_42388e(arg1);
0041b29f          *(uint8_t*)((&data_430e20)[arg1 >> 5] + esi_3 + 4) = 0;
0041b29f          
0041b2a6          if (!ebp_2)
0041b2b1              return 0;
0041b2b1          
0041b2a9          sub_42149e(ebp_2);
0041b24a      }
0041b24a      
0041b2c6      return 0xffffffff;
0041b21b  }


0041b2ce    char sub_41b2ce(int32_t* arg1)

0041b2ce  {
0041b2d3      char result = (char)arg1[3];
0041b2d3      
0041b2dc      if (result & 0x83 && result & 8)
0041b2dc      {
0041b2de          int32_t var_8_1 = arg1[2];
0041b2e1          void** ecx;
0041b2e1          sub_41784c(ecx);
0041b2e6          arg1[3] &= 0xfbf7;
0041b2ec          result = 0;
0041b2ef          *(uint32_t*)arg1 = 0;
0041b2f1          arg1[2] = 0;
0041b2f4          arg1[1] = 0;
0041b2dc      }
0041b2dc      
0041b2f8      return result;
0041b2ce  }


0041b2f9    void* sub_41b2f9(int32_t arg1, char* arg2, uint32_t arg3)

0041b2f9  {
0041b30b      int32_t eax_2;
0041b30b      void* eax_4;
0041b30b      char edx;
0041b30b      int32_t esi_2;
0041b30b      
0041b30b      if (arg1 < data_430f20)
0041b30b      {
0041b316          eax_2 = arg1 >> 5;
0041b319          esi_2 = (arg1 & 0x1f) << 3;
0041b32a          eax_4 = (&data_430e20)[eax_2] + esi_2;
0041b32c          edx = *(uint8_t*)((char*)eax_4 + 4);
0041b30b      }
0041b30b      
0041b332      if (arg1 >= data_430f20 || !(edx & 1))
0041b332      {
0041b4d6          data_4307d8 = 0;
0041b4dd          data_4307d4 = 9;
0041b332      }
0041b332      else
0041b332      {
0041b338          int32_t var_c_1 = 0;
0041b33c          char* lpBuffer_1 = arg2;
0041b343          char* lpBuffer = lpBuffer_1;
0041b343          
0041b34a          if (!arg3 || edx & 2)
0041b3ae              return nullptr;
0041b3ae          
0041b34f          if (edx & 0x48)
0041b34f          {
0041b351              (uint8_t)eax_4 = *(uint8_t*)((char*)eax_4 + 5);
0041b351              
0041b356              if ((uint8_t)eax_4 != 0xa)
0041b356              {
0041b358                  arg3 -= 1;
0041b35b                  *(uint8_t*)lpBuffer_1 = (uint8_t)eax_4;
0041b35f                  lpBuffer = &lpBuffer_1[1];
0041b362                  var_c_1 = 1;
0041b369                  *(uint8_t*)((&data_430e20)[eax_2] + esi_2 + 5) = 0xa;
0041b356              }
0041b34f          }
0041b34f          
0041b385          uint32_t numberOfBytesRead;
0041b385          
0041b385          if (ReadFile((&data_430e20)[eax_2][(arg1 & 0x1f) * 2], lpBuffer, arg3, 
0041b385              &numberOfBytesRead, nullptr))
0041b385          {
0041b3c1              int32_t eax_9 = (&data_430e20)[eax_2];
0041b3c3              uint32_t numberOfBytesRead_1 = numberOfBytesRead;
0041b3c6              void* result = var_c_1 + numberOfBytesRead_1;
0041b3c9              char* ecx_2 = eax_9 + esi_2 + 4;
0041b3cd              (uint8_t)eax_9 = *(uint8_t*)(eax_9 + esi_2 + 4);
0041b3cd              
0041b3d3              if (!((uint8_t)eax_9 & 0x80))
0041b4d1                  return result;
0041b4d1              
0041b3e0              if (!numberOfBytesRead_1 || *(uint8_t*)lpBuffer_1 != 0xa)
0041b3e6                  (uint8_t)eax_9 &= 0xfb;
0041b3e0              else
0041b3e2                  (uint8_t)eax_9 |= 4;
0041b3e2              
0041b3e8              *(uint8_t*)ecx_2 = (uint8_t)eax_9;
0041b3f0              arg3 = arg2;
0041b3f3              void* ecx_4 = (char*)result + arg2;
0041b3f7              void* var_c_2 = ecx_4;
0041b3f7              
0041b3fa              if (arg2 < ecx_4)
0041b3fa              {
0041b4b3                  do
0041b4b3                  {
0041b403                      uint32_t eax_11;
0041b403                      (uint8_t)eax_11 = *(uint8_t*)arg3;
0041b403                      
0041b407                      if ((uint8_t)eax_11 == 0x1a)
0041b407                      {
0041b4bd                          char* esi_3 = (&data_430e20)[eax_2] + esi_2 + 4;
0041b4c1                          int32_t eax_18;
0041b4c1                          (uint8_t)eax_18 = *(uint8_t*)esi_3;
0041b4c1                          
0041b4c5                          if (!((uint8_t)eax_18 & 0x40))
0041b4c5                          {
0041b4c7                              (uint8_t)eax_18 |= 2;
0041b4c9                              *(uint8_t*)esi_3 = (uint8_t)eax_18;
0041b4c5                          }
0041b4c5                          
0041b4c5                          break;
0041b407                      }
0041b407                      
0041b40f                      if ((uint8_t)eax_11 != 0xd)
0041b40f                      {
0041b411                          *(uint8_t*)lpBuffer_1 = (uint8_t)eax_11;
0041b413                          lpBuffer_1 = &lpBuffer_1[1];
0041b414                          arg3 += 1;
0041b40f                      }
0041b40f                      else if (arg3 >= (char*)ecx_4 - 1)
0041b420                      {
0041b440                          arg3 += 1;
0041b456                          uint8_t buffer;
0041b456                          
0041b456                          if (ReadFile((&data_430e20)[eax_2][(arg1 & 0x1f) * 2], &buffer, 
0041b456                              1, &numberOfBytesRead, nullptr))
0041b456                          {
0041b466                              if (numberOfBytesRead)
0041b466                                  goto label_41b46a;
0041b466                              
0041b4a9                              *(uint8_t*)lpBuffer_1 = 0xd;
0041b4ac                              lpBuffer_1 = &lpBuffer_1[1];
0041b456                          }
0041b456                          else if (GetLastError() || !numberOfBytesRead)
0041b466                          {
0041b4a9                              *(uint8_t*)lpBuffer_1 = 0xd;
0041b4ac                              lpBuffer_1 = &lpBuffer_1[1];
0041b466                          }
0041b466                          else
0041b466                          {
0041b46a                          label_41b46a:
0041b46a                              
0041b46f                              if (*(uint8_t*)((&data_430e20)[eax_2] + esi_2 + 4) & 0x48)
0041b46f                              {
0041b471                                  int32_t eax_17;
0041b471                                  (uint8_t)eax_17 = buffer;
0041b471                                  
0041b476                                  if ((uint8_t)eax_17 == 0xa)
0041b476                                  {
0041b48f                                      *(uint8_t*)lpBuffer_1 = 0xa;
0041b4ac                                      lpBuffer_1 = &lpBuffer_1[1];
0041b476                                  }
0041b476                                  else
0041b476                                  {
0041b478                                      *(uint8_t*)lpBuffer_1 = 0xd;
0041b47d                                      lpBuffer_1 = &lpBuffer_1[1];
0041b47e                                      *(uint8_t*)((&data_430e20)[eax_2] + esi_2 + 5) =
0041b47e                                          (uint8_t)eax_17;
0041b476                                  }
0041b46f                              }
0041b46f                              else if (lpBuffer_1 != arg2 || buffer != 0xa)
0041b48d                              {
0041b49b                                  sub_41b825(arg1, 0xffffffff, FILE_CURRENT);
0041b49b                                  
0041b4a7                                  if (buffer != 0xa)
0041b4a7                                  {
0041b4a9                                      *(uint8_t*)lpBuffer_1 = 0xd;
0041b4ac                                      lpBuffer_1 = &lpBuffer_1[1];
0041b4a7                                  }
0041b48d                              }
0041b48d                              else
0041b48d                              {
0041b48f                                  *(uint8_t*)lpBuffer_1 = 0xa;
0041b4ac                                  lpBuffer_1 = &lpBuffer_1[1];
0041b48d                              }
0041b466                          }
0041b420                      }
0041b420                      else if (*(uint8_t*)(arg3 + 1) != 0xa)
0041b429                      {
0041b431                          *(uint8_t*)lpBuffer_1 = 0xd;
0041b434                          lpBuffer_1 = &lpBuffer_1[1];
0041b435                          arg3 += 1;
0041b429                      }
0041b429                      else
0041b429                      {
0041b42b                          arg3 += 2;
0041b48f                          *(uint8_t*)lpBuffer_1 = 0xa;
0041b4ac                          lpBuffer_1 = &lpBuffer_1[1];
0041b429                      }
0041b429                      
0041b4ad                      ecx_4 = var_c_2;
0041b4b3                  } while (arg3 < ecx_4);
0041b3fa              }
0041b3fa              
0041b4ce              return lpBuffer_1 - arg2;
0041b385          }
0041b385          
0041b387          enum WIN32_ERROR eax_8 = GetLastError();
0041b387          
0041b392          if (eax_8 != ERROR_ACCESS_DENIED)
0041b392          {
0041b3ac              if (eax_8 == ERROR_BROKEN_PIPE)
0041b3ae                  return nullptr;
0041b3ae              
0041b3b6              sub_42149e(eax_8);
0041b392          }
0041b392          else
0041b392          {
0041b394              data_4307d4 = 9;
0041b39e              data_4307d8 = 5;
0041b392          }
0041b332      }
0041b332      
0041b4e7      return 0xffffffff;
0041b2f9  }

0041b4ef                                               cc                                                                 .

0041b4f0    char* sub_41b4f0(char* arg1, char* arg2, int32_t arg3)

0041b4f0  {
0041b4f5      char* esi = arg2;
0041b4fb      char* edi = arg1;
0041b50a      uint32_t eax_1;
0041b50a      
0041b50a      if (edi > esi && edi < &esi[arg3])
0041b50a      {
0041b688          void* esi_1 = &esi[arg3 - 4];
0041b68c          void* edi_1 = &edi[arg3 - 4];
0041b696          int32_t edx_2;
0041b696          uint32_t ecx_4;
0041b696          
0041b696          if (!(edi_1 & 3))
0041b696          {
0041b698              ecx_4 = arg3 >> 2;
0041b69b              edx_2 = arg3 & 3;
0041b69b              
0041b6a1              if (ecx_4 >= 8)
0041b6a1              {
0041b6a4                  edi_1 = __builtin_memcpy((char*)edi_1 - (ecx_4 << 2), 
0041b6a4                      (char*)esi_1 - (ecx_4 << 2), ecx_4 << 2);
0041b6a4                  
0041b6a7                  switch (edx_2)
0041b6a7                  {
0041b7e6                      case 0:
0041b7e6                      {
0041b7e6                          return arg1;
0041b7e6                          break;
0041b7e6                      }
0041b6a7                      case 1:
0041b6a7                      {
0041b6a7                          goto label_41b7e8;
0041b6a7                      }
0041b6a7                      case 2:
0041b6a7                      {
0041b6a7                          goto label_41b7f8;
0041b6a7                      }
0041b6a7                      case 3:
0041b6a7                      {
0041b6a7                          goto label_41b80c;
0041b6a7                      }
0041b6a7                  }
0041b6a1              }
0041b696          }
0041b696          else if (arg3 < 4)
0041b6c6              switch (arg3)
0041b6c6              {
0041b7e6                  case 0:
0041b7e6                  {
0041b7e6                      return arg1;
0041b7e6                      break;
0041b7e6                  }
0041b7e8                  case 1:
0041b7e8                  {
0041b7e8                  label_41b7e8:
0041b7e8                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
0041b7eb                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
0041b7f4                      return arg1;
0041b7e8                      break;
0041b7e8                  }
0041b7f8                  case 2:
0041b7f8                  {
0041b7f8                  label_41b7f8:
0041b7f8                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
0041b7fb                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
0041b7fe                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 2);
0041b801                      *(uint8_t*)((char*)edi_1 + 2) = (uint8_t)eax_1;
0041b80a                      return arg1;
0041b7f8                      break;
0041b7f8                  }
0041b80c                  case 3:
0041b80c                  {
0041b80c                  label_41b80c:
0041b80c                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
0041b80f                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
0041b812                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 2);
0041b815                      *(uint8_t*)((char*)edi_1 + 2) = (uint8_t)eax_1;
0041b818                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 1);
0041b81b                      *(uint8_t*)((char*)edi_1 + 1) = (uint8_t)eax_1;
0041b824                      return arg1;
0041b80c                      break;
0041b80c                  }
0041b6c6              }
0041b6c6          else
0041b6c6          {
0041b6c8              eax_1 = edi_1 & 3;
0041b6cb              int32_t ecx_6 = arg3 - eax_1;
0041b6cb              
0041b6cd              switch (jump_table_41b6d8[eax_1])
0041b6cd              {
0041b6e8                  case 0x41b6e8:
0041b6e8                  {
0041b6e8                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
0041b6eb                      edx_2 = 3 & ecx_6;
0041b6ed                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
0041b6f0                      esi_1 -= 1;
0041b6f1                      ecx_4 = ecx_6 >> 2;
0041b6f4                      edi_1 -= 1;
0041b6f4                      
0041b6f8                      if (ecx_4 >= 8)
0041b6f8                      {
0041b6fb                          edi_1 = __builtin_memcpy((char*)edi_1 - (ecx_4 << 2), 
0041b6fb                              (char*)esi_1 - (ecx_4 << 2), ecx_4 << 2);
0041b6fb                          
0041b6fe                          switch (edx_2)
0041b6fe                          {
0041b7e6                              case 0:
0041b7e6                              {
0041b7e6                                  return arg1;
0041b7e6                                  break;
0041b7e6                              }
0041b6fe                              case 1:
0041b6fe                              {
0041b6fe                                  goto label_41b7e8;
0041b6fe                              }
0041b6fe                              case 2:
0041b6fe                              {
0041b6fe                                  goto label_41b7f8;
0041b6fe                              }
0041b6fe                              case 3:
0041b6fe                              {
0041b6fe                                  goto label_41b80c;
0041b6fe                              }
0041b6fe                          }
0041b6f8                      }
0041b6e8                      break;
0041b6e8                  }
0041b708                  case 0x41b708:
0041b708                  {
0041b708                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
0041b70b                      edx_2 = 3 & ecx_6;
0041b70d                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
0041b710                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 2);
0041b713                      ecx_4 = ecx_6 >> 2;
0041b716                      *(uint8_t*)((char*)edi_1 + 2) = (uint8_t)eax_1;
0041b719                      esi_1 -= 2;
0041b71c                      edi_1 -= 2;
0041b71c                      
0041b722                      if (ecx_4 >= 8)
0041b722                      {
0041b725                          edi_1 = __builtin_memcpy((char*)edi_1 - (ecx_4 << 2), 
0041b725                              (char*)esi_1 - (ecx_4 << 2), ecx_4 << 2);
0041b725                          
0041b728                          switch (edx_2)
0041b728                          {
0041b7e6                              case 0:
0041b7e6                              {
0041b7e6                                  return arg1;
0041b7e6                                  break;
0041b7e6                              }
0041b728                              case 1:
0041b728                              {
0041b728                                  goto label_41b7e8;
0041b728                              }
0041b728                              case 2:
0041b728                              {
0041b728                                  goto label_41b7f8;
0041b728                              }
0041b728                              case 3:
0041b728                              {
0041b728                                  goto label_41b80c;
0041b728                              }
0041b728                          }
0041b722                      }
0041b708                      break;
0041b708                  }
0041b730                  case 0x41b730:
0041b730                  {
0041b730                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
0041b733                      edx_2 = 3 & ecx_6;
0041b735                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
0041b738                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 2);
0041b73b                      *(uint8_t*)((char*)edi_1 + 2) = (uint8_t)eax_1;
0041b73e                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 1);
0041b741                      ecx_4 = ecx_6 >> 2;
0041b744                      *(uint8_t*)((char*)edi_1 + 1) = (uint8_t)eax_1;
0041b747                      esi_1 -= 3;
0041b74a                      edi_1 -= 3;
0041b74a                      
0041b750                      if (ecx_4 >= 8)
0041b750                      {
0041b757                          edi_1 = __builtin_memcpy((char*)edi_1 - (ecx_4 << 2), 
0041b757                              (char*)esi_1 - (ecx_4 << 2), ecx_4 << 2);
0041b757                          
0041b75a                          switch (edx_2)
0041b75a                          {
0041b7e6                              case 0:
0041b7e6                              {
0041b7e6                                  return arg1;
0041b7e6                                  break;
0041b7e6                              }
0041b75a                              case 1:
0041b75a                              {
0041b75a                                  goto label_41b7e8;
0041b75a                              }
0041b75a                              case 2:
0041b75a                              {
0041b75a                                  goto label_41b7f8;
0041b75a                              }
0041b75a                              case 3:
0041b75a                              {
0041b75a                                  goto label_41b80c;
0041b75a                              }
0041b75a                          }
0041b750                      }
0041b730                      break;
0041b730                  }
0041b6cd              }
0041b6c6          }
0041b6c6          
0041b7c7          switch (edx_2)
0041b7c7          {
0041b7e6              case 0:
0041b7e6              {
0041b7e6                  return arg1;
0041b7e6                  break;
0041b7e6              }
0041b7c7              case 1:
0041b7c7              {
0041b7c7                  goto label_41b7e8;
0041b7c7              }
0041b7c7              case 2:
0041b7c7              {
0041b7c7                  goto label_41b7f8;
0041b7c7              }
0041b7c7              case 3:
0041b7c7              {
0041b7c7                  goto label_41b80c;
0041b7c7              }
0041b7c7          }
0041b50a      }
0041b50a      
0041b516      uint32_t ecx_1;
0041b516      int32_t edx_1;
0041b516      
0041b516      if (edi & 3)
0041b516      {
0041b536          if (arg3 < 4)
0041b544              /* jump -> *(uint32_t*)(((arg3 - 4) << 2) + &data_41b648) */
0041b544          
0041b538          eax_1 = edi & 3;
0041b53b          int32_t ecx_3 = arg3 - 4 + eax_1;
0041b53b          
0041b53d          switch (jump_table_41b550[eax_1])
0041b53d          {
0041b560              case 0x41b560:
0041b560              {
0041b560                  edx_1 = 3 & ecx_3;
0041b562                  (uint8_t)eax_1 = *(uint8_t*)esi;
0041b564                  *(uint8_t*)edi = (uint8_t)eax_1;
0041b566                  (uint8_t)eax_1 = esi[1];
0041b569                  edi[1] = (uint8_t)eax_1;
0041b56c                  (uint8_t)eax_1 = esi[2];
0041b56f                  ecx_1 = ecx_3 >> 2;
0041b572                  edi[2] = (uint8_t)eax_1;
0041b575                  esi = &esi[3];
0041b578                  edi = &edi[3];
0041b578                  
0041b57e                  if (ecx_1 >= 8)
0041b57e                  {
0041b580                      edi = __builtin_memcpy(edi, esi, ecx_1 << 2);
0041b580                      
0041b582                      switch (edx_1)
0041b582                      {
0041b64e                          case 0:
0041b64e                          {
0041b64e                              return arg1;
0041b64e                              break;
0041b64e                          }
0041b582                          case 1:
0041b582                          {
0041b582                              goto label_41b650;
0041b582                          }
0041b582                          case 2:
0041b582                          {
0041b582                              goto label_41b65c;
0041b582                          }
0041b582                          case 3:
0041b582                          {
0041b582                              goto label_41b670;
0041b582                          }
0041b582                      }
0041b57e                  }
0041b560                  break;
0041b560              }
0041b58c              case 0x41b58c:
0041b58c              {
0041b58c                  edx_1 = 3 & ecx_3;
0041b58e                  (uint8_t)eax_1 = *(uint8_t*)esi;
0041b590                  *(uint8_t*)edi = (uint8_t)eax_1;
0041b592                  (uint8_t)eax_1 = esi[1];
0041b595                  ecx_1 = ecx_3 >> 2;
0041b598                  edi[1] = (uint8_t)eax_1;
0041b59b                  esi = &esi[2];
0041b59e                  edi = &edi[2];
0041b59e                  
0041b5a4                  if (ecx_1 >= 8)
0041b5a4                  {
0041b5a6                      edi = __builtin_memcpy(edi, esi, ecx_1 << 2);
0041b5a6                      
0041b5a8                      switch (edx_1)
0041b5a8                      {
0041b64e                          case 0:
0041b64e                          {
0041b64e                              return arg1;
0041b64e                              break;
0041b64e                          }
0041b5a8                          case 1:
0041b5a8                          {
0041b5a8                              goto label_41b650;
0041b5a8                          }
0041b5a8                          case 2:
0041b5a8                          {
0041b5a8                              goto label_41b65c;
0041b5a8                          }
0041b5a8                          case 3:
0041b5a8                          {
0041b5a8                              goto label_41b670;
0041b5a8                          }
0041b5a8                      }
0041b5a4                  }
0041b58c                  break;
0041b58c              }
0041b5b0              case 0x41b5b0:
0041b5b0              {
0041b5b0                  edx_1 = 3 & ecx_3;
0041b5b2                  (uint8_t)eax_1 = *(uint8_t*)esi;
0041b5b4                  *(uint8_t*)edi = (uint8_t)eax_1;
0041b5b6                  esi = &esi[1];
0041b5b7                  ecx_1 = ecx_3 >> 2;
0041b5ba                  edi = &edi[1];
0041b5ba                  
0041b5be                  if (ecx_1 >= 8)
0041b5be                  {
0041b5c0                      edi = __builtin_memcpy(edi, esi, ecx_1 << 2);
0041b5c0                      
0041b5c2                      switch (edx_1)
0041b5c2                      {
0041b64e                          case 0:
0041b64e                          {
0041b64e                              return arg1;
0041b64e                              break;
0041b64e                          }
0041b5c2                          case 1:
0041b5c2                          {
0041b5c2                              goto label_41b650;
0041b5c2                          }
0041b5c2                          case 2:
0041b5c2                          {
0041b5c2                              goto label_41b65c;
0041b5c2                          }
0041b5c2                          case 3:
0041b5c2                          {
0041b5c2                              goto label_41b670;
0041b5c2                          }
0041b5c2                      }
0041b5be                  }
0041b5b0                  break;
0041b5b0              }
0041b53d          }
0041b516      }
0041b516      else
0041b516      {
0041b518          ecx_1 = arg3 >> 2;
0041b51b          edx_1 = arg3 & 3;
0041b51b          
0041b521          if (ecx_1 >= 8)
0041b521          {
0041b523              edi = __builtin_memcpy(edi, esi, ecx_1 << 2);
0041b523              
0041b525              switch (edx_1)
0041b525              {
0041b64e                  case 0:
0041b64e                  {
0041b64e                      return arg1;
0041b64e                      break;
0041b64e                  }
0041b525                  case 1:
0041b525                  {
0041b525                      goto label_41b650;
0041b525                  }
0041b525                  case 2:
0041b525                  {
0041b525                      goto label_41b65c;
0041b525                  }
0041b525                  case 3:
0041b525                  {
0041b525                      goto label_41b670;
0041b525                  }
0041b525              }
0041b521          }
0041b516      }
0041b516      
0041b54c      switch (ecx_1)
0041b54c      {
0041b54c          case 0:
0041b54c          {
0041b54c              goto label_41b62f;
0041b54c          }
0041b54c          case 1:
0041b54c          {
0041b54c              goto label_41b620;
0041b54c          }
0041b54c          case 2:
0041b54c          {
0041b54c              goto label_41b618;
0041b54c          }
0041b54c          case 3:
0041b54c          {
0041b54c              goto label_41b610;
0041b54c          }
0041b54c          case 4:
0041b54c          {
0041b54c              goto label_41b608;
0041b54c          }
0041b54c          case 5:
0041b54c          {
0041b54c              goto label_41b600;
0041b54c          }
0041b54c          case 6:
0041b54c          {
0041b54c              goto label_41b5f8;
0041b54c          }
0041b5f0          case 7:
0041b5f0          {
0041b5f0              *(uint32_t*)(edi + (ecx_1 << 2) - 0x1c) =
0041b5f0                  *(uint32_t*)(esi + (ecx_1 << 2) - 0x1c);
0041b5f8          label_41b5f8:
0041b5f8              *(uint32_t*)(edi + (ecx_1 << 2) - 0x18) =
0041b5f8                  *(uint32_t*)(esi + (ecx_1 << 2) - 0x18);
0041b600          label_41b600:
0041b600              *(uint32_t*)(edi + (ecx_1 << 2) - 0x14) =
0041b600                  *(uint32_t*)(esi + (ecx_1 << 2) - 0x14);
0041b608          label_41b608:
0041b608              *(uint32_t*)(edi + (ecx_1 << 2) - 0x10) =
0041b608                  *(uint32_t*)(esi + (ecx_1 << 2) - 0x10);
0041b610          label_41b610:
0041b610              *(uint32_t*)(edi + (ecx_1 << 2) - 0xc) =
0041b610                  *(uint32_t*)(esi + (ecx_1 << 2) - 0xc);
0041b618          label_41b618:
0041b618              *(uint32_t*)(edi + (ecx_1 << 2) - 8) = *(uint32_t*)(esi + (ecx_1 << 2) - 8);
0041b620          label_41b620:
0041b620              *(uint32_t*)(edi + (ecx_1 << 2) - 4) = *(uint32_t*)(esi + (ecx_1 << 2) - 4);
0041b624              eax_1 = ecx_1 << 2;
0041b62b              esi = &esi[eax_1];
0041b62d              edi = &edi[eax_1];
0041b62f          label_41b62f:
0041b62f              
0041b62f              switch (edx_1)
0041b62f              {
0041b64e                  case 0:
0041b64e                  {
0041b64e                      return arg1;
0041b64e                      break;
0041b64e                  }
0041b650                  case 1:
0041b650                  {
0041b650                  label_41b650:
0041b650                      (uint8_t)eax_1 = *(uint8_t*)esi;
0041b652                      *(uint8_t*)edi = (uint8_t)eax_1;
0041b65a                      return arg1;
0041b650                      break;
0041b650                  }
0041b65c                  case 2:
0041b65c                  {
0041b65c                  label_41b65c:
0041b65c                      (uint8_t)eax_1 = *(uint8_t*)esi;
0041b65e                      *(uint8_t*)edi = (uint8_t)eax_1;
0041b660                      (uint8_t)eax_1 = esi[1];
0041b663                      edi[1] = (uint8_t)eax_1;
0041b66c                      return arg1;
0041b65c                      break;
0041b65c                  }
0041b670                  case 3:
0041b670                  {
0041b670                  label_41b670:
0041b670                      (uint8_t)eax_1 = *(uint8_t*)esi;
0041b672                      *(uint8_t*)edi = (uint8_t)eax_1;
0041b674                      (uint8_t)eax_1 = esi[1];
0041b677                      edi[1] = (uint8_t)eax_1;
0041b67a                      (uint8_t)eax_1 = esi[2];
0041b67d                      edi[2] = (uint8_t)eax_1;
0041b686                      return arg1;
0041b670                      break;
0041b670                  }
0041b62f              }
0041b5f0              break;
0041b5f0          }
0041b54c      }
0041b4f0  }

0041b54b                                   90                                                                         .
0041b553                                                           90 60 b5 41 00 8c b5 41 00 b0 b5 41 00                     .`.A...A...A.
0041b589                             8d 49 00                                                                       .I.
0041b5af                                               90                                                                 .
0041b5c9                             8d 49 00                                                                       .I.
0041b5cc  uint32_t jump_table_41b5cc[0x8] = 
0041b5cc  {
0041b5cc      [0x0] =  0x0041b62f
0041b5d0      [0x1] =  0x0041b61c
0041b5d4      [0x2] =  0x0041b614
0041b5d8      [0x3] =  0x0041b60c
0041b5dc      [0x4] =  0x0041b604
0041b5e0      [0x5] =  0x0041b5fc
0041b5e4      [0x6] =  0x0041b5f4
0041b5e8      [0x7] =  0x0041b5ec
0041b5ec  }

0041b636                                                                    8b ff                                                ..
0041b638  uint32_t jump_table_41b638[0x4] = 
0041b638  {
0041b638      [0x0] =  0x0041b648
0041b63c      [0x1] =  0x0041b650
0041b640      [0x2] =  0x0041b65c
0041b644      [0x3] =  0x0041b670
0041b648  }

0041b64f                                               90                                                                 .
0041b65b                                                                                   90                                         .
0041b66d                                         8d 49 00                                                               .I.
0041b687                       90                                                                                 .
0041b6ae                                            8b ff                                                                ..
0041b6b9                                                                             8d 49 00                                       .I.
0041b6db                                                                                   90 e8 b6 41 00                             ...A.
0041b6e0  08 b7 41 00 30 b7 41 00                                                                          ..A.0.A.
0041b705                 8d 49 00                                                                               .I.
0041b72f                                               90                                                                 .
0041b761     8d 49 00 84 b7 41 00 8c b7 41 00 94 b7 41 00 9c b7 41 00 a4 b7 41 00 ac b7 41 00 b4 b7 41 00   .I...A...A...A...A...A...A...A.
0041b780  uint32_t jump_table_41b780[0x1] = 
0041b780  {
0041b780      [0x0] =  0x0041b7c7
0041b784  }

0041b784              8b 44 8e 1c 89 44 8f 1c 8b 44 8e 18 89 44 8f 18 8b 44 8e 14 89 44 8f 14 8b 44 8e 10      .D...D...D...D...D...D...D..
0041b7a0  89 44 8f 10 8b 44 8e 0c 89 44 8f 0c 8b 44 8e 08 89 44 8f 08 8b 44 8e 04 89 44 8f 04 8d 04 8d 00  .D...D...D...D...D...D...D......
0041b7c0  00 00 00 03 f0 03 f8                                                                             .......
0041b7ce                                            8b ff                                                                ..
0041b7d0  uint32_t jump_table_41b7d0[0x4] = 
0041b7d0  {
0041b7d0      [0x0] =  0x0041b7e0
0041b7d4      [0x1] =  0x0041b7e8
0041b7d8      [0x2] =  0x0041b7f8
0041b7dc      [0x3] =  0x0041b80c
0041b7e0  }

0041b7e7                       90                                                                                 .
0041b7f5                                                                 8d 49 00                                               .I.
0041b80b                                   90                                                                         .

0041b825    uint32_t sub_41b825(int32_t arg1, int32_t arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)

0041b825  {
0041b832      int32_t esi_3;
0041b832      
0041b832      if (arg1 < data_430f20)
0041b845          esi_3 = (arg1 & 0x1f) << 3;
0041b845      
0041b84f      if (arg1 >= data_430f20 || !(*(uint8_t*)((&data_430e20)[arg1 >> 5] + esi_3 + 4) & 1))
0041b84f      {
0041b8a7          data_4307d8 = 0;
0041b8ae          data_4307d4 = 9;
0041b84f      }
0041b84f      else
0041b84f      {
0041b852          HANDLE hFile = sub_423908(arg1);
0041b852          
0041b85b          if (hFile != 0xffffffff)
0041b85b          {
0041b874              uint32_t result = SetFilePointer(hFile, arg2, nullptr, arg3);
0041b87f              enum WIN32_ERROR eax;
0041b87f              
0041b87f              if (result != 0xffffffff)
0041b889                  eax = NO_ERROR;
0041b87f              else
0041b881                  eax = GetLastError();
0041b881              
0041b88d              if (!eax)
0041b88d              {
0041b898                  int32_t eax_1 = (&data_430e20)[arg1 >> 5];
0041b89a                  *(uint8_t*)(eax_1 + esi_3 + 4) &= 0xfd;
0041b8a3                  return result;
0041b88d              }
0041b88d              
0041b890              sub_42149e(eax);
0041b85b          }
0041b85b          else
0041b85d              data_4307d4 = 9;
0041b84f      }
0041b84f      
0041b8b8      return 0xffffffff;
0041b825  }

0041b8bf                                                                                               cc                                 .

0041b8c0    char* sub_41b8c0(char* arg1, char* arg2)

0041b8c0  {
0041b8c1      char* edi = arg1;
0041b931      char* ecx = arg2;
0041b93b      int32_t edx;
0041b93b      
0041b93b      while (ecx & 3)
0041b93b      {
0041b93d          (uint8_t)edx = *(uint8_t*)ecx;
0041b93f          ecx = &ecx[1];
0041b93f          
0041b942          if (!(uint8_t)edx)
0041b942              goto label_41b9a8;
0041b942          
0041b944          *(uint8_t*)edi = (uint8_t)edx;
0041b946          edi = &edi[1];
0041b93b      }
0041b93b      
0041b95b      while (true)
0041b95b      {
0041b95b          int32_t eax_1 = *(uint32_t*)ecx;
0041b964          edx = *(uint32_t*)ecx;
0041b966          ecx = &ecx[4];
0041b966          
0041b96e          if ((eax_1 ^ 0xffffffff ^ (0x7efefeff + eax_1)) & 0x81010100)
0041b96e          {
0041b972              if (!(uint8_t)edx)
0041b972                  break;
0041b972              
0041b976              if (!*(uint8_t*)((char*)edx)[1])
0041b976              {
0041b99f                  *(uint16_t*)edi = (uint16_t)edx;
0041b9a7                  return arg1;
0041b976              }
0041b976              
0041b97e              if (!(edx & 0xff0000))
0041b97e              {
0041b992                  *(uint16_t*)edi = (uint16_t)edx;
0041b999                  edi[2] = 0;
0041b99e                  return arg1;
0041b97e              }
0041b97e              
0041b986              if (!(edx & 0xff000000))
0041b986              {
0041b98a                  *(uint32_t*)edi = edx;
0041b991                  return arg1;
0041b986              }
0041b96e          }
0041b96e          
0041b951          *(uint32_t*)edi = edx;
0041b953          edi = &edi[4];
0041b95b      }
0041b95b      
0041b9a8  label_41b9a8:
0041b9a8      *(uint8_t*)edi = (uint8_t)edx;
0041b9af      return arg1;
0041b8c0  }

0041b8c7                       8d a4 24 00 00 00 00 8b ff                                                         ..$......

0041b8d0    char* sub_41b8d0(char* arg1, char* arg2)

0041b8d0  {
0041b8d0      char* ecx = arg1;
0041b8db      void* edi;
0041b8db      
0041b8db      while (ecx & 3)
0041b8db      {
0041b8dd          char eax = *(uint8_t*)ecx;
0041b8df          ecx = &ecx[1];
0041b8df          
0041b8e2          if (!eax)
0041b8e2          {
0041b91f          label_41b91f:
0041b91f              edi = &ecx[0xffffffff];
0041b922              goto label_41b931;
0041b8e2          }
0041b8db      }
0041b8db      
0041b8ec      while (true)
0041b8ec      {
0041b8ec          int32_t eax_1 = *(uint32_t*)ecx;
0041b8fa          ecx = &ecx[4];
0041b8fa          
0041b902          if ((eax_1 ^ 0xffffffff ^ (0x7efefeff + eax_1)) & 0x81010100)
0041b902          {
0041b904              int32_t eax_4 = *(uint32_t*)(ecx - 4);
0041b904              
0041b909              if (!(uint8_t)eax_4)
0041b909              {
0041b92e                  edi = &ecx[0xfffffffc];
0041b92e                  break;
0041b909              }
0041b909              
0041b90d              if (!*(uint8_t*)((char*)eax_4)[1])
0041b90d              {
0041b929                  edi = &ecx[0xfffffffd];
0041b92c                  break;
0041b90d              }
0041b90d              
0041b914              if (!(eax_4 & 0xff0000))
0041b914              {
0041b924                  edi = &ecx[0xfffffffe];
0041b927                  break;
0041b914              }
0041b914              
0041b91b              if (!(eax_4 & 0xff000000))
0041b91b                  goto label_41b91f;
0041b902          }
0041b8ec      }
0041b8ec      
0041b931  label_41b931:
0041b931      char* ecx_1 = arg2;
0041b93b      int32_t edx;
0041b93b      
0041b93b      while (ecx_1 & 3)
0041b93b      {
0041b93d          (uint8_t)edx = *(uint8_t*)ecx_1;
0041b93f          ecx_1 = &ecx_1[1];
0041b93f          
0041b942          if (!(uint8_t)edx)
0041b942              goto label_41b9a8;
0041b942          
0041b944          *(uint8_t*)edi = (uint8_t)edx;
0041b946          edi += 1;
0041b93b      }
0041b93b      
0041b95b      while (true)
0041b95b      {
0041b95b          int32_t eax_5 = *(uint32_t*)ecx_1;
0041b964          edx = *(uint32_t*)ecx_1;
0041b966          ecx_1 = &ecx_1[4];
0041b966          
0041b96e          if ((eax_5 ^ 0xffffffff ^ (0x7efefeff + eax_5)) & 0x81010100)
0041b96e          {
0041b972              if (!(uint8_t)edx)
0041b972                  break;
0041b972              
0041b976              if (!*(uint8_t*)((char*)edx)[1])
0041b976              {
0041b99f                  *(uint16_t*)edi = (uint16_t)edx;
0041b9a7                  return arg1;
0041b976              }
0041b976              
0041b97e              if (!(edx & 0xff0000))
0041b97e              {
0041b992                  *(uint16_t*)edi = (uint16_t)edx;
0041b999                  *(uint8_t*)((char*)edi + 2) = 0;
0041b99e                  return arg1;
0041b97e              }
0041b97e              
0041b986              if (!(edx & 0xff000000))
0041b986              {
0041b98a                  *(uint32_t*)edi = edx;
0041b991                  return arg1;
0041b986              }
0041b96e          }
0041b96e          
0041b951          *(uint32_t*)edi = edx;
0041b953          edi += 4;
0041b95b      }
0041b95b      
0041b9a8  label_41b9a8:
0041b9a8      *(uint8_t*)edi = (uint8_t)edx;
0041b9af      return arg1;
0041b8d0  }


0041b9b0    int32_t* sub_41b9b0(PSTR arg1, char* arg2, char arg3, int32_t* arg4)

0041b9b0  {
0041b9b3      int32_t ecx;
0041b9b3      int32_t var_8 = ecx;
0041b9b4      int32_t var_c = ecx;
0041b9b7      int32_t esi = data_430a40;
0041b9be      char* edi = arg2;
0041b9c3      int32_t var_c_1 = 0;
0041b9c6      int32_t var_8_1 = 0;
0041b9c9      int32_t eax;
0041b9c9      (uint8_t)eax = *(uint8_t*)edi;
0041b9cd      int32_t ecx_1;
0041b9cd      int32_t esi_1;
0041b9cd      
0041b9cd      if ((uint8_t)eax == 0x61)
0041b9cd      {
0041b9e9          ecx_1 = 0x109;
0041b9ee      label_41b9ee:
0041b9ee          esi_1 = esi | 2;
0041b9f3      label_41b9f3:
0041b9f3          int32_t edx_1 = 1;
0041b9f3          
0041b9f4          while (true)
0041b9f4          {
0041b9f4              (uint8_t)eax = edi[1];
0041b9f7              edi = &edi[1];
0041b9f7              
0041b9fa              if (!(uint8_t)eax)
0041b9fa                  break;
0041b9fa              
0041ba02              if (!edx_1)
0041ba02                  break;
0041ba02              
0041ba08              int32_t eax_1 = (int32_t)(uint8_t)eax;
0041ba08              
0041ba0e              if (eax_1 > 0x54)
0041ba0e              {
0041ba85                  if (eax_1 == 0x62)
0041ba85                  {
0041bad2                      if (!(*(uint8_t*)((char*)ecx_1)[1] & 0xc0))
0041bad2                      {
0041badb                          *(uint8_t*)((char*)ecx_1)[1] |= 0x80;
0041bade                          continue;
0041bad2                      }
0041ba85                  }
0041ba85                  else if (eax_1 == 0x63)
0041ba88                  {
0041babb                      if (!var_c_1)
0041babb                      {
0041babd                          var_c_1 = 1;
0041bac4                          esi_1 |= 0x4000;
0041baca                          continue;
0041babb                      }
0041ba88                  }
0041ba88                  else if (eax_1 == 0x6e)
0041ba8d                  {
0041baa4                      if (!var_c_1)
0041baa4                      {
0041baa6                          var_c_1 = 1;
0041baad                          esi_1 &= 0xffffbfff;
0041bab3                          continue;
0041baa4                      }
0041ba8d                  }
0041ba8d                  else if (eax_1 == 0x74 && !(*(uint8_t*)((char*)ecx_1)[1] & 0xc0))
0041ba97                  {
0041ba99                      *(uint8_t*)((char*)ecx_1)[1] |= 0x40;
0041ba9c                      continue;
0041ba97                  }
0041ba0e              }
0041ba0e              else if (eax_1 == 0x54)
0041ba10              {
0041ba79                  if (!(0x1000 & ecx_1))
0041ba79                  {
0041ba7b                      ecx_1 |= 0x1000;
0041ba7d                      continue;
0041ba79                  }
0041ba10              }
0041ba10              else if (eax_1 == 0x2b)
0041ba15              {
0041ba5f                  if (!((uint8_t)ecx_1 & 2))
0041ba5f                  {
0041ba67                      ecx_1 = (ecx_1 & 0xfffffffe) | 2;
0041ba6a                      esi_1 = (esi_1 & 0xfffffffc) | 0x80;
0041ba70                      continue;
0041ba5f                  }
0041ba15              }
0041ba15              else if (eax_1 == 0x44)
0041ba1a              {
0041ba55                  if (!((uint8_t)ecx_1 & 0x40))
0041ba55                  {
0041ba57                      ecx_1 |= 0x40;
0041ba5a                      continue;
0041ba55                  }
0041ba1a              }
0041ba1a              else if (eax_1 == 0x52)
0041ba1f              {
0041ba40                  if (!var_8_1)
0041ba40                  {
0041ba46                      var_8_1 = 1;
0041ba4d                      ecx_1 |= 0x10;
0041ba50                      continue;
0041ba40                  }
0041ba1f              }
0041ba1f              else if (eax_1 == 0x53 && !var_8_1)
0041ba2b              {
0041ba31                  var_8_1 = 1;
0041ba38                  ecx_1 |= 0x20;
0041ba3b                  continue;
0041ba2b              }
0041ba2b              
0041bad4              edx_1 = 0;
0041b9f4          }
0041b9f4          
0041bae3          int32_t var_1c_1 = 0x1a4;
0041baef          int32_t eax_2 = sub_421530(arg1, ecx_1, arg3);
0041baef          
0041bafb          if (eax_2 >= 0)
0041bafb          {
0041bb04              data_43082c += 1;
0041bb0a              arg4[3] = esi_1;
0041bb0d              arg4[1] = 0;
0041bb10              *(uint32_t*)arg4 = 0;
0041bb12              arg4[2] = 0;
0041bb15              arg4[7] = 0;
0041bb18              arg4[4] = eax_2;
0041bb1f              return arg4;
0041bafb          }
0041b9cd      }
0041b9cd      else
0041b9cd      {
0041b9d1          if ((uint8_t)eax == 0x72)
0041b9d1          {
0041b9e2              ecx_1 = 0;
0041b9e4              esi_1 = esi | 1;
0041b9e7              goto label_41b9f3;
0041b9d1          }
0041b9d1          
0041b9d5          if ((uint8_t)eax == 0x77)
0041b9d5          {
0041b9db              ecx_1 = 0x301;
0041b9e0              goto label_41b9ee;
0041b9d5          }
0041b9cd      }
0041bafd      return nullptr;
0041b9b0  }


0041bb20    int32_t* sub_41bb20()

0041bb20  {
0041bb20      int32_t edx = data_431f40;
0041bb2b      int32_t* result = nullptr;
0041bb2d      int32_t eax = 0;
0041bb2d      
0041bb32      if (edx > 0)
0041bb32      {
0041bb34          int32_t* ebx_1 = data_430f2c;
0041bb3a          int32_t* edi_1 = ebx_1;
0041bb3a          
0041bb3c          while (true)
0041bb3c          {
0041bb3c              void* ecx_1 = *(uint32_t*)edi_1;
0041bb3c              
0041bb40              if (!ecx_1)
0041bb40              {
0041bb5b                  int32_t edi_3 = eax << 2;
0041bb6a                  *(uint32_t*)(edi_3 + data_430f2c) = sub_41dbac(0x20);
0041bb72                  int32_t* result_1 = *(uint32_t*)(edi_3 + data_430f2c);
0041bb72                  
0041bb77                  if (!result_1)
0041bb77                      break;
0041bb77                  
0041bb79                  result = result_1;
0041bb40              }
0041bb40              else if (!(*(uint8_t*)((char*)ecx_1 + 0xc) & 0x83))
0041bb52                  result = ebx_1[eax];
0041bb46              else
0041bb46              {
0041bb48                  eax += 1;
0041bb49                  edi_1 = &edi_1[1];
0041bb49                  
0041bb4e                  if (eax >= edx)
0041bb4e                      break;
0041bb4e                  
0041bb4e                  continue;
0041bb46              }
0041bb46              
0041bb7d              if (!result)
0041bb7d                  break;
0041bb7d              
0041bb7f              result[4] = 0xffffffff;
0041bb83              result[1] = 0;
0041bb86              result[3] = 0;
0041bb89              result[2] = 0;
0041bb8c              *(uint32_t*)result = 0;
0041bb8e              result[7] = 0;
0041bb8e              break;
0041bb3c          }
0041bb32      }
0041bb32      
0041bb97      return result;
0041bb20  }


0041bb98    int32_t sub_41bb98(int32_t arg1, EXCEPTION_POINTERS* arg2)

0041bb98  {
0041bb9f      int32_t* eax = sub_41bcd9(arg1);
0041bb9f      
0041bba7      if (eax)
0041bba7      {
0041bbad          int32_t ebx_1 = eax[2];
0041bbad          
0041bbb2          if (ebx_1)
0041bbb2          {
0041bbbb              if (ebx_1 == 5)
0041bbbb              {
0041bbbd                  eax[2] = 0;
0041bbc3                  return 1;
0041bbbb              }
0041bbbb              
0041bbcc              if (ebx_1 != 1)
0041bbcc              {
0041bbd2                  int32_t ecx_1 = data_4308c4;
0041bbde                  data_4308c4 = arg2;
0041bbe4                  int32_t ecx_3 = eax[1];
0041bbe4                  
0041bbea                  if (ecx_3 != 8)
0041bbea                  {
0041bcb8                      eax[2] = 0;
0041bcbd                      ebx_1(ecx_3);
0041bbea                  }
0041bbea                  else
0041bbea                  {
0041bbf0                      int32_t ecx_4 = data_42d4d0;
0041bbfc                      int32_t edx_2 = data_42d4d4 + ecx_4;
0041bbfc                      
0041bc01                      if (ecx_4 < edx_2)
0041bc01                      {
0041bc06                          int32_t i_1 = edx_2 - ecx_4;
0041bc08                          void* esi_2 = ecx_4 * 0xc + &data_42d460;
0041bc16                          int32_t i;
0041bc16                          
0041bc16                          do
0041bc16                          {
0041bc0f                              *(uint32_t*)esi_2 = 0;
0041bc12                              esi_2 += 0xc;
0041bc15                              i = i_1;
0041bc15                              i_1 -= 1;
0041bc16                          } while (i != 1);
0041bc01                      }
0041bc01                      
0041bc1a                      int32_t esi_3 = data_42d4dc;
0041bc1a                      
0041bc25                      switch (*(uint32_t*)eax)
0041bc25                      {
0041bc6c                          case 0xc000008d:
0041bc6c                          {
0041bc73                              data_42d4dc = 0x82;
0041bc6c                              break;
0041bc6c                          }
0041bc20                          case 0xc000008e:
0041bc20                          {
0041bc27                              data_42d4dc = 0x83;
0041bc20                              break;
0041bc20                          }
0041bc7f                          case 0xc000008f:
0041bc7f                          {
0041bc86                              data_42d4dc = 0x86;
0041bc7f                              break;
0041bc7f                          }
0041bc33                          case 0xc0000090:
0041bc33                          {
0041bc3a                              data_42d4dc = 0x81;
0041bc33                              break;
0041bc33                          }
0041bc46                          case 0xc0000091:
0041bc46                          {
0041bc4d                              data_42d4dc = 0x84;
0041bc46                              break;
0041bc46                          }
0041bc92                          case 0xc0000092:
0041bc92                          {
0041bc99                              data_42d4dc = 0x8a;
0041bc92                              break;
0041bc92                          }
0041bc59                          case 0xc0000093:
0041bc59                          {
0041bc60                              data_42d4dc = 0x85;
0041bc59                              break;
0041bc59                          }
0041bc25                      }
0041bc25                      
0041bcab                      ebx_1(8, data_42d4dc);
0041bcae                      data_42d4dc = esi_3;
0041bbea                  }
0041bbea                  
0041bcc3                  data_4308c4 = ecx_1;
0041bbcc              }
0041bbcc              
0041bcc8              return 0xffffffff;
0041bbb2          }
0041bba7      }
0041bba7      
0041bcd0      return UnhandledExceptionFilter(arg2);
0041bb98  }


0041bcd9    int32_t* sub_41bcd9(int32_t arg1)

0041bcd9  {
0041bcdd      int32_t ecx = data_42d4d8;
0041bcea      int32_t* result = &data_42d458;
0041bcea      
0041bcef      if (data_42d458 != arg1)
0041bcef      {
0041bd04          do
0041bd04          {
0041bcfb              result = &result[3];
0041bcfb              
0041bd00              if (result >= &(&data_42d458)[ecx * 3])
0041bd00                  break;
0041bd04          } while (*(uint32_t*)result != arg1);
0041bcef      }
0041bcef      
0041bd17      if (result < &(&data_42d458)[ecx * 3] && *(uint32_t*)result == arg1)
0041bd1b          return result;
0041bd1b      
0041bd19      return nullptr;
0041bcd9  }


0041bd1c    int32_t sub_41bd1c()

0041bd1c  {
0041bd27      if (!data_431f4c)
0041bd29          sub_4255f2();
0041bd29      
0041bd2e      char* esi = data_430820;
0041bd34      int32_t edi = 0;
0041bd34      
0041bd36      while (true)
0041bd36      {
0041bd36          void* eax;
0041bd36          (uint8_t)eax = *(uint8_t*)esi;
0041bd36          
0041bd3a          if (!(uint8_t)eax)
0041bd3a              break;
0041bd3a          
0041bd3e          if ((uint8_t)eax != 0x3d)
0041bd40              edi += 1;
0041bd40          
0041bd48          esi = esi + sub_41e7d0(esi) + 1;
0041bd36      }
0041bd36      
0041bd5b      void* esi_1 = sub_41dbac((edi << 2) + 4);
0041bd5d      void* ecx_2 = (edi << 2) + 4;
0041bd60      data_4307fc = esi_1;
0041bd60      
0041bd66      if (!esi_1)
0041bd66      {
0041bd6a          sub_41720a(9);
0041bd6f          ecx_2 = 9;
0041bd66      }
0041bd66      
0041bd70      char* edi_1 = data_430820;
0041bd70      
0041bd78      while (*(uint8_t*)edi_1)
0041bd78      {
0041bd83          ecx_2 = edi_1;
0041bd84          void* ebp_2 = sub_41e7d0(edi_1) + 1;
0041bd84          
0041bd88          if (*(uint8_t*)edi_1 != 0x3d)
0041bd88          {
0041bd8b              void* eax_4 = sub_41dbac(ebp_2);
0041bd93              *(uint32_t*)esi_1 = eax_4;
0041bd93              
0041bd95              if (!eax_4)
0041bd99                  sub_41720a(9);
0041bd99              
0041bd9f              void* var_14_3 = edi_1;
0041bda2              sub_41b8c0(*(uint32_t*)esi_1, var_14_3);
0041bda8              esi_1 += 4;
0041bdab              ecx_2 = var_14_3;
0041bd88          }
0041bd88          
0041bdac          edi_1 += ebp_2;
0041bd78      }
0041bd78      
0041bdb3      int32_t __saved_ebp_3 = data_430820;
0041bdb9      int32_t result = sub_41784c(ecx_2);
0041bdbf      data_430820 = 0;
0041bdc5      *(uint32_t*)esi_1 = 0;
0041bdc9      data_431f48 = 1;
0041bdd4      return result;
0041bd1c  }


0041bdd5    int32_t __fastcall sub_41bdd5(int32_t arg1)

0041bdd5  {
0041bdd8      int32_t var_8 = arg1;
0041bdd9      int32_t var_c = arg1;
0041bdd9      
0041bde5      if (!data_431f4c)
0041bde7          sub_4255f2();
0041bde7      
0041bdf8      GetModuleFileNameA(nullptr, &data_4308c8, 0x104);
0041bdfe      char* eax = data_431f44;
0041be03      data_43080c = &data_4308c8;
0041be09      void* edi = &data_4308c8;
0041be09      
0041be0d      if (*(uint8_t*)eax)
0041be0f          edi = eax;
0041be0f      
0041be1c      sub_41be6e(edi, nullptr, nullptr, &var_8, &var_c);
0041be2b      void* eax_3 = sub_41dbac(var_c + (var_8 << 2));
0041be2b      
0041be37      if (!eax_3)
0041be3b          sub_41720a(8);
0041be3b      
0041be52      sub_41be6e(edi, eax_3, (char*)eax_3 + (var_8 << 2), &var_8, &var_c);
0041be5d      int32_t result = var_8 - 1;
0041be5e      data_4307f4 = eax_3;
0041be66      data_4307f0 = result;
0041be6d      return result;
0041bdd5  }


0041be6e    int32_t* sub_41be6e(char* arg1, int32_t* arg2, char* arg3, int32_t* arg4, int32_t* arg5)

0041be6e  {
0041be71      int32_t* ecx = arg5;
0041be79      *(uint32_t*)ecx = 0;
0041be7c      char* esi = arg3;
0041be80      int32_t* edi = arg2;
0041be83      *(uint32_t*)arg4 = 1;
0041be89      char* eax_1 = arg1;
0041be89      
0041be8e      if (edi)
0041be8e      {
0041be90          *(uint32_t*)edi = esi;
0041be92          edi = &edi[1];
0041be95          arg2 = edi;
0041be8e      }
0041be8e      
0041be9b      uint32_t edx;
0041be9b      
0041be9b      if (*(uint8_t*)eax_1 != 0x22)
0041be9b      {
0041bee1          while (true)
0041bee1          {
0041bee1              *(uint32_t*)ecx += 1;
0041bee1              
0041bee5              if (esi)
0041bee5              {
0041bee7                  (uint8_t)edx = *(uint8_t*)eax_1;
0041bee9                  *(uint8_t*)esi = (uint8_t)edx;
0041beeb                  esi = &esi[1];
0041bee5              }
0041bee5              
0041beec              (uint8_t)edx = *(uint8_t*)eax_1;
0041beee              eax_1 = &eax_1[1];
0041beee              
0041bef9              if (*(uint8_t*)((uint32_t)(uint8_t)edx + 0x430ce1) & 4)
0041bef9              {
0041befb                  *(uint32_t*)ecx += 1;
0041befb                  
0041beff                  if (esi)
0041beff                  {
0041bf01                      uint32_t ebx_1;
0041bf01                      (uint8_t)ebx_1 = *(uint8_t*)eax_1;
0041bf03                      *(uint8_t*)esi = (uint8_t)ebx_1;
0041bf05                      esi = &esi[1];
0041beff                  }
0041beff                  
0041bf06                  eax_1 = &eax_1[1];
0041bef9              }
0041bef9              
0041bf0a              if ((uint8_t)edx == 0x20)
0041bf0a              {
0041bf15              label_41bf15:
0041bf15                  
0041bf17                  if ((uint8_t)edx)
0041bf17                  {
0041bf1e                      if (esi)
0041bf20                          esi[0xffffffff] = 0;
0041bf20                      
0041bf1e                      break;
0041bf17                  }
0041bf0a              }
0041bf0a              else if ((uint8_t)edx)
0041bf0e              {
0041bf13                  if ((uint8_t)edx == 9)
0041bf13                      goto label_41bf15;
0041bf13                  
0041bf13                  continue;
0041bf0e              }
0041bf0e              
0041bf19              eax_1 -= 1;
0041bf1a              break;
0041bee1          }
0041be9b      }
0041be9b      else
0041be9b      {
0041be9d          while (true)
0041be9d          {
0041be9d              (uint8_t)edx = eax_1[1];
0041bea0              eax_1 = &eax_1[1];
0041bea0              
0041bea4              if ((uint8_t)edx == 0x22)
0041bea4                  break;
0041bea4              
0041bea8              if (!(uint8_t)edx)
0041bea8                  break;
0041bea8              
0041beb4              if (*(uint8_t*)((uint32_t)(uint8_t)edx + 0x430ce1) & 4)
0041beb4              {
0041beb6                  *(uint32_t*)ecx += 1;
0041beb6                  
0041beba                  if (esi)
0041beba                  {
0041bebc                      (uint8_t)edx = *(uint8_t*)eax_1;
0041bebe                      *(uint8_t*)esi = (uint8_t)edx;
0041bec0                      esi = &esi[1];
0041bec1                      eax_1 = &eax_1[1];
0041beba                  }
0041beb4              }
0041beb4              
0041bec2              *(uint32_t*)ecx += 1;
0041bec2              
0041bec6              if (esi)
0041bec6              {
0041bec8                  (uint8_t)edx = *(uint8_t*)eax_1;
0041beca                  *(uint8_t*)esi = (uint8_t)edx;
0041becc                  esi = &esi[1];
0041bec6              }
0041be9d          }
0041be9d          
0041becf          *(uint32_t*)ecx += 1;
0041becf          
0041bed3          if (esi)
0041bed3          {
0041bed5              *(uint8_t*)esi = 0;
0041bed8              esi = &esi[1];
0041bed3          }
0041bed3          
0041bedc          if (*(uint8_t*)eax_1 == 0x22)
0041bede              eax_1 = &eax_1[1];
0041be9b      }
0041be9b      
0041bf24      arg5 = nullptr;
0041bf24      
0041bf2b      while (*(uint8_t*)eax_1)
0041bf2b      {
0041bf31          while (true)
0041bf31          {
0041bf31              (uint8_t)edx = *(uint8_t*)eax_1;
0041bf31              
0041bf3b              if ((uint8_t)edx != 0x20 && (uint8_t)edx != 9)
0041bf3b                  break;
0041bf3b              
0041bf3d              eax_1 = &eax_1[1];
0041bf31          }
0041bf31          
0041bf43          if (!*(uint8_t*)eax_1)
0041bf43              break;
0041bf43          
0041bf4b          if (edi)
0041bf4b          {
0041bf4d              *(uint32_t*)edi = esi;
0041bf4f              edi = &edi[1];
0041bf52              arg2 = edi;
0041bf4b          }
0041bf4b          
0041bf58          *(uint32_t*)arg4 += 1;
0041bf58          
0041bf5a          while (true)
0041bf5a          {
0041bf5a              arg1 = 1;
0041bf61              uint32_t i_2 = 0;
0041bf61              
0041bf66              while (*(uint8_t*)eax_1 == 0x5c)
0041bf66              {
0041bf68                  eax_1 = &eax_1[1];
0041bf69                  i_2 += 1;
0041bf66              }
0041bf66              
0041bf6f              if (*(uint8_t*)eax_1 == 0x22)
0041bf6f              {
0041bf74                  if (!((uint8_t)i_2 & 1))
0041bf74                  {
0041bf84                      if (!arg5 || eax_1[1] != 0x22)
0041bf8a                          arg1 = nullptr;
0041bf84                      else
0041bf86                          eax_1 = &eax_1[1];
0041bf86                      
0041bf8d                      edi = arg2;
0041bf95                      int32_t* edx_3;
0041bf95                      (uint8_t)edx_3 = !arg5;
0041bf98                      arg5 = edx_3;
0041bf74                  }
0041bf74                  
0041bf9b                  i_2 u>>= 1;
0041bf6f              }
0041bf6f              
0041bfa2              if (i_2)
0041bfa2              {
0041bfa4                  int32_t i_1 = i_2;
0041bfb0                  int32_t i;
0041bfb0                  
0041bfb0                  do
0041bfb0                  {
0041bfa7                      if (esi)
0041bfa7                      {
0041bfa9                          *(uint8_t*)esi = 0x5c;
0041bfac                          esi = &esi[1];
0041bfa7                      }
0041bfa7                      
0041bfad                      *(uint32_t*)ecx += 1;
0041bfaf                      i = i_1;
0041bfaf                      i_1 -= 1;
0041bfb0                  } while (i != 1);
0041bfa2              }
0041bfa2              
0041bfb2              (uint8_t)edx = *(uint8_t*)eax_1;
0041bfb2              
0041bfb6              if (!(uint8_t)edx)
0041bfb6                  break;
0041bfb6              
0041bfbc              if (!arg5)
0041bfbc              {
0041bfc1                  if ((uint8_t)edx == 0x20)
0041bfc1                      break;
0041bfc1                  
0041bfc6                  if ((uint8_t)edx == 9)
0041bfc6                      break;
0041bfbc              }
0041bfbc              
0041bfcc              if (arg1)
0041bfcc              {
0041bfd0                  if (esi)
0041bfd0                  {
0041bfdc                      if (*(uint8_t*)((uint32_t)(uint8_t)edx + 0x430ce1) & 4)
0041bfdc                      {
0041bfde                          *(uint8_t*)esi = (uint8_t)edx;
0041bfe0                          esi = &esi[1];
0041bfe1                          eax_1 = &eax_1[1];
0041bfe2                          *(uint32_t*)ecx += 1;
0041bfdc                      }
0041bfdc                      
0041bfe4                      (uint8_t)edx = *(uint8_t*)eax_1;
0041bfe6                      *(uint8_t*)esi = (uint8_t)edx;
0041bfe8                      esi = &esi[1];
0041bfd0                  }
0041bfd0                  else if (*(uint8_t*)((uint32_t)(uint8_t)edx + 0x430ce1) & 4)
0041bff5                  {
0041bff7                      eax_1 = &eax_1[1];
0041bff8                      *(uint32_t*)ecx += 1;
0041bff5                  }
0041bff5                  
0041bffa                  *(uint32_t*)ecx += 1;
0041bfcc              }
0041bfcc              
0041bffc              eax_1 = &eax_1[1];
0041bf5a          }
0041bf5a          
0041c004          if (esi)
0041c004          {
0041c006              *(uint8_t*)esi = 0;
0041c009              esi = &esi[1];
0041c004          }
0041c004          
0041c00a          *(uint32_t*)ecx += 1;
0041bf2b      }
0041bf2b      
0041c013      if (edi)
0041c015          *(uint32_t*)edi = 0;
0041c015      
0041c01e      *(uint32_t*)arg4 += 1;
0041c021      return arg4;
0041be6e  }


0041c022    void* sub_41c022()

0041c022  {
0041c022      int32_t ecx;
0041c022      int32_t var_4 = ecx;
0041c023      int32_t var_8 = ecx;
0041c024      int32_t eax = data_4309cc;
0041c033      void* lpMultiByteStr_3 = nullptr;
0041c035      PWSTR esi = nullptr;
0041c037      char* penv = nullptr;
0041c037      
0041c03b      if (!eax)
0041c03b      {
0041c03f          esi = GetEnvironmentStringsW();
0041c03f          
0041c043          if (!esi)
0041c043          {
0041c057              penv = GetEnvironmentStrings();
0041c057              
0041c05b              if (!penv)
0041c14b                  return nullptr;
0041c14b              
0041c061              data_4309cc = 2;
0041c101          label_41c101:
0041c101              
0041c101              if (!penv)
0041c101              {
0041c109                  penv = GetEnvironmentStrings();
0041c109                  
0041c10d                  if (!penv)
0041c14b                      return nullptr;
0041c101              }
0041c101              
0041c111              char* penv_1 = penv;
0041c111              
0041c113              if (*(uint8_t*)penv)
0041c113              {
0041c115                  while (true)
0041c115                  {
0041c115                      penv_1 = &penv_1[1];
0041c115                      
0041c118                      if (!*(uint8_t*)penv_1)
0041c118                      {
0041c11a                          penv_1 = &penv_1[1];
0041c11a                          
0041c11d                          if (!*(uint8_t*)penv_1)
0041c11d                              break;
0041c118                      }
0041c115                  }
0041c113              }
0041c113              
0041c12a              void* esi_1 = sub_41dbac(penv_1 - penv + 1);
0041c12a              
0041c12f              if (esi_1)
0041c138                  sub_41b4f0(esi_1, penv, penv_1 - penv + 1);
0041c12f              else
0041c131                  esi_1 = nullptr;
0041c131              
0041c141              FreeEnvironmentStringsA(penv);
0041c147              return esi_1;
0041c043          }
0041c043          
0041c045          data_4309cc = 1;
0041c03b      }
0041c03b      else if (eax != 1)
0041c073      {
0041c0fd          if (eax != 2)
0041c14b              return nullptr;
0041c14b          
0041c0fd          goto label_41c101;
0041c073      }
0041c073      
0041c07b      if (!esi)
0041c07b      {
0041c07f          esi = GetEnvironmentStringsW();
0041c07f          
0041c083          if (!esi)
0041c14b              return nullptr;
0041c07b      }
0041c07b      
0041c08c      PWSTR eax_4 = esi;
0041c08c      
0041c08e      if (*(uint16_t*)esi)
0041c08e      {
0041c091          while (true)
0041c091          {
0041c091              eax_4 = &eax_4[1];
0041c091              
0041c095              if (!*(uint16_t*)eax_4)
0041c095              {
0041c098                  eax_4 = &eax_4[1];
0041c098                  
0041c09c                  if (!*(uint16_t*)eax_4)
0041c09c                      break;
0041c095              }
0041c091          }
0041c08e      }
0041c08e      
0041c0b5      int32_t cbMultiByte = WideCharToMultiByte(0, 0, esi, ((eax_4 - esi) >> 1) + 1, 
0041c0b5          nullptr, 0, nullptr, nullptr);
0041c0b5      
0041c0bb      if (cbMultiByte)
0041c0bb      {
0041c0be          void* lpMultiByteStr = sub_41dbac(cbMultiByte);
0041c0c6          void* lpMultiByteStr_1 = lpMultiByteStr;
0041c0c6          
0041c0ca          if (lpMultiByteStr)
0041c0ca          {
0041c0d7              int32_t eax_10;
0041c0d7              void** ecx_2;
0041c0d7              eax_10 = WideCharToMultiByte(0, 0, esi, ((eax_4 - esi) >> 1) + 1, 
0041c0d7                  lpMultiByteStr, cbMultiByte, nullptr, nullptr);
0041c0d7              
0041c0db              if (!eax_10)
0041c0db              {
0041c0dd                  void* lpMultiByteStr_2 = lpMultiByteStr_1;
0041c0e1                  sub_41784c(ecx_2);
0041c0e7                  lpMultiByteStr_1 = nullptr;
0041c0db              }
0041c0db              
0041c0eb              lpMultiByteStr_3 = lpMultiByteStr_1;
0041c0ca          }
0041c0bb      }
0041c0bb      
0041c0f0      FreeEnvironmentStringsW(esi);
0041c0f6      return lpMultiByteStr_3;
0041c022  }


0041c154    uint32_t sub_41c154()

0041c154  {
0041c165      void* esi = sub_41dbac(0x100);
0041c165      
0041c16a      if (!esi)
0041c16e          sub_41720a(0x1b);
0041c16e      
0041c174      data_430e20 = esi;
0041c17a      data_430f20 = 0x20;
0041c17a      
0041c18c      for (void* i = (char*)esi + 0x100; esi < i; i = data_430e20 + 0x100)
0041c18c      {
0041c18e          *(uint8_t*)((char*)esi + 4) = 0;
0041c192          *(uint32_t*)esi = 0xffffffff;
0041c195          *(uint8_t*)((char*)esi + 5) = 0xa;
0041c19e          esi += 8;
0041c18c      }
0041c18c      
0041c1ad      STARTUPINFOA startupInfo;
0041c1ad      GetStartupInfoA(&startupInfo);
0041c1ad      
0041c1b9      if (startupInfo.cbReserved2)
0041c1b9      {
0041c1bf          BYTE* lpReserved2 = startupInfo.lpReserved2;
0041c1bf          
0041c1c5          if (lpReserved2)
0041c1c5          {
0041c1cb              void* const i_1 = *(uint32_t*)lpReserved2;
0041c1cd              void* ebp_1 = &lpReserved2[4];
0041c1d7              void* ebx_1 = (char*)i_1 + ebp_1;
0041c1d7              
0041c1da              if (i_1 >= 0x800)
0041c1dc                  i_1 = 0x800;
0041c1dc              
0041c1e4              void* j;
0041c1e4              
0041c1e4              if (data_430f20 < i_1)
0041c1e4              {
0041c1e6                  void* edi_1 = &data_430e24;
0041c1e6                  
0041c22e                  do
0041c22e                  {
0041c1f0                      void* eax_2 = sub_41dbac(0x100);
0041c1f0                      
0041c1f8                      if (!eax_2)
0041c1f8                      {
0041c232                          i_1 = data_430f20;
0041c232                          break;
0041c1f8                      }
0041c1f8                      
0041c1fa                      data_430f20 += 0x20;
0041c201                      *(uint32_t*)edi_1 = eax_2;
0041c201                      
0041c20b                      for (j = (char*)eax_2 + 0x100; eax_2 < j; 
0041c20b                          j = *(uint32_t*)edi_1 + 0x100)
0041c20b                      {
0041c20d                          *(uint8_t*)((char*)eax_2 + 4) = 0;
0041c211                          *(uint32_t*)eax_2 = 0xffffffff;
0041c214                          *(uint8_t*)((char*)eax_2 + 5) = 0xa;
0041c21a                          eax_2 += 8;
0041c20b                      }
0041c20b                      
0041c225                      edi_1 += 4;
0041c22e                  } while (data_430f20 < i_1);
0041c1e4              }
0041c1e4              
0041c238              int32_t edi_2 = 0;
0041c238              
0041c23c              if (i_1 > 0)
0041c23c              {
0041c282                  do
0041c282                  {
0041c23e                      HANDLE hFile = *(uint32_t*)ebx_1;
0041c23e                      
0041c243                      if (hFile != 0xffffffff)
0041c243                      {
0041c245                          (uint8_t)j = *(uint8_t*)ebp_1;
0041c245                          
0041c24b                          if ((uint8_t)j & 1)
0041c24b                          {
0041c250                              if ((uint8_t)j & 8)
0041c250                              {
0041c26e                              label_41c26e:
0041c26e                                  void** eax_7 =
0041c26e                                      (&data_430e20)[edi_2 >> 5] + ((edi_2 & 0x1f) << 3);
0041c273                                  *(uint32_t*)eax_7 = *(uint32_t*)ebx_1;
0041c275                                  (uint8_t)j = *(uint8_t*)ebp_1;
0041c278                                  eax_7[1] = (uint8_t)j;
0041c250                              }
0041c250                              else
0041c250                              {
0041c253                                  enum FILE_TYPE eax_3;
0041c253                                  eax_3 = GetFileType(hFile);
0041c253                                  
0041c25b                                  if (eax_3)
0041c25b                                      goto label_41c26e;
0041c250                              }
0041c24b                          }
0041c243                      }
0041c243                      
0041c27b                      edi_2 += 1;
0041c27c                      ebp_1 += 1;
0041c27d                      ebx_1 += 4;
0041c282                  } while (edi_2 < i_1);
0041c23c              }
0041c1c5          }
0041c1b9      }
0041c1b9      
0041c2e9      for (int32_t i_2 = 0; i_2 < 3; i_2 += 1)
0041c2e9      {
0041c286          int32_t eax_8 = data_430e20;
0041c28f          int32_t* esi_1 = eax_8 + (i_2 << 3);
0041c28f          
0041c292          if (*(uint32_t*)(eax_8 + (i_2 << 3)) != 0xffffffff)
0041c2e1              esi_1[1] |= 0x80;
0041c292          else
0041c292          {
0041c296              esi_1[1] = 0x81;
0041c29a              enum STD_HANDLE nStdHandle;
0041c29a              
0041c29a              if (i_2)
0041c29a              {
0041c2a4                  int32_t eax_11 = -((i_2 - 1));
0041c2a8                  nStdHandle = eax_11 - eax_11 - 0xb;
0041c29a              }
0041c29a              else
0041c29e                  nStdHandle = STD_INPUT_HANDLE;
0041c29e              
0041c2ac              HANDLE hFile_1 = GetStdHandle(nStdHandle);
0041c2ac              
0041c2b7              if (hFile_1 == 0xffffffff)
0041c2d0                  esi_1[1] |= 0x40;
0041c2b7              else
0041c2b7              {
0041c2ba                  enum FILE_TYPE eax_13 = GetFileType(hFile_1);
0041c2ba                  
0041c2c2                  if (!eax_13)
0041c2d0                      esi_1[1] |= 0x40;
0041c2c2                  else
0041c2c2                  {
0041c2c4                      int32_t eax_14 = eax_13 & 0xff;
0041c2c9                      *(uint32_t*)esi_1 = hFile_1;
0041c2c9                      
0041c2ce                      if (eax_14 == 2)
0041c2d0                          esi_1[1] |= 0x40;
0041c2ce                      else if (eax_14 == 3)
0041c2db                          esi_1[1] |= 8;
0041c2c2                  }
0041c2b7              }
0041c292          }
0041c2e9      }
0041c2e9      
0041c2fe      return SetHandleCount(data_430f20);
0041c154  }


0041c2ff    HMODULE sub_41c2ff(int32_t* arg1)

0041c2ff  {
0041c306      *(uint32_t*)arg1 = 0;
0041c309      HMODULE result = GetModuleHandleA(nullptr);
0041c309      
0041c314      if (result->unused == 0x5a4d)
0041c314      {
0041c316          int32_t result_1 = result;
0041c316          
0041c31b          if (result_1)
0041c31b          {
0041c31d              result += result_1;
0041c31f              (uint8_t)result_1 = *((char*)result + 0x1a);
0041c322              *(uint8_t*)arg1 = (uint8_t)result_1;
0041c324              (uint8_t)result = *((char*)result + 0x1b);
0041c327              *(uint8_t*)((char*)arg1 + 1) = (uint8_t)result;
0041c31b          }
0041c314      }
0041c314      
0041c32b      return result;
0041c2ff  }


0041c32c    int32_t sub_41c32c()

0041c32c  {
0041c334      sub_425610(0x122c);
0041c33f      int32_t ebx;
0041c33f      int32_t var_8 = ebx;
0041c340      OSVERSIONINFOA var_9c;
0041c340      var_9c.szCSDVersion[0x7c] = &var_9c;
0041c341      var_9c.dwOSVersionInfoSize = 0x94;
0041c341      
0041c365      if (GetVersionExA(var_9c.szCSDVersion[0x7c]) && var_9c.dwPlatformId == 2
0041c365          && var_9c.dwMajorVersion >= 5)
0041c365      {
0041c367          var_9c.szCSDVersion[0x7c] = 1;
0041c367          var_9c.szCSDVersion[0x7d] = 0;
0041c367          var_9c.szCSDVersion[0x7e] = 0;
0041c367          var_9c.szCSDVersion[0x7f] = 0;
0041c369          return 1;
0041c365      }
0041c365      
0041c375      var_9c.szCSDVersion[0x7c] = 0x90;
0041c375      var_9c.szCSDVersion[0x7d] = 0x10;
0041c375      var_9c.szCSDVersion[0x7e] = 0;
0041c375      var_9c.szCSDVersion[0x7f] = 0;
0041c37a      char var_1230;
0041c37a      var_9c.szCSDVersion[0x78] = &var_1230;
0041c37b      var_9c.szCSDVersion[0x74] = 0xe8;
0041c37b      var_9c.szCSDVersion[0x75] = 0x8f;
0041c37b      var_9c.szCSDVersion[0x76] = 0x42;
0041c37b      var_9c.szCSDVersion[0x77] = 0;
0041c37b      
0041c388      if (GetEnvironmentVariableA(var_9c.szCSDVersion[0x74], var_9c.szCSDVersion[0x78], 
0041c388          var_9c.szCSDVersion[0x7c]))
0041c388      {
0041c390          char* ecx_1 = &var_1230;
0041c390          
0041c39c          if (var_1230)
0041c39c          {
0041c3af              do
0041c3af              {
0041c39e                  uint32_t eax_1;
0041c39e                  (uint8_t)eax_1 = *(uint8_t*)ecx_1;
0041c39e                  
0041c3a6                  if ((uint8_t)eax_1 >= 0x61 && (uint8_t)eax_1 <= 0x7a)
0041c3a6                  {
0041c3a8                      (uint8_t)eax_1 -= 0x20;
0041c3aa                      *(uint8_t*)ecx_1 = (uint8_t)eax_1;
0041c3a6                  }
0041c3a6                  
0041c3ac                  ecx_1 = &ecx_1[1];
0041c3af              } while (*(uint8_t*)ecx_1);
0041c39c          }
0041c39c          
0041c3b7          var_9c.szCSDVersion[0x7c] = 0x16;
0041c3b7          var_9c.szCSDVersion[0x7d] = 0;
0041c3b7          var_9c.szCSDVersion[0x7e] = 0;
0041c3b7          var_9c.szCSDVersion[0x7f] = 0;
0041c3b9          var_9c.szCSDVersion[0x78] = &var_1230;
0041c3ba          var_9c.szCSDVersion[0x74] = 0xd0;
0041c3ba          var_9c.szCSDVersion[0x75] = 0x8f;
0041c3ba          var_9c.szCSDVersion[0x76] = 0x42;
0041c3ba          var_9c.szCSDVersion[0x77] = 0;
0041c3c9          char* eax_3;
0041c3c9          
0041c3c9          if (sub_422d40(var_9c.szCSDVersion[0x74], var_9c.szCSDVersion[0x78], 
0041c3c9              var_9c.szCSDVersion[0x7c]))
0041c3c9          {
0041c3d9              var_9c.szCSDVersion[0x7c] = 4;
0041c3d9              var_9c.szCSDVersion[0x7d] = 1;
0041c3d9              var_9c.szCSDVersion[0x7e] = 0;
0041c3d9              var_9c.szCSDVersion[0x7f] = 0;
0041c3de              uint8_t var_1a0[0x104];
0041c3de              var_9c.szCSDVersion[0x78] = &var_1a0;
0041c3df              var_9c.szCSDVersion[0x74] = 0;
0041c3df              var_9c.szCSDVersion[0x75] = 0;
0041c3df              var_9c.szCSDVersion[0x76] = 0;
0041c3df              var_9c.szCSDVersion[0x77] = 0;
0041c3e0              GetModuleFileNameA(var_9c.szCSDVersion[0x74], var_9c.szCSDVersion[0x78], 
0041c3e0                  var_9c.szCSDVersion[0x7c]);
0041c3ec              uint8_t (* ecx_2)[0x104] = &var_1a0;
0041c3ec              
0041c3f2              if (var_1a0[0])
0041c3f2              {
0041c405                  do
0041c405                  {
0041c3f4                      uint8_t eax_4 = *(uint8_t*)ecx_2;
0041c3f4                      
0041c3fc                      if (eax_4 >= 0x61 && eax_4 <= 0x7a)
0041c400                          *(uint8_t*)ecx_2 = eax_4 - 0x20;
0041c400                      
0041c402                      ecx_2 = &(*(uint2080_t*)ecx_2)[1];
0041c405                  } while (*(uint8_t*)ecx_2);
0041c3f2              }
0041c3f2              
0041c40d              var_9c.szCSDVersion[0x7c] = &var_1a0;
0041c414              var_9c.szCSDVersion[0x78] = &var_1230;
0041c415              eax_3 = sub_417260(var_9c.szCSDVersion[0x78], var_9c.szCSDVersion[0x7c]);
0041c41b              int32_t ecx_3;
0041c41b              (uint8_t)ecx_3 = var_9c.szCSDVersion[0x7c];
0041c41b              *(uint8_t*)((char*)ecx_3)[1] = var_9c.szCSDVersion[0x7d];
0041c41b              *(uint8_t*)((char*)ecx_3)[2] = var_9c.szCSDVersion[0x7e];
0041c41b              *(uint8_t*)((char*)ecx_3)[3] = var_9c.szCSDVersion[0x7f];
0041c3c9          }
0041c3c9          else
0041c3cb              eax_3 = &var_1230;
0041c3cb          
0041c41e          if (eax_3)
0041c41e          {
0041c420              var_9c.szCSDVersion[0x7c] = 0x2c;
0041c420              var_9c.szCSDVersion[0x7d] = 0;
0041c420              var_9c.szCSDVersion[0x7e] = 0;
0041c420              var_9c.szCSDVersion[0x7f] = 0;
0041c422              var_9c.szCSDVersion[0x78] = (uint8_t)eax_3;
0041c422              var_9c.szCSDVersion[0x79] = *(uint8_t*)((char*)eax_3)[1];
0041c422              var_9c.szCSDVersion[0x7a] = *(uint8_t*)((char*)eax_3)[2];
0041c422              var_9c.szCSDVersion[0x7b] = *(uint8_t*)((char*)eax_3)[3];
0041c423              void* eax_5 =
0041c423                  sub_4172f0(var_9c.szCSDVersion[0x78], var_9c.szCSDVersion[0x7c]);
0041c42b              int32_t ecx_4;
0041c42b              (uint8_t)ecx_4 = var_9c.szCSDVersion[0x7c];
0041c42b              *(uint8_t*)((char*)ecx_4)[1] = var_9c.szCSDVersion[0x7d];
0041c42b              *(uint8_t*)((char*)ecx_4)[2] = var_9c.szCSDVersion[0x7e];
0041c42b              *(uint8_t*)((char*)ecx_4)[3] = var_9c.szCSDVersion[0x7f];
0041c42b              
0041c42c              if (eax_5)
0041c42c              {
0041c42f                  void* ecx_5 = (char*)eax_5 + 1;
0041c42f                  
0041c433                  if (*(uint8_t*)((char*)eax_5 + 1))
0041c433                  {
0041c441                      do
0041c441                      {
0041c438                          if (*(uint8_t*)ecx_5 != 0x3b)
0041c43e                              ecx_5 += 1;
0041c438                          else
0041c43a                              *(uint8_t*)ecx_5 = 0;
0041c441                      } while (*(uint8_t*)ecx_5);
0041c433                  }
0041c433                  
0041c443                  var_9c.szCSDVersion[0x7c] = 0xa;
0041c443                  var_9c.szCSDVersion[0x7d] = 0;
0041c443                  var_9c.szCSDVersion[0x7e] = 0;
0041c443                  var_9c.szCSDVersion[0x7f] = 0;
0041c445                  var_9c.szCSDVersion[0x78] = 0;
0041c445                  var_9c.szCSDVersion[0x79] = 0;
0041c445                  var_9c.szCSDVersion[0x7a] = 0;
0041c445                  var_9c.szCSDVersion[0x7b] = 0;
0041c446                  var_9c.szCSDVersion[0x74] = ((char*)eax_5 + 1);
0041c446                  var_9c.szCSDVersion[0x75] = *(uint8_t*)((char*)((char*)eax_5 + 1))[1];
0041c446                  var_9c.szCSDVersion[0x76] = *(uint8_t*)((char*)((char*)eax_5 + 1))[2];
0041c446                  var_9c.szCSDVersion[0x77] = *(uint8_t*)((char*)((char*)eax_5 + 1))[3];
0041c447                  int32_t result = sub_417a5a(var_9c.szCSDVersion[0x74], 
0041c447                      var_9c.szCSDVersion[0x78], var_9c.szCSDVersion[0x7c]);
0041c447                  
0041c45c                  if (result == 2 || result == 3 || result == 1)
0041c473                      return result;
0041c42c              }
0041c41e          }
0041c388      }
0041c388      
0041c461      var_9c.szCSDVersion[0x7c] = &var_8;
0041c462      HMODULE eax_7 = sub_41c2ff(var_9c.szCSDVersion[0x7c]);
0041c46b      int32_t ecx_6;
0041c46b      (uint8_t)ecx_6 = var_9c.szCSDVersion[0x7c];
0041c46b      *(uint8_t*)((char*)ecx_6)[1] = var_9c.szCSDVersion[0x7d];
0041c46b      *(uint8_t*)((char*)ecx_6)[2] = var_9c.szCSDVersion[0x7e];
0041c46b      *(uint8_t*)((char*)ecx_6)[3] = var_9c.szCSDVersion[0x7f];
0041c46e      return eax_7 - eax_7 + 3;
0041c32c  }


0041c474    int32_t sub_41c474(int32_t arg1)

0041c474  {
0041c481      enum HEAP_FLAGS flOptions;
0041c481      (uint8_t)flOptions = !arg1;
0041c485      HANDLE eax = HeapCreate(flOptions, 0x1000, 0);
0041c48d      data_430e04 = eax;
0041c48d      
0041c492      if (eax)
0041c492      {
0041c494          int32_t eax_1 = sub_41c32c();
0041c49c          data_430e08 = eax_1;
0041c4a1          void** eax_2;
0041c4a1          
0041c4a1          if (eax_1 != 3)
0041c4a1          {
0041c4b3              if (eax_1 != 2)
0041c4d0                  return 1;
0041c4d0              
0041c4b5              eax_2 = sub_41d4c4();
0041c4a1          }
0041c4a1          else
0041c4a8              eax_2 = sub_41c97d(0x3f8);
0041c4a8          
0041c4bc          if (eax_2)
0041c4d0              return 1;
0041c4d0          
0041c4c4          HeapDestroy(data_430e04);
0041c492      }
0041c492      
0041c4cc      return 0;
0041c474  }

0041c4d1                                                     cc cc cc                                                       ...

0041c4d4    int32_t sub_41c4d4(int32_t arg1)

0041c4d4  {
0041c4d4      int32_t ebp;
0041c4d4      int32_t var_4 = ebp;
0041c4e7      int32_t result = RtlUnwind(arg1, 0x41c4ec, nullptr, nullptr);
0041c4da      var_4;
0041c4f3      return result;
0041c4d4  }


0041c4f4    int32_t sub_41c4f4(int32_t arg1, int32_t arg2, int32_t* arg3)

0041c4f4  {
0041c504      if (!(*(uint32_t*)(arg1 + 4) & 6))
0041c515          return 1;
0041c515      
0041c50e      *(uint32_t*)arg3 = arg2;
0041c510      return 3;
0041c4f4  }


0041c516    void* sub_41c516(void* arg1, int32_t arg2)

0041c516  {
0041c51d      void* var_10 = arg1;
0041c51e      int32_t var_14 = 0xfffffffe;
0041c520      int32_t (* var_18)(int32_t arg1, int32_t arg2, int32_t* arg3) = sub_41c4f4;
0041c525      TEB* fsbase;
0041c525      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
0041c52c      fsbase->NtTib.ExceptionList = &ExceptionList;
0041c52c      
0041c537      while (true)
0041c537      {
0041c537          int32_t ebx_1 = *(uint32_t*)((char*)arg1 + 8);
0041c53a          int32_t esi_1 = *(uint32_t*)((char*)arg1 + 0xc);
0041c53a          
0041c546          if (esi_1 == 0xffffffff || esi_1 == arg2)
0041c546          {
0041c570              fsbase->NtTib.ExceptionList = ExceptionList;
0041c57d              return arg1;
0041c546          }
0041c546          
0041c548          int32_t esi_2 = esi_1 * 3;
0041c54b          int32_t ecx_1 = *(uint32_t*)(ebx_1 + (esi_2 << 2));
0041c54e          int32_t var_14_1 = ecx_1;
0041c552          *(uint32_t*)((char*)arg1 + 0xc) = ecx_1;
0041c552          
0041c55a          if (!*(uint32_t*)(ebx_1 + (esi_2 << 2) + 4))
0041c55a          {
0041c55c              int32_t var_20_1 = 0x101;
0041c565              void* ebp;
0041c565              sub_41c5aa(*(uint32_t*)(ebx_1 + (esi_2 << 2) + 8), ebp);
0041c56a              (*(uint32_t*)(ebx_1 + (esi_2 << 2) + 8))();
0041c55a          }
0041c537      }
0041c516  }


0041c57e    int32_t __abnormal_termination()

0041c57e  {
0041c580      TEB* fsbase;
0041c580      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
0041c580      
0041c599      if (ExceptionList->Handler == sub_41c4f4 && *(int32_t*)((char*)ExceptionList + 8)
0041c599              == *(uint32_t*)(*(int32_t*)((char*)ExceptionList + 0xc) + 0xc))
0041c59b          return 1;
0041c59b      
0041c5a0      return 0;
0041c57e  }

0041c5a1     53 51 bb ec d4 42 00 eb 0a                                                                     SQ...B...

0041c5aa    void __convention("regparm") sub_41c5aa(int32_t arg1, void* arg2 @ ebp)

0041c5aa  {
0041c5b4      data_42d4f4 = *(uint32_t*)((char*)arg2 + 8);
0041c5b7      data_42d4f0 = arg1;
0041c5ba      data_42d4f8 = arg2;
0041c5aa  }

0041c5c2        cc cc                                                                                        ..

0041c5c4    int32_t __convention("regparm") $$000000(char* arg1, int16_t arg2, void* arg3, void* arg4, int32_t arg5)

0041c5c4  {
0041c5c4      char* esi;
0041c5c4      char* var_4 = esi;
0041c5c6      *(uint8_t*)((char*)arg2)[1] ^= *(uint8_t*)arg1;
0041c5c8      char* eax = var_4;
0041c5ca      *(uint8_t*)eax ^= *(uint8_t*)((char*)arg2)[1];
0041c5cc      char* ebp;
0041c5cc      var_4 = ebp;
0041c5cd      char** ebp_1 = &var_4;
0041c5d2      int32_t entry_ebx;
0041c5d2      int32_t var_10 = entry_ebx + 2;
0041c5d3      char* var_14 = esi;
0041c5d5      char** var_1c = &var_4;
0041c5d7      void* ebx_2 = arg4;
0041c5e4      int32_t result;
0041c5e4      
0041c5e4      if (*(uint32_t*)((char*)arg3 + 4) & 6)
0041c5e4      {
0041c66c          char** var_20_5 = &var_4;
0041c673          sub_41c516(ebx_2, 0xffffffff);
0041c67c          result = 1;
0041c5e4      }
0041c5e4      else
0041c5e4      {
0041c5ea          void* var_c = arg3;
0041c5f0          int32_t var_8_1 = arg5;
0041c5f6          *(uint32_t*)((char*)ebx_2 - 4) = &var_c;
0041c5f9          int32_t esi_1 = *(uint32_t*)((char*)ebx_2 + 0xc);
0041c5fc          int32_t edi_1 = *(uint32_t*)((char*)ebx_2 + 8);
0041c5fc          
0041c602          while (true)
0041c602          {
0041c602              if (esi_1 == 0xffffffff)
0041c602              {
0041c665                  result = 1;
0041c66a                  break;
0041c602              }
0041c602              
0041c604              int32_t ecx_1 = esi_1 * 3;
0041c604              
0041c60c              if (*(uint32_t*)(edi_1 + (ecx_1 << 2) + 4))
0041c60c              {
0041c613                  int32_t eax_3 =
0041c613                      (*(uint32_t*)(edi_1 + (ecx_1 << 2) + 4))(ebp_1, esi_1, var_1c);
0041c619                  ebx_2 = ebp_1[3];
0041c619                  
0041c61e                  if (eax_3)
0041c61e                  {
0041c620                      if (eax_3 < 0)
0041c620                      {
0041c65e                          result = 0;
0041c663                          break;
0041c620                      }
0041c620                      
0041c622                      int32_t edi_2 = *(uint32_t*)((char*)ebx_2 + 8);
0041c626                      sub_41c4d4(ebx_2);
0041c62e                      ebp_1 = (char*)ebx_2 + 0x10;
0041c633                      sub_41c516(ebx_2, esi_1);
0041c63b                      int32_t ecx_2 = esi_1 * 3;
0041c63e                      int32_t var_20_4 = 1;
0041c644                      sub_41c5aa(*(uint32_t*)(edi_2 + (ecx_2 << 2) + 8), ebp_1);
0041c64c                      *(uint32_t*)((char*)ebx_2 + 0xc) = *(uint32_t*)(edi_2 + (ecx_2 << 2));
0041c64f                      (*(uint32_t*)(edi_2 + (ecx_2 << 2) + 8))();
0041c61e                  }
0041c60c              }
0041c60c              
0041c653              edi_1 = *(uint32_t*)((char*)ebx_2 + 8);
0041c659              esi_1 = *(uint32_t*)(edi_1 + esi_1 * 0xc);
0041c602          }
0041c5e4      }
0041c5e4      
0041c687      *(uint32_t*)var_1c;
0041c688      return result;
0041c5c4  }


0041c689    void* __stdcall __seh_longjmp_unwind@4(int32_t* arg1)

0041c689  {
0041c68e      *(uint32_t*)arg1;
0041c6a1      return sub_41c516(arg1[6], arg1[7]);
0041c689  }


0041c6a4    void* sub_41c6a4()

0041c6a4  {
0041c6a4      void* result = data_430828;
0041c6a4      
0041c6ac      if (result == 1)
0041c6ac      {
0041c6c0      label_41c6c0:
0041c6c0          sub_41c6dd(0xfc);
0041c6c5          int32_t eax = data_4309d0;
0041c6c5          
0041c6cd          if (eax)
0041c6cf              eax();
0041c6cf          
0041c6d6          result = sub_41c6dd(0xff);
0041c6ac      }
0041c6ac      else if (!result && data_42cbe4 == 1)
0041c6b9          goto label_41c6c0;
0041c6b9      
0041c6dc      return result;
0041c6a4  }


0041c6dd    void* sub_41c6dd(uint32_t arg1)

0041c6dd  {
0041c6e6      uint32_t i = arg1;
0041c6e9      int32_t ecx = 0;
0041c6eb      void* result = &data_42d500;
0041c6eb      
0041c6f2      while (i != *(uint32_t*)result)
0041c6f2      {
0041c6f4          result += 8;
0041c6f7          ecx += 1;
0041c6f7          
0041c6fd          if (result >= &data_42d590)
0041c6fd              break;
0041c6f2      }
0041c6f2      
0041c70b      if (i == *(uint32_t*)((ecx << 3) + &data_42d500))
0041c70b      {
0041c711          result = data_430828;
0041c711          
0041c719          if (result == 1)
0041c719          {
0041c810          label_41c810:
0041c810              OVERLAPPED* __saved_edi_3 = nullptr;
0041c812              uint32_t* lpNumberOfBytesWritten = &arg1;
0041c81b              uint32_t nNumberOfBytesToWrite = sub_41e7d0((&data_42d504)[ecx * 2]);
0041c827              return WriteFile(GetStdHandle(STD_ERROR_HANDLE), (&data_42d504)[ecx * 2], 
0041c827                  nNumberOfBytesToWrite, lpNumberOfBytesWritten, __saved_edi_3);
0041c719          }
0041c719          
0041c72a          if (!result && data_42cbe4 == 1)
0041c72a              goto label_41c810;
0041c72a          
0041c736          if (i != 0xfc)
0041c736          {
0041c752              void filename;
0041c752              
0041c752              if (!GetModuleFileNameA(nullptr, &filename, 0x104))
0041c760                  sub_41b8c0(&filename, "<program name unknown>");
0041c760              
0041c76f              void* edi_1 = &filename;
0041c76f              
0041c77f              if (sub_41e7d0(&filename) + 1 > 0x3c)
0041c77f              {
0041c798                  int32_t var_1b8_2 = 3;
0041c79a                  void var_1e3;
0041c79a                  edi_1 = sub_41e7d0(&filename) + &var_1e3;
0041c7a2                  sub_417ef0(edi_1, "...", var_1b8_2);
0041c77f              }
0041c77f              
0041c7b6              char var_a4[0xa0];
0041c7b6              sub_41b8c0(&var_a4, "Runtime Error!\n\nProgram: ");
0041c7c3              sub_41b8d0(&var_a4, edi_1);
0041c7d4              sub_41b8d0(&var_a4, "\n\n");
0041c7e6              sub_41b8d0(&var_a4, (&data_42d504)[ecx * 2]);
0041c7fc              return sub_42563f(&var_a4, "Microsoft Visual C++ Runtime Library", 0x12010);
0041c736          }
0041c70b      }
0041c70b      
0041c82f      return result;
0041c6dd  }


0041c830    int32_t sub_41c830(int32_t* arg1)

0041c830  {
0041c830      data_43082c += 1;
0041c83b      void* eax = sub_41dbac(0x1000);
0041c847      arg1[2] = eax;
0041c847      
0041c84a      if (!eax)
0041c84a      {
0041c859          arg1[3] |= 4;
0041c860          arg1[2] = &arg1[5];
0041c863          arg1[6] = 2;
0041c84a      }
0041c84a      else
0041c84a      {
0041c84c          arg1[3] |= 8;
0041c850          arg1[6] = 0x1000;
0041c84a      }
0041c84a      
0041c86a      int32_t result = arg1[2];
0041c86d      arg1[1] = 0;
0041c871      *(uint32_t*)arg1 = result;
0041c873      return result;
0041c830  }


0041c874    void* sub_41c874(uint32_t arg1, int32_t arg2)

0041c874  {
0041c87b      uint32_t dwBytes = arg1 * arg2;
0041c883      arg1 = dwBytes;
0041c883      
0041c886      if (dwBytes <= 0xffffffe0)
0041c886      {
0041c88a          if (!dwBytes)
0041c88e              dwBytes = 1;
0041c88e          
0041c892          dwBytes = (dwBytes + 0xf) & 0xfffffff0;
0041c886      }
0041c886      
0041c906      bool cond:1_1;
0041c906      
0041c906      do
0041c906      {
0041c89a          if (dwBytes <= 0xffffffe0)
0041c89a          {
0041c89c              int32_t eax_1 = data_430e08;
0041c8a4              void* result;
0041c8a4              
0041c8a4              if (eax_1 != 3)
0041c8a4              {
0041c8cb                  if (eax_1 == 2 && dwBytes <= data_42f5b4)
0041c8cb                  {
0041c8d8                      result = sub_41d7bc(dwBytes >> 4);
0041c8d8                      
0041c8dd                      if (result)
0041c8dd                      {
0041c910                          sub_423620(result, 0, dwBytes);
0041c918                          return result;
0041c8dd                      }
0041c8cb                  }
0041c8a4              }
0041c8a4              else if (arg1 <= data_430e00)
0041c8af              {
0041c8b7                  result = sub_41cd19(arg1);
0041c8b7                  
0041c8bc                  if (result)
0041c8bc                  {
0041c910                      sub_423620(result, 0, arg1);
0041c918                      return result;
0041c8bc                  }
0041c8af              }
0041c8af              
0041c8ee              result = HeapAlloc(data_430e04, HEAP_ZERO_MEMORY, dwBytes);
0041c8ee              
0041c8f2              if (result || !data_4309dc)
0041c918                  return result;
0041c89a          }
0041c89a          else if (!data_4309dc)
0041c918              return nullptr;
0041c918          
0041c903          cond:1_1 = !sub_41db91(dwBytes);
0041c906      } while (!cond:1_1);
0041c921      return nullptr;
0041c874  }


0041c925    int32_t sub_41c925()

0041c925  {
0041c929      int32_t result = 0;
0041c92b      int32_t i = 3;
0041c92b      
0041c932      if (data_431f40 > 3)
0041c932      {
0041c976          do
0041c976          {
0041c939              int32_t* eax_2 = *(uint32_t*)(data_430f2c + (i << 2));
0041c939              
0041c93e              if (eax_2)
0041c93e              {
0041c944                  int32_t* ecx;
0041c944                  
0041c944                  if (eax_2[3] & 0x83)
0041c944                  {
0041c94f                      ecx = eax_2;
0041c94f                      
0041c950                      if (sub_416e00(eax_2) != 0xffffffff)
0041c952                          result += 1;
0041c944                  }
0041c944                  
0041c956                  if (i >= 0x14)
0041c956                  {
0041c95d                      int32_t* var_c_2 = *(uint32_t*)(data_430f2c + (i << 2));
0041c960                      sub_41784c(ecx);
0041c96a                      ecx = var_c_2;
0041c96b                      *(uint32_t*)(data_430f2c + (i << 2)) = 0;
0041c956                  }
0041c93e              }
0041c93e              
0041c96f              i += 1;
0041c976          } while (i < data_431f40);
0041c932      }
0041c932      
0041c97c      return result;
0041c925  }


0041c97d    int32_t sub_41c97d(int32_t arg1)

0041c97d  {
0041c98a      int32_t result = HeapAlloc(data_430e04, HEAP_NONE, 0x140);
0041c992      data_430dfc = result;
0041c992      
0041c997      if (!result)
0041c999          return result;
0041c999      
0041c99e      data_430df4 = 0;
0041c9a5      data_430df8 = 0;
0041c9ae      data_430df0 = result;
0041c9b3      data_430e00 = arg1;
0041c9b9      data_430de8 = 0x10;
0041c9c4      return 1;
0041c97d  }


0041c9c5    void* sub_41c9c5(int32_t arg1)

0041c9c5  {
0041c9cd      void* result = data_430dfc;
0041c9d2      void* ecx_1 = (char*)result + data_430df8 * 0x14;
0041c9d2      
0041c9d7      while (true)
0041c9d7      {
0041c9d7          if (result >= ecx_1)
0041c9ed              return nullptr;
0041c9ed          
0041c9e6          if (arg1 - *(uint32_t*)((char*)result + 0xc) < 0x100000)
0041c9e6              break;
0041c9e6          
0041c9e8          result += 0x14;
0041c9d7      }
0041c9d7      
0041c9ef      return result;
0041c9c5  }


0041c9f0    int32_t* sub_41c9f0(void* arg1, int32_t* arg2)

0041c9f0  {
0041c9fe      int32_t* result = *(uint32_t*)((char*)arg1 + 0x10);
0041ca04      int32_t* esi_1 = &arg2[-1];
0041ca0a      uint32_t edi_2 = ((char*)arg2 - *(uint32_t*)((char*)arg1 + 0xc)) >> 0xf;
0041ca21      int32_t* ecx_5 = *(uint32_t*)esi_1 - 1;
0041ca25      int32_t* var_8 = ecx_5;
0041ca25      
0041ca28      if (!((uint8_t)ecx_5 & 1))
0041ca28      {
0041ca2e          int32_t edx_1 = *(uint32_t*)((char*)ecx_5 + esi_1);
0041ca31          int32_t* ebx_1 = (char*)ecx_5 + esi_1;
0041ca37          int32_t edx_2 = esi_1[-1];
0041ca43          arg2 = ebx_1;
0041ca43          
0041ca46          if (!((uint8_t)edx_1 & 1))
0041ca46          {
0041ca4b              int32_t edx_5 = (edx_1 >> 4) - 1;
0041ca4b              
0041ca4f              if (edx_5 > 0x3f)
0041ca53                  edx_5 = 0x3f;
0041ca53              
0041ca5a              int32_t* ecx_13;
0041ca5a              
0041ca5a              if (ebx_1[1] != ebx_1[2])
0041caa8                  ecx_13 = var_8;
0041ca5a              else
0041ca5a              {
0041ca5f                  if (edx_5 >= 0x20)
0041ca5f                  {
0041ca8d                      uint32_t ebx_5 = ~(0x80000000 >> ((uint8_t)edx_5 - 0x20));
0041ca8f                      result[edi_2 + 0x31] &= ebx_5;
0041ca96                      char temp0_1 = *(uint8_t*)(edx_5 + result + 4);
0041ca96                      *(uint8_t*)(edx_5 + result + 4) -= 1;
0041ca96                      
0041ca98                      if (temp0_1 == 1)
0041ca9d                          *(uint32_t*)((char*)arg1 + 4) &= ebx_5;
0041ca5f                  }
0041ca5f                  else
0041ca5f                  {
0041ca6e                      uint32_t ebx_3 = ~(0x80000000 >> (uint8_t)edx_5);
0041ca70                      result[edi_2 + 0x11] &= ebx_3;
0041ca74                      char temp1_1 = *(uint8_t*)(edx_5 + result + 4);
0041ca74                      *(uint8_t*)(edx_5 + result + 4) -= 1;
0041ca74                      
0041ca76                      if (temp1_1 == 1)
0041ca76                      {
0041ca78                          int32_t* ecx_9 = arg1;
0041ca7b                          *(uint32_t*)ecx_9 &= ebx_3;
0041ca76                      }
0041ca5f                  }
0041ca5f                  
0041caa0                  ecx_13 = var_8;
0041caa3                  ebx_1 = arg2;
0041ca5a              }
0041ca5a              
0041cab1              ecx_5 = (char*)ecx_13 + edx_1;
0041cab4              *(uint32_t*)(ebx_1[2] + 4) = ebx_1[1];
0041caba              var_8 = ecx_5;
0041cac3              *(uint32_t*)(arg2[1] + 8) = arg2[2];
0041ca46          }
0041ca46          
0041cacb          int32_t edx_11 = (ecx_5 >> 4) - 1;
0041cacb          
0041cacf          if (edx_11 > 0x3f)
0041cad3              edx_11 = 0x3f;
0041cad3          
0041cad7          int32_t ebx_9 = edx_2 & 1;
0041cadd          void* ebx_12;
0041cadd          
0041cadd          if (ebx_9)
0041cb77              ebx_12 = arg1;
0041cadd          else
0041cadd          {
0041caee              arg2 = (char*)esi_1 - edx_2;
0041caf1              ebx_12 = (edx_2 >> 4) - 1;
0041caf1              
0041caf5              if (ebx_12 > 0x3f)
0041caf7                  ebx_12 = 0x3f;
0041caf7              
0041caf9              int32_t* ecx_14 = (char*)ecx_5 + edx_2;
0041cafe              var_8 = ecx_14;
0041cb04              edx_11 = (ecx_14 >> 4) - 1;
0041cb04              
0041cb07              if (edx_11 > 0x3f)
0041cb09                  edx_11 = 0x3f;
0041cb09              
0041cb0d              if (ebx_12 != edx_11)
0041cb0d              {
0041cb18                  if (arg2[1] == arg2[2])
0041cb18                  {
0041cb1d                      if (ebx_12 >= 0x20)
0041cb1d                      {
0041cb45                          uint32_t esi_7 = ~(0x80000000 >> ((uint8_t)ebx_12 - 0x20));
0041cb47                          result[edi_2 + 0x31] &= esi_7;
0041cb4e                          char temp3_1 = *(uint8_t*)((char*)ebx_12 + result + 4);
0041cb4e                          *(uint8_t*)((char*)ebx_12 + result + 4) -= 1;
0041cb4e                          
0041cb52                          if (temp3_1 == 1)
0041cb57                              *(uint32_t*)((char*)arg1 + 4) &= esi_7;
0041cb1d                      }
0041cb1d                      else
0041cb1d                      {
0041cb28                          uint32_t esi_5 = ~(0x80000000 >> (uint8_t)ebx_12);
0041cb2a                          result[edi_2 + 0x11] &= esi_5;
0041cb2e                          char temp4_1 = *(uint8_t*)((char*)ebx_12 + result + 4);
0041cb2e                          *(uint8_t*)((char*)ebx_12 + result + 4) -= 1;
0041cb2e                          
0041cb32                          if (temp4_1 == 1)
0041cb32                          {
0041cb34                              int32_t* ecx_17 = arg1;
0041cb37                              *(uint32_t*)ecx_17 &= esi_5;
0041cb32                          }
0041cb1d                      }
0041cb18                  }
0041cb18                  
0041cb63                  *(uint32_t*)(arg2[2] + 4) = arg2[1];
0041cb6f                  *(uint32_t*)(arg2[1] + 8) = arg2[2];
0041cb0d              }
0041cb0d              
0041cb72              esi_1 = arg2;
0041cadd          }
0041cadd          
0041cb82          if (ebx_9 || ebx_12 != edx_11)
0041cb82          {
0041cb8f              void* ecx_25 = &result[edi_2 * 0x81 + 0x51 + edx_11 * 2];
0041cb92              esi_1[1] = result[edi_2 * 0x81 + 0x51 + edx_11 * 2 + 1];
0041cb95              esi_1[2] = ecx_25;
0041cb98              *(uint32_t*)((char*)ecx_25 + 4) = esi_1;
0041cb9e              *(uint32_t*)(esi_1[1] + 8) = esi_1;
0041cb9e              
0041cba7              if (esi_1[1] == esi_1[2])
0041cba7              {
0041cba9                  int32_t ecx_27;
0041cba9                  (uint8_t)ecx_27 = *(uint8_t*)(edx_11 + result + 4);
0041cbb0                  *(uint8_t*)((char*)arg2)[3] = (uint8_t)ecx_27;
0041cbb3                  (uint8_t)ecx_27 += 1;
0041cbb5                  *(uint8_t*)(edx_11 + result + 4) = (uint8_t)ecx_27;
0041cbb5                  
0041cbb9                  if (edx_11 >= 0x20)
0041cbb9                  {
0041cbe4                      if (!*(uint8_t*)((char*)arg2)[3])
0041cbf3                          *(uint32_t*)((char*)arg1 + 4) |=
0041cbf3                              0x80000000 >> ((uint8_t)edx_11 - 0x20);
0041cbf3                      
0041cc07                      result[edi_2 + 0x31] |= 0x80000000 >> ((uint8_t)edx_11 - 0x20);
0041cbb9                  }
0041cbb9                  else
0041cbb9                  {
0041cbbf                      if (!*(uint8_t*)((char*)arg2)[3])
0041cbbf                      {
0041cbca                          int32_t* ecx_29 = arg1;
0041cbcd                          *(uint32_t*)ecx_29 |= 0x80000000 >> (uint8_t)edx_11;
0041cbbf                      }
0041cbbf                      
0041cbdc                      result[edi_2 + 0x11] |= 0x80000000 >> (uint8_t)edx_11;
0041cbb9                  }
0041cba7              }
0041cb82          }
0041cb82          
0041cc0c          *(uint32_t*)esi_1 = var_8;
0041cc0e          *(uint32_t*)((char*)var_8 + esi_1 - 4) = var_8;
0041cc12          result = &result[edi_2 * 0x81 + 0x51];
0041cc15          int32_t temp2_1 = *(uint32_t*)result;
0041cc15          *(uint32_t*)result -= 1;
0041cc15          
0041cc17          if (temp2_1 == 1)
0041cc17          {
0041cc1d              int32_t eax_3 = data_430df4;
0041cc1d              
0041cc24              if (eax_3)
0041cc24              {
0041cc48                  VirtualFree((data_430dec << 0xf) + *(uint32_t*)(eax_3 + 0xc), 0x8000, 
0041cc48                      MEM_DECOMMIT);
0041cc50                  void* eax_4 = data_430df4;
0041cc5c                  *(uint32_t*)((char*)eax_4 + 8) |= 0x80000000 >> (char)data_430dec;
0041cc6d                  *(uint32_t*)(*(uint32_t*)(data_430df4 + 0x10) + (data_430dec << 2)
0041cc6d                      + 0xc4) = 0;
0041cc7a                  void* eax_8 = *(uint32_t*)(data_430df4 + 0x10);
0041cc7d                  *(uint8_t*)((char*)eax_8 + 0x43) -= 1;
0041cc80                  void* eax_9 = data_430df4;
0041cc80                  
0041cc8c                  if (!*(uint8_t*)(*(uint32_t*)((char*)eax_9 + 0x10) + 0x43))
0041cc8c                  {
0041cc8e                      *(uint32_t*)((char*)eax_9 + 4) &= 0xfffffffe;
0041cc92                      eax_9 = data_430df4;
0041cc8c                  }
0041cc8c                  
0041cc9b                  if (*(uint32_t*)((char*)eax_9 + 8) == 0xffffffff)
0041cc9b                  {
0041cca3                      VirtualFree(*(uint32_t*)((char*)eax_9 + 0xc), 0, MEM_RELEASE);
0041ccb5                      HeapFree(data_430e04, HEAP_NONE, *(uint32_t*)(data_430df4 + 0x10));
0041ccce                      char* eax_14 = data_430df4;
0041ccdf                      sub_424ef0(eax_14, &eax_14[0x14], 
0041ccdf                          data_430df8 * 0x14 - eax_14 + data_430dfc - 0x14);
0041ccea                      data_430df8 -= 1;
0041ccea                      
0041ccf6                      if (arg1 > data_430df4)
0041ccf8                          arg1 -= 0x14;
0041ccf8                      
0041cd01                      data_430df0 = data_430dfc;
0041cc9b                  }
0041cc24              }
0041cc24              
0041cd06              result = arg1;
0041cd09              data_430dec = edi_2;
0041cd0f              data_430df4 = result;
0041cc17          }
0041ca28      }
0041ca28      
0041cd18      return result;
0041c9f0  }


0041cd19    void* sub_41cd19(int32_t* arg1)

0041cd19  {
0041cd24      int32_t* edx = data_430dfc;
0041cd30      void* edi = &edx[data_430df8 * 5];
0041cd3c      void* ecx_1 = ((char*)arg1 + 0x17) & 0xfffffff0;
0041cd49      uint32_t var_10;
0041cd49      uint32_t var_c;
0041cd49      uint32_t esi;
0041cd49      
0041cd49      if ((ecx_1 >> 4) - 1 >= 0x20)
0041cd49      {
0041cd5f          esi = 0;
0041cd63          var_10 = 0;
0041cd66          var_c = 0xffffffff >> (((ecx_1 >> 4) - 1) - 0x20);
0041cd49      }
0041cd49      else
0041cd49      {
0041cd4e          esi = 0xffffffff >> ((ecx_1 >> 4) - 1);
0041cd50          var_c = 0xffffffff;
0041cd54          var_10 = esi;
0041cd49      }
0041cd49      
0041cd69      int32_t* eax_4 = data_430df0;
0041cd6e      int32_t* ebx = eax_4;
0041cd72      arg1 = ebx;
0041cd72      
0041cd75      if (ebx < edi)
0041cd75      {
0041cd83          while (!((ebx[1] & var_c) | (*(uint32_t*)ebx & esi)))
0041cd83          {
0041cd85              ebx = &ebx[5];
0041cd8b              arg1 = ebx;
0041cd8b              
0041cd8e              if (ebx >= edi)
0041cd8e                  break;
0041cd83          }
0041cd75      }
0041cd75      
0041cd93      if (ebx == edi)
0041cd93      {
0041cd95          ebx = edx;
0041cd97          bool cond:4_1;
0041cd97          
0041cd97          while (true)
0041cd97          {
0041cd97              cond:4_1 = ebx != eax_4;
0041cd99              arg1 = ebx;
0041cd99              
0041cd9c              if (ebx >= eax_4)
0041cd9c                  break;
0041cd9c              
0041cdaa              if ((ebx[1] & var_c) | (*(uint32_t*)ebx & esi))
0041cdaa              {
0041cdb1                  cond:4_1 = ebx != eax_4;
0041cdb1                  break;
0041cdaa              }
0041cdaa              
0041cdac              ebx = &ebx[5];
0041cd97          }
0041cd97          
0041cdb3          if (!cond:4_1)
0041cdb3          {
0041cdb5              bool cond:5_1;
0041cdb5              
0041cdb5              while (true)
0041cdb5              {
0041cdb5                  cond:5_1 = ebx != edi;
0041cdb5                  
0041cdb8                  if (ebx >= edi)
0041cdb8                      break;
0041cdb8                  
0041cdbe                  if (ebx[2])
0041cdbe                  {
0041cdc8                      cond:5_1 = ebx != edi;
0041cdc8                      break;
0041cdbe                  }
0041cdbe                  
0041cdc0                  ebx = &ebx[5];
0041cdc3                  arg1 = ebx;
0041cdb5              }
0041cdb5              
0041cdcb              if (!cond:5_1)
0041cdcb              {
0041cdcd                  ebx = edx;
0041cdcf                  bool cond:7_1;
0041cdcf                  
0041cdcf                  while (true)
0041cdcf                  {
0041cdcf                      cond:7_1 = ebx != eax_4;
0041cdd1                      arg1 = ebx;
0041cdd1                      
0041cdd4                      if (ebx >= eax_4)
0041cdd4                          break;
0041cdd4                      
0041cdda                      if (ebx[2])
0041cdda                      {
0041cde1                          cond:7_1 = ebx != eax_4;
0041cde1                          break;
0041cdda                      }
0041cdda                      
0041cddc                      ebx = &ebx[5];
0041cdcf                  }
0041cdcf                  
0041cde3                  if (!cond:7_1)
0041cde3                  {
0041cdea                      ebx = sub_41d022();
0041cdee                      arg1 = ebx;
0041cdee                      
0041cdf1                      if (!ebx)
0041ce07                          return nullptr;
0041cde3                  }
0041cdcb              }
0041cdcb              
0041cdfd              *(uint32_t*)ebx[4] = sub_41d0d3(ebx);
0041cdfd              
0041ce05              if (*(uint32_t*)ebx[4] == 0xffffffff)
0041ce07                  return nullptr;
0041cdb3          }
0041cd93      }
0041cd93      
0041ce0e      data_430df0 = ebx;
0041ce14      int32_t* eax_8 = ebx[4];
0041ce17      int32_t edx_1 = *(uint32_t*)eax_8;
0041ce1c      int32_t var_8_1 = edx_1;
0041ce1c      
0041ce33      if (edx_1 == 0xffffffff
0041ce33          || !((eax_8[edx_1 + 0x31] & var_c) | (eax_8[edx_1 + 0x11] & esi)))
0041ce33      {
0041ce44          var_8_1 = 0;
0041ce48          void* ecx_15 = &eax_8[0x11];
0041ce4d          esi = var_10;
0041ce4d          
0041ce50          if (!((eax_8[0x31] & var_c) | (eax_8[0x11] & var_10)))
0041ce50          {
0041ce67              int32_t edx_6;
0041ce67              
0041ce67              do
0041ce67              {
0041ce58                  var_8_1 += 1;
0041ce5b                  edx_6 = *(uint32_t*)((char*)ecx_15 + 0x84) & var_c;
0041ce5e                  ecx_15 += 4;
0041ce67              } while (!(edx_6 | (esi & *(uint32_t*)ecx_15)));
0041ce50          }
0041ce50          
0041ce69          edx_1 = var_8_1;
0041ce33      }
0041ce33      
0041ce6e      int32_t edi_9 = 0;
0041ce84      int32_t i = eax_8[edx_1 + 0x11] & esi;
0041ce84      
0041ce86      if (!i)
0041ce86      {
0041ce91          i = eax_8[edx_1 + 0x31] & var_c;
0041ce94          edi_9 = 0x20;
0041ce86      }
0041ce86      
0041ce97      while (i >= 0)
0041ce97      {
0041ce99          i <<= 1;
0041ce9b          edi_9 += 1;
0041ce97      }
0041ce97      
0041cea1      int32_t* edx_8 = eax_8[edx_1 * 0x81 + 0x51 + edi_9 * 2 + 1];
0041cea7      void* ecx_23 = *(uint32_t*)edx_8 - ecx_1;
0041ceb2      int32_t esi_5 = (ecx_23 >> 4) - 1;
0041ceb2      
0041ceb6      if (esi_5 > 0x3f)
0041ceba          esi_5 = 0x3f;
0041ceba      
0041cebd      if (esi_5 == edi_9)
0041cebd      {
0041cfd0      label_41cfd0:
0041cfd0          
0041cfd2          if (ecx_23)
0041cfd2          {
0041cfd4              *(uint32_t*)edx_8 = ecx_23;
0041cfd6              *(uint32_t*)((char*)ecx_23 + edx_8 - 4) = ecx_23;
0041cfd2          }
0041cebd      }
0041cebd      else
0041cebd      {
0041cec9          if (edx_8[1] == edx_8[2])
0041cec9          {
0041cece              if (edi_9 >= 0x20)
0041cece              {
0041cf13                  uint32_t ebx_5 = ~(0x80000000 >> ((uint8_t)edi_9 - 0x20));
0041cf15                  eax_8[var_8_1 + 0x31] &= ebx_5;
0041cf17                  char temp1_1 = *(uint8_t*)((char*)eax_8 + edi_9 + 4);
0041cf17                  *(uint8_t*)((char*)eax_8 + edi_9 + 4) -= 1;
0041cf17                  
0041cf1c                  if (temp1_1 != 1)
0041cf29                      ebx = arg1;
0041cf1c                  else
0041cf1c                  {
0041cf1e                      ebx = arg1;
0041cf24                      ebx[1] &= ebx_5;
0041cf1c                  }
0041cece              }
0041cece              else
0041cece              {
0041cee0                  uint32_t ebx_2 = ~(0x80000000 >> (uint8_t)edi_9);
0041cee9                  eax_8[var_8_1 + 0x11] &= ebx_2;
0041ceed                  char temp2_1 = *(uint8_t*)((char*)eax_8 + edi_9 + 4);
0041ceed                  *(uint8_t*)((char*)eax_8 + edi_9 + 4) -= 1;
0041ceed                  
0041ceef                  if (temp2_1 != 1)
0041cf29                      ebx = arg1;
0041ceef                  else
0041ceef                  {
0041cef1                      ebx = arg1;
0041cef7                      *(uint32_t*)ebx &= ebx_2;
0041ceef                  }
0041cece              }
0041cec9          }
0041cec9          
0041cf36          *(uint32_t*)(edx_8[2] + 4) = edx_8[1];
0041cf3f          *(uint32_t*)(edx_8[1] + 8) = edx_8[2];
0041cf3f          
0041cf42          if (ecx_23)
0041cf42          {
0041cf4f              void* ecx_35 = &eax_8[edx_1 * 0x81 + 0x51 + esi_5 * 2];
0041cf52              edx_8[1] = eax_8[edx_1 * 0x81 + 0x51 + esi_5 * 2 + 1];
0041cf55              edx_8[2] = ecx_35;
0041cf58              *(uint32_t*)((char*)ecx_35 + 4) = edx_8;
0041cf5e              *(uint32_t*)(edx_8[1] + 8) = edx_8;
0041cf5e              
0041cf67              if (edx_8[1] == edx_8[2])
0041cf67              {
0041cf69                  int32_t ecx_37;
0041cf69                  (uint8_t)ecx_37 = *(uint8_t*)(esi_5 + eax_8 + 4);
0041cf70                  *(uint8_t*)((char*)arg1)[3] = (uint8_t)ecx_37;
0041cf70                  
0041cf73                  if (esi_5 >= 0x20)
0041cf73                  {
0041cf9e                      (uint8_t)ecx_37 += 1;
0041cfa4                      *(uint8_t*)(esi_5 + eax_8 + 4) = (uint8_t)ecx_37;
0041cfa4                      
0041cfa8                      if (!*(uint8_t*)((char*)arg1)[3])
0041cfb4                          ebx[1] |= 0x80000000 >> ((uint8_t)esi_5 - 0x20);
0041cfb4                      
0041cfcb                      eax_8[var_8_1 + 0x31] |= 0x80000000 >> ((uint8_t)esi_5 - 0x20);
0041cf73                  }
0041cf73                  else
0041cf73                  {
0041cf75                      (uint8_t)ecx_37 += 1;
0041cf7b                      *(uint8_t*)(esi_5 + eax_8 + 4) = (uint8_t)ecx_37;
0041cf7b                      
0041cf7f                      if (!*(uint8_t*)((char*)arg1)[3])
0041cf8a                          *(uint32_t*)ebx |= 0x80000000 >> (uint8_t)esi_5;
0041cf8a                      
0041cf98                      eax_8[var_8_1 + 0x11] |= 0x80000000 >> (uint8_t)esi_5;
0041cf73                  }
0041cf67              }
0041cf67              
0041cf67              goto label_41cfd0;
0041cf42          }
0041cebd      }
0041cebd      
0041cfe2      void** edx_9 = (char*)edx_8 + ecx_23;
0041cfe7      *(uint32_t*)edx_9 = (char*)ecx_1 + 1;
0041cfe9      *(uint32_t*)((char*)edx_9 + ecx_1 - 4) = (char*)ecx_1 + 1;
0041cff0      int32_t ecx_45 = eax_8[edx_1 * 0x81 + 0x51];
0041cff7      eax_8[edx_1 * 0x81 + 0x51] = ecx_45 + 1;
0041cff7      
0041d00c      if (!ecx_45 && ebx == data_430df4 && var_8_1 == data_430dec)
0041d00e          data_430df4 = 0;
0041d00e      
0041d018      *(uint32_t*)eax_8 = var_8_1;
0041d01a      return &edx_9[1];
0041cd19  }


0041d022    int32_t* sub_41d022()

0041d022  {
0041d022      int32_t eax_3 = data_430df8;
0041d027      int32_t ecx = data_430de8;
0041d027      
0041d033      if (eax_3 != ecx)
0041d033          goto label_41d07b;
0041d033      
0041d04a      int32_t eax_2 =
0041d04a          HeapReAlloc(data_430e04, HEAP_NONE, data_430dfc, (ecx * 5 + 0x50) << 2);
0041d04a      
0041d052      if (eax_2)
0041d052      {
0041d054          data_430de8 += 0x10;
0041d05b          data_430dfc = eax_2;
0041d060          eax_3 = data_430df8;
0041d07b      label_41d07b:
0041d07b          int32_t* result = data_430dfc + eax_3 * 0x14;
0041d07e          int32_t eax_5 = HeapAlloc(data_430e04, HEAP_ZERO_MEMORY, 0x41c4);
0041d086          result[4] = eax_5;
0041d086          
0041d089          if (eax_5)
0041d089          {
0041d098              int32_t eax_6 = VirtualAlloc(nullptr, 0x100000, MEM_RESERVE, PAGE_READWRITE);
0041d0a0              result[3] = eax_6;
0041d0a0              
0041d0a3              if (eax_6)
0041d0a3              {
0041d0b9                  result[2] = 0xffffffff;
0041d0bd                  *(uint32_t*)result = 0;
0041d0bf                  result[1] = 0;
0041d0c2                  data_430df8 += 1;
0041d0cb                  *(uint32_t*)result[4] = 0xffffffff;
0041d0ce                  return result;
0041d0a3              }
0041d0a3              
0041d0af              HeapFree(data_430e04, HEAP_NONE, result[4]);
0041d089          }
0041d052      }
0041d052      
0041d0b5      return nullptr;
0041d022  }


0041d0d3    int32_t sub_41d0d3(void* arg1)

0041d0d3  {
0041d0d6      int32_t ecx;
0041d0d6      int32_t var_8 = ecx;
0041d0dd      void* esi = *(uint32_t*)((char*)arg1 + 0x10);
0041d0e0      int32_t i = *(uint32_t*)((char*)arg1 + 8);
0041d0e3      int32_t result = 0;
0041d0e3      
0041d0e7      while (i >= 0)
0041d0e7      {
0041d0e9          i <<= 1;
0041d0eb          result += 1;
0041d0e7      }
0041d0e7      
0041d0f8      int32_t i_2 = 0x3f;
0041d0f9      void* eax_2 = result * 0x204 + esi + 0x144;
0041d100      void* var_8_1 = eax_2;
0041d10d      int32_t i_1;
0041d10d      
0041d10d      do
0041d10d      {
0041d103          *(uint32_t*)((char*)eax_2 + 8) = eax_2;
0041d106          *(uint32_t*)((char*)eax_2 + 4) = eax_2;
0041d109          eax_2 += 8;
0041d10c          i_1 = i_2;
0041d10c          i_2 -= 1;
0041d10d      } while (i_1 != 1);
0041d116      void* lpAddress = (result << 0xf) + *(uint32_t*)((char*)arg1 + 0xc);
0041d116      
0041d12c      if (!VirtualAlloc(lpAddress, 0x8000, MEM_COMMIT, PAGE_READWRITE))
0041d12e          return 0xffffffff;
0041d12e      
0041d13e      if (lpAddress <= (char*)lpAddress + 0x7000)
0041d13e      {
0041d140          void** eax_5 = (char*)lpAddress + 0x10;
0041d140          
0041d17a          do
0041d17a          {
0041d143              eax_5[-2] = 0xffffffff;
0041d147              eax_5[0x3fb] = 0xffffffff;
0041d154              eax_5[-1] = 0xff0;
0041d15b              *(uint32_t*)eax_5 = &eax_5[0x3ff];
0041d163              eax_5[1] = &eax_5[-0x401];
0041d166              eax_5[0x3fa] = 0xff0;
0041d170              eax_5 = &eax_5[0x400];
0041d17a          } while (&eax_5[-4] <= (char*)lpAddress + 0x7000);
0041d13e      }
0041d13e      
0041d18a      *(uint32_t*)((char*)var_8_1 + 0x1fc) = (char*)lpAddress + 0xc;
0041d18d      *(uint32_t*)((char*)lpAddress + 0x14) = (char*)var_8_1 + 0x1f8;
0041d193      *(uint32_t*)((char*)var_8_1 + 0x200) = (char*)lpAddress + 0x700c;
0041d196      *(uint32_t*)((char*)lpAddress + 0x7010) = (char*)var_8_1 + 0x1f8;
0041d199      *(uint32_t*)((char*)esi + (result << 2) + 0x44) = 0;
0041d19e      *(uint32_t*)((char*)esi + (result << 2) + 0xc4) = 1;
0041d1a5      void* eax_7;
0041d1a5      (uint8_t)eax_7 = *(uint8_t*)((char*)esi + 0x43);
0041d1a8      void* ecx_6;
0041d1a8      (uint8_t)ecx_6 = (uint8_t)eax_7;
0041d1aa      (uint8_t)ecx_6 += 1;
0041d1b1      *(uint8_t*)((char*)esi + 0x43) = (uint8_t)ecx_6;
0041d1b1      
0041d1b4      if (!(uint8_t)eax_7)
0041d1b6          *(uint32_t*)((char*)arg1 + 4) |= 1;
0041d1b6      
0041d1c4      *(uint32_t*)((char*)arg1 + 8) &= ~(0x80000000 >> (uint8_t)result);
0041d1c7      return result;
0041d0d3  }


0041d1ce    int32_t sub_41d1ce(int32_t* arg1, void** arg2, void* arg3)

0041d1ce  {
0041d1e8      int32_t eax_1 = arg1[4];
0041d1eb      void* esi_1 = ((char*)arg3 + 0x17) & 0xfffffff0;
0041d1ee      uint32_t edx_2 = ((char*)arg2 - arg1[3]) >> 0xf;
0041d206      void* ecx_5 = arg2[-1] - 1;
0041d20c      void* ebx = *(uint32_t*)((char*)ecx_5 + arg2 - 4);
0041d210      void* edi_1 = (char*)ecx_5 + arg2 - 4;
0041d210      
0041d217      if (esi_1 > ecx_5)
0041d217      {
0041d22a          if ((uint8_t)ebx & 1 || esi_1 > (char*)ebx + ecx_5)
0041d375              return 0;
0041d375          
0041d236          int32_t ecx_8 = (ebx >> 4) - 1;
0041d23a          int32_t var_c_1 = ecx_8;
0041d23a          
0041d23d          if (ecx_8 > 0x3f)
0041d23d          {
0041d241              ecx_8 = 0x3f;
0041d242              var_c_1 = 0x3f;
0041d23d          }
0041d23d          
0041d24b          if (*(uint32_t*)((char*)edi_1 + 4) == *(uint32_t*)((char*)edi_1 + 8))
0041d24b          {
0041d250              if (ecx_8 >= 0x20)
0041d250              {
0041d282                  uint32_t ebx_6 = ~(0x80000000 >> ((uint8_t)ecx_8 - 0x20));
0041d284                  *(uint32_t*)(eax_1 + (edx_2 << 2) + 0xc4) &= ebx_6;
0041d28b                  char temp0_1 = *(uint8_t*)(var_c_1 + eax_1 + 4);
0041d28b                  *(uint8_t*)(var_c_1 + eax_1 + 4) -= 1;
0041d28b                  
0041d28d                  if (temp0_1 == 1)
0041d292                      arg1[1] &= ebx_6;
0041d250              }
0041d250              else
0041d250              {
0041d260                  uint32_t ebx_4 = ~(0x80000000 >> (uint8_t)ecx_8);
0041d262                  *(uint32_t*)(eax_1 + (edx_2 << 2) + 0x44) &= ebx_4;
0041d266                  char temp1_1 = *(uint8_t*)(var_c_1 + eax_1 + 4);
0041d266                  *(uint8_t*)(var_c_1 + eax_1 + 4) -= 1;
0041d266                  
0041d268                  if (temp1_1 == 1)
0041d26d                      *(uint32_t*)arg1 &= ebx_4;
0041d250              }
0041d24b          }
0041d24b          
0041d29b          *(uint32_t*)(*(uint32_t*)((char*)edi_1 + 8) + 4) = *(uint32_t*)((char*)edi_1 + 4);
0041d2a4          *(uint32_t*)(*(uint32_t*)((char*)edi_1 + 4) + 8) = *(uint32_t*)((char*)edi_1 + 8);
0041d2ac          void* var_8_1 = (char*)ebx + (char*)ecx_5 - esi_1;
0041d2b3          void** edx_4;
0041d2b3          
0041d2b3          if (var_8_1 <= 0)
0041d363              edx_4 = arg2;
0041d2b3          else
0041d2b3          {
0041d2c2              int32_t edi_5 = (var_8_1 >> 4) - 1;
0041d2c2              
0041d2ca              if (edi_5 > 0x3f)
0041d2ce                  edi_5 = 0x3f;
0041d2ce              
0041d2d2              void* ebx_9 = edx_2 * 0x204 + eax_1 + 0x144 + (edi_5 << 3);
0041d2db              *(uint32_t*)((char*)arg2 + esi_1) = *(uint32_t*)((char*)ebx_9 + 4);
0041d2e1              *(uint32_t*)((char*)arg2 + esi_1 + 4) = ebx_9;
0041d2e4              *(uint32_t*)((char*)ebx_9 + 4) = (char*)arg2 + esi_1 - 4;
0041d2ea              *(uint32_t*)(*(uint32_t*)((char*)arg2 + esi_1) + 8) = (char*)arg2 + esi_1 - 4;
0041d2ea              
0041d2f3              if (*(uint32_t*)((char*)arg2 + esi_1)
0041d2f3                  == *(uint32_t*)((char*)arg2 + esi_1 + 4))
0041d2f3              {
0041d2f5                  void* ecx_21;
0041d2f5                  (uint8_t)ecx_21 = *(uint8_t*)(edi_5 + eax_1 + 4);
0041d2fc                  *(uint8_t*)((char*)arg3)[3] = (uint8_t)ecx_21;
0041d2ff                  (uint8_t)ecx_21 += 1;
0041d301                  *(uint8_t*)(edi_5 + eax_1 + 4) = (uint8_t)ecx_21;
0041d305                  int32_t* eax_2;
0041d305                  char ecx_24;
0041d305                  
0041d305                  if (edi_5 >= 0x20)
0041d305                  {
0041d32c                      if (!*(uint8_t*)((char*)arg3)[3])
0041d33b                          arg1[1] |= 0x80000000 >> ((uint8_t)edi_5 - 0x20);
0041d33b                      
0041d33e                      eax_2 = eax_1 + (edx_2 << 2) + 0xc4;
0041d345                      ecx_24 = (uint8_t)edi_5 - 0x20;
0041d305                  }
0041d305                  else
0041d305                  {
0041d30b                      if (!*(uint8_t*)((char*)arg3)[3])
0041d319                          *(uint32_t*)arg1 |= 0x80000000 >> (uint8_t)edi_5;
0041d319                      
0041d31b                      eax_2 = eax_1 + (edx_2 << 2) + 0x44;
0041d324                      ecx_24 = (uint8_t)edi_5;
0041d305                  }
0041d305                  
0041d34f                  *(uint32_t*)eax_2 |= 0x80000000 >> ecx_24;
0041d2f3              }
0041d2f3              
0041d351              edx_4 = arg2;
0041d35b              *(uint32_t*)((char*)edx_4 + esi_1 - 4) = var_8_1;
0041d35d              *(uint32_t*)((char*)var_8_1 + (char*)edx_4 + esi_1 - 4 - 4) = var_8_1;
0041d2b3          }
0041d2b3          
0041d369          edx_4[-1] = (char*)esi_1 + 1;
0041d36c          *(uint32_t*)((char*)edx_4 + esi_1 - 8) = (char*)esi_1 + 1;
0041d217      }
0041d217      else if (esi_1 < ecx_5)
0041d37c      {
0041d385          arg3 = (char*)ecx_5 - esi_1;
0041d38b          arg2[-1] = (char*)esi_1 + 1;
0041d38e          void** ebx_17 = (char*)arg2 + esi_1 - 4;
0041d39b          int32_t esi_4 = (arg3 >> 4) - 1;
0041d39c          ebx_17[-1] = (char*)esi_1 + 1;
0041d39c          
0041d3a2          if (esi_4 > 0x3f)
0041d3a6              esi_4 = 0x3f;
0041d3a6          
0041d3ab          if (!((uint8_t)ebx & 1))
0041d3ab          {
0041d3b7              int32_t esi_7 = (ebx >> 4) - 1;
0041d3b7              
0041d3bb              if (esi_7 > 0x3f)
0041d3bf                  esi_7 = 0x3f;
0041d3bf              
0041d3c6              if (*(uint32_t*)((char*)edi_1 + 4) == *(uint32_t*)((char*)edi_1 + 8))
0041d3c6              {
0041d3cb                  if (esi_7 >= 0x20)
0041d3cb                  {
0041d3f9                      uint32_t ebx_21 = ~(0x80000000 >> ((uint8_t)esi_7 - 0x20));
0041d3fb                      *(uint32_t*)(eax_1 + (edx_2 << 2) + 0xc4) &= ebx_21;
0041d402                      char temp2_1 = *(uint8_t*)(esi_7 + eax_1 + 4);
0041d402                      *(uint8_t*)(esi_7 + eax_1 + 4) -= 1;
0041d402                      
0041d404                      if (temp2_1 == 1)
0041d409                          arg1[1] &= ebx_21;
0041d3cb                  }
0041d3cb                  else
0041d3cb                  {
0041d3da                      uint32_t ebx_19 = ~(0x80000000 >> (uint8_t)esi_7);
0041d3dc                      *(uint32_t*)(eax_1 + (edx_2 << 2) + 0x44) &= ebx_19;
0041d3e0                      char temp3_1 = *(uint8_t*)(esi_7 + eax_1 + 4);
0041d3e0                      *(uint8_t*)(esi_7 + eax_1 + 4) -= 1;
0041d3e0                      
0041d3e2                      if (temp3_1 == 1)
0041d3e7                          *(uint32_t*)arg1 &= ebx_19;
0041d3cb                  }
0041d3c6              }
0041d3c6              
0041d415              *(uint32_t*)(*(uint32_t*)((char*)edi_1 + 8) + 4) =
0041d415                  *(uint32_t*)((char*)edi_1 + 4);
0041d41e              *(uint32_t*)(*(uint32_t*)((char*)edi_1 + 4) + 8) =
0041d41e                  *(uint32_t*)((char*)edi_1 + 8);
0041d424              void* esi_12 = (char*)arg3 + ebx;
0041d427              arg3 = esi_12;
0041d42d              esi_4 = (esi_12 >> 4) - 1;
0041d42d              
0041d431              if (esi_4 > 0x3f)
0041d435                  esi_4 = 0x3f;
0041d3ab          }
0041d3ab          
0041d43d          void* ecx_38 = edx_2 * 0x204 + eax_1 + 0x144 + (esi_4 << 3);
0041d440          ebx_17[1] = *(uint32_t*)(edx_2 * 0x204 + eax_1 + 0x144 + (esi_4 << 3) + 4);
0041d443          ebx_17[2] = ecx_38;
0041d446          *(uint32_t*)((char*)ecx_38 + 4) = ebx_17;
0041d44c          *(uint32_t*)(ebx_17[1] + 8) = ebx_17;
0041d44c          
0041d455          if (ebx_17[1] == ebx_17[2])
0041d455          {
0041d457              int32_t ecx_40;
0041d457              (uint8_t)ecx_40 = *(uint8_t*)(esi_4 + eax_1 + 4);
0041d45e              *(uint8_t*)((char*)arg2)[3] = (uint8_t)ecx_40;
0041d461              (uint8_t)ecx_40 += 1;
0041d463              *(uint8_t*)(esi_4 + eax_1 + 4) = (uint8_t)ecx_40;
0041d467              int32_t* eax_6;
0041d467              char ecx_43;
0041d467              
0041d467              if (esi_4 >= 0x20)
0041d467              {
0041d48e                  if (!*(uint8_t*)((char*)arg2)[3])
0041d49d                      arg1[1] |= 0x80000000 >> ((uint8_t)esi_4 - 0x20);
0041d49d                  
0041d4a0                  eax_6 = eax_1 + (edx_2 << 2) + 0xc4;
0041d4a7                  ecx_43 = (uint8_t)esi_4 - 0x20;
0041d467              }
0041d467              else
0041d467              {
0041d46d                  if (!*(uint8_t*)((char*)arg2)[3])
0041d47b                      *(uint32_t*)arg1 |= 0x80000000 >> (uint8_t)esi_4;
0041d47b                  
0041d47d                  eax_6 = eax_1 + (edx_2 << 2) + 0x44;
0041d486                  ecx_43 = (uint8_t)esi_4;
0041d467              }
0041d467              
0041d4b1              *(uint32_t*)eax_6 |= 0x80000000 >> ecx_43;
0041d455          }
0041d455          
0041d4b6          *(uint32_t*)ebx_17 = arg3;
0041d4b8          *(uint32_t*)((char*)arg3 + ebx_17 - 4) = arg3;
0041d37c      }
0041d37c      
0041d4be      return 1;
0041d1ce  }


0041d4c4    void** sub_41d4c4()

0041d4c4  {
0041d4cf      void** lpMem;
0041d4cf      
0041d4cf      if (data_42d5a0 != 0xffffffff)
0041d4cf      {
0041d4eb          lpMem = HeapAlloc(data_430e04, HEAP_NONE, 0x2020);
0041d4eb          
0041d4ef          if (lpMem)
0041d4ef              goto label_41d50b;
0041d4cf      }
0041d4cf      else
0041d4cf      {
0041d4d1          lpMem = &data_42d590;
0041d50b      label_41d50b:
0041d50b          char* lpAddress =
0041d50b              VirtualAlloc(nullptr, &__dos_header, MEM_RESERVE, PAGE_READWRITE);
0041d50b          
0041d50f          if (lpAddress)
0041d50f          {
0041d527              if (VirtualAlloc(lpAddress, 0x10000, MEM_COMMIT, PAGE_READWRITE))
0041d527              {
0041d534                  if (lpMem != &data_42d590)
0041d534                  {
0041d554                      *(uint32_t*)lpMem = &data_42d590;
0041d55b                      lpMem[1] = data_42d594;
0041d55e                      data_42d594 = lpMem;
0041d567                      *(uint32_t*)lpMem[1] = lpMem;
0041d534                  }
0041d534                  else
0041d534                  {
0041d53d                      if (!data_42d590)
0041d53f                          data_42d590 = &data_42d590;
0041d53f                      
0041d54b                      if (!data_42d594)
0041d54d                          data_42d594 = &data_42d590;
0041d534                  }
0041d534                  
0041d575                  lpMem[5] = lpAddress + &__dos_header;
0041d578                  void* eax_7 = &lpMem[6];
0041d57b                  lpMem[3] = &lpMem[0x26];
0041d57e                  lpMem[4] = lpAddress;
0041d581                  lpMem[2] = eax_7;
0041d581                  
0041d5a6                  for (int32_t i = 0; i < 0x400; )
0041d5a6                  {
0041d590                      int32_t edx_1;
0041d590                      (uint8_t)edx_1 = i >= 0x10;
0041d597                      i += 1;
0041d598                      *(uint32_t*)eax_7 = ((edx_1 - 1) & 0xf1) - 1;
0041d59a                      *(uint32_t*)((char*)eax_7 + 4) = 0xf1;
0041d59d                      eax_7 += 8;
0041d5a6                  }
0041d5a6                  
0041d5ac                  sub_423620(lpAddress, 0, 0x10000);
0041d5ac                  
0041d5bb                  for (; lpAddress < lpMem[4] + 0x10000; lpAddress = &lpAddress[0x1000])
0041d5bb                  {
0041d5bd                      lpAddress[0xf8] = 0xff;
0041d5c7                      *(uint32_t*)lpAddress = &lpAddress[8];
0041d5c9                      *(uint32_t*)(lpAddress + 4) = 0xf0;
0041d5bb                  }
0041d5bb                  
0041d5d8                  return lpMem;
0041d527              }
0041d527              
0041d5e4              VirtualFree(lpAddress, 0, MEM_RELEASE);
0041d50f          }
0041d50f          
0041d5f0          if (lpMem != &data_42d590)
0041d5fb              HeapFree(data_430e04, HEAP_NONE, lpMem);
0041d4cf      }
0041d601      return nullptr;
0041d4c4  }


0041d608    BOOL sub_41d608(int32_t* arg1)

0041d608  {
0041d617      BOOL result = VirtualFree(arg1[4], 0, MEM_RELEASE);
0041d617      
0041d623      if (data_42f5b0 == arg1)
0041d623      {
0041d625          result = arg1[1];
0041d628          data_42f5b0 = result;
0041d623      }
0041d623      
0041d633      if (arg1 == &data_42d590)
0041d633      {
0041d655          data_42d5a0 = 0xffffffff;
0041d65d          return result;
0041d633      }
0041d633      
0041d63d      *(uint32_t*)arg1[1] = *(uint32_t*)arg1;
0041d644      *(uint32_t*)(*(uint32_t*)arg1 + 4) = arg1[1];
0041d654      return HeapFree(data_430e04, HEAP_NONE, arg1);
0041d608  }


0041d65e    void sub_41d65e(int32_t arg1)

0041d65e  {
0041d661      int32_t ecx;
0041d661      int32_t var_8 = ecx;
0041d664      int32_t* esi = data_42d594;
0041d664      
0041d715      do
0041d715      {
0041d66f          if (esi[4] != 0xffffffff)
0041d66f          {
0041d675              int32_t var_8_1 = 0;
0041d679              void* edi_1 = &esi[0x804];
0041d6d0              BOOL eax;
0041d6d0              
0041d6d0              for (int32_t j = 0x3ff000; j >= 0; )
0041d6d0              {
0041d68a                  if (*(uint32_t*)edi_1 == 0xf0
0041d68a                      && VirtualFree(j + esi[4], 0x1000, MEM_DECOMMIT))
0041d68a                  {
0041d6a6                      *(uint32_t*)edi_1 = 0xffffffff;
0041d6a9                      data_4309d4 -= 1;
0041d6af                      eax = esi[3];
0041d6af                      
0041d6b8                      if (!eax || eax > edi_1)
0041d6ba                          esi[3] = edi_1;
0041d6ba                      
0041d6bd                      var_8_1 += 1;
0041d6c0                      int32_t temp0_1 = arg1;
0041d6c0                      arg1 -= 1;
0041d6c0                      
0041d6c3                      if (temp0_1 == 1)
0041d6c3                          break;
0041d68a                  }
0041d68a                  
0041d6c5                  j -= 0x1000;
0041d6cb                  edi_1 -= 8;
0041d6d0              }
0041d6d0              
0041d6d6              int32_t* ecx_1 = esi;
0041d6d8              esi = esi[1];
0041d6d8              
0041d6e1              if (var_8_1 && ecx_1[6] == 0xffffffff)
0041d6e1              {
0041d6e5                  eax = &ecx_1[8];
0041d6e8                  int32_t edx_1 = 1;
0041d6e8                  
0041d6ec                  while (*(uint32_t*)eax == 0xffffffff)
0041d6ec                  {
0041d6ee                      edx_1 += 1;
0041d6ef                      eax += 8;
0041d6ef                      
0041d6f8                      if (edx_1 >= 0x400)
0041d6f8                          break;
0041d6ec                  }
0041d6ec                  
0041d700                  if (edx_1 == 0x400)
0041d703                      sub_41d608(ecx_1);
0041d6e1              }
0041d66f          }
0041d66f          
0041d70f          if (esi == data_42d594)
0041d70f              break;
0041d715      } while (arg1 > 0);
0041d65e  }


0041d720    int32_t sub_41d720(int32_t arg1, void*** arg2, int32_t* arg3)

0041d720  {
0041d72a      void** i = &data_42d590;
0041d72a      
0041d73a      do
0041d73a      {
0041d734          if (arg1 > i[4] && arg1 < i[5])
0041d734          {
0041d751              if ((uint8_t)arg1 & 0xf || (arg1 & 0xfff) < 0x100)
0041d751                  break;
0041d751              
0041d757              *(uint32_t*)arg2 = i;
0041d75f              int32_t ecx;
0041d75f              (uint16_t)ecx = (uint16_t)arg1 & 0xf000;
0041d766              *(uint32_t*)arg3 = ecx;
0041d772              return ((arg1 - ecx - 0x100) >> 4) + ecx + 8;
0041d734          }
0041d734          
0041d736          i = *(uint32_t*)i;
0041d73a      } while (i != &data_42d590);
0041d73a      
0041d776      return 0;
0041d720  }


0041d777    void* sub_41d777(void* arg1, int32_t arg2, char* arg3)

0041d777  {
0041d785      void* result =
0041d785          (char*)arg1 + ((arg2 - *(uint32_t*)((char*)arg1 + 0x10)) >> 0xc << 3) + 0x18;
0041d790      *(uint32_t*)result += (uint32_t)*(uint8_t*)arg3;
0041d792      *(uint8_t*)arg3 = 0;
0041d795      bool cond:0 = *(uint32_t*)result != 0xf0;
0041d79b      *(uint32_t*)((char*)result + 4) = 0xf1;
0041d79b      
0041d7a2      if (!cond:0)
0041d7a2      {
0041d7a4          data_4309d4 += 1;
0041d7a4          
0041d7b1          if (data_4309d4 == 0x20)
0041d7b5              result = sub_41d65e(0x10);
0041d7a2      }
0041d7a2      
0041d7bb      return result;
0041d777  }


0041d7bc    void* sub_41d7bc(int32_t arg1)

0041d7bc  {
0041d7bf      int32_t ecx;
0041d7bf      int32_t var_8 = ecx;
0041d7c0      int32_t var_c = ecx;
0041d7c3      void** esi = data_42f5b0;
0041d7ca      void* result;
0041d7ca      
0041d7ca      while (true)
0041d7ca      {
0041d7ca          int32_t edx_1 = esi[4];
0041d7d0          int32_t ebx_1;
0041d7d0          
0041d7d0          if (edx_1 == 0xffffffff)
0041d875              ebx_1 = arg1;
0041d7d0          else
0041d7d0          {
0041d7d6              void* edi_1 = esi[2];
0041d7ec              void* eax_6 = (((char*)edi_1 - esi - 0x18) >> 3 << 0xc) + edx_1;
0041d7f0              void* var_8_1 = eax_6;
0041d7f0              
0041d7f3              if (edi_1 < &esi[0x806])
0041d7f3              {
0041d7f5                  while (true)
0041d7f5                  {
0041d7f5                      int32_t ecx_2 = *(uint32_t*)edi_1;
0041d7f7                      ebx_1 = arg1;
0041d7f7                      
0041d801                      if (ecx_2 >= ebx_1 && *(uint32_t*)((char*)edi_1 + 4) > ebx_1)
0041d801                      {
0041d806                          result = sub_41d9c4(eax_6, ecx_2, ebx_1);
0041d806                          
0041d810                          if (result)
0041d810                              break;
0041d810                          
0041d812                          eax_6 = var_8_1;
0041d815                          *(uint32_t*)((char*)edi_1 + 4) = ebx_1;
0041d801                      }
0041d801                      
0041d818                      edi_1 += 8;
0041d821                      eax_6 += 0x1000;
0041d828                      var_8_1 = eax_6;
0041d828                      
0041d82b                      if (edi_1 >= &esi[0x806])
0041d82b                          goto label_41d832;
0041d7f5                  }
0041d7f5                  
0041d82b                  goto label_41d887;
0041d7f3              }
0041d7f3              
0041d82f              ebx_1 = arg1;
0041d832          label_41d832:
0041d832              int32_t eax_7 = esi[2];
0041d838              edi_1 = &esi[6];
0041d840              void* var_8_2 = esi[4];
0041d840              
0041d843              if (edi_1 < eax_7)
0041d843              {
0041d845                  while (true)
0041d845                  {
0041d845                      int32_t eax_8 = *(uint32_t*)edi_1;
0041d845                      
0041d84e                      if (eax_8 >= ebx_1 && *(uint32_t*)((char*)edi_1 + 4) > ebx_1)
0041d84e                      {
0041d855                          result = sub_41d9c4(var_8_2, eax_8, ebx_1);
0041d855                          
0041d85f                          if (result)
0041d85f                              break;
0041d85f                          
0041d861                          *(uint32_t*)((char*)edi_1 + 4) = ebx_1;
0041d84e                      }
0041d84e                      
0041d864                      var_8_2 += 0x1000;
0041d86b                      edi_1 += 8;
0041d86b                      
0041d871                      if (edi_1 >= eax_7)
0041d871                          goto label_41d878;
0041d845                  }
0041d845                  
0041d887              label_41d887:
0041d887                  data_42f5b0 = esi;
0041d88d                  *(uint32_t*)edi_1 -= ebx_1;
0041d88f                  esi[2] = edi_1;
0041d892                  break;
0041d843              }
0041d7d0          }
0041d7d0          
0041d878      label_41d878:
0041d878          esi = *(uint32_t*)esi;
0041d878          
0041d880          if (esi == data_42f5b0)
0041d880          {
0041d89c              void** edi_2 = &data_42d590;
0041d8a8              int32_t i;
0041d8a8              int32_t dwSize;
0041d8a8              int32_t* ebx_2;
0041d8a8              int32_t* lpAddress;
0041d8a8              
0041d8a8              while (true)
0041d8a8              {
0041d8a8                  if (edi_2[4] == 0xffffffff || !edi_2[3])
0041d8a8                  {
0041d8aa                      edi_2 = *(uint32_t*)edi_2;
0041d8aa                      
0041d8ae                      if (edi_2 == &data_42d590)
0041d8ae                      {
0041d98b                          void** eax_17 = sub_41d4c4();
0041d98b                          
0041d992                          if (eax_17)
0041d992                          {
0041d994                              void** ecx_7 = eax_17[4];
0041d997                              ecx_7[2] = (uint8_t)ebx_1;
0041d99e                              data_42f5b0 = eax_17;
0041d9a3                              *(uint32_t*)ecx_7 = (char*)ecx_7 + ebx_1 + 8;
0041d9ac                              ecx_7[1] = 0xf0 - ebx_1;
0041d9b2                              eax_17[6] -= (uint32_t)(uint8_t)ebx_1;
0041d9b5                              return &ecx_7[0x40];
0041d992                          }
0041d8ae                      }
0041d8ae                      else
0041d8ae                          continue;
0041d8a8                  }
0041d8a8                  else
0041d8a8                  {
0041d8b6                      ebx_2 = edi_2[3];
0041d8b9                      i = 0;
0041d8bf                      int32_t* eax_9 = ebx_2;
0041d8cc                      lpAddress = (((char*)ebx_2 - edi_2 - 0x18) >> 3 << 0xc) + edi_2[4];
0041d8cc                      
0041d8d2                      if (*(uint32_t*)ebx_2 == 0xffffffff)
0041d8d2                      {
0041d8d8                          while (i < 0x10)
0041d8d8                          {
0041d8da                              eax_9 = &eax_9[2];
0041d8dd                              i += 1;
0041d8dd                              
0041d8e3                              if (*(uint32_t*)eax_9 != 0xffffffff)
0041d8e3                                  break;
0041d8d8                          }
0041d8d2                      }
0041d8d2                      
0041d8ea                      dwSize = i << 0xc;
0041d8ea                      
0041d8ff                      if (VirtualAlloc(lpAddress, dwSize, MEM_COMMIT, PAGE_READWRITE)
0041d8ff                              == lpAddress)
0041d8ff                          break;
0041d8a8                  }
0041d8a8                  
0041d9bd                  return nullptr;
0041d8a8              }
0041d8a8              
0041d90b              sub_423620(lpAddress, (uint8_t)dwSize, 0);
0041d918              int32_t* ecx_5 = ebx_2;
0041d918              
0041d91a              if (i > 0)
0041d91a              {
0041d91c                  void* eax_12 = &lpAddress[1];
0041d91f                  int32_t i_2 = i;
0041d94a                  int32_t i_1;
0041d94a                  
0041d94a                  do
0041d94a                  {
0041d922                      *(uint8_t*)((char*)eax_12 + 0xf4) = 0xff;
0041d92c                      *(uint32_t*)((char*)eax_12 - 4) = (char*)eax_12 + 4;
0041d934                      *(uint32_t*)eax_12 = 0xf0;
0041d936                      *(uint32_t*)ecx_5 = 0xf0;
0041d938                      ecx_5[1] = 0xf1;
0041d93f                      eax_12 += 0x1000;
0041d944                      ecx_5 = &ecx_5[2];
0041d947                      i_1 = i_2;
0041d947                      i_2 -= 1;
0041d94a                  } while (i_1 != 1);
0041d91a              }
0041d91a              
0041d94c              data_42f5b0 = edi_2;
0041d958              bool c_1;
0041d958              
0041d958              while (true)
0041d958              {
0041d958                  c_1 = ecx_5 < &edi_2[0x806];
0041d958                  
0041d95a                  if (!c_1)
0041d95a                      break;
0041d95a                  
0041d95f                  if (*(uint32_t*)ecx_5 == 0xffffffff)
0041d95f                  {
0041d966                      c_1 = ecx_5 < &edi_2[0x806];
0041d966                      break;
0041d95f                  }
0041d95f                  
0041d961                  ecx_5 = &ecx_5[2];
0041d958              }
0041d958              
0041d96c              edi_2[3] = (&edi_2[0x806] - &edi_2[0x806]) & ecx_5;
0041d972              lpAddress[2] = (uint8_t)arg1;
0041d975              edi_2[2] = ebx_2;
0041d978              *(uint32_t*)ebx_2 -= arg1;
0041d97a              lpAddress[1] -= arg1;
0041d981              result = &lpAddress[0x40];
0041d987              *(uint32_t*)lpAddress = (char*)lpAddress + arg1 + 8;
0041d952              break;
0041d880          }
0041d7ca      }
0041d7ca      
0041d9c3      return result;
0041d7bc  }


0041d9c4    int32_t sub_41d9c4(void* arg1, int32_t arg2, int32_t arg3)

0041d9c4  {
0041d9c7      int32_t ecx;
0041d9c7      int32_t var_8 = ecx;
0041d9c8      int32_t* ecx_1 = arg1;
0041d9d0      void* esi = ecx_1[1];
0041d9d4      void* edi = *(uint32_t*)ecx_1;
0041d9de      void* var_8_1 = edi;
0041d9e1      void* eax = edi;
0041d9e6      void* eax_5;
0041d9e6      
0041d9e6      if (esi < arg3)
0041d9e6      {
0041da09          void* esi_1 = (char*)esi + edi;
0041da09          
0041da0e          if (*(uint8_t*)esi_1)
0041da10              eax = esi_1;
0041da10          
0041da17          if ((char*)eax + arg3 >= &ecx_1[0x3e])
0041da17          {
0041da5c          label_41da5c:
0041da5c              char* esi_6 = &ecx_1[2];
0041da61              int32_t eax_4;
0041da61              
0041da61              while (true)
0041da61              {
0041da61                  if (esi_6 >= edi)
0041dae1                      return 0;
0041dae1                  
0041da69                  if (&esi_6[arg3] >= &ecx_1[0x3e])
0041dae1                      return 0;
0041dae1                  
0041da6b                  void* eax_3;
0041da6b                  (uint8_t)eax_3 = *(uint8_t*)esi_6;
0041da6b                  
0041da6f                  if ((uint8_t)eax_3)
0041dab4                      esi_6 = &esi_6[(uint32_t)(uint8_t)eax_3];
0041da6f                  else
0041da6f                  {
0041da73                      void* ebx_1 = &esi_6[1];
0041da76                      eax_4 = 1;
0041da76                      
0041da7a                      while (!*(uint8_t*)ebx_1)
0041da7a                      {
0041da7c                          ebx_1 += 1;
0041da7d                          eax_4 += 1;
0041da7a                      }
0041da7a                      
0041daa3                      if (eax_4 >= arg3)
0041daa3                          break;
0041daa3                      
0041daa5                      arg2 -= eax_4;
0041daa5                      
0041daab                      if (arg2 < arg3)
0041dae1                          return 0;
0041dae1                      
0041daad                      esi_6 = ebx_1;
0041da6f                  }
0041da61              }
0041da61              
0041dab8              void* ebx_3 = &esi_6[arg3];
0041dab8              
0041dabe              if (ebx_3 >= &ecx_1[0x3e])
0041dabe              {
0041dac9                  ecx_1[1] = 0;
0041dad0                  *(uint32_t*)ecx_1 = &ecx_1[2];
0041dabe              }
0041dabe              else
0041dabe              {
0041dac2                  *(uint32_t*)ecx_1 = ebx_3;
0041dac4                  ecx_1[1] = eax_4 - arg3;
0041dabe              }
0041dabe              
0041dad2              *(uint8_t*)esi_6 = (uint8_t)arg3;
0041dad4              eax_5 = &esi_6[8];
0041da17          }
0041da17          else
0041da17          {
0041da19              while (true)
0041da19              {
0041da19                  void* ebx;
0041da19                  (uint8_t)ebx = *(uint8_t*)eax;
0041da19                  
0041da1d                  if ((uint8_t)ebx)
0041da52                      eax += (uint32_t)(uint8_t)ebx;
0041da1d                  else
0041da1d                  {
0041da21                      ebx = (char*)eax + 1;
0041da24                      int32_t esi_3 = 1;
0041da24                      
0041da28                      while (!*(uint8_t*)ebx)
0041da28                      {
0041da2a                          ebx += 1;
0041da2b                          esi_3 += 1;
0041da28                      }
0041da28                      
0041da30                      if (esi_3 >= arg3)
0041da30                      {
0041da80                          void* ebx_2 = (char*)eax + arg3;
0041da80                          
0041da86                          if (ebx_2 >= &ecx_1[0x3e])
0041da86                          {
0041da91                              ecx_1[1] = 0;
0041da98                              *(uint32_t*)ecx_1 = &ecx_1[2];
0041da86                          }
0041da86                          else
0041da86                          {
0041da8a                              *(uint32_t*)ecx_1 = ebx_2;
0041da8c                              ecx_1[1] = esi_3 - arg3;
0041da86                          }
0041da86                          
0041da9a                          *(uint8_t*)eax = (uint8_t)arg3;
0041da9c                          eax_5 = (char*)eax + 8;
0041da9f                          break;
0041da30                      }
0041da30                      
0041da35                      if (eax != var_8_1)
0041da35                      {
0041da3c                          arg2 -= esi_3;
0041da3c                          
0041da42                          if (arg2 < arg3)
0041dae1                              return 0;
0041da35                      }
0041da35                      else
0041da37                          ecx_1[1] = esi_3;
0041da37                      
0041da48                      edi = var_8_1;
0041da4b                      eax = ebx;
0041da1d                  }
0041da1d                  
0041da5a                  if ((char*)eax + arg3 >= &ecx_1[0x3e])
0041da5a                      goto label_41da5c;
0041da19              }
0041da17          }
0041d9e6      }
0041d9e6      else
0041d9e6      {
0041d9eb          *(uint8_t*)edi = (uint8_t)arg3;
0041d9eb          
0041d9ef          if ((char*)edi + arg3 >= &ecx_1[0x3e])
0041d9ef          {
0041d9f8              ecx_1[1] = 0;
0041d9ff              *(uint32_t*)ecx_1 = &ecx_1[2];
0041d9ef          }
0041d9ef          else
0041d9ef          {
0041d9f1              *(uint32_t*)ecx_1 += arg3;
0041d9f3              ecx_1[1] -= arg3;
0041d9ef          }
0041d9ef          
0041da01          eax_5 = (char*)edi + 8;
0041d9e6      }
0041d9e6      
0041dadd      return (eax_5 << 4) - ecx_1 * 0xf;
0041d9c4  }


0041dae8    int32_t sub_41dae8(void* arg1, void** arg2, char* arg3, int32_t arg4)

0041dae8  {
0041daeb      int32_t ecx;
0041daeb      int32_t var_8 = ecx;
0041daf4      uint32_t ecx_1 = (uint32_t)*(uint8_t*)arg3;
0041dafb      int32_t result = 0;
0041db0a      void* edi_1 = (char*)arg1
0041db0a          + (((char*)arg2 - *(uint32_t*)((char*)arg1 + 0x10)) >> 0xc << 3) + 0x18;
0041db0a      
0041db0e      if (ecx_1 <= arg4)
0041db0e      {
0041db22          if (ecx_1 >= arg4)
0041db90              return result;
0041db90          
0041db27          void* esi_1 = &arg3[arg4];
0041db27          
0041db32          if (esi_1 > &arg2[0x3e])
0041db90              return result;
0041db90          
0041db34          void* eax_6 = &arg3[ecx_1];
0041db37          bool cond:2_1;
0041db37          
0041db37          while (true)
0041db37          {
0041db37              cond:2_1 = eax_6 != esi_1;
0041db37              
0041db39              if (eax_6 >= esi_1)
0041db39                  break;
0041db39              
0041db3e              if (*(uint8_t*)eax_6)
0041db3e              {
0041db43                  cond:2_1 = eax_6 != esi_1;
0041db43                  break;
0041db3e              }
0041db3e              
0041db40              eax_6 += 1;
0041db37          }
0041db37          
0041db45          if (cond:2_1)
0041db90              return result;
0041db90          
0041db47          (uint8_t)eax_6 = (uint8_t)arg4;
0041db4a          *(uint8_t*)arg3 = (uint8_t)eax_6;
0041db4c          void* eax_7 = *(uint32_t*)arg2;
0041db4c          
0041db54          if (arg3 <= eax_7 && esi_1 > eax_7)
0041db54          {
0041db5e              if (esi_1 >= &arg2[0x3e])
0041db5e              {
0041db74                  arg2[1] = 0;
0041db7b                  *(uint32_t*)arg2 = &arg2[2];
0041db5e              }
0041db5e              else
0041db5e              {
0041db60                  int32_t eax_9 = 0;
0041db62                  *(uint32_t*)arg2 = esi_1;
0041db62                  
0041db66                  if (!*(uint8_t*)esi_1)
0041db66                  {
0041db6d                      do
0041db68                          eax_9 += 1;
0041db6d                       while (!*(uint8_t*)((char*)esi_1 + eax_9));
0041db66                  }
0041db66                  
0041db6f                  arg2[1] = eax_9;
0041db5e              }
0041db54          }
0041db54          
0041db80          *(uint32_t*)edi_1 += ecx_1 - arg4;
0041db0e      }
0041db0e      else
0041db0e      {
0041db15          *(uint8_t*)arg3 = (uint8_t)arg4;
0041db17          *(uint32_t*)edi_1 += ecx_1 - arg4;
0041db19          *(uint32_t*)((char*)edi_1 + 4) = 0xf1;
0041db0e      }
0041db0e      
0041db82      return 1;
0041dae8  }


0041db91    int32_t sub_41db91(int32_t arg1)

0041db91  {
0041db91      int32_t eax_3 = data_4309d8;
0041db91      
0041db98      if (eax_3 && eax_3(arg1))
0041dba8          return 1;
0041dba8      
0041dbab      return 0;
0041db91  }


0041dbac    void* sub_41dbac(int32_t* arg1)

0041dbac  {
0041dbbd      return sub_41dbbe(arg1, data_4309dc);
0041dbac  }


0041dbbe    void* sub_41dbbe(int32_t* arg1, int32_t arg2)

0041dbbe  {
0041dbc3      if (arg1 <= 0xffffffe0)
0041dbc3      {
0041dbe5          bool cond:1_1;
0041dbe5          
0041dbe5          do
0041dbe5          {
0041dbc9              void* result = sub_41dbea(arg1);
0041dbc9              
0041dbd7              if (result || arg2 == result)
0041dbe9                  return result;
0041dbe9              
0041dbe2              cond:1_1 = sub_41db91(arg1);
0041dbe5          } while (cond:1_1);
0041dbc3      }
0041dbc3      
0041dbe7      return nullptr;
0041dbbe  }


0041dbea    void* sub_41dbea(int32_t* arg1)

0041dbea  {
0041dbea      int32_t eax_5 = data_430e08;
0041dbf0      int32_t* esi = arg1;
0041dbf0      
0041dbf7      if (eax_5 == 3)
0041dbf7      {
0041dbff          if (esi <= data_430e00)
0041dbff          {
0041dc02              void* eax = sub_41cd19(esi);
0041dc02              
0041dc0a              if (eax)
0041dc0d                  return eax;
0041dbff          }
0041dbff          
0041dbff          goto label_41dc42;
0041dbf7      }
0041dbf7      
0041dc11      void* dwBytes;
0041dc11      
0041dc11      if (eax_5 != 2)
0041dc11      {
0041dc42      label_41dc42:
0041dc42          
0041dc42          if (!esi)
0041dc46              esi = 1;
0041dc46          
0041dc4a          dwBytes = ((char*)esi + 0xf) & 0xfffffff0;
0041dc11      }
0041dc11      else
0041dc11      {
0041dc19          dwBytes = !arg1 ? 0x10 : ((char*)arg1 + 0xf) & 0xfffffff0;
0041dc19          
0041dc2c          if (dwBytes <= data_42f5b4)
0041dc2c          {
0041dc34              void* eax_4 = sub_41d7bc(dwBytes >> 4);
0041dc34              
0041dc3c              if (eax_4)
0041dc5d                  return eax_4;
0041dc2c          }
0041dc11      }
0041dc11      
0041dc56      return HeapAlloc(data_430e04, HEAP_NONE, dwBytes);
0041dbea  }


0041dc5e    int32_t sub_41dc5e(int32_t* arg1)

0041dc5e  {
0041dc6e      if (sub_4256c8(arg1[4]))
0041dc6e      {
0041dc76          int32_t eax_1;
0041dc76          
0041dc76          if (arg1 == 0x42cc10)
0041dc76          {
0041dc78              eax_1 = 0;
0041dc87          label_41dc87:
0041dc87              data_43082c += 1;
0041dc87              
0041dc93              if (!(arg1[3] & 0x10c))
0041dc93              {
0041dcab                  void* eax_2;
0041dcab                  
0041dcab                  if (!*(uint32_t*)((eax_1 << 2) + &data_4309e0))
0041dcab                  {
0041dcae                      eax_2 = sub_41dbac(0x1000);
0041dcb6                      *(uint32_t*)((eax_1 << 2) + &data_4309e0) = eax_2;
0041dcab                  }
0041dcab                  
0041dcb8                  if (*(uint32_t*)((eax_1 << 2) + &data_4309e0) || eax_2)
0041dcb8                  {
0041dccd                      int32_t edi_1 = *(uint32_t*)((eax_1 << 2) + &data_4309e0);
0041dccf                      arg1[6] = 0x1000;
0041dcd2                      arg1[2] = edi_1;
0041dcd5                      *(uint32_t*)arg1 = edi_1;
0041dcd7                      arg1[1] = 0x1000;
0041dcb8                  }
0041dcb8                  else
0041dcb8                  {
0041dcbf                      arg1[2] = &arg1[5];
0041dcc2                      *(uint32_t*)arg1 = &arg1[5];
0041dcc5                      arg1[6] = 2;
0041dcc8                      arg1[1] = 2;
0041dcb8                  }
0041dcb8                  
0041dcda                  arg1[3] |= 0x1102;
0041dce6                  return 1;
0041dc93              }
0041dc76          }
0041dc76          else if (arg1 == 0x42cc30)
0041dc82          {
0041dc86              eax_1 = 1;
0041dc86              goto label_41dc87;
0041dc82          }
0041dc6e      }
0041dc6e      
0041dcea      return 0;
0041dc5e  }


0041dceb    void sub_41dceb(int32_t arg1, int32_t* arg2)

0041dceb  {
0041dcf1      if (!arg1)
0041dcf1      {
0041dd1d          if (*(uint8_t*)((char*)arg2 + 0xd) & 0x10)
0041dd20              sub_41ac69(arg2);
0041dcf1      }
0041dcf1      else if (*(uint8_t*)((char*)arg2 + 0xd) & 0x10)
0041dcfb      {
0041dcfe          sub_41ac69(arg2);
0041dd03          *(uint8_t*)((char*)arg2 + 0xd) &= 0xee;
0041dd07          arg2[6] = 0;
0041dd0b          *(uint32_t*)arg2 = 0;
0041dd0e          arg2[2] = 0;
0041dcfb      }
0041dceb  }


0041dd28    int32_t sub_41dd28(int32_t* arg1, void* arg2)

0041dd28  {
0041dd33      char* esi = arg2;
0041dd36      int32_t ecx = 0;
0041dd39      int32_t var_14 = 0;
0041dd3c      int32_t ebx;
0041dd3c      (uint8_t)ebx = *(uint8_t*)esi;
0041dd3e      void* esi_1 = &esi[1];
0041dd41      int32_t i = 0;
0041dd44      char* var_34 = nullptr;
0041dd47      arg2 = esi_1;
0041dd47      
0041dd4a      if ((uint8_t)ebx)
0041dd4a      {
0041dd6d          while (i >= 0)
0041dd6d          {
0041dd7b              int32_t eax_2;
0041dd7b              
0041dd7b              if ((uint8_t)ebx < 0x20 || (uint8_t)ebx > 0x78)
0041dd8b                  eax_2 = 0;
0041dd7b              else
0041dd7b              {
0041dd80                  int32_t eax_1;
0041dd80                  (uint8_t)eax_1 = data_4292b8[0x14][(int32_t)(uint8_t)ebx];
0041dd86                  eax_2 = eax_1 & 0xf;
0041dd7b              }
0041dd7b              
0041dd95              int32_t eax_4 = (int32_t)*(uint8_t*)(ecx + (eax_2 << 3) + 0x4292ec) >> 4;
0041dd9b              int32_t var_40_1 = eax_4;
0041dda4              int32_t var_44;
0041dda4              int32_t var_3c;
0041dda4              int32_t var_30;
0041dda4              int32_t var_2c;
0041dda4              int32_t* var_28;
0041dda4              void* var_c;
0041dda4              int32_t var_8;
0041dda4              void* arg_c;
0041dda4              
0041dda4              switch (eax_4)
0041dda4              {
0041dda4                  case 0:
0041dda4                  {
0041dda4                      goto label_41dee1;
0041dda4                  }
0041ddad                  case 1:
0041ddad                  {
0041ddad                      var_c = 0xffffffff;
0041ddb1                      var_44 = 0;
0041ddb4                      var_3c = 0;
0041ddb7                      var_2c = 0;
0041ddba                      var_28 = nullptr;
0041ddbd                      var_8 = 0;
0041ddc0                      var_30 = 0;
0041ddad                      break;
0041ddad                  }
0041ddc8                  case 2:
0041ddc8                  {
0041ddc8                      int32_t eax_5 = (int32_t)(uint8_t)ebx;
0041ddc8                      
0041ddce                      if (eax_5 == 0x20)
0041de0b                          var_8 |= 2;
0041ddce                      else if (eax_5 == 0x23)
0041de02                          (uint8_t)var_8 |= 0x80;
0041ddd3                      else if (eax_5 == 0x2b)
0041ddf9                          var_8 |= 1;
0041ddd8                      else if (eax_5 == 0x2d)
0041ddf0                          var_8 |= 4;
0041dddc                      else if (eax_5 == 0x30)
0041dde7                          var_8 |= 8;
0041ddc8                      break;
0041ddc8                  }
0041de17                  case 3:
0041de17                  {
0041de17                      if ((uint8_t)ebx != 0x2a)
0041de34                          var_2c = (int32_t)(uint8_t)ebx + var_2c * 0xa - 0x30;
0041de17                      else
0041de17                      {
0041de1d                          int32_t eax_12 = sub_41e564(&arg_c);
0041de25                          var_2c = eax_12;
0041de25                          
0041de28                          if (eax_12 < 0)
0041de28                          {
0041de2e                              var_8 |= 4;
0041de34                              var_2c = -(eax_12);
0041de28                          }
0041de17                      }
0041de17                      break;
0041de17                  }
0041de4b                  case 4:
0041de4b                  {
0041de4b                      var_c = nullptr;
0041de4b                      break;
0041de4b                  }
0041de57                  case 5:
0041de57                  {
0041de57                      if ((uint8_t)ebx != 0x2a)
0041de84                          var_c = (int32_t)(uint8_t)ebx + var_c * 0xa - 0x30;
0041de57                      else
0041de57                      {
0041de5d                          void* eax_16 = sub_41e564(&arg_c);
0041de65                          var_c = eax_16;
0041de65                          
0041de68                          if (eax_16 < 0)
0041de6e                              var_c = 0xffffffff;
0041de57                      }
0041de57                      break;
0041de57                  }
0041de8f                  case 6:
0041de8f                  {
0041de8f                      if ((uint8_t)ebx == 0x49)
0041de8f                      {
0041dec7                          if (*(uint8_t*)esi_1 != 0x36
0041dec7                              || *(uint8_t*)((char*)esi_1 + 1) != 0x34)
0041dec7                          {
0041ded7                              var_40_1 = 0;
0041dee1                          label_41dee1:
0041dee1                              var_30 = 0;
0041dee1                              
0041deed                              if (*(uint8_t*)(
0041deed                                  &(**(uint528_t**)&data_42ce70)[(uint32_t)(uint8_t)ebx]
0041deed                                  + 1) & 0x80)
0041deed                              {
0041defa                                  sub_41e4c6((int32_t)(uint8_t)ebx, arg1, &i);
0041deff                                  (uint8_t)ebx = *(uint8_t*)esi_1;
0041df05                                  arg2 = (char*)esi_1 + 1;
0041deed                              }
0041deed                              
0041df13                              sub_41e4c6((int32_t)(uint8_t)ebx, arg1, &i);
0041dec7                          }
0041dec7                          else
0041dec7                          {
0041decb                              *(uint8_t*)((char*)var_8)[1] |= 0x80;
0041decf                              arg2 = (char*)esi_1 + 2;
0041dec7                          }
0041de8f                      }
0041de8f                      else if ((uint8_t)ebx == 0x68)
0041deb5                          var_8 |= 0x20;
0041de94                      else if ((uint8_t)ebx == 0x6c)
0041deac                          var_8 |= 0x10;
0041de99                      else if ((uint8_t)ebx == 0x77)
0041dea4                          var_8 |= 0x800;
0041de8f                      break;
0041de8f                  }
0041df20                  case 7:
0041df20                  {
0041df20                      int32_t eax_23 = (int32_t)(uint8_t)ebx;
0041df26                      char var_1a;
0041df26                      int32_t var_10;
0041df26                      int32_t eax_42;
0041df26                      
0041df26                      if (eax_23 > 0x67)
0041df26                      {
0041e167                          int32_t var_38;
0041e167                          int32_t var_14_1;
0041e167                          
0041e167                          if (eax_23 == 0x69)
0041e167                          {
0041e23d                          label_41e23d:
0041e23d                              var_8 |= 0x40;
0041e241                          label_41e241:
0041e241                              var_14_1 = 0xa;
0041e24c                          label_41e24c:
0041e24c                              int32_t eax_60;
0041e24c                              int32_t edx_3;
0041e24c                              
0041e24c                              if (*(uint8_t*)((char*)var_8)[1] & 0x80)
0041e24c                              {
0041e251                                  void** var_260_14 = &arg_c;
0041e252                                  eax_60 = sub_41e571(var_260_14);
0041e257                                  ecx = var_260_14;
0041e24c                              }
0041e24c                              else if (!((uint8_t)var_8 & 0x20))
0041e25e                              {
0041e288                                  void** var_260_16 = &arg_c;
0041e288                                  
0041e289                                  if (!((uint8_t)var_8 & 0x40))
0041e289                                  {
0041e293                                      eax_60 = sub_41e564(var_260_16);
0041e298                                      ecx = var_260_16;
0041e299                                      edx_3 = 0;
0041e289                                  }
0041e289                                  else
0041e289                                  {
0041e290                                      ecx = var_260_16;
0041e273                                      edx_3 = HIGHD((int64_t)sub_41e564(var_260_16));
0041e273                                      eax_60 = LOWD((int64_t)sub_41e564(var_260_16));
0041e289                                  }
0041e25e                              }
0041e25e                              else
0041e25e                              {
0041e267                                  void** var_260_15 = &arg_c;
0041e268                                  int32_t eax_62;
0041e268                                  
0041e268                                  if (!((uint8_t)var_8 & 0x40))
0041e268                                  {
0041e27b                                      ecx = var_260_15;
0041e27c                                      eax_62 = (uint32_t)sub_41e564(var_260_15);
0041e268                                  }
0041e268                                  else
0041e268                                  {
0041e26f                                      ecx = var_260_15;
0041e270                                      eax_62 = (int32_t)sub_41e564(var_260_15);
0041e268                                  }
0041e268                                  
0041e273                                  edx_3 = HIGHD((int64_t)eax_62);
0041e273                                  eax_60 = LOWD((int64_t)eax_62);
0041e25e                              }
0041e25e                              
0041e2a9                              int32_t var_24_1;
0041e2a9                              int32_t var_20_1;
0041e2a9                              
0041e2a9                              if (!((uint8_t)var_8 & 0x40) || edx_3 > 0
0041e2a9                                  || (edx_3 >= 0 && eax_60 >= 0))
0041e2a9                              {
0041e2be                                  var_24_1 = eax_60;
0041e2c1                                  var_20_1 = edx_3;
0041e2a9                              }
0041e2a9                              else
0041e2a9                              {
0041e2b0                                  var_24_1 = -(eax_60);
0041e2b5                                  *(uint8_t*)((char*)var_8)[1] |= 1;
0041e2b9                                  var_20_1 = -((edx_3 + 0));
0041e2a9                              }
0041e2a9                              
0041e2c8                              if (!(*(uint8_t*)((char*)var_8)[1] & 0x80))
0041e2ca                                  var_20_1 = 0;
0041e2ca                              
0041e2d2                              if (var_c >= 0)
0041e2d2                              {
0041e2dd                                  var_8 &= 0xfffffff7;
0041e2dd                                  
0041e2e9                                  if (var_c > 0x200)
0041e2eb                                      var_c = 0x200;
0041e2d2                              }
0041e2d2                              else
0041e2d4                                  var_c = 1;
0041e2d4                              
0041e2f4                              if (!(var_24_1 | var_20_1))
0041e2f6                                  var_28 = nullptr;
0041e2f6                              
0041e2fd                              void var_51;
0041e2fd                              char* var_10_1 = &var_51;
0041e2fd                              
0041e300                              while (true)
0041e300                              {
0041e300                                  void* eax_67 = var_c;
0041e303                                  var_c -= 1;
0041e303                                  
0041e310                                  if (eax_67 <= 0 && !(var_24_1 | var_20_1))
0041e310                                      break;
0041e310                                  
0041e315                                  int32_t eax_71;
0041e315                                  uint32_t edx_6;
0041e315                                  edx_6 = HIGHD((int64_t)var_14_1);
0041e315                                  eax_71 = LOWD((int64_t)var_14_1);
0041e32e                                  ebx = __aullrem(var_24_1, var_20_1, eax_71, edx_6) + 0x30;
0041e334                                  uint32_t eax_73;
0041e334                                  int32_t edx_7;
0041e334                                  eax_73 = __aulldiv(var_24_1, var_20_1, eax_71, edx_6);
0041e33c                                  var_24_1 = eax_73;
0041e33f                                  var_20_1 = edx_7;
0041e33f                                  
0041e342                                  if (ebx > 0x39)
0041e344                                      ebx += var_38;
0041e344                                  
0041e347                                  char* eax_74 = var_10_1;
0041e34a                                  var_10_1 -= 1;
0041e34d                                  *(uint8_t*)eax_74 = (uint8_t)ebx;
0041e300                              }
0041e300                              
0041e354                              int32_t eax_75 = &var_51 - var_10_1;
0041e357                              var_10 = &var_10_1[1];
0041e35e                              var_14 = eax_75;
0041e35e                              
0041e361                              if (!(*(uint8_t*)((char*)var_8)[1] & 2))
0041e361                                  goto label_41e37c;
0041e361                              
0041e363                              ecx = var_10;
0041e363                              
0041e36d                              if (*(uint8_t*)ecx == 0x30 && eax_75)
0041e369                                  goto label_41e37c;
0041e369                              
0041e36f                              var_10 -= 1;
0041e372                              eax_42 = eax_75 + 1;
0041e373                              ecx = var_10;
0041e376                              *(uint8_t*)ecx = 0x30;
0041e376                              goto label_41e379;
0041e167                          }
0041e167                          
0041e170                          if (eax_23 != 0x6e)
0041e170                          {
0041e176                              int32_t eax_53 = eax_23 - 0x6f;
0041e176                              
0041e177                              if (eax_23 == 0x6f)
0041e177                              {
0041e205                                  var_14_1 = 8;
0041e205                                  
0041e20c                                  if ((uint8_t)var_8 & 0x80)
0041e20e                                      var_8 |= 0x200;
0041e20e                                  
0041e20c                                  goto label_41e24c;
0041e177                              }
0041e177                              
0041e17e                              if (eax_53 == 1)
0041e17e                              {
0041e1d1                                  var_c = 8;
0041e1d8                              label_41e1d8:
0041e1d8                                  var_38 = 7;
0041e1e3                              label_41e1e3:
0041e1e3                                  var_14_1 = 0x10;
0041e1e3                                  
0041e1ea                                  if ((uint8_t)var_8 & 0x80)
0041e1ea                                  {
0041e1ec                                      (uint8_t)eax_23 = (uint8_t)var_38;
0041e1ef                                      var_1a = 0x30;
0041e1f3                                      (uint8_t)eax_23 += 0x51;
0041e1f5                                      var_28 = 2;
0041e1fc                                      char var_19_1 = (uint8_t)eax_23;
0041e1ea                                  }
0041e1ea                                  
0041e1ea                                  goto label_41e24c;
0041e17e                              }
0041e17e                              
0041e183                              if (eax_53 != 4)
0041e183                              {
0041e18b                                  if (eax_53 == 6)
0041e18b                                      goto label_41e241;
0041e18b                                  
0041e194                                  if (eax_53 != 9)
0041e194                                      goto label_41e37c;
0041e194                                  
0041e19a                                  var_38 = 0x27;
0041e1a1                                  goto label_41e1e3;
0041e183                              }
0041e183                              
0041df6d                          label_41df6d:
0041df6d                              void* esi_5 = 0x7fffffff;
0041df6d                              
0041df72                              if (var_c != 0xffffffff)
0041df74                                  esi_5 = var_c;
0041df74                              
0041df87                              ecx = sub_41e564(&arg_c);
0041df89                              var_10 = ecx;
0041df89                              
0041df8c                              if (!((uint16_t)var_8 & 0x810))
0041df8c                              {
0041e1ae                                  if (!ecx)
0041e1ae                                  {
0041e1b0                                      ecx = data_42f5b8;
0041e1b6                                      var_10 = ecx;
0041e1ae                                  }
0041e1ae                                  
0041e1b9                                  int32_t eax_58 = ecx;
0041e1b9                                  
0041e1bb                                  while (true)
0041e1bb                                  {
0041e1bb                                      void* edx_2 = esi_5;
0041e1bd                                      esi_5 -= 1;
0041e1bd                                      
0041e1c0                                      if (!edx_2)
0041e1c0                                          break;
0041e1c0                                      
0041e1c5                                      if (!*(uint8_t*)eax_58)
0041e1c5                                          break;
0041e1c5                                      
0041e1c7                                      eax_58 += 1;
0041e1bb                                  }
0041e1bb                                  
0041e1ca                                  eax_42 = eax_58 - ecx;
0041df8c                              }
0041df8c                              else
0041df8c                              {
0041df94                                  if (!ecx)
0041df94                                  {
0041df96                                      ecx = data_42f5bc;
0041df9c                                      var_10 = ecx;
0041df94                                  }
0041df94                                  
0041df9f                                  var_30 = 1;
0041dfa6                                  int32_t eax_31 = ecx;
0041dfa6                                  
0041dfa8                                  while (true)
0041dfa8                                  {
0041dfa8                                      void* edx_1 = esi_5;
0041dfaa                                      esi_5 -= 1;
0041dfaa                                      
0041dfad                                      if (!edx_1)
0041dfad                                          break;
0041dfad                                      
0041dfb7                                      if (!*(uint16_t*)eax_31)
0041dfb7                                          break;
0041dfb7                                      
0041dfbe                                      eax_31 += 2;
0041dfa8                                  }
0041dfa8                                  
0041e1a5                                  eax_42 = (eax_31 - ecx) >> 1;
0041df8c                              }
0041df8c                              
0041df8c                              goto label_41e379;
0041e170                          }
0041e170                          
0041e217                          int16_t* eax_59 = sub_41e564(&arg_c);
0041e217                          
0041e221                          if (!((uint8_t)var_8 & 0x20))
0041e221                          {
0041e22c                              ecx = i;
0041e22f                              *(uint32_t*)eax_59 = ecx;
0041e221                          }
0041e221                          else
0041e221                          {
0041e223                              (uint16_t)ecx = (uint16_t)i;
0041e227                              *(uint16_t*)eax_59 = (uint16_t)ecx;
0041e221                          }
0041e221                          
0041e231                          var_3c = 1;
0041df26                      }
0041df26                      else
0041df26                      {
0041df2f                          if (eax_23 >= 0x65)
0041df2f                              goto label_41dfcb;
0041df2f                          
0041df38                          char* var_260_8;
0041df38                          char var_250;
0041df38                          
0041df38                          if (eax_23 <= 0x58)
0041df38                          {
0041df3e                              if (eax_23 == 0x58)
0041df3e                                  goto label_41e1d8;
0041df3e                              
0041df47                              if (eax_23 == 0x43)
0041df47                              {
0041dff4                                  if (!((uint16_t)var_8 & 0x830))
0041dff6                                      var_8 |= 0x800;
0041dff6                                  
0041dff4                                  goto label_41e002;
0041df47                              }
0041df47                              
0041df53                              if (eax_23 != 0x45 && eax_23 != 0x47)
0041df53                              {
0041df58                                  if (eax_23 != 0x53)
0041df58                                      goto label_41e37c;
0041df58                                  
0041df64                                  if (!((uint16_t)var_8 & 0x830))
0041df66                                      var_8 |= 0x800;
0041df66                                  
0041df64                                  goto label_41df6d;
0041df53                              }
0041df53                              
0041dfc1                              var_44 = 1;
0041dfc8                              (uint8_t)ebx += 0x20;
0041dfcb                          label_41dfcb:
0041dfcb                              var_8 |= 0x40;
0041dfd3                              char* edi_1 = &var_250;
0041dfd9                              var_10 = &var_250;
0041dfd9                              
0041dfdc                              if (var_c < 0)
0041dfe2                                  var_c = 6;
0041dfdc                              else if (var_c)
0041e0af                              {
0041e0c2                                  if (var_c > 0x200)
0041e0c4                                      var_c = 0x200;
0041e0c4                                  
0041e0ce                                  if (var_c > 0xa3)
0041e0ce                                  {
0041e0d9                                      char* eax_46 = sub_41dbac((char*)var_c + 0x15d);
0041e0e1                                      var_34 = eax_46;
0041e0e1                                      
0041e0e4                                      if (!eax_46)
0041e0ed                                          var_c = 0xa3;
0041e0e4                                      else
0041e0e4                                      {
0041e0e6                                          edi_1 = eax_46;
0041e0e8                                          var_10 = edi_1;
0041e0e4                                      }
0041e0ce                                  }
0041e0af                              }
0041e0af                              else if ((uint8_t)ebx == 0x67)
0041e0b6                                  var_c = 1;
0041e0b6                              
0041e0fa                              void* eax_48 = (char*)arg_c + 8;
0041e0fd                              arg_c = eax_48;
0041e106                              int32_t var_50 = *(uint32_t*)((char*)eax_48 - 8);
0041e10c                              int32_t var_4c_1 = *(uint32_t*)((char*)eax_48 - 4);
0041e118                              data_42d380(&var_50, edi_1, (int32_t)(uint8_t)ebx, var_c, 
0041e118                                  var_44);
0041e124                              int32_t esi_7 = var_8 & 0x80;
0041e124                              
0041e130                              if (esi_7 && !var_c)
0041e133                                  data_42d38c(edi_1);
0041e133                              
0041e141                              if ((uint8_t)ebx == 0x67 && !esi_7)
0041e144                                  data_42d384(edi_1);
0041e144                              
0041e14e                              if (*(uint8_t*)edi_1 == 0x2d)
0041e14e                              {
0041e150                                  *(uint8_t*)((char*)var_8)[1] |= 1;
0041e154                                  edi_1 = &edi_1[1];
0041e155                                  var_10 = edi_1;
0041e14e                              }
0041e14e                              
0041e158                              var_260_8 = edi_1;
0041e12a                              goto label_41e159;
0041df38                          }
0041df38                          
0041e02d                          if (eax_23 != 0x5a)
0041e02d                          {
0041e032                              if (eax_23 != 0x63)
0041e032                              {
0041e035                                  if (eax_23 == 0x64)
0041e035                                      goto label_41e23d;
0041e035                                  
0041e035                                  goto label_41e37c;
0041e032                              }
0041e032                              
0041e002                          label_41e002:
0041e002                              int32_t* var_260_6 = &arg_c;
0041e002                              
0041e003                              if (!((uint16_t)var_8 & 0x810))
0041e003                              {
0041e045                                  ecx = var_260_6;
0041e046                                  var_250 = sub_41e564(var_260_6);
0041e04c                                  var_14 = 1;
0041e003                              }
0041e003                              else
0041e003                              {
0041e012                                  int32_t eax_34;
0041e012                                  eax_34 = sub_4256ee(&var_250, sub_41e581(var_260_6));
0041e01a                                  var_14 = eax_34;
0041e01a                                  
0041e01f                                  if (eax_34 < 0)
0041e021                                      var_3c = 1;
0041e003                              }
0041e003                              
0041e059                              var_10 = &var_250;
0041e05c                              goto label_41e37c;
0041e02d                          }
0041e02d                          
0041e065                          int16_t* eax_39 = sub_41e564(&arg_c);
0041e065                          
0041e06d                          if (eax_39)
0041e06f                              ecx = *(uint32_t*)((char*)eax_39 + 4);
0041e06f                          
0041e074                          if (!eax_39 || !ecx)
0041e074                          {
0041e0a1                              char* eax_43 = data_42f5b8;
0041e0a6                              var_10 = eax_43;
0041e0a9                              var_260_8 = eax_43;
0041e159                          label_41e159:
0041e159                              eax_42 = sub_41e7d0(var_260_8);
0041e15e                              ecx = var_260_8;
0041e379                          label_41e379:
0041e379                              var_14 = eax_42;
0041e379                              goto label_41e37c;
0041e074                          }
0041e074                          
0041e079                          if (!(var_8 & 0x800))
0041e079                          {
0041e092                              var_30 = 0;
0041e096                              var_10 = ecx;
0041e099                              eax_42 = (int32_t)*(uint16_t*)eax_39;
0041e09c                              goto label_41e379;
0041e079                          }
0041e079                          
0041e080                          var_10 = ecx;
0041e083                          var_14 = (int32_t)*(uint16_t*)eax_39 >> 1;
0041e086                          var_30 = 1;
0041e37c                      label_41e37c:
0041e37c                          
0041e380                          if (!var_3c)
0041e380                          {
0041e38c                              if ((uint8_t)var_8 & 0x40)
0041e38c                              {
0041e391                                  if (*(uint8_t*)((char*)var_8)[1] & 1)
0041e391                                  {
0041e393                                      var_1a = 0x2d;
0041e3ad                                      var_28 = 1;
0041e391                                  }
0041e391                                  else if ((uint8_t)var_8 & 1)
0041e39c                                  {
0041e39e                                      var_1a = 0x2b;
0041e3ad                                      var_28 = 1;
0041e39c                                  }
0041e39c                                  else if ((uint8_t)var_8 & 2)
0041e3a7                                  {
0041e3a9                                      var_1a = 0x20;
0041e3ad                                      var_28 = 1;
0041e3a7                                  }
0041e38c                              }
0041e38c                              
0041e3ba                              int32_t* esi_11 = var_2c - var_28 - var_14;
0041e3ba                              
0041e3c0                              if (!((uint8_t)var_8 & 0xc))
0041e3cc                                  sub_41e4fb(0x20, esi_11, arg1, &i);
0041e3cc                              
0041e3e2                              sub_41e52c(&var_1a, var_28, arg1, &i);
0041e3e2                              
0041e3f2                              if ((uint8_t)var_8 & 8 && !((uint8_t)var_8 & 4))
0041e3fe                                  sub_41e4fb(0x30, esi_11, arg1, &i);
0041e3fe                              
0041e410                              if (!var_30 || var_14 <= 0)
0041e45a                                  ecx = sub_41e52c(var_10, var_14, arg1, &i);
0041e410                              else
0041e410                              {
0041e415                                  ebx = var_10;
0041e418                                  int32_t j_1 = var_14 - 1;
0041e449                                  int32_t j;
0041e449                                  
0041e449                                  do
0041e449                                  {
0041e41b                                      (uint16_t)j = *(uint16_t*)ebx;
0041e424                                      ebx += 2;
0041e425                                      void var_48;
0041e425                                      BOOL eax_76 = sub_4256ee(&var_48, (uint16_t)j);
0041e42d                                      ecx = j;
0041e42d                                      
0041e42e                                      if (eax_76 <= 0)
0041e42e                                          break;
0041e42e                                      
0041e43c                                      ecx = sub_41e52c(&var_48, eax_76, arg1, &i);
0041e444                                      j = j_1;
0041e446                                      j_1 -= 1;
0041e449                                  } while (j);
0041e410                              }
0041e410                              
0041e466                              if ((uint8_t)var_8 & 4)
0041e472                                  ecx = sub_41e4fb(0x20, esi_11, arg1, &i);
0041e380                          }
0041df26                      }
0041df26                      
0041e47e                      if (var_34)
0041e47e                      {
0041e480                          char* var_260_26 = var_34;
0041e483                          sub_41784c(ecx);
0041e488                          var_34 = nullptr;
0041e47e                      }
0041df20                      break;
0041df20                  }
0041dda4              }
0041dda4              
0041e490              (uint8_t)ebx = *(uint8_t*)arg2;
0041e492              esi_1 = (char*)arg2 + 1;
0041e495              arg2 = esi_1;
0041e495              
0041e498              if (!(uint8_t)ebx)
0041e498                  break;
0041e498              
0041dd5c              ecx = var_40_1;
0041dd6d          }
0041dd4a      }
0041dd4a      
0041e4a5      return i;
0041dd28  }

0041e4a6  uint32_t jump_table_41e4a6[0x8] = 
0041e4a6  {
0041e4a6      [0x0] =  0x0041dedb
0041e4aa      [0x1] =  0x0041ddab
0041e4ae      [0x2] =  0x0041ddc8
0041e4b2      [0x3] =  0x0041de14
0041e4b6      [0x4] =  0x0041de4b
0041e4ba      [0x5] =  0x0041de54
0041e4be      [0x6] =  0x0041de8c
0041e4c2      [0x7] =  0x0041df20
0041e4c6  }

0041e4c6    int32_t* sub_41e4c6(int32_t* arg1, int32_t* arg2, int32_t* arg3)

0041e4c6  {
0041e4cc      int32_t temp0 = arg2[1];
0041e4cc      arg2[1] -= 1;
0041e4cf      uint32_t eax_1;
0041e4cf      
0041e4cf      if (temp0 - 1 < 0)
0041e4cf      {
0041e4df          int32_t* var_8_1 = arg2;
0041e4e3          eax_1 = sub_41e84b(arg1);
0041e4cf      }
0041e4cf      else
0041e4cf      {
0041e4d3          char eax = (uint8_t)arg1;
0041e4d6          **(uint8_t**)arg2 = eax;
0041e4d8          *(uint32_t*)arg2 += 1;
0041e4da          eax_1 = (uint32_t)eax;
0041e4cf      }
0041e4cf      
0041e4f0      if (eax_1 != 0xffffffff)
0041e4f0      {
0041e4f7          *(uint32_t*)arg3 += 1;
0041e4fa          return arg3;
0041e4f0      }
0041e4f0      
0041e4f2      *(uint32_t*)arg3 = 0xffffffff;
0041e4f6      return arg3;
0041e4c6  }


0041e4fb    int32_t* sub_41e4fb(int32_t* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)

0041e4fb  {
0041e501      int32_t* i = arg2;
0041e503      int32_t* i_1 = (char*)arg2 - 1;
0041e503      
0041e506      while (i > 0)
0041e506      {
0041e515          i = sub_41e4c6(arg1, arg3, arg4);
0041e515          
0041e520          if (*(uint32_t*)arg4 == 0xffffffff)
0041e520              break;
0041e520          
0041e522          i = i_1;
0041e524          i_1 -= 1;
0041e506      }
0041e506      
0041e52b      return i;
0041e4fb  }


0041e52c    int32_t* sub_41e52c(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)

0041e52c  {
0041e531      int32_t* i = arg2;
0041e533      int32_t* i_1 = (char*)arg2 - 1;
0041e533      
0041e538      if (i > 0)
0041e538      {
0041e53e          char* esi_1 = arg1;
0041e53e          
0041e55e          do
0041e55e          {
0041e542              int32_t eax = (int32_t)*(uint8_t*)esi_1;
0041e546              esi_1 = &esi_1[1];
0041e54c              i = sub_41e4c6(eax, arg3, arg4);
0041e54c              
0041e557              if (*(uint32_t*)arg4 == 0xffffffff)
0041e557                  break;
0041e557              
0041e559              i = i_1;
0041e55b              i_1 -= 1;
0041e55e          } while (i > 0);
0041e538      }
0041e538      
0041e563      return i;
0041e52c  }


0041e564    int32_t sub_41e564(int32_t* arg1)

0041e564  {
0041e568      *(uint32_t*)arg1 += 4;
0041e570      return *(uint32_t*)(*(uint32_t*)arg1 - 4);
0041e564  }


0041e571    int32_t sub_41e571(int32_t* arg1)

0041e571  {
0041e575      *(uint32_t*)arg1 += 8;
0041e578      void* ecx = *(uint32_t*)arg1;
0041e57d      *(uint32_t*)((char*)ecx - 4);
0041e580      return *(uint32_t*)((char*)ecx - 8);
0041e571  }


0041e581    void* sub_41e581(int32_t* arg1)

0041e581  {
0041e585      *(uint32_t*)arg1 += 4;
0041e58a      void* result;
0041e58a      (uint16_t)result = *(uint16_t*)(*(uint32_t*)arg1 - 4);
0041e58e      return result;
0041e581  }


0041e58f    int32_t sub_41e58f()

0041e58f  {
0041e592      int32_t var_8 = 0xffffffff;
0041e594      int32_t var_c = 0x429358;
0041e599      int32_t var_10 = 0x41c5cc;
0041e5a4      TEB* fsbase;
0041e5a4      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
0041e5a5      fsbase->NtTib.ExceptionList = &ExceptionList;
0041e5b2      int32_t __saved_edi;
0041e5b2      int32_t* var_1c = &__saved_edi;
0041e5b5      int32_t var_8_1 = 0;
0041e5c1      int32_t var_20 = 1;
0041e5df      int32_t var_8_2 = 0xffffffff;
0041e5e6      fsbase->NtTib.ExceptionList = ExceptionList;
0041e5f1      return 1;
0041e58f  }


0041e5c6    int32_t sub_41e5c6(void* arg1 @ ebp)

0041e5c6  {
0041e5d4      int32_t result;
0041e5d4      (uint8_t)result = ***(uint32_t***)((char*)arg1 - 0x14) == 0xc0000005;
0041e5d9      return result;
0041e5c6  }

0041e5da                                                                                8b 65 e8 33 c0                               .e.3.

0041e5f4    BOOL sub_41e5f4(uint32_t arg1, uint8_t* arg2, int32_t arg3, uint16_t* arg4, uint32_t arg5, uint32_t arg6, int32_t arg7)

0041e5f4  {
0041e5f7      int32_t var_8 = 0xffffffff;
0041e5f9      int32_t var_c = 0x429370;
0041e5fe      int32_t var_10 = 0x41c5cc;
0041e609      TEB* fsbase;
0041e609      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
0041e60a      fsbase->NtTib.ExceptionList = &ExceptionList;
0041e617      int32_t __saved_edi;
0041e617      int32_t* var_1c = &__saved_edi;
0041e61a      int32_t eax_1 = data_4309e8;
0041e61a      
0041e623      if (eax_1)
0041e623          goto label_41e663;
0041e623      
0041e63b      uint16_t charType;
0041e63b      BOOL result;
0041e63b      
0041e63b      if (!GetStringTypeW(1, &data_429368, 1, &charType))
0041e63b      {
0041e655          if (GetStringTypeA(0, 1, &data_429364, 1, &charType))
0041e655          {
0041e65d              eax_1 = 2;
0041e65d              goto label_41e65e;
0041e655          }
0041e655          
0041e729          result = 0;
0041e63b      }
0041e63b      else
0041e63b      {
0041e63d          eax_1 = 1;
0041e65e      label_41e65e:
0041e65e          data_4309e8 = eax_1;
0041e663      label_41e663:
0041e663          
0041e666          if (eax_1 == 2)
0041e666          {
0041e668              uint32_t Locale = arg6;
0041e668              
0041e66d              if (!Locale)
0041e66f                  Locale = data_430a14;
0041e66f              
0041e681              result = GetStringTypeA(Locale, arg1, arg2, arg3, arg4);
0041e666          }
0041e666          else if (eax_1 != 1)
0041e729              result = 0;
0041e68f          else
0041e68f          {
0041e698              if (!arg5)
0041e69f                  arg5 = data_430a24;
0041e69f              
0041e6ad              int32_t eax_6 = -(arg7);
0041e6b9              int32_t cchWideChar = MultiByteToWideChar(arg5, ((eax_6 - eax_6) & 8) + 1, 
0041e6b9                  arg2, arg3, nullptr, 0);
0041e6b9              
0041e6c4              if (!cchWideChar)
0041e729                  result = 0;
0041e6c4              else
0041e6c4              {
0041e6c6                  int32_t var_8_1 = 0;
0041e6c9                  int32_t edi_1 = cchWideChar * 2;
0041e6d1                  int32_t eax_11;
0041e6d1                  (uint8_t)eax_11 = (edi_1 + 3) & 0xfc;
0041e6d3                  sub_425610(eax_11);
0041e6d8                  int32_t* var_1c_1 = &__saved_edi;
0041e6dd                  int32_t* var_28_1 = &__saved_edi;
0041e6e3                  sub_423620(&__saved_edi, 0, edi_1);
0041e6f8                  int32_t var_8_2 = 0xffffffff;
0041e6f8                  
0041e6fe                  if (!&__saved_edi)
0041e729                      result = 0;
0041e6fe                  else
0041e6fe                  {
0041e70f                      int32_t cchSrc = MultiByteToWideChar(arg5, MB_PRECOMPOSED, arg2, 
0041e70f                          arg3, &__saved_edi, cchWideChar);
0041e70f                      
0041e717                      if (!cchSrc)
0041e729                          result = 0;
0041e717                      else
0041e721                          result = GetStringTypeW(arg1, &__saved_edi, cchSrc, arg4);
0041e6fe                  }
0041e6c4              }
0041e68f          }
0041e63b      }
0041e63b      
0041e731      fsbase->NtTib.ExceptionList = ExceptionList;
0041e73c      return result;
0041e5f4  }


0041e6ed    int32_t sub_41e6ed() __pure

0041e6ed  {
0041e6f0      return 1;
0041e6ed  }

0041e6f1                                                     8b 65 e8 33 db 33 f6                                           .e.3.3.

0041e73d    int32_t sub_41e73d(void* arg1)

0041e73d  {
0041e752      int32_t edi = 0;
0041e759      void var_1c;
0041e759      char* var_8;
0041e759      char eax = sub_4257d5(&var_1c, &var_8, arg1, 0, 0, 0, 0);
0041e766      int32_t var_10;
0041e766      
0041e766      if (!(eax & 4))
0041e766      {
0041e77d          int32_t eax_1 = sub_424cd2(&var_1c, &var_10);
0041e77d          
0041e78c          if (eax & 2 || eax_1 == 1)
0041e78e              edi = 0x80;
0041e78e          
0041e79b          if (eax & 1 || eax_1 == 2)
0041e79d              edi |= 0x100;
0041e766      }
0041e766      else
0041e766      {
0041e768          edi = 0x200;
0041e76d          var_10 = 0;
0041e770          int32_t var_c_1 = 0;
0041e766      }
0041e766      
0041e7a8      **(uint32_t**)&data_42f5c0 = edi;
0041e7b8      *(uint32_t*)(data_42f5c0 + 4) = var_8 - arg1;
0041e7c4      *(uint64_t*)(data_42f5c0 + 0x10) = (double)(long double)var_10;
0041e7cd      return data_42f5c0;
0041e73d  }

0041e7ce                                            cc cc                                                                ..

0041e7d0    void* sub_41e7d0(char* arg1)

0041e7d0  {
0041e7d0      char* ecx = arg1;
0041e7d0      
0041e7da      while (ecx & 3)
0041e7da      {
0041e7dc          int32_t eax;
0041e7dc          (uint8_t)eax = *(uint8_t*)ecx;
0041e7de          ecx = &ecx[1];
0041e7de          
0041e7e1          if (!(uint8_t)eax)
0041e82c              return &ecx[0xffffffff] - arg1;
0041e7da      }
0041e7da      
0041e7f0      while (true)
0041e7f0      {
0041e7f0          int32_t eax_2 = *(uint32_t*)ecx;
0041e7fe          ecx = &ecx[4];
0041e7fe          
0041e806          if ((eax_2 ^ 0xffffffff ^ (0x7efefeff + eax_2)) & 0x81010100)
0041e806          {
0041e808              int32_t eax_5 = *(uint32_t*)(ecx - 4);
0041e808              
0041e80d              if (!(uint8_t)eax_5)
0041e84a                  return &ecx[0xfffffffc] - arg1;
0041e84a              
0041e811              if (!*(uint8_t*)((char*)eax_5)[1])
0041e840                  return &ecx[0xfffffffd] - arg1;
0041e840              
0041e818              if (!(eax_5 & 0xff0000))
0041e836                  return &ecx[0xfffffffe] - arg1;
0041e836              
0041e81f              if (!(eax_5 & 0xff000000))
0041e81f                  break;
0041e806          }
0041e7f0      }
0041e7f0      
0041e82c      return &ecx[0xffffffff] - arg1;
0041e7d0  }


0041e84b    uint32_t sub_41e84b(int32_t* arg1)

0041e84b  {
0041e850      int32_t* esi = arg1;
0041e853      int32_t eax = esi[3];
0041e856      enum WIN32_ERROR ebx = esi[4];
0041e856      
0041e863      if (!((uint8_t)eax & 0x82) || (uint8_t)eax & 0x40)
0041e863      {
0041e954          (uint8_t)eax |= 0x20;
0041e956          esi[3] = eax;
0041e863      }
0041e863      else
0041e863      {
0041e86b          if (!((uint8_t)eax & 1))
0041e86b              goto label_41e883;
0041e86b          
0041e86d          esi[1] = 0;
0041e86d          
0041e873          if (!((uint8_t)eax & 0x10))
0041e873          {
0041e954              (uint8_t)eax |= 0x20;
0041e956              esi[3] = eax;
0041e873          }
0041e873          else
0041e873          {
0041e87c              (uint8_t)eax &= 0xfe;
0041e87e              *(uint32_t*)esi = esi[2];
0041e880              esi[3] = eax;
0041e883          label_41e883:
0041e883              int32_t eax_1 = esi[3];
0041e886              esi[1] = 0;
0041e88a              arg1 = nullptr;
0041e88e              (uint8_t)eax_1 &= 0xef;
0041e890              (uint8_t)eax_1 |= 2;
0041e896              esi[3] = eax_1;
0041e896              
0041e899              if (!((uint16_t)eax_1 & 0x10c))
0041e899              {
0041e8a9                  bool cond:3_1;
0041e8a9                  
0041e8a9                  if (esi == 0x42cc10 || esi == 0x42cc30)
0041e8b1                      cond:3_1 = sub_4256c8(ebx);
0041e8b1                  
0041e8b4                  if ((esi != 0x42cc10 && esi != 0x42cc30) || !cond:3_1)
0041e8b7                      sub_41c830(esi);
0041e899              }
0041e899              
0041e8c4              int32_t arg_4;
0041e8c4              uint32_t edi_2;
0041e8c4              
0041e8c4              if (!(esi[3] & 0x108))
0041e8c4              {
0041e92f                  edi_2 = 1;
0041e93b                  arg1 = sub_424602(ebx, &arg_4, 1);
0041e8c4              }
0041e8c4              else
0041e8c4              {
0041e8c6                  char* eax_3 = esi[2];
0041e8cb                  edi_2 = *(uint32_t*)esi - eax_3;
0041e8d0                  *(uint32_t*)esi = &eax_3[1];
0041e8d8                  esi[1] = esi[6] - 1;
0041e8db                  int32_t ecx_6;
0041e8db                  
0041e8db                  if (edi_2 <= 0)
0041e8db                  {
0041e8f0                      void* eax_8;
0041e8f0                      
0041e8f0                      if (ebx == ~NO_ERROR)
0041e908                          eax_8 = &data_42d4e0;
0041e8f0                      else
0041e903                          eax_8 =
0041e903                              (&data_430e20)[ebx >> 5] + ((ebx & ERROR_GEN_FAILURE) << 3);
0041e903                      
0041e911                      if (*(uint8_t*)((char*)eax_8 + 4) & 0x20)
0041e918                          sub_41b825(ebx, 0, FILE_END);
0041e8db                  }
0041e8db                  else
0041e8db                  {
0041e8e0                      int32_t* eax_4;
0041e8e0                      eax_4 = sub_424602(ebx, eax_3, edi_2);
0041e8e8                      arg1 = eax_4;
0041e8db                  }
0041e8db                  
0041e923                  (uint8_t)ecx_6 = (uint8_t)arg_4;
0041e926                  *(uint8_t*)esi[2] = (uint8_t)ecx_6;
0041e8c4              }
0041e8c4              
0041e942              if (arg1 == edi_2)
0041e94d                  return (uint32_t)(uint8_t)arg_4;
0041e94d              
0041e944              esi[3] |= 0x20;
0041e873          }
0041e863      }
0041e863      
0041e959      return 0xffffffff;
0041e84b  }


0041e960    enum COMPARESTRING_RESULT sub_41e960(uint32_t arg1, uint32_t arg2, char* arg3, void* arg4, uint8_t* arg5, void* arg6, uint32_t arg7)

0041e960  {
0041e963      int32_t var_8 = 0xffffffff;
0041e965      int32_t var_c = 0x429380;
0041e96a      int32_t var_10 = 0x41c5cc;
0041e975      TEB* fsbase;
0041e975      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
0041e976      fsbase->NtTib.ExceptionList = &ExceptionList;
0041e983      int32_t __saved_edi;
0041e983      int32_t* var_1c = &__saved_edi;
0041e983      
0041e991      if (data_430a08)
0041e991          goto label_41e9d3;
0041e991      
0041e9a6      enum COMPARESTRING_RESULT result;
0041e9a6      
0041e9a6      if (!CompareStringW(0, 0, &data_429368, 1, &data_429368, 1))
0041e9a6      {
0041e9c3          if (CompareStringA(0, 0, &data_429364, 1, &data_429364, 1))
0041e9c3          {
0041e9c9              data_430a08 = 2;
0041e9c9              goto label_41e9d3;
0041e9c3          }
0041e9c3          
0041ebc9          result = 0;
0041e9a6      }
0041e9a6      else
0041e9a6      {
0041e9a8          data_430a08 = 1;
0041e9d3      label_41e9d3:
0041e9d3          void* esi_1 = arg4;
0041e9d3          
0041e9d8          if (esi_1 > 0)
0041e9d8          {
0041e9e5              esi_1 = sub_421132(arg3, esi_1);
0041e9e7              arg4 = esi_1;
0041e9d8          }
0041e9d8          
0041e9ed          if (arg6 > 0)
0041e9fc              arg6 = sub_421132(arg5, arg6);
0041e9fc          
0041e9ff          int32_t eax_5 = data_430a08;
0041e9ff          
0041ea07          if (eax_5 == 2)
0041ea19              result = CompareStringA(arg1, arg2, arg3, esi_1, arg5, arg6);
0041ea07          else if (eax_5 != 1)
0041ebc9              result = 0;
0041ea26          else
0041ea26          {
0041ea2f              if (!arg7)
0041ea36                  arg7 = data_430a24;
0041ea36              
0041ea40              if (esi_1 && arg6)
0041ea40              {
0041eae9              label_41eae9:
0041eae9                  int32_t eax_12 = MultiByteToWideChar(arg7, 
0041eae9                      MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, arg3, esi_1, nullptr, 0);
0041eae9                  
0041eaf4                  if (!eax_12)
0041ebc9                      result = 0;
0041eaf4                  else
0041eaf4                  {
0041eafa                      int32_t var_8_1 = 0;
0041eb02                      int32_t eax_14;
0041eb02                      (uint8_t)eax_14 = (eax_12 * 2 + 3) & 0xfc;
0041eb04                      sub_425610(eax_14);
0041eb09                      int32_t* var_1c_1 = &__saved_edi;
0041eb0e                      int32_t* var_28_1 = &__saved_edi;
0041eb11                      int32_t var_8_2 = 0xffffffff;
0041eb11                      
0041eb30                      if (!var_28_1)
0041ebc9                          result = 0;
0041eb30                      else if (!MultiByteToWideChar(arg7, MB_PRECOMPOSED, arg3, esi_1, 
0041eb30                              var_28_1, eax_12))
0041ebc9                          result = 0;
0041eb4e                      else
0041eb4e                      {
0041eb5d                          int32_t eax_16 = MultiByteToWideChar(arg7, 
0041eb5d                              MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, arg5, arg6, nullptr, 
0041eb5d                              0);
0041eb61                          int32_t var_24_1 = eax_16;
0041eb61                          
0041eb66                          if (!eax_16)
0041ebc9                              result = 0;
0041eb66                          else
0041eb66                          {
0041eb68                              int32_t var_8_3 = 1;
0041eb71                              int32_t eax_18;
0041eb71                              (uint8_t)eax_18 = (eax_16 * 2 + 3) & 0xfc;
0041eb73                              sub_425610(eax_18);
0041eb78                              int32_t* var_1c_2 = &__saved_edi;
0041eb7d                              int32_t* var_2c_1 = &__saved_edi;
0041eb80                              int32_t var_8_4 = 0xffffffff;
0041eb80                              
0041eb9a                              if (!&__saved_edi)
0041ebc9                                  result = 0;
0041eb9a                              else if (!MultiByteToWideChar(arg7, MB_PRECOMPOSED, arg5, 
0041eb9a                                      arg6, &__saved_edi, eax_16))
0041ebc9                                  result = 0;
0041ebb1                              else
0041ebc1                                  result = CompareStringW(arg1, arg2, var_28_1, eax_12, 
0041ebc1                                      &__saved_edi, eax_16);
0041eb66                          }
0041eb4e                      }
0041eaf4                  }
0041ea40              }
0041ea40              else if (esi_1 == arg6)
0041ea49              {
0041ea4b              label_41ea4b:
0041ea4d                  result = CSTR_EQUAL;
0041ea49              }
0041ea49              else if (arg6 > 1)
0041ea58                  result = CSTR_LESS_THAN;
0041ea56              else
0041ea56              {
0041ea61                  CPINFO cPInfo;
0041ea61                  
0041ea61                  if (esi_1 > 1)
0041ea4d                      result = CSTR_GREATER_THAN;
0041ea61                  else if (!GetCPInfo(arg7, &cPInfo))
0041ebc9                      result = 0;
0041ea72                  else
0041ea72                  {
0041ea7a                      var_3a;
0041ea7a                      char edx_1;
0041ea7a                      
0041ea7a                      if (esi_1 <= 0)
0041ea7a                      {
0041eaab                          if (arg6 <= 0)
0041eaab                              goto label_41eae9;
0041eaab                          
0041eab1                          if (cPInfo.MaxCharSize >= 2)
0041eab1                          {
0041eab3                              char* eax_10 = &var_3a;
0041eab3                              
0041eab9                              if (cPInfo.LeadByte[0])
0041eab9                              {
0041ead7                                  do
0041ead7                                  {
0041eabb                                      edx_1 = eax_10[1];
0041eabb                                      
0041eac0                                      if (!edx_1)
0041eac0                                          break;
0041eac0                                      
0041eac5                                      uint8_t* ecx_4;
0041eac5                                      (uint8_t)ecx_4 = *(uint8_t*)arg5;
0041eac5                                      
0041eacd                                      if ((uint8_t)ecx_4 >= *(uint8_t*)eax_10
0041eacd                                              && (uint8_t)ecx_4 <= edx_1)
0041eacd                                          goto label_41ea4b;
0041eacd                                      
0041ead4                                      eax_10 = &eax_10[2];
0041ead7                                  } while (*(uint8_t*)eax_10);
0041eab9                              }
0041eab1                          }
0041eab1                          
0041ea58                          result = CSTR_LESS_THAN;
0041ea7a                      }
0041ea7a                      else
0041ea7a                      {
0041ea80                          if (cPInfo.MaxCharSize >= 2)
0041ea80                          {
0041ea82                              char* eax_8 = &var_3a;
0041ea82                              
0041ea88                              if (cPInfo.LeadByte[0])
0041ea88                              {
0041eaa2                                  do
0041eaa2                                  {
0041ea8a                                      edx_1 = eax_8[1];
0041ea8a                                      
0041ea8f                                      if (!edx_1)
0041ea8f                                          break;
0041ea8f                                      
0041ea94                                      char* ecx_3;
0041ea94                                      (uint8_t)ecx_3 = *(uint8_t*)arg3;
0041ea94                                      
0041ea9c                                      if ((uint8_t)ecx_3 >= *(uint8_t*)eax_8
0041ea9c                                              && (uint8_t)ecx_3 <= edx_1)
0041ea9c                                          goto label_41ea4b;
0041ea9c                                      
0041ea9f                                      eax_8 = &eax_8[2];
0041eaa2                                  } while (*(uint8_t*)eax_8);
0041ea88                              }
0041ea80                          }
0041ea80                          
0041ea4d                          result = CSTR_GREATER_THAN;
0041ea7a                      }
0041ea72                  }
0041ea56              }
0041ea26          }
0041e9a6      }
0041e9a6      
0041ebd1      fsbase->NtTib.ExceptionList = ExceptionList;
0041ebdc      return result;
0041e960  }


0041eb17    int32_t sub_41eb17() __pure

0041eb17  {
0041eb1a      return 1;
0041eb17  }

0041eb1b                                                                                   8b 65 e8 33 db                             .e.3.
0041eb20  89 5d dc 83 4d fc ff 8b 75 14 6a 01 5f                                                           .]..M...u.j._

0041eb86    int32_t sub_41eb86() __pure

0041eb86  {
0041eb89      return 1;
0041eb86  }

0041eb8a                                8b 65 e8 33 db 33 ff 83 4d fc ff 8b 75 e0                                    .e.3.3..M...u.
0041ebdd                                                                                         cc cc cc                               ...

0041ebe0    int32_t sub_41ebe0(int32_t* arg1, char* arg2)

0041ebe0  {
0041ebe0      int32_t* edx = arg1;
0041ebe4      char* ecx = arg2;
0041ebee      uint32_t eax;
0041ebee      
0041ebee      if (edx & 3)
0041ebee      {
0041ec32          if (!(edx & 1))
0041ec32          {
0041ec48          label_41ec48:
0041ec48              (uint16_t)eax = *(uint16_t*)edx;
0041ec4b              edx += 2;
0041ec4e              char temp1_1 = *(uint8_t*)ecx;
0041ec4e              
0041ec50              if ((uint8_t)eax != temp1_1)
0041ec29                  return ((eax - eax) << 1) + 1;
0041ec29              
0041ec52              (uint8_t)eax = (uint8_t)eax;
0041ec52              
0041ec54              if (!(uint8_t)eax)
0041ec22                  return 0;
0041ec22              
0041ec56              char temp4_1 = ecx[1];
0041ec56              
0041ec59              if (*(uint8_t*)((char*)eax)[1] != temp4_1)
0041ec29                  return ((eax - eax) << 1) + 1;
0041ec29              
0041ec5b              *(uint8_t*)((char*)eax)[1] = *(uint8_t*)((char*)eax)[1];
0041ec5b              
0041ec5d              if (!*(uint8_t*)((char*)eax)[1])
0041ec22                  return 0;
0041ec22              
0041ec5f              ecx = &ecx[2];
0041ec32          }
0041ec32          else
0041ec32          {
0041ec34              (uint8_t)eax = *(uint8_t*)edx;
0041ec36              edx += 1;
0041ec37              char temp2_1 = *(uint8_t*)ecx;
0041ec37              
0041ec39              if ((uint8_t)eax != temp2_1)
0041ec29                  return ((eax - eax) << 1) + 1;
0041ec29              
0041ec3b              ecx = &ecx[1];
0041ec3c              (uint8_t)eax = (uint8_t)eax;
0041ec3c              
0041ec3e              if (!(uint8_t)eax)
0041ec22                  return 0;
0041ec22              
0041ec46              if (edx & 2)
0041ec46                  goto label_41ec48;
0041ec32          }
0041ebee      }
0041ebee      
0041ebf0      while (true)
0041ebf0      {
0041ebf0          eax = *(uint32_t*)edx;
0041ebf2          char temp0_1 = *(uint8_t*)ecx;
0041ebf2          
0041ebf4          if ((uint8_t)eax != temp0_1)
0041ec29              return ((eax - eax) << 1) + 1;
0041ec29          
0041ebf6          (uint8_t)eax = (uint8_t)eax;
0041ebf6          
0041ebf8          if (!(uint8_t)eax)
0041ec22              return 0;
0041ec22          
0041ebfa          char temp3_1 = ecx[1];
0041ebfa          
0041ebfd          if (*(uint8_t*)((char*)eax)[1] != temp3_1)
0041ec29              return ((eax - eax) << 1) + 1;
0041ec29          
0041ebff          *(uint8_t*)((char*)eax)[1] = *(uint8_t*)((char*)eax)[1];
0041ebff          
0041ec01          if (!*(uint8_t*)((char*)eax)[1])
0041ec22              return 0;
0041ec22          
0041ec03          eax u>>= 0x10;
0041ec06          char temp5_1 = ecx[2];
0041ec06          
0041ec09          if ((uint8_t)eax != temp5_1)
0041ec29              return ((eax - eax) << 1) + 1;
0041ec29          
0041ec0b          (uint8_t)eax = (uint8_t)eax;
0041ec0b          
0041ec0d          if (!(uint8_t)eax)
0041ec22              return 0;
0041ec22          
0041ec0f          char temp6_1 = ecx[3];
0041ec0f          
0041ec12          if (*(uint8_t*)((char*)eax)[1] != temp6_1)
0041ec29              return ((eax - eax) << 1) + 1;
0041ec29          
0041ec14          ecx = &ecx[4];
0041ec17          edx = &edx[1];
0041ec1a          *(uint8_t*)((char*)eax)[1] = *(uint8_t*)((char*)eax)[1];
0041ec1a          
0041ec1c          if (!*(uint8_t*)((char*)eax)[1])
0041ec22              return 0;
0041ebf0      }
0041ebe0  }

0041ec23           90                                                                                         .
0041ec2a                                8b ff                                                                        ..

0041ec64    long double __convention("regparm") sub_41ec64(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, double arg5, int32_t arg6)

0041ec64  {
0041ec6e      if (data_4304d0)
0041ec6e      {
0041ec9e          data_4307d4 = 0x21;
0041ecab          int16_t x87control;
0041ecab          sub_41f590(x87control, arg6, 0xffff);
0041ecb6          return (long double)arg5;
0041ec6e      }
0041ec6e      
0041ec76      int32_t var_c = arg3;
0041ec77      int32_t var_10 = arg3;
0041ec78      var_10 = (double)(long double)arg5;
0041ec7c      int32_t var_18 = arg3;
0041ec7f      var_18 = (double)(long double)0;
0041ec86      int32_t var_20 = arg3;
0041ec87      var_20 = (double)(long double)arg5;
0041ec98      return sub_41f31d(1, arg4, var_20, arg3, var_18, arg3, var_10, arg6);
0041ec64  }


0041ecb7    long double __convention("regparm") sub_41ecb7(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, double arg5, double arg6, int32_t arg7)

0041ecb7  {
0041ecba      int32_t var_8 = arg3;
0041ecbb      int32_t var_c = arg3;
0041ecc9      var_c = (double)((long double)arg5 + (long double)arg6);
0041ecc9      
0041eccc      if (data_4304d0)
0041eccc      {
0041ecfd          data_4307d4 = 0x21;
0041ed0a          int16_t x87control;
0041ed0a          sub_41f590(x87control, arg7, 0xffff);
0041ed15          return (long double)var_c;
0041eccc      }
0041eccc      
0041ecd4      int32_t var_14 = arg3;
0041ecd5      int32_t var_18 = arg3;
0041ecd6      var_18 = (double)(long double)var_c;
0041ecdd      int32_t var_20 = arg3;
0041ecde      var_20 = (double)(long double)arg6;
0041ece5      int32_t var_28 = arg3;
0041ece6      var_28 = (double)(long double)arg5;
0041ecf7      return sub_41f31d(1, arg4, var_28, arg3, var_20, arg3, var_18, arg7);
0041ecb7  }


0041ed16    long double sub_41ed16(int32_t arg1, int32_t arg2, int32_t arg3)

0041ed16  {
0041ed30      double arg_c;
0041ed30      double arg_14;
0041ed30      
0041ed30      if (!sub_41f106(arg1, &arg_14, (char)arg3))
0041ed30      {
0041ed35          int32_t var_24;
0041ed35          int32_t var_24_1 = var_24 & 0xfffffffe;
0041ed4c          void var_5c;
0041ed4c          sub_41ee53(&var_5c, &arg3, (uint8_t)arg1, arg2, &arg_c, &arg_14);
0041ed4c          /* no return */
0041ed30      }
0041ed30      
0041ed57      int32_t eax_1 = sub_41f3f0((uint8_t)arg1);
0041ed57      
0041ed68      if (data_4304d0 || !eax_1)
0041ed68      {
0041ed93          sub_41f3a5(eax_1);
0041eda2          int16_t x87control;
0041eda2          sub_41f590(x87control, arg3, 0xffff);
0041edad          return (long double)arg_14;
0041ed68      }
0041ed68      
0041ed70      int32_t var_64_2 = arg1;
0041ed71      int32_t var_68_2 = arg1;
0041ed72      var_68_2 = (double)(long double)arg_14;
0041ed76      int32_t var_70_1 = arg1;
0041ed79      var_70_1 = (double)(long double)0;
0041ed80      int32_t var_78 = arg1;
0041ed81      var_78 = (double)(long double)arg_c;
0041ed91      return sub_41f31d(eax_1, arg2, var_78, arg1, var_70_1, arg1, var_68_2, arg3);
0041ed16  }

0041ed51                                                     83 c4 18                                                       ...

0041edae    long double sub_41edae(int32_t arg1, int32_t arg2, double arg3, int32_t arg4)

0041edae  {
0041edc8      double arg_c;
0041edc8      double arg_1c;
0041edc8      
0041edc8      if (!sub_41f106(arg1, &arg_1c, (char)arg4))
0041edc8      {
0041edcd          int32_t var_24;
0041edcd          int32_t eax_1;
0041edcd          (uint8_t)eax_1 = (uint8_t)var_24 & 0xe3;
0041edcf          (uint8_t)eax_1 |= 3;
0041edd1          int32_t var_24_1 = eax_1;
0041ede8          double var_34 = (double)(long double)arg3;
0041edf0          void var_5c;
0041edf0          sub_41ee53(&var_5c, &arg4, (uint8_t)arg1, arg2, &arg_c, &arg_1c);
0041edf0          /* no return */
0041edc8      }
0041edc8      
0041edfb      int32_t eax_2 = sub_41f3f0((uint8_t)arg1);
0041edfb      
0041ee0c      if (data_4304d0 || !eax_2)
0041ee0c      {
0041ee38          sub_41f3a5(eax_2);
0041ee47          int16_t x87control;
0041ee47          sub_41f590(x87control, arg4, 0xffff);
0041ee52          return (long double)arg_1c;
0041ee0c      }
0041ee0c      
0041ee14      int32_t var_64_2 = arg1;
0041ee15      int32_t var_68_2 = arg1;
0041ee16      var_68_2 = (double)(long double)arg_1c;
0041ee1d      int32_t var_70_1 = arg1;
0041ee1e      var_70_1 = (double)(long double)arg3;
0041ee25      int32_t var_78 = arg1;
0041ee26      var_78 = (double)(long double)arg_c;
0041ee36      return sub_41f31d(eax_2, arg2, var_78, arg1, var_70_1, arg1, var_68_2, arg4);
0041edae  }


0041edf5    long double sub_41edf5(int32_t* arg1 @ ebp)

0041edf5  {
0041edf8      int32_t arg_14 = arg1[2];
0041edfb      int32_t eax = sub_41f3f0((uint8_t)arg_14);
0041edfb      
0041ee0c      if (data_4304d0 || !eax)
0041ee0c      {
0041ee38          sub_41f3a5(eax);
0041ee47          int16_t x87control;
0041ee47          sub_41f590(x87control, arg1[0xa], 0xffff);
0041ee51          *(uint32_t*)arg1;
0041ee52          return (long double)*(uint64_t*)((char*)arg1 + 0x20);
0041ee0c      }
0041ee0c      
0041ee14      int32_t arg_10 = arg_14;
0041ee15      int32_t arg_c = arg_14;
0041ee16      arg_c = (double)(long double)*(uint64_t*)((char*)arg1 + 0x20);
0041ee1d      int32_t arg_4 = arg_14;
0041ee1e      arg_4 = (double)(long double)*(uint64_t*)((char*)arg1 + 0x18);
0041ee25      int32_t var_4 = arg_14;
0041ee26      var_4 = (double)(long double)*(uint64_t*)((char*)arg1 + 0x10);
0041ee2d      int80_t result =
0041ee2d          sub_41f31d(eax, arg1[3], var_4, arg_14, arg_4, arg_14, arg_c, arg1[0xa]);
0041ee35      *(uint32_t*)arg1;
0041ee36      return result;
0041edf5  }


0041ee53    void sub_41ee53(uint32_t arg1, int32_t* arg2, char arg3, int32_t arg4, double* arg5, double* arg6) __noreturn

0041ee53  {
0041ee5d      *(uint32_t*)(arg1 + 4) = 0;
0041ee66      *(uint32_t*)(arg1 + 8) = 0;
0041ee6d      *(uint32_t*)(arg1 + 0xc) = 0;
0041ee70      uint32_t ecx_2;
0041ee70      (uint8_t)ecx_2 = arg3;
0041ee70      
0041ee76      if ((uint8_t)ecx_2 & 0x10)
0041ee76      {
0041ee78          uint32_t eax_1 = arg1;
0041ee7b          arg3 = 0xc000008f;
0041ee82          *(uint32_t*)(eax_1 + 4) |= 1;
0041ee76      }
0041ee76      
0041ee88      if ((uint8_t)ecx_2 & 2)
0041ee88      {
0041ee8a          uint32_t eax_2 = arg1;
0041ee8d          arg3 = 0xc0000093;
0041ee94          *(uint32_t*)(eax_2 + 4) |= 2;
0041ee88      }
0041ee88      
0041ee9a      if (1 & (uint8_t)ecx_2)
0041ee9a      {
0041ee9c          uint32_t eax_3 = arg1;
0041ee9f          arg3 = 0xc0000091;
0041eea6          *(uint32_t*)(eax_3 + 4) |= 4;
0041ee9a      }
0041ee9a      
0041eead      if ((uint8_t)ecx_2 & 4)
0041eead      {
0041eeaf          uint32_t eax_4 = arg1;
0041eeb2          arg3 = 0xc000008e;
0041eeb9          *(uint32_t*)(eax_4 + 4) |= 8;
0041eead      }
0041eead      
0041eec0      if ((uint8_t)ecx_2 & 8)
0041eec0      {
0041eec2          uint32_t eax_5 = arg1;
0041eec5          arg3 = 0xc0000090;
0041eecc          *(uint32_t*)(eax_5 + 4) |= 0x10;
0041eec0      }
0041eec0      
0041eed3      uint32_t eax_6 = arg1;
0041eeea      *(uint32_t*)(eax_6 + 8) =
0041eeea          (~*(uint32_t*)arg2 & 1) << 4 | (*(uint32_t*)(eax_6 + 8) & 0xffffffef);
0041eeef      uint32_t eax_7 = arg1;
0041ef01      *(uint32_t*)(eax_7 + 8) =
0041ef01          (~*(uint32_t*)arg2 & 4) << 1 | (*(uint32_t*)(eax_7 + 8) & 0xfffffff7);
0041ef06      uint32_t eax_8 = arg1;
0041ef18      *(uint32_t*)(eax_8 + 8) =
0041ef18          (~*(uint32_t*)arg2 >> 1 & 4) | (*(uint32_t*)(eax_8 + 8) & 0xfffffffb);
0041ef1d      uint32_t eax_9 = arg1;
0041ef2f      *(uint32_t*)(eax_9 + 8) =
0041ef2f          (~*(uint32_t*)arg2 >> 3 & 2) | (*(uint32_t*)(eax_9 + 8) & 0xfffffffd);
0041ef34      uint32_t eax_10 = arg1;
0041ef46      *(uint32_t*)(eax_10 + 8) =
0041ef46          (~*(uint32_t*)arg2 >> 5 & 1) | (*(uint32_t*)(eax_10 + 8) & 0xfffffffe);
0041ef49      char eax_11 = sub_41f573();
0041ef49      
0041ef50      if (1 & eax_11)
0041ef50      {
0041ef52          uint32_t ecx_28 = arg1;
0041ef55          *(uint32_t*)(ecx_28 + 0xc) |= 0x10;
0041ef50      }
0041ef50      
0041ef5b      if (eax_11 & 4)
0041ef5b      {
0041ef5d          uint32_t ecx_29 = arg1;
0041ef60          *(uint32_t*)(ecx_29 + 0xc) |= 8;
0041ef5b      }
0041ef5b      
0041ef66      if (eax_11 & 8)
0041ef66      {
0041ef68          uint32_t ecx_30 = arg1;
0041ef6b          *(uint32_t*)(ecx_30 + 0xc) |= 4;
0041ef66      }
0041ef66      
0041ef71      if (eax_11 & 0x10)
0041ef71      {
0041ef73          uint32_t ecx_31 = arg1;
0041ef76          *(uint32_t*)(ecx_31 + 0xc) |= 2;
0041ef71      }
0041ef71      
0041ef7b      if (eax_11 & 0x20)
0041ef7b      {
0041ef7d          uint32_t eax_12 = arg1;
0041ef80          *(uint32_t*)(eax_12 + 0xc) |= 1;
0041ef7b      }
0041ef7b      
0041ef8a      int32_t eax_14 = *(uint32_t*)arg2 & 0xc00;
0041ef8a      
0041ef8c      if (!eax_14)
0041ef8c      {
0041efc2          uint32_t eax_17 = arg1;
0041efc5          *(uint32_t*)eax_17 &= 0xfffffffc;
0041ef8c      }
0041ef8c      else
0041ef8c      {
0041ef93          uint32_t eax_16;
0041ef93          
0041ef93          if (eax_14 == 0x400)
0041ef93          {
0041efb4              eax_16 = arg1;
0041efbe              *(uint32_t*)eax_16 = (*(uint32_t*)eax_16 & 0xfffffffd) | 1;
0041ef93          }
0041ef93          else if (eax_14 == 0x800)
0041ef9a          {
0041efa8              eax_16 = arg1;
0041efbe              *(uint32_t*)eax_16 = (*(uint32_t*)eax_16 & 0xfffffffe) | 2;
0041ef9a          }
0041ef9a          else if (eax_14 == 0xc00)
0041ef9e          {
0041efa0              uint32_t eax_15 = arg1;
0041efa3              *(uint32_t*)eax_15 |= 3;
0041ef9e          }
0041ef8c      }
0041ef8c      
0041efcf      int32_t eax_19 = *(uint32_t*)arg2 & 0x300;
0041efd1      uint32_t eax_21;
0041efd1      
0041efd1      if (!eax_19)
0041efd1      {
0041eff3          eax_21 = arg1;
0041effe          *(uint32_t*)eax_21 = (*(uint32_t*)eax_21 & 0xffffffeb) | 8;
0041efd1      }
0041efd1      else if (eax_19 == 0x200)
0041efd8      {
0041efe6          eax_21 = arg1;
0041effe          *(uint32_t*)eax_21 = (*(uint32_t*)eax_21 & 0xffffffe7) | 4;
0041efd8      }
0041efd8      else if (eax_19 == 0x300)
0041efdc      {
0041efde          uint32_t eax_20 = arg1;
0041efe1          *(uint32_t*)eax_20 &= 0xffffffe3;
0041efdc      }
0041f000      uint32_t eax_22 = arg1;
0041f019      *(uint32_t*)eax_22 = (arg4 & 0xfff) << 5 | (*(uint32_t*)eax_22 & 0xfffe001f);
0041f01b      uint32_t eax_23 = arg1;
0041f01e      *(uint32_t*)(eax_23 + 0x20) |= 1;
0041f021      uint32_t eax_24 = arg1;
0041f02c      *(uint32_t*)(eax_24 + 0x20) = (*(uint32_t*)(eax_24 + 0x20) & 0xffffffe3) | 2;
0041f037      *(uint64_t*)(arg1 + 0x10) = (double)(long double)*(uint64_t*)arg5;
0041f03a      uint32_t eax_27 = arg1;
0041f03d      *(uint32_t*)(eax_27 + 0x50) |= 1;
0041f040      uint32_t eax_28 = arg1;
0041f04e      *(uint32_t*)(eax_28 + 0x50) = (*(uint32_t*)(eax_28 + 0x50) & 0xffffffe3) | 2;
0041f056      *(uint64_t*)(arg1 + 0x40) = (double)(long double)*(uint64_t*)arg6;
0041f059      sub_41f581();
0041f068      RaiseException(arg3, 0, 1, &arg1);
0041f068      /* no return */
0041ee53  }

0041f06e                                            8b 45 08 f6 40 08 10 74 03 83 26 fe f6 40 08 08 74 03                .E..@..t..&..@..t.
0041f080  83 26 fb f6 40 08 04 74 03 83 26 f7 f6 40 08 02 74 03 83 26 ef 84 58 08 74 03 83 26 df 8b 08 ba  .&..@..t..&..@..t..&..X.t..&....
0041f0a0  ff f3 ff ff 83 e1 03 83 e9 00 74 25 49 74 16 49 74 09 49 75 1e 80 4e 01 0c eb 18 8b 0e 80 e5 fb  ..........t%It.It.Iu..N.........
0041f0c0  80 cd 08 eb 08 8b 0e 80 e5 f7 80 cd 04 89 0e eb 02 21 16 8b 08 c1 e9 02 83 e1 07 83 e9 00 74 13  .................!............t.
0041f0e0  49 74 07 49 75 16 21 16 eb 12 8b 0e 23 ca 80 cd 02 eb 07 8b 0e 23 ca 80 cd 03 89 0e dd 40 40 dd  It.Iu.!.....#........#.......@@.
0041f100  1f 5f 5e 5b 5d c3                                                                                ._^[].

0041f106    int32_t sub_41f106(int32_t arg1, double* arg2, char arg3)

0041f106  {
0041f113      int32_t edi_1 = arg1 & 0x1f;
0041f120      long double st0;
0041f120      int80_t x87_r0;
0041f120      
0041f120      if ((uint8_t)arg1 & 8 && arg3 & 1)
0041f120      {
0041f123          sub_41f5b3(x87_r0, 1);
0041f129          edi_1 &= 0xfffffff7;
0041f120      }
0041f120      else if ((uint8_t)arg1 & 4 && arg3 & 4)
0041f139      {
0041f13d          sub_41f5b3(x87_r0, 4);
0041f143          edi_1 &= 0xfffffffb;
0041f139      }
0041f139      else if (1 & (uint8_t)arg1 && arg3 & 8)
0041f157      {
0041f15f          sub_41f5b3(x87_r0, 8);
0041f16d          int32_t ecx_4 = arg3 & 0xc00;
0041f16f          int16_t eax_1;
0041f16f          
0041f16f          if (!ecx_4)
0041f16f          {
0041f200              long double x87_r0_10 = (long double)*(uint64_t*)arg2;
0041f202              long double temp0_1 = (long double)0.0;
0041f202              x87_r0_10 - temp0_1;
0041f208              long double x87_r0_11 = (long double)data_42f6a8;
0041f20e              eax_1 = (x87_r0_10 < temp0_1 ? 1 : 0) << 8
0041f20e                  | (FCMP_UO(x87_r0_10, temp0_1) ? 1 : 0) << 0xa
0041f20e                  | (x87_r0_10 == temp0_1 ? 1 : 0) << 0xe;
0041f20e              
0041f211              if (TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 6)
0041f211                      || TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 0))
0041f213                  x87_r0_11 = -(x87_r0_11);
0041f213              
0041f21b              *(uint64_t*)arg2 = (double)(long double)(double)x87_r0_11;
0041f16f          }
0041f16f          else if (ecx_4 == 0x400)
0041f17b          {
0041f1d8              long double x87_r0_7 = (long double)*(uint64_t*)arg2;
0041f1da              long double temp2_1 = (long double)0.0;
0041f1da              x87_r0_7 - temp2_1;
0041f1e0              eax_1 = (x87_r0_7 < temp2_1 ? 1 : 0) << 8
0041f1e0                  | (FCMP_UO(x87_r0_7, temp2_1) ? 1 : 0) << 0xa
0041f1e0                  | (x87_r0_7 == temp2_1 ? 1 : 0) << 0xe | 0x800;
0041f1e3              long double x87_r0_8;
0041f1e3              
0041f1e3              if (TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 6)
0041f1e3                      || TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 0))
0041f1f3                  x87_r0_8 = -((long double)data_42f6a8);
0041f1e3              else
0041f1e5                  x87_r0_8 = (long double)data_42f6b8;
0041f1e5              
0041f21b              *(uint64_t*)arg2 = (double)(long double)(double)x87_r0_8;
0041f17b          }
0041f17b          else if (ecx_4 == 0x800)
0041f183          {
0041f1b0              long double x87_r0_4 = (long double)*(uint64_t*)arg2;
0041f1b2              long double temp3_1 = (long double)0.0;
0041f1b2              x87_r0_4 - temp3_1;
0041f1b8              eax_1 = (x87_r0_4 < temp3_1 ? 1 : 0) << 8
0041f1b8                  | (FCMP_UO(x87_r0_4, temp3_1) ? 1 : 0) << 0xa
0041f1b8                  | (x87_r0_4 == temp3_1 ? 1 : 0) << 0xe | 0x800;
0041f1bb              long double x87_r0_5;
0041f1bb              
0041f1bb              if (TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 6)
0041f1bb                      || TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 0))
0041f1cb                  x87_r0_5 = -((long double)data_42f6b8);
0041f1bb              else
0041f1bd                  x87_r0_5 = (long double)data_42f6a8;
0041f1bd              
0041f21b              *(uint64_t*)arg2 = (double)(long double)(double)x87_r0_5;
0041f183          }
0041f183          else if (ecx_4 == 0xc00)
0041f187          {
0041f190              long double x87_r0_1 = (long double)*(uint64_t*)arg2;
0041f192              long double temp5_1 = (long double)0.0;
0041f192              x87_r0_1 - temp5_1;
0041f198              long double x87_r0_2 = (long double)data_42f6b8;
0041f19e              eax_1 = (x87_r0_1 < temp5_1 ? 1 : 0) << 8
0041f19e                  | (FCMP_UO(x87_r0_1, temp5_1) ? 1 : 0) << 0xa
0041f19e                  | (x87_r0_1 == temp5_1 ? 1 : 0) << 0xe;
0041f19e              
0041f1a1              if (TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 6)
0041f1a1                      || TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 0))
0041f1a3                  x87_r0_2 = -(x87_r0_2);
0041f1a3              
0041f21b              *(uint64_t*)arg2 = (double)(long double)(double)x87_r0_2;
0041f187          }
0041f21d          edi_1 &= 0xfffffffe;
0041f157      }
0041f157      else if ((uint8_t)arg1 & 2 && arg3 & 0x10)
0041f231      {
0041f238          int32_t esi_1 = 0;
0041f238          
0041f23c          if ((uint8_t)arg1 & 0x10)
0041f23e              esi_1 = 1;
0041f23e          
0041f245          double var_10_5 = (double)(long double)*(uint64_t*)arg2;
0041f248          long double x87_r7_2 = (long double)var_10_5;
0041f24b          long double temp1_1 = (long double)0.0;
0041f24b          x87_r7_2 - temp1_1;
0041f251          double* eax_2;
0041f251          (uint16_t)eax_2 = (x87_r7_2 < temp1_1 ? 1 : 0) << 8
0041f251              | (FCMP_UO(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
0041f251              | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe;
0041f251          
0041f254          if (TEST_BITB(*(uint8_t*)((char*)eax_2)[1], 6))
0041f2e9              esi_1 = 1;
0041f254          else
0041f254          {
0041f261              int32_t ecx;
0041f261              int32_t var_24_1 = ecx;
0041f262              int32_t var_28_1 = ecx;
0041f263              var_28_1 = (double)(long double)var_10_5;
0041f266              int32_t var_8;
0041f266              st0 = sub_41f4b2(esi_1, var_28_1, &var_8);
0041f271              double var_10_6 = (double)st0;
0041f271              
0041f280              if (var_8 - 0x600 >= 0xfffffbce)
0041f280              {
0041f28b                  long double x87_r7_6 = (long double)var_10_6;
0041f28e                  long double temp4_1 = (long double)0.0;
0041f28e                  x87_r7_6 - temp4_1;
0041f294                  int32_t eax_3;
0041f294                  (uint16_t)eax_3 = (x87_r7_6 < temp4_1 ? 1 : 0) << 8
0041f294                      | (FCMP_UO(x87_r7_6, temp4_1) ? 1 : 0) << 0xa
0041f294                      | (x87_r7_6 == temp4_1 ? 1 : 0) << 0xe;
0041f297                  int32_t edx_1;
0041f297                  
0041f297                  edx_1 = !TEST_BITB(*(uint8_t*)((char*)eax_3)[1], 0) ? 0 : 1;
0041f297                  
0041f29f                  (uint8_t)eax_3 = *(uint8_t*)((char*)var_10_6)[6];
0041f2a5                  int16_t eax_4;
0041f2a5                  (uint8_t)eax_4 = ((uint16_t)eax_3 & 0xf) | 0x10;
0041f2a7                  *(uint16_t*)((char*)var_10_6)[6] = eax_4;
0041f2a7                  
0041f2b2                  if (var_8 - 0x600 < 0xfffffc03)
0041f2b2                  {
0041f2b4                      int32_t i_1 = 0xfffffc03 - (var_8 - 0x600);
0041f2d1                      int32_t i;
0041f2d1                      
0041f2d1                      do
0041f2d1                      {
0041f2bd                          if ((uint8_t)var_10_6 & 1 && !esi_1)
0041f2bf                              esi_1 = 1;
0041f2bf                          
0041f2c1                          (uint32_t)var_10_6 u>>= 1;
0041f2c1                          
0041f2c7                          if (*(uint8_t*)((char*)var_10_6)[4] & 1)
0041f2c9                              *(uint8_t*)((char*)var_10_6)[3] |= 0x80;
0041f2c9                          
0041f2cd                          *(uint32_t*)((char*)var_10_6)[4] u>>= 1;
0041f2d0                          i = i_1;
0041f2d0                          i_1 -= 1;
0041f2d1                      } while (i != 1);
0041f2b2                  }
0041f2b2                  
0041f2d5                  if (edx_1)
0041f2dc                      var_10_6 = (double)-((long double)var_10_6);
0041f280              }
0041f280              else
0041f280              {
0041f284                  esi_1 = 1;
0041f286                  var_10_6 = (double)(long double)0;
0041f280              }
0041f280              
0041f2e5              *(uint64_t*)arg2 = (double)(long double)var_10_6;
0041f254          }
0041f254          
0041f2ee          if (esi_1)
0041f2f2              sub_41f5b3(x87_r0, 0x10);
0041f2f2          
0041f2f8          edi_1 &= 0xfffffffd;
0041f231      }
0041f231      
0041f305      if ((uint8_t)arg1 & 0x10 && arg3 & 0x20)
0041f305      {
0041f309          sub_41f5b3(st0, 0x20);
0041f30f          edi_1 &= 0xffffffef;
0041f305      }
0041f305      
0041f318      int32_t result;
0041f318      (uint8_t)result = !edi_1;
0041f31c      return result;
0041f106  }


0041f31d    long double sub_41f31d(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, double arg7, int32_t arg8)

0041f31d  {
0041f326      int32_t eax = sub_41f3cb(arg2);
0041f32e      int32_t var_20 = eax;
0041f331      int16_t x87control;
0041f331      
0041f331      if (!eax)
0041f331      {
0041f390          sub_41f590(x87control, arg8, 0xffff);
0041f398          sub_41f3a5(arg1);
0041f3a4          return (long double)arg7;
0041f331      }
0041f331      
0041f337      int32_t var_1c = arg3;
0041f33d      int32_t var_18 = arg4;
0041f346      int32_t var_14 = arg5;
0041f354      int32_t var_10 = arg6;
0041f35a      int32_t var_24 = arg1;
0041f363      int32_t var_8 = *(uint32_t*)((char*)arg7)[4];
0041f366      sub_41f590(x87control, arg8, 0xffff);
0041f36e      int32_t* var_34 = &var_24;
0041f37c      sub_41f3a5(arg1);
0041f387      return (long double)(uint32_t)arg7;
0041f31d  }


0041f3a5    int32_t sub_41f3a5(int32_t arg1)

0041f3a5  {
0041f3ac      if (arg1 == 1)
0041f3c0          data_4307d4 = 0x21;
0041f3ac      else if (arg1 > 1 && arg1 <= 3)
0041f3b5          data_4307d4 = 0x22;
0041f3b5      
0041f3ca      return arg1;
0041f3a5  }


0041f3cb    int32_t sub_41f3cb(int32_t arg1)

0041f3cb  {
0041f3cb      int32_t ecx = 0;
0041f3cb      
0041f3e3      for (void* i = &data_42f5d0; i < &data_42f6a8; )
0041f3e3      {
0041f3d8          if (*(uint32_t*)i == arg1)
0041f3ef              return *(uint32_t*)((ecx << 3) + &data_42f5d4);
0041f3ef          
0041f3da          i += 8;
0041f3dd          ecx += 1;
0041f3e3      }
0041f3e3      
0041f3e7      return 0;
0041f3cb  }


0041f3f0    int32_t sub_41f3f0(char arg1) __pure

0041f3f0  {
0041f3f6      if (arg1 & 0x20)
0041f3f8          return 5;
0041f3f8      
0041f3fe      if (arg1 & 8)
0041f400          return 1;
0041f400      
0041f406      if (arg1 & 4)
0041f408          return 2;
0041f408      
0041f40e      if (!(arg1 & 1))
0041f41c          return ((uint32_t)arg1 & 2) << 1;
0041f41c      
0041f410      return 3;
0041f3f0  }


0041f41d    long double __frnd(double arg1) __pure

0041f41d  {
0041f420      int32_t ecx;
0041f420      int32_t var_8 = ecx;
0041f421      int32_t var_c = ecx;
0041f427      var_c = (double)round((long double)arg1, ecx);
0041f42e      return (long double)var_c;
0041f41d  }


0041f42f    long double sub_41f42f(double arg1, int16_t arg2, int32_t arg3) __pure

0041f42f  {
0041f432      int32_t ecx;
0041f432      int32_t var_8 = ecx;
0041f433      int32_t var_c = ecx;
0041f447      var_c = (double)(long double)arg1;
0041f44f      *(uint16_t*)((char*)var_8)[2] = (int16_t)((arg3 + 0x3fe) << 4) | (arg2 & 0x800f);
0041f457      return (long double)var_c;
0041f42f  }


0041f458    int32_t sub_41f458(int32_t arg1, int32_t arg2) __pure

0041f458  {
0041f464      if (arg2 != 0x7ff00000)
0041f464      {
0041f47b          if (arg2 == 0xfff00000 && !arg1)
0041f47d              return 2;
0041f464      }
0041f464      else if (!arg1)
0041f46b          return 1;
0041f46b      
0041f489      int16_t ecx_2 = *(uint16_t*)((char*)arg2)[2] & 0x7ff8;
0041f489      
0041f48e      if (ecx_2 == 0x7ff8)
0041f490          return 3;
0041f490      
0041f4a7      if (ecx_2 == 0x7ff0 && (arg2 & 0x7ffff || arg1))
0041f4a9          return 4;
0041f4a9      
0041f4b1      return 0;
0041f458  }


0041f4b2    long double sub_41f4b2(int32_t arg1 @ esi, double arg2, int32_t* arg3)

0041f4b2  {
0041f4b5      int32_t ecx;
0041f4b5      int32_t var_8 = ecx;
0041f4b6      int32_t var_c = ecx;
0041f4b7      long double x87_r7 = (long double)arg2;
0041f4ba      long double temp0 = (long double)0.0;
0041f4ba      x87_r7 - temp0;
0041f4c4      int32_t esi;
0041f4c4      
0041f4c4      if (TEST_BITB(
0041f4c4          *(uint8_t*)((char*)((x87_r7 < temp0 ? 1 : 0) << 8
0041f4c4              | (FCMP_UO(x87_r7, temp0) ? 1 : 0) << 0xa
0041f4c4              | (x87_r7 == temp0 ? 1 : 0) << 0xe))[1], 
0041f4c4          6))
0041f4c4      {
0041f4c8          esi = 0;
0041f4ca          var_c = (double)(long double)0;
0041f4c4      }
0041f4c4      else if (*(uint16_t*)((char*)arg2)[6] & 0x7ff0
0041f4c4          || (!(*(uint32_t*)((char*)arg2)[4] & 0xfffff) && !(uint32_t)arg2))
0041f4e8      {
0041f545          int32_t var_18_2 = 0;
0041f555          var_c = (double)sub_41f42f(0f, 0, arg1);
0041f562          esi = (int32_t)((int16_t)(*(uint32_t*)((char*)arg2)[6] >> 4) & 0x7ff) - 0x3fe;
0041f4e8      }
0041f4e8      else
0041f4e8      {
0041f4ea          long double x87_r7_2 = (long double)arg2;
0041f4ed          long double temp1_1 = (long double)0.0;
0041f4ed          x87_r7_2 - temp1_1;
0041f4f3          esi = 0xfffffc03;
0041f4fb          int32_t eax_1;
0041f4fb          
0041f4fb          eax_1 = !TEST_BITB(
0041f4fb              *(uint8_t*)((char*)((x87_r7_2 < temp1_1 ? 1 : 0) << 8
0041f4fb                  | (FCMP_UO(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
0041f4fb                  | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe))[1], 
0041f4fb              0) ? 0 : 1;
0041f4fb          
0041f508          while (!(*(uint8_t*)((char*)arg2)[6] & 0x10))
0041f508          {
0041f50a              *(uint32_t*)((char*)arg2)[4] <<= 1;
0041f50a              
0041f511              if (*(uint8_t*)((char*)arg2)[3] & 0x80)
0041f513                  *(uint32_t*)((char*)arg2)[4] |= 1;
0041f513              
0041f517              (uint32_t)arg2 <<= 1;
0041f51a              esi -= 1;
0041f508          }
0041f508          
0041f51d          *(uint16_t*)((char*)arg2)[6] &= 0xffef;
0041f51d          
0041f525          if (eax_1)
0041f527              *(uint8_t*)((char*)arg2)[7] |= 0x80;
0041f527          
0041f52f          int32_t var_18_1 = 0;
0041f539          var_c = (double)sub_41f42f(0f, 0, arg1);
0041f4e8      }
0041f4e8      
0041f56e      *(uint32_t*)arg3 = esi;
0041f572      return (long double)var_c;
0041f4b2  }


0041f573    int32_t sub_41f573() __pure

0041f573  {
0041f576      int32_t ecx;
0041f576      int32_t var_8 = ecx;
0041f578      bool c0;
0041f578      bool c1;
0041f578      bool c2;
0041f578      bool c3;
0041f578      *(uint16_t*)((char*)var_8)[2] =
0041f578          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0041f580      return (int32_t)*(uint16_t*)((char*)var_8)[2];
0041f573  }


0041f581    int32_t sub_41f581()

0041f581  {
0041f584      int32_t ecx;
0041f584      int32_t var_8 = ecx;
0041f585      bool c0;
0041f585      bool c1;
0041f585      bool c2;
0041f585      bool c3;
0041f585      *(uint16_t*)((char*)var_8)[2] =
0041f585          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0041f588      __fnclex();
0041f58f      return (int32_t)*(uint16_t*)((char*)var_8)[2];
0041f581  }


0041f590    int32_t sub_41f590(int16_t arg1 @ x87control, int32_t arg2, int32_t arg3)

0041f590  {
0041f593      int32_t ecx;
0041f593      int32_t var_8 = ecx;
0041f595      int16_t x87status;
0041f595      int16_t temp0;
0041f595      temp0 = __fnstcw_memmem16(arg1);
0041f595      (uint16_t)var_8 = temp0;
0041f5aa      int16_t x87control;
0041f5aa      int16_t x87status_1;
0041f5aa      x87control = __fldcw_memmem16(((~arg3 & var_8) | (arg3 & arg2)));
0041f5b2      return (int32_t)(uint16_t)var_8;
0041f590  }


0041f5b3    void sub_41f5b3(int80_t arg1 @ st0, char arg2)

0041f5b3  {
0041f5b6      int32_t ecx;
0041f5b6      int32_t var_8 = ecx;
0041f5b7      int32_t var_c = ecx;
0041f5b8      (uint8_t)ecx = arg2;
0041f5be      int16_t top;
0041f5be      bool c1;
0041f5be      
0041f5be      if ((uint8_t)ecx & 1)
0041f5be      {
0041f5c0          data_42f6d0;
0041f5c6          arg2 = (int32_t)arg1;
0041f5c6          top = 1;
0041f5c6          c1 = /* c1 = unimplemented  {fistp dword [ebp+0x8], st0} */;
0041f5be      }
0041f5be      
0041f5cd      if ((uint8_t)ecx & 8)
0041f5cd      {
0041f5d0          int32_t eax;
0041f5d0          bool c0;
0041f5d0          bool c2;
0041f5d0          bool c3;
0041f5d0          (uint16_t)eax = (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa
0041f5d0              | (c3 ? 1 : 0) << 0xe | (top & 7) << 0xb;
0041f5d2          /* unimplemented  {fld st0, tword [&data_42f6d0]} */
0041f5d8          int64_t temp1_1 = /* int64_t temp1_1 =
0041f5d8              unimplemented  {fstp qword [ebp-0x8], st0} */;
0041f5d8          /* unimplemented  {fstp qword [ebp-0x8], st0} */
0041f5d8          var_c = (double)temp1_1;
0041f5d8          bool c1_1 = /* bool c1_1 = unimplemented  {fstp qword [ebp-0x8], st0} */;
0041f5dd          (uint16_t)eax = (c0 ? 1 : 0) << 8 | (c1_1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa
0041f5dd              | (c3 ? 1 : 0) << 0xe | (top & 7) << 0xb;
0041f5cd      }
0041f5cd      
0041f5e2      if ((uint8_t)ecx & 0x10)
0041f5e2      {
0041f5e4          /* unimplemented  {fld st0, tword [&data_42f6dc]} */
0041f5ea          var_c = (double)/* var_c.q =
0041f5ea              fconvert.d(unimplemented  {fstp qword [ebp-0x8], st0}) */;
0041f5ea          /* unimplemented  {fstp qword [ebp-0x8], st0} */
0041f5e2      }
0041f5e2      
0041f5f1      if ((uint8_t)ecx & 4)
0041f5f1      {
0041f5f3          /* unimplemented  {fldz } */
0041f5f5          /* unimplemented  {fld1 } */
0041f5f7          /* unimplemented  {fdivrp st1, st0} */
0041f5f7          /* unimplemented  {fdivrp st1, st0} */
0041f5f9          /* unimplemented  {fstp st0, st0} */
0041f5f9          /* unimplemented  {fstp st0, st0} */
0041f5f1      }
0041f5f1      
0041f5ff      if (!((uint8_t)ecx & 0x20))
0041f5ff          return;
0041f5ff      
0041f601      /* unimplemented  {fldpi } */
0041f603      var_c = (double)/* var_c.q =
0041f603          fconvert.d(unimplemented  {fstp qword [ebp-0x8], st0}) */;
0041f603      /* unimplemented  {fstp qword [ebp-0x8], st0} */
0041f5b3  }

0041f609                             cc cc cc cc cc cc cc                                                           .......

0041f610    int32_t __fastcall sub_41f610(int16_t arg1, void* arg2 @ ebp, long double arg3 @ st0, long double arg4 @ st1, long double arg5 @ st2, long double arg6 @ st3)

0041f610  {
0041f610      *(uint8_t*)((char*)arg2 - 0x90) = 0xfe;
0041f617      *(uint8_t*)((char*)arg1)[1] = *(uint8_t*)((char*)arg1)[1];
0041f619      long double x87_r0;
0041f619      long double x87_r1;
0041f619      
0041f619      if (*(uint8_t*)((char*)arg1)[1])
0041f619      {
0041f666          int32_t eax_1 = _isintTOS(arg3);
0041f666          
0041f66d          if (!eax_1)
0041f683              /* tailcall */
0041f683              return __rtindfpop(arg2);
0041f683          
0041f66f          *(uint8_t*)((char*)arg1)[1] = 0;
0041f66f          
0041f674          if (eax_1 != 2)
0041f676              *(uint8_t*)((char*)arg1)[1] = 0xff;
0041f676          
0041f678          x87_r1 = arg3;
0041f67a          x87_r0 = fabsl(arg4);
0041f619      }
0041f619      else
0041f619      {
0041f61b          x87_r0 = arg4;
0041f61b          x87_r1 = arg3;
0041f619      }
0041f619      
0041f62e      int16_t ecx;
0041f62e      char edx;
0041f62e      ecx = __ffexpm1(arg1, arg2, __fyl2x(x87_r0, x87_r1));
0041f635      long double x87_r2 = arg5 + (long double)1;
0041f635      
0041f63e      if (*(uint8_t*)((char*)arg2 - 0x9f) & 1)
0041f63e      {
0041f640          long double x87_r1_3 = (long double)1;
0041f640          
0041f649          if (data_4307a8 == 1)
0041f64f              x87_r2 = sub_4208c1(x87_r1_3, x87_r2);
0041f649          else
0041f64b              x87_r2 = x87_r1_3 / x87_r1_3;
0041f63e      }
0041f63e      
0041f657      if (!(edx & 0x40))
0041f659          __fscale(x87_r2, arg6);
0041f659      
0041f65b      *(uint8_t*)((char*)ecx)[1] = *(uint8_t*)((char*)ecx)[1];
0041f661      /* tailcall */
0041f661      return sub_41f918();
0041f610  }


0041f621    int80_t sub_41f621(void* arg1 @ ebp, long double arg2 @ st0, long double arg3 @ st1, long double arg4 @ st2)

0041f621  {
0041f621      *(uint8_t*)((char*)arg1 - 0x90) = 0xfe;
0041f628      int16_t ecx;
0041f628      *(uint8_t*)((char*)ecx)[1] = 0;
0041f62e      int16_t ecx_1;
0041f62e      char edx;
0041f62e      ecx_1 = __ffexpm1(ecx, arg1, 
0041f62e          arg2 * ((long double)1,4426950407214463.0 + (long double)1,675171316223821e-10));
0041f635      long double x87_r1 = arg3 + (long double)1;
0041f635      
0041f63e      if (*(uint8_t*)((char*)arg1 - 0x9f) & 1)
0041f63e      {
0041f640          long double x87_r0_2 = (long double)1;
0041f640          
0041f649          if (data_4307a8 == 1)
0041f64f              x87_r1 = sub_4208c1(x87_r0_2, x87_r1);
0041f649          else
0041f64b              x87_r1 = x87_r0_2 / x87_r0_2;
0041f63e      }
0041f63e      
0041f657      if (!(edx & 0x40))
0041f659          __fscale(x87_r1, arg4);
0041f659      
0041f65b      *(uint8_t*)((char*)ecx_1)[1] = *(uint8_t*)((char*)ecx_1)[1];
0041f661      /* tailcall */
0041f661      return sub_41f918();
0041f621  }


0041f67e    long double j_sub_41f92d()

0041f67e  {
0041f67e      /* tailcall */
0041f67e      return j_sub_41f92d();
0041f67e  }


0041f688    int32_t sub_41f688(void* arg1 @ ebp)

0041f688  {
0041f68c      data_42f6f0;
0041f692      *(uint8_t*)((char*)arg1 - 0x90) = 2;
0041f688  }

0041f69a                                                                                d9 ed d9 c9 d9 e4                            ......
0041f6a0  9b dd bd 60 ff ff ff 9b f6 85 61 ff ff ff 41 75 d2 d9 f1 c3                                      ...`......a...Au....

0041f6b4    int80_t sub_41f6b4(void* arg1 @ ebp)

0041f6b4  {
0041f6b4      *(uint8_t*)((char*)arg1 - 0x90) = 2;
0041f6c3      return data_42f6fa;
0041f6b4  }


0041f6c4    void __fastcall sub_41f6c4(char arg1, void* arg2 @ ebp)

0041f6c4  {
0041f6c6      if (!arg1)
0041f6c8          return;
0041f6c8      
0041f9ca      data_42f760;
0041f9ca      
0041f9d7      if (*(uint8_t*)((char*)arg2 - 0x90) > 0)
0041f9e2          return;
0041f9e2      
0041f9d7      /* tailcall */
0041f9d7      return sub_41f9d9(arg2);
0041f6c4  }


0041f6c9    int32_t __fastcall sub_41f6c9(char arg1, long double arg2 @ st0)

0041f6c9  {
0041f6d3      void* ebp;
0041f6d3      
0041f6d3      if (arg1)
0041f683          /* tailcall */
0041f683          return __rtindfpop(ebp);
0041f6d5      __fyl2x(arg2, 
0041f6d5          (long double)0,30102999560767785.0 + (long double)5,6303348065105986e-11);
0041f6c9  }


0041f6cd    int32_t __fastcall sub_41f6cd(char arg1, long double arg2 @ st0)

0041f6cd  {
0041f6d3      void* ebp;
0041f6d3      
0041f6d3      if (arg1)
0041f683          /* tailcall */
0041f683          return __rtindfpop(ebp);
0041f6d5      __fyl2x(arg2, 
0041f6d5          (long double)0,69314718048553914.0 + (long double)7,4406171098029793e-11);
0041f6cd  }


0041f6d8    long double j_sub_41f92d()

0041f6d8  {
0041f6d8      /* tailcall */
0041f6d8      return j_sub_41f92d();
0041f6d8  }


0041f6dd    int32_t __fastcall sub_41f6dd(int16_t arg1, void* arg2 @ ebp)

0041f6dd  {
0041f6dd      long double x87_r0;
0041f6dd      int32_t result = _isintTOS(x87_r0);
0041f6e6      (uint8_t)arg1 = (uint8_t)arg1;
0041f6e6      
0041f6e8      if ((uint8_t)arg1)
0041f6e8      {
0041f6f8          *(uint8_t*)((char*)arg2 - 0x90) = 2;
0041f6ff          data_42f6f0;
0041f6ff          
0041f708          if (result == 1)
0041f70a              *(uint8_t*)((char*)arg1)[1] = *(uint8_t*)((char*)arg1)[1];
0041f6e8      }
0041f6e8      else if (result == 1)
0041f6f1          *(uint8_t*)((char*)arg1)[1] = *(uint8_t*)((char*)arg1)[1];
0041f6f1      
0041f6f7      return result;
0041f6dd  }

0041f712                                                        dd d8                                                        ..

0041f719    int32_t sub_41f719(void* arg1 @ ebp)

0041f719  {
0041f9ca      data_42f760;
0041f9ca      
0041f9d7      if (*(uint8_t*)((char*)arg1 - 0x90) > 0)
0041f9e2          return;
0041f9e2      
0041f9d7      /* tailcall */
0041f9d7      return sub_41f9d9(arg1);
0041f719  }


0041f74f    int32_t j_sub_41f751(void* arg1 @ ebp)

0041f74f  {
0041f74f      /* tailcall */
0041f74f      return sub_41f751(arg1);
0041f74f  }


0041f751    int80_t sub_41f751(void* arg1 @ ebp)

0041f751  {
0041f753      int80_t result = data_42f6f0;
0041f759      *(uint8_t*)((char*)arg1 - 0x90) = 3;
0041f760      return result;
0041f751  }


0041f761    int80_t __fastcall __rtforexpinf(char arg1)

0041f761  {
0041f763      if (arg1)
0041f714          /* tailcall */
0041f714          return sub_41f926();
0041f714      
0041f76d      return data_42f6f0;
0041f761  }


0041f76e    void __fastcall __ffexpm1(int16_t arg1, void* arg2 @ ebp, long double arg3 @ st0)

0041f76e  {
0041f770      long double x87_r7 = fabsl(arg3);
0041f772      long double x87_r6 = data_42f70e;
0041f778      x87_r6 - x87_r7;
0041f77b      *(uint16_t*)((char*)arg2 - 0xa0) = (x87_r6 < x87_r7 ? 1 : 0) << 8
0041f77b          | (FCMP_UO(x87_r6, x87_r7) ? 1 : 0) << 0xa | (x87_r6 == x87_r7 ? 1 : 0) << 0xe;
0041f77b      
0041f789      if (*(uint8_t*)((char*)arg2 - 0x9f) & 0x41)
0041f789      {
0041f721          long double temp1 = (long double)0;
0041f721          arg3 - temp1;
0041f724          *(uint16_t*)((char*)arg2 - 0xa0) = (arg3 < temp1 ? 1 : 0) << 8
0041f724              | (FCMP_UO(arg3, temp1) ? 1 : 0) << 0xa | (arg3 == temp1 ? 1 : 0) << 0xe;
0041f724          
0041f732          if (*(uint8_t*)((char*)arg2 - 0x9f) & 1)
0041f732          {
0041f743              *(uint8_t*)((char*)arg2 - 0x90) = 4;
0041f74a              /* tailcall */
0041f74a              return sub_41f926();
0041f732          }
0041f732          
0041f736          data_42f6f0;
0041f73c          *(uint8_t*)((char*)arg1)[1] = *(uint8_t*)((char*)arg1)[1];
0041f742          return;
0041f789      }
0041f789      
0041f78d      long double x87_r7_2 = round(arg3, arg3);
0041f78f      long double temp2 = (long double)0;
0041f78f      x87_r7_2 - temp2;
0041f792      *(uint16_t*)((char*)arg2 - 0xa0) = (x87_r7_2 < temp2 ? 1 : 0) << 8
0041f792          | (FCMP_UO(x87_r7_2, temp2) ? 1 : 0) << 0xa | (x87_r7_2 == temp2 ? 1 : 0) << 0xe
0041f792          | 0x3800;
0041f799      int32_t edx;
0041f799      (uint8_t)edx = *(uint8_t*)((char*)arg2 - 0x9f);
0041f7a1      long double x87_r7_4 = arg3 - x87_r7_2;
0041f7a3      long double temp3 = (long double)0;
0041f7a3      x87_r7_4 - temp3;
0041f7a6      *(uint16_t*)((char*)arg2 - 0xa0) = (x87_r7_4 < temp3 ? 1 : 0) << 8
0041f7a6          | (FCMP_UO(x87_r7_4, temp3) ? 1 : 0) << 0xa | (x87_r7_4 == temp3 ? 1 : 0) << 0xe
0041f7a6          | 0x3800;
0041f7ae      __f2xm1(fabsl(x87_r7_4));
0041f76e  }


0041f7b1    int32_t _isintTOS(long double arg1 @ st0)

0041f7b1  {
0041f7b3      long double x87_r7 = round(arg1, arg1);
0041f7b5      x87_r7 - arg1;
0041f7b5      
0041f7bb      if (!TEST_BITB(
0041f7bb              *(uint8_t*)((char*)((x87_r7 < arg1 ? 1 : 0) << 8
0041f7bb                  | (FCMP_UO(x87_r7, arg1) ? 1 : 0) << 0xa
0041f7bb                  | (x87_r7 == arg1 ? 1 : 0) << 0xe))[1], 
0041f7bb              6))
0041f7d7          return 0;
0041f7d7      
0041f7bf      long double x87_r7_2 = arg1 * (long double)data_42f722;
0041f7c7      long double x87_r6_2 = round(x87_r7_2, arg1);
0041f7c9      x87_r6_2 - x87_r7_2;
0041f7c9      
0041f7cf      if (TEST_BITB(
0041f7cf              *(uint8_t*)((char*)((x87_r6_2 < x87_r7_2 ? 1 : 0) << 8
0041f7cf                  | (FCMP_UO(x87_r6_2, x87_r7_2) ? 1 : 0) << 0xa
0041f7cf                  | (x87_r6_2 == x87_r7_2 ? 1 : 0) << 0xe))[1], 
0041f7cf              6))
0041f7de          return 2;
0041f7de      
0041f7d1      return 1;
0041f7b1  }


0041f7e5    long double sub_41f7e5(int16_t arg1 @ x87control, int16_t arg2 @ x87status, int16_t arg3 @ x87tag, long double arg4 @ st0, long double arg5 @ st1)

0041f7e5  {
0041f7f9      int16_t x87control;
0041f7f9      int16_t x87status;
0041f7f9      int16_t x87tag;
0041f7f9      uint864_t temp0;
0041f7f9      temp0 = __fnsave_memmem108(arg1, arg3, arg2);
0041f7fc      double var_78;
0041f7fc      int32_t eax = sub_41fbdc((double)arg5, (double)arg4, &var_78);
0041f804      __frstor_memmem108(temp0);
0041f804      
0041f80f      if (!eax)
0041f816          return (long double)var_78;
0041f816      
0041f811      void* ebp;
0041f811      /* tailcall */
0041f811      return sub_41f9d9(ebp);
0041f7e5  }

0041f817                                                                       cc cc cc cc cc cc cc cc cc                         .........

0041f820    int32_t __fastcall __trandisp1(int32_t arg1, void* arg2, void* arg3 @ ebp, long double arg4 @ st0)

0041f820  {
0041f824      int16_t ebx;
0041f824      
0041f824      if (*(uint8_t*)((char*)arg2 + 0xe) != 5)
0041f837          ebx = 0x133f;
0041f824      else
0041f824      {
0041f82d          *(uint8_t*)((char*)ebx)[1] =
0041f82d              *(uint8_t*)((char*)(*(uint16_t*)((char*)arg3 - 0xa4)))[1] | 2;
0041f830          *(uint8_t*)((char*)ebx)[1] &= 0xfe;
0041f833          (uint8_t)ebx = 0x3f;
0041f824      }
0041f824      
0041f83b      *(uint16_t*)((char*)arg3 - 0xa2) = ebx;
0041f842      int16_t x87control;
0041f842      int16_t x87status;
0041f842      x87control = __fldcw_memmem16(*(uint16_t*)((char*)arg3 - 0xa2));
0041f84d      bool c0;
0041f84d      bool c1;
0041f84d      bool c2;
0041f84d      bool c3;
0041f84d      c0 = __fxam(arg4);
0041f84f      *(uint32_t*)((char*)arg3 - 0x94) = arg2;
0041f856      *(uint16_t*)((char*)arg3 - 0xa0) =
0041f856          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0041f85c      *(uint8_t*)((char*)arg3 - 0x90) = 0;
0041f864      (uint8_t)arg1 = *(uint8_t*)((char*)arg3 - 0x9f);
0041f86a      (uint8_t)arg1 <<= 1;
0041f86c      (uint8_t)arg1 s>>= 1;
0041f86e      (uint8_t)arg1 = ROLB((uint8_t)arg1, 1);
0041f870      int32_t eax;
0041f870      (uint8_t)eax = (uint8_t)arg1;
0041f872      (uint8_t)eax &= 0xf;
0041f874      (uint8_t)eax = *(uint8_t*)(&data_42f77d + eax);
0041f885      /* jump -> *(uint32_t*)((char*)arg2 + (int32_t)(uint8_t)eax + 0x10) */
0041f820  }


0041f887    int32_t __fastcall __trandisp2(int32_t arg1, void* arg2, void* arg3 @ ebp, long double arg4 @ st0, long double arg5 @ st1)

0041f887  {
0041f88b      int16_t ebx;
0041f88b      
0041f88b      if (*(uint8_t*)((char*)arg2 + 0xe) != 5)
0041f89e          ebx = 0x133f;
0041f88b      else
0041f88b      {
0041f894          *(uint8_t*)((char*)ebx)[1] =
0041f894              *(uint8_t*)((char*)(*(uint16_t*)((char*)arg3 - 0xa4)))[1] | 2;
0041f897          *(uint8_t*)((char*)ebx)[1] &= 0xfe;
0041f89a          (uint8_t)ebx = 0x3f;
0041f88b      }
0041f88b      
0041f8a2      *(uint16_t*)((char*)arg3 - 0xa2) = ebx;
0041f8a9      int16_t x87control;
0041f8a9      int16_t x87status;
0041f8a9      x87control = __fldcw_memmem16(*(uint16_t*)((char*)arg3 - 0xa2));
0041f8b4      bool c0;
0041f8b4      bool c1;
0041f8b4      bool c2;
0041f8b4      bool c3;
0041f8b4      c0 = __fxam(arg4);
0041f8b6      *(uint32_t*)((char*)arg3 - 0x94) = arg2;
0041f8bd      *(uint16_t*)((char*)arg3 - 0xa0) =
0041f8bd          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0041f8c3      *(uint8_t*)((char*)arg3 - 0x90) = 0;
0041f8cc      (uint8_t)arg1 = *(uint8_t*)((char*)arg3 - 0x9f);
0041f8d2      bool c0_1;
0041f8d2      bool c1_1;
0041f8d2      bool c2_1;
0041f8d2      bool c3_1;
0041f8d2      c0_1 = __fxam(arg5);
0041f8d5      *(uint16_t*)((char*)arg3 - 0xa0) = (c0_1 ? 1 : 0) << 8 | (c1_1 ? 1 : 0) << 9
0041f8d5          | (c2_1 ? 1 : 0) << 0xa | (c3_1 ? 1 : 0) << 0xe;
0041f8dd      *(uint8_t*)((char*)arg1)[1] = *(uint8_t*)((char*)arg3 - 0x9f);
0041f8e3      *(uint8_t*)((char*)arg1)[1] <<= 1;
0041f8e5      *(uint8_t*)((char*)arg1)[1] s>>= 1;
0041f8e7      *(uint8_t*)((char*)arg1)[1] = ROLB(*(uint8_t*)((char*)arg1)[1], 1);
0041f8e9      int32_t eax;
0041f8e9      (uint8_t)eax = *(uint8_t*)((char*)arg1)[1];
0041f8eb      (uint8_t)eax &= 0xf;
0041f8ed      (uint8_t)eax = *(uint8_t*)(&data_42f77d + eax);
0041f8ee      *(uint8_t*)((char*)eax)[1] = (uint8_t)eax;
0041f8f0      (uint8_t)arg1 <<= 1;
0041f8f2      (uint8_t)arg1 s>>= 1;
0041f8f4      (uint8_t)arg1 = ROLB((uint8_t)arg1, 1);
0041f8f6      (uint8_t)eax = (uint8_t)arg1;
0041f8f8      (uint8_t)eax &= 0xf;
0041f8fa      (uint8_t)eax = *(uint8_t*)(&data_42f77d + eax);
0041f8fb      *(uint8_t*)((char*)eax)[1] <<= 1;
0041f8fd      *(uint8_t*)((char*)eax)[1] <<= 1;
0041f8ff      (uint8_t)eax |= *(uint8_t*)((char*)eax)[1];
0041f911      /* jump -> *(uint32_t*)((char*)arg2 + (int32_t)(uint8_t)eax + 0x10) */
0041f887  }

0041f913                                                           e8 c1 00 00 00                                             .....

0041f918    int32_t sub_41f918() __pure

0041f918  {
0041f91c      return;
0041f918  }

0041f91d                                                                                         e8 b7 00                               ...
0041f920  00 00 eb f6 dd d8                                                                                ......

0041f926    long double sub_41f926() __pure

0041f926  {
0041f92a      return (long double)0;
0041f926  }


0041f92b    long double j_sub_41f92d()

0041f92b  {
0041f92b      /* tailcall */
0041f92b      return sub_41f92d();
0041f92b  }


0041f92d    long double sub_41f92d() __pure

0041f92d  {
0041f931      return (long double)1;
0041f92d  }


0041f932    long double sub_41f932(void* arg1 @ ebp, int80_t arg2 @ st0)

0041f932  {
0041f932      *(uint80_t*)((char*)arg1 - 0x9e) = arg2;
0041f938      long double result = *(uint80_t*)((char*)arg1 - 0x9e);
0041f938      
0041f945      if (!(*(uint8_t*)((char*)arg1 - 0x97) & 0x40))
0041f945      {
0041f94f          *(uint8_t*)((char*)arg1 - 0x90) = 1;
0041f95c          return result + (long double)data_42f774;
0041f945      }
0041f945      
0041f947      *(uint8_t*)((char*)arg1 - 0x90) = 7;
0041f94e      return result;
0041f932  }


0041f95d    long double sub_41f95d(void* arg1 @ ebp, long double arg2 @ st0, int80_t arg3 @ st1)

0041f95d  {
0041f95f      *(uint80_t*)((char*)arg1 - 0x9e) = arg3;
0041f965      long double x87_r0_1 = *(uint80_t*)((char*)arg1 - 0x9e);
0041f965      
0041f972      if (!(*(uint8_t*)((char*)arg1 - 0x97) & 0x40))
0041f97d          *(uint8_t*)((char*)arg1 - 0x90) = 1;
0041f972      else
0041f974          *(uint8_t*)((char*)arg1 - 0x90) = 7;
0041f974      
0041f986      return arg2 + x87_r0_1;
0041f95d  }


0041f987    long double __nan2(void* arg1 @ ebp, int80_t arg2 @ st0, long double arg3 @ st1)

0041f987  {
0041f987      *(uint80_t*)((char*)arg1 - 0x9e) = arg2;
0041f98d      long double x87_r0 = *(uint80_t*)((char*)arg1 - 0x9e);
0041f98d      
0041f99a      if (*(uint8_t*)((char*)arg1 - 0x97) & 0x40)
0041f99a      {
0041f99c          long double x87_r0_1 = arg3;
0041f99c          arg3 = x87_r0;
0041f99e          *(uint80_t*)((char*)arg1 - 0x9e) = x87_r0_1;
0041f9a4          x87_r0 = *(uint80_t*)((char*)arg1 - 0x9e);
0041f99a      }
0041f99a      
0041f9b1      if (!(*(uint8_t*)((char*)arg1 - 0x97) & 0x40)
0041f9b1              || !(*(uint8_t*)((char*)arg1 - 0x97) & 0x40))
0041f9bc          *(uint8_t*)((char*)arg1 - 0x90) = 1;
0041f9b1      else
0041f9b3          *(uint8_t*)((char*)arg1 - 0x90) = 7;
0041f9b3      
0041f9c5      return arg3 + x87_r0;
0041f987  }


0041f9c6    int32_t __rtindfpop(void* arg1 @ ebp)

0041f9c6  {
0041f9ca      data_42f760;
0041f9ca      
0041f9d7      if (*(uint8_t*)((char*)arg1 - 0x90) > 0)
0041f9e2          return;
0041f9e2      
0041f9d7      /* tailcall */
0041f9d7      return sub_41f9d9(arg1);
0041f9c6  }


0041f9d9    int32_t sub_41f9d9(void* arg1 @ ebp)

0041f9d9  {
0041f9d9      *(uint8_t*)((char*)arg1 - 0x90) = 1;
0041f9d9  }


0041f9e3    void __fastcall sub_41f9e3(char arg1, long double arg2 @ st0) __pure

0041f9e3  {
0041f9e9      return;
0041f9e3  }

0041f9ea                                cc cc cc cc cc cc                                                            ......

0041f9f0    long double __convention("regparm") __startTwoArgErrorHandling(int32_t arg1, int32_t arg2, long double arg3 @ st0, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7)

0041f9f0  {
0041f9f6      int32_t var_24 = arg1;
0041f9fc      int32_t var_14 = arg6;
0041fa02      int32_t var_10 = arg7;
0041fa10      double var_c = (double)arg3;
0041fa13      int32_t ecx;
0041fa13      int32_t var_20 = ecx;
0041fa1c      int32_t var_1c = arg4;
0041fa1f      int32_t var_18 = arg5;
0041fa2b      int16_t arg_4;
0041fa2b      sub_425ca6(arg2, &var_24, &arg_4);
0041fa3c      int16_t x87control_1;
0041fa3c      int16_t x87status_1;
0041fa3c      
0041fa3c      if (arg_4 != 0x27f)
0041fa3e          x87control_1 = __fldcw_memmem16(arg_4);
0041fa42      return (long double)var_c;
0041f9f0  }


0041fa07    long double __convention("regparm") __startOneArgErrorHandling(int32_t arg1, int32_t arg2, long double arg3 @ st0, int32_t arg4, int32_t arg5)

0041fa07  {
0041fa0d      int32_t var_24 = arg1;
0041fa10      double var_c = (double)arg3;
0041fa13      int32_t ecx;
0041fa13      int32_t var_20 = ecx;
0041fa1c      int32_t var_1c = arg4;
0041fa1f      int32_t var_18 = arg5;
0041fa2b      int16_t arg_4;
0041fa2b      sub_425ca6(arg2, &var_24, &arg_4);
0041fa3c      int16_t x87control_1;
0041fa3c      int16_t x87status_1;
0041fa3c      
0041fa3c      if (arg_4 != 0x27f)
0041fa3e          x87control_1 = __fldcw_memmem16(arg_4);
0041fa42      return (long double)var_c;
0041fa07  }

0041fa43           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

0041fa50    long double __twoToTOS(long double arg1 @ st0)

0041fa50  {
0041fa52      long double result = round(arg1, arg1);
0041fa60      __fscale(__f2xm1(-((result - arg1))) + (long double)1, result);
0041fa64      return result;
0041fa50  }


0041fa65    int32_t __load_CW(int32_t arg1)

0041fa65  {
0041fa72      *(uint16_t*)((char*)arg1)[2] = ((uint16_t)arg1 & 0x300) | 0x7f;
0041fa77      int16_t x87control;
0041fa77      int16_t x87status;
0041fa77      x87control = __fldcw_memmem16(*(uint16_t*)((char*)arg1)[2]);
0041fa65  }


0041fa7c    void __convention("regparm") __convertTOStoQNaN(int32_t arg1, long double arg2 @ st0) __pure

0041fa88  {
0041fa88      return;
0041fa88  }


0041fa95    long double __fastcall __fload_withFB(int32_t arg1, double* arg2)

0041fa95  {
0041faa2      if ((*(uint32_t*)((char*)arg2 + 4) & 0x7ff00000) != 0x7ff00000)
0041faa6          return (long double)*(uint64_t*)arg2;
0041faa6      
0041fab2      int32_t var_4 = *(uint32_t*)((char*)arg2 + 4) | 0x7fff0000;
0041fab9      int32_t ecx = *(uint32_t*)arg2;
0041fac2      int32_t var_6 = *(uint32_t*)((char*)arg2 + 4) << 0xb | ecx >> 0xffffffeb;
0041fad4      *(uint32_t*)((char*)arg2 + 4);
0041fad7      return (ecx << 0xb);
0041fa95  }


0041fad8    int32_t __checkTOS_withFB(int32_t arg1) __pure

0041fad8  {
0041fadc      int32_t eax = arg1 & 0x7ff00000;
0041fadc      
0041fae6      if (eax == 0x7ff00000)
0041faed          return arg1;
0041faed      
0041fae8      return eax;
0041fad8  }

0041fb25                 83 ec 08 dd 14 24 8b 44 24 04 83 c4 08 25 00 00 f0 7f eb 14                            .....$.D$....%......

0041fbdc    int32_t sub_41fbdc(double arg1, int32_t arg2, int32_t arg3, double* arg4)

0041fbdc  {
0041fbdf      int32_t ecx;
0041fbdf      int32_t var_8 = ecx;
0041fbe0      int32_t var_c = ecx;
0041fbe1      long double x87_r7 = (long double)arg1;
0041fbe4      long double temp0 = (long double)0.0;
0041fbe4      x87_r7 - temp0;
0041fbea      long double x87_r7_1 = (long double)arg1;
0041fbf0      int32_t result = 0;
0041fbf0      
0041fbf5      if (TEST_BITB(
0041fbf5              *(uint8_t*)((char*)((x87_r7 < temp0 ? 1 : 0) << 8
0041fbf5                  | (FCMP_UO(x87_r7, temp0) ? 1 : 0) << 0xa
0041fbf5                  | (x87_r7 == temp0 ? 1 : 0) << 0xe | 0x3800))[1], 
0041fbf5              0))
0041fbf7          x87_r7_1 = -(x87_r7_1);
0041fbf7      
0041fbf9      var_c = (double)x87_r7_1;
0041fc09      int16_t eax_1;
0041fc09      
0041fc09      if (arg3 == 0x7ff00000)
0041fc09      {
0041fc0e          if (arg2)
0041fc0e              goto label_41fc67;
0041fc0e          
0041fc10          long double x87_r7_2 = (long double)var_c;
0041fc13          long double temp1_1 = (long double)1.0;
0041fc13          x87_r7_2 - temp1_1;
0041fc19          eax_1 = (x87_r7_2 < temp1_1 ? 1 : 0) << 8
0041fc19              | (FCMP_UO(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
0041fc19              | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe;
0041fc19          
0041fc1c          if (!TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 6)
0041fc1c                  && !TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 0))
0041fd05              *(uint64_t*)arg4 = (double)(long double)data_42f6a8;
0041fc1c          else
0041fc1c          {
0041fc1e              long double x87_r7_3 = (long double)var_c;
0041fc21              long double temp3_1 = (long double)1.0;
0041fc21              x87_r7_3 - temp3_1;
0041fc21              
0041fc2a              if (TEST_BITB(
0041fc2a                      *(uint8_t*)((char*)((x87_r7_3 < temp3_1 ? 1 : 0) << 8
0041fc2a                          | (FCMP_UO(x87_r7_3, temp3_1) ? 1 : 0) << 0xa
0041fc2a                          | (x87_r7_3 == temp3_1 ? 1 : 0) << 0xe))[1], 
0041fc2a                      0))
0041fd05                  *(uint64_t*)arg4 = (double)(long double)0;
0041fc2a              else
0041fc2a              {
0041fc37                  result = 1;
0041fc38                  *(uint64_t*)arg4 = (double)(long double)data_42f6b0;
0041fc2a              }
0041fc1c          }
0041fc09      }
0041fc09      else if (arg3 != 0xfff00000 || arg2)
0041fc47      {
0041fc67      label_41fc67:
0041fc67          
0041fc6a          if (*(uint32_t*)((char*)arg1)[4] != 0x7ff00000)
0041fc6a          {
0041fca5              if (*(uint32_t*)((char*)arg1)[4] == 0xfff00000 && !(uint32_t)arg1)
0041fca5              {
0041fcaa                  int32_t var_14_1 = 0xfff00000;
0041fcb4                  long double x87_r7_9 = (long double)arg2;
0041fcb7                  long double temp6_1 = (long double)0.0;
0041fcb7                  x87_r7_9 - temp6_1;
0041fcbf                  int32_t ecx_1 = sub_41fd0c(0x7ff00000, 0, 0xfff00000, -nanf);
0041fcc1                  int32_t eax_3;
0041fcc1                  (uint16_t)eax_3 = (x87_r7_9 < temp6_1 ? 1 : 0) << 8
0041fcc1                      | (FCMP_UO(x87_r7_9, temp6_1) ? 1 : 0) << 0xa
0041fcc1                      | (x87_r7_9 == temp6_1 ? 1 : 0) << 0xe;
0041fcc1                  
0041fcc4                  if (TEST_BITB(*(uint8_t*)((char*)eax_3)[1], 6)
0041fcc4                      || TEST_BITB(*(uint8_t*)((char*)eax_3)[1], 0))
0041fcc4                  {
0041fcdb                      long double x87_r7_12 = (long double)arg2;
0041fcde                      long double temp8_1 = (long double)0.0;
0041fcde                      x87_r7_12 - temp8_1;
0041fce4                      (uint16_t)eax_3 = (x87_r7_12 < temp8_1 ? 1 : 0) << 8
0041fce4                          | (FCMP_UO(x87_r7_12, temp8_1) ? 1 : 0) << 0xa
0041fce4                          | (x87_r7_12 == temp8_1 ? 1 : 0) << 0xe;
0041fce4                      
0041fce7                      if (!TEST_BITB(*(uint8_t*)((char*)eax_3)[1], 0))
0041fd05                          *(uint64_t*)arg4 = (double)(long double)1;
0041fce7                      else
0041fce7                      {
0041fcec                          long double x87_r7_13;
0041fcec                          
0041fcec                          if (ecx_1 != 1)
0041fcf6                              x87_r7_13 = (long double)0;
0041fcec                          else
0041fcee                              x87_r7_13 = (long double)data_42f6c8;
0041fcee                          
0041fcf8                          arg2 = (double)x87_r7_13;
0041fd05                          *(uint64_t*)arg4 = (double)(long double)arg2;
0041fce7                      }
0041fcc4                  }
0041fcc4                  else
0041fcc4                  {
0041fcc6                      long double x87_r7_10 = (long double)data_42f6a8;
0041fcc6                      
0041fccf                      if (ecx_1 == 1)
0041fcd1                          x87_r7_10 = -(x87_r7_10);
0041fcd1                      
0041fcd3                      arg2 = (double)x87_r7_10;
0041fd05                      *(uint64_t*)arg4 = (double)(long double)arg2;
0041fcc4                  }
0041fca5              }
0041fc6a          }
0041fc6a          else if (!(uint32_t)arg1)
0041fc6f          {
0041fc75              long double x87_r7_7 = (long double)arg2;
0041fc78              long double temp4_1 = (long double)0.0;
0041fc78              x87_r7_7 - temp4_1;
0041fc7e              eax_1 = (x87_r7_7 < temp4_1 ? 1 : 0) << 8
0041fc7e                  | (FCMP_UO(x87_r7_7, temp4_1) ? 1 : 0) << 0xa
0041fc7e                  | (x87_r7_7 == temp4_1 ? 1 : 0) << 0xe;
0041fc7e              
0041fc81              if (TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 6)
0041fc81                  || TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 0))
0041fc81              {
0041fc8b                  long double x87_r7_8 = (long double)arg2;
0041fc8e                  long double temp7_1 = (long double)0.0;
0041fc8e                  x87_r7_8 - temp7_1;
0041fc8e                  
0041fc97                  if (!TEST_BITB(
0041fc97                          *(uint8_t*)((char*)((x87_r7_8 < temp7_1 ? 1 : 0) << 8
0041fc97                              | (FCMP_UO(x87_r7_8, temp7_1) ? 1 : 0) << 0xa
0041fc97                              | (x87_r7_8 == temp7_1 ? 1 : 0) << 0xe))[1], 
0041fc97                          0))
0041fd05                      *(uint64_t*)arg4 = (double)(long double)1;
0041fc97                  else
0041fd05                      *(uint64_t*)arg4 = (double)(long double)0;
0041fc81              }
0041fc81              else
0041fd05                  *(uint64_t*)arg4 = (double)(long double)data_42f6a8;
0041fc6f          }
0041fc47      }
0041fc47      else
0041fc47      {
0041fc49          long double x87_r7_5 = (long double)var_c;
0041fc4c          long double temp2_1 = (long double)1.0;
0041fc4c          x87_r7_5 - temp2_1;
0041fc52          eax_1 = (x87_r7_5 < temp2_1 ? 1 : 0) << 8
0041fc52              | (FCMP_UO(x87_r7_5, temp2_1) ? 1 : 0) << 0xa
0041fc52              | (x87_r7_5 == temp2_1 ? 1 : 0) << 0xe;
0041fc52          
0041fc55          if (!TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 6)
0041fc55                  && !TEST_BITB(*(uint8_t*)((char*)eax_1)[1], 0))
0041fd05              *(uint64_t*)arg4 = (double)(long double)0;
0041fc55          else
0041fc55          {
0041fc57              long double x87_r7_6 = (long double)var_c;
0041fc5a              long double temp5_1 = (long double)1.0;
0041fc5a              x87_r7_6 - temp5_1;
0041fc5a              
0041fc63              if (!TEST_BITB(
0041fc63                  *(uint8_t*)((char*)((x87_r7_6 < temp5_1 ? 1 : 0) << 8
0041fc63                      | (FCMP_UO(x87_r7_6, temp5_1) ? 1 : 0) << 0xa
0041fc63                      | (x87_r7_6 == temp5_1 ? 1 : 0) << 0xe))[1], 
0041fc63                  0))
0041fc63              {
0041fc37                  result = 1;
0041fc38                  *(uint64_t*)arg4 = (double)(long double)data_42f6b0;
0041fc63              }
0041fc63              else
0041fd05                  *(uint64_t*)arg4 = (double)(long double)data_42f6a8;
0041fc55          }
0041fc47      }
0041fd0b      return result;
0041fbdc  }


0041fd0c    int32_t __convention("regparm") sub_41fd0c(int32_t arg1, int32_t arg2, int32_t arg3, double arg4)

0041fd0c  {
0041fd0f      int32_t var_8 = arg3;
0041fd15      int32_t var_14 = arg3;
0041fd16      var_14 = (double)(long double)arg4;
0041fd16      
0041fd22      if (!(sub_420e7c(var_14, arg3) & 0x90))
0041fd22      {
0041fd28          int32_t var_14_1 = arg3;
0041fd29          var_14_1 = (double)(long double)arg4;
0041fd31          int32_t var_c;
0041fd31          var_c = (double)__frnd(var_14_1);
0041fd34          long double x87_r7_3 = (long double)var_c;
0041fd37          long double temp0_1 = (long double)arg4;
0041fd37          x87_r7_3 - temp0_1;
0041fd37          
0041fd3f          if (TEST_BITB(
0041fd3f              *(uint8_t*)((char*)((x87_r7_3 < temp0_1 ? 1 : 0) << 8
0041fd3f                  | (FCMP_UO(x87_r7_3, temp0_1) ? 1 : 0) << 0xa
0041fd3f                  | (x87_r7_3 == temp0_1 ? 1 : 0) << 0xe))[1], 
0041fd3f              6))
0041fd3f          {
0041fd4a              int32_t var_10_2 = arg3;
0041fd4b              int32_t var_14_2 = arg3;
0041fd4c              arg4 = (double)((long double)arg4 / (long double)2.0);
0041fd52              var_14_2 = (double)(long double)arg4;
0041fd55              long double st0_2 = __frnd(var_14_2);
0041fd5a              long double temp1 = (long double)arg4;
0041fd5a              st0_2 - temp1;
0041fd5a              
0041fd62              if (!TEST_BITB(
0041fd62                      *(uint8_t*)((char*)((st0_2 < temp1 ? 1 : 0) << 8
0041fd62                          | (FCMP_UO(st0_2, temp1) ? 1 : 0) << 0xa
0041fd62                          | (st0_2 == temp1 ? 1 : 0) << 0xe))[1], 
0041fd62                      6))
0041fd68                  return 1;
0041fd68              
0041fd64              return 2;
0041fd3f          }
0041fd22      }
0041fd22      
0041fd70      return 0;
0041fd0c  }

0041fd71                                                     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                   ...............

0041fd80    int32_t $$000000(void* arg1 @ ebp)

0041fd80  {
0041fd80      *(uint8_t*)((char*)arg1 - 0x90) = 0xff;
0041fd87      char ecx;
0041fd87      long double st0;
0041fd87      long double x87_r0;
0041fd87      long double x87_r1;
0041fd87      long double x87_r2;
0041fd87      st0 = fFEXPH(arg1, x87_r0, x87_r1, x87_r2);
0041fd8e      char entry_ebx;
0041fd8e      
0041fd8e      if (!entry_ebx)
0041fe10          /* tailcall */
0041fe10          return sub_41f9e3(ecx, sub_41f751(arg1));
0041fe10      
0041fded      __fscale(st0 - ExpHypCopyInv(st0), -((long double)1));
0041fdef      /* tailcall */
0041fdef      return sub_41f918();
0041fd80  }


0041fd99    int32_t sub_41fd99(void* arg1 @ ebp, long double arg2 @ st0)

0041fd99  {
0041fd9b      long double x87_r7 = fabsl(arg2);
0041fd9d      long double x87_r6 = data_42f790;
0041fda3      x87_r6 - x87_r7;
0041fda6      *(uint16_t*)((char*)arg1 - 0xa0) = (x87_r6 < x87_r7 ? 1 : 0) << 8
0041fda6          | (FCMP_UO(x87_r6, x87_r7) ? 1 : 0) << 0xa | (x87_r6 == x87_r7 ? 1 : 0) << 0xe;
0041fdb4      char ecx;
0041fdb4      
0041fdb4      if (!(*(uint8_t*)((char*)arg1 - 0x9f) & 0x41))
0041fdb4      {
0041fdb6          long double st0_1;
0041fdb6          long double x87_r1;
0041fdb6          long double x87_r2;
0041fdb6          st0_1 = fFEXPH(arg1, arg2, x87_r1, x87_r2);
0041fdbd          char entry_ebx;
0041fdbd          
0041fdbd          if (entry_ebx)
0041fdbd          {
0041fdc1              ExpHypSum(st0_1);
0041fdd1              return &data_41fe33;
0041fdbd          }
0041fdb4      }
0041fdb4      
0041fe1a      *(uint8_t*)((char*)arg1 - 0x90) = 8;
0041fe21      long double st0_5 = sub_41f92d();
0041fe21      /* unimplemented  {call sub_41f92d} */
0041fe10      /* tailcall */
0041fe10      return sub_41f9e3(ecx, st0_5);
0041fd99  }


0041fdd2    int32_t sub_41fdd2(void* arg1 @ ebp)

0041fdd2  {
0041fdd2      *(uint8_t*)((char*)arg1 - 0x90) = 0xff;
0041fdd9      long double x87_r0;
0041fdd9      long double x87_r1;
0041fdd9      long double x87_r2;
0041fdd9      long double st0 = fFEXPH(arg1, x87_r0, x87_r1, x87_r2);
0041fde0      char entry_ebx;
0041fde0      
0041fde0      if (!entry_ebx)
0041fe15          /* tailcall */
0041fe15          return sub_41f751(arg1);
0041fe15      
0041fded      __fscale(ExpHypSum(st0), -((long double)1));
0041fdef      /* tailcall */
0041fdef      return sub_41f918();
0041fdd2  }


0041fdf4    int80_t sub_41fdf4()

0041fdf4  {
0041fdfc      char ecx;
0041fdfc      /* tailcall */
0041fdfc      return sub_41f9e3(ecx, data_42f6f0);
0041fdf4  }


0041fe01    int80_t sub_41fe01()

0041fe01  {
0041fe09      return data_42f6f0;
0041fe01  }


0041fe0a    int32_t sub_41fe0a() __pure

0041fe0a  {
0041fe0a      return;
0041fe0a  }


0041fe28    int80_t fFEXPH(void* arg1 @ ebp, long double arg2 @ st0, long double arg3 @ st1, long double arg4 @ st2)

0041fe28  {
0041fe2e      int16_t ecx;
0041fe2e      char edx = __ffexpm1(ecx, arg1, 
0041fe2e          arg2 * ((long double)1,4426950407214463.0 + (long double)1,675171316223821e-10));
0041fe33      int32_t ebx;
0041fe33      (uint8_t)ebx = 0xff;
0041fe35      *(uint8_t*)((char*)arg1 - 0x9f);
0041fe35      
0041fe4a      if (!(edx & 0x40))
0041fe4a      {
0041fe4c          *(uint8_t*)((char*)ebx)[1] = 0xff;
0041fe52          __fscale(arg3 + (long double)1, arg4);
0041fe4a      }
0041fe4a      
0041fe54      /* tailcall */
0041fe54      return sub_41f918();
0041fe28  }


0041fe59    long double ExpHypSum(long double arg1 @ st0)

0041fe59  {
0041fe5e      long double result = arg1 + ExpHypCopyInv(arg1);
0041fe60      int16_t entry_ebx;
0041fe60      *(uint8_t*)((char*)entry_ebx)[1] = *(uint8_t*)((char*)entry_ebx)[1];
0041fe60      
0041fe62      if (*(uint8_t*)((char*)entry_ebx)[1])
0041fe6a          return result;
0041fe6a      
0041fe64      long double x87_r7_1 = (long double)1;
0041fe68      return result + x87_r7_1 + x87_r7_1;
0041fe59  }


0041fe6b    long double ExpHypCopyInv(long double arg1 @ st0) __pure

0041fe6b  {
0041fe6d      long double x87_r6 = (long double)1;
0041fe6f      int16_t entry_ebx;
0041fe6f      *(uint8_t*)((char*)entry_ebx)[1] = *(uint8_t*)((char*)entry_ebx)[1];
0041fe6f      
0041fe71      if (!*(uint8_t*)((char*)entry_ebx)[1])
0041fe77          x87_r6 = arg1;
0041fe77      
0041fe7b      return x87_r6 / x87_r6;
0041fe6b  }

0041fe7c                                                                                      cc cc cc cc                              ....

0041fe80    int80_t sub_41fe80(int16_t arg1 @ x87control, long double arg2 @ st0, long double arg3 @ st1)

0041fe80  {
0041fe81      int32_t __saved_ebp;
0041fe81      int32_t* ebp = &__saved_ebp;
0041fe8b      int16_t x87status;
0041fe8b      int16_t temp0;
0041fe8b      temp0 = __fnstcw_memmem16(arg1);
0041fe8b      int16_t var_a8 = temp0;
0041fe8b      
0041fe99      if (!data_4304d0)
0041fe99      {
0041feb1          double var_8a_1 = (double)arg3;
0041feb9          double var_82_1 = (double)arg2;
0041fe99      }
0041fe99      
0041fe9b      int32_t ecx;
0041fe9b      void* edx;
0041fe9b      __trandisp2(ecx, edx, ebp, arg2, arg3);
0041fea0      data_430a38 = 1;
0041feae      return sub_41ff35(ebp, arg2);
0041fe80  }


0041febe    int80_t sub_41febe(int16_t arg1 @ x87control, long double arg2 @ st0)

0041febe  {
0041febf      int32_t __saved_ebp;
0041febf      int32_t* ebp = &__saved_ebp;
0041fec9      int16_t x87status;
0041fec9      int16_t temp0;
0041fec9      temp0 = __fnstcw_memmem16(arg1);
0041fec9      int16_t var_a8 = temp0;
0041fec9      
0041fed6      if (!data_4304d0)
0041feec          double var_8a_1 = (double)arg2;
0041feec      
0041fed8      int32_t ecx;
0041fed8      void* edx;
0041fed8      __trandisp1(ecx, edx, ebp, arg2);
0041fedd      data_430a38 = 1;
0041feeb      return sub_41ff35(ebp, arg2);
0041febe  }


0041fef4    long double sub_41fef4(int16_t arg1 @ x87control, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)

0041fef4  {
0041fefe      int32_t var_2ac = arg3;
0041ff04      int32_t entry_ebx;
0041ff04      long double st0 = __fload(arg2, (uint16_t)entry_ebx);
0041ff0c      int32_t var_2ac_1 = arg5;
0041ff12      long double result = __fload(arg4);
0041ff1b      int16_t x87status;
0041ff1b      int16_t temp0;
0041ff1b      temp0 = __fnstcw_memmem16(arg1);
0041ff1b      int16_t var_a8 = temp0;
0041ff21      int32_t __saved_ebp;
0041ff21      int32_t ecx;
0041ff21      void* edx;
0041ff21      __trandisp2(ecx, edx, &__saved_ebp, result, st0);
0041ff26      sub_41ff2e();
0041ff2d      return result;
0041fef4  }


0041ff2e    int32_t sub_41ff2e()

0041ff2e  {
0041ff2e      data_430a38 = 0;
0041ff2e      void* ebp;
0041ff2e      long double x87_r0;
0041ff2e      /* tailcall */
0041ff2e      return sub_41ff35(ebp, x87_r0);
0041ff2e  }


0041ff35    void sub_41ff35(void* arg1 @ ebp, long double arg2 @ st0)

0041ff35  {
0041ff3c      if (!data_4307a4)
0041ff3c      {
0041ff3e          data_430a30 = (double)arg2;
0041ff3e          bool c1_1 = /* bool c1_1 = unimplemented  {fst qword [&data_430a30], st0} */;
0041ff44          int16_t eax;
0041ff44          (uint8_t)eax = *(uint8_t*)((char*)arg1 - 0x90);
0041ff4a          (uint8_t)eax = (uint8_t)eax;
0041ff4a          
0041ff4c          if (!(uint8_t)eax)
0041ff4c          {
0041ff6f          label_41ff6f:
0041ff7c              bool c0;
0041ff7c              bool c2;
0041ff7c              bool c3;
0041ff7c              
0041ff7c              if (!(*(uint16_t*)((char*)arg1 - 0xa4) & 0x20) && ((c0 ? 1 : 0) << 8
0041ff7c                  | (c1_1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe) & 0x20)
0041ff7c              {
0041ff7e                  *(uint32_t*)((char*)arg1 - 0x8e) = 8;
0042000b              label_42000b:
0042000b                  void* ebx_2 = *(uint32_t*)((char*)arg1 - 0x94) + 1;
0042000c                  *(uint32_t*)((char*)arg1 - 0x8a) = ebx_2;
0042000c                  
00420019                  if (!data_430a38)
00420019                  {
00420025                      *(uint32_t*)((char*)arg1 - 0x86) = *(uint32_t*)((char*)arg1 + 8);
00420026                      *(uint32_t*)((char*)arg1 - 0x82) = *(uint32_t*)((char*)arg1 + 0xc);
00420026                      
0042002b                      if (*(uint8_t*)((char*)ebx_2 + 0xc) != 1)
0042002b                      {
00420033                          *(uint32_t*)((char*)arg1 - 0x7e) =
00420033                              *(uint32_t*)((char*)arg1 + 0x10);
00420034                          *(uint32_t*)((char*)arg1 - 0x7a) =
00420034                              *(uint32_t*)((char*)arg1 + 0x14);
0042002b                      }
00420019                  }
00420019                  
00420035                  *(uint64_t*)((char*)arg1 - 0x76) = (double)arg2;
0042004c                  void* eax_2;
0042004c                  (uint8_t)eax_2 = *(uint8_t*)(*(uint32_t*)((char*)arg1 - 0x94) + 0xe);
00420053                  sub_425ca6((int32_t)(uint8_t)eax_2, (char*)arg1 - 0x8e, 
00420053                      (char*)arg1 - 0xa4);
0042005d                  *(uint64_t*)((char*)arg1 - 0x76);
0041ff7c              }
0041ff4c          }
0041ff4c          else
0041ff4c          {
0041ff54              if ((uint8_t)eax == 0xff || (uint8_t)eax == 0xfe)
0041ff54              {
0041ff9c                  eax = (*(int32_t*)((char*)data_430a30 + 6)) & 0x7ff0;
0041ff9c                  
0041ff9f                  if (!eax)
0041ff9f                  {
0041ffa9                      *(uint32_t*)((char*)arg1 - 0x8e) = 4;
0041ffb9                      long double x87_r7_2 = arg2;
0041ffb9                      arg2 = (long double)1536.0;
0041ffbb                      __fscale(x87_r7_2, arg2);
0041ffc1                      long double x87_r7_5 = fabsl(arg2);
0041ffc3                      long double temp1_1 = (long double)2,2250738585072014e-308;
0041ffc3                      x87_r7_5 - temp1_1;
0041ffc3                      
0041ffcd                      if (TEST_BITB(
0041ffcd                              *(uint8_t*)((char*)((x87_r7_5 < temp1_1 ? 1 : 0) << 8
0041ffcd                                  | (FCMP_UO(x87_r7_5, temp1_1) ? 1 : 0) << 0xa
0041ffcd                                  | (x87_r7_5 == temp1_1 ? 1 : 0) << 0xe))[1], 
0041ffcd                              0))
0041ffcf                          arg2 = arg2 * (long double)0.0;
0041ffcf                      
0041ffcd                      goto label_42000b;
0041ff9f                  }
0041ff9f                  
0041ffa5                  if (eax != 0x7ff0)
0041ffa5                      goto label_41ff6f;
0041ffa5                  
0041ffd7                  *(uint32_t*)((char*)arg1 - 0x8e) = 3;
0041ffe7                  long double x87_r7_7 = arg2;
0041ffe7                  arg2 = (long double)-1536.0;
0041ffe9                  __fscale(x87_r7_7, arg2);
0041ffef                  long double x87_r7_10 = fabsl(arg2);
0041fff1                  long double temp2_1 = (long double)1,7976931348623157e+308;
0041fff1                  x87_r7_10 - temp2_1;
0041fff8                  eax = (x87_r7_10 < temp2_1 ? 1 : 0) << 8
0041fff8                      | (FCMP_UO(x87_r7_10, temp2_1) ? 1 : 0) << 0xa
0041fff8                      | (x87_r7_10 == temp2_1 ? 1 : 0) << 0xe;
0041fff8                  
0041fffb                  if (!TEST_BITB(*(uint8_t*)((char*)eax)[1], 6)
0041fffb                          && !TEST_BITB(*(uint8_t*)((char*)eax)[1], 0))
0041fffd                      arg2 = arg2 * (long double)inf.0;
0041fffd                  
0041fffb                  goto label_42000b;
0041ff54              }
0041ff54              
0041ff56              (uint8_t)eax = (uint8_t)eax;
0041ff56              
0041ff58              if ((uint8_t)eax)
0041ff58              {
0041ff5d                  *(uint32_t*)((char*)arg1 - 0x8e) = (int32_t)(uint8_t)eax;
0041ff63                  goto label_42000b;
0041ff58              }
0041ff4c          }
0041ff3c      }
0041ff3c      
0041ff8a      int16_t x87control;
0041ff8a      int16_t x87status;
0041ff8a      x87control = __fldcw_memmem16(*(uint16_t*)((char*)arg1 - 0xa4));
0041ff35  }


00420065    long double sub_420065(int16_t arg1 @ x87control, int32_t arg2, int32_t arg3)

00420065  {
0042006f      int32_t var_2ac = arg3;
00420075      int32_t entry_ebx;
00420075      long double result = __fload(arg2, (uint16_t)entry_ebx);
0042007e      int16_t x87status;
0042007e      int16_t temp0;
0042007e      temp0 = __fnstcw_memmem16(arg1);
0042007e      int16_t var_a8 = temp0;
00420084      int32_t __saved_ebp;
00420084      int32_t ecx;
00420084      void* edx;
00420084      __trandisp1(ecx, edx, &__saved_ebp, result);
00420089      sub_41ff2e();
00420090      return result;
00420065  }


00420091    long double __fload(double arg1, int16_t arg2) __pure

00420091  {
0042009c      int32_t ebx;
0042009c      (uint16_t)ebx = arg2;
0042009c      
004200a7      if ((arg2 & 0x7ff0) != 0x7ff0)
004200c7          return (long double)arg1;
004200c7      
004200a9      (uint16_t)ebx |= 0x7fff;
004200ae      int16_t var_6_1 = (uint16_t)ebx;
004200b5      int32_t ebx_1 = (uint32_t)arg1;
004200bc      int32_t var_a_1 = *(uint32_t*)((char*)arg1)[4] << 0xb | ebx_1 >> 0xffffffeb;
004200c2      return ebx_1;
00420091  }

004200cd                                         cc cc cc                                                               ...

004200d0    long double sub_4200d0(int16_t arg1 @ x87control, long double arg2, long double arg3)

004200d0  {
004200d0      long double x87_r7 = arg3;
004200d4      long double x87_r6 = arg2;
004200d4      
004200d8      while (true)
004200d8      {
004200d8          int32_t eax_1 = *(uint32_t*)((char*)arg2)[4];
004200d8          
004200de          if (eax_1 * 2 < eax_1)
004200de          {
004200e4              int32_t eax_3 = (eax_1 * 2) ^ 0xe000000;
004200e4              
004200ee              if (eax_3 & 0xe000000)
004200f2                  return x87_r7 / x87_r6;
004200f2              
004200fd              if (!*(uint8_t*)((eax_3 >> 0x1c) + 0x42f800))
00420101                  return x87_r7 / x87_r6;
00420101              
00420106              int32_t eax_6 = *(uint32_t*)((char*)arg2)[8] & 0x7fff;
00420106              
00420112              if (!eax_6 || eax_6 == 0x7fff)
00420176                  return x87_r7 / x87_r6;
00420176              
00420114              int16_t x87status_1;
00420114              int16_t temp0_1;
00420114              temp0_1 = __fnstcw_memmem16(arg1);
0042012a              int16_t x87control;
0042012a              int16_t x87status_2;
0042012a              x87control = __fldcw_memmem16((temp0_1 | 0x33f) & 0xf3ff);
0042012a              
0042013a              if ((*(uint32_t*)((char*)arg3)[8] & 0x7fff) == 1)
0042013a              {
00420159                  long double x87_r7_6 = x87_r6 * (long double)data_42f814;
00420161                  long double x87_r7_7 = x87_r7 * (long double)data_42f814;
00420163                  int16_t x87control_2;
00420163                  int16_t x87status_4;
00420163                  x87control_2 = __fldcw_memmem16(temp0_1);
00420169                  return x87_r7_7 / x87_r7_6;
0042013a              }
0042013a              
00420142              long double x87_r7_3 = x87_r6 * (long double)data_42f810;
0042014a              long double x87_r7_4 = x87_r7 * (long double)data_42f810;
0042014c              int16_t x87control_1;
0042014c              int16_t x87status_3;
0042014c              x87control_1 = __fldcw_memmem16(temp0_1);
00420152              return x87_r7_4 / x87_r7_3;
004200de          }
004200de          
00420180          if (!((uint32_t)arg2 | *(uint32_t*)((char*)arg2)[4])
00420180                  || *(uint32_t*)((char*)arg2)[8] & 0x7fff)
00420176              return x87_r7 / x87_r6;
00420176          
00420182          int16_t x87status_5;
00420182          int16_t temp0_6;
00420182          temp0_6 = __fnstcw_memmem16(arg1);
00420198          int16_t x87control_3;
00420198          int16_t x87status_6;
00420198          x87control_3 = __fldcw_memmem16((temp0_6 | 0x33f) & 0xf3ff);
004201a0          int32_t eax_20 = *(uint32_t*)((char*)arg3)[8] & 0x7fff;
004201a5          int16_t x87control_4;
004201a5          int16_t x87status_8;
004201a5          
004201a5          if (!eax_20)
004201a5          {
004201b8              int32_t eax_23 = *(uint32_t*)((char*)arg3)[4];
004201b8              
004201be              if (eax_23 * 2 < eax_23)
004201be              {
004201e0                  x87control_4 = __fldcw_memmem16(temp0_6);
004201e6                  return x87_r7 / x87_r6;
004201be              }
004201a5          }
004201a5          else
004201a5          {
004201ac              if (eax_20 == 0x7fff)
004201ac              {
004201e0                  x87control_4 = __fldcw_memmem16(temp0_6);
004201e6                  return x87_r7 / x87_r6;
004201ac              }
004201ac              
004201ae              int32_t eax_21 = *(uint32_t*)((char*)arg3)[4];
004201ae              
004201b4              if (eax_21 * 2 >= eax_21)
004201b4              {
004201e0                  x87control_4 = __fldcw_memmem16(temp0_6);
004201e6                  return x87_r7 / x87_r6;
004201b4              }
004201a5          }
004201cc          arg2 = x87_r7 * (long double)data_42f818;
004201d4          x87_r6 = x87_r7;
004201d4          x87_r7 = arg3;
004201d7          int16_t x87status_7;
004201d7          arg1 = __fldcw_memmem16(temp0_6);
004200d8      }
004200d0  }


004201e7    int32_t __convention("regparm") sub_4201e7(int32_t arg1)

004201e7  {
004201ed      /* jump -> *(uint32_t*)(((arg1 & 0x3f) << 2) + &data_42f85e) */
004201e7  }

004201f4                                                              d8 f0 83 c4 2c c3                                        ....,.

004201fa    void sub_4201fa() __noreturn

004201fa  {
004201fd      trap(6);
004201fa  }


00420205    void sub_420205() __noreturn

00420205  {
00420208      trap(6);
00420205  }


00420210    int32_t sub_420210(long double arg1 @ st0) __pure

00420210  {
00420215      return;
00420210  }


00420216    long double sub_420216(long double arg1 @ st0) __pure

00420216  {
0042021b      return arg1 / arg1;
00420216  }


0042021c    int32_t sub_42021c(long double arg1 @ st0) __pure

0042021c  {
00420221      return;
0042021c  }


00420222    int80_t sub_420222(long double arg1 @ st0, int80_t arg2 @ st1)

00420222  {
00420228      __return_addr = arg2;
0042023d      int16_t x87control;
0042023d      return sub_4200d0(x87control, __return_addr, arg1);
00420222  }


0042023e    void sub_42023e() __noreturn

0042023e  {
00420241      trap(6);
0042023e  }


00420259    void sub_420259() __noreturn

00420259  {
0042025c      trap(6);
00420259  }


0042027a    int80_t sub_42027a(int80_t arg1 @ st0, long double arg2 @ st1)

0042027a  {
0042027a      __return_addr = arg1;
00420289      int16_t x87control;
00420289      return sub_4200d0(x87control, __return_addr, arg2);
0042027a  }


0042028a    long double sub_42028a(long double arg1 @ st0, int80_t arg2 @ st1)

0042028a  {
0042028e      __return_addr = arg2;
00420291      int16_t x87control;
00420291      sub_4200d0(x87control, __return_addr, arg1);
0042029d      return arg1;
0042028a  }


0042029e    int80_t sub_42029e(long double arg1 @ st0, int80_t arg2 @ st1)

0042029e  {
004202a2      __return_addr = arg2;
004202ad      int16_t x87control;
004202ad      return sub_4200d0(x87control, __return_addr, arg1);
0042029e  }


004202ae    int80_t sub_4202ae(long double arg1 @ st0, int80_t arg2 @ st2)

004202ae  {
004202b6      __return_addr = arg2;
004202cd      int16_t x87control;
004202cd      return sub_4200d0(x87control, __return_addr, arg1);
004202ae  }


004202ce    void sub_4202ce() __noreturn

004202ce  {
004202d1      trap(6);
004202ce  }


004202ed    void sub_4202ed() __noreturn

004202ed  {
004202f0      trap(6);
004202ed  }


00420312    int80_t sub_420312(int80_t arg1 @ st0, int80_t arg2 @ st1, long double arg3 @ st2)

00420312  {
00420312      __return_addr = arg1;
0042031b      int16_t x87control;
0042031b      sub_4200d0(x87control, __return_addr, arg3);
00420325      return arg2;
00420312  }


00420326    long double sub_420326(long double arg1 @ st0, int80_t arg2 @ st2)

00420326  {
0042032c      __return_addr = arg2;
0042032f      int16_t x87control;
0042032f      sub_4200d0(x87control, __return_addr, arg1);
0042033d      return arg1;
00420326  }


0042033e    int80_t sub_42033e(long double arg1 @ st0, int80_t arg2 @ st1, int80_t arg3 @ st2)

0042033e  {
00420344      __return_addr = arg3;
00420347      int16_t x87control;
00420347      sub_4200d0(x87control, __return_addr, arg1);
00420351      return arg2;
0042033e  }


00420352    int80_t sub_420352(long double arg1 @ st0, int80_t arg2 @ st3)

00420352  {
0042035a      __return_addr = arg2;
00420371      int16_t x87control;
00420371      return sub_4200d0(x87control, __return_addr, arg1);
00420352  }


00420372    void sub_420372() __noreturn

00420372  {
00420375      trap(6);
00420372  }


00420391    void sub_420391() __noreturn

00420391  {
00420394      trap(6);
00420391  }


004203b6    int32_t sub_4203b6(int80_t arg1 @ st0, long double arg2 @ st3)

004203b6  {
004203b6      __return_addr = arg1;
004203bf      int32_t result;
004203bf      int16_t x87control;
004203bf      int80_t st0;
004203bf      st0 = sub_4200d0(x87control, __return_addr, arg2);
004203c9      return result;
004203b6  }


004203ca    int32_t sub_4203ca(long double arg1 @ st0, int80_t arg2 @ st3)

004203ca  {
004203d0      __return_addr = arg2;
004203d3      int32_t result;
004203d3      int16_t x87control;
004203d3      int80_t st0;
004203d3      st0 = sub_4200d0(x87control, __return_addr, arg1);
004203e1      return result;
004203ca  }


004203e2    int32_t sub_4203e2(long double arg1 @ st0, int80_t arg2 @ st3)

004203e2  {
004203e8      __return_addr = arg2;
004203eb      int32_t result;
004203eb      int16_t x87control;
004203eb      int80_t st0;
004203eb      st0 = sub_4200d0(x87control, __return_addr, arg1);
004203f5      return result;
004203e2  }


004203f6    int80_t sub_4203f6(long double arg1 @ st0, int80_t arg2 @ st4)

004203f6  {
004203fe      __return_addr = arg2;
00420415      int16_t x87control;
00420415      return sub_4200d0(x87control, __return_addr, arg1);
004203f6  }


00420416    void sub_420416() __noreturn

00420416  {
00420419      trap(6);
00420416  }


00420435    void sub_420435() __noreturn

00420435  {
00420438      trap(6);
00420435  }


0042045a    int32_t sub_42045a(int80_t arg1 @ st0, long double arg2 @ st4)

0042045a  {
0042045a      __return_addr = arg1;
00420463      int32_t result;
00420463      int16_t x87control;
00420463      int80_t st0;
00420463      st0 = sub_4200d0(x87control, __return_addr, arg2);
0042046d      return result;
0042045a  }


0042046e    int32_t sub_42046e(long double arg1 @ st0, int80_t arg2 @ st4)

0042046e  {
00420474      __return_addr = arg2;
00420477      int32_t result;
00420477      int16_t x87control;
00420477      int80_t st0;
00420477      st0 = sub_4200d0(x87control, __return_addr, arg1);
00420485      return result;
0042046e  }


00420486    int32_t sub_420486(long double arg1 @ st0, int80_t arg2 @ st4)

00420486  {
0042048c      __return_addr = arg2;
0042048f      int32_t result;
0042048f      int16_t x87control;
0042048f      int80_t st0;
0042048f      st0 = sub_4200d0(x87control, __return_addr, arg1);
00420499      return result;
00420486  }


0042049a    int80_t sub_42049a(long double arg1 @ st0, int80_t arg2 @ st5)

0042049a  {
004204a2      __return_addr = arg2;
004204b9      int16_t x87control;
004204b9      return sub_4200d0(x87control, __return_addr, arg1);
0042049a  }


004204ba    void sub_4204ba() __noreturn

004204ba  {
004204bd      trap(6);
004204ba  }


004204d9    void sub_4204d9() __noreturn

004204d9  {
004204dc      trap(6);
004204d9  }


004204fe    int32_t sub_4204fe(int80_t arg1 @ st0, long double arg2 @ st5)

004204fe  {
004204fe      __return_addr = arg1;
00420507      int32_t result;
00420507      int16_t x87control;
00420507      int80_t st0;
00420507      st0 = sub_4200d0(x87control, __return_addr, arg2);
00420511      return result;
004204fe  }


00420512    int32_t sub_420512(long double arg1 @ st0, int80_t arg2 @ st5)

00420512  {
00420518      __return_addr = arg2;
0042051b      int32_t result;
0042051b      int16_t x87control;
0042051b      int80_t st0;
0042051b      st0 = sub_4200d0(x87control, __return_addr, arg1);
00420529      return result;
00420512  }


0042052a    int32_t sub_42052a(long double arg1 @ st0, int80_t arg2 @ st5)

0042052a  {
00420530      __return_addr = arg2;
00420533      int32_t result;
00420533      int16_t x87control;
00420533      int80_t st0;
00420533      st0 = sub_4200d0(x87control, __return_addr, arg1);
0042053d      return result;
0042052a  }


0042053e    int80_t sub_42053e(long double arg1 @ st0, int80_t arg2 @ st6)

0042053e  {
00420546      __return_addr = arg2;
0042055d      int16_t x87control;
0042055d      return sub_4200d0(x87control, __return_addr, arg1);
0042053e  }


0042055e    void sub_42055e() __noreturn

0042055e  {
00420561      trap(6);
0042055e  }


0042057d    void sub_42057d() __noreturn

0042057d  {
00420580      trap(6);
0042057d  }


004205a2    int32_t sub_4205a2(int80_t arg1 @ st0, long double arg2 @ st6)

004205a2  {
004205a2      __return_addr = arg1;
004205ab      int32_t result;
004205ab      int16_t x87control;
004205ab      int80_t st0;
004205ab      st0 = sub_4200d0(x87control, __return_addr, arg2);
004205b5      return result;
004205a2  }


004205b6    int32_t sub_4205b6(long double arg1 @ st0, int80_t arg2 @ st6)

004205b6  {
004205bc      __return_addr = arg2;
004205bf      int32_t result;
004205bf      int16_t x87control;
004205bf      int80_t st0;
004205bf      st0 = sub_4200d0(x87control, __return_addr, arg1);
004205cd      return result;
004205b6  }


004205ce    int32_t sub_4205ce(long double arg1 @ st0, int80_t arg2 @ st6)

004205ce  {
004205d4      __return_addr = arg2;
004205d7      int32_t result;
004205d7      int16_t x87control;
004205d7      int80_t st0;
004205d7      st0 = sub_4200d0(x87control, __return_addr, arg1);
004205e1      return result;
004205ce  }


004205e2    int80_t sub_4205e2(long double arg1 @ st0, int80_t arg2 @ st7)

004205e2  {
004205ea      __return_addr = arg2;
00420601      int16_t x87control;
00420601      return sub_4200d0(x87control, __return_addr, arg1);
004205e2  }


00420602    void sub_420602() __noreturn

00420602  {
00420605      trap(6);
00420602  }


00420621    void sub_420621() __noreturn

00420621  {
00420624      trap(6);
00420621  }


00420646    int32_t sub_420646(int80_t arg1 @ st0, long double arg2 @ st7)

00420646  {
00420646      __return_addr = arg1;
0042064f      int32_t result;
0042064f      int16_t x87control;
0042064f      int80_t st0;
0042064f      st0 = sub_4200d0(x87control, __return_addr, arg2);
00420659      return result;
00420646  }


0042065a    int32_t sub_42065a(long double arg1 @ st0, int80_t arg2 @ st7)

0042065a  {
00420660      __return_addr = arg2;
00420663      int32_t result;
00420663      int16_t x87control;
00420663      int80_t st0;
00420663      st0 = sub_4200d0(x87control, __return_addr, arg1);
00420671      return result;
0042065a  }


00420672    int32_t sub_420672(long double arg1 @ st0, int80_t arg2 @ st7)

00420672  {
00420678      __return_addr = arg2;
0042067b      int32_t result;
0042067b      int16_t x87control;
0042067b      int80_t st0;
0042067b      st0 = sub_4200d0(x87control, __return_addr, arg1);
00420685      return result;
00420672  }


00420686    int80_t sub_420686(long double arg1 @ st0, long double arg2 @ st1)

00420686  {
00420698      int16_t x87control;
00420698      return sub_4200d0(x87control, arg1, arg2);
00420686  }


00420699    int80_t sub_420699(long double arg1 @ st0, long double arg2 @ st1)

00420699  {
004206ab      int16_t x87control;
004206ab      return sub_4200d0(x87control, arg2, arg1);
00420699  }


004206ac    long double __stdcall sub_4206ac(long double arg1 @ st0, float arg2)

004206ac  {
004206bb      if ((arg2 & 0x7f800000) == 0x7f800000)
004206f5          return arg1 / (long double)arg2;
004206f5      
004206bd      int32_t eax_1;
004206bd      bool c0;
004206bd      bool c1;
004206bd      bool c2;
004206bd      bool c3;
004206bd      (uint16_t)eax_1 =
004206bd          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
004206d0      return sub_420686((long double)arg2, arg1);
004206ac  }


004206f8    long double __stdcall sub_4206f8(long double arg1 @ st0, double arg2, int32_t arg3)

004206f8  {
00420707      if ((arg3 & 0x7ff00000) == 0x7ff00000)
00420741          return arg1 / (long double)arg2;
00420741      
00420709      int32_t eax_1;
00420709      bool c0;
00420709      bool c1;
00420709      bool c2;
00420709      bool c3;
00420709      (uint16_t)eax_1 =
00420709          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0042071c      return sub_420686((long double)arg2, arg1);
004206f8  }


00420744    int80_t __stdcall sub_420744(long double arg1 @ st0, int16_t arg2)

00420744  {
00420745      int32_t eax;
00420745      bool c0;
00420745      bool c1;
00420745      bool c2;
00420745      bool c3;
00420745      (uint16_t)eax =
00420745          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
00420758      return sub_420686((long double)arg2, arg1);
00420744  }


00420778    int80_t __stdcall sub_420778(long double arg1 @ st0, int32_t arg2)

00420778  {
00420779      int32_t eax;
00420779      bool c0;
00420779      bool c1;
00420779      bool c2;
00420779      bool c3;
00420779      (uint16_t)eax =
00420779          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0042078c      return sub_420686((long double)arg2, arg1);
00420778  }


004207ac    long double __stdcall sub_4207ac(long double arg1 @ st0, float arg2)

004207ac  {
004207bb      if ((arg2 & 0x7f800000) == 0x7f800000)
004207f5          return (long double)arg2 / arg1;
004207f5      
004207bd      int32_t eax_1;
004207bd      bool c0;
004207bd      bool c1;
004207bd      bool c2;
004207bd      bool c3;
004207bd      (uint16_t)eax_1 =
004207bd          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
004207d0      return sub_420699((long double)arg2, arg1);
004207ac  }


004207f8    long double __stdcall sub_4207f8(long double arg1 @ st0, double arg2, int32_t arg3)

004207f8  {
00420807      if ((arg3 & 0x7ff00000) == 0x7ff00000)
00420841          return (long double)arg2 / arg1;
00420841      
00420809      int32_t eax_1;
00420809      bool c0;
00420809      bool c1;
00420809      bool c2;
00420809      bool c3;
00420809      (uint16_t)eax_1 =
00420809          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0042081c      return sub_420699((long double)arg2, arg1);
004207f8  }


00420844    int80_t __stdcall sub_420844(long double arg1 @ st0, int16_t arg2)

00420844  {
00420845      int32_t eax;
00420845      bool c0;
00420845      bool c1;
00420845      bool c2;
00420845      bool c3;
00420845      (uint16_t)eax =
00420845          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
00420858      return sub_420699((long double)arg2, arg1);
00420844  }


00420878    int80_t __stdcall sub_420878(long double arg1 @ st0, int32_t arg2)

00420878  {
00420879      int32_t eax;
00420879      bool c0;
00420879      bool c1;
00420879      bool c2;
00420879      bool c3;
00420879      (uint16_t)eax =
00420879          (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe;
0042088c      return sub_420699((long double)arg2, arg1);
00420878  }


004208ac    int80_t sub_4208ac(long double arg1 @ st0, long double arg2 @ st1)

004208ac  {
004208c0      int16_t x87control;
004208c0      return sub_4200d0(x87control, arg1, arg2);
004208ac  }


004208c1    int80_t sub_4208c1(long double arg1 @ st0, long double arg2 @ st1)

004208c1  {
004208d5      int16_t x87control;
004208d5      return sub_4200d0(x87control, arg2, arg1);
004208c1  }


004208d6    long double __convention("regparm") sub_4208d6(int32_t arg1, int32_t arg2, int16_t arg3 @ x87control, long double arg4, int32_t arg5, long double arg6, long double arg7)

004208d6  {
004208dd      int32_t eax_1 = arg5 ^ 0x700;
0042090e      int16_t arg_28;
0042090e      long double result;
0042090e      long double result_3;
0042090e      bool c0;
0042090e      bool c1;
0042090e      bool c2_3;
0042090e      bool c3;
0042090e      
0042090e      if (eax_1 & 0x700 || !*(uint8_t*)((eax_1 >> 0xb & 0xf) + 0x42f81c)
0042090e          || (arg5 & 0x7fff0000) == 0x7fff0000)
0042090e      {
00420a70      label_420a70:
00420a70          result_3 = arg4;
00420a78          long double result_1;
00420a78          uint8_t temp0_7;
00420a78          result_1 = __fprem(arg7, result_3);
00420a78          result = result_1;
00420a78          
00420a78          if (!c2_3)
00420a78          {
00420a78              c0 = temp0_7 & 4;
00420a78              c1 = temp0_7 & 1;
00420a78              c3 = temp0_7 & 2;
00420a78          }
0042090e      }
0042090e      else
0042090e      {
00420918          int32_t eax_7 = *(uint32_t*)((char*)arg7)[6] & 0x7fff0000;
00420918          
00420928          if (!eax_7 || eax_7 == 0x7fff0000)
0042091d              goto label_420a70;
0042091d          
0042092e          int32_t eax_8 = *(uint32_t*)((char*)arg7)[4];
0042092e          
00420934          if (eax_8 != -(eax_8))
00420934              goto label_420a70;
00420934          
0042093a          int32_t eax_10 = *(uint32_t*)((char*)arg4)[4];
0042093a          
00420940          if (eax_10 != -(eax_10))
00420940              goto label_420a70;
00420940          
0042095e          if ((*(uint32_t*)((char*)arg7)[8] & 0x7fff) <= (arg5 & 0x7fff) + 0x3f)
0042095e          {
00420978              while ((*(uint32_t*)((char*)arg7)[8] & 0x7fff) - ((arg5 & 0x7fff) + 0xa) >= 0)
00420978              {
00420982                  int32_t eax_18 = arg5;
0042098a                  int32_t ebx_8 = *(uint32_t*)((char*)arg7)[8] & 0x7fff;
004209a6                  arg5 = (ebx_8 - (((ebx_8 - eax_18) & 7) | 4)) | (eax_18 & 0x8000);
004209ae                  arg5 = eax_18;
004209b4                  long double st0_1;
004209b4                  uint8_t temp0_2;
004209b4                  bool c2_1;
004209b4                  st0_1 = __fprem(arg7, arg4);
004209b4                  
004209b4                  if (!c2_1)
004209b4                  {
004209b4                      c0 = temp0_2 & 4;
004209b4                      c1 = temp0_2 & 1;
004209b4                      c3 = temp0_2 & 2;
004209b4                  }
004209b4                  
004209b6                  arg7 = st0_1;
00420978              }
00420978              
00420978              goto label_420a70;
0042095e          }
0042095e          
004209c4          if (!(arg2 & 2))
004209ca              arg6 = arg4;
004209ca          
004209ce          int16_t x87status_1;
004209ce          char temp0_3;
004209ce          temp0_3 = __fnstcw_memmem16(arg3);
004209ce          arg_28 = temp0_3;
004209df          int16_t x87control;
004209df          int16_t x87status_2;
004209df          x87control = __fldcw_memmem16(arg_28 | 0x33f);
00420a01          int32_t i_1 = ((((*(uint32_t*)((char*)arg7)[8] & 0x7fff) - (arg5 & 0x7fff))
00420a01              & 0x3f) | 0x20) + 1;
00420a18          arg5 = (*(uint32_t*)((char*)arg7)[8] & 0x7fff) | (arg5 & 0x8000);
00420a20          long double x87_r7_5 = fabsl(arg4);
00420a26          long double result_2 = fabsl(arg7);
00420a42          int32_t i;
00420a42          
00420a42          do
00420a42          {
00420a28              result_2 - x87_r7_5;
00420a28              c0 = result_2 < x87_r7_5;
00420a28              c1 = false;
00420a28              c3 = result_2 == x87_r7_5;
00420a2a              int32_t eax_24;
00420a2a              (uint16_t)eax_24 = (c0 ? 1 : 0) << 8
00420a2a                  | (FCMP_UO(result_2, x87_r7_5) ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe
00420a2a                  | 0x3000;
00420a2a              
00420a31              if (!(eax_24 & 0x100))
00420a33                  result_2 = result_2 - x87_r7_5;
00420a33              
00420a3d              x87_r7_5 = x87_r7_5 * (long double)data_42f84c;
00420a3f              i = i_1;
00420a3f              i_1 -= 1;
00420a42          } while (i != 1);
00420a58          long double result_4;
00420a58          uint8_t temp0_6;
00420a58          result_4 = __fprem(data_42f854, arg6);
00420a58          
00420a58          if (!c2_3)
00420a58          {
00420a58              c0 = temp0_6 & 4;
00420a58              c1 = temp0_6 & 1;
00420a58              c3 = temp0_6 & 2;
00420a58          }
00420a58          
00420a5a          result_3 = result_4;
00420a5c          result = result_2;
00420a60          int16_t x87status_3;
00420a60          arg3 = __fldcw_memmem16(arg_28);
00420a60          
00420a6a          if (*(uint32_t*)((char*)arg7)[8] & 0x8000)
00420a6a          {
00420a6c              result = -(result);
00420a6c              c1 = false;
00420a6a          }
0042090e      }
0042090e      
00420a80      if (arg2 & 3)
00420a80      {
00420a8c          if (arg2 & 1)
00420a8c          {
00420a8e              int16_t x87status_4;
00420a8e              char temp0_8;
00420a8e              temp0_8 = __fnstcw_memmem16(arg3);
00420a8e              arg_28 = temp0_8;
00420a9f              int16_t x87control_1;
00420a9f              int16_t x87status_5;
00420a9f              x87control_1 = __fldcw_memmem16(arg_28 | 0x300);
00420aa3              data_42f83c;
00420aa9              int16_t x87control_2;
00420aa9              int16_t x87status_6;
00420aa9              x87control_2 = __fldcw_memmem16(arg_28);
00420a8c          }
00420a8c          
00420ab9          result = result_3;
00420ac3          int16_t x87status_7;
00420ac3          char temp0_11;
00420ac3          temp0_11 = __fnstenv_memmem28();
00420ac6          uint224_t var_28_1;
00420ac6          *(uint32_t*)((char*)var_28_1)[4] = *(uint32_t*)((char*)temp0_11)[4] & 0xbcff;
00420ace          *(uint32_t*)((char*)var_28_1)[4] |= ((c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9
00420ace              | (c2_3 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe | 0x3000) & 0x4300;
00420ad2          __fldenv_memmem28(var_28_1);
00420a80      }
00420a80      
00420adb      return result;
004208d6  }


00420adc    long double sub_420adc(int16_t arg1 @ x87control, long double arg2 @ st0, long double arg3 @ st1)

00420adc  {
00420ae0      long double var_1c = arg2;
00420ae9      int32_t eax = *(uint32_t*)((char*)arg3)[6];
00420ae9      
00420af2      if (eax & 0x7fff0000)
00420afd          return sub_4208d6(eax, 0, arg1, arg3);
00420afd      
00420b0c      if (!((uint32_t)arg3 | *(uint32_t*)((char*)arg3)[4]))
00420b0c      {
00420b87          long double result;
00420b87          int80_t temp0_4;
00420b87          bool c2;
00420b87          result = __fprem(var_1c, arg3);
00420b8d          return result;
00420b0c      }
00420b0c      
00420b19      int32_t edx = 2;
00420b1c      int16_t x87status;
00420b1c      int16_t temp0_2;
00420b1c      temp0_2 = __fnstcw_memmem16(arg1);
00420b1c      int16_t var_10 = temp0_2;
00420b29      int32_t var_c = var_10 | 0x33f;
00420b2d      int16_t x87control;
00420b2d      int16_t x87status_1;
00420b2d      x87control = __fldcw_memmem16((uint16_t)var_c);
00420b35      int32_t eax_6 = *(uint32_t*)((char*)var_1c)[8] & 0x7fff;
00420b3f      long double var_34_1;
00420b3f      
00420b3f      if (eax_6 > 0x7fbe)
00420b3f      {
00420b59          int16_t x87status_2;
00420b59          int16_t temp0_3;
00420b59          temp0_3 = __fnstcw_memmem16(x87control);
00420b59          var_10 = temp0_3;
00420b61          eax_6 = var_10 | 0x300;
00420b66          var_c = eax_6;
00420b6a          int16_t x87control_1;
00420b6a          int16_t x87status_3;
00420b6a          x87control_1 = __fldcw_memmem16((uint16_t)var_c);
00420b76          var_34_1 = var_1c * (long double)data_42f834;
00420b3f      }
00420b3f      else
00420b3f      {
00420b41          edx = 3;
00420b4a          var_1c = var_1c * (long double)data_42f834;
00420b54          var_34_1 = arg3 * (long double)data_42f834;
00420b3f      }
00420b3f      
00420b79      int16_t x87control_2;
00420b79      int16_t x87status_4;
00420b79      x87control_2 = __fldcw_memmem16(var_10);
00420b86      return sub_4208d6(eax_6, edx, x87control_2, var_34_1, arg3, var_1c, var_10, var_c);
00420adc  }


00420b8e    long double __convention("regparm") sub_420b8e(int32_t arg1, int32_t arg2, int16_t arg3 @ x87control, long double arg4, int32_t arg5, long double arg6, long double arg7)

00420b8e  {
00420b95      int32_t eax_1 = arg5 ^ 0x700;
00420bc6      int16_t arg_28;
00420bc6      long double result;
00420bc6      long double result_3;
00420bc6      bool c0;
00420bc6      bool c1;
00420bc6      bool c2_3;
00420bc6      bool c3;
00420bc6      
00420bc6      if (eax_1 & 0x700 || !*(uint8_t*)((eax_1 >> 0xb & 0xf) + 0x42f81c)
00420bc6          || (arg5 & 0x7fff0000) == 0x7fff0000)
00420bc6      {
00420d28      label_420d28:
00420d28          result_3 = arg4;
00420d30          long double result_1;
00420d30          uint8_t temp0_7;
00420d30          result_1 = __fprem1(arg7, result_3);
00420d30          result = result_1;
00420d30          
00420d30          if (!c2_3)
00420d30          {
00420d30              c0 = temp0_7 & 4;
00420d30              c1 = temp0_7 & 1;
00420d30              c3 = temp0_7 & 2;
00420d30          }
00420bc6      }
00420bc6      else
00420bc6      {
00420bd0          int32_t eax_7 = *(uint32_t*)((char*)arg7)[6] & 0x7fff0000;
00420bd0          
00420be0          if (!eax_7 || eax_7 == 0x7fff0000)
00420bd5              goto label_420d28;
00420bd5          
00420be6          int32_t eax_8 = *(uint32_t*)((char*)arg7)[4];
00420be6          
00420bec          if (eax_8 != -(eax_8))
00420bec              goto label_420d28;
00420bec          
00420bf2          int32_t eax_10 = *(uint32_t*)((char*)arg4)[4];
00420bf2          
00420bf8          if (eax_10 != -(eax_10))
00420bf8              goto label_420d28;
00420bf8          
00420c0e          int32_t ebx_2 = *(uint32_t*)((char*)arg7)[8] & 0x7fff;
00420c0e          
00420c16          if (ebx_2 <= (arg5 & 0x7fff) + 0x3f)
00420c16          {
00420c30              while ((*(uint32_t*)((char*)arg7)[8] & 0x7fff) - ((arg5 & 0x7fff) + 0xa) >= 0)
00420c30              {
00420c3a                  int32_t eax_18 = arg5;
00420c42                  int32_t ebx_8 = *(uint32_t*)((char*)arg7)[8] & 0x7fff;
00420c5e                  arg5 = (ebx_8 - (((ebx_8 - eax_18) & 7) | 4)) | (eax_18 & 0x8000);
00420c66                  arg5 = eax_18;
00420c6c                  long double st0_1;
00420c6c                  uint8_t temp0_2;
00420c6c                  bool c2_1;
00420c6c                  st0_1 = __fprem(arg7, arg4);
00420c6c                  
00420c6c                  if (!c2_1)
00420c6c                  {
00420c6c                      c0 = temp0_2 & 4;
00420c6c                      c1 = temp0_2 & 1;
00420c6c                      c3 = temp0_2 & 2;
00420c6c                  }
00420c6c                  
00420c6e                  arg7 = st0_1;
00420c30              }
00420c30              
00420c30              goto label_420d28;
00420c16          }
00420c16          
00420c7c          if (!((ebx_2 - ((arg5 & 0x7fff) + 0x3f)) & 2))
00420c82              arg6 = arg4;
00420c82          
00420c86          int16_t x87status_1;
00420c86          char temp0_3;
00420c86          temp0_3 = __fnstcw_memmem16(arg3);
00420c86          arg_28 = temp0_3;
00420c97          int16_t x87control;
00420c97          int16_t x87status_2;
00420c97          x87control = __fldcw_memmem16(arg_28 | 0x33f);
00420cb9          int32_t i_1 = ((((*(uint32_t*)((char*)arg7)[8] & 0x7fff) - (arg5 & 0x7fff))
00420cb9              & 0x3f) | 0x20) + 1;
00420cd0          arg5 = (*(uint32_t*)((char*)arg7)[8] & 0x7fff) | (arg5 & 0x8000);
00420cd8          long double x87_r7_5 = fabsl(arg4);
00420cde          long double result_2 = fabsl(arg7);
00420cfa          int32_t i;
00420cfa          
00420cfa          do
00420cfa          {
00420ce0              result_2 - x87_r7_5;
00420ce0              c0 = result_2 < x87_r7_5;
00420ce0              c1 = false;
00420ce0              c3 = result_2 == x87_r7_5;
00420ce2              int32_t eax_24;
00420ce2              (uint16_t)eax_24 = (c0 ? 1 : 0) << 8
00420ce2                  | (FCMP_UO(result_2, x87_r7_5) ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe
00420ce2                  | 0x3000;
00420ce2              
00420ce9              if (!(eax_24 & 0x100))
00420ceb                  result_2 = result_2 - x87_r7_5;
00420ceb              
00420cf5              x87_r7_5 = x87_r7_5 * (long double)data_42f84c;
00420cf7              i = i_1;
00420cf7              i_1 -= 1;
00420cfa          } while (i != 1);
00420d10          long double result_4;
00420d10          uint8_t temp0_6;
00420d10          result_4 = __fprem1(data_42f854, arg6);
00420d10          
00420d10          if (!c2_3)
00420d10          {
00420d10              c0 = temp0_6 & 4;
00420d10              c1 = temp0_6 & 1;
00420d10              c3 = temp0_6 & 2;
00420d10          }
00420d10          
00420d12          result_3 = result_4;
00420d14          result = result_2;
00420d18          int16_t x87status_3;
00420d18          arg3 = __fldcw_memmem16(arg_28);
00420d18          
00420d22          if (*(uint32_t*)((char*)arg7)[8] & 0x8000)
00420d22          {
00420d24              result = -(result);
00420d24              c1 = false;
00420d22          }
00420bc6      }
00420bc6      
00420d38      if (arg2 & 3)
00420d38      {
00420d44          if (arg2 & 1)
00420d44          {
00420d46              int16_t x87status_4;
00420d46              char temp0_8;
00420d46              temp0_8 = __fnstcw_memmem16(arg3);
00420d46              arg_28 = temp0_8;
00420d57              int16_t x87control_1;
00420d57              int16_t x87status_5;
00420d57              x87control_1 = __fldcw_memmem16(arg_28 | 0x300);
00420d5b              data_42f83c;
00420d61              int16_t x87control_2;
00420d61              int16_t x87status_6;
00420d61              x87control_2 = __fldcw_memmem16(arg_28);
00420d44          }
00420d44          
00420d71          result = result_3;
00420d7b          int16_t x87status_7;
00420d7b          char temp0_11;
00420d7b          temp0_11 = __fnstenv_memmem28();
00420d7e          uint224_t var_28_1;
00420d7e          *(uint32_t*)((char*)var_28_1)[4] = *(uint32_t*)((char*)temp0_11)[4] & 0xbcff;
00420d86          *(uint32_t*)((char*)var_28_1)[4] |= ((c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9
00420d86              | (c2_3 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe | 0x3000) & 0x4300;
00420d8a          __fldenv_memmem28(var_28_1);
00420d38      }
00420d38      
00420d93      return result;
00420b8e  }


00420d94    long double sub_420d94(int16_t arg1 @ x87control, long double arg2 @ st0, long double arg3 @ st1)

00420d94  {
00420d98      long double var_1c = arg2;
00420da4      int32_t eax = *(uint32_t*)((char*)arg3)[6];
00420da4      
00420dad      if (eax & 0x7fff0000)
00420db8          return sub_420b8e(eax, 0, arg1, arg3);
00420db8      
00420dc7      if (!((uint32_t)arg3 | *(uint32_t*)((char*)arg3)[4]))
00420dc7      {
00420e42          long double result;
00420e42          int80_t temp0_4;
00420e42          bool c2;
00420e42          result = __fprem(var_1c, arg3);
00420e48          return result;
00420dc7      }
00420dc7      
00420dd4      int32_t edx = 2;
00420dd7      int16_t x87status;
00420dd7      int16_t temp0_2;
00420dd7      temp0_2 = __fnstcw_memmem16(arg1);
00420dd7      int16_t var_10 = temp0_2;
00420de4      int32_t var_c = var_10 | 0x33f;
00420de8      int16_t x87control;
00420de8      int16_t x87status_1;
00420de8      x87control = __fldcw_memmem16((uint16_t)var_c);
00420df0      int32_t eax_6 = *(uint32_t*)((char*)var_1c)[8] & 0x7fff;
00420dfa      long double var_34_1;
00420dfa      
00420dfa      if (eax_6 > 0x7fbe)
00420dfa      {
00420e14          int16_t x87status_2;
00420e14          int16_t temp0_3;
00420e14          temp0_3 = __fnstcw_memmem16(x87control);
00420e14          var_10 = temp0_3;
00420e1c          eax_6 = var_10 | 0x300;
00420e21          var_c = eax_6;
00420e25          int16_t x87control_1;
00420e25          int16_t x87status_3;
00420e25          x87control_1 = __fldcw_memmem16((uint16_t)var_c);
00420e31          var_34_1 = var_1c * (long double)data_42f834;
00420dfa      }
00420dfa      else
00420dfa      {
00420dfc          edx = 3;
00420e05          var_1c = var_1c * (long double)data_42f834;
00420e0f          var_34_1 = arg3 * (long double)data_42f834;
00420dfa      }
00420dfa      
00420e34      int16_t x87control_2;
00420e34      int16_t x87status_4;
00420e34      x87control_2 = __fldcw_memmem16(var_10);
00420e41      return sub_420b8e(eax_6, edx, x87control_2, var_34_1, arg3, var_1c, var_10, var_c);
00420d94  }


00420e49    int80_t sub_420e49()

00420e49  {
00420e4e      int16_t x87control;
00420e4e      long double x87_r0;
00420e4e      long double x87_r1;
00420e4e      return sub_420adc(x87control, x87_r0, x87_r1);
00420e49  }


00420e4f    int80_t sub_420e4f()

00420e4f  {
00420e54      int16_t x87control;
00420e54      long double x87_r0;
00420e54      long double x87_r1;
00420e54      return sub_420d94(x87control, x87_r0, x87_r1);
00420e4f  }


00420e55    long double sub_420e55(long double arg1 @ st0, long double arg2 @ st1)

00420e55  {
00420e57      return __fpatan(arg1, arg2);
00420e55  }


00420e58    int32_t sub_420e58(long double arg1 @ st0)

00420e58  {
00420e58      long double st0;
00420e58      bool c2;
00420e58      st0 = __fptan(arg1);
00420e58  }


00420e5b    long double sub_420e5b(int32_t arg1, int32_t arg2, int32_t arg3) __pure

00420e5b  {
00420e5e      int32_t ecx;
00420e5e      int32_t var_8 = ecx;
00420e5f      int32_t var_c = ecx;
00420e74      int32_t var_8_1 = ((arg3 ^ arg2) & 0x7fffffff) ^ arg3;
00420e7b      return (long double)arg1;
00420e5b  }


00420e7c    int32_t sub_420e7c(double arg1, int32_t arg2)

00420e7c  {
00420e89      int16_t edx_1 = (uint16_t)arg2 & 0x7ff0;
00420e89      
00420e8e      if (edx_1 == 0x7ff0)
00420e8e      {
00420e98          int32_t eax_1 = sub_41f458(0x7ff0, 0x7ff0);
00420e98          
00420ea0          if (eax_1 == 1)
00420ebb              return 0x200;
00420ebb          
00420ea3          if (eax_1 == 2)
00420eb1              return 4;
00420eb1          
00420ea6          if (eax_1 == 3)
00420ead              return 2;
00420ead          
00420ea8          return 1;
00420e8e      }
00420e8e      
00420ec4      int32_t ecx_1 = arg2 & 0x8000;
00420ec4      
00420ed5      if (!edx_1 && (*(uint32_t*)((char*)arg1)[4] & 0xfffff || (uint32_t)arg1))
00420ed5      {
00420ed9          int32_t eax_9 = -(ecx_1);
00420edd          int32_t eax_10;
00420edd          (uint8_t)eax_10 = (eax_9 - eax_9) & 0x90;
00420ee5          return eax_10 + 0x80;
00420ed5      }
00420ed5      
00420ee6      long double x87_r7 = (long double)arg1;
00420ee9      long double temp1 = (long double)0.0;
00420ee9      x87_r7 - temp1;
00420eef      int32_t eax_7;
00420eef      (uint16_t)eax_7 = (x87_r7 < temp1 ? 1 : 0) << 8
00420eef          | (FCMP_UO(x87_r7, temp1) ? 1 : 0) << 0xa | (x87_r7 == temp1 ? 1 : 0) << 0xe;
00420eef      
00420ef4      if (!TEST_BITB(*(uint8_t*)((char*)eax_7)[1], 6))
00420ef4      {
00420f01          int32_t eax_16 = -(ecx_1);
00420f05          int32_t eax_17;
00420f05          (uint8_t)eax_17 = (eax_16 - eax_16) & 8;
00420f0d          return eax_17 + 0x100;
00420ef4      }
00420ef4      
00420ef6      int32_t eax_13 = -(ecx_1);
00420efa      int32_t eax_14;
00420efa      (uint8_t)eax_14 = (eax_13 - eax_13) & 0xe0;
00420f00      return eax_14 + 0x40;
00420e7c  }


00420f0e    int32_t sub_420f0e(uint32_t arg1, uint32_t arg2, uint8_t* arg3, void* arg4, PSTR arg5, int32_t arg6, uint32_t arg7, int32_t arg8)

00420f0e  {
00420f11      int32_t var_8 = 0xffffffff;
00420f13      int32_t var_c = 0x429440;
00420f18      int32_t var_10 = 0x41c5cc;
00420f23      TEB* fsbase;
00420f23      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
00420f24      fsbase->NtTib.ExceptionList = &ExceptionList;
00420f31      int32_t __saved_edi;
00420f31      int32_t* var_1c = &__saved_edi;
00420f31      
00420f3c      if (data_430a3c)
00420f3c          goto label_420f87;
00420f3c      
00420f58      int32_t result;
00420f58      
00420f58      if (!LCMapStringW(0, 0x100, &data_429368, 1, nullptr, 0))
00420f58      {
00420f74          if (LCMapStringA(0, 0x100, &data_429364, 1, nullptr, 0))
00420f74          {
00420f7a              data_430a3c = 2;
00420f7a              goto label_420f87;
00420f74          }
00420f74          
0042109c          result = 0;
00420f58      }
00420f58      else
00420f58      {
00420f5a          data_430a3c = 1;
00420f87      label_420f87:
00420f87          
00420f87          if (arg4 > 0)
00420f96              arg4 = sub_421132(arg3, arg4);
00420f96          
00420f99          int32_t eax_4 = data_430a3c;
00420f99          
00420fa1          if (eax_4 == 2)
00420fb5              result = LCMapStringA(arg1, arg2, arg3, arg4, arg5, arg6);
00420fa1          else if (eax_4 != 1)
0042109c              result = 0;
00420fc3          else
00420fc3          {
00420fcc              if (!arg7)
00420fd3                  arg7 = data_430a24;
00420fd3              
00420fe1              int32_t eax_7 = -(arg8);
00420fed              int32_t eax_11 = MultiByteToWideChar(arg7, ((eax_7 - eax_7) & 8) + 1, arg3, 
00420fed                  arg4, nullptr, 0);
00420fed              
00420ffa              if (!eax_11)
0042109c                  result = 0;
00420ffa              else
00420ffa              {
00421000                  int32_t var_8_1 = 0;
00421009                  int32_t eax_13;
00421009                  (uint8_t)eax_13 = (eax_11 * 2 + 3) & 0xfc;
0042100b                  sub_425610(eax_13);
00421010                  int32_t* var_1c_1 = &__saved_edi;
00421015                  int32_t* var_28_1 = &__saved_edi;
00421018                  int32_t var_8_2 = 0xffffffff;
00421018                  
00421034                  if (!var_28_1)
0042109c                      result = 0;
00421034                  else if (!MultiByteToWideChar(arg7, MB_PRECOMPOSED, arg3, arg4, var_28_1, 
00421034                          eax_11))
0042109c                      result = 0;
0042104d                  else
0042104d                  {
00421061                      int32_t result_1 =
00421061                          LCMapStringW(arg1, arg2, var_28_1, eax_11, nullptr, 0);
00421063                      int32_t result_2 = result_1;
00421063                      
00421068                      if (!result_1)
0042109c                          result = 0;
00421068                      else if (!(*(uint8_t*)((char*)arg2)[1] & 4))
0042106e                      {
004210b0                          int32_t var_8_3 = 1;
004210bd                          int32_t eax_18;
004210bd                          (uint8_t)eax_18 = (result_1 * 2 + 3) & 0xfc;
004210bf                          sub_425610(eax_18);
004210c4                          int32_t* var_1c_2 = &__saved_edi;
004210c9                          int32_t* var_24_1 = &__saved_edi;
004210cc                          int32_t var_8_4 = 0xffffffff;
004210cc                          
004210e6                          if (!&__saved_edi)
0042109c                              result = 0;
004210e6                          else if (!LCMapStringW(arg1, arg2, var_28_1, eax_11, 
004210e6                                  &__saved_edi, result_1))
0042109c                              result = 0;
004210fe                          else
004210fe                          {
00421105                              PSTR lpMultiByteStr;
00421105                              int32_t cbMultiByte;
00421105                              
00421105                              if (arg6)
00421105                              {
0042110b                                  cbMultiByte = arg6;
0042110e                                  lpMultiByteStr = arg5;
00421105                              }
00421105                              else
00421105                              {
00421107                                  cbMultiByte = 0;
00421108                                  lpMultiByteStr = nullptr;
00421105                              }
00421105                              
00421121                              result_1 = WideCharToMultiByte(arg7, 0x220, &__saved_edi, 
00421121                                  result_1, lpMultiByteStr, cbMultiByte, nullptr, nullptr);
00421121                              
00421125                              result = !result_1 ? 0 : result_1;
004210fe                          }
0042106e                      }
0042106e                      else if (!arg6)
0042112b                          result = result_1;
00421073                      else if (result_1 > arg6)
0042109c                          result = 0;
0042107c                      else if (LCMapStringW(arg1, arg2, var_28_1, eax_11, arg5, arg6))
0042112b                          result = result_1;
00421096                      else
0042109c                          result = 0;
0042104d                  }
00420ffa              }
00420fc3          }
00420f58      }
00420f58      
004210a4      fsbase->NtTib.ExceptionList = ExceptionList;
004210af      return result;
00420f0e  }


0042101e    int32_t sub_42101e() __pure

0042101e  {
00421021      return 1;
0042101e  }

00421022        8b 65 e8 33 ff 89 7d dc 83 4d fc ff 8b 5d e4                                                 .e.3..}..M...].

004210d2    int32_t sub_4210d2() __pure

004210d2  {
004210d5      return 1;
004210d2  }

004210d6                                                                    8b 65 e8 33 ff 33 db 83 4d fc                        .e.3.3..M.
004210e0  ff 8b 75 d8                                                                                      ..u.

00421132    void* sub_421132(char* arg1, int32_t arg2)

00421132  {
00421136      char* eax = arg1;
0042113d      int32_t ecx = arg2 - 1;
0042113d      
00421140      if (arg2)
00421140      {
00421145          while (*(uint8_t*)eax)
00421145          {
00421147              eax = &eax[1];
00421148              int32_t esi_1 = ecx;
0042114a              ecx -= 1;
0042114a              
0042114d              if (!esi_1)
0042114d                  break;
00421145          }
00421140      }
00421140      
00421153      if (*(uint8_t*)eax)
0042115c          return arg2;
0042115c      
00421159      return eax - arg1;
00421132  }


0042115d    char* sub_42115d(int32_t arg1, char* arg2, int32_t* arg3, int32_t* arg4)

0042115d  {
00421160      int32_t ecx;
00421160      int32_t var_8 = ecx;
00421161      int32_t var_c = ecx;
00421170      char* result_1 = sub_4212c0(arg1, arg2, arg3, arg4);
0042117b      char* result = result_1;
0042117b      
0042118b      if (result_1 == 0xffffffff && data_4307d4 == 2 && !sub_425dea(arg2, 0x2f))
0042118b      {
004211aa          void* eax_1 = sub_418fca("PATH");
004211aa          
004211b4          if (eax_1)
004211b4          {
004211bf              void* eax_2 = sub_41dbac(0x104);
004211bf              
004211c9              if (eax_2)
004211c9              {
004211d5                  int32_t var_1c_2 = 0x103;
004211d6                  void* var_20_1 = eax_2;
004211d7                  void* var_24_1 = eax_1;
004211d8                  void* ecx_7;
004211d8                  
004211d8                  while (true)
004211d8                  {
004211d8                      void* eax_3;
004211d8                      eax_3 = sub_425d76(var_24_1, var_20_1, 0x103);
004211d8                      
004211e5                      if (!eax_3)
004211e5                          break;
004211e5                      
004211ee                      if (!*(uint8_t*)eax_2)
004211ee                          break;
004211ee                      
004211fa                      void* edi_2 = sub_41e7d0(eax_2) + eax_2 - 1;
004211ff                      void* eax_4;
004211ff                      (uint8_t)eax_4 = *(uint8_t*)edi_2;
00421203                      bool cond:3_1;
00421203                      
00421203                      if ((uint8_t)eax_4 != 0x5c)
00421213                          cond:3_1 = (uint8_t)eax_4 == 0x2f;
00421203                      else
0042120e                          cond:3_1 = edi_2 == sub_421893(eax_2, 0x5c);
0042120e                      
00421215                      if (!cond:3_1)
0042121d                          sub_41b8d0(eax_2, U"\;");
0042121d                      
0042123d                      ecx_7 = eax_2;
0042123d                      
0042123e                      if (sub_41e7d0(eax_2) + sub_41e7d0(arg2) >= 0x104)
0042123e                          break;
0042123e                      
00421244                      sub_41b8d0(eax_2, arg2);
00421253                      char* result_2;
00421253                      result_2 = sub_4212c0(arg1, eax_2, arg3, arg4);
0042125e                      result = result_2;
0042125e                      
00421261                      if (result_2 != 0xffffffff)
00421261                          break;
00421261                      
0042126a                      if (data_4307d4 != 2)
0042126a                      {
00421278                          if (eax_2 != sub_425dea(eax_2, 0x5c))
00421278                          {
00421285                              ecx_7 = 0x2f;
00421285                              
00421286                              if (eax_2 != sub_425dea(eax_2, 0x2f))
00421286                                  break;
00421278                          }
00421278                          
00421297                          if ((char*)eax_2 + 1 != sub_425dea((char*)eax_2 + 1, 0x5c))
00421297                          {
004212a4                              ecx_7 = 0x2f;
004212a4                              
004212a5                              if ((char*)eax_2 + 1 != sub_425dea((char*)eax_2 + 1, 0x2f))
004212a5                                  break;
00421297                          }
0042126a                      }
0042126a                      
004212a7                      int32_t var_1c_6 = 0x103;
004212a8                      var_20_1 = eax_2;
004212a9                      var_24_1 = eax_3;
004211d8                  }
004211d8                  
004212b1                  void* var_1c_7 = eax_2;
004212b2                  sub_41784c(ecx_7);
004211c9              }
004211b4          }
0042118b      }
0042118b      
004212bf      return result;
0042115d  }


004212c0    char* sub_4212c0(int32_t arg1, char* arg2, int32_t* arg3, int32_t* arg4)

004212c0  {
004212c3      int32_t ecx;
004212c3      int32_t var_8 = ecx;
004212c4      int32_t var_c = ecx;
004212c6      char* ebx = arg2;
004212ce      void* edi = ebx;
004212d8      char* esi = sub_421893(ebx, 0x5c);
004212da      char* eax_1 = sub_421893(ebx, 0x2f);
004212da      
004212e4      if (eax_1)
004212e4      {
00421331          if (!esi || eax_1 > esi)
00421333              esi = eax_1;
00421333          
00421331          goto label_421335;
004212e4      }
004212e4      
004212e8      if (esi)
004212e8          goto label_421335;
004212e8      
004212f2      esi = sub_425dea(ebx, 0x3a);
004212f2      
004212f8      if (esi)
004212f8          goto label_421335;
004212f8      
00421309      edi = sub_41dbac(sub_41e7d0(ebx) + 3);
00421309      
0042130f      if (edi)
0042130f      {
00421317          sub_41b8c0(edi, ".\");
0042131e          sub_41b8d0(edi, ebx);
00421326          esi = (char*)edi + 2;
00421335      label_421335:
00421335          char* result = 0xffffffff;
00421345          void** ecx_4;
00421345          
00421345          if (sub_421893(esi, 0x2e))
00421345          {
00421353              ecx_4 = nullptr;
00421353              
00421354              if (sub_42145a(edi, 0) != 0xffffffff)
00421354              {
00421364                  char* result_1;
00421364                  result_1 = sub_421409(arg1, edi, arg3, arg4);
0042136c                  result = result_1;
00421354              }
00421354              
00421354              goto label_4213f8;
00421345          }
00421345          
00421383          void** ebx_1 = sub_41dbac(sub_41e7d0(edi) + 5);
00421383          
0042138c          if (ebx_1)
0042138c          {
00421395              sub_41b8c0(ebx_1, edi);
004213a5              void* esi_2 = sub_41e7d0(edi) + ebx_1;
004213cf              void** ecx_6;
004213cf              
004213cf              for (char const (** i)[0x5] = &data_42f96c; i >= &data_42f960; i -= 4)
004213cf              {
004213af                  sub_41b8c0(esi_2, *(uint32_t*)i);
004213b9                  int32_t eax_12;
004213b9                  eax_12 = sub_42145a(ebx_1, 0);
004213b9                  
004213c4                  if (eax_12 != 0xffffffff)
004213c4                  {
004213df                      char* result_2;
004213df                      result_2 = sub_421409(arg1, ebx_1, arg3, arg4);
004213e7                      result = result_2;
004213e7                      break;
004213c4                  }
004213cf              }
004213cf              
004213ed              sub_41784c(ecx_6);
004213f2              ebx = arg2;
004213f5              ecx_4 = ebx_1;
004213f8          label_4213f8:
004213f8              
004213f8              if (edi != ebx)
004213f8              {
004213fa                  void* var_1c_8 = edi;
004213fb                  sub_41784c(ecx_4);
004213f8              }
004213f8              
00421401              return result;
0042138c          }
0042130f      }
0042130f      
0042138e      return 0xffffffff;
004212c0  }


00421409    char* sub_421409(int32_t arg1, PSTR arg2, int32_t* arg3, int32_t* arg4)

00421409  {
0042140c      PSTR __saved_esi = arg2;
0042141d      int32_t eax = sub_42603c(arg3, arg4, &arg4, &arg3);
0042141d      
00421428      if (eax == 0xffffffff)
0042142d          return eax;
0042142d      
0042142f      int32_t* var_c_1 = arg3;
0042143b      char* eax_2;
0042143b      void** ecx;
0042143b      eax_2 = sub_425e5d(arg1, arg2, arg4);
00421440      int32_t* var_1c = arg4;
00421445      void** ecx_1 = sub_41784c(ecx);
0042144a      int32_t* var_20 = arg3;
0042144d      sub_41784c(ecx_1);
00421459      return eax_2;
00421409  }


0042145a    int32_t sub_42145a(PSTR arg1, char arg2)

0042145a  {
0042145e      uint32_t eax = GetFileAttributesA(arg1);
0042145e      
00421467      if (eax != 0xffffffff)
00421467      {
00421483          if (!((uint8_t)eax & 1) || !(arg2 & 2))
0042149d              return 0;
0042149d          
00421485          data_4307d4 = 0xd;
0042148f          data_4307d8 = 5;
00421467      }
00421467      else
00421470          sub_42149e(GetLastError());
00421470      
00421479      return 0xffffffff;
0042145a  }


0042149e    void* sub_42149e(int32_t arg1)

0042149e  {
004214a2      int32_t edx = 0;
004214a4      data_4307d8 = arg1;
004214bc      void* i;
004214bc      
004214bc      for (i = &data_42f970; i < 0x42fad8; )
004214bc      {
004214b1          if (arg1 == *(uint32_t*)i)
004214b1          {
004214d3              int32_t eax = *(uint32_t*)((edx << 3) + &data_42f974);
004214da              data_4307d4 = eax;
004214df              return eax;
004214b1          }
004214b1          
004214b3          i += 8;
004214b6          edx += 1;
004214bc      }
004214bc      
004214c6      if (arg1 >= 0x13 && arg1 <= 0x24)
004214c6      {
004214c8          data_4307d4 = 0xd;
004214d2          return i;
004214c6      }
004214c6      
004214e6      if (arg1 < 0xbc)
004214fa          data_4307d4 = 0x16;
004214e6      else
004214e6      {
004214ee          data_4307d4 = 8;
004214ee          
004214f8          if (arg1 > 0xca)
004214fa              data_4307d4 = 0x16;
004214e6      }
004214e6      
00421504      return i;
0042149e  }


00421505    char* sub_421505(char* arg1)

00421505  {
0042150c      if (arg1)
0042150c      {
00421516          void* eax_3 = sub_41dbac(sub_41e7d0(arg1) + 1);
00421516          
0042151f          if (eax_3)
0042152b              return sub_41b8c0(eax_3, arg1);
0042150c      }
0042150c      
0042152f      return 0;
00421505  }


00421530    int32_t sub_421530(PSTR arg1, int32_t arg2, char arg3)

00421530  {
00421541      SECURITY_ATTRIBUTES securityAttributes;
00421541      securityAttributes.nLength = 0xc;
00421548      securityAttributes.lpSecurityDescriptor = 0;
0042154b      char var_5;
0042154b      
0042154b      if (!((uint8_t)arg2 & 0x80))
0042154b      {
00421556          var_5 = 0;
0042155a          securityAttributes.bInheritHandle = 1;
0042154b      }
0042154b      else
0042154b      {
0042154d          securityAttributes.bInheritHandle = 0;
00421550          var_5 = 0x10;
0042154b      }
0042154b      
00421575      if (!(0x8000 & arg2) && (*(uint8_t*)((char*)arg2)[1] & 0x40 || data_430ba8 != 0x8000))
00421577          var_5 |= 0x80;
00421577      
00421580      int32_t eax_1 = arg2 & 3;
00421584      uint32_t dwDesiredAccess;
00421584      
00421584      if (!eax_1)
00421584      {
004215b3          dwDesiredAccess = 0x80000000;
004215ba      label_4215ba:
004215ba          int32_t arg_c;
004215ba          int32_t eax_4 = arg_c;
004215c0          enum FILE_SHARE_MODE dwShareMode;
004215c0          
004215c0          if (eax_4 == 0x10)
004215c0          {
004215e8              dwShareMode = FILE_SHARE_NONE;
004215f5          label_4215f5:
004215f5              int32_t ecx_1 = arg2 & 0x700;
004215fe              enum FILE_CREATION_DISPOSITION dwCreationDisposition;
004215fe              
004215fe              if (ecx_1 <= 0x400)
004215fe              {
00421604                  if (ecx_1 == 0x400 || !ecx_1)
00421604                  {
00421630                      dwCreationDisposition = OPEN_EXISTING;
00421633                      goto label_421661;
00421604                  }
00421604                  
00421608                  if (ecx_1 == 0x100)
00421608                  {
00421627                      dwCreationDisposition = OPEN_ALWAYS;
0042162e                      goto label_421661;
00421608                  }
00421608                  
00421610                  if (ecx_1 == 0x200)
00421610                      goto label_42164e;
00421610                  
00421618                  if (ecx_1 == 0x300)
00421618                  {
0042161e                      dwCreationDisposition = CREATE_ALWAYS;
00421625                      goto label_421661;
00421618                  }
00421618                  
0042158c                  data_4307d4 = 0x16;
00421596                  data_4307d8 = 0;
004215fe              }
004215fe              else if (ecx_1 == 0x500)
0042163b              {
00421657              label_421657:
00421657                  dwCreationDisposition = CREATE_NEW;
00421661              label_421661:
00421661                  enum FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes =
00421661                      FILE_ATTRIBUTE_NORMAL;
00421661                  
00421678                  if (0x100 & arg2 && !((char)~data_4307dc & arg3 & 0x80))
0042167c                      dwFlagsAndAttributes = FILE_ATTRIBUTE_READONLY;
0042167c                  
0042167f                  if ((uint8_t)arg2 & 0x40)
0042167f                  {
00421681                      dwFlagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;
00421687                      *(uint8_t*)((char*)dwDesiredAccess)[2] |= 1;
0042167f                  }
0042167f                  
0042168e                  if (*(uint8_t*)((char*)arg2)[1] & 0x10)
00421690                      dwFlagsAndAttributes |= FILE_ATTRIBUTE_TEMPORARY;
00421690                  
00421694                  if ((uint8_t)arg2 & 0x20)
00421696                      dwFlagsAndAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;
00421694                  else if ((uint8_t)arg2 & 0x10)
004216a2                      dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;
004216a2                  
004216a8                  int32_t result = sub_423782();
004216a8                  
004216b4                  if (result == 0xffffffff)
004216b4                  {
004216b6                      data_4307d8 = 0;
004216bd                      data_4307d4 = 0x18;
00421707                      return 0xffffffff;
004216b4                  }
004216b4                  
004216dc                  HANDLE eax_6 = CreateFileA(arg1, dwDesiredAccess, dwShareMode, 
004216dc                      &securityAttributes, dwCreationDisposition, dwFlagsAndAttributes, 
004216dc                      nullptr);
004216dc                  
004216e6                  if (eax_6 == 0xffffffff)
004216e6                  {
00421701                      sub_42149e(GetLastError());
00421707                      return 0xffffffff;
004216e6                  }
004216e6                  
004216e9                  enum FILE_TYPE eax_7 = GetFileType(eax_6);
004216e9                  
004216f1                  if (!eax_7)
004216f1                  {
004216f4                      CloseHandle(eax_6);
00421701                      sub_42149e(GetLastError());
00421707                      return 0xffffffff;
004216f1                  }
004216f1                  
00421711                  if (eax_7 == FILE_TYPE_CHAR)
00421713                      var_5 |= 0x40;
00421711                  else if (eax_7 == FILE_TYPE_PIPE)
0042171e                      var_5 |= 8;
0042171e                  
00421724                  sub_423817(result, eax_6);
00421732                  char eax_9 = var_5 | 1;
0042173a                  *(uint8_t*)((char*)arg1)[3] = eax_9;
00421744                  int32_t esi_4 = (result & 0x1f) << 3;
00421749                  char temp3_1 = *(uint8_t*)((char*)arg1)[3] & 0x48;
00421749                  *(uint8_t*)((char*)arg1)[3] = temp3_1;
0042174d                  *(uint8_t*)((&data_430e20)[result >> 5] + esi_4 + 4) = eax_9;
0042174d                  
0042175b                  if (temp3_1 || !(eax_9 & 0x80) || !((uint8_t)arg2 & 2))
0042175b                  {
004217d5                  label_4217d5:
004217d5                      
004217d5                      if (!*(uint8_t*)((char*)arg1)[3] && (uint8_t)arg2 & 8)
004217d5                      {
004217d7                          int32_t eax_14 = (&data_430e20)[result >> 5];
004217d9                          *(uint8_t*)(eax_14 + esi_4 + 4) |= 0x20;
004217d5                      }
004217d5                      
004217e2                      return result;
0042175b                  }
0042175b                  
00421762                  int32_t eax_10 = sub_41b825(result, 0xffffffff, FILE_END);
00421762                  
00421770                  if (eax_10 != 0xffffffff)
00421770                  {
00421780                      *(uint8_t*)((char*)arg_c)[3] = 0;
00421780                      
0042179b                      if (sub_41b2f9(result, &*(uint32_t*)((char*)arg_c)[3], 1)
0042179b                          || *(uint8_t*)((char*)arg_c)[3] != 0x1a)
0042179b                      {
004217b2                      label_4217b2:
004217b2                          
004217bd                          if (sub_41b825(result, 0, FILE_BEGIN) != 0xffffffff)
004217bd                              goto label_4217d5;
004217bd                          
004217c0                          sub_41b21b(result);
0042179b                      }
0042179b                      else
0042179b                      {
004217ab                          if (sub_426240(result, eax_10) != 0xffffffff)
004217ab                              goto label_4217b2;
004217ab                          
004217c0                          sub_41b21b(result);
0042179b                      }
00421770                  }
00421770                  else
00421770                  {
0042177c                      if (data_4307d8 == 0x83)
0042177c                          goto label_4217d5;
0042177c                      
004217c0                      sub_41b21b(result);
00421770                  }
0042163b              }
0042163b              else
0042163b              {
00421643                  if (ecx_1 == 0x600)
00421643                  {
0042164e                  label_42164e:
0042164e                      dwCreationDisposition = TRUNCATE_EXISTING;
00421655                      goto label_421661;
00421643                  }
00421643                  
00421647                  if (ecx_1 == 0x700)
00421647                      goto label_421657;
00421647                  
0042158c                  data_4307d4 = 0x16;
00421596                  data_4307d8 = 0;
0042163b              }
004215c0          }
004215c0          else
004215c0          {
004215c5              if (eax_4 == 0x20)
004215c5              {
004215df                  dwShareMode = FILE_SHARE_READ;
004215e6                  goto label_4215f5;
004215c5              }
004215c5              
004215ca              if (eax_4 == 0x30)
004215ca              {
004215d6                  dwShareMode = FILE_SHARE_WRITE;
004215dd                  goto label_4215f5;
004215ca              }
004215ca              
004215cf              if (eax_4 == 0x40)
004215cf              {
004215d1                  dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
004215d4                  goto label_4215f5;
004215cf              }
004215cf              
0042158c              data_4307d4 = 0x16;
00421596              data_4307d8 = 0;
004215c0          }
00421584      }
00421584      else
00421584      {
00421587          if (eax_1 == 1)
00421587          {
004215aa              dwDesiredAccess = 0x40000000;
004215b1              goto label_4215ba;
00421587          }
00421587          
0042158a          if (eax_1 == 2)
0042158a          {
004215a1              dwDesiredAccess = 0xc0000000;
004215a8              goto label_4215ba;
0042158a          }
0042158a          
0042158c          data_4307d4 = 0x16;
00421596          data_4307d8 = 0;
00421584      }
004217c6      return 0xffffffff;
00421530  }


004217e9    char* sub_4217e9(int32_t arg1, char* arg2, int32_t arg3)

004217e9  {
004217f6      int32_t var_c;
004217f6      int32_t var_8;
004217f6      
004217f6      if (arg3 != 0xa || arg1 >= 0)
004217f6      {
004217fe          var_8 = 0;
00421800          var_c = arg3;
004217f6      }
004217f6      else
004217f6      {
004217f8          var_8 = 1;
004217fa          var_c = 0xa;
004217f6      }
004217f6      
00421809      sub_421816(arg1, arg2, var_c, var_8);
00421815      return arg2;
004217e9  }


00421816    uint32_t sub_421816(int32_t arg1, char* arg2, int32_t arg3, int32_t arg4)

00421816  {
0042181d      char* ecx = arg2;
00421823      int32_t i;
00421823      
00421823      if (!arg4)
00421830          i = arg1;
00421823      else
00421823      {
00421828          *(uint8_t*)ecx = 0x2d;
0042182b          ecx = &ecx[1];
0042182c          i = -(arg1);
00421823      }
00421823      
00421833      char* edi = ecx;
00421833      
00421859      do
00421859      {
00421839          uint32_t temp1_1 = COMBINE(0, i) % arg3;
00421848          i = COMBINE(0, i) / arg3;
0042184a          uint32_t ebx_1;
0042184a          
0042184a          if (temp1_1 <= 9)
00421851              (uint8_t)ebx_1 = (uint8_t)temp1_1 + 0x30;
0042184a          else
0042184c              (uint8_t)ebx_1 = (uint8_t)temp1_1 + 0x57;
0042184c          
00421854          *(uint8_t*)ecx = (uint8_t)ebx_1;
00421856          ecx = &ecx[1];
00421859      } while (i > 0);
00421859      
0042185b      *(uint8_t*)ecx = 0;
0042185e      void* ecx_1 = ecx - 1;
0042186b      uint32_t result;
0042186b      
0042186b      do
0042186b      {
00421861          (uint8_t)result = *(uint8_t*)ecx_1;
00421863          *(uint8_t*)ecx_1 = *(uint8_t*)edi;
00421865          *(uint8_t*)edi = (uint8_t)result;
00421867          ecx_1 -= 1;
00421868          edi = &edi[1];
0042186b      } while (edi < ecx_1);
0042186b      
00421871      return result;
00421816  }


00421872    char* sub_421872(int32_t arg1, char* arg2, int32_t arg3)

00421872  {
00421880      sub_421816(arg1, arg2, arg3, 0);
0042188c      return arg2;
00421872  }


0042188d    uint32_t __stdcall GetCurrentProcessId()

0042188d  {
0042188d      /* tailcall */
0042188d      return GetCurrentProcessId();
0042188d  }


00421893    char* sub_421893(char* arg1, int32_t arg2)

00421893  {
00421896      void* result = nullptr;
00421896      
0042189e      if (!data_430bdc)
004218ae          return sub_41ad40(arg1, (uint8_t)arg2);
004218ae      
004218af      char* result_1 = arg1;
004218b2      int32_t ebx;
004218b2      int32_t var_8_1 = ebx;
004218b2      
004218ed      do
004218ed      {
004218b4          (uint8_t)ebx = *(uint8_t*)result_1;
004218b6          uint32_t ecx_2 = (uint32_t)(uint8_t)ebx;
004218c3          bool cond:0_1;
004218c3          
004218c3          if (!(*(uint8_t*)((uint32_t)(uint8_t)ecx_2 + 0x430ce1) & 4))
004218c3          {
004218e3              cond:0_1 = arg2 != ecx_2;
004218e6          label_4218e6:
004218e6              
004218e6              if (!cond:0_1)
004218e8                  result = result_1;
004218c3          }
004218c3          else
004218c3          {
004218c5              (uint8_t)ebx = result_1[1];
004218c8              result_1 = &result_1[1];
004218c8              
004218cb              if (!(uint8_t)ebx)
004218cb              {
004218df                  cond:0_1 = result;
004218e1                  goto label_4218e6;
004218cb              }
004218cb              
004218d8              if (arg2 == (ecx_2 << 8 | (uint32_t)(uint8_t)ebx))
004218da                  result = &result_1[0xffffffff];
004218c3          }
004218ea          result_1 = &result_1[1];
004218ed      } while ((uint8_t)ebx);
004218ed      
004218f2      return result;
00421893  }


004218f3    int32_t sub_4218f3()

004218f3  {
004218f5      int32_t i = 0;
004218f7      int32_t result = 0;
004218f7      
004218ff      if (data_431f40 > 0)
004218ff      {
00421928          do
00421928          {
00421906              int32_t* eax_2 = *(uint32_t*)(data_430f2c + (i << 2));
00421906              
00421917              if (eax_2 && eax_2[3] & 0x83 && eax_2[7])
00421917              {
0042191a                  sub_416e00(eax_2);
00421920                  result += 1;
00421917              }
00421917              
00421921              i += 1;
00421928          } while (i < data_431f40);
004218ff      }
004218ff      
0042192e      return result;
004218f3  }


0042192f    int32_t sub_42192f(char* arg1, uint8_t* arg2, void* arg3)

0042192f  {
00421936      if (!arg3)
0042193b          return 0;
0042193b      
00421956      enum COMPARESTRING_RESULT eax_1 =
00421956          sub_41e960(data_430de4, 1, arg1, arg3, arg2, arg3, data_430bc0);
00421956      
00421960      if (eax_1)
0042196d          return eax_1 - 2;
0042196d      
00421968      return 0x7fffffff;
0042192f  }


0042196e    int32_t sub_42196e()

0042196e  {
0042196e      void* ecx;
0042196e      void* var_4 = ecx;
00421972      int32_t* esi = data_430804;
0042197b      wchar16* lpWideCharStr = *(uint32_t*)esi;
0042197b      
0042197f      while (lpWideCharStr)
0042197f      {
00421991          int32_t cbMultiByte = WideCharToMultiByte(1, 0, lpWideCharStr, 0xffffffff, 
00421991              nullptr, 0, nullptr, nullptr);
00421991          
00421997          if (!cbMultiByte)
004219d7              return 0xffffffff;
004219d7          
0042199a          void* lpMultiByteStr = sub_41dbac(cbMultiByte);
0042199a          
004219a6          if (!lpMultiByteStr)
004219d7              return 0xffffffff;
004219d7          
004219b7          if (!WideCharToMultiByte(1, 0, *(uint32_t*)esi, 0xffffffff, lpMultiByteStr, 
004219b7                  cbMultiByte, nullptr, nullptr))
004219d7              return 0xffffffff;
004219d7          
004219be          sub_426386(lpMultiByteStr, 0);
004219c3          lpWideCharStr = esi[1];
004219c6          esi = &esi[1];
0042197f      }
0042197f      
004219cf      return 0;
0042196e  }

004219dc                                                                                      cc cc cc cc                              ....

004219e0    uint32_t __stdcall __aulldiv(int32_t arg1, uint32_t arg2, int32_t arg3, uint32_t arg4) __pure

004219e0  {
004219e8      if (!arg4)
00421a45          return COMBINE(COMBINE(0, arg2) % arg3, arg1) / arg3;
00421a45      
00421a02      uint32_t i = arg4;
00421a04      int32_t ebx_1 = arg3;
00421a08      uint32_t edx_3 = arg2;
00421a0c      int32_t eax_6 = arg1;
00421a0c      
00421a1a      do
00421a1a      {
00421a12          ebx_1 = RRCD(ebx_1, 1, i & 1);
00421a14          uint32_t temp4_1 = edx_3;
00421a14          edx_3 u>>= 1;
00421a16          eax_6 = RRCD(eax_6, 1, temp4_1 & 1);
00421a18          i u>>= 1;
00421a1a      } while (i);
00421a1a      
00421a1c      uint32_t result = COMBINE(edx_3, eax_6) / ebx_1;
00421a20      int32_t eax_8 = result * arg4;
00421a2a      int32_t eax_10;
00421a2a      int32_t edx_4;
00421a2a      edx_4 = HIGHD(arg3 * result);
00421a2a      eax_10 = LOWD(arg3 * result);
00421a2c      int32_t edx_5 = edx_4 + eax_8;
00421a2c      
00421a3c      if (edx_4 + eax_8 >= edx_4 && edx_5 <= arg2 && (edx_5 < arg2 || eax_10 <= arg1))
00421a41          return result;
00421a41      
00421a3e      return result - 1;
004219e0  }

00421a48                          cc cc cc cc cc cc cc cc                                                          ........

00421a50    int32_t __stdcall __allmul(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) __pure

00421a50  {
00421a5e      if (!(arg4 | arg2))
00421a66          return arg1 * arg3;
00421a66      
00421a7c      int32_t result;
00421a7c      int32_t edx;
00421a7c      edx = HIGHD(arg1 * arg3);
00421a7c      result = LOWD(arg1 * arg3);
00421a81      return result;
00421a50  }


00421a84    void sub_421a84()

00421a84  {
00421a8b      if (!data_430b00)
00421a8b      {
00421a8d          BOOL ecx;
00421a8d          sub_421a99(ecx);
00421a92          data_430b00 += 1;
00421a8b      }
00421a84  }


00421a99    void* __fastcall sub_421a99(BOOL arg1)

00421a99  {
00421a99      BOOL usedDefaultChar = arg1;
00421aa8      int32_t edi = 0;
00421aaa      data_430a48 = 0;
00421ab0      data_42fb88 = 0xffffffff;
00421ab6      data_42fb78 = 0xffffffff;
00421abc      void* result = sub_418fca(&data_4294c4);
00421ac1      void* result_1 = result;
00421ac3      void* const ecx = &data_4294c4;
00421ac3      
00421ac6      if (!result_1)
00421ac6      {
00421ad1          result = GetTimeZoneInformation(&data_430a50);
00421ad1          
00421ad9          if (result != 0xffffffff)
00421ad9          {
00421ae4              int32_t ecx_1 = data_430aa4;
00421aea              int32_t eax_1 = data_430a50 * 0x3c;
00421aed              bool cond:0_1 = !data_430a96;
00421af7              data_42fae0 = eax_1;
00421afc              data_430a48 = 1;
00421afc              
00421b02              if (!cond:0_1)
00421b0b                  data_42fae0 = eax_1 + ecx_1 * 0x3c;
00421b0b              
00421b17              int32_t eax_3;
00421b17              
00421b17              if (data_430aea)
00421b19                  eax_3 = data_430af8;
00421b19              
00421b20              if (!data_430aea || !eax_3)
00421b20              {
00421b34                  data_42fae4 = 0;
00421b3a                  data_42fae8 = 0;
00421b20              }
00421b20              else
00421b20              {
00421b24                  data_42fae4 = 1;
00421b2d                  data_42fae8 = (eax_3 - ecx_1) * 0x3c;
00421b20              }
00421b20              
00421b70              if (!WideCharToMultiByte(data_430a24, 0x220, &data_430a54, 0xffffffff, 
00421b70                      data_42fb6c, 0x3f, nullptr, &usedDefaultChar) || usedDefaultChar)
00421b82                  **(uint8_t**)&data_42fb6c = 0;
00421b70              else
00421b77                  *(uint8_t*)(data_42fb6c + 0x3f) = 0;
00421b77              
00421bae              if (!WideCharToMultiByte(data_430a24, 0x220, &data_430aa8, 0xffffffff, 
00421bae                  data_42fb70, 0x3f, nullptr, &usedDefaultChar) || usedDefaultChar)
00421bae              {
00421ce9                  result = data_42fb70;
00421cee                  *(uint8_t*)result = 0;
00421bae              }
00421bae              else
00421bae              {
00421bb4                  result = data_42fb70;
00421bb9                  *(uint8_t*)((char*)result + 0x3f) = 0;
00421bae              }
00421ad9          }
00421ac6      }
00421ac6      else if (*(uint8_t*)result_1)
00421bc5      {
00421bcb          void* eax_10 = data_430afc;
00421bcb          
00421bd2          if (eax_10)
00421bd2          {
00421bd6              result = sub_41ebe0(result_1, eax_10);
00421bde              ecx = eax_10;
00421bd2          }
00421bd2          
00421bdf          if (!eax_10 || result)
00421bdf          {
00421be5              int32_t var_18_4 = data_430afc;
00421beb              sub_41784c(ecx);
00421bf8              result = sub_41dbac(sub_41e7d0(result_1) + 1);
00421c02              data_430afc = result;
00421c02              
00421c07              if (result)
00421c07              {
00421c0f                  sub_41b8c0(result, result_1);
00421c1d                  sub_417ef0(data_42fb6c, result_1, 3);
00421c27                  void* esi_2 = (char*)result_1 + 3;
00421c2d                  *(uint8_t*)(data_42fb6c + 3) = 0;
00421c2d                  
00421c34                  if (*(uint8_t*)esi_2 == 0x2d)
00421c34                  {
00421c38                      esi_2 += 1;
00421c39                      edi = 1;
00421c34                  }
00421c34                  
00421c45                  int32_t ecx_3 = sub_4265cc(esi_2) * 0xe10;
00421c4b                  data_42fae0 = ecx_3;
00421c4b                  
00421c51                  while (true)
00421c51                  {
00421c51                      int32_t eax_14;
00421c51                      (uint8_t)eax_14 = *(uint8_t*)esi_2;
00421c51                      
00421c55                      if ((uint8_t)eax_14 != 0x2b)
00421c55                      {
00421c59                          if ((uint8_t)eax_14 < 0x30)
00421c59                              break;
00421c59                          
00421c5d                          if ((uint8_t)eax_14 > 0x39)
00421c5d                              break;
00421c55                      }
00421c55                      
00421c5f                      esi_2 += 1;
00421c51                  }
00421c51                  
00421c65                  if (*(uint8_t*)esi_2 == 0x3a)
00421c65                  {
00421c67                      esi_2 += 1;
00421c6e                      int32_t eax_16 = sub_4265cc(esi_2) * 0x3c;
00421c78                      ecx_3 = data_42fae0 + eax_16;
00421c7a                      data_42fae0 = ecx_3;
00421c7a                      
00421c80                      while (true)
00421c80                      {
00421c80                          (uint8_t)eax_16 = *(uint8_t*)esi_2;
00421c80                          
00421c84                          if ((uint8_t)eax_16 < 0x30)
00421c84                              break;
00421c84                          
00421c88                          if ((uint8_t)eax_16 > 0x39)
00421c88                              break;
00421c88                          
00421c8a                          esi_2 += 1;
00421c80                      }
00421c80                      
00421c90                      if (*(uint8_t*)esi_2 == 0x3a)
00421c90                      {
00421c92                          esi_2 += 1;
00421c94                          int32_t eax_17 = sub_4265cc(esi_2);
00421ca0                          ecx_3 = data_42fae0 + eax_17;
00421ca2                          data_42fae0 = ecx_3;
00421ca2                          
00421ca8                          while (true)
00421ca8                          {
00421ca8                              (uint8_t)eax_17 = *(uint8_t*)esi_2;
00421ca8                              
00421cac                              if ((uint8_t)eax_17 < 0x30)
00421cac                                  break;
00421cac                              
00421cb0                              if ((uint8_t)eax_17 > 0x39)
00421cb0                                  break;
00421cb0                              
00421cb2                              esi_2 += 1;
00421ca8                          }
00421c90                      }
00421c65                  }
00421c65                  
00421cb7                  if (edi)
00421cbb                      data_42fae0 = -(ecx_3);
00421cbb                  
00421cc1                  int32_t eax_18 = (int32_t)*(uint8_t*)esi_2;
00421cc6                  data_42fae4 = eax_18;
00421cc6                  
00421ccb                  if (!eax_18)
00421ccb                  {
00421ce9                      result = data_42fb70;
00421cee                      *(uint8_t*)result = 0;
00421ccb                  }
00421ccb                  else
00421ccb                  {
00421cd6                      sub_417ef0(data_42fb70, esi_2, 3);
00421cdb                      result = data_42fb70;
00421ce3                      *(uint8_t*)((char*)result + 3) = 0;
00421ccb                  }
00421c07              }
00421bdf          }
00421bc5      }
00421bc5      
00421cf6      return result;
00421a99  }


00421cf7    int32_t sub_421cf7(void* arg1)

00421cf7  {
00421d02      if (data_42fae4)
00421d02      {
00421d12          int32_t eax_1 = *(uint32_t*)((char*)arg1 + 0x14);
00421d12          
00421d23          if (eax_1 != data_42fb78 || eax_1 != data_42fb88)
00421d23          {
00421d2f              if (!data_430a48)
00421d2f              {
00421e0e                  sub_421ea3(1, 1, eax_1, 4, 1, 0, 0, 2, 0, 0, 0);
00421e23                  sub_421ea3(0, 1, *(uint32_t*)((char*)arg1 + 0x14), 0xa, 5, 0, 0, 2, 0, 0, 
00421e23                      0);
00421d2f              }
00421d2f              else
00421d2f              {
00421d5c                  int32_t var_34_1;
00421d5c                  int32_t var_30_1;
00421d5c                  uint32_t var_2c_1;
00421d5c                  uint32_t var_28_1;
00421d5c                  uint32_t var_24_1;
00421d5c                  uint32_t var_20_1;
00421d5c                  
00421d5c                  if (data_430ae8)
00421d5c                  {
00421d82                      var_20_1 = (uint32_t)data_430aee;
00421d83                      var_24_1 = 0;
00421d8b                      var_28_1 = 0;
00421d8c                      var_2c_1 = (uint32_t)data_430aea;
00421d8d                      var_30_1 = eax_1;
00421d8e                      var_34_1 = 0;
00421d5c                  }
00421d5c                  else
00421d5c                  {
00421d65                      var_20_1 = 0;
00421d66                      var_24_1 = (uint32_t)data_430aec;
00421d6e                      var_28_1 = (uint32_t)data_430aee;
00421d76                      var_2c_1 = (uint32_t)data_430aea;
00421d77                      var_30_1 = eax_1;
00421d78                      var_34_1 = 1;
00421d5c                  }
00421d5c                  
00421d90                  sub_421ea3(1, var_34_1, var_30_1, var_2c_1, var_28_1, var_24_1, var_20_1, 
00421d90                      (uint32_t)data_430af0, (uint32_t)data_430af2, (uint32_t)data_430af4, 
00421d90                      (uint32_t)data_430af6);
00421dbf                  int32_t var_34_2;
00421dbf                  int32_t var_30_2;
00421dbf                  uint32_t var_2c_2;
00421dbf                  uint32_t var_28_2;
00421dbf                  uint32_t var_24_2;
00421dbf                  uint32_t var_20_2;
00421dbf                  
00421dbf                  if (data_430a94)
00421dbf                  {
00421df0                      var_20_2 = (uint32_t)data_430a9a;
00421df1                      var_24_2 = 0;
00421df9                      var_28_2 = 0;
00421dfa                      var_2c_2 = (uint32_t)data_430a96;
00421dfb                      var_30_2 = *(uint32_t*)((char*)arg1 + 0x14);
00421dfe                      var_34_2 = 0;
00421dbf                  }
00421dbf                  else
00421dbf                  {
00421dc8                      var_20_2 = 0;
00421dc9                      var_24_2 = (uint32_t)data_430a98;
00421dd1                      var_28_2 = (uint32_t)data_430a9a;
00421dd9                      var_2c_2 = (uint32_t)data_430a96;
00421dda                      var_30_2 = *(uint32_t*)((char*)arg1 + 0x14);
00421ddd                      var_34_2 = 1;
00421dbf                  }
00421dbf                  
00421ddf                  sub_421ea3(0, var_34_2, var_30_2, var_2c_2, var_28_2, var_24_2, var_20_2, 
00421ddf                      (uint32_t)data_430a9c, (uint32_t)data_430a9e, (uint32_t)data_430aa0, 
00421ddf                      (uint32_t)data_430aa2);
00421d2f              }
00421d23          }
00421d23          
00421e2b          int32_t edx_1 = data_42fb7c;
00421e31          int32_t eax_11 = data_42fb8c;
00421e36          int32_t ecx_10 = *(uint32_t*)((char*)arg1 + 0x1c);
00421e36          
00421e3b          if (edx_1 >= eax_11)
00421e3b          {
00421e61              if (ecx_10 < eax_11 || ecx_10 > edx_1)
00421e55                  return 1;
00421e55              
00421e69              if (ecx_10 <= eax_11 || ecx_10 >= edx_1)
00421e69              {
00421e7d              label_421e7d:
00421e7d                  int32_t eax_18 = ((*(uint32_t*)((char*)arg1 + 8) * 0x3c
00421e7d                      + *(uint32_t*)((char*)arg1 + 4)) * 0x3c + *(uint32_t*)arg1) * 0x3e8;
00421e85                  int32_t result;
00421e85                  
00421e85                  if (ecx_10 != edx_1)
00421e9e                      (uint8_t)result = eax_18 < data_42fb90;
00421e85                  else
00421e8f                      (uint8_t)result = eax_18 >= data_42fb80;
00421e8f                  
00421e92                  return result;
00421e69              }
00421e3b          }
00421e3b          else if (ecx_10 >= edx_1 && ecx_10 <= eax_11)
00421e47          {
00421e53              if (ecx_10 <= edx_1 || ecx_10 >= eax_11)
00421e4f                  goto label_421e7d;
00421e4f              
00421e55              return 1;
00421e47          }
00421d02      }
00421d02      
00421d04      return 0;
00421cf7  }


00421ea3    int32_t sub_421ea3(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, int32_t arg9, int32_t arg10, int32_t arg11)

00421ea3  {
00421eaf      int32_t ecx_1;
00421eaf      
00421eaf      if (arg2 != 1)
00421eaf      {
00421f44          int32_t ecx_2;
00421f44          
00421f44          if ((uint8_t)arg3 & 3)
00421f4f              ecx_2 = *(uint32_t*)((arg4 << 2) + &data_42fbd0);
00421f44          else
00421f46              ecx_2 = *(uint32_t*)((arg4 << 2) + &data_42fb9c);
00421f46          
00421f56          ecx_1 = ecx_2 + arg7;
00421eaf      }
00421eaf      else
00421eaf      {
00421ebb          int32_t temp2_1 = arg3 & 3;
00421ec1          int32_t eax_1;
00421ec1          int32_t esi_2;
00421ec1          
00421ec1          if (temp2_1)
00421ec1          {
00421ece              esi_2 = arg4 << 2;
00421ed1              eax_1 = *(uint32_t*)(esi_2 + &data_42fbd0);
00421ec1          }
00421ec1          else
00421ec1          {
00421ec3              esi_2 = arg4 << 2;
00421ec6              eax_1 = *(uint32_t*)(esi_2 + &data_42fb9c);
00421ec1          }
00421ec1          
00421ef8          int32_t temp1_1 =
00421ef8              (int64_t)(arg3 * 0x16d + eax_1 + 1 + ((arg3 - 1) >> 2) - 0x63db) % 7;
00421ef8          
00421f01          ecx_1 = temp1_1 > arg6 ? eax_1 + 1 + arg5 * 7 - temp1_1 + arg6
00421f01              : eax_1 + 1 + arg5 * 7 - temp1_1 + arg6 - 7;
00421f01          
00421f1f          if (arg5 == 5)
00421f1f          {
00421f25              int32_t esi_3;
00421f25              
00421f25              if (temp2_1)
00421f2f                  esi_3 = *(uint32_t*)(esi_2 + &data_42fbd4);
00421f25              else
00421f27                  esi_3 = *(uint32_t*)(esi_2 + &data_42fba0);
00421f27              
00421f37              if (ecx_1 > esi_3)
00421f39                  ecx_1 -= 7;
00421f1f          }
00421eaf      }
00421eaf      
00421f5d      int32_t result;
00421f5d      
00421f5d      if (arg1 != 1)
00421f5d      {
00421f8d          data_42fb8c = ecx_1;
00421fa5          int32_t eax_26 = ((arg8 * 0x3c + arg9) * 0x3c + data_42fae8 + arg10) * 0x3e8;
00421fab          result = eax_26 + arg11;
00421fae          data_42fb90 = result;
00421fae          
00421fb3          if (eax_26 + arg11 < 0)
00421fb3          {
00421fb5              result += 0x5265c00;
00421fbb              data_42fb90 = result;
00421fd3              data_42fb8c = ecx_1 - 1;
00421fb3          }
00421fb3          else if (result >= 0x5265c00)
00421fc9          {
00421fcb              result -= 0x5265c00;
00421fce              data_42fb90 = result;
00421fd3              data_42fb8c = ecx_1 + 1;
00421fc9          }
00421fc9          
00421fd9          data_42fb88 = arg3;
00421f5d      }
00421f5d      else
00421f5d      {
00421f62          data_42fb7c = ecx_1;
00421f6e          data_42fb78 = arg3;
00421f80          result = ((arg8 * 0x3c + arg9) * 0x3c + arg10) * 0x3e8 + arg11;
00421f83          data_42fb80 = result;
00421f5d      }
00421f5d      
00421fe2      return result;
00421ea3  }

00421fe3           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

00421ff0    int32_t __convention("regparm") sub_421ff0(int32_t arg1, int32_t arg2, int32_t arg3, char* arg4, char* arg5)

00421ff0  {
00421ff6      char* esi = arg5;
00421ff6      
00422006      if (data_430a14)
00422006      {
00422043          int32_t result = 0xff;
0042204a          char* edi_2 = arg4;
0042204c          uint32_t eax_1;
0042204c          
0042204c          while (true)
0042204c          {
0042204c              (uint8_t)result = (uint8_t)result;
0042204c              
0042204e              if (!(uint8_t)result)
0042207b                  return result;
0042207b              
00422050              (uint8_t)result = *(uint8_t*)esi;
00422052              esi = &esi[1];
00422053              uint32_t ebx_1;
00422053              (uint8_t)ebx_1 = *(uint8_t*)edi_2;
00422055              edi_2 = &edi_2[1];
00422055              
00422058              if ((uint8_t)result != (uint8_t)ebx_1)
00422058              {
0042205a                  int32_t result_1 = result;
0042205b                  uint32_t var_18_1 = ebx_1;
0042205c                  int32_t ecx;
0042205c                  eax_1 = sub_418a84(arg3);
00422066                  result = sub_418a84(ecx);
00422066                  
00422070                  if ((uint8_t)eax_1 != (uint8_t)result)
00422070                      break;
00422058              }
0042204c          }
0042204c          
00422072          bool c_6 = /* bool c_6 = unimplemented  {sbb eax, eax} */;
00422074          return result - result + 1;
00422006      }
00422006      
00422008      int16_t eax;
00422008      (uint8_t)eax = 0xff;
0042200a      char* edi_1 = arg4;
0042200a      
0042200c      while (true)
0042200c      {
0042200c          (uint8_t)eax = (uint8_t)eax;
0042200c          
0042200e          if (!(uint8_t)eax)
0042200e              break;
0042200e          
00422010          (uint8_t)eax = *(uint8_t*)esi;
00422012          esi = &esi[1];
00422013          *(uint8_t*)((char*)eax)[1] = *(uint8_t*)edi_1;
00422015          edi_1 = &edi_1[1];
00422015          
00422018          if (*(uint8_t*)((char*)eax)[1] != (uint8_t)eax)
00422018          {
0042201a              (uint8_t)eax -= 0x41;
0042201e              (uint8_t)arg3 = (uint8_t)arg3 - (uint8_t)arg3;
00422020              (uint8_t)arg3 &= 0x20;
00422023              (uint8_t)eax += (uint8_t)arg3;
00422025              (uint8_t)eax += 0x41;
00422027              char temp0_1 = (uint8_t)eax;
00422027              (uint8_t)eax = *(uint8_t*)((char*)eax)[1];
00422027              *(uint8_t*)((char*)eax)[1] = temp0_1;
00422029              (uint8_t)eax -= 0x41;
0042202d              (uint8_t)arg3 = (uint8_t)arg3 - (uint8_t)arg3;
0042202f              (uint8_t)arg3 &= 0x20;
00422032              (uint8_t)eax += (uint8_t)arg3;
00422034              (uint8_t)eax += 0x41;
00422034              
00422038              if ((uint8_t)eax != *(uint8_t*)((char*)eax)[1])
00422038              {
0042203a                  (uint8_t)eax = (uint8_t)eax - (uint8_t)eax;
0042203a                  bool c_4 = /* bool c_4 = unimplemented  {sbb al, al} */;
0042203c                  (uint8_t)eax = (uint8_t)eax + 1;
0042203c                  break;
00422038              }
00422018          }
0042200c      }
0042200c      
0042203e      return (int32_t)(uint8_t)eax;
00421ff0  }


0042207c    int32_t sub_42207c(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7)

0042207c  {
0042209b      if (arg1 - 0x76c < 0x46 || arg1 - 0x76c > 0x8a)
00422138          return 0xffffffff;
00422138      
004220ad      int32_t esi_2 = *(uint32_t*)((arg2 << 2) + &data_42fbd0) + arg3;
004220ad      
004220b8      if (!((arg1 - 0x76c) & 3) && arg2 > 2)
004220ba          esi_2 += 1;
004220ba      
004220bb      sub_421a84();
004220d0      int32_t var_c_1 = esi_2;
004220d5      int32_t var_14_1 = arg1 - 0x76c;
004220e3      int32_t var_20_1 = arg4;
004220fd      int32_t var_18_1 = arg2 - 1;
00422102      int32_t result = (
00422102          (arg4 + ((arg1 - 0x76c) * 0x16d + esi_2 + ((arg1 - 0x76d) >> 2)) * 0x18) * 0x3c
00422102          + arg5) * 0x3c + data_42fae0 + arg6 + 0x7c558180;
00422102      
0042210c      if (arg7 != 1)
0042210c      {
0042211b          if (arg7 != 0xffffffff || !data_42fae4)
00422134              return result;
00422134          
0042212c          void var_28;
0042212c          
0042212c          if (!sub_421cf7(&var_28))
00422134              return result;
0042210c      }
0042210c      
0042212e      return result + data_42fae8;
0042207c  }


0042213e    int32_t sub_42213e()

0042213e  {
00422146      if (!data_430a20)
00422146      {
004221a2          int32_t* var_8_4 = data_430b04;
004221a8          data_42d170 = 0x42d178;
004221b2          void** ecx_6 = sub_42251d(var_8_4);
004221b7          int32_t var_c_3 = data_430b04;
004221bd          sub_41784c(ecx_6);
004221c2          data_430b04 = 0;
00422146      }
00422146      else
00422146      {
0042214f          void* eax_1 = sub_41c874(1, 0xac);
0042214f          
0042215a          if (!eax_1)
00422160              return 1;
00422160          
0042216a          if (sub_4221cf(eax_1))
0042216a          {
00422172              void* var_c_1 = eax_1;
00422173              sub_41784c(sub_42251d(eax_1));
00422160              return 1;
0042216a          }
0042216a          
0042217c          int32_t* var_8_3 = data_430b04;
00422182          data_42d170 = eax_1;
00422188          void** ecx_4 = sub_42251d(var_8_3);
0042218d          int32_t var_c_2 = data_430b04;
00422193          sub_41784c(ecx_4);
00422199          data_430b04 = eax_1;
00422146      }
00422146      
004221ce      return 0;
0042213e  }


004221cf    int32_t sub_4221cf(void** arg1)

004221cf  {
004221d2      int32_t ecx;
004221d2      int32_t var_8 = ecx;
004221d3      int32_t var_c = ecx;
004221d4      uint32_t eax = (uint32_t)data_430b3e;
004221db      uint32_t ecx_1 = (uint32_t)data_430b40;
004221db      
004221ee      if (!arg1)
004221f0          return 0xffffffff;
004221f0      
00422240      int32_t edi_4 = sub_426657(1, eax, 0x31, &arg1[1])
00422240          | sub_426657(1, eax, 0x32, &arg1[2]) | sub_426657(1, eax, 0x33, &arg1[3])
00422240          | sub_426657(1, eax, 0x34, &arg1[4]);
00422284      int32_t edi_8 = edi_4 | sub_426657(1, eax, 0x35, &arg1[5])
00422284          | sub_426657(1, eax, 0x36, &arg1[6]) | sub_426657(1, eax, 0x37, arg1)
00422284          | sub_426657(1, eax, 0x2a, &arg1[8]);
004222cb      int32_t edi_12 = edi_8 | sub_426657(1, eax, 0x2b, &arg1[9])
004222cb          | sub_426657(1, eax, 0x2c, &arg1[0xa]) | sub_426657(1, eax, 0x2d, &arg1[0xb])
004222cb          | sub_426657(1, eax, 0x2e, &arg1[0xc]);
00422312      int32_t edi_16 = edi_12 | sub_426657(1, eax, 0x2f, &arg1[0xd])
00422312          | sub_426657(1, eax, 0x30, &arg1[7]) | sub_426657(1, eax, 0x44, &arg1[0xe])
00422312          | sub_426657(1, eax, 0x45, &arg1[0xf]);
00422359      int32_t edi_20 = edi_16 | sub_426657(1, eax, 0x46, &arg1[0x10])
00422359          | sub_426657(1, eax, 0x47, &arg1[0x11]) | sub_426657(1, eax, 0x48, &arg1[0x12])
00422359          | sub_426657(1, eax, 0x49, &arg1[0x13]);
004223a0      int32_t edi_24 = edi_20 | sub_426657(1, eax, 0x4a, &arg1[0x14])
004223a0          | sub_426657(1, eax, 0x4b, &arg1[0x15]) | sub_426657(1, eax, 0x4c, &arg1[0x16])
004223a0          | sub_426657(1, eax, 0x4d, &arg1[0x17]);
004223e7      int32_t edi_28 = edi_24 | sub_426657(1, eax, 0x4e, &arg1[0x18])
004223e7          | sub_426657(1, eax, 0x4f, &arg1[0x19]) | sub_426657(1, eax, 0x38, &arg1[0x1a])
004223e7          | sub_426657(1, eax, 0x39, &arg1[0x1b]);
0042242e      int32_t edi_32 = edi_28 | sub_426657(1, eax, 0x3a, &arg1[0x1c])
0042242e          | sub_426657(1, eax, 0x3b, &arg1[0x1d]) | sub_426657(1, eax, 0x3c, &arg1[0x1e])
0042242e          | sub_426657(1, eax, 0x3d, &arg1[0x1f]);
00422481      int32_t edi_36 = edi_32 | sub_426657(1, eax, 0x3e, &arg1[0x20])
00422481          | sub_426657(1, eax, 0x3f, &arg1[0x21]) | sub_426657(1, eax, 0x40, &arg1[0x22])
00422481          | sub_426657(1, eax, 0x41, &arg1[0x23]);
004224d4      int32_t edi_40 = edi_36 | sub_426657(1, eax, 0x42, &arg1[0x24])
004224d4          | sub_426657(1, eax, 0x43, &arg1[0x25]) | sub_426657(1, eax, 0x28, &arg1[0x26])
004224d4          | sub_426657(1, eax, 0x29, &arg1[0x27]);
00422502      int32_t edi_42 = edi_40 | sub_426657(1, ecx_1, 0x1f, &arg1[0x28])
00422502          | sub_426657(1, ecx_1, 0x20, &arg1[0x29]);
00422516      return sub_426657(1, ecx_1, 0x1003, &arg1[0x2a]) | edi_42;
004221cf  }


0042251d    void sub_42251d(int32_t* arg1)

0042251d  {
00422524      if (!arg1)
00422524          return;
00422524      
0042252a      int32_t var_8_1 = arg1[1];
0042252d      void** ecx;
0042252d      void** ecx_1 = sub_41784c(ecx);
00422532      int32_t var_c_1 = arg1[2];
00422535      void** ecx_2 = sub_41784c(ecx_1);
0042253a      int32_t var_10_1 = arg1[3];
0042253d      void** ecx_3 = sub_41784c(ecx_2);
00422542      int32_t var_14_1 = arg1[4];
00422545      void** ecx_4 = sub_41784c(ecx_3);
0042254a      int32_t var_18_1 = arg1[5];
0042254d      void** ecx_5 = sub_41784c(ecx_4);
00422552      int32_t var_1c_1 = arg1[6];
00422555      void** ecx_6 = sub_41784c(ecx_5);
0042255a      int32_t var_20_1 = *(uint32_t*)arg1;
0042255c      void** ecx_7 = sub_41784c(ecx_6);
00422561      int32_t var_24_1 = arg1[8];
00422564      void** ecx_8 = sub_41784c(ecx_7);
00422569      int32_t var_28_1 = arg1[9];
0042256c      void** ecx_9 = sub_41784c(ecx_8);
00422571      int32_t var_2c_1 = arg1[0xa];
00422574      void** ecx_10 = sub_41784c(ecx_9);
00422579      int32_t var_30_1 = arg1[0xb];
0042257c      void** ecx_11 = sub_41784c(ecx_10);
00422581      int32_t var_34_1 = arg1[0xc];
00422584      void** ecx_12 = sub_41784c(ecx_11);
00422589      int32_t var_38_1 = arg1[0xd];
0042258c      void** ecx_13 = sub_41784c(ecx_12);
00422591      int32_t var_3c_1 = arg1[7];
00422594      void** ecx_14 = sub_41784c(ecx_13);
00422599      int32_t var_40_1 = arg1[0xe];
0042259c      void** ecx_15 = sub_41784c(ecx_14);
004225a1      int32_t var_44_1 = arg1[0xf];
004225a4      void** ecx_16 = sub_41784c(ecx_15);
004225ac      int32_t var_8_2 = arg1[0x10];
004225af      void** ecx_17 = sub_41784c(ecx_16);
004225b4      int32_t var_c_2 = arg1[0x11];
004225b7      void** ecx_18 = sub_41784c(ecx_17);
004225bc      int32_t var_10_2 = arg1[0x12];
004225bf      void** ecx_19 = sub_41784c(ecx_18);
004225c4      int32_t var_14_2 = arg1[0x13];
004225c7      void** ecx_20 = sub_41784c(ecx_19);
004225cc      int32_t var_18_2 = arg1[0x14];
004225cf      void** ecx_21 = sub_41784c(ecx_20);
004225d4      int32_t var_1c_2 = arg1[0x15];
004225d7      void** ecx_22 = sub_41784c(ecx_21);
004225dc      int32_t var_20_2 = arg1[0x16];
004225df      void** ecx_23 = sub_41784c(ecx_22);
004225e4      int32_t var_24_2 = arg1[0x17];
004225e7      void** ecx_24 = sub_41784c(ecx_23);
004225ec      int32_t var_28_2 = arg1[0x18];
004225ef      void** ecx_25 = sub_41784c(ecx_24);
004225f4      int32_t var_2c_2 = arg1[0x19];
004225f7      void** ecx_26 = sub_41784c(ecx_25);
004225fc      int32_t var_30_2 = arg1[0x1a];
004225ff      void** ecx_27 = sub_41784c(ecx_26);
00422604      int32_t var_34_2 = arg1[0x1b];
00422607      void** ecx_28 = sub_41784c(ecx_27);
0042260c      int32_t var_38_2 = arg1[0x1c];
0042260f      void** ecx_29 = sub_41784c(ecx_28);
00422614      int32_t var_3c_2 = arg1[0x1d];
00422617      void** ecx_30 = sub_41784c(ecx_29);
0042261c      int32_t var_40_2 = arg1[0x1e];
0042261f      void** ecx_31 = sub_41784c(ecx_30);
00422624      int32_t var_44_2 = arg1[0x1f];
00422627      void** ecx_32 = sub_41784c(ecx_31);
0042262f      int32_t var_8_3 = arg1[0x20];
00422635      void** ecx_33 = sub_41784c(ecx_32);
0042263a      int32_t var_c_3 = arg1[0x21];
00422640      void** ecx_34 = sub_41784c(ecx_33);
00422645      int32_t var_10_3 = arg1[0x22];
0042264b      void** ecx_35 = sub_41784c(ecx_34);
00422650      int32_t var_14_3 = arg1[0x23];
00422656      void** ecx_36 = sub_41784c(ecx_35);
0042265b      int32_t var_18_3 = arg1[0x24];
00422661      void** ecx_37 = sub_41784c(ecx_36);
00422666      int32_t var_1c_3 = arg1[0x25];
0042266c      void** ecx_38 = sub_41784c(ecx_37);
00422671      int32_t var_20_3 = arg1[0x26];
00422677      void** ecx_39 = sub_41784c(ecx_38);
0042267c      int32_t var_24_3 = arg1[0x27];
00422682      void** ecx_40 = sub_41784c(ecx_39);
00422687      int32_t var_28_3 = arg1[0x28];
0042268d      void** ecx_41 = sub_41784c(ecx_40);
00422692      int32_t var_2c_3 = arg1[0x29];
00422698      void** ecx_42 = sub_41784c(ecx_41);
0042269d      int32_t var_30_3 = arg1[0x2a];
004226a3      sub_41784c(ecx_42);
0042251d  }


004226ad    int32_t sub_4226ad()

004226ad  {
004226b8      uint32_t edi = (uint32_t)data_430b3a;
004226b8      
004226bf      if (!data_430a1c)
004226bf      {
004227bd          int32_t __saved_esi_3 = data_430b08;
004227c3          void** ecx;
004227c3          void** ecx_9 = sub_41784c(ecx);
004227c8          int32_t var_14_3 = data_430b0c;
004227ce          void** ecx_10 = sub_41784c(ecx_9);
004227d3          int32_t var_18_3 = data_430b10;
004227d9          sub_41784c(ecx_10);
004227e0          data_430b08 = 0;
004227e6          data_430b0c = 0;
004227ec          data_430b10 = 0;
00422800          **(uint32_t**)&data_42d0c0 = sub_41dbac(2);
00422807          char* eax_13 = **(uint32_t**)&data_42d0c0;
00422807          
0042280b          if (eax_13)
0042280b          {
00422817              sub_41b8c0(eax_13, U".");
0042282c              *(uint32_t*)(data_42d0c0 + 4) = sub_41dbac(2);
00422834              char* eax_16 = *(uint32_t*)(data_42d0c0 + 4);
00422834              
00422839              if (eax_16)
00422839              {
00422841                  *(uint8_t*)eax_16 = 0;
0042284f                  *(uint32_t*)(data_42d0c0 + 8) = sub_41dbac(2);
00422857                  char* eax_19 = *(uint32_t*)(data_42d0c0 + 8);
00422857                  
0042285c                  if (eax_19)
0042285c                  {
00422862                      *(uint8_t*)eax_19 = 0;
0042286b                      char* eax_21;
0042286b                      (uint8_t)eax_21 = ***(uint8_t***)&data_42d0c0;
0042286d                      data_42d084 = 1;
00422877                      data_42d080 = (uint8_t)eax_21;
0042287c                      return 0;
0042285c                  }
00422839              }
0042280b          }
004226bf      }
004226bf      else
004226bf      {
004226f0          int32_t esi_2 =
004226f0              sub_426657(1, edi, 0xe, &data_430b08) | sub_426657(1, edi, 0xf, &data_430b0c);
004226f2          int32_t eax_2 = sub_426657(1, edi, 0x10, &data_430b10);
004226ff          void** ecx_1 = sub_422882(data_430b10);
004226ff          
0042270a          if (!(esi_2 | eax_2))
0042270a          {
0042274f              int32_t __saved_esi_4 = **(uint32_t**)&data_42d0c0;
0042274f              
00422756              if (__saved_esi_4 != &data_42d088)
00422756              {
00422758                  int32_t __saved_esi_2 = __saved_esi_4;
00422759                  void** ecx_4 = sub_41784c(ecx_1);
00422763                  int32_t var_14_2 = *(uint32_t*)(data_42d0c0 + 4);
00422766                  void** ecx_5 = sub_41784c(ecx_4);
00422770                  int32_t var_18_2 = *(uint32_t*)(data_42d0c0 + 8);
00422773                  sub_41784c(ecx_5);
00422756              }
00422756              
00422786              **(uint32_t**)&data_42d0c0 = data_430b08;
00422793              *(uint32_t*)(data_42d0c0 + 4) = data_430b0c;
004227a1              *(uint32_t*)(data_42d0c0 + 8) = data_430b10;
004227ab              char* eax_10;
004227ab              (uint8_t)eax_10 = ***(uint8_t***)&data_42d0c0;
004227ad              data_42d084 = 1;
004227b3              data_42d080 = (uint8_t)eax_10;
0042287c              return 0;
0042270a          }
0042270a          
0042270c          int32_t __saved_esi_1 = data_430b08;
00422712          void** ecx_2 = sub_41784c(ecx_1);
00422717          int32_t var_14_1 = data_430b0c;
0042271d          void** ecx_3 = sub_41784c(ecx_2);
00422722          int32_t var_18_1 = data_430b10;
00422728          sub_41784c(ecx_3);
00422730          data_430b08 = 0;
00422736          data_430b0c = 0;
0042273c          data_430b10 = 0;
004226bf      }
004226bf      
00422742      return 0xffffffff;
004226ad  }


00422882    char* sub_422882(char* arg1)

00422882  {
00422882      char* result_1 = arg1;
00422886      char* result;
00422886      (uint8_t)result = *(uint8_t*)result_1;
00422886      
0042288a      while ((uint8_t)result)
0042288a      {
00422893          if ((uint8_t)result >= 0x30 && (uint8_t)result <= 0x39)
00422893          {
00422895              (uint8_t)result -= 0x30;
00422897              *(uint8_t*)result_1 = (uint8_t)result;
00422899              result_1 = &result_1[1];
00422893          }
00422893          else if ((uint8_t)result != 0x3b)
00422899              result_1 = &result_1[1];
004228a4          else
004228a4          {
004228a6              result = result_1;
004228a6              
004228b5              do
004228b5              {
004228ae                  *(uint8_t*)result = result[1];
004228b0                  result = &result[1];
004228b5              } while (*(uint8_t*)result);
004228a4          }
004228a4          
0042289a          (uint8_t)result = *(uint8_t*)result_1;
0042288a      }
0042288a      
004228a1      return result;
00422882  }


004228b9    int32_t sub_4228b9()

004228b9  {
004228c1      if (!data_430a18)
004228c1      {
00422939          int32_t* eax_9 = data_42d0c0;
0042293e          void* var_8_4 = data_430b14;
00422946          data_42d090 = *(uint32_t*)eax_9;
0042294f          data_42d094 = eax_9[1];
00422958          data_42d098 = eax_9[2];
0042295d          data_42d0c0 = &data_42d090;
00422967          void** ecx_8 = sub_422aa6(var_8_4);
0042296c          int32_t var_c_3 = data_430b14;
00422972          sub_41784c(ecx_8);
00422977          data_430b14 = 0;
004228c1      }
004228c1      else
004228c1      {
004228c7          void* eax = sub_41c874(1, 0x30);
004228c7          
004228d2          if (!eax)
004228d8              return 1;
004228d8          
004228e2          if (sub_422984(eax))
004228e2          {
004228ea              void* var_c_1 = eax;
004228eb              sub_41784c(sub_422aa6(eax));
004228d8              return 1;
004228e2          }
004228e2          
004228fb          *(uint32_t*)eax = **(uint32_t**)&data_42d0c0;
00422905          *(uint32_t*)((char*)eax + 4) = *(uint32_t*)(data_42d0c0 + 4);
00422910          *(uint32_t*)((char*)eax + 8) = *(uint32_t*)(data_42d0c0 + 8);
00422913          void* var_8_3 = data_430b14;
00422919          data_42d0c0 = eax;
0042291f          void** ecx_4 = sub_422aa6(var_8_3);
00422924          int32_t var_c_2 = data_430b14;
0042292a          sub_41784c(ecx_4);
00422930          data_430b14 = eax;
004228c1      }
004228c1      
00422983      return 0;
004228b9  }


00422984    int32_t sub_422984(void* arg1)

00422984  {
0042298a      uint32_t edi = (uint32_t)data_430b34;
0042298a      
00422993      if (!arg1)
00422995          return 0xffffffff;
00422995      
004229df      int32_t ebx_4 = sub_426657(1, edi, 0x15, (char*)arg1 + 0xc)
004229df          | sub_426657(1, edi, 0x14, (char*)arg1 + 0x10)
004229df          | sub_426657(1, edi, 0x16, (char*)arg1 + 0x14)
004229df          | sub_426657(1, edi, 0x17, (char*)arg1 + 0x18);
004229ea      int32_t eax_10 = sub_426657(1, edi, 0x18, (char*)arg1 + 0x1c);
004229f4      sub_422882(*(uint32_t*)((char*)arg1 + 0x1c));
00422a3a      int32_t ebx_9 = ebx_4 | eax_10 | sub_426657(1, edi, 0x50, (char*)arg1 + 0x20)
00422a3a          | sub_426657(1, edi, 0x51, (char*)arg1 + 0x24)
00422a3a          | sub_426657(0, edi, 0x1a, (char*)arg1 + 0x28)
00422a3a          | sub_426657(0, edi, 0x19, (char*)arg1 + 0x29);
00422a7d      int32_t ebx_13 = ebx_9 | sub_426657(0, edi, 0x54, (char*)arg1 + 0x2a)
00422a7d          | sub_426657(0, edi, 0x55, (char*)arg1 + 0x2b)
00422a7d          | sub_426657(0, edi, 0x56, (char*)arg1 + 0x2c)
00422a7d          | sub_426657(0, edi, 0x57, (char*)arg1 + 0x2d);
00422a90      int32_t ebx_14 = ebx_13 | sub_426657(0, edi, 0x52, (char*)arg1 + 0x2e);
00422aa0      return sub_426657(0, edi, 0x53, (char*)arg1 + 0x2f) | ebx_14;
00422984  }


00422aa6    void sub_422aa6(void* arg1)

00422aa6  {
00422aad      if (!arg1)
00422aad          return;
00422aad      
00422aaf      int32_t eax = *(uint32_t*)((char*)arg1 + 0xc);
00422aaf      
00422ab7      if (eax == 0x430830)
00422ab7          return;
00422ab7      
00422ab9      int32_t var_8_1 = eax;
00422aba      void** ecx;
00422aba      void** ecx_1 = sub_41784c(ecx);
00422abf      int32_t var_c_1 = *(uint32_t*)((char*)arg1 + 0x10);
00422ac2      void** ecx_2 = sub_41784c(ecx_1);
00422ac7      int32_t var_10_1 = *(uint32_t*)((char*)arg1 + 0x14);
00422aca      void** ecx_3 = sub_41784c(ecx_2);
00422acf      int32_t var_14_1 = *(uint32_t*)((char*)arg1 + 0x18);
00422ad2      void** ecx_4 = sub_41784c(ecx_3);
00422ad7      int32_t var_18_1 = *(uint32_t*)((char*)arg1 + 0x1c);
00422ada      void** ecx_5 = sub_41784c(ecx_4);
00422adf      int32_t var_1c_1 = *(uint32_t*)((char*)arg1 + 0x20);
00422ae2      void** ecx_6 = sub_41784c(ecx_5);
00422ae7      int32_t var_20_1 = *(uint32_t*)((char*)arg1 + 0x24);
00422aea      sub_41784c(ecx_6);
00422aa6  }


00422af4    int32_t sub_422af4()

00422af4  {
00422afb      int32_t result = 0;
00422b03      void* var_8 = nullptr;
00422b06      void* var_c = nullptr;
00422b06      
00422b09      if (!data_430a14)
00422b09      {
00422d01          int32_t __saved_esi_1 = data_430b18;
00422d0c          data_42ce70 = u"         (((((                  H";
00422d11          data_42ce74 = u"         (((((                  H";
00422d16          void** ecx;
00422d16          void** ecx_11 = sub_41784c(ecx);
00422d1b          int32_t __saved_edi_1 = data_430b1c;
00422d21          sub_41784c(ecx_11);
00422d27          data_430b18 = 0;
00422d2e          data_430b1c = 0;
00422d34          return 0;
00422b09      }
00422b09      
00422b17      int32_t eax_2;
00422b17      uint32_t ecx_1;
00422b17      
00422b17      if (!data_430a24)
00422b2c          eax_2 = sub_426657(0, (uint32_t)data_430b2c, 0x1004, &data_430a24);
00422b2c      
00422b36      void* var_14;
00422b36      void* var_10;
00422b36      
00422b36      if (!data_430a24 && eax_2)
00422b36      {
00422cf2      label_422cf2:
00422cf2          void* var_3c_3 = var_10;
00422cf5          sub_41784c(sub_41784c(ecx_1));
00422cfb          ecx_1 = var_14;
00422cfe          result = 1;
00422b36      }
00422b36      else
00422b36      {
00422b42          void* eax_3 = sub_41dbac(0x202);
00422b4a          var_14 = eax_3;
00422b57          var_10 = sub_41dbac(0x202);
00422b60          var_8 = sub_41dbac(0x101);
00422b63          void* eax_6;
00422b63          eax_6 = sub_41dbac(0x202);
00422b6d          var_c = eax_6;
00422b6d          
00422b8a          if (!eax_3 || !var_10 || !var_8 || !eax_6)
00422b70              goto label_422cf2;
00422b70          
00422ba0          for (char* i = nullptr; i < 0x100; i = &i[1])
00422b9a              *(uint8_t*)(i + var_8) = (uint8_t)i;
00422b9a          
00422bac          CPINFO cPInfo;
00422bac          BOOL eax_7;
00422bac          uint32_t i_1;
00422bac          eax_7 = GetCPInfo(data_430a24, &cPInfo);
00422bac          
00422bbe          if (!eax_7 || cPInfo.MaxCharSize > 2)
00422bb4              goto label_422cf2;
00422bb4          
00422bc4          uint32_t eax_8 = (uint32_t)cPInfo.MaxCharSize;
00422bcb          data_42d07c = eax_8;
00422bd5          var_21;
00422bd5          
00422bd5          if (eax_8 > 1 && cPInfo.LeadByte[0])
00422bd5          {
00422bd7              void* eax_9 = &var_21;
00422bd7              
00422bfc              do
00422bfc              {
00422bda                  (uint8_t)i_1 = *(uint8_t*)eax_9;
00422bda                  
00422bde                  if (!(uint8_t)i_1)
00422bde                      break;
00422bde                  
00422be0                  char* ecx_3 = (uint32_t)*(uint8_t*)((char*)eax_9 - 1);
00422be0                  
00422be9                  for (i_1 = (uint32_t)(uint8_t)i_1; ecx_3 <= i_1; 
00422be9                      i_1 = (uint32_t)*(uint8_t*)eax_9)
00422be9                  {
00422bee                      *(uint8_t*)(ecx_3 + var_8) = 0;
00422bf1                      ecx_3 = &ecx_3[1];
00422be9                  }
00422be9                  
00422bf8                  eax_9 += 2;
00422bfc              } while (*(uint8_t*)((char*)eax_9 - 1));
00422bd5          }
00422bd5          
00422c0b          BOOL eax_12;
00422c0b          eax_12 = sub_41e5f4(1, var_8, 0x100, (char*)eax_3 + 2, 0, 0, 0);
00422c0b          
00422c15          if (!eax_12)
00422c15              goto label_422cf2;
00422c15          
00422c1b          void* ecx_4 = var_c;
00422c1e          *(uint16_t*)eax_3 = 0;
00422c1e          
00422c2b          for (int32_t i_2 = 0; i_2 < 0x100; i_2 += 1)
00422c2b          {
00422c23              *(uint16_t*)ecx_4 = (uint16_t)i_2;
00422c27              ecx_4 += 2;
00422c2b          }
00422c2b          
00422c3c          BOOL eax_14;
00422c3c          eax_14 = sub_42678f(1, var_c, 0x100, (char*)var_10 + 2, 0, 0);
00422c3c          
00422c46          if (!eax_14)
00422c46              goto label_422cf2;
00422c46          
00422c4f          *(uint16_t*)var_10 = 0;
00422c4f          
00422c5e          if (data_42d07c > 1 && cPInfo.LeadByte[0])
00422c5e          {
00422c60              void* eax_16 = &var_21;
00422c60              
00422c8f              do
00422c8f              {
00422c63                  (uint8_t)ecx_1 = *(uint8_t*)eax_16;
00422c63                  
00422c67                  if (!(uint8_t)ecx_1)
00422c67                      break;
00422c67                  
00422c69                  uint32_t i_3 = (uint32_t)*(uint8_t*)((char*)eax_16 - 1);
00422c6d                  ecx_1 = (uint32_t)(uint8_t)ecx_1;
00422c6d                  
00422c72                  if (i_3 <= ecx_1)
00422c72                  {
00422c77                      ecx_1 = (char*)var_14 + (i_3 << 1) + 2;
00422c77                      
00422c88                      do
00422c88                      {
00422c7b                          *(uint16_t*)ecx_1 = 0x8000;
00422c80                          i_3 += 1;
00422c85                          ecx_1 += 2;
00422c88                      } while (i_3 <= (uint32_t)*(uint8_t*)eax_16);
00422c72                  }
00422c72                  
00422c8b                  eax_16 += 2;
00422c8f              } while (*(uint8_t*)((char*)eax_16 - 1));
00422c5e          }
00422c5e          
00422c94          data_42ce74 = (char*)var_10 + 2;
00422c9d          data_42ce70 = (char*)var_14 + 2;
00422ca2          uint32_t eax_20 = data_430b18;
00422ca2          
00422ca9          if (eax_20)
00422ca9          {
00422cac              sub_41784c(ecx_1);
00422cb1              ecx_1 = eax_20;
00422ca9          }
00422ca9          
00422cb5          data_430b18 = var_14;
00422cba          uint32_t eax_22 = data_430b1c;
00422cba          
00422cc1          if (eax_22)
00422cc1          {
00422cc4              sub_41784c(ecx_1);
00422cc9              ecx_1 = eax_22;
00422cc1          }
00422cc1          
00422ccd          data_430b1c = var_10;
00422b36      }
00422cd2      void* var_38_4 = var_8;
00422cda      void* var_3c_2 = var_c;
00422cdd      sub_41784c(sub_41784c(ecx_1));
00422d38      return result;
00422af4  }

00422d39                                                                             cc cc cc cc cc cc cc                           .......

00422d40    int32_t sub_422d40(void* arg1, void* arg2, int32_t arg3)

00422d40  {
00422d46      int32_t i = arg3;
00422d46      
00422d49      if (i)
00422d49      {
00422d4b          int32_t i_2 = i;
00422d4d          void* edi_1 = arg1;
00422d50          void* esi_1 = edi_1;
00422d50          
00422d54          while (i)
00422d54          {
00422d54              bool cond:0_1 = 0 != *(uint8_t*)edi_1;
00422d54              edi_1 += 1;
00422d54              i -= 1;
00422d54              
00422d54              if (!cond:0_1)
00422d54                  break;
00422d54          }
00422d54          
00422d58          int32_t i_1 = -(i) + i_2;
00422d5a          void* edi_2 = esi_1;
00422d5c          void* esi_2 = arg2;
00422d5c          
00422d5f          while (i_1)
00422d5f          {
00422d5f              bool cond:1_1 = *(uint8_t*)esi_2 == *(uint8_t*)edi_2;
00422d5f              esi_2 += 1;
00422d5f              edi_2 += 1;
00422d5f              i_1 -= 1;
00422d5f              
00422d5f              if (!cond:1_1)
00422d5f                  break;
00422d5f          }
00422d5f          
00422d61          char eax_1 = *(uint8_t*)((char*)esi_2 - 1);
00422d64          i = 0;
00422d66          char temp0_1 = *(uint8_t*)((char*)edi_2 - 1);
00422d66          
00422d69          if (eax_1 > temp0_1)
00422d6f              return ~i;
00422d6f          
00422d6b          if (eax_1 != temp0_1)
00422d6f              return ~0xfffffffe;
00422d49      }
00422d49      
00422d77      return i;
00422d40  }


00422d78    int32_t sub_422d78(char* arg1, int16_t* arg2, void* arg3)

00422d78  {
00422d83      if (!data_430b64)
00422d83      {
00422d8c          if (!sub_4234a9())
00422d9a              data_430b64 = sub_4234df;
00422d8c          else
00422d93              data_430b64 = GetLocaleInfoA;
00422d83      }
00422d83      
00422daa      BOOL eax_3;
00422daa      int32_t ecx_2;
00422daa      int32_t edx;
00422daa      
00422daa      if (!arg1)
00422e30          eax_3 = sub_4233a8();
00422daa      else
00422daa      {
00422db0          data_430b54 = arg1;
00422db0          
00422db8          if (*(uint8_t*)arg1)
00422dc6              sub_422ef5(&data_430180, 0x40, &data_430b54);
00422dc6          
00422dce          void* eax_2 = &arg1[0x40];
00422dd3          data_430b58 = eax_2;
00422dd3          
00422ddc          if (eax_2 && *(uint8_t*)eax_2)
00422ddc          {
00422dea              sub_422ef5(&data_4300c8, 0x16, &data_430b58);
00422def              eax_2 = data_430b58;
00422ddc          }
00422ddc          
00422df7          char* ecx_1 = data_430b54;
00422dfd          (*(uint32_t*)data_430b5c) = 0;
00422dfd          
00422e09          if (!ecx_1 || !*(uint8_t*)ecx_1)
00422e09          {
00422e27              if (!eax_2 || !*(uint8_t*)eax_2)
00422e30                  eax_3 = sub_4233a8();
00422e27              else
00422e29                  eax_3 = sub_4232eb();
00422e09          }
00422e09          else if (!eax_2 || !*(uint8_t*)eax_2)
00422e1a              eax_3 = sub_4231d8();
00422e11          else
00422e13              eax_3 = sub_422f4d();
00422daa      }
00422daa      
00422e3b      if ((*(uint32_t*)data_430b5c))
00422e3b      {
00422e48          int32_t eax_4 = sub_4233c2(eax_3, edx, ecx_2, &arg1[0x80]);
00422e48          
00422e52          if (eax_4 && IsValidCodePage((uint32_t)(uint16_t)eax_4)
00422e52              && IsValidLocale(data_430b44, LCID_INSTALLED))
00422e52          {
00422e82              if (arg2)
00422e82              {
00422e8b                  *(uint16_t*)arg2 = (*(uint16_t*)data_430b44);
00422e95                  arg2[1] = (*(uint16_t*)data_430b60);
00422e99                  arg2[2] = (uint16_t)eax_4;
00422e82              }
00422e82              
00422ea3              if (!arg3)
00422eec                  return 1;
00422eec              
00422ebb              if (data_430b64(data_430b44, 0x1001, arg3, 0x40)
00422ebb                  && data_430b64(data_430b60, 0x1002, (char*)arg3 + 0x40, 0x40))
00422ebb              {
00422ee2                  sub_4217e9(eax_4, (char*)arg3 + 0x80, 0xa);
00422eec                  return 1;
00422ebb              }
00422e52          }
00422e3b      }
00422e3b      
00422eef      return 0;
00422d78  }


00422ef5    int32_t sub_422ef5(int32_t arg1, int32_t arg2, char* arg3)

00422ef5  {
00422efb      int32_t ebx = 0;
00422f02      int32_t i = 1;
00422f02      
00422f03      if (arg2 >= 0)
00422f03      {
00422f07          while (i)
00422f07          {
00422f0e              int32_t eax_2;
00422f0e              int32_t edx_1;
00422f0e              edx_1 = HIGHD((int64_t)(arg2 + ebx));
00422f0e              eax_2 = LOWD((int64_t)(arg2 + ebx));
00422f16              int32_t esi_2 = (eax_2 - edx_1) >> 1;
00422f18              char* var_14_1 = *(uint32_t*)(arg1 + (esi_2 << 3));
00422f1e              int32_t* eax_5 = arg3;
00422f23              char* ecx;
00422f23              i = sub_421ff0(eax_5, edx_1, ecx, *(uint32_t*)eax_5, var_14_1);
00422f2b              ecx = var_14_1;
00422f2b              
00422f2c              if (!i)
00422f2c              {
00422f2e                  ecx = arg3;
00422f34                  *(uint32_t*)ecx = arg1 + (esi_2 << 3) + 4;
00422f2c              }
00422f2c              else if (i >= 0)
00422f40                  ebx = esi_2 + 1;
00422f38              else
00422f3b                  arg2 = esi_2 - 1;
00422f3b              
00422f46              if (ebx > arg2)
00422f46                  break;
00422f07          }
00422f03      }
00422f03      
00422f4c      return i;
00422ef5  }


00422f4d    int16_t sub_422f4d()

00422f4d  {
00422f53      void* eax = sub_41e7d0(data_430b54);
00422f58      char* var_8 = data_430b58;
00422f61      int32_t eax_2 = -(((char*)eax - 3));
00422f66      data_430b50 = eax_2 - eax_2 + 1;
00422f70      void* eax_6 = sub_41e7d0(var_8) - 3;
00422f74      int32_t eax_7 = -(eax_6);
00422f78      data_430b44 = 0;
00422f80      bool cond:0 = !data_430b50;
00422f88      data_430b48 = eax_7 - eax_7 + 1;
00422f88      
00422f8d      if (cond:0)
00422fa7          data_430b4c = sub_4235fe(data_430b54);
00422f8d      else
00422f8f          data_430b4c = 2;
00422f8f      
00422fb3      EnumSystemLocalesA(sub_422fd4, 1);
00422fb9      int16_t result = (int16_t)(*(uint32_t*)data_430b5c);
00422fb9      
00422fca      if (!(*(uint8_t*)((char*)result)[1] & 1) || !(*(uint8_t*)((char*)result)[1] & 2)
00422fca              || !((uint8_t)result & 7))
00422fcc          (*(uint32_t*)data_430b5c) = 0;
00422fcc      
00422fd3      return result;
00422f4d  }


00422fd4    int32_t __stdcall sub_422fd4(char* arg1)

00422fd4  {
00422fe0      int32_t eax = sub_4235c5(arg1);
00422fee      int32_t eax_1 = data_430b48;
00422ff3      int32_t eax_2 = -(eax_1);
00422ff7      int32_t eax_3;
00422ff7      (uint16_t)eax_3 = (eax_2 - eax_2) & 0xf005;
00423002      char var_7c[0x78];
00423002      int32_t eax_5;
00423002      int32_t ecx_1;
00423002      int32_t edx;
00423002      eax_5 = data_430b64(eax, eax_3 + 0x1002, &var_7c, 0x78);
00423002      
0042300a      if (eax_5)
0042300a      {
0042302d          if (sub_421ff0(&var_7c, edx, ecx_1, data_430b58, &var_7c))
0042302d          {
004230fc          label_4230fc:
004230fc              
004230fe              if (((*(uint32_t*)data_430b5c) & 0x300) == 0x300)
004231ce                  return ~(*(uint32_t*)data_430b5c) >> 2 & 1;
004231ce              
0042310a              int32_t eax_20 = data_430b50;
0042310f              int32_t eax_21 = -(eax_20);
00423119              int32_t eax_25;
00423119              int32_t ecx_9;
00423119              int32_t edx_2;
00423119              eax_25 = data_430b64(eax, ((eax_21 - eax_21) & 0xfffff002) + 0x1001, &var_7c, 
00423119                  0x78);
00423119              
00423121              if (eax_25)
00423121              {
00423145                  int32_t var_8c_8;
00423145                  
00423145                  if (!sub_421ff0(&var_7c, edx_2, ecx_9, data_430b54, &var_7c))
00423145                  {
00423147                      data_430b5d |= 2;
00423147                      
0042315e                      if (!data_430b50 && data_430b4c)
0042315e                      {
00423172                          if (sub_41e7d0(data_430b54) != data_430b4c)
00423172                              goto label_4231af;
00423172                          
00423174                          var_8c_8 = 1;
00423176                          goto label_4231aa;
0042315e                      }
0042315e                      
004231af                  label_4231af:
004231af                      data_430b5d |= 1;
004231af                      
004231bc                      if (!data_430b44)
004231be                          data_430b44 = eax;
00423145                  }
00423145                  else if (!data_430b50)
00423180                  {
00423182                      int32_t eax_30 = data_430b4c;
00423182                      
00423189                      if (eax_30 && !sub_426960(data_430b54, &var_7c, eax_30))
00423189                      {
004231a2                          var_8c_8 = 0;
004231aa                      label_4231aa:
004231aa                          
004231ad                          if (sub_423447(eax, var_8c_8))
004231ad                              goto label_4231af;
00423189                      }
00423180                  }
004231ce                  return ~(*(uint32_t*)data_430b5c) >> 2 & 1;
00423121              }
0042302d          }
0042302d          else
0042302d          {
00423039              int32_t eax_8 = data_430b50;
0042303e              int32_t eax_9 = -(eax_8);
00423048              int32_t eax_13;
00423048              int32_t ecx_3;
00423048              int32_t edx_1;
00423048              eax_13 =
00423048                  data_430b64(eax, ((eax_9 - eax_9) & 0xfffff002) + 0x1001, &var_7c, 0x78);
00423048              
00423050              if (eax_13)
00423050              {
00423069                  if (!sub_421ff0(&var_7c, edx_1, ecx_3, data_430b54, &var_7c))
00423069                  {
0042306b                      (*(uint16_t*)data_430b5c) |= 0x304;
00423074                      data_430b60 = eax;
0042307a                      data_430b44 = eax;
00423069                  }
00423069                  else if (!(data_430b5c & 2))
00423089                  {
0042308b                      int32_t eax_16 = data_430b4c;
00423092                      int32_t eax_17;
00423092                      
00423092                      if (eax_16)
0042309f                          eax_17 = sub_426960(data_430b54, &var_7c, eax_16);
0042309f                      
004230a9                      if (eax_16 && !eax_17)
004230a9                      {
004230ab                          char* var_8c_4 = data_430b54;
004230b1                          (*(uint32_t*)data_430b5c) |= 2;
004230b8                          data_430b60 = eax;
004230b8                          
004230ca                          if (sub_41e7d0(var_8c_4) == data_430b4c)
0042307a                              data_430b44 = eax;
004230a9                      }
004230a9                      else if (!(data_430b5c & 1) && sub_423428((uint16_t)eax))
004230d5                      {
004230e2                          (*(uint32_t*)data_430b5c) |= 1;
004230e9                          data_430b60 = eax;
004230d5                      }
00423089                  }
00423089                  
00423069                  goto label_4230fc;
00423050              }
0042302d          }
0042300a      }
0042300a      
00423123      (*(uint32_t*)data_430b5c) = 0;
0042312c      return 1;
00422fd4  }


004231d8    BOOL sub_4231d8()

004231d8  {
004231e3      void* eax_1 = sub_41e7d0(data_430b54) - 3;
004231e7      int32_t eax_2 = -(eax_1);
004231e9      int32_t eax_3 = eax_2 - eax_2;
004231ec      data_430b50 = eax_3 + 1;
004231ec      
004231f1      if (eax_3 == 0xffffffff)
0042320b          data_430b4c = sub_4235fe(data_430b54);
004231f1      else
004231f3          data_430b4c = 2;
004231f3      
00423217      BOOL result = EnumSystemLocalesA(sub_42322e, 1);
00423217      
00423224      if (!(data_430b5c & 4))
00423226          (*(uint32_t*)data_430b5c) = 0;
00423226      
0042322d      return result;
004231d8  }


0042322e    int32_t __stdcall sub_42322e(char* arg1)

0042322e  {
00423238      int32_t eax = sub_4235c5(arg1);
00423246      int32_t eax_1 = data_430b50;
0042324b      int32_t eax_2 = -(eax_1);
0042324f      int32_t eax_3;
0042324f      (uint16_t)eax_3 = (eax_2 - eax_2) & 0xf002;
0042325a      char var_7c[0x78];
0042325a      int32_t eax_5;
0042325a      int32_t ecx_1;
0042325a      int32_t edx;
0042325a      eax_5 = data_430b64(eax, eax_3 + 0x1001, &var_7c, 0x78);
0042325a      
00423262      if (!eax_5)
00423262      {
00423264          (*(uint32_t*)data_430b5c) &= eax_5;
0042326c          return 1;
00423262      }
00423262      
00423279      int32_t eax_8 = sub_421ff0(&var_7c, edx, ecx_1, data_430b54, &var_7c);
00423282      int32_t var_84_2;
00423282      
00423282      if (eax_8)
00423282      {
00423297          if (!data_430b50)
00423297          {
00423299              int32_t eax_9 = data_430b4c;
00423299              
004232a0              if (eax_9)
004232a0              {
004232ad                  int32_t eax_10 = sub_426960(data_430b54, &var_7c, eax_9);
004232ad                  
004232b7                  if (!eax_10)
004232b7                  {
004232b9                      var_84_2 = eax_10;
004232b9                      goto label_4232c1;
004232b7                  }
004232a0              }
00423297          }
00423282      }
00423282      else if (data_430b50 != eax_8)
0042328a      {
004232c6      label_4232c6:
004232c6          (*(uint32_t*)data_430b5c) |= 4;
004232cd          data_430b60 = eax;
004232d3          data_430b44 = eax;
0042328a      }
0042328a      else
0042328a      {
0042328c          var_84_2 = 1;
004232c1      label_4232c1:
004232c1          
004232c4          if (sub_423447(eax, var_84_2))
004232c4              goto label_4232c6;
0042328a      }
004232e3      return ~(*(uint32_t*)data_430b5c) >> 2 & 1;
0042322e  }


004232eb    BOOL sub_4232eb()

004232eb  {
004232f6      void* eax_1 = sub_41e7d0(data_430b58) - 3;
004232fa      int32_t eax_2 = -(eax_1);
00423306      data_430b48 = eax_2 - eax_2 + 1;
0042330b      BOOL result = EnumSystemLocalesA(sub_423322, 1);
0042330b      
00423318      if (!(data_430b5c & 4))
0042331a          (*(uint32_t*)data_430b5c) = 0;
0042331a      
00423321      return result;
004232eb  }


00423322    int32_t __stdcall sub_423322(char* arg1)

00423322  {
0042332c      int32_t eax = sub_4235c5(arg1);
0042333a      int32_t eax_1 = data_430b48;
0042333f      int32_t eax_2 = -(eax_1);
00423343      int32_t eax_3;
00423343      (uint16_t)eax_3 = (eax_2 - eax_2) & 0xf005;
0042334e      char var_7c[0x78];
0042334e      int32_t eax_5;
0042334e      int32_t ecx_1;
0042334e      int32_t edx;
0042334e      eax_5 = data_430b64(eax, eax_3 + 0x1002, &var_7c, 0x78);
0042334e      
00423356      if (!eax_5)
00423356      {
00423358          (*(uint32_t*)data_430b5c) &= eax_5;
00423360          return 1;
00423356      }
00423356      
00423376      if (!sub_421ff0(&var_7c, edx, ecx_1, data_430b58, &var_7c)
00423376          && sub_423428((uint16_t)eax))
00423376      {
00423383          (*(uint32_t*)data_430b5c) |= 4;
0042338a          data_430b60 = eax;
00423390          data_430b44 = eax;
00423376      }
00423376      
004233a0      return ~(*(uint32_t*)data_430b5c) >> 2 & 1;
00423322  }


004233a8    uint32_t sub_4233a8()

004233a8  {
004233a8      (*(uint16_t*)data_430b5c) |= 0x104;
004233b1      uint32_t result = GetUserDefaultLCID();
004233b7      data_430b60 = result;
004233bc      data_430b44 = result;
004233c1      return result;
004233a8  }


004233c2    int32_t __convention("regparm") sub_4233c2(int32_t arg1, int32_t arg2, int32_t arg3, char* arg4)

004233c2  {
004233c5      int32_t var_8 = arg3;
004233c6      int32_t var_c = arg3;
004233d2      bool cond:0_1;
004233d2      
004233d2      if (arg4 && *(uint8_t*)arg4)
004233e0          cond:0_1 = !sub_41ebe0(arg4, "ACP");
004233e0      
004233e3      int32_t result;
004233e3      int32_t var_1c_1;
004233e3      int32_t* var_18_3;
004233e3      
004233e3      if (!arg4 || !*(uint8_t*)arg4 || cond:0_1)
004233e3      {
00423403          int32_t var_14_2 = 8;
00423405          var_18_3 = &var_c;
00423406          var_1c_1 = 0x1004;
00423411      label_423411:
00423411          result = data_430b64(data_430b60, var_1c_1, var_18_3, 8);
00423411          
00423419          if (result)
0042341f              result = sub_4265cc(&var_c);
004233e3      }
004233e3      else
004233e3      {
004233f4          if (!sub_41ebe0(arg4, "OCP"))
004233f4          {
004233f9              int32_t var_14_1 = 8;
004233fb              var_18_3 = &var_c;
004233fc              var_1c_1 = 0xb;
004233fe              goto label_423411;
004233f4          }
004233f4          
0042341f          result = sub_4265cc(arg4);
004233e3      }
00423427      return result;
004233c2  }


00423428    int32_t sub_423428(int16_t arg1)

00423428  {
0042343e      for (void* i = &data_4300b4; i < &data_4300c8; i += 2)
0042343e      {
00423435          if (arg1 == *(uint16_t*)i)
00423446              return 0;
0042343e      }
0042343e      
00423443      return 1;
00423428  }


00423447    int32_t sub_423447(int32_t arg1, int32_t arg2)

00423447  {
0042345d      int32_t eax_1;
0042345d      *(uint8_t*)((char*)eax_1)[1] = *(uint8_t*)((char*)(arg1 & 0x3ff))[1] | 4;
00423469      char var_7c[0x78];
00423469      
00423469      if (data_430b64(eax_1, 1, &var_7c, 0x78))
00423469      {
0042347e          if (arg1 == sub_4235c5(&var_7c) || !arg2)
004234a8              return 1;
004234a8          
0042349e          if (sub_4235fe(data_430b54) != sub_41e7d0(data_430b54))
004234a8              return 1;
00423469      }
00423469      
004234a3      return 0;
00423447  }


004234a9    int32_t sub_4234a9()

004234a9  {
004234b8      OSVERSIONINFOA versionInformation;
004234b8      versionInformation.dwOSVersionInfoSize = 0x94;
004234b8      
004234d4      if (GetVersionExA(&versionInformation) && versionInformation.dwPlatformId == 2)
004234da          return 1;
004234da      
004234de      return 0;
004234a9  }


004234df    int32_t __stdcall sub_4234df(uint32_t arg1, uint32_t arg2, uint8_t* arg3, int32_t arg4)

004234df  {
004234e7      int32_t esi = 0;
004234e9      int32_t edi = 0x1a;
004234e9      
00423514      do
00423514      {
004234f0          int32_t eax_2;
004234f0          int32_t edx_1;
004234f0          edx_1 = HIGHD((int64_t)(edi + esi));
004234f0          eax_2 = LOWD((int64_t)(edi + esi));
004234f3          int32_t eax_4 = (eax_2 - edx_1) >> 1;
004234fa          int32_t ecx_3 = *(uint32_t*)(eax_4 * 0x2c + 0x42fc10);
004234fa          
00423503          if (arg1 == ecx_3)
00423503          {
00423531              char* eax_7;
00423531              
00423531              if (arg2 == 1)
00423531              {
00423591                  eax_7 = &data_42fc14[eax_4 * 0x2c];
00423596              label_423596:
00423596                  
004235a1                  if (eax_7 && arg4 >= 1)
004235a1                  {
004235b0                      sub_417ef0(arg3, eax_7, arg4 - 1);
004235b8                      arg3[arg4 - 1] = 0;
004235bf                      return 1;
004235a1                  }
00423531              }
00423531              else
00423535                  switch (arg2)
00423535                  {
00423534                      case 3:
00423534                      {
00423587                          eax_7 = eax_4 * 0x2c + &data_42fc20;
0042358c                          goto label_423596;
00423534                      }
00423537                      case 7:
00423537                      {
0042357d                          eax_7 = eax_4 * 0x2c + &data_42fc28;
00423582                          goto label_423596;
00423537                      }
0042353c                      case 0xb:
0042353c                      {
00423573                          eax_7 = eax_4 * 0x2c + &data_42fc2c;
00423578                          goto label_423596;
0042353c                      }
00423541                      case 0x1001:
00423541                      {
00423568                          eax_7 = (&data_42fc1c)[eax_4 * 0xb];
0042356e                          goto label_423596;
00423541                      }
00423549                      case 0x1002:
00423549                      {
0042355d                          eax_7 = (&data_42fc24)[eax_4 * 0xb];
00423563                          goto label_423596;
00423549                      }
0042354d                      case 0x1004:
0042354d                      {
00423553                          eax_7 = &data_42fc34[eax_4 * 0x2c];
00423558                          goto label_423596;
0042354d                      }
00423535                  }
00423531              break;
00423503          }
00423503          
00423508          if (arg1 >= ecx_3)
0042350f              esi = eax_4 + 1;
00423508          else
0042350a              edi = eax_4 - 1;
00423514      } while (esi <= edi);
00423514      
00423520      return GetLocaleInfoA(arg1, arg2, arg3, arg4);
004234df  }


004235c5    int32_t sub_4235c5(char* arg1)

004235c5  {
004235c5      char* edx = arg1;
004235c9      int32_t result = 0;
004235c9      
004235cb      while (true)
004235cb      {
004235cb          int32_t ecx;
004235cb          (uint8_t)ecx = *(uint8_t*)edx;
004235cd          edx = &edx[1];
004235cd          
004235d0          if (!(uint8_t)ecx)
004235d0              break;
004235d0          
004235da          if ((uint8_t)ecx >= 0x61 && (uint8_t)ecx <= 0x66)
004235dc              (uint8_t)ecx -= 0x27;
004235da          else if ((uint8_t)ecx >= 0x41 && (uint8_t)ecx <= 0x46)
004235eb              (uint8_t)ecx -= 7;
004235eb          
004235f9          result = ((result + 0xffffffd) << 4) + (int32_t)(uint8_t)ecx;
004235cb      }
004235cb      
004235fd      return result;
004235c5  }


004235fe    int32_t sub_4235fe(char* arg1)

004235fe  {
004235fe      char* edx = arg1;
00423602      int32_t result = 0;
00423602      
00423604      while (true)
00423604      {
00423604          char ecx = *(uint8_t*)edx;
00423606          edx = &edx[1];
00423606          
00423619          if ((ecx < 0x41 || ecx > 0x5a) && (ecx < 0x61 || ecx > 0x7a))
0042361e              return result;
0042361e          
0042361b          result += 1;
00423604      }
004235fe  }

0042361f                                                                                               cc                                 .

00423620    char* sub_423620(char* arg1, char arg2, int32_t arg3)

00423620  {
00423620      int32_t i_3 = arg3;
00423620      
0042362a      if (!i_3)
00423677          return arg1;
00423677      
0042362e      int32_t eax;
0042362e      (uint8_t)eax = arg2;
00423633      char* edi = arg1;
00423633      
00423638      if (i_3 < 4)
00423638      {
0042366b      label_42366b:
0042366b          int32_t i;
0042366b          
0042366b          do
0042366b          {
00423667              *(uint8_t*)edi = (uint8_t)eax;
00423669              edi = &edi[1];
0042366a              i = i_3;
0042366a              i_3 -= 1;
0042366b          } while (i != 1);
00423638      }
00423638      else
00423638      {
0042363c          int32_t i_2 = -(arg1) & 3;
0042363c          
0042363f          if (i_2)
0042363f          {
00423641              i_3 -= i_2;
00423647              int32_t i_1;
00423647              
00423647              do
00423647              {
00423643                  *(uint8_t*)edi = (uint8_t)eax;
00423645                  edi = &edi[1];
00423646                  i_1 = i_2;
00423646                  i_2 -= 1;
00423647              } while (i_1 != 1);
0042363f          }
0042363f          
00423655          eax *= 0x1010101;
00423657          int32_t i_4 = i_3;
00423659          i_3 &= 3;
0042365c          uint32_t ecx_4 = i_4 >> 2;
0042365c          
0042365f          if (!ecx_4)
0042365f              goto label_42366b;
0042365f          
00423661          int32_t ecx_5;
00423661          edi = __memfill_u32(edi, eax, ecx_4);
00423661          
00423665          if (i_3)
00423665              goto label_42366b;
00423638      }
00423638      
00423672      return arg1;
00423620  }


00423678    char* sub_423678(int32_t arg1, char* arg2)

00423678  {
0042368d      void arg_c;
0042368d      return sub_426a0d(arg1, arg2, &arg_c);
00423678  }


0042368e    char* sub_42368e(int32_t arg1, char* arg2)

0042368e  {
004236a5      void arg_c;
004236a5      return sub_4212c0(arg1, arg2, &arg_c, nullptr);
0042368e  }


004236a6    int32_t* sub_4236a6(int32_t arg1, char* arg2)

004236a6  {
004236cb      if (arg1 < data_430f20
004236cb          && *(uint8_t*)((&data_430e20)[arg1 >> 5] + ((arg1 & 0x1f) << 3) + 4) & 1)
004236cb      {
004236cd          int32_t* result = sub_41bb20();
004236cd          
004236d4          if (result)
004236d4          {
004236d6              char* edx_1 = arg2;
004236d9              char ecx_4 = *(uint8_t*)edx_1;
004236d9              
004236de              if (ecx_4 == 0x61)
004236de              {
004236f4              label_4236f4:
004236f4                  result[3] = 2;
00423703              label_423703:
00423703                  int32_t edi_1 = 0;
00423705                  arg2 = nullptr;
00423708                  result[3] |= data_430a40;
0042370b                  int32_t esi_1 = 1;
0042370b                  
0042370d                  while (true)
0042370d                  {
0042370d                      int32_t ecx_5;
0042370d                      (uint8_t)ecx_5 = edx_1[1];
00423710                      edx_1 = &edx_1[1];
00423710                      
00423713                      if (!(uint8_t)ecx_5)
00423713                          break;
00423713                      
00423717                      if (!esi_1)
00423717                          break;
00423717                      
00423719                      int32_t ecx_6 = (int32_t)(uint8_t)ecx_5;
00423719                      
0042371f                      if (ecx_6 == 0x2b)
0042371f                      {
00423758                          ecx_5 = result[3];
00423758                          
0042375e                          if (!((uint8_t)ecx_5 & 0x80))
0042375e                          {
00423767                              (uint8_t)ecx_5 = (ecx_5 & 0xfffffffc) | 0x80;
0042376a                              result[3] = ecx_5;
0042376d                              continue;
0042375e                          }
0042371f                      }
0042371f                      else if (ecx_6 == 0x62)
00423724                      {
0042374d                      label_42374d:
0042374d                          
00423751                          if (!arg2)
00423751                          {
00423753                              arg2 = 1;
00423756                              continue;
00423751                          }
00423724                      }
00423724                      else if (ecx_6 == 0x63)
00423727                      {
00423743                          if (!edi_1)
00423743                          {
00423745                              *(uint8_t*)((char*)result + 0xd) |= 0x40;
00423749                              edi_1 = 1;
0042374b                              continue;
00423743                          }
00423727                      }
00423727                      else if (ecx_6 == 0x6e)
0042372c                      {
00423737                          if (!edi_1)
00423737                          {
00423739                              *(uint8_t*)((char*)result + 0xd) &= 0xbf;
0042373d                              edi_1 = 1;
0042373f                              continue;
00423737                          }
0042372c                      }
0042372c                      else if (ecx_6 == 0x74)
00423731                          goto label_42374d;
00423731                      
00423760                      esi_1 = 0;
0042370d                  }
0042370d                  
00423772                  data_43082c += 1;
00423779                  result[4] = arg1;
004236ee                  return result;
004236de              }
004236de              
004236e3              if (ecx_4 == 0x72)
004236e3              {
004236ef                  result[3] = 1;
004236f2                  goto label_423703;
004236e3              }
004236e3              
004236e8              if (ecx_4 == 0x77)
004236e8                  goto label_4236f4;
004236d4          }
004236cb      }
004236cb      
004236ea      return nullptr;
004236a6  }


00423782    int32_t sub_423782()

00423782  {
00423785      int32_t result = 0xffffffff;
00423788      int32_t edi = 0;
0042378a      int32_t esi = 0;
0042378a      
004237ca      for (int32_t* i = &data_430e20; i < &data_430f20; )
004237ca      {
00423791          void* eax_1 = *(uint32_t*)i;
00423791          
00423795          if (!eax_1)
00423795          {
004237d4              void* eax_5 = sub_41dbac(0x100);
004237d4              
004237dc              if (!eax_5)
004237dc                  break;
004237dc              
004237de              data_430f20 += 0x20;
004237ec              void* j = (char*)eax_5 + 0x100;
004237f2              (&data_430e20)[edi] = eax_5;
004237f2              
004237f6              for (; eax_5 < j; j = (&data_430e20)[edi] + 0x100)
004237f6              {
004237f8                  *(uint8_t*)((char*)eax_5 + 4) = 0;
004237fc                  *(uint32_t*)eax_5 = 0xffffffff;
004237ff                  *(uint8_t*)((char*)eax_5 + 5) = 0xa;
00423805                  eax_5 += 8;
004237f6              }
004237f6              
0042380f              return edi << 5;
00423795          }
00423795          
00423797          void* edx_1 = (char*)eax_1 + 0x100;
00423797          
0042379f          while (true)
0042379f          {
0042379f              if (eax_1 >= edx_1)
0042379f                  goto label_4237bd;
0042379f              
004237a5              if (!(*(uint8_t*)((char*)eax_1 + 4) & 1))
004237a5                  break;
004237a5              
004237a7              eax_1 += 8;
0042379f          }
0042379f          
004237ac          *(uint32_t*)eax_1 = 0xffffffff;
004237b6          result = (((char*)eax_1 - *(uint32_t*)i) >> 3) + esi;
004237b6          
004237bb          if (result != 0xffffffff)
004237bb              break;
004237bb          
004237bd      label_4237bd:
004237bd          i = &i[1];
004237c0          edi += 1;
004237c1          esi += 0x20;
004237ca      }
004237ca      
00423816      return result;
00423782  }


00423817    int32_t sub_423817(int32_t arg1, HANDLE arg2)

00423817  {
00423823      if (arg1 < data_430f20 && (&data_430e20)[arg1 >> 5][(arg1 & 0x1f) * 2] == 0xffffffff)
00423823      {
0042384d          if (data_42cbe4 == 1)
0042384d          {
00423852              if (!arg1)
00423867                  SetStdHandle(STD_INPUT_HANDLE, arg2);
00423852              else if (arg1 == 1)
00423867                  SetStdHandle(STD_OUTPUT_HANDLE, arg2);
00423855              else if (arg1 == 2)
00423867                  SetStdHandle(STD_ERROR_HANDLE, arg2);
0042384d          }
0042384d          
0042386f          (&data_430e20)[arg1 >> 5][(arg1 & 0x1f) * 2] = arg2;
00423872          return 0;
00423823      }
00423823      
00423877      data_4307d8 = 0;
0042387e      data_4307d4 = 9;
00423888      return 0xffffffff;
00423817  }


0042388e    int32_t sub_42388e(int32_t arg1)

0042388e  {
0042389a      if (arg1 < data_430f20)
0042389a      {
004238b2          int32_t* eax_4 = (&data_430e20)[arg1 >> 5] + ((arg1 & 0x1f) << 3);
004238b2          
004238bd          if (eax_4[1] & 1 && *(uint32_t*)eax_4 != 0xffffffff)
004238bd          {
004238c6              if (data_42cbe4 == 1)
004238c6              {
004238cc                  if (!arg1)
004238cc                  {
004238de                      int32_t var_c_3 = 0;
004238e1                      SetStdHandle(STD_INPUT_HANDLE, nullptr);
004238cc                  }
004238cc                  else if (arg1 == 1)
004238cf                  {
004238d9                      int32_t var_c_2 = 0;
004238e1                      SetStdHandle(STD_OUTPUT_HANDLE, nullptr);
004238cf                  }
004238cf                  else if (arg1 == 2)
004238d2                  {
004238d4                      int32_t var_c_1 = 0;
004238e1                      SetStdHandle(STD_ERROR_HANDLE, nullptr);
004238d2                  }
004238c6              }
004238c6              
004238e9              (&data_430e20)[arg1 >> 5][(arg1 & 0x1f) * 2] = 0xffffffff;
004238ed              return 0;
004238bd          }
0042389a      }
0042389a      
004238f1      data_4307d8 = 0;
004238f8      data_4307d4 = 9;
00423902      return 0xffffffff;
0042388e  }


00423908    int32_t sub_423908(int32_t arg1)

00423908  {
00423912      if (arg1 < data_430f20)
00423912      {
00423916          int32_t eax = arg1 & 0x1f;
0042391c          int32_t ecx_3 = (&data_430e20)[arg1 >> 5];
0042391c          
0042392b          if (*(uint8_t*)(ecx_3 + (eax << 3) + 4) & 1)
0042392f              return *(uint32_t*)(ecx_3 + (eax << 3));
00423912      }
00423912      
00423930      data_4307d8 = 0;
00423937      data_4307d4 = 9;
00423944      return 0xffffffff;
00423908  }


00423945    int32_t sub_423945(int32_t* arg1, int32_t arg2)

00423945  {
0042394b      SECURITY_ATTRIBUTES pipeAttributes;
0042394b      pipeAttributes.lpSecurityDescriptor = 0;
00423957      int32_t ebx_1 = arg2 & 0x80;
00423961      pipeAttributes.nLength = 0xc;
00423968      int32_t eax;
00423968      (uint8_t)eax = !ebx_1;
0042396b      pipeAttributes.bInheritHandle = eax;
00423982      HANDLE var_8;
00423982      HANDLE hObject_1;
00423982      
00423982      if (CreatePipe(&hObject_1, &var_8, &pipeAttributes, hObject_1))
00423982      {
00423996          int32_t eax_3 = sub_423782();
004239a1          *(uint32_t*)arg1 = eax_3;
004239a1          
004239a3          if (eax_3 != 0xffffffff)
004239a3          {
004239ba              *(uint8_t*)((&data_430e20)[eax_3 >> 5] + ((eax_3 & 0x1f) << 3) + 4) = 0x89;
004239bf              int32_t eax_5 = sub_423782();
004239c7              arg1[1] = eax_5;
004239c7              
004239ca              if (eax_5 != 0xffffffff)
004239ca              {
004239de                  *(uint8_t*)((&data_430e20)[eax_5 >> 5] + ((eax_5 & 0x1f) << 3) + 4) =
004239de                      0x89;
004239de                  
004239eb                  if (arg2 & 0x8000)
004239eb                  {
004239fb                  label_4239fb:
004239fb                      int32_t eax_7 = *(uint32_t*)arg1;
004239ff                      int32_t eax_8 = eax_7 & 0x1f;
00423a04                      int32_t ecx_10 = (&data_430e20)[eax_7 >> 5];
00423a0b                      *(uint8_t*)(ecx_10 + (eax_8 << 3) + 4) &= 0x7f;
00423a14                      int32_t eax_9 = arg1[1];
00423a19                      int32_t eax_10 = eax_9 & 0x1f;
00423a1e                      int32_t ecx_13 = (&data_430e20)[eax_9 >> 5];
00423a25                      *(uint8_t*)(ecx_13 + (eax_10 << 3) + 4) &= 0x7f;
004239eb                  }
004239eb                  else if (!(*(uint8_t*)((char*)arg2)[1] & 0x40) && data_430ba8 == 0x8000)
004239f9                      goto label_4239fb;
004239f9                  
00423a30                  if (ebx_1)
00423a30                  {
00423a32                      int32_t eax_12 = *(uint32_t*)arg1;
00423a36                      int32_t eax_13 = eax_12 & 0x1f;
00423a3b                      int32_t ecx_16 = (&data_430e20)[eax_12 >> 5];
00423a42                      *(uint8_t*)(ecx_16 + (eax_13 << 3) + 4) |= 0x10;
00423a4b                      int32_t eax_14 = arg1[1];
00423a50                      int32_t eax_15 = eax_14 & 0x1f;
00423a55                      int32_t ecx_19 = (&data_430e20)[eax_14 >> 5];
00423a5c                      *(uint8_t*)(ecx_19 + (eax_15 << 3) + 4) |= 0x10;
00423a30                  }
00423a30                  
00423a6a                  sub_423817(*(uint32_t*)arg1, hObject_1);
00423a75                  sub_423817(arg1[1], var_8);
00423a7a                  data_4307d4 = 0;
00423a84                  return 0;
004239ca              }
004239ca              
00423a8b              int32_t esi_2 = *(uint32_t*)arg1;
00423a9b              *(uint8_t*)((&data_430e20)[esi_2 >> 5] + ((esi_2 & 0x1f) << 3) + 4) = 0;
004239a3          }
004239a3          
00423aa0          HANDLE hObject = hObject_1;
00423aa9          data_4307d4 = 0x18;
00423ab3          CloseHandle(hObject);
00423ab8          CloseHandle(var_8);
00423aba          data_4307d8 = 0;
00423982      }
00423982      else
0042398b          sub_42149e(GetLastError());
0042398b      
00423ac1      return 0xffffffff;
00423945  }


00423ac6    HANDLE sub_423ac6(int32_t* arg1, HANDLE arg2)

00423ac6  {
00423aca      HANDLE result_1 = arg2;
00423aca      
00423ad5      if (result_1 == 0xffffffff || result_1 == 0xfffffffe)
00423ad5      {
00423b41          data_4307d4 = 0xa;
00423b4b          return 0xffffffff;
00423ad5      }
00423ad5      
00423adb      enum WAIT_EVENT eax = WaitForSingleObject(result_1, 0xffffffff);
00423ae3      BOOL eax_1;
00423ae3      
00423ae3      if (!eax)
00423aea          eax_1 = GetExitCodeProcess(result_1, &arg2);
00423aea      
00423af2      HANDLE result;
00423af2      
00423af2      if (eax || !eax_1)
00423af2      {
00423b05          if (GetLastError() != ERROR_INVALID_HANDLE)
00423b1c              sub_42149e(GetLastError());
00423b05          else
00423b05          {
00423b07              data_4307d4 = 0xa;
00423b11              data_4307d8 = 6;
00423b05          }
00423b05          
00423b22          result = 0xffffffff;
00423b25          arg2 = 0xffffffff;
00423af2      }
00423af2      else
00423af4          result = result_1;
00423af4      
00423b2a      CloseHandle(result_1);
00423b2a      
00423b35      if (arg1)
00423b3a          *(uint32_t*)arg1 = arg2;
00423b3a      
00423b3c      return result;
00423ac6  }


00423b51    int32_t sub_423b51(int32_t* arg1, char* arg2, void* arg3)

00423b51  {
00423b5a      char var_19 = 0;
00423b60      char* esi = arg2;
00423b66      void* eax;
00423b66      (uint8_t)eax = *(uint8_t*)esi;
00423b68      void* var_8 = nullptr;
00423b6d      int32_t result = 0;
00423b70      void* var_18;
00423b70      
00423b70      if ((uint8_t)eax)
00423b70      {
00423b76          int32_t* edi_1 = arg1;
00423b76          
00423b87          while (true)
00423b87          {
00423b87              BOOL eax_2;
00423b87              uint32_t ecx;
00423b87              int32_t edx;
00423b87              
00423b87              if (data_42d07c <= 1)
00423b87              {
00423b98                  ecx = data_42ce70;
00423ba1                  uint32_t eax_3;
00423ba1                  (uint8_t)eax_3 = *(uint8_t*)(ecx + ((uint32_t)(uint8_t)eax << 1));
00423ba4                  eax_2 = eax_3 & 8;
00423b87              }
00423b87              else
00423b87              {
00423b89                  uint32_t eax_1 = (uint32_t)(uint8_t)eax;
00423b8f                  eax_2 = sub_4179df(eax_1, edx, ecx, eax_1);
00423b95                  ecx = 8;
00423b87              }
00423b87              
00423ba9              if (eax_2)
00423ba9              {
00423bab                  var_8 -= 1;
00423bbc                  sub_4245c7(sub_4245de(&var_8, edi_1), edi_1);
00423bc1                  uint32_t eax_5 = (uint32_t)esi[1];
00423bc5                  esi = &esi[1];
00423bc7                  BOOL i;
00423bc7                  i = sub_426aec(eax_5);
00423bc7                  
00423bd1                  while (i)
00423bd1                  {
00423bd3                      uint32_t eax_6 = (uint32_t)esi[1];
00423bd7                      esi = &esi[1];
00423bd9                      i = sub_426aec(eax_6);
00423bde                      ecx = eax_6;
00423bd1                  }
00423ba9              }
00423ba9              
00423be4              if (*(uint8_t*)esi != 0x25)
00423be4              {
004244c3                  var_8 += 1;
004244c7                  uint32_t eax_58;
004244c7                  eax_58 = sub_4245ad(edi_1);
004244cf                  uint32_t eax_59 = (uint32_t)*(uint8_t*)esi;
004244d2                  esi = &esi[1];
004244d5                  var_18 = eax_58;
004244d8                  arg2 = esi;
004244d8                  
004244db                  if (eax_59 != eax_58)
004244db                  {
00424532                      var_8 -= 1;
00424537                      sub_4245c7(eax_58, edi_1);
0042453e                      break;
004244db                  }
004244db                  
004244dd                  ecx = data_42ce70;
004244dd                  
004244eb                  if (*(uint8_t*)(ecx + ((uint32_t)(uint8_t)eax_58 << 1) + 1) & 0x80)
004244eb                  {
004244ed                      var_8 += 1;
004244f1                      eax = sub_4245ad(edi_1);
004244f7                      ecx = (uint32_t)*(uint8_t*)esi;
004244fa                      esi = &esi[1];
004244fd                      arg2 = esi;
004244fd                      
00424500                      if (ecx != eax)
00424500                      {
00424540                          var_8 -= 1;
00424545                          sub_4245c7(eax, edi_1);
0042454a                          var_8 -= 1;
0042454f                          sub_4245c7(eax_58, edi_1);
00424554                          break;
00424500                      }
00424500                      
00424502                      var_8 -= 1;
004244eb                  }
00423be4              }
00423be4              else
00423be4              {
00423bea                  char var_39_1 = 0;
00423bee                  char var_1c_1 = 0;
00423bf2                  char var_1b_1 = 0;
00423bf6                  char var_12_1 = 0;
00423bfa                  char i_1 = 0;
00423bfe                  char var_1a_1 = 0;
00423c02                  void* edi_2 = nullptr;
00423c04                  char var_9_1 = 0;
00423c08                  int32_t var_20_1 = 0;
00423c0b                  int32_t var_24_1 = 0;
00423c0e                  void* var_10_1 = nullptr;
00423c11                  char var_11_1 = 1;
00423c15                  int32_t var_34_1 = 0;
00423cc3                  void* var_2c;
00423cc3                  uint32_t var_28;
00423cc3                  void* eax_8;
00423cc3                  
00423cc3                  do
00423cc3                  {
00423c18                      uint32_t ebx_1 = (uint32_t)esi[1];
00423c1c                      esi = &esi[1];
00423c1c                      
00423c24                      if (data_42d07c <= 1)
00423c24                      {
00423c35                          ecx = data_42ce70;
00423c3e                          uint32_t eax_9;
00423c3e                          (uint8_t)eax_9 =
00423c3e                              *(uint8_t*)(ecx + ((uint32_t)(uint8_t)ebx_1 << 1));
00423c41                          eax_8 = eax_9 & 4;
00423c24                      }
00423c24                      else
00423c24                      {
00423c26                          uint32_t eax_7 = (uint32_t)(uint8_t)ebx_1;
00423c2c                          eax_8 = sub_4179df(eax_7, edx, ecx, eax_7);
00423c32                          ecx = 4;
00423c24                      }
00423c24                      
00423c46                      if (eax_8)
00423c46                      {
00423c4b                          var_24_1 += 1;
00423c55                          var_10_1 = ebx_1 + var_10_1 * 0xa - 0x30;
00423c46                      }
00423c46                      else if (ebx_1 > 0x4e)
00423c5d                      {
00423ca0                          if (ebx_1 == 0x68)
00423ca0                          {
00423cb9                              var_11_1 -= 1;
00423cbc                              var_9_1 -= 1;
00423ca0                          }
00423ca0                          else if (ebx_1 == 0x6c)
00423ca5                          {
00423cb1                              var_11_1 += 1;
00423cb4                              var_9_1 += 1;
00423ca5                          }
00423ca5                          else if (ebx_1 == 0x77)
00423cb4                              var_9_1 += 1;
00423caa                          else
00423cac                              i_1 += 1;
00423c5d                      }
00423c5d                      else if (ebx_1 != 0x4e)
00423c5f                      {
00423c64                          if (ebx_1 == 0x2a)
00423c98                              var_12_1 += 1;
00423c64                          else if (ebx_1 != 0x46)
00423c69                          {
00423c6e                              if (ebx_1 == 0x49)
00423c6e                              {
00423c87                                  if (esi[1] != 0x36 || esi[2] != 0x34)
00423cac                                      i_1 += 1;
00423c87                                  else
00423c87                                  {
00423c89                                      var_34_1 += 1;
00423c8c                                      var_2c = nullptr;
00423c90                                      var_28 = 0;
00423c94                                      esi = &esi[2];
00423c87                                  }
00423c6e                              }
00423c6e                              else if (ebx_1 != 0x4c)
00423cac                                  i_1 += 1;
00423c73                              else
00423c75                                  var_11_1 += 1;
00423c69                          }
00423c5f                      }
00423cc3                  } while (!i_1);
00423cc3                  
00423ccd                  arg2 = esi;
00423cd0                  void* var_48;
00423cd0                  void* var_30;
00423cd0                  
00423cd0                  if (!var_12_1)
00423cd0                  {
00423cd5                      var_48 = arg3;
00423cd8                      void* eax_13 = (char*)arg3 + 4;
00423cdb                      arg3 = eax_13;
00423ce1                      var_30 = *(uint32_t*)((char*)eax_13 - 4);
00423cd0                  }
00423cd0                  
00423ce4                  char var_13_1 = 0;
00423ce4                  
00423cec                  if (!var_9_1)
00423cec                  {
00423cee                      (uint8_t)eax_8 = *(uint8_t*)esi;
00423cee                      
00423cf6                      var_9_1 = (uint8_t)eax_8 == 0x53 || (uint8_t)eax_8 == 0x43 ? 1 : 0xff;
00423cec                  }
00423cec                  
00423d08                  int32_t esi_2 = (uint32_t)*(uint8_t*)arg2 | 0x20;
00423d08                  
00423d11                  if (esi_2 != 0x6e)
00423d11                  {
00423d1b                      int32_t* var_1d8_3;
00423d1b                      uint32_t eax_14;
00423d1b                      
00423d1b                      if (esi_2 == 0x63 || esi_2 == 0x7b)
00423d1b                      {
00423d2c                          var_1d8_3 = arg1;
00423d2f                          var_8 += 1;
00423d32                          eax_14 = sub_4245ad(var_1d8_3);
00423d1b                      }
00423d1b                      else
00423d1b                      {
00423d1d                          var_1d8_3 = arg1;
00423d24                          eax_14 = sub_4245de(&var_8, var_1d8_3);
00423d1b                      }
00423d1b                      
00423d37                      ecx = var_1d8_3;
00423d38                      var_18 = eax_14;
00423d11                  }
00423d11                  
00423d3b                  eax = nullptr;
00423d3b                  
00423d45                  if (var_24_1 && !var_10_1)
00423d45                  {
00424527                  label_424527:
0042452a                      var_8 -= 1;
00424537                      sub_4245c7(var_18, arg1);
0042453e                      break;
00423d45                  }
00423d45                  
00423d4e                  void* ebx_3;
00423d4e                  void* edi_4;
00423d4e                  
00423d4e                  if (esi_2 <= 0x6f)
00423d4e                  {
00423d54                      if (esi_2 == 0x6f)
00423d54                          goto label_424264;
00423d54                      
00423d5d                      if (esi_2 == 0x63)
00423d5d                      {
00423f92                          if (!var_24_1)
00423f92                          {
00423f94                              var_10_1 += 1;
00423f97                              var_24_1 = 1;
00423f92                          }
00423f92                          
00423fa2                          if (var_9_1 > 0)
00423fa4                              var_1a_1 = 1;
00423fa4                          
00423fa8                          edi_4 = &data_430398;
00423fa2                          goto label_4240bd;
00423d5d                      }
00423d5d                      
00423d66                      if (esi_2 == 0x64)
00423d66                          goto label_424264;
00423d66                      
00423d6c                      if (esi_2 > 0x64)
00423d6c                      {
00423d75                          if (esi_2 <= 0x67)
00423d75                          {
00423daf                              void* ebx_4 = var_18;
00423db2                              char var_1c8;
00423db2                              char* esi_3 = &var_1c8;
00423dbb                              int32_t* edi_3;
00423dbb                              
00423dbb                              if (ebx_4 != 0x2d)
00423dbb                              {
00423dce                                  if (ebx_4 == 0x2b)
00423dce                                      goto label_423dd0;
00423dce                                  
00423de7                                  edi_3 = arg1;
00423dbb                              }
00423dbb                              else
00423dbb                              {
00423dbd                                  var_1c8 = (uint8_t)ebx_4;
00423dc3                                  void var_1c7;
00423dc3                                  esi_3 = &var_1c7;
00423dd0                              label_423dd0:
00423dd0                                  edi_3 = arg1;
00423dd3                                  var_10_1 -= 1;
00423dd6                                  var_8 += 1;
00423dda                                  eax = sub_4245ad(edi_3);
00423ddf                                  ebx_4 = eax;
00423de1                                  ecx = edi_3;
00423de2                                  var_18 = ebx_4;
00423dbb                              }
00423dbb                              
00423df7                              if (!var_24_1 || var_10_1 > 0x15d)
00423df9                                  var_10_1 = 0x15d;
00423df9                              
00423e07                              while (true)
00423e07                              {
00423e07                                  BOOL eax_15;
00423e07                                  
00423e07                                  if (data_42d07c <= 1)
00423e07                                  {
00423e1a                                      wchar16 (* eax_16)[0x21];
00423e1a                                      (uint8_t)eax_16 =
00423e1a                                          (**(uint528_t**)&data_42ce70)[ebx_4];
00423e1d                                      eax_15 = eax_16 & 4;
00423e07                                  }
00423e07                                  else
00423e0c                                      eax_15 = sub_4179df(eax, edx, ecx, ebx_4);
00423e0c                                  
00423e22                                  if (!eax_15)
00423e22                                      break;
00423e22                                  
00423e24                                  void* eax_17 = var_10_1;
00423e27                                  var_10_1 -= 1;
00423e27                                  
00423e2c                                  if (!eax_17)
00423e2c                                      break;
00423e2c                                  
00423e2e                                  var_20_1 += 1;
00423e31                                  *(uint8_t*)esi_3 = (uint8_t)ebx_4;
00423e33                                  esi_3 = &esi_3[1];
00423e34                                  var_8 += 1;
00423e38                                  eax = sub_4245ad(edi_3);
00423e3d                                  ebx_4 = eax;
00423e3f                                  ecx = edi_3;
00423e40                                  var_18 = ebx_4;
00423e07                              }
00423e07                              
00423e4b                              if (data_42d080 == (uint8_t)ebx_4)
00423e4b                              {
00423e4d                                  void* eax_18 = var_10_1;
00423e50                                  var_10_1 -= 1;
00423e50                                  
00423e55                                  if (eax_18)
00423e55                                  {
00423e57                                      var_8 += 1;
00423e5b                                      uint32_t eax_19;
00423e5b                                      int32_t edx_1;
00423e5b                                      eax_19 = sub_4245ad(edi_3);
00423e60                                      ebx_4 = eax_19;
00423e62                                      (uint8_t)eax_19 = data_42d080;
00423e67                                      *(uint8_t*)esi_3 = (uint8_t)eax_19;
00423e69                                      int32_t* ecx_4 = edi_3;
00423e6a                                      var_18 = ebx_4;
00423e6d                                      esi_3 = &esi_3[1];
00423e6d                                      
00423e75                                      while (true)
00423e75                                      {
00423e75                                          BOOL eax_20;
00423e75                                          
00423e75                                          if (data_42d07c <= 1)
00423e75                                          {
00423e88                                              wchar16 (* eax_21)[0x21];
00423e88                                              (uint8_t)eax_21 =
00423e88                                                  (**(uint528_t**)&data_42ce70)[ebx_4];
00423e8b                                              eax_20 = eax_21 & 4;
00423e75                                          }
00423e75                                          else
00423e7a                                              eax_20 =
00423e7a                                                  sub_4179df(eax_19, edx_1, ecx_4, ebx_4);
00423e7a                                          
00423e90                                          if (!eax_20)
00423e90                                              break;
00423e90                                          
00423e92                                          void* eax_22 = var_10_1;
00423e95                                          var_10_1 -= 1;
00423e95                                          
00423e9a                                          if (!eax_22)
00423e9a                                              break;
00423e9a                                          
00423e9c                                          var_20_1 += 1;
00423e9f                                          *(uint8_t*)esi_3 = (uint8_t)ebx_4;
00423ea1                                          esi_3 = &esi_3[1];
00423ea2                                          var_8 += 1;
00423ea6                                          eax_19 = sub_4245ad(edi_3);
00423eab                                          ebx_4 = eax_19;
00423ead                                          ecx_4 = edi_3;
00423eae                                          var_18 = ebx_4;
00423e75                                      }
00423e55                                  }
00423e4b                              }
00423e4b                              
00423ec5                              if (var_20_1 && (ebx_4 == 0x65 || ebx_4 == 0x45))
00423ec5                              {
00423ece                                  void* var_10_2 = (char*)var_10_1 - 1;
00423ece                                  
00423ed3                                  if (var_10_1)
00423ed3                                  {
00423ed5                                      *(uint8_t*)esi_3 = 0x65;
00423ed8                                      esi_3 = &esi_3[1];
00423ed9                                      var_8 += 1;
00423edd                                      uint32_t eax_24;
00423edd                                      int32_t edx_2;
00423edd                                      eax_24 = sub_4245ad(edi_3);
00423ee2                                      ebx_4 = eax_24;
00423ee4                                      int32_t* ecx_6 = edi_3;
00423ee8                                      var_18 = ebx_4;
00423ee8                                      
00423eeb                                      if (ebx_4 == 0x2d)
00423eeb                                      {
00423eed                                          *(uint8_t*)esi_3 = (uint8_t)eax_24;
00423eef                                          esi_3 = &esi_3[1];
00423ef7                                      label_423ef7:
00423ef7                                          eax_24 = var_10_2;
00423efa                                          var_10_2 -= 1;
00423efa                                          
00423eff                                          if (eax_24)
00423eff                                              goto label_423f06;
00423eff                                          
00423f01                                          var_10_2 &= eax_24;
00423eeb                                      }
00423eeb                                      else if (ebx_4 == 0x2b)
00423ef5                                          goto label_423ef7;
00423ef5                                      
00423f1c                                      while (true)
00423f1c                                      {
00423f1c                                          BOOL eax_25;
00423f1c                                          
00423f1c                                          if (data_42d07c <= 1)
00423f1c                                          {
00423f2f                                              wchar16 (* eax_26)[0x21];
00423f2f                                              (uint8_t)eax_26 =
00423f2f                                                  (**(uint528_t**)&data_42ce70)[ebx_4];
00423f32                                              eax_25 = eax_26 & 4;
00423f1c                                          }
00423f1c                                          else
00423f21                                              eax_25 =
00423f21                                                  sub_4179df(eax_24, edx_2, ecx_6, ebx_4);
00423f21                                          
00423f37                                          if (!eax_25)
00423f37                                              break;
00423f37                                          
00423f39                                          void* eax_27 = var_10_2;
00423f3c                                          var_10_2 -= 1;
00423f3c                                          
00423f41                                          if (!eax_27)
00423f41                                              break;
00423f41                                          
00423f43                                          var_20_1 += 1;
00423f46                                          *(uint8_t*)esi_3 = (uint8_t)ebx_4;
00423f48                                          esi_3 = &esi_3[1];
00423f06                                      label_423f06:
00423f06                                          var_8 += 1;
00423f0a                                          eax_24 = sub_4245ad(edi_3);
00423f0f                                          ebx_4 = eax_24;
00423f11                                          ecx_6 = edi_3;
00423f12                                          var_18 = ebx_4;
00423f1c                                      }
00423ed3                                  }
00423ec5                              }
00423ec5                              
00423f4b                              var_8 -= 1;
00423f50                              eax = sub_4245c7(ebx_4, edi_3);
00423f5a                              ecx = edi_3;
00423f5a                              
00423f5b                              if (!var_20_1)
00423f5b                                  break;
00423f5b                              
00423f65                              if (!var_12_1)
00423f65                              {
00423f6b                                  result += 1;
00423f6e                                  *(uint8_t*)esi_3 = 0;
00423f81                                  eax =
00423f81                                      data_42d388((int32_t)var_11_1 - 1, var_30, &var_1c8);
00423f65                              }
00423f65                              
00423ec5                              goto label_4244b8;
00423d75                          }
00423d75                          
00423d7a                          if (esi_2 == 0x69)
00423d7a                          {
00423d99                              esi_2 = 0x64;
00423d9a                          label_423d9a:
00423d9a                              ebx_3 = var_18;
00423d9a                              
00423da0                              if (ebx_3 == 0x2d)
00423da0                              {
00423da6                                  var_1b_1 = 1;
00424029                              label_424029:
00424029                                  void* temp6_1 = var_10_1;
00424029                                  var_10_1 -= 1;
00424029                                  
00424032                                  if (temp6_1 != 1 || !var_24_1)
00424032                                  {
0042403d                                      var_8 += 1;
00424040                                      eax = sub_4245ad(arg1);
00424045                                      ebx_3 = eax;
00424047                                      ecx = arg1;
00424048                                      var_18 = ebx_3;
00424032                                  }
00424032                                  else
00424034                                      var_13_1 = 1;
00423da0                              }
00423da0                              else if (ebx_3 == 0x2b)
00424027                                  goto label_424029;
00424027                              
0042404e                              if (ebx_3 != 0x30)
0042404e                                  goto label_42429d;
0042404e                              
00424057                              var_8 += 1;
0042405a                              eax = sub_4245ad(arg1);
0042405f                              ebx_3 = eax;
00424061                              ecx = arg1;
00424065                              var_18 = ebx_3;
0042406d                              int32_t var_1d8_14;
0042406d                              
0042406d                              if ((uint8_t)ebx_3 == 0x78 || (uint8_t)ebx_3 == 0x58)
0042406d                              {
0042409c                                  var_8 += 1;
0042409f                                  eax = sub_4245ad(arg1);
004240a4                                  ecx = arg1;
004240a5                                  ebx_3 = eax;
004240a7                                  var_18 = ebx_3;
004240aa                                  var_1d8_14 = 0x78;
0042406d                              }
0042406d                              else
0042406d                              {
00424072                                  var_20_1 = 1;
00424072                                  
00424079                                  if (esi_2 == 0x78)
00424079                                  {
00424086                                      var_8 -= 1;
0042408a                                      eax = sub_4245c7(ebx_3, arg1);
00424090                                      ecx = arg1;
00424093                                      ebx_3 = 0x30;
00424094                                      goto label_424296;
00424079                                  }
00424079                                  
0042407b                                  var_1d8_14 = 0x6f;
0042406d                              }
0042406d                              
0042407d                              esi_2 = var_1d8_14;
0042407e                              goto label_42429d;
00423d7a                          }
00423d7a                          
00423d7f                          if (esi_2 == 0x6e)
00423d7f                          {
00423d89                              edi_2 = var_8;
00423d89                              
00423d8c                              if (!var_12_1)
00423d8c                                  goto label_424492;
00423d8c                              
00423d8c                              goto label_4244b8;
00423d7f                          }
00423d6c                      }
00423d6c                      
00423fdf                  label_423fdf:
00423fdf                      
00423fe2                      if ((uint32_t)*(uint8_t*)arg2 != var_18)
00423fe2                          goto label_424527;
00423fe2                      
00423fe8                      var_19 -= 1;
00423fe8                      
00423fef                      if (!var_12_1)
00423ff8                          arg3 = var_48;
00423ff8                      
00423fef                      goto label_4244b8;
00423d4e                  }
00423d4e                  
00423fb4                  eax = esi_2 - 0x70;
00423fb4                  
00423fb7                  if (esi_2 != 0x70)
00423fb7                  {
00423fc0                      if (eax == 3)
00423fc0                      {
004240b2                          if (var_9_1 > 0)
004240b4                              var_1a_1 = 1;
004240b4                          
004240b8                          edi_4 = " \t-\r]";
004240b8                          goto label_4240bd;
00423fc0                      }
00423fc0                      
00423fc6                      void* eax_32 = (char*)eax - 4;
00423fc7                      eax = (char*)eax_32 - 1;
00423fc7                      
00423fc8                      if (eax_32 == 1)
00423fc8                          goto label_424264;
00423fc8                      
00423fce                      void* temp3_1 = eax;
00423fce                      eax -= 3;
00423fce                      
00423fd1                      if (temp3_1 == 3)
00423fd1                          goto label_423d9a;
00423fd1                      
00423fda                      if (eax != 3)
00423fda                          goto label_423fdf;
00423fda                      
00424004                      if (var_9_1 > 0)
00424006                          var_1a_1 = 1;
00424006                      
0042400d                      edi_4 = &arg2[1];
0042400e                      arg2 = edi_4;
0042400e                      
00424014                      if (*(uint8_t*)edi_4 == 0x5e)
00424014                      {
0042401c                          edi_4 += 1;
004240bd                      label_4240bd:
004240bd                          var_1c_1 = 0xff;
00424014                      }
00424014                      
004240c9                      char var_68[0xb];
004240c9                      char* eax_35;
004240c9                      uint32_t edx_3;
004240c9                      eax_35 = sub_423620(&var_68, 0, 0x20);
004240c9                      
004240da                      if (esi_2 != 0x7b || *(uint8_t*)edi_4 != 0x5d)
004240e5                          (uint8_t)edx_3 = var_39_1;
004240da                      else
004240da                      {
004240dc                          (uint8_t)edx_3 = 0x5d;
004240de                          edi_4 += 1;
004240df                          char var_5d_1 = 0x20;
004240da                      }
004240da                      
004240e8                      while (true)
004240e8                      {
004240e8                          (uint8_t)eax_35 = *(uint8_t*)edi_4;
004240e8                          
004240ec                          if ((uint8_t)eax_35 == 0x5d)
004240ec                              break;
004240ec                          
004240ee                          edi_4 += 1;
004240f5                          int32_t __saved_ebp;
004240f5                          char* ebx_2;
004240f5                          
004240f5                          if ((uint8_t)eax_35 == 0x2d && (uint8_t)edx_3)
004240f5                          {
004240f7                              char ecx_8 = *(uint8_t*)edi_4;
004240f7                              
004240fc                              if (ecx_8 != 0x5d)
004240fc                              {
004240fe                                  edi_4 += 1;
004240fe                                  
00424101                                  if ((uint8_t)edx_3 >= ecx_8)
00424101                                  {
00424107                                      (uint8_t)eax_35 = (uint8_t)edx_3;
00424109                                      (uint8_t)edx_3 = ecx_8;
00424101                                  }
00424101                                  else
00424103                                      (uint8_t)eax_35 = ecx_8;
00424103                                  
0042410d                                  if ((uint8_t)edx_3 <= (uint8_t)eax_35)
0042410d                                  {
0042410f                                      edx_3 = (uint32_t)(uint8_t)edx_3;
00424117                                      int32_t i_3 = (uint32_t)(uint8_t)eax_35 - edx_3 + 1;
0042412e                                      int32_t i_2;
0042412e                                      
0042412e                                      do
0042412e                                      {
0042411f                                          (uint8_t)ebx_2 = 1;
00424124                                          (uint8_t)ebx_2 = 1 << ((uint8_t)edx_3 & 7);
0042412a                                          *(uint8_t*)(
0042412a                                              &__saved_ebp + (edx_3 >> 3) - 0x64) |=
0042412a                                              (uint8_t)ebx_2;
0042412c                                          edx_3 += 1;
0042412d                                          i_2 = i_3;
0042412d                                          i_3 -= 1;
0042412e                                      } while (i_2 != 1);
0042410d                                  }
0042410d                                  
00424130                                  (uint8_t)edx_3 = 0;
00424132                                  continue;
004240fc                              }
004240f5                          }
004240f5                          
00424134                          uint32_t ecx_10 = (uint32_t)(uint8_t)eax_35;
00424137                          (uint8_t)edx_3 = (uint8_t)eax_35;
0042413e                          (uint8_t)ebx_2 = 1;
00424143                          (uint8_t)ebx_2 = 1 << ((uint8_t)ecx_10 & 7);
00424149                          *(uint8_t*)(&__saved_ebp + (ecx_10 >> 3) - 0x64) |=
00424149                              (uint8_t)ebx_2;
004240e8                      }
004240e8                      
00424150                      if (!*(uint8_t*)edi_4)
00424150                          break;
00424150                      
0042415a                      if (esi_2 == 0x7b)
0042415c                          arg2 = edi_4;
0042415c                      
00424162                      char* esi_6 = var_30;
00424165                      var_8 -= 1;
0042416c                      char* var_34_2 = esi_6;
0042416f                      edx = sub_4245c7(var_18, arg1);
00424175                      ecx = arg1;
00424175                      
0042417a                      while (true)
0042417a                      {
0042417a                          if (var_24_1)
0042417a                          {
0042417c                              eax = var_10_1;
0042417f                              var_10_1 -= 1;
0042417f                              
00424184                              if (!eax)
00424184                                  break;
0042417a                          }
0042417a                          
0042418a                          var_8 += 1;
0042418e                          uint32_t eax_40 = sub_4245ad(arg1);
00424197                          var_18 = eax_40;
00424197                          
0042419a                          if (eax_40 != 0xffffffff)
0042419a                          {
004241a8                              edx = 1 << ((uint8_t)eax_40 & 7);
004241b4                              ecx = (int32_t)var_68[eax_40 >> 3] ^ (int32_t)var_1c_1;
004241b4                              
004241b8                              if (ecx & edx)
004241b8                              {
004241be                                  if (var_12_1)
004241be                                  {
00424212                                      var_34_2 = &var_34_2[1];
00424215                                      continue;
004241be                                  }
004241be                                  else
004241be                                  {
004241c4                                      if (!var_1a_1)
004241c4                                      {
00424207                                          *(uint8_t*)esi_6 = (uint8_t)eax_40;
00424209                                          esi_6 = &esi_6[1];
004241c4                                      }
004241c4                                      else
004241c4                                      {
004241c6                                          wchar16 (* ecx_17)[0x21] = data_42ce70;
004241cc                                          char var_3c = (uint8_t)eax_40;
004241cc                                          
004241d7                                          if (*(uint8_t*)(&(*(uint528_t*)ecx_17)[(uint32_t)(
004241d7                                              uint8_t)eax_40] + 1) & 0x80)
004241d7                                          {
004241d9                                              var_8 += 1;
004241e3                                              char var_3b_1 = sub_4245ad(arg1);
004241d7                                          }
004241d7                                          
004241f4                                          int16_t var_42;
004241f4                                          ecx = sub_426a24(&var_42, &var_3c, data_42d07c);
00424200                                          *(uint16_t*)esi_6 = var_42;
00424204                                          esi_6 = &esi_6[2];
004241c4                                      }
004241c4                                      
0042420a                                      var_30 = esi_6;
0042420d                                      continue;
004241be                                  }
004241b8                              }
0042419a                          }
0042419a                          
0042421a                          var_8 -= 1;
0042421f                          eax = sub_4245c7(eax_40, arg1);
00424225                          ecx = arg1;
00424225                          break;
0042417a                      }
0042417a                      
00424229                      if (var_34_2 == esi_6)
00424229                          break;
00424229                      
00424233                      if (!var_12_1)
00424233                      {
00424239                          result += 1;
00424239                          
00424240                          if (esi_2 != 0x63)
00424240                          {
0042424d                              if (!var_1a_1)
00424258                                  *(uint8_t*)var_30 = 0;
0042424d                              else
0042424f                                  *(uint16_t*)var_30 = 0;
00424240                          }
00424233                      }
00424233                      
00424150                      goto label_4244b8;
00423fb7                  }
00423fb7                  
00424260                  var_11_1 = 1;
00424264              label_424264:
00424264                  ebx_3 = var_18;
00424264                  
0042426a                  if (ebx_3 != 0x2d)
0042426a                  {
00424275                      if (ebx_3 != 0x2b)
00424275                          goto label_42429d;
00424275                      
00424275                      goto label_424277;
0042426a                  }
0042426a                  
0042426c                  var_1b_1 = 1;
00424277              label_424277:
00424277                  void* temp4_1 = var_10_1;
00424277                  var_10_1 -= 1;
00424277                  
00424280                  if (temp4_1 != 1 || !var_24_1)
00424280                  {
0042428b                      var_8 += 1;
0042428e                      eax = sub_4245ad(arg1);
00424293                      ecx = arg1;
00424294                      ebx_3 = eax;
00424296                  label_424296:
00424296                      var_18 = ebx_3;
00424296                      goto label_42429d;
00424280                  }
00424280                  
00424282                  var_13_1 = 1;
0042429d              label_42429d:
0042429d                  
0042429d                  if (!var_34_1)
0042429d                  {
004243b6                      if (!var_13_1)
004243b6                      {
004243c4                          while (true)
004243c4                          {
004243c4                              int32_t edi_7;
004243c4                              
004243c4                              if (esi_2 == 0x78 || esi_2 == 0x70)
004243c4                              {
00424407                                  BOOL eax_56;
00424407                                  
00424407                                  if (data_42d07c <= 1)
00424407                                  {
0042441d                                      wchar16 (* eax_57)[0x21];
0042441d                                      (uint8_t)eax_57 =
0042441d                                          (**(uint528_t**)&data_42ce70)[ebx_3];
00424420                                      eax_56 = eax_57 & 0x80;
00424407                                  }
00424407                                  else
0042440f                                      eax_56 = sub_4179df(eax, edx, ecx, ebx_3);
0042440f                                  
00424427                                  if (!eax_56)
00424427                                  {
00424463                                  label_424463:
00424463                                      var_8 -= 1;
00424467                                      eax = sub_4245c7(ebx_3, arg1);
0042446d                                      ecx = arg1;
0042446d                                      break;
00424427                                  }
00424427                                  
00424429                                  void* var_1d8_26 = ebx_3;
0042442a                                  edi_7 = edi_2 << 4;
0042442d                                  eax = sub_424576(var_1d8_26);
00424432                                  ebx_3 = eax;
00424434                                  ecx = var_1d8_26;
00424435                                  var_18 = ebx_3;
004243c4                              }
004243c4                              else
004243c4                              {
004243cd                                  if (data_42d07c <= 1)
004243cd                                  {
004243e0                                      wchar16 (* eax_55)[0x21];
004243e0                                      (uint8_t)eax_55 =
004243e0                                          (**(uint528_t**)&data_42ce70)[ebx_3];
004243e3                                      eax = eax_55 & 4;
004243cd                                  }
004243cd                                  else
004243cd                                  {
004243d2                                      eax = sub_4179df(eax, edx, ecx, ebx_3);
004243d8                                      ecx = 4;
004243cd                                  }
004243cd                                  
004243e8                                  if (!eax)
004243e8                                      goto label_424463;
004243e8                                  
004243ed                                  if (esi_2 != 0x6f)
004243fc                                      edi_7 = edi_2 * 0xa;
004243ed                                  else
004243ed                                  {
004243f2                                      if (ebx_3 >= 0x38)
004243f2                                          goto label_424463;
004243f2                                      
004243f4                                      edi_7 = edi_2 << 3;
004243ed                                  }
004243c4                              }
004243c4                              
00424438                              var_20_1 += 1;
0042443f                              edi_2 = edi_7 + ebx_3 - 0x30;
0042443f                              
00424443                              if (var_24_1)
00424443                              {
00424445                                  void* temp9_1 = var_10_1;
00424445                                  var_10_1 -= 1;
00424445                                  
00424448                                  if (temp9_1 == 1)
00424448                                      break;
00424443                              }
00424443                              
0042444d                              var_8 += 1;
00424450                              eax = sub_4245ad(arg1);
00424455                              ebx_3 = eax;
00424457                              ecx = arg1;
00424458                              var_18 = ebx_3;
004243c4                          }
004243b6                      }
004243b6                      
00424472                      if (var_1b_1)
00424474                          edi_2 = -(edi_2);
0042429d                  }
0042429d                  else
0042429d                  {
004242a7                      if (!var_13_1)
004242a7                      {
004242b0                          while (true)
004242b0                          {
004242b0                              int32_t var_2c_1;
004242b0                              int32_t var_28_1;
004242b0                              
004242b0                              if (esi_2 != 0x78)
004242b0                              {
00424308                                  BOOL eax_49;
00424308                                  
00424308                                  if (data_42d07c <= 1)
00424308                                  {
0042431b                                      wchar16 (* eax_50)[0x21];
0042431b                                      (uint8_t)eax_50 =
0042431b                                          (**(uint528_t**)&data_42ce70)[ebx_3];
0042431e                                      eax_49 = eax_50 & 4;
00424308                                  }
00424308                                  else
0042430d                                      eax_49 = sub_4179df(eax, edx, ecx, ebx_3);
0042430d                                  
00424323                                  if (!eax_49)
00424323                                  {
00424385                                  label_424385:
00424385                                      var_8 -= 1;
00424389                                      eax = sub_4245c7(ebx_3, arg1);
0042438f                                      ecx = arg1;
0042438f                                      break;
00424323                                  }
00424323                                  
00424328                                  int32_t eax_52;
00424328                                  int32_t edx_7;
00424328                                  
00424328                                  if (esi_2 != 0x6f)
00424328                                  {
00424349                                      eax_52 = __allmul(var_2c, var_28, 0xa, 0);
0042434e                                      var_2c_1 = eax_52;
00424351                                      var_28_1 = edx_7;
00424328                                  }
00424328                                  else
00424328                                  {
0042432d                                      if (ebx_3 >= 0x38)
0042432d                                          goto label_424385;
0042432d                                      
00424338                                      eax_52 = __allshl(var_2c, var_28, 3);
0042434e                                      var_2c_1 = eax_52;
00424351                                      var_28_1 = edx_7;
00424328                                  }
004242b0                              }
004242b0                              else
004242b0                              {
004242b9                                  BOOL eax_44;
004242b9                                  
004242b9                                  if (data_42d07c <= 1)
004242b9                                  {
004242cf                                      wchar16 (* eax_45)[0x21];
004242cf                                      (uint8_t)eax_45 =
004242cf                                          (**(uint528_t**)&data_42ce70)[ebx_3];
004242d2                                      eax_44 = eax_45 & 0x80;
004242b9                                  }
004242b9                                  else
004242c1                                      eax_44 = sub_4179df(eax, edx, ecx, ebx_3);
004242c1                                  
004242d9                                  if (!eax_44)
004242d9                                      goto label_424385;
004242d9                                  
004242e8                                  int32_t eax_47;
004242e8                                  int32_t edx_5;
004242e8                                  eax_47 = __allshl(var_2c, var_28, 4);
004242ed                                  void* var_1d8_23 = ebx_3;
004242ee                                  var_2c_1 = eax_47;
004242f1                                  var_28_1 = edx_5;
004242f9                                  ebx_3 = sub_424576(var_1d8_23);
004242fb                                  ecx = var_1d8_23;
004242fc                                  var_18 = ebx_3;
004242b0                              }
004242b0                              
00424354                              var_20_1 += 1;
0042435a                              edx = HIGHD((int64_t)((char*)ebx_3 - 0x30));
0042435a                              eax = LOWD((int64_t)((char*)ebx_3 - 0x30));
0042435b                              var_2c = var_2c_1 + eax;
0042435e                              var_28 = var_28_1 + edx;
0042435e                              
00424365                              if (var_24_1)
00424365                              {
00424367                                  void* temp10_1 = var_10_1;
00424367                                  var_10_1 -= 1;
00424367                                  
0042436a                                  if (temp10_1 == 1)
0042436a                                      break;
00424365                              }
00424365                              
0042436f                              var_8 += 1;
00424372                              eax = sub_4245ad(arg1);
00424377                              ebx_3 = eax;
00424379                              ecx = arg1;
0042437a                              var_18 = ebx_3;
004242b0                          }
004242a7                      }
004242a7                      
00424394                      if (var_1b_1)
00424394                      {
004243a2                          int32_t ecx_22 = var_28 + 0;
004243a5                          var_2c = -(var_2c);
004243a8                          ecx = -(ecx_22);
004243aa                          var_28 = ecx;
00424394                      }
0042429d                  }
0042429d                  
00424479                  if (esi_2 == 0x46)
0042447b                      var_20_1 = 0;
0042447b                  
00424483                  if (!var_20_1)
00424483                      break;
00424483                  
0042448d                  if (var_12_1)
0042448d                      goto label_4244b8;
0042448d                  
0042448f                  result += 1;
00424492              label_424492:
00424492                  
00424496                  if (!var_34_1)
00424496                  {
004244af                      if (!var_11_1)
004244b5                          *(uint16_t*)var_30 = (uint16_t)edi_2;
004244af                      else
004244b1                          *(uint32_t*)var_30 = edi_2;
004244b1                      
004244af                      goto label_4244b8;
00424496                  }
00424496                  
0042449e                  *(uint32_t*)var_30 = var_2c;
004244a0                  ecx = var_28;
004244a3                  *(uint32_t*)((char*)var_30 + 4) = ecx;
004244b8              label_4244b8:
004244b8                  var_19 += 1;
004244bb                  arg2 = &arg2[1];
004244be                  esi = arg2;
00423be4              }
00423be4              
00424509              if (var_18 == 0xffffffff)
00424509              {
0042450e                  if (*(uint8_t*)esi != 0x25)
0042450e                      goto label_42455d;
0042450e                  
00424510                  eax = arg2;
00424510                  
00424517                  if (*(uint8_t*)((char*)eax + 1) != 0x6e)
00424517                      goto label_42455d;
00424517                  
00424519                  esi = eax;
00424509              }
00424509              
0042451b              (uint8_t)eax = *(uint8_t*)esi;
0042451b              
0042451f              if (!(uint8_t)eax)
0042451f                  break;
0042451f              
00423b7b              edi_1 = arg1;
00423b87          }
00423b70      }
00423b70      
0042455b      if (var_18 != 0xffffffff)
0042456e          return result;
0042456e      
0042455d  label_42455d:
0042455d      
00424567      if (!result && var_19 == (uint8_t)result)
00424569          return 0xffffffff;
00424569      
00424575      return result;
00423b51  }


00424576    int32_t sub_424576(int32_t arg1)

00424576  {
0042457e      BOOL eax_1;
0042457e      int32_t result;
0042457e      
0042457e      if (data_42d07c <= 1)
0042457e      {
00424590          result = arg1;
00424599          wchar16 (* eax_2)[0x21];
00424599          (uint8_t)eax_2 = (**(uint528_t**)&data_42ce70)[result];
0042459c          eax_1 = eax_2 & 4;
0042457e      }
0042457e      else
0042457e      {
00424580          result = arg1;
00424587          int32_t eax;
00424587          int32_t ecx;
00424587          int32_t edx;
00424587          eax_1 = sub_4179df(eax, edx, ecx, result);
0042457e      }
0042457e      
004245a1      if (eax_1)
004245ac          return result;
004245ac      
004245a6      return (result & 0xffffffdf) - 7;
00424576  }


004245ad    uint32_t sub_4245ad(int32_t* arg1)

004245ad  {
004245b1      int32_t temp0 = arg1[1];
004245b1      arg1[1] -= 1;
004245b1      
004245b4      if (temp0 - 1 < 0)
004245c6          return sub_41741a(arg1);
004245c6      
004245b6      char* ecx = *(uint32_t*)arg1;
004245b8      uint32_t result = (uint32_t)*(uint8_t*)ecx;
004245bc      *(uint32_t*)arg1 = &ecx[1];
004245be      return result;
004245ad  }


004245c7    void sub_4245c7(int32_t arg1, int32_t* arg2)

004245c7  {
004245cc      if (arg1 != 0xffffffff)
004245d6          sub_4173ac(arg1, arg2);
004245c7  }


004245de    uint32_t sub_4245de(int32_t* arg1, int32_t* arg2)

004245de  {
004245fb      uint32_t result;
004245fb      bool cond:0_1;
004245fb      
004245fb      do
004245fb      {
004245e8          *(uint32_t*)arg1 += 1;
004245ea          result = sub_4245ad(arg2);
004245f8          cond:0_1 = sub_426aec(result);
004245fb      } while (cond:0_1);
00424601      return result;
004245de  }


00424602    int32_t sub_424602(enum WIN32_ERROR arg1, char* arg2, uint32_t arg3)

00424602  {
00424617      int32_t eax_3;
00424617      void* ebx_1;
00424617      int32_t esi_3;
00424617      
00424617      if (arg1 < data_430f20)
00424617      {
00424627          ebx_1 = &(&data_430e20)[arg1 >> 5];
0042462e          esi_3 = (arg1 & ERROR_GEN_FAILURE) << 3;
00424633          (uint8_t)eax_3 = *(uint8_t*)(*(uint32_t*)ebx_1 + esi_3 + 4);
00424617      }
00424617      
00424639      if (arg1 >= data_430f20 || !((uint8_t)eax_3 & 1))
00424639      {
00424796          data_4307d8 = 0;
0042479d          data_4307d4 = 9;
00424639      }
00424639      else
00424639      {
00424644          uint32_t numberOfBytesWritten_1 = 0;
00424647          int32_t var_14_1 = 0;
00424647          
0042464a          if (!arg3)
0042464c              return 0;
0042464c          
00424655          if ((uint8_t)eax_3 & 0x20)
0042465b              sub_41b825(arg1, 0, FILE_END);
0042465b          
00424665          int32_t* eax_5 = *(uint32_t*)ebx_1 + esi_3;
0042466b          uint32_t numberOfBytesWritten;
0042466b          
0042466b          if (!(eax_5[1] & 0x80))
0042466b          {
00424747              if (!WriteFile(*(uint32_t*)eax_5, arg2, arg3, &numberOfBytesWritten, nullptr))
0042475a                  arg1 = GetLastError();
00424747              else
00424747              {
0042474c                  arg1 = NO_ERROR;
0042474f                  numberOfBytesWritten_1 = numberOfBytesWritten;
00424747              }
00424747              
004246fe          label_4246fe:
004246fe              
00424700              if (numberOfBytesWritten_1)
00424791                  return numberOfBytesWritten_1 - var_14_1;
00424791              
00424709              if (!arg1)
00424709                  goto label_42476c;
00424709              
00424711              if (arg1 != ERROR_ACCESS_DENIED)
00424762                  sub_42149e(arg1);
00424711              else
00424711              {
00424713                  data_4307d4 = 9;
0042471d                  data_4307d8 = 5;
00424711              }
0042466b          }
0042466b          else
0042466b          {
00424677              char* var_8_1 = arg2;
0042467a              arg1 = NO_ERROR;
0042467a              
0042467d              if (arg3 > 0)
0042467d              {
004246f7                  do
004246f7                  {
00424683                      uint8_t buffer[0x404];
00424683                      uint8_t (* eax_7)[0x404] = &buffer;
00424683                      
00424692                      while (var_8_1 - arg2 < arg3)
00424692                      {
00424694                          char* ecx_3 = var_8_1;
00424697                          var_8_1 = &var_8_1[1];
0042469a                          (uint8_t)ecx_3 = *(uint8_t*)ecx_3;
0042469a                          
0042469f                          if ((uint8_t)ecx_3 == 0xa)
0042469f                          {
004246a1                              var_14_1 += 1;
004246a4                              *(uint8_t*)eax_7 = 0xd;
004246a7                              eax_7 = &(*(uint4096_t*)eax_7)[1];
0042469f                          }
0042469f                          
004246a8                          *(uint8_t*)eax_7 = (uint8_t)ecx_3;
004246aa                          eax_7 = &(*(uint4096_t*)eax_7)[1];
004246aa                          
004246bb                          if ((char*)eax_7 - &buffer >= 0x400)
004246bb                              break;
00424692                      }
00424692                      
004246c5                      uint32_t nNumberOfBytesToWrite = (char*)eax_7 - &buffer;
004246c5                      
004246e2                      if (!WriteFile((*(uint32_t*)ebx_1)[(arg1 & 0x1f) * 2], &buffer, 
004246e2                          nNumberOfBytesToWrite, &numberOfBytesWritten, nullptr))
004246e2                      {
0042472d                          arg1 = GetLastError();
00424730                          break;
004246e2                      }
004246e2                      
004246e4                      uint32_t numberOfBytesWritten_2 = numberOfBytesWritten;
004246e7                      numberOfBytesWritten_1 += numberOfBytesWritten_2;
004246e7                      
004246ec                      if (numberOfBytesWritten_2 < nNumberOfBytesToWrite)
004246ec                          break;
004246f7                  } while (var_8_1 - arg2 < arg3);
004246f7                  
004246e2                  goto label_4246fe;
0042467d              }
0042467d              
0042476c          label_42476c:
0042476c              
00424779              if (*(uint8_t*)(*(uint32_t*)ebx_1 + esi_3 + 4) & 0x40
00424779                      && *(uint8_t*)arg2 == 0x1a)
0042464c                  return 0;
0042464c              
0042477f              data_4307d4 = 0x1c;
00424789              data_4307d8 = 0;
0042466b          }
00424639      }
00424639      
004247a7      return 0xffffffff;
00424602  }


004247af    enum WIN32_ERROR sub_4247af(int32_t arg1)

004247af  {
004247d1      if (arg1 < data_430f20
004247d1          && *(uint8_t*)((&data_430e20)[arg1 >> 5] + ((arg1 & 0x1f) << 3) + 4) & 1)
004247d1      {
004247e3          enum WIN32_ERROR result;
004247e3          
004247e3          if (FlushFileBuffers(sub_423908(arg1)))
004247ed              result = NO_ERROR;
004247e3          else
004247e5              result = GetLastError();
004247e5          
004247f1          if (!result)
00424805              return result;
00424805          
004247f3          data_4307d8 = result;
004247d1      }
004247d1      
004247f8      data_4307d4 = 9;
00424802      return ~NO_ERROR;
004247af  }


00424806    int32_t sub_424806(int16_t arg1 @ x87control, int32_t arg2, int32_t arg3)

00424806  {
00424809      int32_t ecx;
00424809      int32_t var_8 = ecx;
0042480c      int16_t x87status;
0042480c      int16_t temp0;
0042480c      temp0 = __fnstcw_memmem16(arg1);
0042480c      (uint16_t)var_8 = temp0;
00424826      int32_t result = (sub_424851((uint16_t)var_8) & ~arg3) | (arg2 & arg3);
00424833      int16_t x87control;
00424833      int16_t x87status_1;
00424833      x87control = __fldcw_memmem16(sub_4248e3(result));
0042483a      return result;
00424806  }


0042483b    int32_t sub_42483b(int32_t arg1, int32_t arg2)

0042483b  {
00424850      int16_t x87control;
00424850      return sub_424806(x87control, arg1, arg2 & 0xfff7ffff);
0042483b  }


00424851    int32_t sub_424851(int16_t arg1) __pure

00424851  {
00424856      int32_t result = 0;
00424856      
0042485d      if ((uint8_t)arg1 & 1)
00424861          result = 0x10;
00424861      
00424865      if ((uint8_t)arg1 & 4)
00424867          (uint8_t)result |= 8;
00424867      
0042486c      if ((uint8_t)arg1 & 8)
0042486e          (uint8_t)result |= 4;
0042486e      
00424873      if ((uint8_t)arg1 & 0x10)
00424875          (uint8_t)result |= 2;
00424875      
0042487a      if ((uint8_t)arg1 & 0x20)
0042487c          (uint8_t)result |= 1;
0042487c      
00424881      if ((uint8_t)arg1 & 2)
00424883          result |= 0x80000;
00424883      
00424888      uint32_t ecx = (uint32_t)arg1;
00424898      int32_t edx_1 = ecx & 0xc00;
00424898      
0042489f      if (edx_1)
0042489f      {
004248a7          if (edx_1 == 0x400)
004248bd              *(uint8_t*)((char*)result)[1] |= 1;
004248a7          else if (edx_1 == 0x800)
004248b9              result |= 0x200;
004248af          else if (edx_1 == 0xc00)
004248b5              result |= 0x300;
0042489f      }
0042489f      
004248c0      int32_t ecx_1 = ecx & 0x300;
004248c0      
004248c3      if (!ecx_1)
004248d0          result |= 0x20000;
004248c3      else if (ecx_1 == 0x200)
004248c9          result |= 0x10000;
004248c9      
004248db      if (!(*(uint8_t*)((char*)arg1)[1] & 0x10))
004248e2          return result;
004248e2      
004248dd      return result | 0x40000;
00424851  }


004248e3    int32_t sub_4248e3(int32_t arg1) __pure

004248e3  {
004248e8      int32_t result = 0;
004248e8      
004248ee      if ((uint8_t)arg1 & 0x10)
004248f2          result = 1;
004248f2      
004248f6      if ((uint8_t)arg1 & 8)
004248f8          (uint8_t)result |= 4;
004248f8      
004248fd      if ((uint8_t)arg1 & 4)
004248ff          (uint8_t)result |= 8;
004248ff      
00424904      if ((uint8_t)arg1 & 2)
00424906          (uint8_t)result |= 0x10;
00424906      
0042490b      if ((uint8_t)arg1 & 1)
0042490d          (uint8_t)result |= 0x20;
0042490d      
00424915      if (arg1 & 0x80000)
00424917          (uint8_t)result |= 2;
00424917      
00424920      int32_t ecx_1 = arg1 & 0x300;
00424920      
00424927      if (ecx_1)
00424927      {
0042492f          if (ecx_1 == 0x100)
00424943              *(uint8_t*)((char*)result)[1] |= 4;
0042492f          else if (ecx_1 == 0x200)
0042493e              *(uint8_t*)((char*)result)[1] |= 8;
00424933          else if (ecx_1 == 0x300)
00424939              *(uint8_t*)((char*)result)[1] |= 0xc;
00424927      }
00424927      
00424948      int32_t ecx_3 = arg1 & 0x30000;
00424948      
0042494e      if (!ecx_3)
0042495c          result |= 0x300;
0042494e      else if (ecx_3 == 0x10000)
00424958          result |= 0x200;
00424958      
00424966      if (arg1 & 0x40000)
00424968          *(uint8_t*)((char*)result)[1] |= 0x10;
00424968      
0042496b      return result;
004248e3  }


0042496c    int32_t sub_42496c(int32_t arg1, int32_t arg2)

0042496c  {
00424975      int32_t temp0 = (int64_t)arg2 / 0x20;
00424975      
00424993      if (*(uint32_t*)(arg1 + (temp0 << 2))
00424993              & ~(0xffffffff << (0x1f - (char)((int64_t)arg2 % 0x20))))
004249b4          return 0;
004249b4      
00424995      int32_t esi_1 = temp0 + 1;
00424995      
00424999      if (esi_1 >= 3)
004249b0          return 1;
004249b0      
0042499b      int32_t* eax_5 = arg1 + (esi_1 << 2);
0042499b      
004249a1      while (true)
004249a1      {
004249a1          if (*(uint32_t*)eax_5)
004249b4              return 0;
004249b4          
004249a3          esi_1 += 1;
004249a4          eax_5 = &eax_5[1];
004249a4          
004249aa          if (esi_1 >= 3)
004249b0              return 1;
004249a1      }
0042496c  }


004249b5    int32_t sub_4249b5(int32_t arg1, int32_t arg2)

004249b5  {
004249c4      int32_t temp0 = (int64_t)arg2 / 0x20;
004249cf      int32_t* edi = arg1 + (temp0 << 2);
004249e0      int32_t i =
004249e0          sub_426b3f(*(uint32_t*)edi, 1 << (0x1f - (char)((int64_t)arg2 % 0x20)), edi);
004249e8      int32_t esi_1 = temp0 - 1;
004249e8      
004249e9      if (temp0 - 1 >= 0)
004249e9      {
004249eb          int32_t* edi_1 = arg1 + (esi_1 << 2);
004249eb          
004249f0          while (i)
004249f0          {
004249f7              i = sub_426b3f(*(uint32_t*)edi_1, 1, edi_1);
004249ff              esi_1 -= 1;
00424a00              edi_1 -= 4;
00424a00              
00424a05              if (esi_1 < 0)
00424a05                  break;
004249f0          }
004249e9      }
004249e9      
00424a0a      return i;
004249b5  }


00424a0b    int32_t sub_424a0b(int32_t arg1, int32_t* arg2)

00424a0b  {
00424a0e      int32_t ecx;
00424a0e      int32_t var_8 = ecx;
00424a0f      int32_t var_c = ecx;
00424a16      void* edi = (char*)arg2 - 1;
00424a1c      int32_t result = 0;
00424a29      int32_t temp0 = (int64_t)((char*)edi + 1) / 0x20;
00424a31      int32_t eax_5;
00424a31      int32_t edx_1;
00424a31      edx_1 = HIGHD((int64_t)((char*)edi + 1));
00424a31      eax_5 = LOWD((int64_t)((char*)edi + 1));
00424a3d      int32_t* eax_7 = arg1 + (temp0 << 2);
00424a3d      
00424a4c      if (*(uint32_t*)eax_7 & 1 << (0x1f - (char)(COMBINE(edx_1, eax_5) % 0x20))
00424a4c              && !sub_42496c(arg1, (char*)edi + 2))
00424a68          result = sub_4249b5(arg1, edi);
00424a68      
00424a79      *(uint32_t*)eax_7 &= 0xffffffff << (0x1f - (char)(COMBINE(edx_1, eax_5) % 0x20));
00424a79      
00424a81      if (temp0 + 1 < 3)
00424a8d          __builtin_memset(arg1 + ((temp0 + 1) << 2), 0, (3 - (temp0 + 1)) << 2);
00424a8d      
00424a96      return result;
00424a0b  }


00424a97    int32_t* sub_424a97(int32_t arg1, int32_t* arg2)

00424a97  {
00424a97      int32_t* result = arg2;
00424aa2      int32_t* ecx_1 = arg1 - result;
00424aa4      int32_t i_1 = 3;
00424aae      int32_t i;
00424aae      
00424aae      do
00424aae      {
00424aa7          *(uint32_t*)((char*)ecx_1 + result) = *(uint32_t*)result;
00424aaa          result = &result[1];
00424aad          i = i_1;
00424aad          i_1 -= 1;
00424aae      } while (i != 1);
00424ab1      return result;
00424a97  }


00424ab2    int32_t sub_424ab2(int32_t* arg1)

00424ab2  {
00424ab9      *(uint32_t*)arg1 = 0;
00424ab9      void* edi_1 = &arg1[1];
00424aba      *(uint32_t*)edi_1 = 0;
00424abb      *(uint32_t*)((char*)edi_1 + 4) = 0;
00424abd      return 0;
00424ab2  }


00424abe    int32_t sub_424abe(int32_t* arg1)

00424abe  {
00424abe      int32_t* eax = arg1;
00424abe      
00424ad0      for (int32_t i = 0; i < 3; )
00424ad0      {
00424ac7          if (*(uint32_t*)eax)
00424ad8              return 0;
00424ad8          
00424ac9          i += 1;
00424aca          eax = &eax[1];
00424ad0      }
00424ad0      
00424ad5      return 1;
00424abe  }


00424ad9    int32_t* sub_424ad9(int32_t* arg1, int32_t arg2)

00424ad9  {
00424ae7      int32_t* edi = arg1;
00424af1      int32_t i_1 = 3;
00424af8      int32_t temp0 = (int64_t)arg2 / 0x20;
00424b01      char temp1 = (char)((int64_t)arg2 % 0x20);
00424b03      arg2 = 0;
00424b31      int32_t i;
00424b31      
00424b31      do
00424b31      {
00424b0f          int32_t eax_6 = *(uint32_t*)edi;
00424b1f          *(uint32_t*)edi = eax_6 >> temp1 | arg2;
00424b26          edi = &edi[1];
00424b2b          i = i_1;
00424b2b          i_1 -= 1;
00424b2e          arg2 = (eax_6 & ~(0xffffffff << temp1)) << (0x20 - temp1);
00424b31      } while (i != 1);
00424b38      int32_t ebx_1 = 2;
00424b3d      int32_t* ecx_5 = 8;
00424b5f      int32_t* result;
00424b5f      int32_t* temp3_1;
00424b5f      
00424b5f      do
00424b5f      {
00424b43          if (ebx_1 < temp0)
00424b43          {
00424b54              result = arg1;
00424b57              *(uint32_t*)((char*)ecx_5 + result) = 0;
00424b43          }
00424b43          else
00424b43          {
00424b4c              result = *(uint32_t*)((char*)ecx_5 - (temp0 << 2) + arg1);
00424b4f              *(uint32_t*)((char*)ecx_5 + arg1) = result;
00424b43          }
00424b43          
00424b5b          ebx_1 -= 1;
00424b5c          temp3_1 = ecx_5;
00424b5c          ecx_5 -= 4;
00424b5f      } while ((char*)temp3_1 - 4 >= 0);
00424b65      return result;
00424ad9  }


00424b66    int32_t sub_424b66(int16_t* arg1, int32_t* arg2, int32_t* arg3)

00424b66  {
00424b72      uint32_t ecx = (uint32_t)arg1[5];
00424b78      int16_t* ecx_1 = ecx & 0x8000;
00424b84      int32_t var_10 = *(uint32_t*)((char*)arg1 + 6);
00424b87      int32_t ecx_3 = *(uint32_t*)((char*)arg1 + 2);
00424b96      int32_t ebx_2 = (ecx & 0x7fff) - 0x3fff;
00424ba8      uint32_t var_8 = (uint32_t)*(uint16_t*)arg1 << 0x10;
00424bab      int32_t result;
00424bab      int32_t esi_1;
00424bab      
00424bab      if (ebx_2 != 0xffffc001)
00424bab      {
00424bdb          void var_1c;
00424bdb          sub_424a97(&var_1c, &var_10);
00424bdb          
00424bf1          if (sub_424a0b(&var_10, arg3[2]))
00424bf3              ebx_2 += 1;
00424bf3          
00424bf4          int32_t eax_5 = arg3[1];
00424bf4          
00424bfe          if (ebx_2 >= eax_5 - arg3[2])
00424bfe          {
00424c0e              if (ebx_2 <= eax_5)
00424c0e              {
00424c1c                  sub_424a97(&var_10, &var_1c);
00424c26                  sub_424ad9(&var_10, eax_5 - ebx_2);
00424c32                  sub_424a0b(&var_10, arg3[2]);
00424c40                  sub_424ad9(&var_10, arg3[3] + 1);
00424c45                  goto label_424c48;
00424c0e              }
00424c0e              
00424c51              if (ebx_2 < *(uint32_t*)arg3)
00424c51              {
00424c81                  *(uint8_t*)((char*)var_10)[3] &= 0x7f;
00424c89                  esi_1 = arg3[5] + ebx_2;
00424c8b                  sub_424ad9(&var_10, arg3[3]);
00424c92                  result = 0;
00424c51              }
00424c51              else
00424c51              {
00424c57                  sub_424ab2(&var_10);
00424c5f                  *(uint8_t*)((char*)var_10)[3] |= 0x80;
00424c67                  sub_424ad9(&var_10, arg3[3]);
00424c72                  esi_1 = arg3[5] + *(uint32_t*)arg3;
00424bcd                  result = 1;
00424c51              }
00424bfe          }
00424bfe          else
00424bfe          {
00424c04              sub_424ab2(&var_10);
00424c48          label_424c48:
00424c48              esi_1 = 0;
00424bcd              result = 2;
00424bfe          }
00424bab      }
00424bab      else
00424bab      {
00424bb0          esi_1 = 0;
00424bb0          
00424bbb          if (sub_424abe(&var_10))
00424c92              result = 0;
00424bbb          else
00424bbb          {
00424bc5              sub_424ab2(&var_10);
00424bcd              result = 2;
00424bbb          }
00424bab      }
00424bab      
00424c9a      int32_t edi_1 = arg3[4];
00424ca2      int32_t ecx_12 = -(ecx_1);
00424cae      int32_t esi_7 =
00424cae          esi_1 << (0x1f - (char)arg3[3]) | ((ecx_12 - ecx_12) & 0x80000000) | var_10;
00424cae      
00424cb4      if (edi_1 == 0x40)
00424cb4      {
00424cbc          arg2[1] = esi_7;
00424cbf          *(uint32_t*)arg2 = ecx_3;
00424cb4      }
00424cb4      else if (edi_1 == 0x20)
00424ccb          *(uint32_t*)arg2 = esi_7;
00424ccb      
00424cd1      return result;
00424b66  }


00424cd2    int32_t sub_424cd2(int16_t* arg1, int32_t* arg2)

00424cd2  {
00424ce7      return sub_424b66(arg1, arg2, 0x4303a0);
00424cd2  }


00424ce8    int32_t sub_424ce8(int16_t* arg1, int32_t* arg2)

00424ce8  {
00424cfd      return sub_424b66(arg1, arg2, 0x4303b8);
00424ce8  }


00424cfe    int32_t sub_424cfe(int32_t* arg1, void* arg2)

00424cfe  {
00424d15      void var_10;
00424d15      sub_4257d5(&var_10, &arg2, arg2, 0, 0, 0, 0);
00424d2a      return sub_424cd2(&var_10, arg1);
00424cfe  }


00424d2b    int32_t sub_424d2b(int32_t* arg1, void* arg2)

00424d2b  {
00424d42      void var_10;
00424d42      sub_4257d5(&var_10, &arg2, arg2, 0, 0, 0, 0);
00424d57      return sub_424ce8(&var_10, arg1);
00424d2b  }


00424d58    char* sub_424d58(char* arg1, char* arg2, int32_t arg3)

00424d58  {
00424d5b      int32_t edx = arg3;
00424d5f      char* ebx = arg2;
00424d63      char* esi = arg1;
00424d66      char* ecx = *(uint32_t*)(edx + 0xc);
00424d6d      *(uint8_t*)esi = 0x30;
00424d72      char* result = &esi[1];
00424d72      
00424d74      if (ebx > 0)
00424d74      {
00424d76          arg1 = ebx;
00424d79          ebx = nullptr;
00424d90          char* i;
00424d90          
00424d90          do
00424d90          {
00424d7b              (uint8_t)edx = *(uint8_t*)ecx;
00424d7b              
00424d7f              if (!(uint8_t)edx)
00424d89                  edx = 0x30;
00424d7f              else
00424d7f              {
00424d81                  edx = (int32_t)(uint8_t)edx;
00424d84                  ecx = &ecx[1];
00424d7f              }
00424d7f              
00424d8a              *(uint8_t*)result = (uint8_t)edx;
00424d8c              result = &result[1];
00424d8d              i = arg1;
00424d8d              arg1 -= 1;
00424d90          } while (i != 1);
00424d92          edx = arg3;
00424d74      }
00424d74      
00424d95      *(uint8_t*)result = 0;
00424d95      
00424d9f      if (ebx >= 0 && *(uint8_t*)ecx >= 0x35)
00424d9f      {
00424da1          while (true)
00424da1          {
00424da1              result -= 1;
00424da1              
00424da5              if (*(uint8_t*)result != 0x39)
00424da5                  break;
00424da5              
00424da7              *(uint8_t*)result = 0x30;
00424da1          }
00424da1          
00424dac          *(uint8_t*)result += 1;
00424d9f      }
00424d9f      
00424db1      if (*(uint8_t*)esi != 0x31)
00424dc2          return sub_424ef0(esi, &esi[1], sub_41e7d0(&esi[1]) + 1);
00424dc2      
00424db3      *(uint32_t*)(edx + 4) += 1;
00424dce      return result;
00424d58  }


00424dcf    int32_t sub_424dcf()

00424dcf  {
00424ddf      int32_t var_10;
00424ddf      void arg_4;
00424ddf      sub_424e33(&var_10, &arg_4);
00424de9      int16_t* var_1c_1 = &data_430b68;
00424dee      int32_t var_20_1 = 0;
00424df0      int32_t var_24 = 0x11;
00424df7      int32_t var_30 = var_10;
00424df7      void var_2c;
00424df7      void* edi = &var_2c;
00424df7      void var_c;
00424df7      void* esi = &var_c;
00424df8      *(uint32_t*)edi = *(uint32_t*)esi;
00424df9      *(uint16_t*)((char*)edi + 4) = *(uint16_t*)((char*)esi + 4);
00424e00      data_430b90 = sub_426ce0(var_30);
00424e0f      data_430b88 = (int32_t)data_430b6a;
00424e1c      data_430b8c = (int32_t)data_430b68;
00424e21      data_430b94 = 0x430b6c;
00424e32      return &data_430b88;
00424dcf  }


00424e33    int32_t* sub_424e33(int32_t* arg1, int32_t* arg2)

00424e33  {
00424e36      int32_t ecx;
00424e36      int32_t var_8 = ecx;
00424e3d      int32_t eax;
00424e3d      (uint16_t)eax = *(uint16_t*)((char*)arg2 + 6);
00424e50      int32_t ecx_3 = eax >> 4 & 0x7ff;
00424e58      int32_t edx_1 = *(uint32_t*)arg2;
00424e5a      uint32_t ebx = (uint32_t)(uint16_t)ecx_3;
00424e62      int32_t eax_3 = arg2[1] & 0xfffff;
00424e69      int32_t var_8_1 = 0x80000000;
00424e6c      int32_t edi_1;
00424e6c      
00424e6c      if (ebx)
00424e6c      {
00424e70          edi_1 = ebx == 0x7ff ? 0x7fff : ecx_3 + 0x3c00;
00424e70          
00424e70          goto label_424eac;
00424e6c      }
00424e6c      
00424e89      int32_t* result;
00424e89      
00424e89      if (eax_3 || edx_1)
00424e89      {
00424e99          edi_1 = ecx_3 + 0x3c01;
00424e9f          var_8_1 = 0;
00424eac      label_424eac:
00424eac          result = arg1;
00424eaf          int32_t ecx_7 = edx_1 >> 0x15 | eax_3 << 0xb | var_8_1;
00424eb5          result[1] = ecx_7;
00424eb8          *(uint32_t*)result = edx_1 << 0xb;
00424eb8          
00424ebc          while (!(0x80000000 & ecx_7))
00424ebc          {
00424ebe              int32_t edx_3 = *(uint32_t*)result;
00424ec7              int32_t ebx_3 = edx_3 >> 0x1f | (ecx_7 * 2);
00424ecc              *(uint32_t*)result = edx_3 * 2;
00424ece              result[1] = ebx_3;
00424ed1              edi_1 += 0xffff;
00424ed7              ecx_7 = ebx_3;
00424ebc          }
00424ebc          
00424ee0          result[2] = (eax & 0x8000) | (uint16_t)edi_1;
00424e89      }
00424e89      else
00424e89      {
00424e8b          result = arg1;
00424e8e          result[1] = 0;
00424e91          *(uint32_t*)result = 0;
00424e93          result[2] = 0;
00424e89      }
00424e89      
00424ee8      return result;
00424e33  }

00424ee9                             cc cc cc cc cc cc cc                                                           .......

00424ef0    char* sub_424ef0(char* arg1, char* arg2, int32_t arg3)

00424ef0  {
00424ef5      char* esi = arg2;
00424efb      char* edi = arg1;
00424f0a      uint32_t eax_1;
00424f0a      
00424f0a      if (edi > esi && edi < &esi[arg3])
00424f0a      {
00425088          void* esi_1 = &esi[arg3 - 4];
0042508c          void* edi_1 = &edi[arg3 - 4];
00425096          int32_t edx_2;
00425096          uint32_t ecx_4;
00425096          
00425096          if (!(edi_1 & 3))
00425096          {
00425098              ecx_4 = arg3 >> 2;
0042509b              edx_2 = arg3 & 3;
0042509b              
004250a1              if (ecx_4 >= 8)
004250a1              {
004250a4                  edi_1 = __builtin_memcpy((char*)edi_1 - (ecx_4 << 2), 
004250a4                      (char*)esi_1 - (ecx_4 << 2), ecx_4 << 2);
004250a4                  
004250a7                  switch (edx_2)
004250a7                  {
004251e6                      case 0:
004251e6                      {
004251e6                          return arg1;
004251e6                          break;
004251e6                      }
004250a7                      case 1:
004250a7                      {
004250a7                          goto label_4251e8;
004250a7                      }
004250a7                      case 2:
004250a7                      {
004250a7                          goto label_4251f8;
004250a7                      }
004250a7                      case 3:
004250a7                      {
004250a7                          goto label_42520c;
004250a7                      }
004250a7                  }
004250a1              }
00425096          }
00425096          else if (arg3 < 4)
004250c6              switch (arg3)
004250c6              {
004251e6                  case 0:
004251e6                  {
004251e6                      return arg1;
004251e6                      break;
004251e6                  }
004251e8                  case 1:
004251e8                  {
004251e8                  label_4251e8:
004251e8                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
004251eb                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
004251f4                      return arg1;
004251e8                      break;
004251e8                  }
004251f8                  case 2:
004251f8                  {
004251f8                  label_4251f8:
004251f8                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
004251fb                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
004251fe                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 2);
00425201                      *(uint8_t*)((char*)edi_1 + 2) = (uint8_t)eax_1;
0042520a                      return arg1;
004251f8                      break;
004251f8                  }
0042520c                  case 3:
0042520c                  {
0042520c                  label_42520c:
0042520c                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
0042520f                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
00425212                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 2);
00425215                      *(uint8_t*)((char*)edi_1 + 2) = (uint8_t)eax_1;
00425218                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 1);
0042521b                      *(uint8_t*)((char*)edi_1 + 1) = (uint8_t)eax_1;
00425224                      return arg1;
0042520c                      break;
0042520c                  }
004250c6              }
004250c6          else
004250c6          {
004250c8              eax_1 = edi_1 & 3;
004250cb              int32_t ecx_6 = arg3 - eax_1;
004250cb              
004250cd              switch (jump_table_4250d8[eax_1])
004250cd              {
004250e8                  case 0x4250e8:
004250e8                  {
004250e8                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
004250eb                      edx_2 = 3 & ecx_6;
004250ed                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
004250f0                      esi_1 -= 1;
004250f1                      ecx_4 = ecx_6 >> 2;
004250f4                      edi_1 -= 1;
004250f4                      
004250f8                      if (ecx_4 >= 8)
004250f8                      {
004250fb                          edi_1 = __builtin_memcpy((char*)edi_1 - (ecx_4 << 2), 
004250fb                              (char*)esi_1 - (ecx_4 << 2), ecx_4 << 2);
004250fb                          
004250fe                          switch (edx_2)
004250fe                          {
004251e6                              case 0:
004251e6                              {
004251e6                                  return arg1;
004251e6                                  break;
004251e6                              }
004250fe                              case 1:
004250fe                              {
004250fe                                  goto label_4251e8;
004250fe                              }
004250fe                              case 2:
004250fe                              {
004250fe                                  goto label_4251f8;
004250fe                              }
004250fe                              case 3:
004250fe                              {
004250fe                                  goto label_42520c;
004250fe                              }
004250fe                          }
004250f8                      }
004250e8                      break;
004250e8                  }
00425108                  case 0x425108:
00425108                  {
00425108                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
0042510b                      edx_2 = 3 & ecx_6;
0042510d                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
00425110                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 2);
00425113                      ecx_4 = ecx_6 >> 2;
00425116                      *(uint8_t*)((char*)edi_1 + 2) = (uint8_t)eax_1;
00425119                      esi_1 -= 2;
0042511c                      edi_1 -= 2;
0042511c                      
00425122                      if (ecx_4 >= 8)
00425122                      {
00425125                          edi_1 = __builtin_memcpy((char*)edi_1 - (ecx_4 << 2), 
00425125                              (char*)esi_1 - (ecx_4 << 2), ecx_4 << 2);
00425125                          
00425128                          switch (edx_2)
00425128                          {
004251e6                              case 0:
004251e6                              {
004251e6                                  return arg1;
004251e6                                  break;
004251e6                              }
00425128                              case 1:
00425128                              {
00425128                                  goto label_4251e8;
00425128                              }
00425128                              case 2:
00425128                              {
00425128                                  goto label_4251f8;
00425128                              }
00425128                              case 3:
00425128                              {
00425128                                  goto label_42520c;
00425128                              }
00425128                          }
00425122                      }
00425108                      break;
00425108                  }
00425130                  case 0x425130:
00425130                  {
00425130                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 3);
00425133                      edx_2 = 3 & ecx_6;
00425135                      *(uint8_t*)((char*)edi_1 + 3) = (uint8_t)eax_1;
00425138                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 2);
0042513b                      *(uint8_t*)((char*)edi_1 + 2) = (uint8_t)eax_1;
0042513e                      (uint8_t)eax_1 = *(uint8_t*)((char*)esi_1 + 1);
00425141                      ecx_4 = ecx_6 >> 2;
00425144                      *(uint8_t*)((char*)edi_1 + 1) = (uint8_t)eax_1;
00425147                      esi_1 -= 3;
0042514a                      edi_1 -= 3;
0042514a                      
00425150                      if (ecx_4 >= 8)
00425150                      {
00425157                          edi_1 = __builtin_memcpy((char*)edi_1 - (ecx_4 << 2), 
00425157                              (char*)esi_1 - (ecx_4 << 2), ecx_4 << 2);
00425157                          
0042515a                          switch (edx_2)
0042515a                          {
004251e6                              case 0:
004251e6                              {
004251e6                                  return arg1;
004251e6                                  break;
004251e6                              }
0042515a                              case 1:
0042515a                              {
0042515a                                  goto label_4251e8;
0042515a                              }
0042515a                              case 2:
0042515a                              {
0042515a                                  goto label_4251f8;
0042515a                              }
0042515a                              case 3:
0042515a                              {
0042515a                                  goto label_42520c;
0042515a                              }
0042515a                          }
00425150                      }
00425130                      break;
00425130                  }
004250cd              }
004250c6          }
004250c6          
004251c7          switch (edx_2)
004251c7          {
004251e6              case 0:
004251e6              {
004251e6                  return arg1;
004251e6                  break;
004251e6              }
004251c7              case 1:
004251c7              {
004251c7                  goto label_4251e8;
004251c7              }
004251c7              case 2:
004251c7              {
004251c7                  goto label_4251f8;
004251c7              }
004251c7              case 3:
004251c7              {
004251c7                  goto label_42520c;
004251c7              }
004251c7          }
00424f0a      }
00424f0a      
00424f16      uint32_t ecx_1;
00424f16      int32_t edx_1;
00424f16      
00424f16      if (edi & 3)
00424f16      {
00424f36          if (arg3 < 4)
00424f44              /* jump -> *(uint32_t*)(((arg3 - 4) << 2) + &data_425048) */
00424f44          
00424f38          eax_1 = edi & 3;
00424f3b          int32_t ecx_3 = arg3 - 4 + eax_1;
00424f3b          
00424f3d          switch (jump_table_424f50[eax_1])
00424f3d          {
00424f60              case 0x424f60:
00424f60              {
00424f60                  edx_1 = 3 & ecx_3;
00424f62                  (uint8_t)eax_1 = *(uint8_t*)esi;
00424f64                  *(uint8_t*)edi = (uint8_t)eax_1;
00424f66                  (uint8_t)eax_1 = esi[1];
00424f69                  edi[1] = (uint8_t)eax_1;
00424f6c                  (uint8_t)eax_1 = esi[2];
00424f6f                  ecx_1 = ecx_3 >> 2;
00424f72                  edi[2] = (uint8_t)eax_1;
00424f75                  esi = &esi[3];
00424f78                  edi = &edi[3];
00424f78                  
00424f7e                  if (ecx_1 >= 8)
00424f7e                  {
00424f80                      edi = __builtin_memcpy(edi, esi, ecx_1 << 2);
00424f80                      
00424f82                      switch (edx_1)
00424f82                      {
0042504e                          case 0:
0042504e                          {
0042504e                              return arg1;
0042504e                              break;
0042504e                          }
00424f82                          case 1:
00424f82                          {
00424f82                              goto label_425050;
00424f82                          }
00424f82                          case 2:
00424f82                          {
00424f82                              goto label_42505c;
00424f82                          }
00424f82                          case 3:
00424f82                          {
00424f82                              goto label_425070;
00424f82                          }
00424f82                      }
00424f7e                  }
00424f60                  break;
00424f60              }
00424f8c              case 0x424f8c:
00424f8c              {
00424f8c                  edx_1 = 3 & ecx_3;
00424f8e                  (uint8_t)eax_1 = *(uint8_t*)esi;
00424f90                  *(uint8_t*)edi = (uint8_t)eax_1;
00424f92                  (uint8_t)eax_1 = esi[1];
00424f95                  ecx_1 = ecx_3 >> 2;
00424f98                  edi[1] = (uint8_t)eax_1;
00424f9b                  esi = &esi[2];
00424f9e                  edi = &edi[2];
00424f9e                  
00424fa4                  if (ecx_1 >= 8)
00424fa4                  {
00424fa6                      edi = __builtin_memcpy(edi, esi, ecx_1 << 2);
00424fa6                      
00424fa8                      switch (edx_1)
00424fa8                      {
0042504e                          case 0:
0042504e                          {
0042504e                              return arg1;
0042504e                              break;
0042504e                          }
00424fa8                          case 1:
00424fa8                          {
00424fa8                              goto label_425050;
00424fa8                          }
00424fa8                          case 2:
00424fa8                          {
00424fa8                              goto label_42505c;
00424fa8                          }
00424fa8                          case 3:
00424fa8                          {
00424fa8                              goto label_425070;
00424fa8                          }
00424fa8                      }
00424fa4                  }
00424f8c                  break;
00424f8c              }
00424fb0              case 0x424fb0:
00424fb0              {
00424fb0                  edx_1 = 3 & ecx_3;
00424fb2                  (uint8_t)eax_1 = *(uint8_t*)esi;
00424fb4                  *(uint8_t*)edi = (uint8_t)eax_1;
00424fb6                  esi = &esi[1];
00424fb7                  ecx_1 = ecx_3 >> 2;
00424fba                  edi = &edi[1];
00424fba                  
00424fbe                  if (ecx_1 >= 8)
00424fbe                  {
00424fc0                      edi = __builtin_memcpy(edi, esi, ecx_1 << 2);
00424fc0                      
00424fc2                      switch (edx_1)
00424fc2                      {
0042504e                          case 0:
0042504e                          {
0042504e                              return arg1;
0042504e                              break;
0042504e                          }
00424fc2                          case 1:
00424fc2                          {
00424fc2                              goto label_425050;
00424fc2                          }
00424fc2                          case 2:
00424fc2                          {
00424fc2                              goto label_42505c;
00424fc2                          }
00424fc2                          case 3:
00424fc2                          {
00424fc2                              goto label_425070;
00424fc2                          }
00424fc2                      }
00424fbe                  }
00424fb0                  break;
00424fb0              }
00424f3d          }
00424f16      }
00424f16      else
00424f16      {
00424f18          ecx_1 = arg3 >> 2;
00424f1b          edx_1 = arg3 & 3;
00424f1b          
00424f21          if (ecx_1 >= 8)
00424f21          {
00424f23              edi = __builtin_memcpy(edi, esi, ecx_1 << 2);
00424f23              
00424f25              switch (edx_1)
00424f25              {
0042504e                  case 0:
0042504e                  {
0042504e                      return arg1;
0042504e                      break;
0042504e                  }
00424f25                  case 1:
00424f25                  {
00424f25                      goto label_425050;
00424f25                  }
00424f25                  case 2:
00424f25                  {
00424f25                      goto label_42505c;
00424f25                  }
00424f25                  case 3:
00424f25                  {
00424f25                      goto label_425070;
00424f25                  }
00424f25              }
00424f21          }
00424f16      }
00424f16      
00424f4c      switch (ecx_1)
00424f4c      {
00424f4c          case 0:
00424f4c          {
00424f4c              goto label_42502f;
00424f4c          }
00424f4c          case 1:
00424f4c          {
00424f4c              goto label_425020;
00424f4c          }
00424f4c          case 2:
00424f4c          {
00424f4c              goto label_425018;
00424f4c          }
00424f4c          case 3:
00424f4c          {
00424f4c              goto label_425010;
00424f4c          }
00424f4c          case 4:
00424f4c          {
00424f4c              goto label_425008;
00424f4c          }
00424f4c          case 5:
00424f4c          {
00424f4c              goto label_425000;
00424f4c          }
00424f4c          case 6:
00424f4c          {
00424f4c              goto label_424ff8;
00424f4c          }
00424ff0          case 7:
00424ff0          {
00424ff0              *(uint32_t*)(edi + (ecx_1 << 2) - 0x1c) =
00424ff0                  *(uint32_t*)(esi + (ecx_1 << 2) - 0x1c);
00424ff8          label_424ff8:
00424ff8              *(uint32_t*)(edi + (ecx_1 << 2) - 0x18) =
00424ff8                  *(uint32_t*)(esi + (ecx_1 << 2) - 0x18);
00425000          label_425000:
00425000              *(uint32_t*)(edi + (ecx_1 << 2) - 0x14) =
00425000                  *(uint32_t*)(esi + (ecx_1 << 2) - 0x14);
00425008          label_425008:
00425008              *(uint32_t*)(edi + (ecx_1 << 2) - 0x10) =
00425008                  *(uint32_t*)(esi + (ecx_1 << 2) - 0x10);
00425010          label_425010:
00425010              *(uint32_t*)(edi + (ecx_1 << 2) - 0xc) =
00425010                  *(uint32_t*)(esi + (ecx_1 << 2) - 0xc);
00425018          label_425018:
00425018              *(uint32_t*)(edi + (ecx_1 << 2) - 8) = *(uint32_t*)(esi + (ecx_1 << 2) - 8);
00425020          label_425020:
00425020              *(uint32_t*)(edi + (ecx_1 << 2) - 4) = *(uint32_t*)(esi + (ecx_1 << 2) - 4);
00425024              eax_1 = ecx_1 << 2;
0042502b              esi = &esi[eax_1];
0042502d              edi = &edi[eax_1];
0042502f          label_42502f:
0042502f              
0042502f              switch (edx_1)
0042502f              {
0042504e                  case 0:
0042504e                  {
0042504e                      return arg1;
0042504e                      break;
0042504e                  }
00425050                  case 1:
00425050                  {
00425050                  label_425050:
00425050                      (uint8_t)eax_1 = *(uint8_t*)esi;
00425052                      *(uint8_t*)edi = (uint8_t)eax_1;
0042505a                      return arg1;
00425050                      break;
00425050                  }
0042505c                  case 2:
0042505c                  {
0042505c                  label_42505c:
0042505c                      (uint8_t)eax_1 = *(uint8_t*)esi;
0042505e                      *(uint8_t*)edi = (uint8_t)eax_1;
00425060                      (uint8_t)eax_1 = esi[1];
00425063                      edi[1] = (uint8_t)eax_1;
0042506c                      return arg1;
0042505c                      break;
0042505c                  }
00425070                  case 3:
00425070                  {
00425070                  label_425070:
00425070                      (uint8_t)eax_1 = *(uint8_t*)esi;
00425072                      *(uint8_t*)edi = (uint8_t)eax_1;
00425074                      (uint8_t)eax_1 = esi[1];
00425077                      edi[1] = (uint8_t)eax_1;
0042507a                      (uint8_t)eax_1 = esi[2];
0042507d                      edi[2] = (uint8_t)eax_1;
00425086                      return arg1;
00425070                      break;
00425070                  }
0042502f              }
00424ff0              break;
00424ff0          }
00424f4c      }
00424ef0  }

00424f4b                                   90                                                                         .
00424f53                                                           90 60 4f 42 00 8c 4f 42 00 b0 4f 42 00                     .`OB..OB..OB.
00424f89                             8d 49 00                                                                       .I.
00424faf                                               90                                                                 .
00424fc9                             8d 49 00                                                                       .I.
00424fcc  uint32_t jump_table_424fcc[0x8] = 
00424fcc  {
00424fcc      [0x0] =  0x0042502f
00424fd0      [0x1] =  0x0042501c
00424fd4      [0x2] =  0x00425014
00424fd8      [0x3] =  0x0042500c
00424fdc      [0x4] =  0x00425004
00424fe0      [0x5] =  0x00424ffc
00424fe4      [0x6] =  0x00424ff4
00424fe8      [0x7] =  0x00424fec
00424fec  }

00425036                                                                    8b ff                                                ..
00425038  uint32_t jump_table_425038[0x4] = 
00425038  {
00425038      [0x0] =  0x00425048
0042503c      [0x1] =  0x00425050
00425040      [0x2] =  0x0042505c
00425044      [0x3] =  0x00425070
00425048  }

0042504f                                               90                                                                 .
0042505b                                                                                   90                                         .
0042506d                                         8d 49 00                                                               .I.
00425087                       90                                                                                 .
004250ae                                            8b ff                                                                ..
004250b9                                                                             8d 49 00                                       .I.
004250db                                                                                   90 e8 50 42 00                             ..PB.
004250e0  08 51 42 00 30 51 42 00                                                                          .QB.0QB.
00425105                 8d 49 00                                                                               .I.
0042512f                                               90                                                                 .
00425161     8d 49 00 84 51 42 00 8c 51 42 00 94 51 42 00 9c 51 42 00 a4 51 42 00 ac 51 42 00 b4 51 42 00   .I..QB..QB..QB..QB..QB..QB..QB.
00425180  uint32_t jump_table_425180[0x1] = 
00425180  {
00425180      [0x0] =  0x004251c7
00425184  }

00425184              8b 44 8e 1c 89 44 8f 1c 8b 44 8e 18 89 44 8f 18 8b 44 8e 14 89 44 8f 14 8b 44 8e 10      .D...D...D...D...D...D...D..
004251a0  89 44 8f 10 8b 44 8e 0c 89 44 8f 0c 8b 44 8e 08 89 44 8f 08 8b 44 8e 04 89 44 8f 04 8d 04 8d 00  .D...D...D...D...D...D...D......
004251c0  00 00 00 03 f0 03 f8                                                                             .......
004251ce                                            8b ff                                                                ..
004251d0  uint32_t jump_table_4251d0[0x4] = 
004251d0  {
004251d0      [0x0] =  0x004251e0
004251d4      [0x1] =  0x004251e8
004251d8      [0x2] =  0x004251f8
004251dc      [0x3] =  0x0042520c
004251e0  }

004251e7                       90                                                                                 .
004251f5                                                                 8d 49 00                                               .I.
0042520b                                   90                                                                         .

00425225    int32_t sub_425225()

00425225  {
0042522d      return sub_41720a(2);
00425225  }


0042522e    int32_t sub_42522e(uint32_t arg1)

0042522e  {
0042523a      uint32_t CodePage = sub_4253c7(arg1);
0042523a      
0042524b      if (CodePage != data_430bc0)
0042524b      {
00425255          if (!CodePage)
00425255          {
004253b1          label_4253b1:
004253b1              sub_425444();
00425255          }
00425255          else
00425255          {
0042525b              void* edx_1 = nullptr;
0042525d              void* eax = &data_4303d8;
0042525d              
00425264              while (true)
00425264              {
00425264                  if (*(uint32_t*)eax == CodePage)
00425264                  {
004252e7                      void* i = nullptr;
004252ea                      int32_t esi_2 = edx_1 * 0x30;
004252ed                      *(uint8_t*)__builtin_memset(0x430ce0, 0, 0x100) = 0;
004252ee                      char* ebx_1 = esi_2 + 0x4303e8;
004252ee                      
00425331                      do
00425331                      {
004252f7                          char* ecx_2 = ebx_1;
004252f7                          
004252f9                          if (*(uint8_t*)ebx_1)
004252f9                          {
00425325                              do
00425325                              {
004252fb                                  (uint8_t)edx_1 = ecx_2[1];
004252fb                                  
00425300                                  if (!(uint8_t)edx_1)
00425300                                      break;
00425300                                  
00425302                                  uint32_t eax_2 = (uint32_t)*(uint8_t*)ecx_2;
00425305                                  uint32_t edi_5 = (uint32_t)(uint8_t)edx_1;
00425305                                  
0042530a                                  if (eax_2 <= edi_5)
0042530a                                  {
0042530f                                      (uint8_t)edx_1 = *(uint8_t*)((char*)i + 0x4303d0);
0042530f                                      
0042531e                                      do
0042531e                                      {
00425315                                          *(uint8_t*)(eax_2 + 0x430ce1) |= (uint8_t)edx_1;
0042531b                                          eax_2 += 1;
0042531e                                      } while (eax_2 <= edi_5);
0042530a                                  }
0042530a                                  
00425321                                  ecx_2 = &ecx_2[2];
00425325                              } while (*(uint8_t*)ecx_2);
004252f9                          }
004252f9                          
00425327                          i += 1;
0042532a                          ebx_1 = &ebx_1[8];
00425331                      } while (i < 4);
00425331                      
00425336                      data_430bdc = 1;
00425341                      data_430bc0 = CodePage;
00425346                      int32_t eax_4 = sub_425411(CodePage);
00425356                      data_430bd0 = *(uint32_t*)(esi_2 + 0x4303dc);
00425356                      void* edi_6 = &data_430bd4;
00425356                      void* esi_4 = esi_2 + 0x4303e0;
00425357                      *(uint32_t*)edi_6 = *(uint32_t*)esi_4;
00425359                      data_430de4 = eax_4;
0042535e                      *(uint32_t*)((char*)edi_6 + 4) = *(uint32_t*)((char*)esi_4 + 4);
0042535e                      break;
00425264                  }
00425264                  
00425266                  eax += 0x30;
00425269                  edx_1 += 1;
00425269                  
0042526f                  if (eax >= 0x4304c8)
0042526f                  {
00425276                      CPINFO cPInfo;
00425276                      BOOL eax_1;
00425276                      uint32_t edx_2;
00425276                      eax_1 = GetCPInfo(CodePage, &cPInfo);
00425276                      
0042527f                      if (eax_1 != 1)
0042527f                      {
004253af                          if (!data_430b98)
004253bf                              return 0xffffffff;
004253bf                          
004253af                          goto label_4253b1;
0042527f                      }
0042527f                      
0042528f                      bool cond:2_1 = cPInfo.MaxCharSize <= 1;
00425293                      data_430bc0 = CodePage;
0042529b                      *(uint8_t*)__builtin_memset(0x430ce0, 0, 0x100) = 0;
0042529c                      data_430de4 = 0;
0042529c                      
004252a2                      if (cond:2_1)
00425397                          data_430bdc = 0;
004252a2                      else
004252a2                      {
004252ac                          if (cPInfo.LeadByte[0])
004252ac                          {
004252b2                              var_15;
004252b2                              void* ecx_1 = &var_15;
004252b2                              
00425367                              do
00425367                              {
004252b5                                  (uint8_t)edx_2 = *(uint8_t*)ecx_1;
004252b5                                  
004252b9                                  if (!(uint8_t)edx_2)
004252b9                                      break;
004252b9                                  
004252c8                                  for (uint32_t i_1 =
004252c8                                          (uint32_t)*(uint8_t*)((char*)ecx_1 - 1); 
004252c8                                          i_1 <= (uint32_t)(uint8_t)edx_2; i_1 += 1)
004252ce                                      *(uint8_t*)(i_1 + 0x430ce1) |= 4;
004252ce                                  
00425362                                  ecx_1 += 2;
00425367                              } while (*(uint8_t*)((char*)ecx_1 - 1));
004252ac                          }
004252ac                          
0042537d                          for (void* i_2 = 1; i_2 < 0xff; i_2 += 1)
00425370                              *(uint8_t*)((char*)i_2 + 0x430ce1) |= 8;
00425370                          
00425386                          data_430de4 = sub_425411(CodePage);
0042538b                          data_430bdc = 1;
004252a2                      }
004252a2                      
004253a4                      data_430bd0 = 0;
004253a4                      void* edi_9 = &data_430bd4;
004253a5                      *(uint32_t*)edi_9 = 0;
004253a6                      *(uint32_t*)((char*)edi_9 + 4) = 0;
004253a4                      goto label_4253b6;
0042526f                  }
00425264              }
00425255          }
00425255          
004253b6      label_4253b6:
004253b6          sub_42546d();
0042524b      }
0042524b      
004253bb      return 0;
0042522e  }


004253c7    int32_t sub_4253c7(int32_t arg1)

004253c7  {
004253c7      int32_t result = arg1;
004253cb      data_430b98 = 0;
004253cb      
004253d5      if (result == 0xfffffffe)
004253d5      {
004253d7          data_430b98 = 1;
004253e1          /* tailcall */
004253e1          return GetOEMCP();
004253d5      }
004253d5      
004253ea      if (result == 0xfffffffd)
004253ea      {
004253ec          data_430b98 = 1;
004253f6          /* tailcall */
004253f6          return GetACP();
004253ea      }
004253ea      
004253ff      if (result == 0xfffffffc)
004253ff      {
00425401          result = data_430a24;
00425406          data_430b98 = 1;
004253ff      }
004253ff      
00425410      return result;
004253c7  }


00425411    int32_t sub_425411(int32_t arg1) __pure

00425411  {
0042541a      if (arg1 == 0x3a4)
00425443          return 0x411;
00425443      
0042541f      if (arg1 == 0x3a8)
0042543d          return 0x804;
0042543d      
00425424      if (arg1 == 0x3b5)
00425437          return 0x412;
00425437      
00425427      if (arg1 == 0x3b6)
00425431          return 0x404;
00425431      
0042542b      return 0;
00425411  }


00425444    int32_t sub_425444()

00425444  {
00425451      *(uint8_t*)__builtin_memset(0x430ce0, 0, 0x100) = 0;
00425459      data_430bc0 = 0;
0042545e      data_430bdc = 0;
00425463      data_430de4 = 0;
00425468      data_430bd0 = 0;
00425468      void* edi_2 = &data_430bd4;
00425469      *(uint32_t*)edi_2 = 0;
0042546a      *(uint32_t*)((char*)edi_2 + 4) = 0;
0042546c      return 0;
00425444  }


0042546d    void* sub_42546d()

0042546d  {
0042548a      CPINFO cPInfo;
0042548a      void* i;
0042548a      
0042548a      if (GetCPInfo(data_430bc0, &cPInfo) != 1)
0042548a      {
004255ed          for (i = nullptr; i < 0x100; i += 1)
004255ed          {
004255b5              if (i >= 0x41 && i <= 0x5a)
004255b5              {
004255b7                  *(uint8_t*)((char*)i + 0x430ce1) |= 0x10;
004255c3                  *(uint8_t*)((char*)i + 0x430be0) = (uint8_t)i + 0x20;
004255b5              }
004255b5              else if (i < 0x61 || i > 0x7a)
004255e3                  *(uint8_t*)((char*)i + 0x430be0) = 0;
004255d3              else
004255d3              {
004255d5                  *(uint8_t*)((char*)i + 0x430ce1) |= 0x20;
004255c3                  *(uint8_t*)((char*)i + 0x430be0) = (uint8_t)i - 0x20;
004255d3              }
004255ed          }
0042548a      }
0042548a      else
0042548a      {
004254a1          uint8_t var_118[0x100];
004254a1          uint32_t i_1;
004254a1          
004254a1          for (i_1 = 0; i_1 < 0x100; i_1 += 1)
00425497              var_118[i_1] = (uint8_t)i_1;
00425497          
004254a3          (uint8_t)i_1 = cPInfo.LeadByte[0];
004254a6          var_118[0] = 0x20;
004254a6          
004254af          if ((uint8_t)i_1)
004254af          {
004254b3              var_11;
004254b3              void* edx_1 = &var_11;
004254b3              
004254e4              do
004254e4              {
004254b6                  uint32_t ecx_2 = (uint32_t)*(uint8_t*)edx_1;
004254b9                  i_1 = (uint32_t)(uint8_t)i_1;
004254b9                  
004254be                  if (i_1 <= ecx_2)
004254be                  {
004254c9                      int32_t ecx_4 = ecx_2 - i_1 + 1;
004254db                      int32_t __saved_ebp;
004254db                      __builtin_memset(
004254db                          __builtin_memset(&__saved_ebp + i_1 - 0x114, 0x20202020, 
004254db                              ecx_4 >> 2 << 2), 
004254db                          0x20, ecx_4 & 3);
004254be                  }
004254be                  
004254de                  edx_1 += 2;
004254df                  (uint8_t)i_1 = *(uint8_t*)((char*)edx_1 - 1);
004254e4              } while ((uint8_t)i_1);
004254af          }
004254af          
00425507          uint16_t var_518[0x100];
00425507          sub_41e5f4(1, &var_118, 0x100, &var_518, data_430bc0, data_430de4, 0);
0042552b          char var_218[0x100];
0042552b          sub_420f0e(data_430de4, 0x100, &var_118, 0x100, &var_218, 0x100, data_430bc0, 0);
00425553          char var_318[0x100];
00425553          sub_420f0e(data_430de4, 0x200, &var_118, 0x100, &var_318, 0x100, data_430bc0, 0);
0042555b          i = nullptr;
0042555d          uint16_t (* ecx_8)[0x100] = &var_518;
0042555d          
004255a2          do
004255a2          {
00425563              uint8_t edx_3 = (char)*(uint16_t*)ecx_8;
00425563              
00425569              if (edx_3 & 1)
00425569              {
0042556b                  *(uint8_t*)((char*)i + 0x430ce1) |= 0x10;
00425579                  *(uint8_t*)((char*)i + 0x430be0) = *(uint8_t*)(&var_218 + i);
00425569              }
00425569              else if (!(edx_3 & 2))
00425596                  *(uint8_t*)((char*)i + 0x430be0) = 0;
00425584              else
00425584              {
00425586                  *(uint8_t*)((char*)i + 0x430ce1) |= 0x20;
00425579                  *(uint8_t*)((char*)i + 0x430be0) = *(uint8_t*)(&var_318 + i);
00425584              }
00425584              
0042559d              i += 1;
0042559f              ecx_8 = &(*(uint4096_t*)ecx_8)[1];
004255a2          } while (i < 0x100);
0042548a      }
0042548a      
004255f1      return i;
0042546d  }


004255f2    void sub_4255f2()

004255f2  {
004255f9      if (!data_431f4c)
004255f9      {
004255fd          sub_42522e(0xfffffffd);
00425603          data_431f4c = 1;
004255f9      }
004255f2  }

0042560e                                            cc cc                                                                ..

00425610    void* const __convention("regparm") sub_425610(int32_t arg1)

00425610  {
00425616      void arg_4;
00425616      void* ecx = &arg_4;
00425616      
0042561a      while (arg1 >= 0x1000)
0042561a      {
0042561c          ecx -= 0x1000;
00425622          arg1 -= 0x1000;
00425627          *(uint32_t*)ecx;
0042561a      }
0042561a      
00425630      void* ecx_1 = (char*)ecx - arg1;
00425634      *(uint32_t*)ecx_1;
0042563d      *(uint32_t*)((char*)ecx_1 - 4) = __return_addr;
0042563e      return __return_addr;
00425610  }


0042563f    int32_t sub_42563f(int32_t arg1, int32_t arg2, int32_t arg3)

0042563f  {
00425640      int32_t ebx = 0;
00425640      
0042564a      if (!data_430b9c)
0042564a      {
00425651          HMODULE hModule = LoadLibraryA("user32.dll");
0042565b          int32_t eax_1;
0042565b          
0042565b          if (hModule)
0042565b          {
00425669              eax_1 = GetProcAddress(hModule, "MessageBoxA");
0042566d              data_430b9c = eax_1;
0042565b          }
0042565b          
00425672          if (!hModule || !eax_1)
004256c4              return 0;
004256c4          
00425682          data_430ba0 = GetProcAddress(hModule, "GetActiveWindow");
00425689          data_430ba4 = GetProcAddress(hModule, "GetLastActivePopup");
0042564a      }
0042564a      
0042568e      int32_t eax_4 = data_430ba0;
0042568e      
00425695      if (eax_4)
00425695      {
00425699          ebx = eax_4();
00425699          
0042569d          if (ebx)
0042569d          {
0042569f              int32_t eax_6 = data_430ba4;
0042569f              
004256a6              if (eax_6)
004256ab                  ebx = eax_6(ebx);
0042569d          }
00425695      }
00425695      
004256ba      return data_430b9c(ebx, arg1, arg2, arg3);
0042563f  }


004256c8    int32_t sub_4256c8(int32_t arg1)

004256c8  {
004256d2      if (arg1 >= data_430f20)
004256d6          return 0;
004256d6      
004256e6      int32_t eax_1;
004256e6      (uint8_t)eax_1 = *(uint8_t*)((&data_430e20)[arg1 >> 5] + ((arg1 & 0x1f) << 3) + 4);
004256ed      return eax_1 & 0x40;
004256c8  }


004256ee    BOOL sub_4256ee(BOOL arg1, wchar16 arg2)

004256ee  {
004256f1      BOOL lpMultiByteStr = arg1;
004256f1      
004256f6      if (!lpMultiByteStr)
004256f9          return lpMultiByteStr;
004256f9      
00425701      if (data_430a14)
00425701      {
00425718          arg1 = 0;
00425737          int32_t eax_1 = WideCharToMultiByte(data_430a24, 0x220, &arg2, 1, lpMultiByteStr, 
00425737              data_42d07c, nullptr, &arg1);
00425737          
00425745          if (eax_1 && !arg1)
00425755              return eax_1;
00425701      }
00425701      else
00425701      {
00425703          wchar16 ecx = arg2;
00425703          
0042570c          if (ecx <= 0xff)
0042570c          {
00425710              *(uint8_t*)lpMultiByteStr = (uint8_t)ecx;
00425714              return 1;
0042570c          }
00425701      }
00425701      
00425747      data_4307d4 = 0x2a;
00425751      return 0xffffffff;
004256ee  }

00425756                                                                    cc cc cc cc cc cc cc cc cc cc                        ..........

00425760    uint32_t __stdcall __aullrem(int32_t arg1, uint32_t arg2, int32_t arg3, uint32_t arg4) __pure

00425760  {
00425767      uint32_t result;
00425767      
00425767      if (arg4)
00425767      {
00425781          uint32_t i = arg4;
00425783          int32_t ebx_1 = arg3;
00425787          uint32_t edx_4 = arg2;
0042578b          int32_t eax_4 = arg1;
0042578b          
00425799          do
00425799          {
00425791              ebx_1 = RRCD(ebx_1, 1, i & 1);
00425793              uint32_t temp4_1 = edx_4;
00425793              edx_4 u>>= 1;
00425795              eax_4 = RRCD(eax_4, 1, temp4_1 & 1);
00425797              i u>>= 1;
00425799          } while (i);
00425799          
0042579b          uint32_t temp0_1 = COMBINE(edx_4, eax_4) / ebx_1;
0042579f          int32_t eax_6 = temp0_1 * arg4;
004257a4          int32_t eax_8;
004257a4          int32_t edx_5;
004257a4          edx_5 = HIGHD(temp0_1 * arg3);
004257a4          eax_8 = LOWD(temp0_1 * arg3);
004257a8          int32_t edx_6 = edx_5 + eax_6;
004257a8          
004257b0          if (edx_5 + eax_6 < edx_5 || edx_6 > arg2)
004257ba              eax_8 -= arg3;
004257b0          else if (edx_6 >= arg2 && eax_8 > arg1)
004257ba              eax_8 -= arg3;
004257ba          
004257cc          result = -((eax_8 - arg1));
00425767      }
00425767      else
0042577b          result = COMBINE(COMBINE(0, arg2) % arg3, arg1) % arg3;
0042577b      
004257d2      return result;
00425760  }


004257d5    int32_t sub_4257d5(int16_t* arg1, char** arg2, void* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7)

004257d5  {
004257db      int32_t ebx;
004257db      int32_t var_64 = ebx;
004257de      char* edi = arg3;
004257e6      void var_60;
004257e6      void* var_10 = &var_60;
004257e9      int32_t eax = 0;
004257eb      int32_t edx = 1;
004257ec      int16_t var_2c = 0;
004257ef      int32_t var_1c = 1;
004257f2      int32_t var_8 = 0;
004257f5      int32_t var_14 = 0;
004257f8      int32_t var_28 = 0;
004257fb      int32_t var_24 = 0;
004257fe      int32_t var_30 = 0;
00425801      int32_t var_34 = 0;
00425804      void* var_20 = nullptr;
00425807      int32_t var_c = 0;
0042580a      int32_t result = 0;
0042580d      arg3 = edi;
0042580d      
00425810      while (true)
00425810      {
00425810          void* ecx;
00425810          (uint8_t)ecx = *(uint8_t*)edi;
00425810          
00425824          if ((uint8_t)ecx != 0x20 && (uint8_t)ecx != 9 && (uint8_t)ecx != 0xa
00425824              && (uint8_t)ecx != 0xd)
00425824          {
0042582c              while (true)
0042582c              {
0042582c                  (uint8_t)ebx = *(uint8_t*)edi;
0042582e                  edi = &edi[1];
00425838                  int32_t var_70_1;
00425838                  
00425838                  switch (eax)
00425838                  {
00425847                      case 0:
00425847                      {
00425847                          if ((uint8_t)ebx >= 0x31 && (uint8_t)ebx <= 0x39)
00425847                          {
00425849                          label_425849:
00425849                              var_70_1 = 3;
00425a6d                          label_425a6d:
00425a6d                              eax = var_70_1;
00425a6e                              edi -= 1;
00425a6f                              continue;
00425847                          }
00425847                          else if ((uint8_t)ebx != data_42d080)
00425856                          {
0042585f                              int32_t eax_1 = (int32_t)(uint8_t)ebx;
0042585f                              
00425865                              if (eax_1 == 0x2b)
00425865                              {
00425885                                  var_2c = 0;
0042588b                                  eax = 2;
0042588c                                  continue;
00425865                              }
00425865                              else if (eax_1 == 0x2d)
00425869                              {
0042587b                                  var_2c = -0x8000;
00425882                                  eax = 2;
00425883                                  continue;
00425869                              }
00425869                              else
00425869                              {
0042586e                                  if (eax_1 != 0x30)
0042586e                                  {
00425b48                                      edi -= 1;
00425b49                                      break;
0042586e                                  }
0042586e                                  
00425908                                  eax = 1;
0042590a                                  continue;
00425869                              }
00425856                          }
00425856                          else
00425856                          {
00425858                          label_425858:
00425aa5                              eax = 5;
00425aa6                              continue;
00425856                          }
00425847                          break;
00425847                      }
00425891                      case 1:
00425891                      {
00425891                          var_14 = 1;
00425891                          
00425899                          if ((uint8_t)ebx >= 0x31 && (uint8_t)ebx <= 0x39)
00425894                              goto label_425849;
00425894                          
004258a1                          if ((uint8_t)ebx == data_42d080)
004258a1                          {
00425963                              eax = 4;
00425965                              continue;
004258a1                          }
004258a1                          else if ((uint8_t)ebx == 0x2b || (uint8_t)ebx == 0x2d)
004258af                          {
004258dd                          label_4258dd:
004258dd                              edi -= 1;
00425aa5                              eax = 0xb;
00425aa6                              continue;
004258af                          }
004258af                          else if ((uint8_t)ebx == 0x30)
004258b4                          {
00425908                              eax = 1;
0042590a                              continue;
004258b4                          }
004258b4                          else
004258b4                          {
004258b6                          label_4258b6:
004258b6                              
004258d0                              if ((uint8_t)ebx <= 0x43 || ((uint8_t)ebx > 0x45
004258d0                                  && ((uint8_t)ebx <= 0x63 || (uint8_t)ebx > 0x65)))
004258d0                              {
00425b48                                  edi -= 1;
00425b49                                  break;
004258d0                              }
004258d0                              
00425aa5                              eax = 6;
00425aa6                              continue;
004258b4                          }
00425891                          break;
00425891                      }
004258ed                      case 2:
004258ed                      {
004258ed                          if ((uint8_t)ebx >= 0x31 && (uint8_t)ebx <= 0x39)
004258e8                              goto label_425849;
004258e8                          
004258f9                          if ((uint8_t)ebx == data_42d080)
004258f9                              goto label_425858;
004258f9                          
00425902                          if ((uint8_t)ebx != 0x30)
00425902                          {
00425abd                              edi = arg3;
00425ac0                              break;
00425902                          }
00425902                          
00425908                          eax = 1;
0042590a                          continue;
004258ed                      }
0042590f                      case 3:
0042590f                      {
0042590f                          var_14 = 1;
0042590f                          
00425918                          while (true)
00425918                          {
00425918                              BOOL eax_7;
00425918                              
00425918                              if (data_42d07c <= 1)
00425918                              {
0042592b                                  ecx = data_42ce70;
00425934                                  uint32_t eax_8;
00425934                                  (uint8_t)eax_8 = *(uint8_t*)((char*)ecx
00425934                                      + ((uint32_t)(uint8_t)ebx << 1));
00425937                                  eax_7 = eax_8 & 4;
00425918                              }
00425918                              else
00425918                              {
0042591a                                  uint32_t eax_6 = (uint32_t)(uint8_t)ebx;
0042591f                                  eax_7 = sub_4179df(eax_6, 1, ecx, eax_6);
00425925                                  ecx = 4;
00425928                                  edx = 1;
00425918                              }
00425918                              
0042593b                              if (!eax_7)
0042593b                                  break;
0042593b                              
00425941                              if (var_8 >= 0x19)
00425953                                  var_c += 1;
00425941                              else
00425941                              {
00425943                                  void* eax_9 = var_10;
00425946                                  var_8 += 1;
00425949                                  (uint8_t)ebx -= 0x30;
0042594c                                  var_10 += 1;
0042594f                                  *(uint8_t*)eax_9 = (uint8_t)ebx;
00425941                              }
00425941                              
00425956                              (uint8_t)ebx = *(uint8_t*)edi;
00425958                              edi = &edi[1];
00425918                          }
00425918                          
00425961                          if ((uint8_t)ebx == data_42d080)
00425961                          {
00425963                              eax = 4;
00425965                              continue;
00425961                          }
00425961                          
004259ca                      label_4259ca:
004259ca                          
004259d6                          if ((uint8_t)ebx == 0x2b || (uint8_t)ebx == 0x2d)
004259cd                              goto label_4258dd;
004259cd                          
004259cd                          goto label_4258b6;
0042590f                      }
0042596e                      case 4:
0042596e                      {
0042596e                          var_14 = 1;
00425971                          var_28 = 1;
00425971                          
00425974                          if (!var_8)
00425974                          {
00425979                              while ((uint8_t)ebx == 0x30)
00425979                              {
0042597b                                  var_c -= 1;
0042597e                                  (uint8_t)ebx = *(uint8_t*)edi;
00425980                                  edi = &edi[1];
00425979                              }
00425974                          }
00425974                          
00425989                          while (true)
00425989                          {
00425989                              BOOL eax_11;
00425989                              
00425989                              if (data_42d07c <= 1)
00425989                              {
0042599c                                  ecx = data_42ce70;
004259a5                                  uint32_t eax_12;
004259a5                                  (uint8_t)eax_12 = *(uint8_t*)((char*)ecx
004259a5                                      + ((uint32_t)(uint8_t)ebx << 1));
004259a8                                  eax_11 = eax_12 & 4;
00425989                              }
00425989                              else
00425989                              {
0042598b                                  uint32_t eax_10 = (uint32_t)(uint8_t)ebx;
00425990                                  eax_11 = sub_4179df(eax_10, 1, ecx, eax_10);
00425996                                  ecx = 4;
00425999                                  edx = 1;
00425989                              }
00425989                              
004259ac                              if (!eax_11)
004259ac                                  break;
004259ac                              
004259b2                              if (var_8 < 0x19)
004259b2                              {
004259b4                                  void* eax_13 = var_10;
004259b7                                  var_8 += 1;
004259ba                                  (uint8_t)ebx -= 0x30;
004259bd                                  var_10 += 1;
004259c0                                  var_c -= 1;
004259c3                                  *(uint8_t*)eax_13 = (uint8_t)ebx;
004259b2                              }
004259b2                              
004259c5                              (uint8_t)ebx = *(uint8_t*)edi;
004259c7                              edi = &edi[1];
00425989                          }
00425989                          
004259ac                          goto label_4259ca;
0042596e                      }
004259e7                      case 5:
004259e7                      {
004259e7                          var_28 = 1;
004259ea                          BOOL eax_15;
004259ea                          
004259ea                          if (data_42d07c <= 1)
004259ea                          {
004259fd                              ecx = data_42ce70;
00425a06                              uint32_t eax_16;
00425a06                              (uint8_t)eax_16 =
00425a06                                  *(uint8_t*)((char*)ecx + ((uint32_t)(uint8_t)ebx << 1));
00425a09                              eax_15 = eax_16 & 4;
004259ea                          }
004259ea                          else
004259ea                          {
004259ec                              uint32_t eax_14 = (uint32_t)(uint8_t)ebx;
004259f1                              eax_15 = sub_4179df(eax_14, 1, ecx, eax_14);
004259f7                              ecx = 4;
004259fa                              edx = 1;
004259ea                          }
004259ea                          
00425a0d                          if (!eax_15)
00425a0d                          {
00425abd                              edi = arg3;
00425ac0                              break;
00425a0d                          }
00425a0d                          
00425a13                          eax = 4;
00425a6e                          edi -= 1;
00425a6f                          continue;
004259e7                      }
00425a17                      case 6:
00425a17                      {
00425a17                          ecx = &edi[0xfffffffe];
00425a1d                          arg3 = ecx;
00425a1d                          
00425a25                          if ((uint8_t)ebx >= 0x31 && (uint8_t)ebx <= 0x39)
00425a25                          {
00425a6b                          label_425a6b:
00425a6b                              var_70_1 = 9;
00425a6b                              goto label_425a6d;
00425a25                          }
00425a25                          
00425a27                          int32_t eax_17 = (int32_t)(uint8_t)ebx;
00425a27                          
00425a2d                          if (eax_17 == 0x2b)
00425a2d                              goto label_425aa3;
00425a2d                          
00425a31                          if (eax_17 == 0x2d)
00425a31                              goto label_425a97;
00425a31                          
00425a36                          if (eax_17 == 0x30)
00425a36                              goto label_425a3c;
00425a36                          
00425b4b                          edi = ecx;
00425b4b                          break;
00425a17                          break;
00425a17                      }
00425a69                      case 7:
00425a69                      {
00425a69                          if ((uint8_t)ebx >= 0x31 && (uint8_t)ebx <= 0x39)
00425a64                              goto label_425a6b;
00425a64                          
00425a77                          if ((uint8_t)ebx != 0x30)
00425a77                          {
00425abd                              edi = arg3;
00425ac0                              break;
00425a77                          }
00425a77                          
00425a3c                      label_425a3c:
00425aa5                          eax = 8;
00425aa6                          continue;
00425a69                      }
00425a40                      case 8:
00425a40                      {
00425a40                          var_24 = 1;
00425a40                          
00425a46                          while ((uint8_t)ebx == 0x30)
00425a46                          {
00425a48                              (uint8_t)ebx = *(uint8_t*)edi;
00425a4a                              edi = &edi[1];
00425a46                          }
00425a46                          
00425a59                          if ((uint8_t)ebx >= 0x31 && (uint8_t)ebx <= 0x39)
00425a50                              goto label_425a6b;
00425a50                          
00425b48                          edi -= 1;
00425b49                          break;
00425a40                          break;
00425a40                      }
00425ac5                      case 9:
00425ac5                      {
00425ac5                          var_24 = 1;
00425acc                          void* esi_1 = nullptr;
00425acc                          
00425ad5                          while (true)
00425ad5                          {
00425ad5                              BOOL eax_27;
00425ad5                              
00425ad5                              if (data_42d07c <= 1)
00425ad5                              {
00425ae6                                  ecx = data_42ce70;
00425aef                                  uint32_t eax_28;
00425aef                                  (uint8_t)eax_28 = *(uint8_t*)((char*)ecx
00425aef                                      + ((uint32_t)(uint8_t)ebx << 1));
00425af2                                  eax_27 = eax_28 & 4;
00425ad5                              }
00425ad5                              else
00425ad5                              {
00425ad7                                  uint32_t eax_26 = (uint32_t)(uint8_t)ebx;
00425add                                  eax_27 = sub_4179df(eax_26, edx, ecx, eax_26);
00425ae3                                  ecx = 4;
00425ad5                              }
00425ad5                              
00425af7                              if (!eax_27)
00425af7                                  break;
00425af7                              
00425af9                              ecx = (int32_t)(uint8_t)ebx;
00425aff                              esi_1 = (char*)ecx + esi_1 * 0xa - 0x30;
00425aff                              
00425b09                              if (esi_1 > 0x1450)
00425b09                              {
00425b10                                  esi_1 = 0x1451;
00425b10                                  break;
00425b09                              }
00425b09                              
00425b0b                              (uint8_t)ebx = *(uint8_t*)edi;
00425b0d                              edi = &edi[1];
00425ad5                          }
00425ad5                          
00425b15                          var_20 = esi_1;
00425b15                          
00425b1f                          while (true)
00425b1f                          {
00425b1f                              BOOL eax_31;
00425b1f                              
00425b1f                              if (data_42d07c <= 1)
00425b1f                              {
00425b30                                  ecx = data_42ce70;
00425b39                                  uint32_t eax_32;
00425b39                                  (uint8_t)eax_32 = *(uint8_t*)((char*)ecx
00425b39                                      + ((uint32_t)(uint8_t)ebx << 1));
00425b3c                                  eax_31 = eax_32 & 4;
00425b1f                              }
00425b1f                              else
00425b1f                              {
00425b21                                  uint32_t eax_30 = (uint32_t)(uint8_t)ebx;
00425b27                                  eax_31 = sub_4179df(eax_30, edx, ecx, eax_30);
00425b2d                                  ecx = 4;
00425b1f                              }
00425b1f                              
00425b41                              if (!eax_31)
00425b41                                  break;
00425b41                              
00425b43                              (uint8_t)ebx = *(uint8_t*)edi;
00425b45                              edi = &edi[1];
00425b1f                          }
00425b1f                          
00425b48                          edi -= 1;
00425b49                          break;
00425ac5                          break;
00425ac5                      }
00425a7f                      case 0xb:
00425a7f                      {
00425a7f                          if (!arg7)
00425a7f                          {
00425aad                              edi -= 1;
00425aae                              eax = 0xa;
00425a7f                          }
00425a7f                          else
00425a7f                          {
00425a81                              int32_t eax_22 = (int32_t)(uint8_t)ebx;
00425a84                              ecx = &edi[0xffffffff];
00425a8a                              arg3 = ecx;
00425a8a                              
00425a8d                              if (eax_22 == 0x2b)
00425a8d                              {
00425aa3                              label_425aa3:
00425aa5                                  eax = 7;
00425aa6                                  continue;
00425a8d                              }
00425a8d                              else
00425a8d                              {
00425a91                                  if (eax_22 != 0x2d)
00425a91                                  {
00425b4b                                      edi = ecx;
00425b4b                                      break;
00425a91                                  }
00425a91                                  
00425a97                              label_425a97:
00425a97                                  var_1c = 0xffffffff;
00425a9d                                  eax = 7;
00425a9e                                  continue;
00425a8d                              }
00425a7f                          }
00425a7f                          break;
00425a7f                      }
00425838                  }
00425838                  
00425ab2                  if (eax == 0xa)
00425ab2                      break;
0042582c              }
0042582c              
00425b54              *(uint32_t*)arg2 = edi;
00425b56              int16_t eax_38;
00425b56              int16_t edx_1;
00425b56              void* ebx_1;
00425b56              void* esi_2;
00425b56              
00425b56              if (!var_14)
00425b56              {
00425c35                  edx_1 = 0;
00425c37                  eax_38 = 0;
00425c39                  esi_2 = nullptr;
00425c3b                  ebx_1 = nullptr;
00425c3d                  result = 4;
00425b56              }
00425b56              else
00425b56              {
00425b62                  void* eax_35;
00425b62                  
00425b62                  if (var_8 <= 0x18)
00425b79                      eax_35 = var_10;
00425b62                  else
00425b62                  {
00425b68                      char var_49;
00425b68                      
00425b68                      if (var_49 >= 5)
00425b6a                          char var_49_1 = var_49 + 1;
00425b6a                      
00425b6d                      var_8 = 0x18;
00425b73                      eax_35 = (char*)var_10 - 1;
00425b74                      var_c += 1;
00425b62                  }
00425b62                  
00425b80                  if (var_8 <= 0)
00425b80                  {
00425c2b                      edx_1 = 0;
00425c2d                      eax_38 = 0;
00425c2f                      esi_2 = nullptr;
00425c31                      ebx_1 = nullptr;
00425b80                  }
00425b80                  else
00425b80                  {
00425b86                      while (true)
00425b86                      {
00425b86                          eax_35 -= 1;
00425b86                          
00425b8a                          if (*(uint8_t*)eax_35)
00425b8a                              break;
00425b8a                          
00425b8c                          var_8 -= 1;
00425b8f                          var_c += 1;
00425b86                      }
00425b86                      
00425b9f                      int32_t var_44;
00425b9f                      sub_426c19(&var_60, var_8, &var_44);
00425ba4                      void* eax_36 = var_20;
00425ba4                      
00425baf                      if (var_1c < 0)
00425bb1                          eax_36 = -(eax_36);
00425bb1                      
00425bb3                      void* eax_37 = (char*)eax_36 + var_c;
00425bb3                      
00425bb9                      if (!var_24)
00425bbb                          eax_37 += arg5;
00425bbb                      
00425bc1                      if (!var_28)
00425bc3                          eax_37 -= arg6;
00425bc3                      
00425bcb                      if (eax_37 <= 0x1450)
00425bcb                      {
00425c02                          if (eax_37 < 0xffffebb0)
00425c02                          {
00425c04                              var_34 = 1;
00425c0b                              goto label_425bd4;
00425c02                          }
00425c02                          
00425c15                          sub_427193(&var_44, eax_37, arg4);
00425c1a                          edx_1 = (int16_t)var_44;
00425c1d                          ebx_1 = var_44;
00425c20                          void* var_3e;
00425c20                          esi_2 = var_3e;
00425c23                          int16_t var_3a;
00425c23                          eax_38 = var_3a;
00425bcb                      }
00425bcb                      else
00425bcb                      {
00425bcd                          var_30 = 1;
00425bd4                      label_425bd4:
00425bd4                          ebx_1 = arg3;
00425bd7                          esi_2 = arg3;
00425bda                          eax_38 = (uint16_t)arg3;
00425bdd                          edx_1 = (uint16_t)arg3;
00425bcb                      }
00425b80                  }
00425b80                  
00425be4                  if (var_30)
00425be4                  {
00425be6                      ebx_1 = nullptr;
00425be8                      eax_38 = 0x7fff;
00425bed                      esi_2 = 0x80000000;
00425bf2                      edx_1 = 0;
00425bf4                      result = 2;
00425be4                  }
00425be4                  else if (var_34)
00425c4a                  {
00425c4c                      edx_1 = 0;
00425c4e                      eax_38 = 0;
00425c50                      esi_2 = nullptr;
00425c52                      ebx_1 = nullptr;
00425c54                      result = 1;
00425c4a                  }
00425b56              }
00425b56              
00425c62              *(uint32_t*)((char*)arg1 + 6) = esi_2;
00425c65              *(uint32_t*)((char*)arg1 + 2) = ebx_1;
00425c68              arg1[5] = eax_38 | var_2c;
00425c70              *(uint16_t*)arg1 = edx_1;
00425c75              return result;
00425824          }
00425824          
00425826          edi = &edi[1];
00425810      }
004257d5  }

00425c76  uint32_t jump_table_425c76[0xc] = 
00425c76  {
00425c76      [0x0] =  0x0042583f
00425c7a      [0x1] =  0x0042588e
00425c7e      [0x2] =  0x004258e5
00425c82      [0x3] =  0x0042590f
00425c86      [0x4] =  0x0042596a
00425c8a      [0x5] =  0x004259e1
00425c8e      [0x6] =  0x00425a17
00425c92      [0x7] =  0x00425a61
00425c96      [0x8] =  0x00425a40
00425c9a      [0x9] =  0x00425ac5
00425c9e      [0xa] =  0x00425aaf
00425ca2      [0xb] =  0x00425a7b
00425ca6  }

00425ca6    int32_t sub_425ca6(int32_t arg1, int32_t* arg2, uint32_t arg3)

00425ca6  {
00425cb4      uint32_t ecx = (uint32_t)*(uint16_t*)arg3;
00425cb7      int32_t eax_1 = *(uint32_t*)arg2;
00425cbb      arg3 = ecx;
00425cbe      int32_t var_6c_1;
00425cbe      
00425cbe      if (eax_1 == 1)
00425cbe      {
00425ceb      label_425ceb:
00425ceb          var_6c_1 = 8;
00425cf4      label_425cf4:
00425cf4          
00425cfe          if (!sub_41f106(var_6c_1, &arg2[6], (uint8_t)ecx))
00425cfe          {
00425d10              int32_t var_24;
00425d10              
00425d10              if (arg1 == 0x10 || arg1 == 0x16 || arg1 == 0x1d)
00425d10              {
00425d21                  double var_34_1 = (double)(long double)*(uint64_t*)((char*)arg2 + 0x10);
00425d27                  int32_t var_24_2 = (var_24 & 0xffffffe3) | 3;
00425d10              }
00425d10              else
00425d12                  int32_t var_24_1 = var_24 & 0xfffffffe;
00425d39              void var_5c;
00425d39              sub_41ee53(&var_5c, &arg3, (uint8_t)var_6c_1, arg1, &arg2[2], &arg2[6]);
00425d39              /* no return */
00425cfe          }
00425cbe      }
00425cbe      else
00425cbe      {
00425cc1          if (eax_1 == 2)
00425cc1          {
00425ce7              var_6c_1 = 4;
00425ce9              goto label_425cf4;
00425cc1          }
00425cc1          
00425cc4          if (eax_1 == 3)
00425cc4          {
00425ce3              var_6c_1 = 0x11;
00425ce5              goto label_425cf4;
00425cc4          }
00425cc4          
00425cc7          if (eax_1 == 4)
00425cc7          {
00425cdf              var_6c_1 = 0x12;
00425ce1              goto label_425cf4;
00425cc7          }
00425cc7          
00425cca          if (eax_1 == 5)
00425cca              goto label_425ceb;
00425cca          
00425cce          if (eax_1 == 7)
00425cd7              *(uint32_t*)arg2 = 1;
00425cce          else if (eax_1 == 8)
00425cd1          {
00425cd3              var_6c_1 = 0x10;
00425cd5              goto label_425cf4;
00425cd1          }
00425cbe      }
00425d49      int16_t x87control;
00425d49      sub_41f590(x87control, arg3, 0xffff);
00425d49      
00425d5c      if (*(uint32_t*)arg2 != 8 && !data_4304d0)
00425d5c      {
00425d5e          int32_t* var_6c_4 = arg2;
00425d5f          sub_41a390();
00425d5c      }
00425d5c      
00425d75      return sub_41f3a5(*(uint32_t*)arg2);
00425ca6  }

00425d3e                                                                                            83 c4                                ..
00425d40  18                                                                                               .

00425d76    void* sub_425d76(char* arg1, char* arg2, int32_t arg3)

00425d76  {
00425d79      char* ecx = arg1;
00425d79      
00425d7f      while (*(uint8_t*)ecx == 0x3b)
00425d81          ecx = &ecx[1];
00425d81      
00425d84      int32_t temp0 = arg3;
00425d84      arg3 -= 1;
00425d88      char* eax = ecx;
00425d8a      char* esi;
00425d8a      
00425d8a      if (temp0 == 1)
00425dd9          esi = arg2;
00425d8a      else
00425d8a      {
00425d8c          char i = *(uint8_t*)ecx;
00425d8e          esi = arg2;
00425d8e          
00425d93          if (i)
00425d93          {
00425d98              while (i != 0x3b)
00425d98              {
00425d9d                  if (i == 0x22)
00425d9d                  {
00425daa                      ecx = &ecx[1];
00425daa                      
00425dab                      while (true)
00425dab                      {
00425dab                          i = *(uint8_t*)ecx;
00425dab                          
00425db4                          if (!i || i == 0x22)
00425db4                          {
00425dc4                              if (!*(uint8_t*)ecx)
00425dc4                                  break;
00425dc4                              
00425dc6                              ecx = &ecx[1];
00425dc6                              break;
00425db4                          }
00425db4                          
00425db6                          *(uint8_t*)esi = i;
00425db8                          esi = &esi[1];
00425db9                          ecx = &ecx[1];
00425dba                          int32_t temp3_1 = arg3;
00425dba                          arg3 -= 1;
00425dba                          
00425dbd                          if (temp3_1 == 1)
00425dbd                              goto label_425dd5;
00425dbd                          
00425dbd                          continue;
00425dab                      }
00425d9d                  }
00425d9d                  else
00425d9d                  {
00425d9f                      *(uint8_t*)esi = i;
00425da1                      esi = &esi[1];
00425da2                      ecx = &ecx[1];
00425da3                      int32_t temp2_1 = arg3;
00425da3                      arg3 -= 1;
00425da3                      
00425da6                      if (temp2_1 == 1)
00425da6                      {
00425dd5                      label_425dd5:
00425dd5                          eax = ecx;
00425dd7                          goto label_425ddc;
00425da6                      }
00425d9d                  }
00425d9d                  
00425dc7                  i = *(uint8_t*)ecx;
00425dc7                  
00425dcb                  if (!i)
00425dcb                      break;
00425d98              }
00425d93          }
00425d93          
00425dd0          while (*(uint8_t*)ecx == 0x3b)
00425dd2              ecx = &ecx[1];
00425d8a      }
00425d8a      
00425ddc  label_425ddc:
00425ddc      *(uint8_t*)esi = 0;
00425ddf      int32_t eax_1 = eax - ecx;
00425de1      int32_t eax_2 = -(eax_1);
00425de9      return (eax_2 - eax_2) & ecx;
00425d76  }


00425dea    void* sub_425dea(char* arg1, int32_t arg2)

00425dea  {
00425df4      if (!data_430bdc)
00425e04          return sub_4172f0(arg1, (uint8_t)arg2);
00425e04      
00425e05      char* ecx_1 = arg1;
00425e08      uint32_t eax;
00425e08      
00425e08      while (true)
00425e08      {
00425e08          (uint16_t)eax = (uint16_t)*(uint8_t*)ecx_1;
00425e08          
00425e0f          if (!(uint16_t)eax)
00425e0f              break;
00425e0f          
00425e1b          if (*(uint8_t*)((uint32_t)(uint8_t)eax + 0x430ce1) & 4)
00425e1b          {
00425e1d              uint32_t edx_1;
00425e1d              (uint8_t)edx_1 = ecx_1[1];
00425e20              ecx_1 = &ecx_1[1];
00425e20              
00425e23              if (!(uint8_t)edx_1)
00425e45                  return 0;
00425e45              
00425e33              if (arg2 == ((uint32_t)(uint16_t)eax << 8 | (uint32_t)(uint8_t)edx_1))
00425e4a                  return &ecx_1[0xffffffff];
00425e1b          }
00425e1b          else if (arg2 == (uint32_t)(uint16_t)eax)
00425e3d              break;
00425e3d          
00425e3f          ecx_1 = &ecx_1[1];
00425e08      }
00425e08      
00425e51      int32_t eax_7 = arg2 - (uint32_t)(uint16_t)eax;
00425e53      int32_t eax_8 = -(eax_7);
00425e5c      return ~(eax_8 - eax_8) & ecx_1;
00425dea  }


00425e5d    char* sub_425e5d(int32_t arg1, PSTR arg2, int32_t arg3)

00425e5d  {
00425e5d      int32_t __saved_ebp_1;
00425e5d      int32_t __saved_ebp = __saved_ebp_1;
00425e66      char var_5 = 0;
00425e6a      int32_t ebx;
00425e6a      int32_t var_68 = ebx;
00425e6b      int32_t esi;
00425e6b      int32_t var_6c = esi;
00425e6c      int32_t edi;
00425e6c      int32_t var_70 = edi;
00425e6c      int32_t* esp_1 = &var_70;
00425e71      enum PROCESS_CREATION_FLAGS dwCreationFlags = 0;
00425e71      
00425e79      if (!arg1 || arg1 == 1)
00425e74          goto label_425e8b;
00425e74      
00425e7b      char* result;
00425e7b      
00425e7b      if (arg1 <= 1)
00425e7b      {
00425ead      label_425ead:
00425ead          data_4307d4 = 0x16;
00425eb7          data_4307d8 = 0;
00425fde          result = 0xffffffff;
00425e7b      }
00425e7b      else
00425e7b      {
00425e80          if (arg1 <= 3)
00425e80              goto label_425e8b;
00425e80          
00425e85          if (arg1 != 4)
00425e85              goto label_425ead;
00425e85          
00425e87          var_5 = 1;
00425e8b      label_425e8b:
00425e8b          char* result_1;
00425e8b          char* lpCommandLine_1 = result_1;
00425e8e          char* lpCommandLine = lpCommandLine_1;
00425e8e          
00425e91          while (true)
00425e91          {
00425e91              void* ecx;
00425e91              (uint8_t)ecx = *(uint8_t*)lpCommandLine_1;
00425e91              
00425e95              if (!(uint8_t)ecx)
00425e95                  break;
00425e95              
00425e9b              do
00425e97                  lpCommandLine_1 = &lpCommandLine_1[1];
00425e9b               while (*(uint8_t*)lpCommandLine_1);
00425e9b              
00425ea4              if (lpCommandLine_1[1])
00425ea4              {
00425ea6                  *(uint8_t*)lpCommandLine_1 = 0x20;
00425ea9                  lpCommandLine_1 = &lpCommandLine_1[1];
00425ea4              }
00425e91          }
00425e91          
00425ec2          PROCESS_INFORMATION* lpProcessInformation = 0x44;
00425ec7          PROCESS_INFORMATION* esi_1 = lpProcessInformation;
00425ec8          lpProcessInformation = esi_1;
00425ec9          int32_t var_78_1 = 0;
00425ecb          PROCESS_INFORMATION* startupInfo;
00425ecb          sub_423620(&startupInfo, 0, lpProcessInformation);
00425ed0          startupInfo = esi_1;
00425ed3          PROCESS_INFORMATION* lpProcessInformation_5 = data_430f20;
00425ed3          
00425ede          if (lpProcessInformation_5)
00425ede          {
00425ee0              void* __offset(_PROCESS_INFORMATION, -0x1) eax_1 =
00425ee0                  (char*)lpProcessInformation_5 - 1;
00425ee0              
00425ef9              while (!*(uint8_t*)((&data_430e20)[eax_1 >> 5] + ((eax_1 & 0x1f) << 3) + 4))
00425ef9              {
00425efb                  lpProcessInformation_5 -= 1;
00425efc                  eax_1 -= 1;
00425efc                  
00425eff                  if (!lpProcessInformation_5)
00425eff                      break;
00425ef9              }
00425ede          }
00425ede          
00425f05          lpProcessInformation = 1;
00425f07          int16_t var_32_1 =
00425f07              (uint16_t)lpProcessInformation_5 + (int16_t)(lpProcessInformation_5 << 2) + 4;
00425f0f          void* lpProcessInformation_1 = sub_41c874(
00425f0f              (uint32_t)((uint16_t)lpProcessInformation_5
00425f0f                  + (int16_t)(lpProcessInformation_5 << 2) + 4), 
00425f0f              lpProcessInformation);
00425f18          *(uint32_t*)lpProcessInformation_1 = lpProcessInformation_5;
00425f1a          void* lpProcessInformation_4 = lpProcessInformation_1;
00425f1e          int32_t ebx_1 = 0;
00425f22          void* ecx_4 = (char*)lpProcessInformation_4 + 4;
00425f25          void* edx_3 = &lpProcessInformation_5->hThread + lpProcessInformation_4;
00425f25          
00425f29          if (lpProcessInformation_5 > 0)
00425f29          {
00425f5b              do
00425f5b              {
00425f3c                  int32_t* edi_3 = (&data_430e20)[ebx_1 >> 5] + ((ebx_1 & 0x1f) << 3);
00425f3f                  int32_t eax_6;
00425f3f                  (uint8_t)eax_6 = edi_3[1];
00425f3f                  
00425f44                  if ((uint8_t)eax_6 & 0x10)
00425f44                  {
00425f4e                      *(uint8_t*)ecx_4 = 0;
00425f51                      *(uint32_t*)edx_3 = 0xffffffff;
00425f44                  }
00425f44                  else
00425f44                  {
00425f46                      *(uint8_t*)ecx_4 = (uint8_t)eax_6;
00425f4a                      *(uint32_t*)edx_3 = *(uint32_t*)edi_3;
00425f44                  }
00425f44                  
00425f54                  ebx_1 += 1;
00425f55                  ecx_4 += 1;
00425f56                  edx_3 += 4;
00425f5b              } while (ebx_1 < lpProcessInformation_5);
00425f5b              
00425f5d              lpProcessInformation_4 = lpProcessInformation_1;
00425f29          }
00425f29          
00425f66          if (var_5)
00425f66          {
00425f68              void* ecx_5 = (char*)lpProcessInformation_4 + 4;
00425f6b              int32_t edx_4 = 0;
00425f6d              void* eax_8 = &lpProcessInformation_5->hThread + lpProcessInformation_4;
00425f6d              
00425f74              while (true)
00425f74              {
00425f74                  PROCESS_INFORMATION* lpProcessInformation_3;
00425f74                  
00425f74                  if (lpProcessInformation_5 >= 3)
00425f74                  {
00425f7a                      lpProcessInformation = 3;
00425f7c                      lpProcessInformation_3 = lpProcessInformation;
00425f74                  }
00425f74                  else
00425f76                      lpProcessInformation_3 = lpProcessInformation_5;
00425f76                  
00425f7f                  if (edx_4 >= lpProcessInformation_3)
00425f7f                      break;
00425f7f                  
00425f81                  *(uint8_t*)ecx_5 = 0;
00425f84                  *(uint32_t*)eax_8 = 0xffffffff;
00425f87                  edx_4 += 1;
00425f88                  ecx_5 += 1;
00425f89                  eax_8 += 4;
00425f74              }
00425f74              
00425f8e              dwCreationFlags = DETACHED_PROCESS;
00425f66          }
00425f66          
00425f98          data_4307d4 = 0;
00425f9e          char* result_2;
00425f9e          lpProcessInformation = &result_2;
00425fa3          int32_t var_7c_2 = 0;
00425fa7          data_4307d8 = 0;
00425fb0          int32_t var_88_1 = 1;
00425fb2          int32_t var_8c_1 = 0;
00425fb3          int32_t var_90_1 = 0;
00425fba          BOOL eax_9 = CreateProcessA(arg2, lpCommandLine, nullptr, nullptr, 1, 
00425fba              dwCreationFlags, arg3, nullptr, &startupInfo, lpProcessInformation);
00425fc2          enum WIN32_ERROR lpProcessInformation_2;
00425fc2          void** ecx_6;
00425fc2          lpProcessInformation_2 = GetLastError();
00425fc8          lpProcessInformation = lpProcessInformation_1;
00425fcd          sub_41784c(ecx_6);
00425fd4          int32_t* esp_2 = &var_70;
00425fd4          
00425fd5          if (eax_9)
00425fd5          {
00425fe7              if (arg1 == 2)
00425fe7              {
00425fe9                  lpProcessInformation = nullptr;
00425fe9                  esp_2 = &lpProcessInformation;
00425fea                  sub_417034(lpProcessInformation);
00425fe7              }
00425fe7              
00425ff8              if (!arg1)
00425ff8              {
00425ffa                  *(uint32_t*)((char*)esp_2 - 4) = 0xffffffff;
00425ffc                  *(uint32_t*)((char*)esp_2 - 8) = result_2;
00425fff                  WaitForSingleObject();
00426008                  *(uint32_t*)((char*)esp_2 - 4) = &result_1;
00426009                  *(uint32_t*)((char*)esp_2 - 8) = result_2;
0042600c                  GetExitCodeProcess();
00426012                  *(uint32_t*)((char*)esp_2 - 4) = result_2;
00426015                  CloseHandle();
00425ff8              }
00425ff8              else if (arg1 != 4)
0042602c                  result_1 = result_2;
0042601d              else
0042601d              {
0042601f                  *(uint32_t*)((char*)esp_2 - 4) = result_2;
00426022                  CloseHandle();
00426024                  result_1 = nullptr;
0042601d              }
0042601d              
0042602f              int32_t var_1c;
0042602f              *(uint32_t*)((char*)esp_2 - 4) = var_1c;
00426032              CloseHandle();
00426032              esp_1 = esp_2;
00426034              result = result_1;
00425fd5          }
00425fd5          else
00425fd5          {
00425fd7              lpProcessInformation = lpProcessInformation_2;
00425fd8              sub_42149e(lpProcessInformation);
00425fdd              esp_1 = &var_70;
00425fde              result = 0xffffffff;
00425fd5          }
00425e7b      }
00425e7b      
00426037      *(uint32_t*)esp_1;
00426037      esp_1[1];
00426038      esp_1[2];
0042603b      return result;
00425e5d  }


0042603c    int32_t sub_42603c(int32_t* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)

0042603c  {
00426040      int32_t* ebx = arg1;
00426047      void* esi = 2;
00426048      void* edi = 2;
00426048      
0042604a      while (true)
0042604a      {
0042604a          char* eax_1 = *(uint32_t*)ebx;
0042604a          
0042604e          if (!eax_1)
0042604e              break;
0042604e          
00426051          ebx = &ebx[1];
0042605a          edi = (char*)edi + sub_41e7d0(eax_1) + 1;
0042604a      }
0042604a      
00426061      void* eax_3 = sub_41dbac(edi);
00426067      void** ecx_2 = arg3;
0042606c      *(uint32_t*)ecx_2 = eax_3;
0042606c      
0042606e      if (!eax_3)
0042606e      {
00426073          *(uint32_t*)arg4 = 0;
0042615d      label_42615d:
0042615d          data_4307d4 = 0xc;
00426167          data_4307d8 = 8;
00426171          return 0xffffffff;
0042606e      }
0042606e      
0042607b      int32_t* edi_1 = arg2;
00426080      void* ebx_1;
00426080      int32_t* edi_2;
00426080      
00426080      if (!edi_1)
00426080      {
0042609b          ebx_1 = arg4;
0042609e          edi_2 = arg4;
004260a1          *(uint32_t*)arg4 = 0;
00426080      }
00426080      else
00426080      {
00426082          while (true)
00426082          {
00426082              char* eax_5 = *(uint32_t*)edi_1;
00426082              
00426086              if (!eax_5)
00426086                  break;
00426086              
00426089              edi_1 = &edi_1[1];
00426092              esi = (char*)esi + sub_41e7d0(eax_5) + 1;
00426082          }
00426082          
004260bf          char* eax_11 = data_430820;
004260bf          
004260c6          if (!eax_11)
004260c6          {
004260c8              eax_11 = sub_41c022();
004260cf              data_430820 = eax_11;
004260cf              
004260d4              if (!eax_11)
00426171                  return 0xffffffff;
004260c6          }
004260c6          
004260da          ebx_1 = nullptr;
004260da          
004260de          if (*(uint8_t*)eax_11)
004260de          {
004260e0              void* edi_3 = eax_11;
004260e2              (uint8_t)ecx_2 = *(uint8_t*)edi_3;
004260e2              
004260e7              while ((uint8_t)ecx_2 != 0x3d)
004260e7              {
004260ef                  ebx_1 = (char*)ebx_1 + sub_41e7d0(edi_3) + 1;
004260f3                  eax_11 = data_430820;
004260f9                  (uint8_t)ecx_2 = *(uint8_t*)(eax_11 + ebx_1);
004260fc                  edi_3 = eax_11 + ebx_1;
004260fc                  
00426101                  if (!(uint8_t)ecx_2)
00426101                      break;
004260e7              }
004260de          }
004260de          
00426103          edi_2 = ebx_1;
00426105          void* eax_13 = eax_11 + ebx_1;
00426105          
0042610a          while (*(uint8_t*)eax_13 == 0x3d)
0042610a          {
00426110              if (!*(uint8_t*)((char*)eax_13 + 1))
00426110                  break;
00426110              
00426116              if (*(uint8_t*)((char*)eax_13 + 2) != 0x3a)
00426116                  break;
00426116              
0042611c              if (*(uint8_t*)((char*)eax_13 + 3) != 0x3d)
0042611c                  break;
0042611c              
00426127              edi_2 = (char*)edi_2 + sub_41e7d0((char*)eax_13 + 4) + 5;
00426131              eax_13 = data_430820 + edi_2;
0042610a          }
0042610a          
0042613c          void* eax_20 = sub_41dbac((char*)edi_2 - ebx_1 + esi);
00426142          ecx_2 = arg4;
00426147          *(uint32_t*)ecx_2 = eax_20;
00426147          
00426149          if (!eax_20)
00426149          {
00426152              int32_t var_14_7 = *(uint32_t*)arg3;
00426154              sub_41784c(ecx_2);
00426159              *(uint32_t*)arg3 = 0;
0042615c              goto label_42615d;
00426149          }
00426080      }
00426080      
004260a7      void* esi_1 = *(uint32_t*)arg3;
004260ac      arg3 = arg1;
004260af      char* eax_10 = *(uint32_t*)arg1;
004260b3      char* esi_3;
004260b3      
004260b3      if (eax_10)
004260b3      {
0042617b          sub_41b8c0(esi_1, eax_10);
00426189          arg3 = &arg1[1];
0042618c          void* eax_23;
0042618c          eax_23 = sub_41e7d0(*(uint32_t*)arg1);
00426194          esi_3 = (char*)esi_1 + eax_23 + 1;
00426194          goto label_42619b;
004260b3      }
004260b3      
004260b9      while (true)
004260b9      {
004260b9          esi_3 = (char*)esi_1 + 1;
0042619b      label_42619b:
0042619b          char* eax_25 = *(uint32_t*)arg3;
0042619b          
0042619f          if (!eax_25)
0042619f              break;
0042619f          
004261a3          sub_41b8c0(esi_3, eax_25);
004261a8          int32_t* eax_26 = arg3;
004261ab          arg3 = &arg3[1];
004261b2          void* eax_28;
004261b2          eax_28 = sub_41e7d0(*(uint32_t*)eax_26);
004261ba          esi_1 = esi_3 + eax_28;
004261bc          *(uint8_t*)esi_1 = 0x20;
004260b9      }
004260b9      
004261c7      esi_3[0xffffffff] = 0;
004261cb      *(uint8_t*)esi_3 = 0;
004261d2      char* esi_4 = *(uint32_t*)arg4;
004261d2      
004261d4      if (arg2)
004261d4      {
004261e4          ecx_2 = sub_41b4f0(esi_4, data_430820 + ebx_1, (char*)edi_2 - ebx_1);
004261ee          esi_4 = &esi_4[(char*)edi_2 - ebx_1];
004261f0          int32_t* edi_5 = arg2;
004261f0          
004261f3          while (true)
004261f3          {
004261f3              char* eax_34 = *(uint32_t*)edi_5;
004261f3              
004261f7              if (!eax_34)
004261f7                  break;
004261f7              
004261fb              sub_41b8c0(esi_4, eax_34);
00426200              char* eax_35 = *(uint32_t*)edi_5;
00426202              edi_5 = &edi_5[1];
00426206              void* eax_36;
00426206              eax_36 = sub_41e7d0(eax_35);
0042620e              esi_4 = esi_4 + eax_36 + 1;
004261f3          }
004261d4      }
004261d4      
00426216      if (esi_4)
00426216      {
0042621d          if (esi_4 == *(uint32_t*)arg4)
0042621d          {
0042621f              *(uint8_t*)esi_4 = 0;
00426222              esi_4 = &esi_4[1];
0042621d          }
0042621d          
00426223          *(uint8_t*)esi_4 = 0;
00426216      }
00426216      
00426226      int32_t var_14_12 = data_430820;
0042622c      sub_41784c(ecx_2);
00426231      data_430820 = 0;
00426239      return 0;
0042603c  }


00426240    int32_t sub_426240(uint32_t arg1, int32_t arg2)

00426240  {
00426248      sub_425610(0x1000);
00426252      int32_t result = 0;
00426252      
00426276      if (arg1 >= data_430f20
00426276              || !(*(uint8_t*)((&data_430e20)[arg1 >> 5] + ((arg1 & 0x1f) << 3) + 4) & 1))
00426375          data_4307d4 = 9;
00426276      else
00426276      {
00426280          uint32_t eax_4 = sub_41b825(arg1, 0, FILE_CURRENT);
00426280          
0042628e          if (eax_4 != 0xffffffff)
0042628e          {
00426298              uint32_t eax_5 = sub_41b825(arg1, 0, FILE_END);
00426298              
004262a3              if (eax_5 != 0xffffffff)
004262a3              {
004262ad                  uint32_t i = arg2 - eax_5;
004262ad                  
004262b1                  if (i > 0)
004262b1                  {
004262c0                      char var_1004[0xfe0];
004262c0                      sub_423620(&var_1004, 0, 0x1000);
004262cb                      int32_t eax_6 = sub_42720f(arg1, 0x8000);
004262cb                      
004262fb                      do
004262fb                      {
004262d6                          uint32_t i_1 = 0x1000;
004262d6                          
004262dd                          if (i < 0x1000)
004262df                              i_1 = i;
004262df                          
004262ea                          int32_t eax_7 = sub_424602(arg1, &var_1004, i_1);
004262ea                          
004262f5                          if (eax_7 == 0xffffffff)
004262f5                          {
00426306                              if (data_4307d8 == 5)
00426308                                  data_4307d4 = 0xd;
00426308                              
00426312                              result = 0xffffffff;
00426312                              break;
004262f5                          }
004262f5                          
004262f7                          i -= eax_7;
004262fb                      } while (i > 0);
004262fb                      
00426319                      sub_42720f(arg1, eax_6);
004262b1                  }
004262b1                  else if (i < 0)
00426322                  {
0042632a                      sub_41b825(arg1, arg2, FILE_BEGIN);
00426339                      BOOL eax_9 = SetEndOfFile(sub_423908(arg1));
00426341                      int32_t esi_1 = -(eax_9);
00426347                      result = -((esi_1 - esi_1)) - 1;
00426347                      
0042634b                      if (result == 0xffffffff)
0042634b                      {
0042634d                          data_4307d4 = 0xd;
0042635d                          data_4307d8 = GetLastError();
0042634b                      }
00426322                  }
00426322                  
00426368                  sub_41b825(arg1, eax_4, FILE_BEGIN);
00426370                  return result;
004262a3              }
0042628e          }
00426276      }
00426276      
0042637f      return 0xffffffff;
00426240  }


00426386    int32_t sub_426386(char* arg1, int32_t arg2)

00426386  {
00426389      int32_t ecx;
00426389      int32_t var_8 = ecx;
0042638a      int32_t var_c = ecx;
0042638a      
00426393      if (arg1)
00426393      {
0042639a          void* eax_1 = sub_425dea(arg1, 0x3d);
0042639a          
004263ad          if (eax_1 && arg1 != eax_1)
004263ad          {
004263af              void* eax_2 = data_4307fc;
004263b9              int32_t ebx_1;
004263b9              (uint8_t)ebx_1 = !*(uint8_t*)((char*)eax_1 + 1);
004263b9              
004263c2              if (eax_2 == data_430800)
004263c2              {
004263c5                  eax_2 = sub_426565(eax_2);
004263cb                  data_4307fc = eax_2;
004263c2              }
004263c2              
004263d2              if (eax_2)
004263d2                  goto label_426428;
004263d2              
004263df              if (!arg2 || !data_430804)
004263df              {
004263f4                  if (ebx_1)
00426506                      return 0;
00426506                  
004263fc                  void* eax_5 = sub_41dbac(4);
00426404                  data_4307fc = eax_5;
00426404                  
00426409                  if (eax_5)
00426409                  {
0042640b                      *(uint32_t*)eax_5 = 0;
0042640b                      
00426413                      if (data_430804)
00426413                          goto label_426428;
00426413                      
00426417                      void* eax_6 = sub_41dbac(4);
0042641f                      data_430804 = eax_6;
0042641f                      
00426424                      if (eax_6)
00426424                      {
00426426                          *(uint32_t*)eax_6 = 0;
00426428                      label_426428:
00426428                          void* esi_2 = (char*)eax_1 - arg1;
0042642b                          int32_t* edi_1 = data_4307fc;
00426438                          int32_t eax_7;
00426438                          int32_t edx_1;
00426438                          eax_7 = sub_42650d(arg1, esi_2);
0042643d                          int32_t esi_3 = eax_7;
00426448                          void* eax_11;
00426448                          
00426448                          if (esi_3 >= 0 && *(uint32_t*)edi_1)
00426448                          {
0042644c                              if (!ebx_1)
00426483                                  edi_1[esi_3] = arg1;
0042644c                              else
0042644c                              {
0042644e                                  void** var_1c_3 = edi_1[esi_3];
00426451                                  void* edi_2 = &edi_1[esi_3];
00426454                                  int32_t edx_2 = sub_41784c(esi_2);
00426454                                  
0042645d                                  while (*(uint32_t*)edi_2)
0042645d                                  {
00426462                                      esi_3 += 1;
00426463                                      *(uint32_t*)edi_2 = *(uint32_t*)((char*)edi_2 + 4);
00426465                                      edi_2 += 4;
0042645d                                  }
0042645d                                  
0042646c                                  int32_t eax_10 = esi_3 << 2;
0042646f                                  int32_t var_1c_4 = eax_10;
00426473                                  eax_11 = sub_4175ac(eax_10, edx_2, var_1c_3, edi_1);
00426473                                  
0042647c                                  if (eax_11)
0042647c                                      goto label_4264b5;
0042644c                              }
0042644c                              
004264ba                          label_4264ba:
004264ba                              
004264be                              if (!arg2)
00426506                                  return 0;
00426506                              
004264d0                              PSTR lpName = sub_41dbac(sub_41e7d0(arg1) + 2);
004264d0                              
004264d6                              if (lpName)
004264d6                              {
004264dc                                  sub_41b8c0(lpName, arg1);
004264e8                                  void* eax_20 = lpName - arg1 + eax_1;
004264eb                                  *(uint8_t*)eax_20 = 0;
004264ef                                  int32_t ebx_2 = -(ebx_1);
004264ff                                  PSTR lpName_1 = lpName;
00426500                                  sub_41784c(SetEnvironmentVariableA(lpName, 
00426500                                      ~(ebx_2 - ebx_2) & ((char*)eax_20 + 1)));
004264d6                              }
004264d6                              
00426506                              return 0;
00426448                          }
00426448                          
0042648a                          if (ebx_1)
00426506                              return 0;
00426506                          
0042648e                          if (esi_3 < 0)
00426490                              esi_3 = -(esi_3);
00426490                          
00426499                          void* var_1c_5 = (esi_3 << 2) + 8;
0042649b                          eax_11 = sub_4175ac((esi_3 << 2) + 8, edx_1, esi_2, edi_1);
0042649b                          
004264a4                          if (eax_11)
004264a4                          {
004264ad                              *(uint32_t*)((char*)eax_11 + (esi_3 << 2)) = arg1;
004264b0                              *(uint32_t*)((char*)eax_11 + (esi_3 << 2) + 4) = 0;
004264b5                          label_4264b5:
004264b5                              data_4307fc = eax_11;
004264b5                              goto label_4264ba;
004264a4                          }
00426424                      }
00426409                  }
004263df              }
004263df              else if (!sub_42196e())
004263e8                  goto label_426428;
004263ad          }
00426393      }
00426393      
004263ea      return 0xffffffff;
00426386  }


0042650d    int32_t sub_42650d(char* arg1, void* arg2)

0042650d  {
0042650e      int32_t* esi = data_4307fc;
00426515      uint8_t* i = *(uint32_t*)esi;
00426515      
00426519      while (i)
00426519      {
0042652f          if (!sub_42192f(arg1, i, arg2))
0042652f          {
00426533              char* eax_1;
00426533              (uint8_t)eax_1 = *(uint8_t*)(*(uint32_t*)esi + arg2);
00426533              
0042653c              if ((uint8_t)eax_1 == 0x3d || !(uint8_t)eax_1)
00426560                  return ((char*)esi - data_4307fc) >> 2;
0042652f          }
0042652f          
0042653e          i = esi[1];
00426541          esi = &esi[1];
00426519      }
00426519      
00426553      return -((((char*)esi - data_4307fc) >> 2));
0042650d  }


00426565    void* sub_426565(int32_t* arg1)

00426565  {
0042656a      int32_t ecx = 0;
0042656a      
0042656e      if (!arg1)
00426573          return 0;
00426573      
00426577      int32_t* eax_1 = &arg1[1];
00426577      
0042657a      if (*(uint32_t*)arg1)
0042657a      {
00426584          int32_t i;
00426584          
00426584          do
00426584          {
0042657c              i = *(uint32_t*)eax_1;
0042657e              ecx += 1;
0042657f              eax_1 = &eax_1[1];
00426584          } while (i);
0042657a      }
0042657a      
00426596      void* result_1 = sub_41dbac((ecx << 2) + 4);
0042659b      void* result = result_1;
0042659b      
0042659d      if (!result_1)
004265a1          sub_41720a(9);
004265a1      
004265a7      char* i_1 = *(uint32_t*)arg1;
004265a9      int32_t* ebx = arg1;
004265a9      
004265ad      while (i_1)
004265ad      {
004265b0          ebx = &ebx[1];
004265b8          *(uint32_t*)result_1 = sub_421505(i_1);
004265ba          i_1 = *(uint32_t*)ebx;
004265bd          result_1 += 4;
004265ad      }
004265ad      
004265c2      *(uint32_t*)result_1 = 0;
004265cb      return result;
00426565  }


004265cc    int32_t sub_4265cc(char* arg1)

004265cc  {
004265d0      char* edi = arg1;
004265db      BOOL eax_2;
004265db      wchar16 (* ecx)[0x21];
004265db      int32_t edx;
004265db      
004265db      while (true)
004265db      {
004265db          if (data_42d07c <= 1)
004265db          {
004265ef              ecx = data_42ce70;
004265f5              uint32_t eax_3;
004265f5              (uint8_t)eax_3 = (*(uint528_t*)ecx)[(uint32_t)*(uint8_t*)edi];
004265f8              eax_2 = eax_3 & 8;
004265db          }
004265db          else
004265db          {
004265dd              uint32_t eax_1 = (uint32_t)*(uint8_t*)edi;
004265e3              eax_2 = sub_4179df(eax_1, edx, ecx, eax_1);
004265e9              ecx = 8;
004265db          }
004265db          
004265fd          if (!eax_2)
004265fd              break;
004265fd          
004265ff          edi = &edi[1];
004265db      }
004265db      
00426602      uint32_t esi = (uint32_t)*(uint8_t*)edi;
00426605      void* edi_1 = &edi[1];
00426609      uint32_t ebp = esi;
00426609      
00426610      if (esi == 0x2d || esi == 0x2b)
00426610      {
00426612          esi = (uint32_t)*(uint8_t*)edi_1;
00426615          edi_1 += 1;
00426610      }
00426610      
00426616      int32_t result = 0;
00426616      
0042661f      while (true)
0042661f      {
0042661f          BOOL eax_4;
0042661f          
0042661f          if (data_42d07c <= 1)
0042661f          {
00426632              wchar16 (* eax_5)[0x21];
00426632              (uint8_t)eax_5 = (**(uint528_t**)&data_42ce70)[esi];
00426635              eax_4 = eax_5 & 4;
0042661f          }
0042661f          else
0042661f          {
00426624              eax_4 = sub_4179df(eax_2, edx, ecx, esi);
0042662a              ecx = 4;
0042661f          }
0042661f          
0042663a          if (!eax_4)
0042663a              break;
0042663a          
0042663c          eax_2 = result * 5;
0042663f          result = esi + (eax_2 << 1) - 0x30;
00426643          esi = (uint32_t)*(uint8_t*)edi_1;
00426646          edi_1 += 1;
0042661f      }
0042661f      
0042664e      if (ebp != 0x2d)
00426656          return result;
00426656      
00426650      return -(result);
004265cc  }


00426657    int32_t sub_426657(int32_t arg1, uint32_t arg2, uint32_t arg3, void** arg4)

00426657  {
00426664      int32_t ebx;
00426664      int32_t var_88 = ebx;
00426664      
00426667      if (arg1 == 1)
00426667      {
00426679          void var_84;
00426679          void* edi_1 = &var_84;
0042667f          arg1 = 0;
0042668a          int32_t esi_1 = sub_427398(arg2, arg3, &var_84, 0x80, 0);
00426691          void* var_94_3;
00426691          
00426691          if (esi_1)
00426691          {
004266e1          label_4266e1:
004266e1              void* eax_6 = sub_41dbac(esi_1);
004266ec              *(uint32_t*)arg4 = eax_6;
004266ec              
004266ee              if (eax_6)
004266ee              {
00426707                  void** ecx_4 = sub_417ef0(eax_6, edi_1, esi_1);
00426707                  
00426712                  if (arg1)
00426712                  {
00426714                      void* var_94_5 = edi_1;
00426715                      sub_41784c(ecx_4);
00426712                  }
00426712                  
00426788                  return 0;
004266ee              }
004266ee              
004266f3              if (arg1)
004266f3              {
004266f5                  var_94_3 = edi_1;
004266f6                  sub_41784c(arg4);
004266f3              }
00426691          }
00426691          else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
0042669c          {
004266a7              int32_t eax_3 = sub_427398(arg2, arg3, nullptr, 0, 0);
004266a7              
004266b3              if (eax_3)
004266b3              {
004266bb                  edi_1 = sub_41dbac(eax_3);
004266bb                  
004266c0                  if (edi_1)
004266c0                  {
004266c5                      arg1 = 1;
004266d2                      int32_t eax_5;
004266d2                      void** ecx_2;
004266d2                      eax_5 = sub_427398(arg2, arg3, edi_1, eax_3, 0);
004266d7                      esi_1 = eax_5;
004266d7                      
004266de                      if (esi_1)
004266de                          goto label_4266e1;
004266de                      
004266f5                      var_94_3 = edi_1;
004266f6                      sub_41784c(ecx_2);
004266c0                  }
004266b3              }
0042669c          }
00426667      }
00426667      else if (!arg1)
00426721      {
00426725          void* i = &data_430bac;
00426733          int32_t eax_8;
00426733          wchar16 (* ecx_6)[0x21];
00426733          int32_t edx_1;
00426733          eax_8 = sub_427285(arg2, arg3, &data_430bac, 4, 0);
00426733          
0042673d          if (eax_8)
0042673d          {
00426742              *(uint8_t*)arg4 = nullptr;
00426742              
00426786              do
00426786              {
0042674c                  (uint8_t)ebx = *(uint8_t*)i;
0042674e                  BOOL eax_10;
0042674e                  
0042674e                  if (data_42d07c <= 1)
0042674e                  {
00426768                      uint32_t eax_11;
00426768                      (uint8_t)eax_11 =
00426768                          (**(uint528_t**)&data_42ce70)[(uint32_t)(uint8_t)ebx];
0042676b                      eax_10 = eax_11 & 4;
0042674e                  }
0042674e                  else
0042674e                  {
00426750                      uint32_t eax_9 = (uint32_t)(uint8_t)ebx;
00426756                      eax_10 = sub_4179df(eax_9, edx_1, ecx_6, eax_9);
0042674e                  }
0042674e                  
00426770                  if (!eax_10)
00426770                      break;
00426770                  
00426772                  (uint8_t)eax_10 = *(uint8_t*)arg4;
00426774                  (uint8_t)ecx_6 = 0xa;
00426776                  (uint16_t)eax_10 = (uint8_t)eax_10 * 0xa;
00426778                  (uint8_t)eax_10 += (uint8_t)ebx;
0042677a                  (uint8_t)eax_10 -= 0x30;
0042677d                  i += 2;
0042677e                  *(uint8_t*)arg4 = (uint8_t)eax_10;
00426786              } while (i < &data_430bb4);
00426786              
00426788              return 0;
0042673d          }
00426721      }
00426721      
004266fc      return 0xffffffff;
00426657  }


0042678f    BOOL sub_42678f(uint32_t arg1, wchar16* arg2, int32_t arg3, char* arg4, uint32_t arg5, uint32_t arg6)

0042678f  {
00426792      int32_t var_8 = 0xffffffff;
00426794      int32_t var_c = 0x429b90;
00426799      int32_t var_10 = 0x41c5cc;
004267a4      TEB* fsbase;
004267a4      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
004267a5      fsbase->NtTib.ExceptionList = &ExceptionList;
004267b2      int32_t __saved_edi;
004267b2      int32_t* var_1c = &__saved_edi;
004267b5      int32_t eax_1 = data_430bb4;
004267b5      
004267be      if (eax_1)
004267be          goto label_4267fe;
004267be      
004267d6      uint16_t charType;
004267d6      BOOL result;
004267d6      
004267d6      if (!GetStringTypeW(1, &data_429368, 1, &charType))
004267d6      {
004267f0          if (GetStringTypeA(0, 1, &data_429364, 1, &charType))
004267f0          {
004267f8              eax_1 = 2;
004267f8              goto label_4267f9;
004267f0          }
004267f0          
00426940          result = 0;
004267d6      }
004267d6      else
004267d6      {
004267d8          eax_1 = 1;
004267f9      label_4267f9:
004267f9          data_430bb4 = eax_1;
004267fe      label_4267fe:
004267fe          
00426801          if (eax_1 == 1)
0042680f              result = GetStringTypeW(arg1, arg2, arg3, arg4);
00426801          else if (eax_1 != 2)
00426940              result = 0;
0042681d          else
0042681d          {
00426826              if (!arg5)
0042682d                  arg5 = data_430a24;
0042682d              
00426842              int32_t eax_5 = WideCharToMultiByte(arg5, 0x220, arg2, arg3, nullptr, 0, 
00426842                  nullptr, nullptr);
00426842              
0042684f              if (!eax_5)
00426940                  result = 0;
0042684f              else
0042684f              {
00426855                  int32_t var_8_1 = 0;
0042685b                  int32_t eax_6;
0042685b                  (uint8_t)eax_6 = (eax_5 + 3) & 0xfc;
0042685d                  sub_425610(eax_6);
00426862                  int32_t* var_1c_1 = &__saved_edi;
00426867                  PSTR var_30_1 = &__saved_edi;
0042686d                  sub_423620(&__saved_edi, 0, eax_5);
00426875                  int32_t var_8_2 = 0xffffffff;
00426875                  
00426891                  if (!var_30_1)
00426940                      result = 0;
00426891                  else if (!WideCharToMultiByte(arg5, 0x220, arg2, arg3, var_30_1, eax_5, 
00426891                          nullptr, nullptr))
00426940                      result = 0;
004268b3                  else
004268b3                  {
004268b9                      int32_t var_8_3 = 1;
004268c7                      int32_t eax_9;
004268c7                      (uint8_t)eax_9 = (eax_5 * 2 + 5) & 0xfc;
004268c9                      sub_425610(eax_9);
004268ce                      int32_t* var_1c_2 = &__saved_edi;
004268d3                      int32_t* var_28_1 = &__saved_edi;
004268e3                      int32_t var_8_4 = 0xffffffff;
004268e3                      
004268e9                      if (!&__saved_edi)
00426940                          result = 0;
004268e9                      else
004268e9                      {
004268eb                          uint32_t Locale = arg6;
004268eb                          
004268f0                          if (!Locale)
004268f2                              Locale = data_430a14;
004268f2                          
004268fa                          int32_t edi_1 = arg3 * 2;
004268fd                          void* esi_2 = edi_1 + &__saved_edi;
00426900                          *(uint16_t*)esi_2 = 0xffff;
00426905                          *(uint16_t*)((char*)esi_2 - 2) = 0xffff;
00426916                          BOOL result_1 =
00426916                              GetStringTypeA(Locale, arg1, var_30_1, eax_5, &__saved_edi);
00426916                          
0042692c                          if (*(uint16_t*)((char*)esi_2 - 2) == 0xffff
0042692c                                  || *(uint16_t*)esi_2 != 0xffff)
00426940                              result = 0;
0042692c                          else
0042692c                          {
00426933                              sub_424ef0(arg4, &__saved_edi, edi_1);
0042693b                              result = result_1;
0042692c                          }
004268e9                      }
004268b3                  }
0042684f              }
0042681d          }
004267d6      }
004267d6      
00426948      fsbase->NtTib.ExceptionList = ExceptionList;
00426953      return result;
0042678f  }


0042687b    int32_t sub_42687b() __pure

0042687b  {
0042687e      return 1;
0042687b  }


0042687f    int32_t sub_42687f(void* arg1 @ ebp)

0042687f  {
0042687f      int32_t esp_24 = *(uint32_t*)((char*)arg1 - 0x18);
00426884      *(uint32_t*)((char*)arg1 - 0x2c) = 0;
00426887      *(uint32_t*)((char*)arg1 - 4) = 0xffffffff;
0042688b      int32_t esi = *(uint32_t*)((char*)arg1 - 0x28);
00426891      int32_t result;
00426891      
00426891      if (!*(uint32_t*)((char*)arg1 - 0x2c))
00426940          result = 0;
00426891      else
00426891      {
00426897          *(uint32_t*)(esp_24 - 4) = 0;
00426898          *(uint32_t*)(esp_24 - 8) = 0;
00426899          *(uint32_t*)(esp_24 - 0xc) = esi;
0042689a          *(uint32_t*)(esp_24 - 0x10) = *(uint32_t*)((char*)arg1 - 0x2c);
0042689d          *(uint32_t*)(esp_24 - 0x14) = *(uint32_t*)((char*)arg1 + 0x10);
004268a0          *(uint32_t*)(esp_24 - 0x18) = *(uint32_t*)((char*)arg1 + 0xc);
004268a3          *(uint32_t*)(esp_24 - 0x1c) = 0x220;
004268a8          *(uint32_t*)(esp_24 - 0x20) = *(uint32_t*)((char*)arg1 + 0x18);
004268a8          
004268b3          if (!WideCharToMultiByte())
00426940              result = 0;
004268b3          else
004268b3          {
004268b9              *(uint32_t*)((char*)arg1 - 4) = 1;
004268c7              int32_t eax_3;
004268c7              (uint8_t)eax_3 = (esi * 2 + 5) & 0xfc;
004268c9              sub_425610(eax_3);
004268ce              *(uint32_t*)((char*)arg1 - 0x18) = esp_24;
004268d3              *(uint32_t*)((char*)arg1 - 0x24) = esp_24;
004268e3              *(uint32_t*)((char*)arg1 - 4) = 0xffffffff;
004268e3              
004268e9              if (!esp_24)
00426940                  result = 0;
004268e9              else
004268e9              {
004268eb                  int32_t eax_4 = *(uint32_t*)((char*)arg1 + 0x1c);
004268eb                  
004268f0                  if (!eax_4)
004268f2                      eax_4 = data_430a14;
004268f2                  
004268fa                  void* edi_1 = *(uint32_t*)((char*)arg1 + 0x10) * 2;
004268fd                  int16_t* esi_1 = (char*)edi_1 + esp_24;
00426900                  *(uint16_t*)esi_1 = 0xffff;
00426905                  esi_1[-1] = 0xffff;
0042690b                  *(uint32_t*)(esp_24 - 4) = esp_24;
0042690c                  *(uint32_t*)(esp_24 - 8) = *(uint32_t*)((char*)arg1 - 0x28);
0042690f                  *(uint32_t*)(esp_24 - 0xc) = *(uint32_t*)((char*)arg1 - 0x2c);
00426912                  *(uint32_t*)(esp_24 - 0x10) = *(uint32_t*)((char*)arg1 + 8);
00426915                  *(uint32_t*)(esp_24 - 0x14) = eax_4;
0042691c                  *(uint32_t*)((char*)arg1 - 0x20) = GetStringTypeA();
0042691c                  
0042692c                  if (esi_1[-1] == 0xffff || *(uint16_t*)esi_1 != 0xffff)
00426940                      result = 0;
0042692c                  else
0042692c                  {
0042692e                      *(uint32_t*)(esp_24 - 4) = edi_1;
0042692f                      *(uint32_t*)(esp_24 - 8) = esp_24;
00426930                      *(uint32_t*)(esp_24 - 0xc) = *(uint32_t*)((char*)arg1 + 0x14);
00426933                      sub_424ef0();
0042693b                      result = *(uint32_t*)((char*)arg1 - 0x20);
0042692c                  }
004268e9              }
004268b3          }
00426891      }
00426891      
00426948      TEB* fsbase;
00426948      fsbase->NtTib.ExceptionList = *(uint32_t*)((char*)arg1 - 0x10);
0042694f      *(uint32_t*)((char*)arg1 - 0x38);
00426950      *(uint32_t*)((char*)arg1 - 0x34);
00426951      *(uint32_t*)((char*)arg1 - 0x30);
00426952      *(uint32_t*)arg1;
00426953      return result;
0042687f  }


004268d8    int32_t sub_4268d8() __pure

004268d8  {
004268db      return 1;
004268d8  }


004268dc    int32_t sub_4268dc(void* arg1 @ ebp)

004268dc  {
004268dc      *(uint32_t*)((char*)arg1 - 0x18);
004268e3      *(uint32_t*)((char*)arg1 - 4) = 0xffffffff;
00426948      TEB* fsbase;
00426948      fsbase->NtTib.ExceptionList = *(uint32_t*)((char*)arg1 - 0x10);
0042694f      *(uint32_t*)((char*)arg1 - 0x38);
00426950      *(uint32_t*)((char*)arg1 - 0x34);
00426951      *(uint32_t*)((char*)arg1 - 0x30);
00426952      *(uint32_t*)arg1;
00426953      return 0;
004268dc  }

00426954                                                              cc cc cc cc cc cc cc cc cc cc cc cc                      ............

00426960    int32_t sub_426960(char* arg1, char* arg2, int32_t arg3)

00426960  {
00426969      int32_t result = arg3;
00426969      
0042696b      if (result)
0042696b      {
00426971          char* esi_1 = arg1;
00426974          char* edi_1 = arg2;
00426974          
00426981          if (data_430a14)
00426981          {
004269ca              char* edi_2 = edi_1;
004269ca              
004269cc              while (true)
004269cc              {
004269cc                  uint32_t eax_2;
004269cc                  (uint8_t)eax_2 = *(uint8_t*)esi_1;
004269d0                  uint32_t ebx_1;
004269d0                  (uint8_t)ebx_1 = *(uint8_t*)edi_2;
004269d6                  bool cond:0_1;
004269d6                  
004269d6                  if (!eax_2 || !ebx_1)
004269d6                  {
004269f7                  label_4269f7:
004269f7                      result = 0;
004269f9                      cond:0_1 = eax_2 < ebx_1;
004269f9                      
004269fb                      if (eax_2 == ebx_1)
004269fb                          break;
004269d6                  }
004269d6                  else
004269d6                  {
004269d8                      esi_1 = &esi_1[1];
004269d9                      edi_2 = &edi_2[1];
004269db                      uint32_t var_18_1 = eax_2;
004269dc                      uint32_t var_1c_1 = ebx_1;
004269dd                      uint32_t eax_3;
004269dd                      int32_t ecx_1;
004269dd                      eax_3 = sub_418a84(result);
004269e2                      ebx_1 = eax_3;
004269e7                      eax_2 = sub_418a84(ecx_1);
004269f0                      cond:0_1 = eax_2 < ebx_1;
004269f0                      
004269f2                      if (eax_2 == ebx_1)
004269f2                      {
004269f4                          int32_t result_2 = result;
004269f4                          result -= 1;
004269f4                          
004269f5                          if (result_2 != 1)
004269f5                              continue;
004269f5                          
004269f5                          goto label_4269f7;
004269f2                      }
004269d6                  }
004269d6                  
004269fd                  result = 0xffffffff;
004269fd                  
00426a02                  if (!cond:0_1)
00426a04                      return 1;
00426a04                  
00426a02                  break;
004269cc              }
00426981          }
00426981          else
00426981          {
00426989              int32_t result_1 = result;
00426989              
0042698c              while (true)
0042698c              {
0042698c                  int16_t eax_1;
0042698c                  *(uint8_t*)((char*)eax_1)[1] = *(uint8_t*)esi_1;
0042698e                  *(uint8_t*)((char*)eax_1)[1] = *(uint8_t*)((char*)eax_1)[1];
0042698e                  bool cond:3_1 = !*(uint8_t*)((char*)eax_1)[1];
00426990                  (uint8_t)eax_1 = *(uint8_t*)edi_1;
00426992                  bool cond:1_1;
00426992                  
00426992                  if (cond:3_1)
00426992                  {
004269b5                  label_4269b5:
004269b5                      result = 0;
004269b7                      cond:1_1 = *(uint8_t*)((char*)eax_1)[1] < (uint8_t)eax_1;
004269b7                      
004269b9                      if (*(uint8_t*)((char*)eax_1)[1] == (uint8_t)eax_1)
004269b9                          break;
00426992                  }
00426992                  else
00426992                  {
00426994                      (uint8_t)eax_1 = (uint8_t)eax_1;
00426994                      
00426996                      if (!(uint8_t)eax_1)
00426996                          goto label_4269b5;
00426996                      
00426998                      esi_1 = &esi_1[1];
00426999                      edi_1 = &edi_1[1];
00426999                      
004269a0                      if (*(uint8_t*)((char*)eax_1)[1] >= 0x41
004269a0                              && *(uint8_t*)((char*)eax_1)[1] <= 0x5a)
004269a2                          *(uint8_t*)((char*)eax_1)[1] += 0x20;
004269a2                      
004269aa                      if ((uint8_t)eax_1 >= 0x41 && (uint8_t)eax_1 <= 0x5a)
004269ac                          (uint8_t)eax_1 += 0x20;
004269ac                      
004269ae                      cond:1_1 = *(uint8_t*)((char*)eax_1)[1] < (uint8_t)eax_1;
004269ae                      
004269b0                      if (*(uint8_t*)((char*)eax_1)[1] == (uint8_t)eax_1)
004269b0                      {
004269b2                          int32_t result_3 = result_1;
004269b2                          result_1 -= 1;
004269b2                          
004269b3                          if (result_3 != 1)
004269b3                              continue;
004269b3                          
004269b3                          goto label_4269b5;
004269b0                      }
00426992                  }
00426992                  
004269bb                  result = 0xffffffff;
004269bb                  
004269c0                  if (!cond:1_1)
004269c2                      return 1;
004269c2                  
004269c0                  break;
0042698c              }
00426981          }
0042696b      }
0042696b      
00426a0c      return result;
00426960  }


00426a0d    char* sub_426a0d(int32_t arg1, char* arg2, int32_t* arg3)

00426a0d  {
00426a23      return sub_42115d(arg1, arg2, arg3, nullptr);
00426a0d  }


00426a24    int32_t sub_426a24(int16_t* arg1, char* arg2, int32_t arg3)

00426a24  {
00426a35      if (arg2 && arg3)
00426a35      {
00426a37          uint16_t eax;
00426a37          (uint8_t)eax = *(uint8_t*)arg2;
00426a37          
00426a3b          if ((uint8_t)eax)
00426a3b          {
00426a53              if (data_430a14)
00426a53              {
00426a76                  if (*
00426a76                      (uint8_t*)(&(**(uint528_t**)&data_42ce70)[(uint32_t)(uint8_t)eax] + 1)
00426a76                      & 0x80)
00426a76                  {
00426a78                      int32_t cbMultiByte = data_42d07c;
00426a78                      
00426a80                      if (cbMultiByte <= 1)
00426a80                      {
00426aac                      label_426aac:
00426aac                          
00426ab4                          if (arg3 >= cbMultiByte && arg2[1])
00426a4c                              return cbMultiByte;
00426a80                      }
00426a80                      else if (arg3 >= cbMultiByte)
00426a85                      {
00426a8c                          int32_t cchWideChar_1;
00426a8c                          (uint8_t)cchWideChar_1 = arg1;
00426aa3                          bool cond:0_1 = MultiByteToWideChar(data_430a24, 
00426aa3                              MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, arg2, cbMultiByte, 
00426aa3                              arg1, cchWideChar_1);
00426aa5                          cbMultiByte = data_42d07c;
00426aa5                          
00426aaa                          if (cond:0_1)
00426a4c                              return cbMultiByte;
00426a4c                          
00426aaa                          goto label_426aac;
00426a85                      }
00426a85                      
00426ab6                      data_4307d4 = 0x2a;
00426ac0                      return 0xffffffff;
00426a76                  }
00426a76                  
00426aca                  int32_t cchWideChar;
00426aca                  (uint8_t)cchWideChar = arg1;
00426aca                  
00426ae4                  if (!MultiByteToWideChar(data_430a24, 
00426ae4                      MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, arg2, 1, arg1, cchWideChar))
00426ae4                  {
00426ab6                      data_4307d4 = 0x2a;
00426ac0                      return 0xffffffff;
00426ae4                  }
00426a53              }
00426a53              else if (arg1)
00426a60                  *(uint16_t*)arg1 = (uint16_t)(uint8_t)eax;
00426a60              
00426a65              return 1;
00426a3b          }
00426a3b          
00426a42          if (arg1)
00426a44              *(uint16_t*)arg1 = 0;
00426a35      }
00426a35      
00426a47      return 0;
00426a24  }


00426aec    BOOL sub_426aec(int32_t arg1)

00426aec  {
00426af3      if (data_42d07c > 1)
00426af3      {
00426b02          int32_t eax;
00426b02          int32_t ecx;
00426b02          int32_t edx;
00426b02          return sub_4179df(eax, edx, ecx, arg1);
00426af3      }
00426af3      
00426b0d      int32_t eax_2;
00426b0d      (uint8_t)eax_2 = (**(uint528_t**)&data_42ce70)[arg1];
00426b13      return eax_2 & 8;
00426aec  }

00426b14                                                              cc cc cc cc cc cc cc cc cc cc cc cc                      ............

00426b20    int32_t __convention("regparm") __allshl(int32_t arg1, int32_t arg2, char arg3) __pure

00426b20  {
00426b23      if (arg3 >= 0x40)
00426b3e          return 0;
00426b3e      
00426b28      if (arg3 >= 0x20)
00426b39          return 0;
00426b39      
00426b2f      return arg1 << arg3;
00426b20  }


00426b3f    int32_t sub_426b3f(int32_t arg1, int32_t arg2, int32_t* arg3)

00426b3f  {
00426b48      int32_t result = 0;
00426b4a      int32_t ecx = arg1 + arg2;
00426b4a      
00426b53      if (ecx < arg1 || ecx < arg2)
00426b57          result = 1;
00426b57      
00426b5d      *(uint32_t*)arg3 = ecx;
00426b5f      return result;
00426b3f  }


00426b60    int32_t sub_426b60(int32_t* arg1, int32_t* arg2)

00426b60  {
00426b79      if (sub_426b3f(*(uint32_t*)arg1, *(uint32_t*)arg2, arg1)
00426b79              && sub_426b3f(arg1[1], 1, &arg1[1]))
00426b8f          arg1[2] += 1;
00426b8f      
00426ba5      if (sub_426b3f(arg1[1], arg2[1], &arg1[1]))
00426ba7          arg1[2] += 1;
00426ba7      
00426bbd      return sub_426b3f(arg1[2], arg2[2], &arg1[2]);
00426b60  }


00426bbe    int32_t* sub_426bbe(int32_t* arg1)

00426bbe  {
00426bc4      int32_t esi = *(uint32_t*)arg1;
00426bc6      int32_t edi = arg1[1];
00426bcd      *(uint32_t*)arg1 = esi * 2;
00426bd7      int32_t ecx_2 = arg1[2];
00426bdc      arg1[1] = (edi * 2) | esi >> 0x1f;
00426be7      arg1[2] = ecx_2 << 1 | edi >> 0x1f;
00426beb      return arg1;
00426bbe  }


00426bec    int32_t* sub_426bec(int32_t* arg1)

00426bec  {
00426bf2      int32_t edx = arg1[2];
00426bf5      int32_t ecx = arg1[1];
00426c03      arg1[1] = ecx >> 1 | edx << 0x1f;
00426c0f      int32_t ecx_5 = *(uint32_t*)arg1 >> 1 | ecx << 0x1f;
00426c12      arg1[2] = edx >> 1;
00426c15      *(uint32_t*)arg1 = ecx_5;
00426c18      return arg1;
00426bec  }


00426c19    int32_t sub_426c19(char* arg1, int32_t arg2, int32_t arg3)

00426c19  {
00426c23      int32_t* ebx = arg3;
00426c2b      int32_t var_8 = 0x404e;
00426c32      *(uint32_t*)ebx = 0;
00426c34      ebx[1] = 0;
00426c37      ebx[2] = 0;
00426c37      
00426c3a      if (arg2 > 0)
00426c3a      {
00426c3d          arg3 = arg2;
00426c88          int32_t i;
00426c88          
00426c88          do
00426c88          {
00426c45              int32_t var_14 = *(uint32_t*)ebx;
00426c45              int32_t var_10;
00426c45              int32_t* edi_1 = &var_10;
00426c45              void* esi_2 = &ebx[1];
00426c46              *(uint32_t*)edi_1 = *(uint32_t*)esi_2;
00426c48              edi_1[1] = *(uint32_t*)((char*)esi_2 + 4);
00426c49              sub_426bbe(ebx);
00426c4f              sub_426bbe(ebx);
00426c59              sub_426b60(ebx, &var_14);
00426c5f              sub_426bbe(ebx);
00426c67              var_10 = 0;
00426c6b              int32_t var_c_1 = 0;
00426c72              var_14 = (int32_t)*(uint8_t*)arg1;
00426c7a              sub_426b60(ebx, &var_14);
00426c82              arg1 = &arg1[1];
00426c85              i = arg3;
00426c85              arg3 -= 1;
00426c88          } while (i != 1);
00426c3a      }
00426c3a      
00426c90      while (!ebx[2])
00426c90      {
00426c92          int32_t ecx_1 = ebx[1];
00426c9a          ebx[2] = ecx_1 >> 0x10;
00426c9d          int32_t eax_4 = *(uint32_t*)ebx;
00426cac          var_8 += 0xfff0;
00426cb3          ebx[1] = eax_4 >> 0x10 | ecx_1 << 0x10;
00426cb6          *(uint32_t*)ebx = eax_4 << 0x10;
00426c90      }
00426c90      
00426cc2      while (!(ebx[2] & 0x8000))
00426cc2      {
00426cc5          sub_426bbe(ebx);
00426cca          var_8 += 0xffff;
00426cc2      }
00426cc2      
00426cd4      int32_t result;
00426cd4      (uint16_t)result = (uint16_t)var_8;
00426cd9      *(uint16_t*)((char*)ebx + 0xa) = (uint16_t)result;
00426cdf      return result;
00426c19  }


00426ce0    int32_t sub_426ce0(int16_t arg1, void* arg2, char arg3, void* arg4)

00426ce0  {
00426cea      int16_t* ebx = arg4;
00426cf5      int16_t ecx_1 = arg1 & 0x8000;
00426cfb      int16_t eax_1 = arg1 & 0x7fff;
00426d01      char var_20 = 0xcc;
00426d05      char var_1f = 0xcc;
00426d09      char var_1e = 0xcc;
00426d0d      char var_1d = 0xcc;
00426d11      char var_1c = 0xcc;
00426d15      char var_1b = 0xcc;
00426d19      char var_1a = 0xcc;
00426d1d      char var_19 = 0xcc;
00426d21      char var_18 = 0xcc;
00426d25      char var_17 = 0xcc;
00426d29      char var_16 = 0xfb;
00426d2d      char var_15 = 0x3f;
00426d31      int32_t result = 1;
00426d31      
00426d3a      if (!ecx_1)
00426d42          ebx[1] = 0x20;
00426d3a      else
00426d3c          ebx[1] = 0x2d;
00426d3c      
00426d46      int32_t arg_8;
00426d46      int32_t edi = arg_8;
00426d55      int32_t arg_4;
00426d55      
00426d55      if (eax_1 || edi || arg_4 != edi)
00426d55      {
00426d6f          if (eax_1 == 0x7fff)
00426d6f          {
00426d76              *(uint16_t*)ebx = 1;
00426d76              
00426d8b              if ((edi != 0x80000000 || arg_4) && !(edi & 0x40000000))
00426d8b              {
00426dde                  sub_41b8c0(&ebx[2], "1#SNAN");
00426de4                  *(uint8_t*)((char*)ebx + 3) = 6;
00426d8b              }
00426d8b              else if (ecx_1 && edi == 0xc0000000)
00426d9f              {
00426da5                  if (arg_4)
00426da5                      goto label_426dd5;
00426da5                  
00426dc1                  sub_41b8c0(&ebx[2], "1#IND");
00426dc7                  *(uint8_t*)((char*)ebx + 3) = 5;
00426d9f              }
00426d9f              else if (edi != 0x80000000 || arg_4)
00426db6              {
00426dd5              label_426dd5:
00426dde                  sub_41b8c0(&ebx[2], "1#QNAN");
00426de4                  *(uint8_t*)((char*)ebx + 3) = 6;
00426db6              }
00426db6              else
00426db6              {
00426dc1                  sub_41b8c0(&ebx[2], "1#INF");
00426dc7                  *(uint8_t*)((char*)ebx + 3) = 5;
00426db6              }
00426db6              
00426dcc              return 0;
00426d6f          }
00426d6f          
00426deb          uint32_t eax_4 = (uint32_t)eax_1;
00426dfe          int16_t var_14 = 0;
00426e0f          int32_t var_e_1 = edi;
00426e1c          int32_t esi_4 = (((eax_4 >> 8) + (edi >> 0x18 << 1)) * 0x4d + eax_4 * 0x4d10
00426e1c              - 0x134312f4) >> 0x10;
00426e1f          int32_t var_12 = arg_4;
00426e2c          sub_427193(&var_14, -((int32_t)(uint16_t)esi_4), 1);
00426e2c          
00426e3a          if (eax_1 >= 0x3fff)
00426e3a          {
00426e3f              esi_4 += 1;
00426e45              sub_426f73(&var_14, &var_20);
00426e3a          }
00426e3a          
00426e50          *(uint16_t*)ebx = (uint16_t)esi_4;
00426e53          void* edi_2;
00426e53          
00426e53          if (!(arg3 & 1))
00426e66              edi_2 = arg2;
00426e53          else
00426e53          {
00426e5b              edi_2 = (char*)arg2 + (int32_t)(uint16_t)esi_4;
00426e5b              
00426e5f              if (edi_2 <= 0)
00426e5f                  goto label_426d57;
00426e53          }
00426e53          
00426e6c          if (edi_2 > 0x15)
00426e70              edi_2 = 0x15;
00426e70          
00426e7b          int16_t var_a_2 = 0;
00426e80          arg4 = 8;
00426e94          void* i;
00426e94          
00426e94          do
00426e94          {
00426e8b              sub_426bbe(&var_14);
00426e90              i = arg4;
00426e90              arg4 -= 1;
00426e94          } while (i != 1);
00426e94          
00426e98          if ((uint32_t)eax_1 - 0x3ffe < 0)
00426e98          {
00426e9c              uint32_t i_3 = (uint32_t)(uint8_t)-(((uint32_t)eax_1 - 0x3ffe));
00426e9c              
00426ea2              if (i_3 > 0)
00426ea2              {
00426eaf                  uint32_t i_1;
00426eaf                  
00426eaf                  do
00426eaf                  {
00426ea8                      sub_426bec(&var_14);
00426ead                      i_1 = i_3;
00426ead                      i_3 -= 1;
00426eaf                  } while (i_1 != 1);
00426ea2              }
00426e98          }
00426e98          
00426eb4          void* eax_10 = &ebx[2];
00426eb9          arg4 = eax_10;
00426ebc          void* ecx_11;
00426ebc          
00426ebc          if ((char*)edi_2 + 1 > 0)
00426ebc          {
00426ebe              arg2 = (char*)edi_2 + 1;
00426f09              void* i_2;
00426f09              
00426f09              do
00426f09              {
00426ec7                  arg_4 = var_14;
00426ec7                  int32_t* edi_3 = &arg_8;
00426ec7                  void* esi_8 = &*(uint32_t*)((char*)var_12)[2];
00426ec8                  *(uint32_t*)edi_3 = *(uint32_t*)esi_8;
00426ecd                  edi_3[1] = *(uint32_t*)((char*)esi_8 + 4);
00426ece                  sub_426bbe(&var_14);
00426ed7                  sub_426bbe(&var_14);
00426ee4                  sub_426b60(&var_14, &arg_4);
00426eed                  sub_426bbe(&var_14);
00426ef2                  char eax_11 = *(uint8_t*)((char*)var_a_2)[1];
00426ef5                  ecx_11 = arg4;
00426ef8                  *(uint8_t*)((char*)var_a_2)[1] = 0;
00426f01                  arg4 += 1;
00426f04                  i_2 = arg2;
00426f04                  arg2 -= 1;
00426f07                  *(uint8_t*)ecx_11 = eax_11 + 0x30;
00426f09              } while (i_2 != 1);
00426f0b              eax_10 = arg4;
00426ebc          }
00426ebc          
00426f0e          (uint8_t)ecx_11 = *(uint8_t*)((char*)eax_10 - 1);
00426f12          void* eax_13 = (char*)eax_10 - 2;
00426f12          
00426f19          if ((uint8_t)ecx_11 >= 0x35)
00426f19          {
00426f1d              while (true)
00426f1d              {
00426f1d                  if (eax_13 >= &ebx[2])
00426f1d                  {
00426f22                      if (*(uint8_t*)eax_13 == 0x39)
00426f22                      {
00426f24                          *(uint8_t*)eax_13 = 0x30;
00426f27                          eax_13 -= 1;
00426f28                          continue;
00426f22                      }
00426f22                      else if (eax_13 >= &ebx[2])
00426f2c                          break;
00426f1d                  }
00426f1d                  
00426f2e                  eax_13 += 1;
00426f2f                  *(uint16_t*)ebx += 1;
00426f2f                  break;
00426f1d              }
00426f1d              
00426f32              *(uint8_t*)eax_13 += 1;
00426f32              goto label_426f34;
00426f19          }
00426f19          
00426f4d          while (true)
00426f4d          {
00426f4d              if (eax_13 < &ebx[2])
00426f4d                  goto label_426f5b;
00426f4d              
00426f52              if (*(uint8_t*)eax_13 != 0x30)
00426f52                  break;
00426f52              
00426f54              eax_13 -= 1;
00426f4d          }
00426f4d          
00426f59          if (eax_13 >= &ebx[2])
00426f59          {
00426f34          label_426f34:
00426f34              (uint8_t)eax_13 -= (uint8_t)ebx;
00426f36              (uint8_t)eax_13 -= 3;
00426f38              *(uint8_t*)((char*)ebx + 3) = (uint8_t)eax_13;
00426f3e              *(uint8_t*)((int32_t)(uint8_t)eax_13 + ebx + 4) = 0;
00426f43              return result;
00426f59          }
00426f59          
00426f5b      label_426f5b:
00426f5b          *(uint16_t*)ebx = 0;
00426f5f          ebx[1] = 0x20;
00426f63          *(uint8_t*)((char*)ebx + 3) = 1;
00426f67          ebx[2] = 0x30;
00426d55      }
00426d55      else
00426d55      {
00426d57      label_426d57:
00426d57          *(uint16_t*)ebx = 0;
00426d5b          ebx[1] = 0x20;
00426d5f          *(uint8_t*)((char*)ebx + 3) = 1;
00426d63          ebx[2] = 0x30;
00426d55      }
00426d55      
00426f6a      *(uint8_t*)((char*)ebx + 5) = 0;
00426f70      return 1;
00426ce0  }


00426f73    int16_t* sub_426f73(int16_t* arg1, int32_t* arg2)

00426f73  {
00426f7a      int32_t* ebx = arg2;
00426f7e      int16_t* esi = arg1;
00426f81      int32_t ecx;
00426f81      (uint16_t)ecx = *(uint16_t*)((char*)ebx + 0xa);
00426f88      int32_t var_18 = 0;
00426f8b      int32_t var_28 = 0;
00426f8e      int32_t var_24 = 0;
00426f91      int32_t var_20 = 0;
00426f94      int32_t eax;
00426f94      (uint16_t)eax = esi[5];
00426fa1      int16_t* result = eax & 0x7fff;
00426fa3      int32_t* ecx_1 = ecx & 0x7fff;
00426fa5      int32_t edi_2 = (ecx ^ eax) & 0x8000;
00426faf      void* edx = (char*)ecx_1 + result;
00426fb2      arg1 = edx;
00426fb2      
00426fcb      if ((uint16_t)result >= 0x7fff || (uint16_t)ecx_1 >= 0x7fff || (uint16_t)edx > 0xbffd)
00426fcb      {
00427173      label_427173:
00427173          int16_t temp0_1 = (uint16_t)edi_2;
00427173          (uint16_t)edi_2 = -((uint16_t)edi_2);
00427178          *(uint32_t*)((char*)esi + 4) = 0;
00427188          *(uint32_t*)esi = 0;
0042718b          *(uint32_t*)((char*)esi + 8) = ((edi_2 - edi_2) & 0x80000000) + 0x7fff8000;
00426fcb      }
00426fcb      else if ((uint16_t)edx > 0x3fbf)
00426fd6      {
00426fe4          if (!(uint16_t)result)
00426fe6              arg1 += 1;
00426fe6          
00426fec          if ((uint16_t)result || *(uint32_t*)((char*)esi + 8) & 0x7fffffff)
00426fec          {
00426ffe              result = nullptr;
00427003          label_427003:
00427003              
00427003              if (!(uint16_t)ecx_1)
00427005                  arg1 += 1;
00427005              
00427014              if (!(uint16_t)ecx_1 && !(ebx[2] & 0x7fffffff) && !ebx[1] && !*(uint32_t*)ebx)
0042700b                  goto label_427016;
0042700b              
00427023              void* var_14_1 = nullptr;
00427029              int32_t* var_8_1 = &var_24;
00427029              
00427095              for (arg2 = 5; arg2 > 0; arg2 -= 1)
00427095              {
0042703c                  if (arg2 > 0)
0042703c                  {
00427043                      void* var_c_1 = var_14_1 * 2 + esi;
00427049                      void* var_10_1 = &ebx[2];
0042704c                      int32_t* j_1 = arg2;
00427085                      int32_t* j;
00427085                      
00427085                      do
00427085                      {
00427068                          int32_t eax_8;
00427068                          eax_8 = sub_426b3f(var_8_1[-1], 
00427068                              (uint32_t)*(uint16_t*)var_c_1 * (uint32_t)
00427068                                  *(uint16_t*)var_10_1, 
00427068                              &var_8_1[-1]);
00427068                          
00427072                          if (eax_8)
00427077                              *(uint16_t*)var_8_1 += 1;
00427077                          
0042707a                          var_c_1 += 2;
0042707e                          var_10_1 -= 2;
00427082                          j = j_1;
00427082                          j_1 -= 1;
00427085                      } while (j != 1);
0042703c                  }
0042703c                  
00427087                  var_8_1 += 2;
0042708b                  var_14_1 += 1;
00427095              }
00427095              
00427097              arg1 = &arg1[0x6001];
00427097              
004270a3              if ((uint16_t)arg1 <= 0)
004270a3              {
004270ca              label_4270ca:
004270ca                  arg1 += 0xffff;
004270ca                  
004270d6                  if ((uint16_t)arg1 < 0)
004270d6                  {
004270dc                      int32_t i_2 = -((int32_t)(uint16_t)arg1);
004270de                      arg1 += i_2;
004270e1                      int32_t i_1 = i_2;
004270f7                      int32_t i;
004270f7                      
004270f7                      do
004270f7                      {
004270e7                          if ((uint8_t)var_28 & 1)
004270e9                              var_18 += 1;
004270e9                          
004270f0                          sub_426bec(&var_28);
004270f5                          i = i_1;
004270f5                          i_1 -= 1;
004270f7                      } while (i != 1);
004270f7                      
004270fd                      if (var_18)
004270ff                          (uint8_t)var_28 |= 1;
004270d6                  }
004270a3              }
004270a3              else
004270a3              {
004270a9                  while (!(*(uint8_t*)((char*)var_20)[3] & 0x80))
004270a9                  {
004270af                      sub_426bbe(&var_28);
004270b4                      arg1 += 0xffff;
004270b4                      
004270c1                      if ((uint16_t)arg1 <= 0)
004270c1                          break;
004270a9                  }
004270a9                  
004270c8                  if ((uint16_t)arg1 <= 0)
004270c8                      goto label_4270ca;
004270a3              }
004270a3              
00427118              if ((uint16_t)var_28 > 0x8000 || (var_28 & 0x1ffff) == 0x18000)
00427118              {
0042711e                  if (var_28 != 0xffffffff)
0042714c                      var_28 += 1;
0042711e                  else
0042711e                  {
00427120                      var_28 = 0;
00427120                      
00427128                      if (var_24 != 0xffffffff)
00427147                          var_24 += 1;
00427128                      else
00427128                      {
0042712a                          var_24 = 0;
0042712a                          
00427134                          if (*(uint16_t*)((char*)var_20)[2] != 0xffff)
00427141                              *(uint16_t*)((char*)var_20)[2] += 1;
00427134                          else
00427134                          {
00427136                              arg1 += 1;
00427139                              *(uint16_t*)((char*)var_20)[2] = 0x8000;
00427134                          }
00427128                      }
0042711e                  }
00427118              }
00427118              
0042714f              result = arg1;
0042714f              
00427156              if ((uint16_t)result >= 0x7fff)
00427156                  goto label_427173;
00427156              
00427158              (uint16_t)ecx_1 = *(uint16_t*)((char*)var_28)[2];
0042715c              result |= edi_2;
0042715e              *(uint16_t*)esi = (uint16_t)ecx_1;
00427164              *(uint32_t*)((char*)esi + 2) = var_24;
0042716a              *(uint32_t*)((char*)esi + 6) = var_20;
0042716d              esi[5] = (uint16_t)result;
00426fec          }
00426fec          else
00426fec          {
00426fee              result = nullptr;
00426fee              
00426ff7              if (*(uint32_t*)((char*)esi + 4) || *(uint32_t*)esi)
00426ff3                  goto label_427003;
00426ff3              
0042716d              esi[5] = (uint16_t)result;
00426fec          }
00426fd6      }
00426fd6      else
00426fd6      {
00426fd8          result = nullptr;
00427016      label_427016:
00427016          *(uint32_t*)((char*)esi + 8) = 0;
00427019          *(uint32_t*)((char*)esi + 4) = 0;
0042701c          *(uint32_t*)esi = 0;
00426fd6      }
00426fd6      
00427192      return result;
00426f73  }


00427193    void sub_427193(int32_t arg1, int32_t arg2, int32_t arg3)

00427193  {
004271a1      int32_t ebx = 0x430480;
004271a1      
004271a7      if (!arg2)
004271a7          return;
004271a7      
004271a9      if (arg2 < 0)
004271a9      {
004271b5          arg2 = -(arg2);
004271b8          ebx = 0x4305e0;
004271a9      }
004271a9      
004271be      if (!arg3)
004271c3          *(uint16_t*)arg1 = 0;
004271c3      
004271c9      while (arg2)
004271c9      {
004271cd          int32_t eax_2 = arg2;
004271d0          ebx += 0x54;
004271d3          arg2 s>>= 3;
004271d7          int32_t eax = eax_2 & 7;
004271d7          
004271dc          if (eax)
004271dc          {
004271de              int32_t eax_3 = eax * 3;
004271e7              int32_t* esi_1 = ebx + (eax_3 << 2);
004271e7              
004271ea              if (*(uint16_t*)(ebx + (eax_3 << 2)) >= 0x8000)
004271ea              {
004271ef                  int32_t var_10 = *(uint32_t*)esi_1;
004271ef                  void var_c;
004271ef                  int32_t* edi_1 = &var_c;
004271ef                  void* esi_2 = &esi_1[1];
004271f0                  *(uint32_t*)edi_1 = *(uint32_t*)esi_2;
004271f1                  edi_1[1] = *(uint32_t*)((char*)esi_2 + 4);
004271f2                  var_10 -= 1;
004271f5                  esi_1 = &var_10;
004271ea              }
004271ea              
004271fc              sub_426f73(arg1, esi_1);
004271dc          }
004271c9      }
00427193  }


0042720f    int32_t sub_42720f(int32_t arg1, int32_t arg2)

0042720f  {
0042721a      int32_t eax;
0042721a      int32_t ecx_3;
0042721a      char* edx_1;
0042721a      
0042721a      if (arg1 < data_430f20)
0042721a      {
0042721e          eax = arg1 & 0x1f;
00427224          ecx_3 = (&data_430e20)[arg1 >> 5];
0042722b          edx_1 = ecx_3 + (eax << 3) + 4;
0042722f          (uint8_t)ecx_3 = *(uint8_t*)(ecx_3 + (eax << 3) + 4);
0042721a      }
0042721a      
00427236      if (arg1 >= data_430f20 || !((uint8_t)ecx_3 & 1))
00427276          data_4307d4 = 9;
00427236      else
00427236      {
00427238          (uint8_t)eax = (uint8_t)ecx_3;
0042723f          int32_t eax_1 = eax & 0x80;
0042723f          
00427248          if (arg2 == 0x8000)
00427248          {
0042724a              (uint8_t)ecx_3 &= 0x7f;
0042725c          label_42725c:
0042725c              int32_t eax_2 = -(eax_1);
00427260              *(uint8_t*)edx_1 = (uint8_t)ecx_3;
00427262              int32_t eax_3;
00427262              (uint16_t)eax_3 = (eax_2 - eax_2) & 0xc000;
00427269              return eax_3 + 0x8000;
00427248          }
00427248          
00427257          if (arg2 == 0x4000)
00427257          {
00427259              (uint8_t)ecx_3 |= 0x80;
00427259              goto label_42725c;
00427257          }
00427257          
0042726a          data_4307d4 = 0x16;
00427236      }
00427236      
00427284      return 0xffffffff;
0042720f  }


00427285    int32_t sub_427285(uint32_t arg1, uint32_t arg2, wchar16* arg3, int32_t arg4, uint32_t arg5)

00427285  {
00427288      int32_t var_8 = 0xffffffff;
0042728a      int32_t var_c = 0x429bc8;
0042728f      int32_t var_10 = 0x41c5cc;
0042729a      TEB* fsbase;
0042729a      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
0042729b      fsbase->NtTib.ExceptionList = &ExceptionList;
004272a8      int32_t __saved_edi;
004272a8      int32_t* var_1c = &__saved_edi;
004272ab      int32_t eax_1 = data_430bb8;
004272ab      
004272b4      if (eax_1)
004272b4          goto label_4272e4;
004272b4      
004272c3      int32_t result;
004272c3      int32_t var_38_1;
004272c3      
004272c3      if (!GetLocaleInfoW(0, 1, nullptr, 0))
004272c3      {
004272d6          if (GetLocaleInfoA(0, 1, nullptr, 0))
004272d6          {
004272dc              var_38_1 = 2;
004272dc              goto label_4272de;
004272d6          }
004272d6          
00427384          result = 0;
004272c3      }
004272c3      else
004272c3      {
004272c5          var_38_1 = 1;
004272de      label_4272de:
004272de          eax_1 = var_38_1;
004272df          data_430bb8 = eax_1;
004272e4      label_4272e4:
004272e4          
004272e7          if (eax_1 == 1)
004272f5              result = GetLocaleInfoW(arg1, arg2, arg3, arg4);
004272e7          else if (eax_1 != 2)
00427384              result = 0;
00427303          else
00427303          {
00427308              if (!arg5)
0042730f                  arg5 = data_430a24;
0042730f              
0042731a              int32_t cchData = GetLocaleInfoA(arg1, arg2, nullptr, 0);
0042731a              
00427325              if (!cchData)
00427384                  result = 0;
00427325              else
00427325              {
00427327                  int32_t var_8_1 = 0;
0042732d                  int32_t eax_5;
0042732d                  (uint8_t)eax_5 = (cchData + 3) & 0xfc;
0042732f                  sub_425610(eax_5);
00427334                  int32_t* var_1c_1 = &__saved_edi;
00427339                  int32_t* var_24_1 = &__saved_edi;
00427349                  int32_t var_8_2 = 0xffffffff;
00427349                  
0042734f                  if (!&__saved_edi)
00427384                      result = 0;
0042734f                  else if (!GetLocaleInfoA(arg1, arg2, &__saved_edi, cchData))
00427384                      result = 0;
00427363                  else
00427363                  {
00427368                      wchar16* lpWideCharStr;
00427368                      int32_t cchWideChar;
00427368                      
00427368                      if (arg4)
00427368                      {
0042736e                          cchWideChar = arg4;
00427371                          lpWideCharStr = arg3;
00427368                      }
00427368                      else
00427368                      {
0042736a                          cchWideChar = 0;
0042736b                          lpWideCharStr = nullptr;
00427368                      }
00427368                      
0042737c                      result = MultiByteToWideChar(arg5, MB_PRECOMPOSED, &__saved_edi, 
0042737c                          0xffffffff, lpWideCharStr, cchWideChar);
00427363                  }
00427325              }
00427303          }
004272c3      }
0042738c      fsbase->NtTib.ExceptionList = ExceptionList;
00427397      return result;
00427285  }


0042733e    int32_t sub_42733e() __pure

0042733e  {
00427341      return 1;
0042733e  }

00427342        8b 65 e8 33 ff 33 f6                                                                         .e.3.3.

00427398    int32_t sub_427398(uint32_t arg1, uint32_t arg2, PSTR arg3, int32_t arg4, uint32_t arg5)

00427398  {
0042739b      int32_t var_8 = 0xffffffff;
0042739d      int32_t var_c = 0x429bd8;
004273a2      int32_t var_10 = 0x41c5cc;
004273ad      TEB* fsbase;
004273ad      struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList;
004273ae      fsbase->NtTib.ExceptionList = &ExceptionList;
004273bb      int32_t __saved_edi;
004273bb      int32_t* var_1c = &__saved_edi;
004273be      int32_t eax_1 = data_430bbc;
004273be      
004273c7      if (eax_1)
004273c7          goto label_4273f7;
004273c7      
004273d6      int32_t result;
004273d6      int32_t var_38_1;
004273d6      
004273d6      if (!GetLocaleInfoW(0, 1, nullptr, 0))
004273d6      {
004273e9          if (GetLocaleInfoA(0, 1, nullptr, 0))
004273e9          {
004273ef              var_38_1 = 2;
004273ef              goto label_4273f1;
004273e9          }
004273e9          
004274a2          result = 0;
004273d6      }
004273d6      else
004273d6      {
004273d8          var_38_1 = 1;
004273f1      label_4273f1:
004273f1          eax_1 = var_38_1;
004273f2          data_430bbc = eax_1;
004273f7      label_4273f7:
004273f7          
004273fa          if (eax_1 == 2)
00427408              result = GetLocaleInfoA(arg1, arg2, arg3, arg4);
004273fa          else if (eax_1 != 1)
004274a2              result = 0;
00427416          else
00427416          {
0042741f              if (!arg5)
00427426                  arg5 = data_430a24;
00427426              
00427431              int32_t cchData = GetLocaleInfoW(arg1, arg2, nullptr, 0);
00427431              
0042743c              if (!cchData)
004274a2                  result = 0;
0042743c              else
0042743c              {
0042743e                  int32_t var_8_1 = 0;
00427446                  int32_t eax_6;
00427446                  (uint8_t)eax_6 = (cchData * 2 + 3) & 0xfc;
00427448                  sub_425610(eax_6);
0042744d                  int32_t* var_1c_1 = &__saved_edi;
00427452                  int32_t* var_24_1 = &__saved_edi;
00427462                  int32_t var_8_2 = 0xffffffff;
00427462                  
00427468                  if (!&__saved_edi)
004274a2                      result = 0;
00427468                  else if (!GetLocaleInfoW(arg1, arg2, &__saved_edi, cchData))
004274a2                      result = 0;
0042747c                  else
0042747c                  {
00427483                      PSTR lpMultiByteStr;
00427483                      int32_t cbMultiByte;
00427483                      
00427483                      if (arg4)
00427483                      {
00427489                          cbMultiByte = arg4;
0042748c                          lpMultiByteStr = arg3;
00427483                      }
00427483                      else
00427483                      {
00427485                          cbMultiByte = 0;
00427486                          lpMultiByteStr = nullptr;
00427483                      }
00427483                      
0042749a                      result = WideCharToMultiByte(arg5, 0x220, &__saved_edi, 0xffffffff, 
0042749a                          lpMultiByteStr, cbMultiByte, nullptr, nullptr);
0042747c                  }
0042743c              }
00427416          }
004273d6      }
004274aa      fsbase->NtTib.ExceptionList = ExceptionList;
004274b5      return result;
00427398  }


00427457    int32_t sub_427457() __pure

00427457  {
0042745a      return 1;
00427457  }

0042745b                                                                                   8b 65 e8 33 f6                             .e.3.
00427460  33 ff                                                                                            3.

004274b6    void __stdcall RtlUnwind(void* TargetFrame, void* TargetIp, EXCEPTION_RECORD* ExceptionRecord, void* ReturnValue)

004274b6  {
004274b6      /* tailcall */
004274b6      return RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
004274b6  }

.text section ended  {0x401000-0x4274bc}

.rdata section started  {0x428000-0x42a262}
00428000  void (__stdcall* const KERNEL32:GetStartupInfoA)(STARTUPINFOA* lpStartupInfo) = GetStartupInfoA
00428004  HMODULE (__stdcall* const KERNEL32:LoadLibraryA)(PSTR lpLibFileName) = LoadLibraryA
00428008  uint32_t (__stdcall* const KERNEL32:FormatMessageA)(enum FORMAT_MESSAGE_OPTIONS dwFlags, void* lpSource, uint32_t dwMessageId, uint32_t dwLanguageId, PSTR lpBuffer, uint32_t nSize, char** Arguments) = FormatMessageA
0042800c  enum WIN32_ERROR (__stdcall* const KERNEL32:GetLastError)() = GetLastError
00428010  FARPROC (__stdcall* const KERNEL32:GetProcAddress)(HMODULE hModule, PSTR lpProcName) = GetProcAddress
00428014  BOOL (__stdcall* const KERNEL32:FreeLibrary)(HMODULE hLibModule) = FreeLibrary
00428018  HANDLE (__stdcall* const KERNEL32:HeapCreate)(enum HEAP_FLAGS flOptions, uint32_t dwInitialSize, uint32_t dwMaximumSize) = HeapCreate
0042801c  BOOL (__stdcall* const KERNEL32:HeapDestroy)(HANDLE hHeap) = HeapDestroy
00428020  void (__stdcall* const KERNEL32:ExitProcess)(uint32_t uExitCode) __noreturn = ExitProcess
00428024  BOOL (__stdcall* const KERNEL32:TerminateProcess)(HANDLE hProcess, uint32_t uExitCode) = TerminateProcess
00428028  HANDLE (__stdcall* const KERNEL32:GetCurrentProcess)() = GetCurrentProcess
0042802c  PSTR (__stdcall* const KERNEL32:GetCommandLineA)() = GetCommandLineA
00428030  uint32_t (__stdcall* const KERNEL32:GetVersion)() = GetVersion
00428034  void* (__stdcall* const KERNEL32:HeapReAlloc)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem, uint32_t dwBytes) = HeapReAlloc
00428038  void* (__stdcall* const KERNEL32:HeapAlloc)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, uint32_t dwBytes) = HeapAlloc
0042803c  BOOL (__stdcall* const KERNEL32:HeapFree)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem) = HeapFree
00428040  BOOL (__stdcall* const KERNEL32:DeleteFileA)(PSTR lpFileName) = DeleteFileA
00428044  BOOL (__stdcall* const KERNEL32:MoveFileA)(PSTR lpExistingFileName, PSTR lpNewFileName) = MoveFileA
00428048  void (__stdcall* const KERNEL32:GetSystemTimeAsFileTime)(FILETIME* lpSystemTimeAsFileTime) = GetSystemTimeAsFileTime
0042804c  uint32_t (__stdcall* const KERNEL32:GetTimeZoneInformation)(TIME_ZONE_INFORMATION* lpTimeZoneInformation) = GetTimeZoneInformation
00428050  void (__stdcall* const KERNEL32:GetSystemTime)(SYSTEMTIME* lpSystemTime) = GetSystemTime
00428054  void (__stdcall* const KERNEL32:GetLocalTime)(SYSTEMTIME* lpSystemTime) = GetLocalTime
00428058  BOOL (__stdcall* const KERNEL32:CloseHandle)(HANDLE hObject) = CloseHandle
0042805c  BOOL (__stdcall* const KERNEL32:DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, HANDLE* lpTargetHandle, uint32_t dwDesiredAccess, BOOL bInheritHandle, enum DUPLICATE_HANDLE_OPTIONS dwOptions) = DuplicateHandle
00428060  HMODULE (__stdcall* const KERNEL32:GetModuleHandleA)(PSTR lpModuleName) = GetModuleHandleA
00428064  BOOL (__stdcall* const KERNEL32:ReadFile)(HANDLE hFile, uint8_t* lpBuffer, uint32_t nNumberOfBytesToRead, uint32_t* lpNumberOfBytesRead, OVERLAPPED* lpOverlapped) = ReadFile
00428068  uint32_t (__stdcall* const KERNEL32:SetFilePointer)(HANDLE hFile, int32_t lDistanceToMove, int32_t* lpDistanceToMoveHigh, enum SET_FILE_POINTER_MOVE_METHOD dwMoveMethod) = SetFilePointer
0042806c  int32_t (__stdcall* const KERNEL32:UnhandledExceptionFilter)(EXCEPTION_POINTERS* ExceptionInfo) = UnhandledExceptionFilter
00428070  BOOL (__stdcall* const KERNEL32:FreeEnvironmentStringsA)(PSTR penv) = FreeEnvironmentStringsA
00428074  BOOL (__stdcall* const KERNEL32:FreeEnvironmentStringsW)(PWSTR penv) = FreeEnvironmentStringsW
00428078  int32_t (__stdcall* const KERNEL32:WideCharToMultiByte)(uint32_t CodePage, uint32_t dwFlags, wchar16* lpWideCharStr, int32_t cchWideChar, PSTR lpMultiByteStr, int32_t cbMultiByte, PSTR lpDefaultChar, BOOL* lpUsedDefaultChar) = WideCharToMultiByte
0042807c  PSTR (__stdcall* const KERNEL32:GetEnvironmentStrings)() = GetEnvironmentStrings
00428080  PWSTR (__stdcall* const KERNEL32:GetEnvironmentStringsW)() = GetEnvironmentStringsW
00428084  uint32_t (__stdcall* const KERNEL32:SetHandleCount)(uint32_t uNumber) = SetHandleCount
00428088  HANDLE (__stdcall* const KERNEL32:GetStdHandle)(enum STD_HANDLE nStdHandle) = GetStdHandle
0042808c  enum FILE_TYPE (__stdcall* const KERNEL32:GetFileType)(HANDLE hFile) = GetFileType
00428090  uint32_t (__stdcall* const KERNEL32:GetModuleFileNameA)(HMODULE hModule, uint8_t* lpFilename, uint32_t nSize) = GetModuleFileNameA
00428094  uint32_t (__stdcall* const KERNEL32:GetEnvironmentVariableA)(PSTR lpName, uint8_t* lpBuffer, uint32_t nSize) = GetEnvironmentVariableA
00428098  BOOL (__stdcall* const KERNEL32:GetVersionExA)(OSVERSIONINFOA* lpVersionInformation) = GetVersionExA
0042809c  BOOL (__stdcall* const KERNEL32:SetEnvironmentVariableA)(PSTR lpName, PSTR lpValue) = SetEnvironmentVariableA
004280a0  int32_t (__stdcall* const KERNEL32:GetLocaleInfoW)(uint32_t Locale, uint32_t LCType, wchar16* lpLCData, int32_t cchData) = GetLocaleInfoW
004280a4  BOOL (__stdcall* const KERNEL32:VirtualFree)(void* lpAddress, uint32_t dwSize, enum VIRTUAL_FREE_TYPE dwFreeType) = VirtualFree
004280a8  void (__stdcall* const KERNEL32:RtlUnwind)(void* TargetFrame, void* TargetIp, EXCEPTION_RECORD* ExceptionRecord, void* ReturnValue) = RtlUnwind
004280ac  BOOL (__stdcall* const KERNEL32:WriteFile)(HANDLE hFile, uint8_t* lpBuffer, uint32_t nNumberOfBytesToWrite, uint32_t* lpNumberOfBytesWritten, OVERLAPPED* lpOverlapped) = WriteFile
004280b0  void* (__stdcall* const KERNEL32:VirtualAlloc)(void* lpAddress, uint32_t dwSize, enum VIRTUAL_ALLOCATION_TYPE flAllocationType, enum PAGE_PROTECTION_FLAGS flProtect) = VirtualAlloc
004280b4  int32_t (__stdcall* const KERNEL32:MultiByteToWideChar)(uint32_t CodePage, enum MULTI_BYTE_TO_WIDE_CHAR_FLAGS dwFlags, uint8_t* lpMultiByteStr, int32_t cbMultiByte, wchar16* lpWideCharStr, int32_t cchWideChar) = MultiByteToWideChar
004280b8  BOOL (__stdcall* const KERNEL32:GetStringTypeA)(uint32_t Locale, uint32_t dwInfoType, uint8_t* lpSrcStr, int32_t cchSrc, uint16_t* lpCharType) = GetStringTypeA
004280bc  BOOL (__stdcall* const KERNEL32:GetStringTypeW)(uint32_t dwInfoType, wchar16* lpSrcStr, int32_t cchSrc, uint16_t* lpCharType) = GetStringTypeW
004280c0  BOOL (__stdcall* const KERNEL32:GetCPInfo)(uint32_t CodePage, CPINFO* lpCPInfo) = GetCPInfo
004280c4  enum COMPARESTRING_RESULT (__stdcall* const KERNEL32:CompareStringA)(uint32_t Locale, uint32_t dwCmpFlags, char* lpString1, int32_t cchCount1, char* lpString2, int32_t cchCount2) = CompareStringA
004280c8  enum COMPARESTRING_RESULT (__stdcall* const KERNEL32:CompareStringW)(uint32_t Locale, uint32_t dwCmpFlags, wchar16* lpString1, int32_t cchCount1, wchar16* lpString2, int32_t cchCount2) = CompareStringW
004280cc  void (__stdcall* const KERNEL32:RaiseException)(uint32_t dwExceptionCode, uint32_t dwExceptionFlags, uint32_t nNumberOfArguments, uint32_t* lpArguments) __noreturn = RaiseException
004280d0  int32_t (__stdcall* const KERNEL32:LCMapStringA)(uint32_t Locale, uint32_t dwMapFlags, uint8_t* lpSrcStr, int32_t cchSrc, PSTR lpDestStr, int32_t cchDest) = LCMapStringA
004280d4  int32_t (__stdcall* const KERNEL32:LCMapStringW)(uint32_t Locale, uint32_t dwMapFlags, wchar16* lpSrcStr, int32_t cchSrc, PWSTR lpDestStr, int32_t cchDest) = LCMapStringW
004280d8  uint32_t (__stdcall* const KERNEL32:GetFileAttributesA)(PSTR lpFileName) = GetFileAttributesA
004280dc  HANDLE (__stdcall* const KERNEL32:CreateFileA)(PSTR lpFileName, uint32_t dwDesiredAccess, enum FILE_SHARE_MODE dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, enum FILE_CREATION_DISPOSITION dwCreationDisposition, enum FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile) = CreateFileA
004280e0  uint32_t (__stdcall* const KERNEL32:GetCurrentProcessId)() = GetCurrentProcessId
004280e4  BOOL (__stdcall* const KERNEL32:IsValidLocale)(uint32_t Locale, enum IS_VALID_LOCALE_FLAGS dwFlags) = IsValidLocale
004280e8  BOOL (__stdcall* const KERNEL32:IsValidCodePage)(uint32_t CodePage) = IsValidCodePage
004280ec  int32_t (__stdcall* const KERNEL32:GetLocaleInfoA)(uint32_t Locale, uint32_t LCType, uint8_t* lpLCData, int32_t cchData) = GetLocaleInfoA
004280f0  BOOL (__stdcall* const KERNEL32:EnumSystemLocalesA)(LOCALE_ENUMPROCA lpLocaleEnumProc, uint32_t dwFlags) = EnumSystemLocalesA
004280f4  uint32_t (__stdcall* const KERNEL32:GetUserDefaultLCID)() = GetUserDefaultLCID
004280f8  BOOL (__stdcall* const KERNEL32:SetStdHandle)(enum STD_HANDLE nStdHandle, HANDLE hHandle) = SetStdHandle
004280fc  BOOL (__stdcall* const KERNEL32:CreatePipe)(HANDLE* hReadPipe, HANDLE* hWritePipe, SECURITY_ATTRIBUTES* lpPipeAttributes, uint32_t nSize) = CreatePipe
00428100  BOOL (__stdcall* const KERNEL32:GetExitCodeProcess)(HANDLE hProcess, uint32_t* lpExitCode) = GetExitCodeProcess
00428104  enum WAIT_EVENT (__stdcall* const KERNEL32:WaitForSingleObject)(HANDLE hHandle, uint32_t dwMilliseconds) = WaitForSingleObject
00428108  BOOL (__stdcall* const KERNEL32:FlushFileBuffers)(HANDLE hFile) = FlushFileBuffers
0042810c  uint32_t (__stdcall* const KERNEL32:GetACP)() = GetACP
00428110  uint32_t (__stdcall* const KERNEL32:GetOEMCP)() = GetOEMCP
00428114  BOOL (__stdcall* const KERNEL32:CreateProcessA)(PSTR lpApplicationName, PSTR lpCommandLine, SECURITY_ATTRIBUTES* lpProcessAttributes, SECURITY_ATTRIBUTES* lpThreadAttributes, BOOL bInheritHandles, enum PROCESS_CREATION_FLAGS dwCreationFlags, void* lpEnvironment, PSTR lpCurrentDirectory, STARTUPINFOA* lpStartupInfo, PROCESS_INFORMATION* lpProcessInformation) = CreateProcessA
00428118  BOOL (__stdcall* const KERNEL32:SetEndOfFile)(HANDLE hFile) = SetEndOfFile

0042811c                                                                                      00 00 00 00                              ....

00428120  enum MESSAGEBOX_RESULT (__stdcall* const USER32:MessageBoxA)(HWND hWnd, PSTR lpText, PSTR lpCaption, enum MESSAGEBOX_STYLE uType) = MessageBoxA

00428124              00 00 00 00 00 00 00 00 00 00 00 00 24 4c 75 61 3a 20 4c 75 61 20 35 2e 31 20 43 6f      ............$Lua: Lua 5.1 Co
00428140  70 79 72 69 67 68 74 20 28 43 29 20 31 39 39 34 2d 32 30 30 36 20 4c 75 61 2e 6f 72 67 2c 20 50  pyright (C) 1994-2006 Lua.org, P
00428160  55 43 2d 52 69 6f 20 24 0a 24 41 75 74 68 6f 72 73 3a 20 52 2e 20 49 65 72 75 73 61 6c 69 6d 73  UC-Rio $.$Authors: R. Ierusalims
00428180  63 68 79 2c 20 4c 2e 20 48 2e 20 64 65 20 46 69 67 75 65 69 72 65 64 6f 20 26 20 57 2e 20 43 65  chy, L. H. de Figueiredo & W. Ce
004281a0  6c 65 73 20 24 0a 24 55 52 4c 3a 20 77 77 77 2e 6c 75 61 2e 6f 72 67 20 24 0a 00 00 00 00 00 00  les $.$URL: www.lua.org $.......

004281c0  int64_t data_4281c0 = 0x0
004281c8  int64_t data_4281c8 = 0x4338000000000000
004281d0  void* data_4281d0 = data_4307a0
004281d4  void* data_4281d4 = sub_4124c0
004281d8  char (* data_4281d8)[0x8] = data_42b28c {"package"}
004281dc  void* data_4281dc = sub_411380
004281e0  char (* data_4281e0)[0x6] = data_42b284 {"table"}
004281e4  void* data_4281e4 = sub_410950

004281e8                          80 b2 42 00                                                                      ..B.

004281ec  void* data_4281ec = sub_40ffe0

004281f0                                                  7c b2 42 00 40 f3 40 00                                          |.B.@.@.

004281f8  char (* data_4281f8)[0x7] = data_42b274 {"string"}
004281fc  void* data_4281fc = sub_40ec80
00428200  char (* data_428200)[0x5] = data_42b26c {"math"}
00428204  void* data_428204 = sub_40cfc0
00428208  char (* data_428208)[0x6] = data_42b264 {"debug"}
0042820c  void* data_42820c = sub_40c860

00428210                                                  00 00 00 00 00 00 00 00                                          ........
00428218  data_428218:
00428218                                                                          40 b4 42 00                                      @.B.

0042821c  char (* data_42821c)[0x6] = data_42b438 {"break"}

00428220  34 b4 42 00                                                                                      4.B.

00428224  char (* data_428224)[0x5] = data_42b42c {"else"}
00428228  char (* data_428228)[0x7] = data_42b424 {"elseif"}

0042822c                                      20 b4 42 00                                                               .B.

00428230  char (* data_428230)[0x6] = data_42b418 {"false"}

00428234                                                              14 b4 42 00                                              ..B.

00428238  char (* data_428238)[0x9] = data_42b408 {"function"}

0042823c                                                                                      04 b4 42 00                              ..B.
00428240  00 b4 42 00                                                                                      ..B.

00428244  char (* data_428244)[0x6] = data_42b3f8 {"local"}

00428248                          f4 b3 42 00 f0 b3 42 00 ec b3 42 00                                              ..B...B...B.

00428254  char (* data_428254)[0x7] = data_42b3e4 {"repeat"}
00428258  char (* data_428258)[0x7] = data_42b3dc {"return"}
0042825c  char (* data_42825c)[0x5] = data_42b3d4 {"then"}
00428260  char (* data_428260)[0x5] = data_42b3cc {"true"}
00428264  char (* data_428264)[0x6] = data_42b3c4 {"until"}
00428268  char (* data_428268)[0x6] = data_42b3bc {"while"}

0042826c                                      b8 b3 42 00                                                              ..B.

00428270  void* data_428270 = data_42b3b4

00428274                                                              b0 b3 42 00 ac b3 42 00 a8 b3 42 00                      ..B...B...B.
00428280  a4 b3 42 00                                                                                      ..B.

00428284  char (* data_428284)[0x9] = data_42b398 {"<number>"}
00428288  char (* data_428288)[0x7] = data_42b390 {"<name>"}
0042828c  char (* data_42828c)[0x9] = data_42b384 {"<string>"}
00428290  char (* data_428290)[0x6] = data_42b37c {"<eof>"}

00428294                                                              00 00 00 00                                              ....
00428298  data_428298:
00428298                                                                          f4 b3 42 00                                      ..B.

0042829c  char (* data_42829c)[0x8] = data_42b628 {"boolean"}
004282a0  char (* data_4282a0)[0x9] = data_42b61c {"userdata"}
004282a4  char (* data_4282a4)[0x7] = data_42b614 {"number"}
004282a8  char (* data_4282a8)[0x7] = data_42b274 {"string"}
004282ac  char (* data_4282ac)[0x6] = data_42b284 {"table"}
004282b0  char (* data_4282b0)[0x9] = data_42b408 {"function"}
004282b4  char (* data_4282b4)[0x9] = data_42b61c {"userdata"}
004282b8  char (* data_4282b8)[0x7] = data_42b60c {"thread"}
004282bc  char (* data_4282bc)[0x6] = data_42b604 {"proto"}
004282c0  char (* data_4282c0)[0x6] = data_42b5fc {"upval"}
004282c4  char (* data_4282c4)[0x8] = data_42b5f4 {"__index"}
004282c8  char (* data_4282c8)[0xb] = data_42b5e8 {"__newindex"}
004282cc  char (* data_4282cc)[0x5] = data_42b5e0 {"__gc"}
004282d0  char (* data_4282d0)[0x7] = data_42b5d8 {"__mode"}
004282d4  char (* data_4282d4)[0x5] = data_42b5d0 {"__eq"}
004282d8  char (* data_4282d8)[0x6] = data_42b5c8 {"__add"}
004282dc  char (* data_4282dc)[0x6] = data_42b5c0 {"__sub"}
004282e0  char (* data_4282e0)[0x6] = data_42b5b8 {"__mul"}
004282e4  char (* data_4282e4)[0x6] = data_42b5b0 {"__div"}
004282e8  char (* data_4282e8)[0x6] = data_42b5a8 {"__mod"}
004282ec  char (* data_4282ec)[0x6] = data_42b5a0 {"__pow"}
004282f0  char (* data_4282f0)[0x6] = data_42b598 {"__unm"}
004282f4  char (* data_4282f4)[0x6] = data_42b590 {"__len"}
004282f8  char (* data_4282f8)[0x5] = data_42b588 {"__lt"}
004282fc  char (* data_4282fc)[0x5] = data_42b580 {"__le"}
00428300  char (* data_428300)[0x9] = data_42b574 {"__concat"}
00428304  char (* data_428304)[0x7] = data_42b56c {"__call"}

00428308                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
00428320  00 00 00 00 00 00 00 00                                                                          ........

00428328  int64_t data_428328 = 0x3ff0000000000000

00428330  data_428330:
00428330                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
00428340  00 01 02 02 03 03 03 03 04 04 04 04 04 04 04 04 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05 05  ................................
00428360  06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06 06  ................................
00428380  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................................
004283a0  07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07  ................................
004283c0  08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08  ................................
004283e0  08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08  ................................
00428400  08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08  ................................
00428420  08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08 08  ................................
00428440  68 00 00 00                                                                                      h...

00428444  char (* data_428444)[0x5] = data_42b2e4 {"call"}
00428448  char (* data_428448)[0x7] = data_42b3dc {"return"}
0042844c  char (* data_42844c)[0x5] = data_42b8f8 {"line"}
00428450  char (* data_428450)[0x6] = data_42b8f0 {"count"}
00428454  char (* data_428454)[0xc] = data_42b8e4 {"tail return"}
00428458  char (* data_428458)[0x6] = data_42b264 {"debug"}
0042845c  void* data_42845c = sub_40c520
00428460  char (* data_428460)[0x8] = data_42b8dc {"getfenv"}
00428464  void* data_428464 = sub_40bcc0
00428468  char (* data_428468)[0x8] = data_42b8d4 {"gethook"}
0042846c  void* data_42846c = sub_40c440
00428470  char (* data_428470)[0x8] = data_42b8cc {"getinfo"}
00428474  void* data_428474 = sub_40bd20
00428478  char (* data_428478)[0x9] = data_42b8c0 {"getlocal"}
0042847c  void* data_42847c = sub_40c020
00428480  char (* data_428480)[0xc] = data_42b8b4 {"getregistry"}
00428484  void* data_428484 = sub_40bc20
00428488  char (* data_428488)[0xd] = data_42b8a4 {"getmetatable"}
0042848c  void* data_42848c = sub_40bc40
00428490  char (* data_428490)[0xb] = data_42b898 {"getupvalue"}
00428494  void* data_428494 = sub_40c190
00428498  char (* data_428498)[0x8] = data_42b890 {"setfenv"}
0042849c  void* data_42849c = sub_40bce0
004284a0  char (* data_4284a0)[0x8] = data_42b888 {"sethook"}
004284a4  void* data_4284a4 = sub_40c230
004284a8  char (* data_4284a8)[0x9] = data_42b87c {"setlocal"}
004284ac  void* data_4284ac = sub_40c0e0
004284b0  char (* data_4284b0)[0xd] = data_42b86c {"setmetatable"}
004284b4  void* data_4284b4 = sub_40bc70
004284b8  char (* data_4284b8)[0xb] = data_42b860 {"setupvalue"}
004284bc  void* data_4284bc = sub_40c210
004284c0  char (* data_4284c0)[0xa] = data_42b854 {"traceback"}
004284c4  void* data_4284c4 = sub_40c640

004284c8                          00 00 00 00 00 00 00 00 64 bb 42 00                                              ........d.B.

004284d4  void* data_4284d4 = sub_40c880
004284d8  char (* data_4284d8)[0x5] = data_42bb5c {"acos"}
004284dc  void* data_4284dc = sub_40ca00
004284e0  char (* data_4284e0)[0x5] = data_42bb54 {"asin"}
004284e4  void* data_4284e4 = sub_40c9d0
004284e8  char (* data_4284e8)[0x6] = data_42bb4c {"atan2"}
004284ec  void* data_4284ec = sub_40ca60
004284f0  char (* data_4284f0)[0x5] = data_42bb44 {"atan"}
004284f4  void* data_4284f4 = sub_40ca30
004284f8  char (* data_4284f8)[0x5] = data_42bb3c {"ceil"}
004284fc  void* data_4284fc = sub_40caa0
00428500  char (* data_428500)[0x5] = data_42bb34 {"cosh"}
00428504  void* data_428504 = sub_40c940

00428508                          30 bb 42 00                                                                      0.B.

0042850c  void* data_42850c = sub_40c910

00428510                                                  2c bb 42 00                                                      ,.B.

00428514  void* data_428514 = sub_40ccd0

00428518                                                                          28 bb 42 00                                      (.B.

0042851c  void* data_42851c = sub_40cc90
00428520  char (* data_428520)[0x6] = data_42bb20 {"floor"}
00428524  void* data_428524 = sub_40cad0
00428528  char (* data_428528)[0x5] = data_42bb18 {"fmod"}
0042852c  void* data_42852c = sub_40cb00
00428530  char (* data_428530)[0x6] = data_42bb10 {"frexp"}
00428534  void* data_428534 = sub_40cd30
00428538  char (* data_428538)[0x6] = data_42bb08 {"ldexp"}
0042853c  void* data_42853c = sub_40cd70
00428540  char (* data_428540)[0x6] = data_42bb00 {"log10"}
00428544  void* data_428544 = sub_40cc60

00428548                          fc ba 42 00                                                                      ..B.

0042854c  void* data_42854c = sub_40cc30

00428550                                                  f8 ba 42 00                                                      ..B.

00428554  void* data_428554 = sub_40ce20

00428558                                                                          f4 ba 42 00                                      ..B.

0042855c  void* data_42855c = sub_40cdb0
00428560  char (* data_428560)[0x5] = data_42baec {"modf"}
00428564  void* data_428564 = sub_40cb50

00428568                          e8 ba 42 00                                                                      ..B.

0042856c  void* data_42856c = sub_40cbe0

00428570                                                  e4 ba 42 00                                                      ..B.

00428574  void* data_428574 = sub_40cd00
00428578  char (* data_428578)[0x7] = data_42badc {"random"}
0042857c  void* data_42857c = sub_40ce90
00428580  char (* data_428580)[0xb] = data_42bad0 {"randomseed"}
00428584  void* data_428584 = sub_40cfa0
00428588  char (* data_428588)[0x5] = data_42bac8 {"sinh"}
0042858c  void* data_42858c = sub_40c8e0

00428590                                                  c4 ba 42 00                                                      ..B.

00428594  void* data_428594 = sub_40c8b0
00428598  char (* data_428598)[0x5] = data_42babc {"sqrt"}
0042859c  void* data_42859c = sub_40cbb0
004285a0  char (* data_4285a0)[0x5] = data_42bab4 {"tanh"}
004285a4  void* data_4285a4 = sub_40c9a0

004285a8                          b0 ba 42 00                                                                      ..B.

004285ac  void* data_4285ac = sub_40c970

004285b0                                                  00 00 00 00 00 00 00 00                                          ........

004285b8  int64_t data_4285b8 = 0x404ca5dc1a63c1f8
004285c0  int64_t data_4285c0 = 0x3f91df46a2529d39
004285c8  int64_t data_4285c8 = 0x3f00002000400080
004285d0  char (* data_4285d0)[0x5] = data_42bc0c {"byte"}
004285d4  void* data_4285d4 = sub_40d390
004285d8  char (* data_4285d8)[0x5] = data_42bc04 {"char"}
004285dc  void* data_4285dc = sub_40d460
004285e0  char (* data_4285e0)[0x5] = data_42bbfc {"dump"}
004285e4  void* data_4285e4 = sub_40d510
004285e8  char (* data_4285e8)[0x5] = data_42bbf4 {"find"}
004285ec  void* data_4285ec = sub_40d5a0
004285f0  char (* data_4285f0)[0x7] = data_42bbec {"format"}
004285f4  void* data_4285f4 = sub_40e6e0
004285f8  char (* data_4285f8)[0x6] = data_42bbe4 {"gfind"}
004285fc  void* data_4285fc = sub_40e340
00428600  char (* data_428600)[0x7] = data_42bbdc {"gmatch"}
00428604  void* data_428604 = sub_40e230
00428608  char (* data_428608)[0x5] = data_42bbd4 {"gsub"}
0042860c  void* data_42860c = sub_40e360

00428610                                                  d0 bb 42 00                                                      ..B.

00428614  void* data_428614 = sub_40d040
00428618  char (* data_428618)[0x6] = data_42bbc8 {"lower"}
0042861c  void* data_42861c = sub_40d1d0
00428620  char (* data_428620)[0x6] = data_42bbc0 {"match"}
00428624  void* data_428624 = sub_40e220

00428628                          bc bb 42 00                                                                      ..B.

0042862c  void* data_42862c = sub_40d310
00428630  char (* data_428630)[0x8] = data_42bbb4 {"reverse"}
00428634  void* data_428634 = sub_40d130

00428638                                                                          b0 bb 42 00                                      ..B.

0042863c  void* data_42863c = sub_40d070
00428640  char (* data_428640)[0x6] = data_42bba8 {"upper"}
00428644  void* data_428644 = sub_40d270

00428648                          00 00 00 00 00 00 00 00                                                          ........
00428650  data_428650:
00428650                                                  00 00 00 00 01 00 00 00 02 00 00 00 03 00 00 00                  ................
00428660  04 00 00 00 05 00 00 00 b4 be 42 00                                                              ..........B.

0042866c  char (* data_42866c)[0x8] = data_42beac {"collate"}
00428670  char (* data_428670)[0x6] = data_42bea4 {"ctype"}
00428674  char (* data_428674)[0x9] = data_42be98 {"monetary"}
00428678  char (* data_428678)[0x8] = data_42be90 {"numeric"}
0042867c  char (* data_42867c)[0x5] = data_42be88 {"time"}

00428680  00 00 00 00 00 00 00 00                                                                          ........

00428688  char (* data_428688)[0x6] = data_42be80 {"clock"}
0042868c  void* data_42868c = sub_40ee40
00428690  char (* data_428690)[0x5] = data_42be78 {"date"}
00428694  void* data_428694 = sub_40ee70
00428698  char (* data_428698)[0x9] = data_42be6c {"difftime"}
0042869c  void* data_42869c = sub_40f260
004286a0  char (* data_4286a0)[0x8] = data_42be64 {"execute"}
004286a4  void* data_4286a4 = sub_40ed20
004286a8  char (* data_4286a8)[0x5] = data_42be5c {"exit"}
004286ac  void* data_4286ac = sub_40f320
004286b0  char (* data_4286b0)[0x7] = data_42be54 {"getenv"}
004286b4  void* data_4286b4 = sub_40ee10
004286b8  char (* data_4286b8)[0x7] = data_42be4c {"remove"}
004286bc  void* data_4286bc = sub_40ed50
004286c0  char (* data_4286c0)[0x7] = data_42be44 {"rename"}
004286c4  void* data_4286c4 = sub_40ed80
004286c8  char (* data_4286c8)[0xa] = data_42be38 {"setlocale"}
004286cc  void* data_4286cc = sub_40f2b0
004286d0  char (* data_4286d0)[0x5] = data_42be88 {"time"}
004286d4  void* data_4286d4 = sub_40f0a0
004286d8  char (* data_4286d8)[0x8] = data_42be30 {"tmpname"}
004286dc  void* data_4286dc = sub_40edc0

004286e0  00 00 00 00 00 00 00 00 fc a9 f1 d2                                                              ............

004286ec  char const data_4286ec[0x4] = "MbP?"
004286f0  char (* data_4286f0)[0x6] = data_42bfdc {"input"}
004286f4  char (* data_4286f4)[0x7] = data_42bfd4 {"output"}

004286f8  data_4286f8:
004286f8                                                                          00 00 00 00 01 00 00 00                          ........
00428700  02 00 00 00 d0 bf 42 00 cc bf 42 00 20 b4 42 00 00 00 00 00                                      ......B...B. .B.....
00428714  data_428714:
00428714                                                              04 00 00 00 00 00 00 00 40 00 00 00                      ........@...
00428720  c8 bf 42 00                                                                                      ..B.

00428724  char (* data_428724)[0x5] = data_42bfc0 {"full"}
00428728  char (* data_428728)[0x5] = data_42b8f8 {"line"}

0042872c                                      00 00 00 00                                                              ....

00428730  char (* data_428730)[0x6] = data_42bfb8 {"close"}
00428734  void* data_428734 = sub_40f400
00428738  char (* data_428738)[0x6] = data_42bfb0 {"flush"}
0042873c  void* data_42873c = sub_40ff80
00428740  char (* data_428740)[0x6] = data_42bfdc {"input"}
00428744  void* data_428744 = sub_40f700
00428748  char (* data_428748)[0x6] = data_42bfa8 {"lines"}
0042874c  void* data_42874c = sub_40f860
00428750  char (* data_428750)[0x5] = data_42b0fc {"open"}
00428754  void* data_428754 = sub_40f530
00428758  char (* data_428758)[0x7] = data_42bfd4 {"output"}
0042875c  void* data_42875c = sub_40f7f0
00428760  char (* data_428760)[0x6] = data_42bfa0 {"popen"}
00428764  void* data_428764 = sub_40f660
00428768  char (* data_428768)[0x5] = data_42b0d8 {"read"}
0042876c  void* data_42876c = sub_40f8e0
00428770  char (* data_428770)[0x8] = data_42bf98 {"tmpfile"}
00428774  void* data_428774 = sub_40f6c0
00428778  char (* data_428778)[0x5] = data_42bf90 {"type"}
0042877c  void* data_42877c = sub_40f360
00428780  char (* data_428780)[0x6] = data_42bf88 {"write"}
00428784  void* data_428784 = sub_40fda0

00428788                          00 00 00 00 00 00 00 00                                                          ........

00428790  char (* data_428790)[0x6] = data_42bfb8 {"close"}
00428794  void* data_428794 = sub_40f400
00428798  char (* data_428798)[0x6] = data_42bfb0 {"flush"}
0042879c  void* data_42879c = sub_40ffb0
004287a0  char (* data_4287a0)[0x6] = data_42bfa8 {"lines"}
004287a4  void* data_4287a4 = sub_40f810
004287a8  char (* data_4287a8)[0x5] = data_42b0d8 {"read"}
004287ac  void* data_4287ac = sub_40fce0
004287b0  char (* data_4287b0)[0x5] = data_42b0e0 {"seek"}
004287b4  void* data_4287b4 = sub_40feb0
004287b8  char (* data_4287b8)[0x8] = data_42bf80 {"setvbuf"}
004287bc  void* data_4287bc = sub_40ff20
004287c0  char (* data_4287c0)[0x6] = data_42bf88 {"write"}
004287c4  void* data_4287c4 = sub_40fe90
004287c8  char (* data_4287c8)[0x5] = data_42b5e0 {"__gc"}
004287cc  void* data_4287cc = sub_40f4a0
004287d0  char (* data_4287d0)[0xb] = data_42bf74 {"__tostring"}
004287d4  void* data_4287d4 = sub_40f4e0

004287d8                                                                          00 00 00 00 00 00 00 00                          ........

004287e0  char (* data_4287e0)[0x7] = data_42c0f8 {"concat"}
004287e4  void* data_4287e4 = sub_410520
004287e8  char (* data_4287e8)[0x8] = data_42c0f0 {"foreach"}
004287ec  void* data_4287ec = sub_410270
004287f0  char (* data_4287f0)[0x9] = data_42c0e4 {"foreachi"}
004287f4  void* data_4287f4 = sub_4101e0
004287f8  char (* data_4287f8)[0x5] = data_42c0dc {"getn"}
004287fc  void* data_4287fc = sub_4103a0
00428800  char (* data_428800)[0x5] = data_42c0d4 {"maxn"}
00428804  void* data_428804 = sub_410300
00428808  char (* data_428808)[0x7] = data_42c0cc {"insert"}
0042880c  void* data_42880c = sub_410400
00428810  char (* data_428810)[0x7] = data_42be4c {"remove"}
00428814  void* data_428814 = sub_4104a0
00428818  char (* data_428818)[0x5] = data_42c0c4 {"setn"}
0042881c  void* data_42881c = sub_4103d0
00428820  char (* data_428820)[0x5] = data_42c0bc {"sort"}
00428824  void* data_428824 = sub_410610

00428828                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                  ................

00428838  char (* data_428838)[0x8] = data_42c194 {"loadlib"}
0042883c  void* data_42883c = sub_410970
00428840  char (* data_428840)[0x7] = data_42c18c {"seeall"}
00428844  void* data_428844 = sub_411320

00428848                          00 00 00 00 00 00 00 00                                                          ........

00428850  char (* data_428850)[0x7] = data_42c184 {"module"}
00428854  void* data_428854 = sub_411140
00428858  char (* data_428858)[0x8] = data_42c17c {"require"}
0042885c  void* data_42885c = sub_410f90

00428860  00 00 00 00 00 00 00 00                                                                          ........

00428868  void* data_428868 = sub_410f20
0042886c  void* data_42886c = sub_410bd0
00428870  void* data_428870 = sub_410dc0
00428874  void* data_428874 = sub_410e80

00428878                                                                          00 00 00 00 00 00 00 00                          ........

00428880  char (* data_428880)[0x5] = data_42c538 {"stop"}
00428884  char (* data_428884)[0x8] = data_42c530 {"restart"}
00428888  char (* data_428888)[0x8] = data_42c528 {"collect"}
0042888c  char (* data_42888c)[0x6] = data_42b8f0 {"count"}
00428890  char (* data_428890)[0x5] = data_42c520 {"step"}
00428894  char (* data_428894)[0x9] = data_42c514 {"setpause"}
00428898  char (* data_428898)[0xb] = data_42c508 {"setstepmul"}

0042889c                                                                                      00 00 00 00                              ....
004288a0  data_4288a0:
004288a0  00 00 00 00 01 00 00 00 02 00 00 00 03 00 00 00 05 00 00 00 06 00 00 00 07 00 00 00 00 00 00 00  ................................

004288c0  char (* data_4288c0)[0x7] = data_42c500 {"assert"}
004288c4  void* data_4288c4 = sub_411e60
004288c8  char (* data_4288c8)[0xf] = data_42c4f0 {"collectgarbage"}
004288cc  void* data_4288cc = sub_411b90
004288d0  char (* data_4288d0)[0x7] = data_42c4e8 {"dofile"}
004288d4  void* data_4288d4 = sub_411e10
004288d8  char (* data_4288d8)[0x6] = data_42c4e0 {"error"}
004288dc  void* data_4288dc = sub_4117f0
004288e0  char (* data_4288e0)[0x7] = data_42c4d8 {"gcinfo"}
004288e4  void* data_4288e4 = sub_411b70
004288e8  char (* data_4288e8)[0x8] = data_42b8dc {"getfenv"}
004288ec  void* data_4288ec = sub_411920
004288f0  char (* data_4288f0)[0xd] = data_42b8a4 {"getmetatable"}
004288f4  void* data_4288f4 = sub_411850
004288f8  char (* data_4288f8)[0x9] = data_42c4cc {"loadfile"}
004288fc  void* data_4288fc = sub_411d10
00428900  char (* data_428900)[0x5] = data_42c4c4 {"load"}
00428904  void* data_428904 = sub_411d40
00428908  char (* data_428908)[0xb] = data_42c4b8 {"loadstring"}
0042890c  void* data_42890c = sub_411ca0
00428910  char (* data_428910)[0x5] = data_42c4b0 {"next"}
00428914  void* data_428914 = sub_411c60
00428918  char (* data_428918)[0x6] = data_42c4a8 {"pcall"}
0042891c  void* data_42891c = sub_411fb0
00428920  char (* data_428920)[0x6] = data_42c4a0 {"print"}
00428924  void* data_428924 = sub_411610
00428928  char (* data_428928)[0x9] = data_42c494 {"rawequal"}
0042892c  void* data_42892c = sub_411ac0
00428930  char (* data_428930)[0x7] = data_42c48c {"rawget"}
00428934  void* data_428934 = sub_411af0
00428938  char (* data_428938)[0x7] = data_42c484 {"rawset"}
0042893c  void* data_42893c = sub_411b30
00428940  char (* data_428940)[0x7] = data_42c47c {"select"}
00428944  void* data_428944 = sub_411f30
00428948  char (* data_428948)[0x8] = data_42b890 {"setfenv"}
0042894c  void* data_42894c = sub_411a20
00428950  char (* data_428950)[0xd] = data_42b86c {"setmetatable"}
00428954  void* data_428954 = sub_4118a0
00428958  char (* data_428958)[0x9] = data_42c470 {"tonumber"}
0042895c  void* data_42895c = sub_4116d0
00428960  char (* data_428960)[0x9] = data_42c464 {"tostring"}
00428964  void* data_428964 = sub_412050
00428968  char (* data_428968)[0x5] = data_42bf90 {"type"}
0042896c  void* data_42896c = sub_411c30
00428970  char (* data_428970)[0x7] = data_42c45c {"unpack"}
00428974  void* data_428974 = sub_411eb0
00428978  char (* data_428978)[0x7] = data_42c454 {"xpcall"}
0042897c  void* data_42897c = sub_412000

00428980  00 00 00 00 00 00 00 00                                                                          ........

00428988  char (* data_428988)[0x7] = data_42c44c {"create"}
0042898c  void* data_42898c = sub_412290
00428990  char (* data_428990)[0x7] = data_42c444 {"resume"}

00428994                                                              50 21 41 00                                              P!A.

00428998  char (* data_428998)[0x8] = data_42c43c {"running"}
0042899c  void* data_42899c = sub_4124a0
004289a0  char (* data_4289a0)[0x7] = data_42c434 {"status"}
004289a4  void* data_4289a4 = sub_4123b0
004289a8  char (* data_4289a8)[0x5] = data_42c42c {"wrap"}
004289ac  void* data_4289ac = sub_4122f0
004289b0  char (* data_4289b0)[0x6] = data_42c424 {"yield"}
004289b4  void* data_4289b4 = sub_412390

004289b8                                                                          00 00 00 00 00 00 00 00                          ........

004289c0  int64_t data_4289c0 = 0x3f50000000000000

004289c8  data_4289c8:
004289c8                          06                                                                               .
004289c9  data_4289c9:
004289c9                             06 06 06 07 07 07 07 07 07 0a 09 05 04 03 03 03 03 03 03 03 03 03 03           .......................
004289e0  03 03 02 02 01 01 00 00                                                                          ........

004289e8  char (* data_4289e8)[0x5] = data_42cb70 {"MOVE"}
004289ec  char (* data_4289ec)[0x6] = data_42cb68 {"LOADK"}
004289f0  char (* data_4289f0)[0x9] = data_42cb5c {"LOADBOOL"}
004289f4  char (* data_4289f4)[0x8] = data_42cb54 {"LOADNIL"}
004289f8  char (* data_4289f8)[0x9] = data_42cb48 {"GETUPVAL"}
004289fc  char (* data_4289fc)[0xa] = data_42cb3c {"GETGLOBAL"}
00428a00  char (* data_428a00)[0x9] = data_42cb30 {"GETTABLE"}
00428a04  char (* data_428a04)[0xa] = data_42cb24 {"SETGLOBAL"}
00428a08  char (* data_428a08)[0x9] = data_42cb18 {"SETUPVAL"}
00428a0c  char (* data_428a0c)[0x9] = data_42cb0c {"SETTABLE"}
00428a10  char (* data_428a10)[0x9] = data_42cb00 {"NEWTABLE"}
00428a14  char (* data_428a14)[0x5] = data_42caf8 {"SELF"}

00428a18                                                                          f4 ca 42 00 f0 ca 42 00                          ..B...B.
00428a20  ec ca 42 00 e8 ca 42 00 e4 ca 42 00 e0 ca 42 00 dc ca 42 00 d8 ca 42 00 d4 ca 42 00              ..B...B...B...B...B...B...B.

00428a3c  char (* data_428a3c)[0x7] = data_42cacc {"CONCAT"}

00428a40  c8 ca 42 00 c4 ca 42 00 c0 ca 42 00 bc ca 42 00                                                  ..B...B...B...B.

00428a50  char (* data_428a50)[0x5] = data_42cab4 {"TEST"}
00428a54  char (* data_428a54)[0x8] = data_42caac {"TESTSET"}
00428a58  char (* data_428a58)[0x5] = data_42caa4 {"CALL"}
00428a5c  char (* data_428a5c)[0x9] = data_42ca98 {"TAILCALL"}
00428a60  char (* data_428a60)[0x7] = data_42ca90 {"RETURN"}
00428a64  char (* data_428a64)[0x8] = data_42ca88 {"FORLOOP"}
00428a68  char (* data_428a68)[0x8] = data_42ca80 {"FORPREP"}
00428a6c  char (* data_428a6c)[0x9] = data_42ca74 {"TFORLOOP"}
00428a70  char (* data_428a70)[0x8] = data_42ca6c {"SETLIST"}
00428a74  char (* data_428a74)[0x6] = data_42ca64 {"CLOSE"}
00428a78  char (* data_428a78)[0x8] = data_42ca5c {"CLOSURE"}
00428a7c  char (* data_428a7c)[0x7] = data_42ca54 {"VARARG"}

00428a80  00 00 00 00 60 71 54 60 50 71 6c 31 10 3c 54 6c 7c 7c 7c 7c 7c 7c 60 60 60 68 22 bc bc bc e4 e4  ....`qT`Pql1.<Tl||||||```h".....
00428aa0  54 54 10 62 62 84 14 00 51 50 00 00 00 00 00 00 ff ff ff ff eb 71 41 00 ff 71 41 00              TT.bb...QP...........qA..qA.

00428abc  char const data_428abc[0x8] = "cmd.exe", 0
00428ac4  char const data_428ac4[0xc] = "command.com", 0

00428ad0  data_428ad0:
00428ad0                                                  2f 63 00 00                                                      /c..

00428ad4  char const data_428ad4[0x8] = "COMSPEC", 0
00428adc  char const data_428adc[0x8] = "H:mm:ss", 0
00428ae4  char const data_428ae4[0x14] = "dddd, MMMM dd, yyyy", 0
00428af8  char const data_428af8[0x7] = "M/d/yy", 0

00428aff                                                                                               00                                 .
00428b00  50 4d 00 00 41 4d 00 00                                                                          PM..AM..

00428b08  char const data_428b08[0x9] = "December", 0

00428b11                                                     00 00 00                                                       ...

00428b14  char const data_428b14[0x9] = "November", 0

00428b1d                                                                                         00 00 00                               ...

00428b20  char const data_428b20[0x8] = "October", 0
00428b28  char const data_428b28[0xa] = "September", 0

00428b32                                                        00 00                                                        ..

00428b34  char const data_428b34[0x7] = "August", 0

00428b3b                                                                                   00                                         .

00428b3c  char const data_428b3c[0x5] = "July", 0

00428b41     00 00 00                                                                                       ...

00428b44  char const data_428b44[0x5] = "June", 0

00428b49                             00 00 00                                                                       ...

00428b4c  char const data_428b4c[0x6] = "April", 0

00428b52                                                        00 00                                                        ..

00428b54  char const data_428b54[0x6] = "March", 0

00428b5a                                                                                00 00                                        ..

00428b5c  char const data_428b5c[0x9] = "February", 0

00428b65                 00 00 00                                                                               ...

00428b68  char const data_428b68[0x8] = "January", 0

00428b70                                                  44 65 63 00 4e 6f 76 00 4f 63 74 00 53 65 70 00                  Dec.Nov.Oct.Sep.
00428b80  41 75 67 00 4a 75 6c 00 4a 75 6e 00 4d 61 79 00 41 70 72 00 4d 61 72 00 46 65 62 00 4a 61 6e 00  Aug.Jul.Jun.May.Apr.Mar.Feb.Jan.

00428ba0  char const data_428ba0[0x9] = "Saturday", 0

00428ba9                             00 00 00                                                                       ...

00428bac  char const data_428bac[0x7] = "Friday", 0

00428bb3                                                           00                                                         .

00428bb4  char const data_428bb4[0x9] = "Thursday", 0

00428bbd                                                                                         00 00 00                               ...

00428bc0  char const data_428bc0[0xa] = "Wednesday", 0

00428bca                                00 00                                                                        ..

00428bcc  char const data_428bcc[0x8] = "Tuesday", 0
00428bd4  char const data_428bd4[0x7] = "Monday", 0

00428bdb                                                                                   00                                         .

00428bdc  char const data_428bdc[0x7] = "Sunday", 0

00428be3           00 53 61 74 00 46 72 69 00 54 68 75 00 57 65 64 00 54 75 65 00 4d 6f 6e 00 53 75 6e 00     .Sat.Fri.Thu.Wed.Tue.Mon.Sun.
00428c00  data_428c00:
00428c00  61 2f 70 00                                                                                      a/p.

00428c04  char const data_428c04[0x6] = "am/pm", 0

00428c0a                                00 00                                                                        ..

00428c0c  char const data_428c0c[0x8] = "LC_TIME", 0
00428c14  char const data_428c14[0xb] = "LC_NUMERIC", 0

00428c1f                                                                                               00                                 .

00428c20  char const data_428c20[0xc] = "LC_MONETARY", 0
00428c2c  char const data_428c2c[0x9] = "LC_CTYPE", 0

00428c35                                                                 00 00 00                                               ...

00428c38  char const data_428c38[0xb] = "LC_COLLATE", 0

00428c43           00                                                                                         .

00428c44  char const data_428c44[0x7] = "LC_ALL", 0

00428c4b                                   00                                                                         .
00428c4c  data_428c4c:
00428c4c                                      3d 3b 00 00                                                              =;..
00428c50  data_428c50:
00428c50                                                  3d 00 00 00                                                      =...
00428c54  data_428c54:
00428c54                                                              5f 2e 2c 00                                              _.,.

00428c58  int64_t data_428c58 = 0x4150017ec0000000
00428c60  int64_t data_428c60 = 0x4147ffff80000000
00428c68  char const data_428c68[0x1a] = "IsProcessorFeaturePresent", 0

00428c82        00 00                                                                                        ..

00428c84  char const data_428c84[0x9] = "KERNEL32", 0

00428c8d                                         00 00 00                                                               ...

00428c90  char const data_428c90[0x6] = "e+000", 0

00428c96                                                                    00 00                                                ..

00428c98  char const data_428c98[0x16] = "Illegal byte sequence", 0

00428cae                                            00 00                                                                ..

00428cb0  char const data_428cb0[0x14] = "Directory not empty", 0
00428cc4  char const data_428cc4[0x19] = "Function not implemented", 0

00428cdd                                                                                         00 00 00                               ...

00428ce0  char const data_428ce0[0x13] = "No locks available", 0

00428cf3                                                           00                                                         .

00428cf4  char const data_428cf4[0x12] = "Filename too long", 0

00428d06                    00 00                                                                                ..

00428d08  char const data_428d08[0x1a] = "Resource deadlock avoided", 0

00428d22        00 00                                                                                        ..

00428d24  char const data_428d24[0x11] = "Result too large", 0

00428d35                                                                 00 00 00                                               ...

00428d38  char const data_428d38[0xd] = "Domain error", 0

00428d45                 00 00 00                                                                               ...

00428d48  char const data_428d48[0xc] = "Broken pipe", 0
00428d54  char const data_428d54[0xf] = "Too many links", 0

00428d63           00                                                                                         .

00428d64  char const data_428d64[0x16] = "Read-only file system", 0

00428d7a                                                                                00 00                                        ..

00428d7c  char const data_428d7c[0xd] = "Invalid seek", 0

00428d89                             00 00 00                                                                       ...

00428d8c  char const data_428d8c[0x18] = "No space left on device", 0
00428da4  char const data_428da4[0xf] = "File too large", 0

00428db3                                                           00                                                         .

00428db4  char const data_428db4[0x24] = "Inappropriate I/O control operation", 0
00428dd8  char const data_428dd8[0x14] = "Too many open files", 0
00428dec  char const data_428dec[0x1e] = "Too many open files in system", 0

00428e0a                                00 00                                                                        ..

00428e0c  char const data_428e0c[0x11] = "Invalid argument", 0

00428e1d                                                                                         00 00 00                               ...

00428e20  char const data_428e20[0xf] = "Is a directory", 0

00428e2f                                               00                                                                 .

00428e30  char const data_428e30[0x10] = "Not a directory", 0
00428e40  char const data_428e40[0xf] = "No such device", 0

00428e4f                                               00                                                                 .

00428e50  char const data_428e50[0xe] = "Improper link", 0

00428e5e                                                                                            00 00                                ..

00428e60  char const data_428e60[0xc] = "File exists", 0
00428e6c  char const data_428e6c[0x10] = "Resource device", 0
00428e7c  char const data_428e7c[0xe] = "Unknown error", 0

00428e8a                                00 00                                                                        ..

00428e8c  char const data_428e8c[0xc] = "Bad address", 0
00428e98  char const data_428e98[0x12] = "Permission denied", 0

00428eaa                                00 00                                                                        ..

00428eac  char const data_428eac[0x11] = "Not enough space", 0

00428ebd                                                                                         00 00 00                               ...

00428ec0  char const data_428ec0[0x21] = "Resource temporarily unavailable", 0

00428ee1     00 00 00                                                                                       ...

00428ee4  char const data_428ee4[0x13] = "No child processes", 0

00428ef7                                                                       00                                                 .

00428ef8  char const data_428ef8[0x14] = "Bad file descriptor", 0
00428f0c  char const data_428f0c[0x12] = "Exec format error", 0

00428f1e                                                                                            00 00                                ..

00428f20  char const data_428f20[0x12] = "Arg list too long", 0

00428f32                                                        00 00                                                        ..

00428f34  char const data_428f34[0x1a] = "No such device or address", 0

00428f4e                                            00 00                                                                ..

00428f50  char const data_428f50[0x13] = "Input/output error", 0

00428f63           00                                                                                         .

00428f64  char const data_428f64[0x1a] = "Interrupted function call", 0

00428f7e                                                                                            00 00                                ..

00428f80  char const data_428f80[0x10] = "No such process", 0
00428f90  char const data_428f90[0x1a] = "No such file or directory", 0

00428faa                                00 00                                                                        ..

00428fac  char const data_428fac[0x18] = "Operation not permitted", 0
00428fc4  char const data_428fc4[0x9] = "No error", 0

00428fcd                                         00 00 00                                                               ...

00428fd0  char const data_428fd0[0x17] = "__GLOBAL_HEAP_SELECTED", 0

00428fe7                       00                                                                                 .

00428fe8  char const data_428fe8[0x15] = "__MSVCRT_HEAP_SELECT", 0

00428ffd                                                                                         00 00 00                               ...

00429000  char const data_429000[0xf] = "runtime error ", 0

0042900f                                               00 0d 0a 00 00                                                     .....

00429014  char const data_429014[0xe] = "TLOSS error\r\n", 0

00429022        00 00                                                                                        ..

00429024  char const data_429024[0xd] = "SING error\r\n", 0

00429031                                                     00 00 00                                                       ...

00429034  char const data_429034[0xf] = "DOMAIN error\r\n", 0

00429043           00                                                                                         .

00429044  char const data_429044[0x25] = "R6028\r\n"
00429044      "- unable to initialize heap\r\n", 0

00429069                             00 00 00                                                                       ...

0042906c  char const data_42906c[0x35] = "R6027\r\n"
0042906c      "- not enough space for lowio initialization\r\n", 0

004290a1     00 00 00                                                                                       ...

004290a4  char const data_4290a4[0x35] = "R6026\r\n"
004290a4      "- not enough space for stdio initialization\r\n", 0

004290d9                                                                             00 00 00                                       ...

004290dc  char const data_4290dc[0x26] = "R6025\r\n"
004290dc      "- pure virtual function call\r\n", 0

00429102        00 00                                                                                        ..

00429104  char const data_429104[0x35] = "R6024\r\n"
00429104      "- not enough space for _onexit/atexit table\r\n", 0

00429139                                                                             00 00 00                                       ...

0042913c  char const data_42913c[0x29] = "R6019\r\n"
0042913c      "- unable to open console device\r\n", 0

00429165                 00 00 00                                                                               ...

00429168  char const data_429168[0x21] = "R6018\r\n"
00429168      "- unexpected heap error\r\n", 0

00429189                             00 00 00                                                                       ...

0042918c  char const data_42918c[0x2d] = "R6017\r\n"
0042918c      "- unexpected multithread lock error\r\n", 0

004291b9                                                                             00 00 00                                       ...

004291bc  char const data_4291bc[0x2c] = "R6016\r\n"
004291bc      "- not enough space for thread data\r\n", 0
004291e8  char const data_4291e8[0x21] = "\r\nabnormal program termination\r\n", 0

00429209                             00 00 00                                                                       ...

0042920c  char const data_42920c[0x2c] = "R6009\r\n"
0042920c      "- not enough space for environment\r\n", 0
00429238  char const data_429238[0x2a] = "R6008\r\n"
00429238      "- not enough space for arguments\r\n", 0

00429262        00 00                                                                                        ..

00429264  char const data_429264[0x25] = "R6002\r\n"
00429264      "- floating point not loaded\r\n", 0

00429289                             00 00 00                                                                       ...

0042928c  char const data_42928c[0x25] = "Microsoft Visual C++ Runtime Library", 0

004292b1                                                     00 00 00                                                       ...
004292b4  data_4292b4:
004292b4                                                              0a 0a 00 00                                              ....

004292b8  char const data_4292b8[0x1a] = "Runtime Error!\n\n"
004292b8      "Program: ", 0

004292d2                                                        00 00                                                        ..

004292d4  char const data_4292d4[0x17] = "<program name unknown>", 0

004292eb                                   00 06 00 00 06 00 01 00 00 10 00 03 06 00 06 02 10 04 45 45 45             ..................EEE
00429300  05 05 05 05 05 35 30 00 50 00 00 00 00 20 28 38 50 58 07 08 00 37 30 30 57 50 07 00 00 20 20 08  .....50.P.... (8PX...700WP...  .
00429320  00 00 00 00 08 60 68 60 60 60 60 00 00 70 70 78 78 78 78 08 07 08 00 00 07 00 08 08 08 00 00 08  .....`h````..ppxxxx.............
00429340  00 08 00 07 08 00 00 00                                                                          ........

00429348  wchar16 const data_429348[0x7] = "(null)", 0

00429356                                                                    00 00 ff ff ff ff                                    ......

0042935c  void* data_42935c = sub_41e5c6

00429360  da e5 41 00                                                                                      ..A.
00429364  data_429364:
00429364              00 00 00 00                                                                              ....
00429368  data_429368:
00429368                          00 00 00 00 00 00 00 00 ff ff ff ff                                              ............

00429374  void* data_429374 = sub_41e6ed

00429378                                                                          f1 e6 41 00 00 00 00 00                          ..A.....
00429380  ff ff ff ff                                                                                      ....

00429384  void* data_429384 = sub_41eb17

00429388                          1b eb 41 00 ff ff ff ff                                                          ..A.....

00429390  void* data_429390 = sub_41eb86

00429394                                                              8a eb 41 00 5f 79 6e 00 5f 79 31 00                      ..A._yn._y1.
004293a0  5f 79 30 00                                                                                      _y0.

004293a4  char const data_4293a4[0x7] = "_hypot", 0

004293ab                                   00                                                                         .

004293ac  char const data_4293ac[0x6] = "_cabs", 0

004293b2                                                        00 00                                                        ..

004293b4  char const data_4293b4[0x5] = "fabs", 0

004293b9                                                                             00 00 00 00 00 00 00                           .......

004293c0  int64_t data_4293c0 = 0x3ff0000000000000

004293c8                          7f 02 35 c2 68 21 a2 da 0f c9 3e 40                                              ..5.h!....>@

004293d4  int64_t data_4293d4 = 0x7fefffffffffffff
004293dc  int64_t data_4293dc = 0x10000000000000
004293e4  int64_t data_4293e4 = -0x3f68000000000000
004293ec  int64_t data_4293ec = 0x4098000000000000
004293f4  int64_t data_4293f4 = 0x7ff0000000000000
004293fc  int64_t data_4293fc = 0x0

00429404              00 00 00 00                                                                              ....

00429408  int64_t data_429408 = 0x4000000000000000
00429410  int64_t data_429410 = 0x7fefffffffffffff
00429418  int64_t data_429418 = 0x10000000000000
00429420  int64_t data_429420 = -0x3f68000000000000
00429428  int64_t data_429428 = 0x4098000000000000
00429430  int64_t data_429430 = 0x7ff0000000000000
00429438  int64_t data_429438 = 0x0

00429440  ff ff ff ff                                                                                      ....

00429444  void* data_429444 = sub_42101e

00429448                          22 10 42 00 ff ff ff ff                                                          ".B.....

00429450  void* data_429450 = sub_4210d2

00429454                                                              d6 10 42 00                                              ..B.

00429458  char const data_429458[0x5] = "PATH", 0

0042945d                                                                                         00 00 00                               ...

00429460  char const data_429460[0x5] = ".com", 0

00429465                 00 00 00                                                                               ...

00429468  char const data_429468[0x5] = ".exe", 0

0042946d                                         00 00 00                                                               ...

00429470  char const data_429470[0x5] = ".bat", 0

00429475                                                                 00 00 00                                               ...

00429478  char const data_429478[0x5] = ".cmd", 0

0042947d                                                                                         00 00 00                               ...
00429480  2e 5c 00 00 53 75 6e 4d 6f 6e 54 75 65 57 65 64 54 68 75 46 72 69 53 61 74 00 00 00 4a 61 6e 46  .\..SunMonTueWedThuFriSat...JanF
004294a0  65 62 4d 61 72 41 70 72 4d 61 79 4a 75 6e 4a 75 6c 41 75 67 53 65 70 4f 63 74 4e 6f 76 44 65 63  ebMarAprMayJunJulAugSepOctNovDec
004294c0  00 00 00 00                                                                                      ....
004294c4  data_4294c4:
004294c4              54 5a 00 00                                                                              TZ..

004294c8  char const data_4294c8[0x9] = "Paraguay", 0

004294d1                                                     00 00 00                                                       ...

004294d4  char const data_4294d4[0x8] = "Uruguay", 0
004294dc  char const data_4294dc[0x6] = "Chile", 0

004294e2        00 00                                                                                        ..

004294e4  char const data_4294e4[0x8] = "Ecuador", 0
004294ec  char const data_4294ec[0xa] = "Argentina", 0

004294f6                                                                    00 00                                                ..

004294f8  char const data_4294f8[0x5] = "Peru", 0

004294fd                                                                                         00 00 00                               ...

00429500  char const data_429500[0x9] = "Colombia", 0

00429509                             00 00 00                                                                       ...

0042950c  char const data_42950c[0xa] = "Venezuela", 0

00429516                                                                    00 00                                                ..

00429518  char const data_429518[0x13] = "Dominican Republic", 0

0042952b                                   00                                                                         .

0042952c  char const data_42952c[0xd] = "South Africa", 0

00429539                                                                             00 00 00                                       ...

0042953c  char const data_42953c[0x7] = "Panama", 0

00429543           00                                                                                         .

00429544  char const data_429544[0xb] = "Luxembourg", 0

0042954f                                               00                                                                 .

00429550  char const data_429550[0xb] = "Costa Rica", 0

0042955b                                                                                   00                                         .

0042955c  char const data_42955c[0xc] = "Switzerland", 0
00429568  char const data_429568[0xa] = "Guatemala", 0

00429572                                                        00 00                                                        ..

00429574  char const data_429574[0x7] = "Canada", 0

0042957b                                                                                   00                                         .

0042957c  char const data_42957c[0x16] = "Spanish - Modern Sort", 0

00429592                                                        00 00                                                        ..

00429594  char const data_429594[0xa] = "Australia", 0

0042959e                                                                                            00 00                                ..

004295a0  char const data_4295a0[0x8] = "English", 0
004295a8  char const data_4295a8[0x8] = "Austria", 0
004295b0  char const data_4295b0[0x7] = "German", 0

004295b7                                                                       00                                                 .

004295b8  char const data_4295b8[0x8] = "Belgium", 0
004295c0  char const data_4295c0[0x7] = "Mexico", 0

004295c7                       00                                                                                 .

004295c8  char const data_4295c8[0x8] = "Spanish", 0
004295d0  char const data_4295d0[0x7] = "Basque", 0

004295d7                                                                       00                                                 .

004295d8  char const data_4295d8[0x7] = "Sweden", 0

004295df                                                                                               00                                 .

004295e0  char const data_4295e0[0x8] = "Swedish", 0
004295e8  char const data_4295e8[0x8] = "Iceland", 0
004295f0  char const data_4295f0[0xa] = "Icelandic", 0

004295fa                                                                                00 00                                        ..

004295fc  char const data_4295fc[0x7] = "France", 0

00429603           00                                                                                         .

00429604  char const data_429604[0x7] = "French", 0

0042960b                                   00                                                                         .

0042960c  char const data_42960c[0x8] = "Finland", 0
00429614  char const data_429614[0x8] = "Finnish", 0
0042961c  char const data_42961c[0x6] = "Spain", 0

00429622        00 00                                                                                        ..

00429624  char const data_429624[0x1b] = "Spanish - Traditional Sort", 0

0042963f                                                                                               00                                 .

00429640  char const data_429640[0xe] = "united-states", 0

0042964e                                            00 00                                                                ..

00429650  char const data_429650[0xf] = "united-kingdom", 0

0042965f                                                                                               00                                 .

00429660  char const data_429660[0x12] = "trinidad & tobago", 0

00429672                                                        00 00                                                        ..

00429674  char const data_429674[0xc] = "south-korea", 0
00429680  char const data_429680[0xd] = "south-africa", 0

0042968d                                         00 00 00                                                               ...

00429690  char const data_429690[0xc] = "south korea", 0
0042969c  char const data_42969c[0xd] = "south africa", 0

004296a9                             00 00 00                                                                       ...

004296ac  char const data_4296ac[0x7] = "slovak", 0

004296b3                                                           00                                                         .

004296b4  char const data_4296b4[0xc] = "puerto-rico", 0
004296c0  char const data_4296c0[0x9] = "pr-china", 0

004296c9                             00 00 00                                                                       ...

004296cc  char const data_4296cc[0x9] = "pr china", 0

004296d5                                                                 00 00 00 6e 7a 00 00                                   ...nz..

004296dc  char const data_4296dc[0xc] = "new-zealand", 0
004296e8  char const data_4296e8[0xa] = "hong-kong", 0

004296f2                                                        00 00                                                        ..

004296f4  char const data_4296f4[0x8] = "holland", 0
004296fc  char const data_4296fc[0xe] = "great britain", 0

0042970a                                00 00                                                                        ..

0042970c  char const data_42970c[0x8] = "england", 0
00429714  char const data_429714[0x6] = "czech", 0

0042971a                                                                                00 00                                        ..

0042971c  char const data_42971c[0x6] = "china", 0

00429722        00 00                                                                                        ..

00429724  char const data_429724[0x8] = "britain", 0
0042972c  char const data_42972c[0x8] = "america", 0

00429734                                                              75 73 61 00 75 73 00 00 75 6b 00 00                      usa.us..uk..

00429740  char const data_429740[0x6] = "swiss", 0

00429746                    00 00                                                                                ..

00429748  char const data_429748[0x10] = "swedish-finland", 0
00429758  char const data_429758[0x12] = "spanish-venezuela", 0

0042976a                                00 00                                                                        ..

0042976c  char const data_42976c[0x10] = "spanish-uruguay", 0
0042977c  char const data_42977c[0x14] = "spanish-puerto rico", 0
00429790  char const data_429790[0xd] = "spanish-peru", 0

0042979d                                                                                         00 00 00                               ...

004297a0  char const data_4297a0[0x11] = "spanish-paraguay", 0

004297b1                                                     00 00 00                                                       ...

004297b4  char const data_4297b4[0xf] = "spanish-panama", 0

004297c3           00                                                                                         .

004297c4  char const data_4297c4[0x12] = "spanish-nicaragua", 0

004297d6                                                                    00 00                                                ..

004297d8  char const data_4297d8[0xf] = "spanish-modern", 0

004297e7                       00                                                                                 .

004297e8  char const data_4297e8[0x10] = "spanish-mexican", 0
004297f8  char const data_4297f8[0x11] = "spanish-honduras", 0

00429809                             00 00 00                                                                       ...

0042980c  char const data_42980c[0x12] = "spanish-guatemala", 0

0042981e                                                                                            00 00                                ..

00429820  char const data_429820[0x14] = "spanish-el salvador", 0
00429834  char const data_429834[0x10] = "spanish-ecuador", 0
00429844  char const data_429844[0x1b] = "spanish-dominican republic", 0

0042985f                                                                                               00                                 .

00429860  char const data_429860[0x13] = "spanish-costa rica", 0

00429873                                                           00                                                         .

00429874  char const data_429874[0x11] = "spanish-colombia", 0

00429885                 00 00 00                                                                               ...

00429888  char const data_429888[0xe] = "spanish-chile", 0

00429896                                                                    00 00                                                ..

00429898  char const data_429898[0x10] = "spanish-bolivia", 0
004298a8  char const data_4298a8[0x12] = "spanish-argentina", 0

004298ba                                                                                00 00                                        ..

004298bc  char const data_4298bc[0x15] = "portuguese-brazilian", 0

004298d1                                                     00 00 00                                                       ...

004298d4  char const data_4298d4[0x12] = "norwegian-nynorsk", 0

004298e6                    00 00                                                                                ..

004298e8  char const data_4298e8[0x11] = "norwegian-bokmal", 0

004298f9                                                                             00 00 00                                       ...

004298fc  char const data_4298fc[0xa] = "norwegian", 0

00429906                    00 00                                                                                ..

00429908  char const data_429908[0xe] = "italian-swiss", 0

00429916                                                                    00 00                                                ..

00429918  char const data_429918[0xe] = "irish-english", 0

00429926                    00 00                                                                                ..

00429928  char const data_429928[0xd] = "german-swiss", 0

00429935                                                                 00 00 00                                               ...

00429938  char const data_429938[0x12] = "german-luxembourg", 0

0042994a                                00 00                                                                        ..

0042994c  char const data_42994c[0x14] = "german-lichtenstein", 0
00429960  char const data_429960[0x10] = "german-austrian", 0
00429970  char const data_429970[0xd] = "french-swiss", 0

0042997d                                                                                         00 00 00                               ...

00429980  char const data_429980[0x12] = "french-luxembourg", 0

00429992                                                        00 00                                                        ..

00429994  char const data_429994[0x10] = "french-canadian", 0
004299a4  char const data_4299a4[0xf] = "french-belgian", 0

004299b3                                                           00                                                         .

004299b4  char const data_4299b4[0xc] = "english-usa", 0
004299c0  char const data_4299c0[0xb] = "english-us", 0

004299cb                                   00                                                                         .

004299cc  char const data_4299cc[0xb] = "english-uk", 0

004299d7                                                                       00                                                 .

004299d8  char const data_4299d8[0x1a] = "english-trinidad y tobago", 0

004299f2                                                        00 00                                                        ..

004299f4  char const data_4299f4[0x15] = "english-south africa", 0

00429a09                             00 00 00                                                                       ...

00429a0c  char const data_429a0c[0xb] = "english-nz", 0

00429a17                                                                       00                                                 .

00429a18  char const data_429a18[0x10] = "english-jamaica", 0
00429a28  char const data_429a28[0xc] = "english-ire", 0
00429a34  char const data_429a34[0x12] = "english-caribbean", 0

00429a46                    00 00                                                                                ..

00429a48  char const data_429a48[0xc] = "english-can", 0
00429a54  char const data_429a54[0xf] = "english-belize", 0

00429a63           00                                                                                         .

00429a64  char const data_429a64[0xc] = "english-aus", 0
00429a70  char const data_429a70[0x11] = "english-american", 0

00429a81     00 00 00                                                                                       ...

00429a84  char const data_429a84[0xe] = "dutch-belgian", 0

00429a92                                                        00 00                                                        ..

00429a94  char const data_429a94[0x14] = "chinese-traditional", 0
00429aa8  char const data_429aa8[0x12] = "chinese-singapore", 0

00429aba                                                                                00 00                                        ..

00429abc  char const data_429abc[0x13] = "chinese-simplified", 0

00429acf                                               00                                                                 .

00429ad0  char const data_429ad0[0x11] = "chinese-hongkong", 0

00429ae1     00 00 00                                                                                       ...

00429ae4  char const data_429ae4[0x8] = "chinese", 0

00429aec                                      63 68 69 00 63 68 68 00                                                  chi.chh.

00429af4  char const data_429af4[0x9] = "canadian", 0

00429afd                                                                                         00 00 00                               ...

00429b00  char const data_429b00[0x8] = "belgian", 0
00429b08  char const data_429b08[0xb] = "australian", 0

00429b13                                                           00                                                         .

00429b14  char const data_429b14[0x11] = "american-english", 0

00429b25                 00 00 00                                                                               ...

00429b28  char const data_429b28[0x11] = "american english", 0

00429b39                                                                             00 00 00                                       ...

00429b3c  char const data_429b3c[0x9] = "american", 0

00429b45                 00 00 00                                                                               ...
00429b48  data_429b48:
00429b48                          4f 43 50 00                                                                      OCP.
00429b4c  data_429b4c:
00429b4c                                      41 43 50 00                                                              ACP.

00429b50  char const data_429b50[0x13] = "GetLastActivePopup", 0

00429b63           00                                                                                         .

00429b64  char const data_429b64[0x10] = "GetActiveWindow", 0
00429b74  char const data_429b74[0xc] = "MessageBoxA", 0
00429b80  char const data_429b80[0xb] = "user32.dll", 0

00429b8b                                   00 00 00 00 00 ff ff ff ff                                                 .........

00429b94  void* data_429b94 = sub_42687b
00429b98  void* data_429b98 = sub_42687f

00429b9c                                                                                      ff ff ff ff                              ....

00429ba0  void* data_429ba0 = sub_4268d8
00429ba4  void* data_429ba4 = sub_4268dc
00429ba8  char const data_429ba8[0x7] = "1#QNAN", 0

00429baf                                               00                                                                 .

00429bb0  char const data_429bb0[0x6] = "1#INF", 0

00429bb6                                                                    00 00                                                ..

00429bb8  char const data_429bb8[0x6] = "1#IND", 0

00429bbe                                                                                            00 00                                ..

00429bc0  char const data_429bc0[0x7] = "1#SNAN", 0

00429bc7                       00 ff ff ff ff                                                                     .....

00429bcc  void* data_429bcc = sub_42733e

00429bd0                                                  42 73 42 00 00 00 00 00 ff ff ff ff                              BsB.........

00429bdc  void* data_429bdc = sub_427457

00429be0  5b 74 42 00                                                                                      [tB.
00429be4  struct Import_Directory_Table __import_directory_entries[0x3] = 
00429be4  {
00429be4      [0x0] = 
00429be4      {
00429be4          uint32_t importLookupTableRva = 0x29c20
00429be8          uint32_t timeDateStamp = 0x0
00429bec          uint32_t forwarderChain = 0x0
00429bf0          uint32_t nameRva = 0x29db0
00429bf4          uint32_t importAddressTableRva = 0x28000
00429bf8      }
00429bf8      [0x1] = 
00429bf8      {
00429bf8          uint32_t importLookupTableRva = 0x29d40
00429bfc          uint32_t timeDateStamp = 0x0
00429c00          uint32_t forwarderChain = 0x0
00429c04          uint32_t nameRva = 0x29dcc
00429c08          uint32_t importAddressTableRva = 0x28120
00429c0c      }
00429c0c      [0x2] = 
00429c0c      {
00429c0c          uint32_t importLookupTableRva = 0x0
00429c10          uint32_t timeDateStamp = 0x0
00429c14          uint32_t forwarderChain = 0x0
00429c18          uint32_t nameRva = 0x0
00429c1c          uint32_t importAddressTableRva = 0x0
00429c20      }
00429c20  }
00429c20  uint32_t __import_lookup_table_0(KERNEL32:GetStartupInfoA) = 0x29fdc
00429c24  uint32_t __import_lookup_table_0(KERNEL32:LoadLibraryA) = 0x29d5e
00429c28  uint32_t __import_lookup_table_0(KERNEL32:FormatMessageA) = 0x29d6e
00429c2c  uint32_t __import_lookup_table_0(KERNEL32:GetLastError) = 0x29d80
00429c30  uint32_t __import_lookup_table_0(KERNEL32:GetProcAddress) = 0x29d90
00429c34  uint32_t __import_lookup_table_0(KERNEL32:FreeLibrary) = 0x29da2
00429c38  uint32_t __import_lookup_table_0(KERNEL32:HeapCreate) = 0x2a026
00429c3c  uint32_t __import_lookup_table_0(KERNEL32:HeapDestroy) = 0x2a018
00429c40  uint32_t __import_lookup_table_0(KERNEL32:ExitProcess) = 0x29dd8
00429c44  uint32_t __import_lookup_table_0(KERNEL32:TerminateProcess) = 0x29de6
00429c48  uint32_t __import_lookup_table_0(KERNEL32:GetCurrentProcess) = 0x29dfa
00429c4c  uint32_t __import_lookup_table_0(KERNEL32:GetCommandLineA) = 0x29e0e
00429c50  uint32_t __import_lookup_table_0(KERNEL32:GetVersion) = 0x29e20
00429c54  uint32_t __import_lookup_table_0(KERNEL32:HeapReAlloc) = 0x29e2e
00429c58  uint32_t __import_lookup_table_0(KERNEL32:HeapAlloc) = 0x29e3c
00429c5c  uint32_t __import_lookup_table_0(KERNEL32:HeapFree) = 0x29e48
00429c60  uint32_t __import_lookup_table_0(KERNEL32:DeleteFileA) = 0x29e54
00429c64  uint32_t __import_lookup_table_0(KERNEL32:MoveFileA) = 0x29e62
00429c68  uint32_t __import_lookup_table_0(KERNEL32:GetSystemTimeAsFileTime) = 0x29e6e
00429c6c  uint32_t __import_lookup_table_0(KERNEL32:GetTimeZoneInformation) = 0x29e88
00429c70  uint32_t __import_lookup_table_0(KERNEL32:GetSystemTime) = 0x29ea2
00429c74  uint32_t __import_lookup_table_0(KERNEL32:GetLocalTime) = 0x29eb2
00429c78  uint32_t __import_lookup_table_0(KERNEL32:CloseHandle) = 0x29ec2
00429c7c  uint32_t __import_lookup_table_0(KERNEL32:DuplicateHandle) = 0x29ed0
00429c80  uint32_t __import_lookup_table_0(KERNEL32:GetModuleHandleA) = 0x29ee2
00429c84  uint32_t __import_lookup_table_0(KERNEL32:ReadFile) = 0x29ef6
00429c88  uint32_t __import_lookup_table_0(KERNEL32:SetFilePointer) = 0x29f02
00429c8c  uint32_t __import_lookup_table_0(KERNEL32:UnhandledExceptionFilter) = 0x29f14
00429c90  uint32_t __import_lookup_table_0(KERNEL32:FreeEnvironmentStringsA) = 0x29f30
00429c94  uint32_t __import_lookup_table_0(KERNEL32:FreeEnvironmentStringsW) = 0x29f4a
00429c98  uint32_t __import_lookup_table_0(KERNEL32:WideCharToMultiByte) = 0x29f64
00429c9c  uint32_t __import_lookup_table_0(KERNEL32:GetEnvironmentStrings) = 0x29f7a
00429ca0  uint32_t __import_lookup_table_0(KERNEL32:GetEnvironmentStringsW) = 0x29f92
00429ca4  uint32_t __import_lookup_table_0(KERNEL32:SetHandleCount) = 0x29fac
00429ca8  uint32_t __import_lookup_table_0(KERNEL32:GetStdHandle) = 0x29fbe
00429cac  uint32_t __import_lookup_table_0(KERNEL32:GetFileType) = 0x29fce
00429cb0  uint32_t __import_lookup_table_0(KERNEL32:GetModuleFileNameA) = 0x29d48
00429cb4  uint32_t __import_lookup_table_0(KERNEL32:GetEnvironmentVariableA) = 0x29fee
00429cb8  uint32_t __import_lookup_table_0(KERNEL32:GetVersionExA) = 0x2a008
00429cbc  uint32_t __import_lookup_table_0(KERNEL32:SetEnvironmentVariableA) = 0x2a236
00429cc0  uint32_t __import_lookup_table_0(KERNEL32:GetLocaleInfoW) = 0x2a250
00429cc4  uint32_t __import_lookup_table_0(KERNEL32:VirtualFree) = 0x2a034
00429cc8  uint32_t __import_lookup_table_0(KERNEL32:RtlUnwind) = 0x2a042
00429ccc  uint32_t __import_lookup_table_0(KERNEL32:WriteFile) = 0x2a04e
00429cd0  uint32_t __import_lookup_table_0(KERNEL32:VirtualAlloc) = 0x2a05a
00429cd4  uint32_t __import_lookup_table_0(KERNEL32:MultiByteToWideChar) = 0x2a06a
00429cd8  uint32_t __import_lookup_table_0(KERNEL32:GetStringTypeA) = 0x2a080
00429cdc  uint32_t __import_lookup_table_0(KERNEL32:GetStringTypeW) = 0x2a092
00429ce0  uint32_t __import_lookup_table_0(KERNEL32:GetCPInfo) = 0x2a0a4
00429ce4  uint32_t __import_lookup_table_0(KERNEL32:CompareStringA) = 0x2a0b0
00429ce8  uint32_t __import_lookup_table_0(KERNEL32:CompareStringW) = 0x2a0c2
00429cec  uint32_t __import_lookup_table_0(KERNEL32:RaiseException) = 0x2a0d4
00429cf0  uint32_t __import_lookup_table_0(KERNEL32:LCMapStringA) = 0x2a0e6
00429cf4  uint32_t __import_lookup_table_0(KERNEL32:LCMapStringW) = 0x2a0f6
00429cf8  uint32_t __import_lookup_table_0(KERNEL32:GetFileAttributesA) = 0x2a106
00429cfc  uint32_t __import_lookup_table_0(KERNEL32:CreateFileA) = 0x2a11c
00429d00  uint32_t __import_lookup_table_0(KERNEL32:GetCurrentProcessId) = 0x2a12a
00429d04  uint32_t __import_lookup_table_0(KERNEL32:IsValidLocale) = 0x2a140
00429d08  uint32_t __import_lookup_table_0(KERNEL32:IsValidCodePage) = 0x2a150
00429d0c  uint32_t __import_lookup_table_0(KERNEL32:GetLocaleInfoA) = 0x2a162
00429d10  uint32_t __import_lookup_table_0(KERNEL32:EnumSystemLocalesA) = 0x2a174
00429d14  uint32_t __import_lookup_table_0(KERNEL32:GetUserDefaultLCID) = 0x2a18a
00429d18  uint32_t __import_lookup_table_0(KERNEL32:SetStdHandle) = 0x2a1a0
00429d1c  uint32_t __import_lookup_table_0(KERNEL32:CreatePipe) = 0x2a1b0
00429d20  uint32_t __import_lookup_table_0(KERNEL32:GetExitCodeProcess) = 0x2a1be
00429d24  uint32_t __import_lookup_table_0(KERNEL32:WaitForSingleObject) = 0x2a1d4
00429d28  uint32_t __import_lookup_table_0(KERNEL32:FlushFileBuffers) = 0x2a1ea
00429d2c  uint32_t __import_lookup_table_0(KERNEL32:GetACP) = 0x2a1fe
00429d30  uint32_t __import_lookup_table_0(KERNEL32:GetOEMCP) = 0x2a208
00429d34  uint32_t __import_lookup_table_0(KERNEL32:CreateProcessA) = 0x2a214
00429d38  uint32_t __import_lookup_table_0(KERNEL32:SetEndOfFile) = 0x2a226
00429d3c  uint32_t data_429d3c = 0x0
00429d40  uint32_t __import_lookup_table_1(USER32:MessageBoxA) = 0x29dbe
00429d44  uint32_t data_429d44 = 0x0
00429d48  uint16_t __export_name_ptr_table_0(KERNEL32:GetModuleFileNameA) = 0x124
00429d4a  char __import_name_0(KERNEL32:GetModuleFileNameA)[0x13] = "GetModuleFileNameA", 0

00429d5d                                                                                         00                                     .

00429d5e  uint16_t __export_name_ptr_table_0(KERNEL32:LoadLibraryA) = 0x1c2
00429d60  char __import_name_0(KERNEL32:LoadLibraryA)[0xd] = "LoadLibraryA", 0

00429d6d                                         00                                                                     .

00429d6e  uint16_t __export_name_ptr_table_0(KERNEL32:FormatMessageA) = 0xaf
00429d70  char __import_name_0(KERNEL32:FormatMessageA)[0xf] = "FormatMessageA", 0

00429d7f                                                                                               00                                 .

00429d80  uint16_t __export_name_ptr_table_0(KERNEL32:GetLastError) = 0x11a
00429d82  char __import_name_0(KERNEL32:GetLastError)[0xd] = "GetLastError", 0

00429d8f                                               00                                                                 .

00429d90  uint16_t __export_name_ptr_table_0(KERNEL32:GetProcAddress) = 0x13e
00429d92  char __import_name_0(KERNEL32:GetProcAddress)[0xf] = "GetProcAddress", 0

00429da1     00                                                                                             .

00429da2  uint16_t __export_name_ptr_table_0(KERNEL32:FreeLibrary) = 0xb4
00429da4  char __import_name_0(KERNEL32:FreeLibrary)[0xc] = "FreeLibrary", 0
00429db0  char __import_dll_name(KERNEL32)[0xd] = "KERNEL32.dll", 0

00429dbd                                                                                         00                                     .

00429dbe  uint16_t __export_name_ptr_table_1(USER32:MessageBoxA) = 0x1be
00429dc0  char __import_name_1(USER32:MessageBoxA)[0xc] = "MessageBoxA", 0
00429dcc  char __import_dll_name(USER32)[0xb] = "USER32.dll", 0

00429dd7                                                                       00                                                 .

00429dd8  uint16_t __export_name_ptr_table_0(KERNEL32:ExitProcess) = 0x7d
00429dda  char __import_name_0(KERNEL32:ExitProcess)[0xc] = "ExitProcess", 0
00429de6  uint16_t __export_name_ptr_table_0(KERNEL32:TerminateProcess) = 0x29e
00429de8  char __import_name_0(KERNEL32:TerminateProcess)[0x11] = "TerminateProcess", 0

00429df9                                                                             00                                             .

00429dfa  uint16_t __export_name_ptr_table_0(KERNEL32:GetCurrentProcess) = 0xf7
00429dfc  char __import_name_0(KERNEL32:GetCurrentProcess)[0x12] = "GetCurrentProcess", 0
00429e0e  uint16_t __export_name_ptr_table_0(KERNEL32:GetCommandLineA) = 0xca
00429e10  char __import_name_0(KERNEL32:GetCommandLineA)[0x10] = "GetCommandLineA", 0
00429e20  uint16_t __export_name_ptr_table_0(KERNEL32:GetVersion) = 0x174
00429e22  char __import_name_0(KERNEL32:GetVersion)[0xb] = "GetVersion", 0

00429e2d                                         00                                                                     .

00429e2e  uint16_t __export_name_ptr_table_0(KERNEL32:HeapReAlloc) = 0x1a2
00429e30  char __import_name_0(KERNEL32:HeapReAlloc)[0xc] = "HeapReAlloc", 0
00429e3c  uint16_t __export_name_ptr_table_0(KERNEL32:HeapAlloc) = 0x199
00429e3e  char __import_name_0(KERNEL32:HeapAlloc)[0xa] = "HeapAlloc", 0
00429e48  uint16_t __export_name_ptr_table_0(KERNEL32:HeapFree) = 0x19f
00429e4a  char __import_name_0(KERNEL32:HeapFree)[0x9] = "HeapFree", 0

00429e53                                                           00                                                         .

00429e54  uint16_t __export_name_ptr_table_0(KERNEL32:DeleteFileA) = 0x57
00429e56  char __import_name_0(KERNEL32:DeleteFileA)[0xc] = "DeleteFileA", 0
00429e62  uint16_t __export_name_ptr_table_0(KERNEL32:MoveFileA) = 0x1dd
00429e64  char __import_name_0(KERNEL32:MoveFileA)[0xa] = "MoveFileA", 0
00429e6e  uint16_t __export_name_ptr_table_0(KERNEL32:GetSystemTimeAsFileTime) = 0x15f
00429e70  char __import_name_0(KERNEL32:GetSystemTimeAsFileTime)[0x18] = "GetSystemTimeAsFileTime", 0
00429e88  uint16_t __export_name_ptr_table_0(KERNEL32:GetTimeZoneInformation) = 0x170
00429e8a  char __import_name_0(KERNEL32:GetTimeZoneInformation)[0x17] = "GetTimeZoneInformation", 0

00429ea1     00                                                                                             .

00429ea2  uint16_t __export_name_ptr_table_0(KERNEL32:GetSystemTime) = 0x15d
00429ea4  char __import_name_0(KERNEL32:GetSystemTime)[0xe] = "GetSystemTime", 0
00429eb2  uint16_t __export_name_ptr_table_0(KERNEL32:GetLocalTime) = 0x11b
00429eb4  char __import_name_0(KERNEL32:GetLocalTime)[0xd] = "GetLocalTime", 0

00429ec1     00                                                                                             .

00429ec2  uint16_t __export_name_ptr_table_0(KERNEL32:CloseHandle) = 0x1b
00429ec4  char __import_name_0(KERNEL32:CloseHandle)[0xc] = "CloseHandle", 0
00429ed0  uint16_t __export_name_ptr_table_0(KERNEL32:DuplicateHandle) = 0x63
00429ed2  char __import_name_0(KERNEL32:DuplicateHandle)[0x10] = "DuplicateHandle", 0
00429ee2  uint16_t __export_name_ptr_table_0(KERNEL32:GetModuleHandleA) = 0x126
00429ee4  char __import_name_0(KERNEL32:GetModuleHandleA)[0x11] = "GetModuleHandleA", 0

00429ef5                                                                 00                                                     .

00429ef6  uint16_t __export_name_ptr_table_0(KERNEL32:ReadFile) = 0x218
00429ef8  char __import_name_0(KERNEL32:ReadFile)[0x9] = "ReadFile", 0

00429f01     00                                                                                             .

00429f02  uint16_t __export_name_ptr_table_0(KERNEL32:SetFilePointer) = 0x26a
00429f04  char __import_name_0(KERNEL32:SetFilePointer)[0xf] = "SetFilePointer", 0

00429f13                                                           00                                                         .

00429f14  uint16_t __export_name_ptr_table_0(KERNEL32:UnhandledExceptionFilter) = 0x2ad
00429f16  char __import_name_0(KERNEL32:UnhandledExceptionFilter)[0x19] = "UnhandledExceptionFilter", 0

00429f2f                                               00                                                                 .

00429f30  uint16_t __export_name_ptr_table_0(KERNEL32:FreeEnvironmentStringsA) = 0xb2
00429f32  char __import_name_0(KERNEL32:FreeEnvironmentStringsA)[0x18] = "FreeEnvironmentStringsA", 0
00429f4a  uint16_t __export_name_ptr_table_0(KERNEL32:FreeEnvironmentStringsW) = 0xb3
00429f4c  char __import_name_0(KERNEL32:FreeEnvironmentStringsW)[0x18] = "FreeEnvironmentStringsW", 0
00429f64  uint16_t __export_name_ptr_table_0(KERNEL32:WideCharToMultiByte) = 0x2d2
00429f66  char __import_name_0(KERNEL32:WideCharToMultiByte)[0x14] = "WideCharToMultiByte", 0
00429f7a  uint16_t __export_name_ptr_table_0(KERNEL32:GetEnvironmentStrings) = 0x106
00429f7c  char __import_name_0(KERNEL32:GetEnvironmentStrings)[0x16] = "GetEnvironmentStrings", 0
00429f92  uint16_t __export_name_ptr_table_0(KERNEL32:GetEnvironmentStringsW) = 0x108
00429f94  char __import_name_0(KERNEL32:GetEnvironmentStringsW)[0x17] = "GetEnvironmentStringsW", 0

00429fab                                   00                                                                         .

00429fac  uint16_t __export_name_ptr_table_0(KERNEL32:SetHandleCount) = 0x26d
00429fae  char __import_name_0(KERNEL32:SetHandleCount)[0xf] = "SetHandleCount", 0

00429fbd                                                                                         00                                     .

00429fbe  uint16_t __export_name_ptr_table_0(KERNEL32:GetStdHandle) = 0x152
00429fc0  char __import_name_0(KERNEL32:GetStdHandle)[0xd] = "GetStdHandle", 0

00429fcd                                         00                                                                     .

00429fce  uint16_t __export_name_ptr_table_0(KERNEL32:GetFileType) = 0x115
00429fd0  char __import_name_0(KERNEL32:GetFileType)[0xc] = "GetFileType", 0
00429fdc  uint16_t __export_name_ptr_table_0(KERNEL32:GetStartupInfoA) = 0x150
00429fde  char __import_name_0(KERNEL32:GetStartupInfoA)[0x10] = "GetStartupInfoA", 0
00429fee  uint16_t __export_name_ptr_table_0(KERNEL32:GetEnvironmentVariableA) = 0x109
00429ff0  char __import_name_0(KERNEL32:GetEnvironmentVariableA)[0x18] = "GetEnvironmentVariableA", 0
0042a008  uint16_t __export_name_ptr_table_0(KERNEL32:GetVersionExA) = 0x175
0042a00a  char __import_name_0(KERNEL32:GetVersionExA)[0xe] = "GetVersionExA", 0
0042a018  uint16_t __export_name_ptr_table_0(KERNEL32:HeapDestroy) = 0x19d
0042a01a  char __import_name_0(KERNEL32:HeapDestroy)[0xc] = "HeapDestroy", 0
0042a026  uint16_t __export_name_ptr_table_0(KERNEL32:HeapCreate) = 0x19b
0042a028  char __import_name_0(KERNEL32:HeapCreate)[0xb] = "HeapCreate", 0

0042a033                                                           00                                                         .

0042a034  uint16_t __export_name_ptr_table_0(KERNEL32:VirtualFree) = 0x2bf
0042a036  char __import_name_0(KERNEL32:VirtualFree)[0xc] = "VirtualFree", 0
0042a042  uint16_t __export_name_ptr_table_0(KERNEL32:RtlUnwind) = 0x22f
0042a044  char __import_name_0(KERNEL32:RtlUnwind)[0xa] = "RtlUnwind", 0
0042a04e  uint16_t __export_name_ptr_table_0(KERNEL32:WriteFile) = 0x2df
0042a050  char __import_name_0(KERNEL32:WriteFile)[0xa] = "WriteFile", 0
0042a05a  uint16_t __export_name_ptr_table_0(KERNEL32:VirtualAlloc) = 0x2bb
0042a05c  char __import_name_0(KERNEL32:VirtualAlloc)[0xd] = "VirtualAlloc", 0

0042a069                             00                                                                             .

0042a06a  uint16_t __export_name_ptr_table_0(KERNEL32:MultiByteToWideChar) = 0x1e4
0042a06c  char __import_name_0(KERNEL32:MultiByteToWideChar)[0x14] = "MultiByteToWideChar", 0
0042a080  uint16_t __export_name_ptr_table_0(KERNEL32:GetStringTypeA) = 0x153
0042a082  char __import_name_0(KERNEL32:GetStringTypeA)[0xf] = "GetStringTypeA", 0

0042a091                                                     00                                                             .

0042a092  uint16_t __export_name_ptr_table_0(KERNEL32:GetStringTypeW) = 0x156
0042a094  char __import_name_0(KERNEL32:GetStringTypeW)[0xf] = "GetStringTypeW", 0

0042a0a3           00                                                                                         .

0042a0a4  uint16_t __export_name_ptr_table_0(KERNEL32:GetCPInfo) = 0xbf
0042a0a6  char __import_name_0(KERNEL32:GetCPInfo)[0xa] = "GetCPInfo", 0
0042a0b0  uint16_t __export_name_ptr_table_0(KERNEL32:CompareStringA) = 0x21
0042a0b2  char __import_name_0(KERNEL32:CompareStringA)[0xf] = "CompareStringA", 0

0042a0c1     00                                                                                             .

0042a0c2  uint16_t __export_name_ptr_table_0(KERNEL32:CompareStringW) = 0x22
0042a0c4  char __import_name_0(KERNEL32:CompareStringW)[0xf] = "CompareStringW", 0

0042a0d3                                                           00                                                         .

0042a0d4  uint16_t __export_name_ptr_table_0(KERNEL32:RaiseException) = 0x20b
0042a0d6  char __import_name_0(KERNEL32:RaiseException)[0xf] = "RaiseException", 0

0042a0e5                 00                                                                                     .

0042a0e6  uint16_t __export_name_ptr_table_0(KERNEL32:LCMapStringA) = 0x1bf
0042a0e8  char __import_name_0(KERNEL32:LCMapStringA)[0xd] = "LCMapStringA", 0

0042a0f5                                                                 00                                                     .

0042a0f6  uint16_t __export_name_ptr_table_0(KERNEL32:LCMapStringW) = 0x1c0
0042a0f8  char __import_name_0(KERNEL32:LCMapStringW)[0xd] = "LCMapStringW", 0

0042a105                 00                                                                                     .

0042a106  uint16_t __export_name_ptr_table_0(KERNEL32:GetFileAttributesA) = 0x10d
0042a108  char __import_name_0(KERNEL32:GetFileAttributesA)[0x13] = "GetFileAttributesA", 0

0042a11b                                                                                   00                                         .

0042a11c  uint16_t __export_name_ptr_table_0(KERNEL32:CreateFileA) = 0x34
0042a11e  char __import_name_0(KERNEL32:CreateFileA)[0xc] = "CreateFileA", 0
0042a12a  uint16_t __export_name_ptr_table_0(KERNEL32:GetCurrentProcessId) = 0xf8
0042a12c  char __import_name_0(KERNEL32:GetCurrentProcessId)[0x14] = "GetCurrentProcessId", 0
0042a140  uint16_t __export_name_ptr_table_0(KERNEL32:IsValidLocale) = 0x1be
0042a142  char __import_name_0(KERNEL32:IsValidLocale)[0xe] = "IsValidLocale", 0
0042a150  uint16_t __export_name_ptr_table_0(KERNEL32:IsValidCodePage) = 0x1bd
0042a152  char __import_name_0(KERNEL32:IsValidCodePage)[0x10] = "IsValidCodePage", 0
0042a162  uint16_t __export_name_ptr_table_0(KERNEL32:GetLocaleInfoA) = 0x11c
0042a164  char __import_name_0(KERNEL32:GetLocaleInfoA)[0xf] = "GetLocaleInfoA", 0

0042a173                                                           00                                                         .

0042a174  uint16_t __export_name_ptr_table_0(KERNEL32:EnumSystemLocalesA) = 0x77
0042a176  char __import_name_0(KERNEL32:EnumSystemLocalesA)[0x13] = "EnumSystemLocalesA", 0

0042a189                             00                                                                             .

0042a18a  uint16_t __export_name_ptr_table_0(KERNEL32:GetUserDefaultLCID) = 0x171
0042a18c  char __import_name_0(KERNEL32:GetUserDefaultLCID)[0x13] = "GetUserDefaultLCID", 0

0042a19f                                                                                               00                                 .

0042a1a0  uint16_t __export_name_ptr_table_0(KERNEL32:SetStdHandle) = 0x27c
0042a1a2  char __import_name_0(KERNEL32:SetStdHandle)[0xd] = "SetStdHandle", 0

0042a1af                                               00                                                                 .

0042a1b0  uint16_t __export_name_ptr_table_0(KERNEL32:CreatePipe) = 0x43
0042a1b2  char __import_name_0(KERNEL32:CreatePipe)[0xb] = "CreatePipe", 0

0042a1bd                                                                                         00                                     .

0042a1be  uint16_t __export_name_ptr_table_0(KERNEL32:GetExitCodeProcess) = 0x10b
0042a1c0  char __import_name_0(KERNEL32:GetExitCodeProcess)[0x13] = "GetExitCodeProcess", 0

0042a1d3                                                           00                                                         .

0042a1d4  uint16_t __export_name_ptr_table_0(KERNEL32:WaitForSingleObject) = 0x2ce
0042a1d6  char __import_name_0(KERNEL32:WaitForSingleObject)[0x14] = "WaitForSingleObject", 0
0042a1ea  uint16_t __export_name_ptr_table_0(KERNEL32:FlushFileBuffers) = 0xaa
0042a1ec  char __import_name_0(KERNEL32:FlushFileBuffers)[0x11] = "FlushFileBuffers", 0

0042a1fd                                                                                         00                                     .

0042a1fe  uint16_t __export_name_ptr_table_0(KERNEL32:GetACP) = 0xb9
0042a200  char __import_name_0(KERNEL32:GetACP)[0x7] = "GetACP", 0

0042a207                       00                                                                                 .

0042a208  uint16_t __export_name_ptr_table_0(KERNEL32:GetOEMCP) = 0x131
0042a20a  char __import_name_0(KERNEL32:GetOEMCP)[0x9] = "GetOEMCP", 0

0042a213                                                           00                                                         .

0042a214  uint16_t __export_name_ptr_table_0(KERNEL32:CreateProcessA) = 0x44
0042a216  char __import_name_0(KERNEL32:CreateProcessA)[0xf] = "CreateProcessA", 0

0042a225                 00                                                                                     .

0042a226  uint16_t __export_name_ptr_table_0(KERNEL32:SetEndOfFile) = 0x261
0042a228  char __import_name_0(KERNEL32:SetEndOfFile)[0xd] = "SetEndOfFile", 0

0042a235                                                                 00                                                     .

0042a236  uint16_t __export_name_ptr_table_0(KERNEL32:SetEnvironmentVariableA) = 0x262
0042a238  char __import_name_0(KERNEL32:SetEnvironmentVariableA)[0x18] = "SetEnvironmentVariableA", 0
0042a250  uint16_t __export_name_ptr_table_0(KERNEL32:GetLocaleInfoW) = 0x11d
0042a252  char __import_name_0(KERNEL32:GetLocaleInfoW)[0xf] = "GetLocaleInfoW", 0

0042a261     00                                                                                             .
.rdata section ended  {0x428000-0x42a262}

.data section started  {0x42b000-0x431f58}
0042b000  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............

0042b00c  void* data_42b00c = sub_4174f3
0042b010  void* data_42b010 = sub_41908a
0042b014  void* data_42b014 = sub_4255f2

0042b018                                                                          00 00 00 00 00 00 00 00                          ........

0042b020  void* data_42b020 = sub_417598
0042b024  void* data_42b024 = sub_4218f3

0042b028                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................

0042b040  char data_42b040[0x1c] = "not enough memory for state", 0
0042b05c  char data_42b05c[0x1e] = "cannot locate this executable", 0

0042b07a                                                                                00 00                                        ..

0042b07c  char data_42b07c[0x1d] = "too many arguments to script", 0

0042b099                                                                             00 00 00                                       ...

0042b09c  char data_42b09c[0xa] = "_PROGNAME", 0

0042b0a6                    00 00 61 72 67 00 6e 00 00 00                                                        ..arg.n...

0042b0b0  char data_42b0b0[0x1b] = "no Lua program found in %s", 0

0042b0cb                                   00                                                                         .

0042b0cc  char data_42b0cc[0x9] = "%%glue:L", 0

0042b0d5                                                                 00 00 00                                               ...

0042b0d8  char data_42b0d8[0x5] = "read", 0

0042b0dd                                                                                         00 00 00                               ...

0042b0e0  char data_42b0e0[0x5] = "seek", 0

0042b0e5                 00 00 00                                                                               ...

0042b0e8  char data_42b0e8[0x11] = "cannot %s %s: %s", 0

0042b0f9                                                                             00 00 00                                       ...

0042b0fc  char data_42b0fc[0x5] = "open", 0

0042b101     00 00 00 72 62 00 00                                                                           ...rb..

0042b108  char data_42b108[0x12] = "not enough memory", 0

0042b11a                                                                                00 00                                        ..

0042b11c  char data_42b11c[0x9] = "no value", 0

0042b125                 00 00 00                                                                               ...
0042b128  data_42b128:
0042b128                          3f 00 00 00                                                                      ?...

0042b12c  char data_42b12c[0x1e] = "bad argument #%d to \'%s\' (%s)", 0

0042b14a                                00 00                                                                        ..

0042b14c  char data_42b14c[0x1e] = "calling \'%s\' on bad self (%s)", 0

0042b16a                                00 00                                                                        ..

0042b16c  char data_42b16c[0x7] = "method", 0

0042b173                                                           00                                                         .

0042b174  char data_42b174[0x16] = "bad argument #%d (%s)", 0

0042b18a                                00 00                                                                        ..

0042b18c  char data_42b18c[0x14] = "%s expected, got %s", 0
0042b1a0  char data_42b1a0[0x8] = "%s:%d: ", 0

0042b1a8                          53 6c 00 00                                                                      Sl..

0042b1ac  char data_42b1ac[0x14] = "invalid option \'%s\'", 0
0042b1c0  char data_42b1c0[0x14] = "stack overflow (%s)", 0
0042b1d4  char data_42b1d4[0xf] = "value expected", 0

0042b1e3           00                                                                                         .

0042b1e4  char data_42b1e4[0x1e] = "name conflict for module \'%s\'", 0

0042b202        00 00                                                                                        ..

0042b204  char data_42b204[0x8] = "_LOADED", 0
0042b20c  char data_42b20c[0x7] = "reopen", 0

0042b213                                                           00                                                         .

0042b214  int32_t data_42b214 = 0x61754c1b

0042b218                                                                          00 00 00 00 72 00 00 00                          ....r...
0042b220  40 25 73 00                                                                                      @%s.

0042b224  char data_42b224[0x7] = "=stdin", 0

0042b22b                                   00                                                                         .
0042b22c  data_42b22c:
0042b22c                                      0a 00 00 00                                                              ....

0042b230  char data_42b230[0x32] = "PANIC: unprotected error in call to Lua API (%s)\n", 0

0042b262        00 00                                                                                        ..

0042b264  char data_42b264[0x6] = "debug", 0

0042b26a                                00 00                                                                        ..

0042b26c  char data_42b26c[0x5] = "math", 0

0042b271                                                     00 00 00                                                       ...

0042b274  char data_42b274[0x7] = "string", 0

0042b27b                                                                                   00 6f 73 00 00                             .os..
0042b280  69 6f 00 00                                                                                      io..

0042b284  char data_42b284[0x6] = "table", 0

0042b28a                                00 00                                                                        ..

0042b28c  char data_42b28c[0x8] = "package", 0
0042b294  char data_42b294[0x27] = "memory allocation error: block too big", 0

0042b2bb                                                                                   00                                         .

0042b2bc  char data_42b2bc[0x18] = "error in error handling", 0
0042b2d4  char data_42b2d4[0xf] = "stack overflow", 0

0042b2e3           00                                                                                         .

0042b2e4  char data_42b2e4[0x5] = "call", 0

0042b2e9                             00 00 00                                                                       ...

0042b2ec  char data_42b2ec[0x11] = "C stack overflow", 0

0042b2fd                                                                                         00 00 00                               ...

0042b300  char data_42b300[0x26] = "cannot resume non-suspended coroutine", 0

0042b326                    00 00                                                                                ..

0042b328  char data_42b328[0x1d] = "cannot resume dead coroutine", 0

0042b345                 00 00 00                                                                               ...

0042b348  char data_42b348[0x33] = "attempt to yield across metamethod/C-call boundary", 0

0042b37b                                                                                   00                                         .

0042b37c  char data_42b37c[0x6] = "<eof>", 0

0042b382        00 00                                                                                        ..

0042b384  char data_42b384[0x9] = "<string>", 0

0042b38d                                         00 00 00                                                               ...

0042b390  char data_42b390[0x7] = "<name>", 0

0042b397                                                                       00                                                 .

0042b398  char data_42b398[0x9] = "<number>", 0

0042b3a1     00 00 00 7e 3d 00 00 3c 3d 00 00 3e 3d 00 00 3d 3d 00 00                                       ...~=..<=..>=..==..
0042b3b4  data_42b3b4:
0042b3b4                                                              2e 2e 2e 00 2e 2e 00 00                                  ........

0042b3bc  char data_42b3bc[0x6] = "while", 0

0042b3c2        00 00                                                                                        ..

0042b3c4  char data_42b3c4[0x6] = "until", 0

0042b3ca                                00 00                                                                        ..

0042b3cc  char data_42b3cc[0x5] = "true", 0

0042b3d1                                                     00 00 00                                                       ...

0042b3d4  char data_42b3d4[0x5] = "then", 0

0042b3d9                                                                             00 00 00                                       ...

0042b3dc  char data_42b3dc[0x7] = "return", 0

0042b3e3           00                                                                                         .

0042b3e4  char data_42b3e4[0x7] = "repeat", 0

0042b3eb                                   00 6f 72 00 00 6e 6f 74 00 6e 69 6c 00                                     .or..not.nil.

0042b3f8  char data_42b3f8[0x6] = "local", 0

0042b3fe                                                                                            00 00                                ..
0042b400  69 6e 00 00 69 66 00 00                                                                          in..if..

0042b408  char data_42b408[0x9] = "function", 0

0042b411                                                     00 00 00 66 6f 72 00                                           ...for.

0042b418  char data_42b418[0x6] = "false", 0

0042b41e                                                                                            00 00                                ..
0042b420  65 6e 64 00                                                                                      end.

0042b424  char data_42b424[0x7] = "elseif", 0

0042b42b                                   00                                                                         .

0042b42c  char data_42b42c[0x5] = "else", 0

0042b431                                                     00 00 00 64 6f 00 00                                           ...do..

0042b438  char data_42b438[0x6] = "break", 0

0042b43e                                                                                            00 00                                ..
0042b440  61 6e 64 00 25 63 00 00                                                                          and.%c..

0042b448  char data_42b448[0x9] = "char(%d)", 0

0042b451                                                     00 00 00                                                       ...

0042b454  char data_42b454[0xd] = "%s near \'%s\'", 0

0042b461     00 00 00                                                                                       ...

0042b464  char data_42b464[0xa] = "%s:%d: %s", 0

0042b46e                                            00 00                                                                ..

0042b470  char data_42b470[0x19] = "lexical element too long", 0

0042b489                             00 00 00                                                                       ...
0042b48c  data_42b48c:
0042b48c                                      2e 00 00 00                                                              ....

0042b490  char data_42b490[0x1e] = "invalid long string delimiter", 0

0042b4ae                                            00 00                                                                ..

0042b4b0  char data_42b4b0[0x19] = "chunk has too many lines", 0

0042b4c9                             00 00 00 2b 2d 00 00 45 65 00 00                                               ...+-..Ee..

0042b4d4  char data_42b4d4[0x11] = "malformed number", 0

0042b4e5                 00 00 00                                                                               ...

0042b4e8  char data_42b4e8[0x21] = "nesting of [[...]] is deprecated", 0

0042b509                             00 00 00                                                                       ...

0042b50c  char data_42b50c[0x18] = "unfinished long comment", 0
0042b524  char data_42b524[0x17] = "unfinished long string", 0

0042b53b                                                                                   00                                         .

0042b53c  char data_42b53c[0x1a] = "escape sequence too large", 0

0042b556                                                                    00 00                                                ..

0042b558  char data_42b558[0x12] = "unfinished string", 0

0042b56a                                00 00                                                                        ..

0042b56c  char data_42b56c[0x7] = "__call", 0

0042b573                                                           00                                                         .

0042b574  char data_42b574[0x9] = "__concat", 0

0042b57d                                                                                         00 00 00                               ...

0042b580  char data_42b580[0x5] = "__le", 0

0042b585                 00 00 00                                                                               ...

0042b588  char data_42b588[0x5] = "__lt", 0

0042b58d                                         00 00 00                                                               ...

0042b590  char data_42b590[0x6] = "__len", 0

0042b596                                                                    00 00                                                ..

0042b598  char data_42b598[0x6] = "__unm", 0

0042b59e                                                                                            00 00                                ..

0042b5a0  char data_42b5a0[0x6] = "__pow", 0

0042b5a6                    00 00                                                                                ..

0042b5a8  char data_42b5a8[0x6] = "__mod", 0

0042b5ae                                            00 00                                                                ..

0042b5b0  char data_42b5b0[0x6] = "__div", 0

0042b5b6                                                                    00 00                                                ..

0042b5b8  char data_42b5b8[0x6] = "__mul", 0

0042b5be                                                                                            00 00                                ..

0042b5c0  char data_42b5c0[0x6] = "__sub", 0

0042b5c6                    00 00                                                                                ..

0042b5c8  char data_42b5c8[0x6] = "__add", 0

0042b5ce                                            00 00                                                                ..

0042b5d0  char data_42b5d0[0x5] = "__eq", 0

0042b5d5                                                                 00 00 00                                               ...

0042b5d8  char data_42b5d8[0x7] = "__mode", 0

0042b5df                                                                                               00                                 .

0042b5e0  char data_42b5e0[0x5] = "__gc", 0

0042b5e5                 00 00 00                                                                               ...

0042b5e8  char data_42b5e8[0xb] = "__newindex", 0

0042b5f3                                                           00                                                         .

0042b5f4  char data_42b5f4[0x8] = "__index", 0
0042b5fc  char data_42b5fc[0x6] = "upval", 0

0042b602        00 00                                                                                        ..

0042b604  char data_42b604[0x6] = "proto", 0

0042b60a                                00 00                                                                        ..

0042b60c  char data_42b60c[0x7] = "thread", 0

0042b613                                                           00                                                         .

0042b614  char data_42b614[0x7] = "number", 0

0042b61b                                                                                   00                                         .

0042b61c  char data_42b61c[0x9] = "userdata", 0

0042b625                 00 00 00                                                                               ...

0042b628  char data_42b628[0x8] = "boolean", 0
0042b630  char data_42b630[0x16] = "invalid key to \'next\'", 0

0042b646                    00 00                                                                                ..

0042b648  char data_42b648[0xf] = "table overflow", 0

0042b657                                                                       00                                                 .

0042b658  char data_42b658[0x13] = "table index is nil", 0

0042b66b                                   00                                                                         .
0042b66c  data_42b66c:
0042b66c                                      25 00 00 00 25 70 00 00                                                  %...%p..

0042b674  char data_42b674[0x7] = "(null)", 0

0042b67b                                                                                   00                                         .
0042b67c  data_42b67c:
0042b67c                                                                                      22 5d 00 00                              "]..

0042b680  char data_42b680[0xa] = "[string \"", 0

0042b68a                                00 00 0a 0d 00 00                                                            ......

0042b690  char data_42b690[0x6] = "%.14g", 0

0042b696                                                                    00 00                                                ..

0042b698  char data_42b698[0x11] = "loop in gettable", 0

0042b6a9                             00 00 00                                                                       ...

0042b6ac  char data_42b6ac[0x6] = "index", 0

0042b6b2                                                        00 00                                                        ..

0042b6b4  char data_42b6b4[0x11] = "loop in settable", 0

0042b6c5                 00 00 00                                                                               ...

0042b6c8  char data_42b6c8[0x17] = "string length overflow", 0

0042b6df                                                                                               00                                 .

0042b6e0  char data_42b6e0[0x1c] = "\'for\' step must be a number", 0
0042b6fc  char data_42b6fc[0x1d] = "\'for\' limit must be a number", 0

0042b719                                                                             00 00 00                                       ...

0042b71c  char data_42b71c[0x25] = "\'for\' initial value must be a number", 0

0042b741     00 00 00                                                                                       ...

0042b744  char data_42b744[0xe] = "get length of", 0

0042b752                                                        00 00                                                        ..

0042b754  char data_42b754[0xd] = "(*temporary)", 0

0042b761     00 00 00                                                                                       ...
0042b764  data_42b764:
0042b764              4c 75 61 00                                                                              Lua.

0042b768  char data_42b768[0x5] = "main", 0

0042b76d                                         00 00 00                                                               ...
0042b770  data_42b770:
0042b770                                                  43 00 00 00                                                      C...

0042b774  char data_42b774[0x5] = "=[C]", 0

0042b779                                                                             00 00 00                                       ...

0042b77c  char data_42b77c[0x5] = "tail", 0

0042b781     00 00 00                                                                                       ...

0042b784  char data_42b784[0xd] = "=(tail call)", 0

0042b791                                                     00 00 00                                                       ...

0042b794  char data_42b794[0x8] = "upvalue", 0
0042b79c  char data_42b79c[0x6] = "field", 0

0042b7a2        00 00                                                                                        ..

0042b7a4  char data_42b7a4[0x7] = "global", 0

0042b7ab                                   00                                                                         .

0042b7ac  char data_42b7ac[0x19] = "attempt to %s a %s value", 0

0042b7c5                 00 00 00                                                                               ...

0042b7c8  char data_42b7c8[0x23] = "attempt to %s %s \'%s\' (a %s value)", 0

0042b7eb                                   00                                                                         .

0042b7ec  char data_42b7ec[0xc] = "concatenate", 0
0042b7f8  char data_42b7f8[0x16] = "perform arithmetic on", 0

0042b80e                                            00 00                                                                ..

0042b810  char data_42b810[0x1e] = "attempt to compare %s with %s", 0

0042b82e                                            00 00                                                                ..

0042b830  char data_42b830[0x21] = "attempt to compare two %s values", 0

0042b851                                                     00 00 00                                                       ...

0042b854  char data_42b854[0xa] = "traceback", 0

0042b85e                                                                                            00 00                                ..

0042b860  char data_42b860[0xb] = "setupvalue", 0

0042b86b                                   00                                                                         .

0042b86c  char data_42b86c[0xd] = "setmetatable", 0

0042b879                                                                             00 00 00                                       ...

0042b87c  char data_42b87c[0x9] = "setlocal", 0

0042b885                 00 00 00                                                                               ...

0042b888  char data_42b888[0x8] = "sethook", 0
0042b890  char data_42b890[0x8] = "setfenv", 0
0042b898  char data_42b898[0xb] = "getupvalue", 0

0042b8a3           00                                                                                         .

0042b8a4  char data_42b8a4[0xd] = "getmetatable", 0

0042b8b1                                                     00 00 00                                                       ...

0042b8b4  char data_42b8b4[0xc] = "getregistry", 0
0042b8c0  char data_42b8c0[0x9] = "getlocal", 0

0042b8c9                             00 00 00                                                                       ...

0042b8cc  char data_42b8cc[0x8] = "getinfo", 0
0042b8d4  char data_42b8d4[0x8] = "gethook", 0
0042b8dc  char data_42b8dc[0x8] = "getfenv", 0
0042b8e4  char data_42b8e4[0xc] = "tail return", 0
0042b8f0  char data_42b8f0[0x6] = "count", 0

0042b8f6                                                                    00 00                                                ..

0042b8f8  char data_42b8f8[0x5] = "line", 0

0042b8fd                                                                                         00 00 00                               ...

0042b900  char data_42b900[0x16] = "nil or table expected", 0

0042b916                                                                    00 00                                                ..

0042b918  char data_42b918[0x34] = "\'setfenv\' cannot change environment of given object", 0
0042b94c  char data_42b94c[0x1b] = "function or level expected", 0

0042b967                       00                                                                                 .

0042b968  char data_42b968[0x5] = "func", 0

0042b96d                                         00 00 00                                                               ...

0042b970  char data_42b970[0xc] = "activelines", 0
0042b97c  char data_42b97c[0x9] = "namewhat", 0

0042b985                 00 00 00                                                                               ...

0042b988  char data_42b988[0x5] = "name", 0

0042b98d                                         00 00 00                                                               ...

0042b990  char data_42b990[0x5] = "nups", 0

0042b995                                                                 00 00 00                                               ...

0042b998  char data_42b998[0xc] = "currentline", 0
0042b9a4  char data_42b9a4[0x5] = "what", 0

0042b9a9                             00 00 00                                                                       ...

0042b9ac  char data_42b9ac[0x10] = "lastlinedefined", 0
0042b9bc  char data_42b9bc[0xc] = "linedefined", 0
0042b9c8  char data_42b9c8[0xa] = "short_src", 0

0042b9d2                                                        00 00                                                        ..

0042b9d4  char data_42b9d4[0x7] = "source", 0

0042b9db                                                                                   00                                         .

0042b9dc  char data_42b9dc[0xf] = "invalid option", 0

0042b9eb                                   00 3e 25 73 00                                                             .>%s.

0042b9f0  char data_42b9f0[0x6] = "flnSu", 0

0042b9f6                                                                    00 00                                                ..

0042b9f8  char data_42b9f8[0x13] = "level out of range", 0

0042ba0b                                   00                                                                         .

0042ba0c  char data_42ba0c[0xe] = "external hook", 0

0042ba1a                                                                                00 00                                        ..

0042ba1c  char data_42ba1c[0x11] = "=(debug command)", 0

0042ba2d                                         00 00 00                                                               ...

0042ba30  char data_42ba30[0x6] = "cont\n", 0

0042ba36                                                                    00 00                                                ..

0042ba38  char data_42ba38[0xc] = "lua_debug> ", 0

0042ba44              20 3f 00 00                                                                               ?..

0042ba48  char data_42ba48[0x15] = " in function <%s:%d>", 0

0042ba5d                                                                                         00 00 00                               ...

0042ba60  char data_42ba60[0xf] = " in main chunk", 0

0042ba6f                                               00                                                                 .

0042ba70  char data_42ba70[0x12] = " in function \'%s\'", 0

0042ba82        00 00 25 64 3a 00 25 73 3a 00 53 6e 6c 00 0a 09 00 00                                        ..%d:.%s:.Snl.....

0042ba94  char data_42ba94[0x6] = "\n\t...", 0

0042ba9a                                                                                00 00                                        ..

0042ba9c  char data_42ba9c[0x11] = "stack traceback:", 0

0042baad                                         00 00 00 74 61 6e 00                                                   ...tan.

0042bab4  char data_42bab4[0x5] = "tanh", 0

0042bab9                                                                             00 00 00                                       ...

0042babc  char data_42babc[0x5] = "sqrt", 0

0042bac1     00 00 00 73 69 6e 00                                                                           ...sin.

0042bac8  char data_42bac8[0x5] = "sinh", 0

0042bacd                                         00 00 00                                                               ...

0042bad0  char data_42bad0[0xb] = "randomseed", 0

0042badb                                                                                   00                                         .

0042badc  char data_42badc[0x7] = "random", 0

0042bae3           00 72 61 64 00 70 6f 77 00                                                                 .rad.pow.

0042baec  char data_42baec[0x5] = "modf", 0

0042baf1                                                     00 00 00 6d 69 6e 00 6d 61 78 00 6c 6f 67 00                   ...min.max.log.

0042bb00  char data_42bb00[0x6] = "log10", 0

0042bb06                    00 00                                                                                ..

0042bb08  char data_42bb08[0x6] = "ldexp", 0

0042bb0e                                            00 00                                                                ..

0042bb10  char data_42bb10[0x6] = "frexp", 0

0042bb16                                                                    00 00                                                ..

0042bb18  char data_42bb18[0x5] = "fmod", 0

0042bb1d                                                                                         00 00 00                               ...

0042bb20  char data_42bb20[0x6] = "floor", 0

0042bb26                    00 00 65 78 70 00 64 65 67 00 63 6f 73 00                                            ..exp.deg.cos.

0042bb34  char data_42bb34[0x5] = "cosh", 0

0042bb39                                                                             00 00 00                                       ...

0042bb3c  char data_42bb3c[0x5] = "ceil", 0

0042bb41     00 00 00                                                                                       ...

0042bb44  char data_42bb44[0x5] = "atan", 0

0042bb49                             00 00 00                                                                       ...

0042bb4c  char data_42bb4c[0x6] = "atan2", 0

0042bb52                                                        00 00                                                        ..

0042bb54  char data_42bb54[0x5] = "asin", 0

0042bb59                                                                             00 00 00                                       ...

0042bb5c  char data_42bb5c[0x5] = "acos", 0

0042bb61     00 00 00 61 62 73 00                                                                           ...abs.

0042bb68  char data_42bb68[0x12] = "interval is empty", 0

0042bb7a                                                                                00 00                                        ..

0042bb7c  char data_42bb7c[0x1a] = "wrong number of arguments", 0

0042bb96                                                                    00 00 6d 6f 64 00                                    ..mod.

0042bb9c  char data_42bb9c[0x5] = "huge", 0

0042bba1     00 00 00 70 69 00 00                                                                           ...pi..

0042bba8  char data_42bba8[0x6] = "upper", 0

0042bbae                                            00 00 73 75 62 00                                                    ..sub.

0042bbb4  char data_42bbb4[0x8] = "reverse", 0

0042bbbc                                                                                      72 65 70 00                              rep.

0042bbc0  char data_42bbc0[0x6] = "match", 0

0042bbc6                    00 00                                                                                ..

0042bbc8  char data_42bbc8[0x6] = "lower", 0

0042bbce                                            00 00 6c 65 6e 00                                                    ..len.

0042bbd4  char data_42bbd4[0x5] = "gsub", 0

0042bbd9                                                                             00 00 00                                       ...

0042bbdc  char data_42bbdc[0x7] = "gmatch", 0

0042bbe3           00                                                                                         .

0042bbe4  char data_42bbe4[0x6] = "gfind", 0

0042bbea                                00 00                                                                        ..

0042bbec  char data_42bbec[0x7] = "format", 0

0042bbf3                                                           00                                                         .

0042bbf4  char data_42bbf4[0x5] = "find", 0

0042bbf9                                                                             00 00 00                                       ...

0042bbfc  char data_42bbfc[0x5] = "dump", 0

0042bc01     00 00 00                                                                                       ...

0042bc04  char data_42bc04[0x5] = "char", 0

0042bc09                             00 00 00                                                                       ...

0042bc0c  char data_42bc0c[0x5] = "byte", 0

0042bc11                                                     00 00 00                                                       ...

0042bc14  char data_42bc14[0x16] = "string slice too long", 0

0042bc2a                                00 00                                                                        ..

0042bc2c  char data_42bc2c[0xe] = "invalid value", 0

0042bc3a                                                                                00 00                                        ..

0042bc3c  char data_42bc3c[0x1e] = "unable to dump given function", 0

0042bc5a                                                                                00 00                                        ..

0042bc5c  char data_42bc5c[0xb] = "^$*+?.([%-", 0

0042bc67                       00                                                                                 .

0042bc68  char data_42bc68[0x23] = "missing \'[\' after \'%%f\' in pattern", 0

0042bc8b                                   00                                                                         .

0042bc8c  char data_42bc8c[0x23] = "malformed pattern (ends with \'%%\')", 0

0042bcaf                                               00                                                                 .

0042bcb0  char data_42bcb0[0x20] = "malformed pattern (missing \']\')", 0
0042bcd0  char data_42bcd0[0x13] = "unbalanced pattern", 0

0042bce3           00                                                                                         .

0042bce4  char data_42bce4[0x12] = "too many captures", 0

0042bcf6                                                                    00 00                                                ..

0042bcf8  char data_42bcf8[0x18] = "invalid pattern capture", 0
0042bd10  char data_42bd10[0x16] = "invalid capture index", 0

0042bd26                    00 00                                                                                ..

0042bd28  char data_42bd28[0x13] = "unfinished capture", 0

0042bd3b                                                                                   00                                         .

0042bd3c  char data_42bd3c[0x2e] = "\'string.gfind\' was renamed to \'string.gmatch\'", 0

0042bd6a                                00 00                                                                        ..

0042bd6c  char data_42bd6c[0x1f] = "string/function/table expected", 0

0042bd8b                                   00                                                                         .

0042bd8c  char data_42bd8c[0x21] = "invalid replacement value (a %s)", 0

0042bdad                                         00 00 00                                                               ...

0042bdb0  char data_42bdb0[0x1b] = "invalid option to \'format\'", 0

0042bdcb                                   00                                                                         .

0042bdcc  char data_42bdcc[0x5] = "\\000", 0

0042bdd1                                                     00 00 00                                                       ...

0042bdd4  char data_42bdd4[0x2d] = "invalid format (width or precision too long)", 0

0042be01     00 00 00                                                                                       ...

0042be04  char data_42be04[0x20] = "invalid format (repeated flags)", 0
0042be24  char data_42be24[0x6] = "-+ #0", 0

0042be2a                                00 00                                                                        ..

0042be2c  int16_t data_42be2c = 0x6c

0042be2e                                            00 00                                                                ..

0042be30  char data_42be30[0x8] = "tmpname", 0
0042be38  char data_42be38[0xa] = "setlocale", 0

0042be42        00 00                                                                                        ..

0042be44  char data_42be44[0x7] = "rename", 0

0042be4b                                   00                                                                         .

0042be4c  char data_42be4c[0x7] = "remove", 0

0042be53                                                           00                                                         .

0042be54  char data_42be54[0x7] = "getenv", 0

0042be5b                                                                                   00                                         .

0042be5c  char data_42be5c[0x5] = "exit", 0

0042be61     00 00 00                                                                                       ...

0042be64  char data_42be64[0x8] = "execute", 0
0042be6c  char data_42be6c[0x9] = "difftime", 0

0042be75                                                                 00 00 00                                               ...

0042be78  char data_42be78[0x5] = "date", 0

0042be7d                                                                                         00 00 00                               ...

0042be80  char data_42be80[0x6] = "clock", 0

0042be86                    00 00                                                                                ..

0042be88  char data_42be88[0x5] = "time", 0

0042be8d                                         00 00 00                                                               ...

0042be90  char data_42be90[0x8] = "numeric", 0
0042be98  char data_42be98[0x9] = "monetary", 0

0042bea1     00 00 00                                                                                       ...

0042bea4  char data_42bea4[0x6] = "ctype", 0

0042beaa                                00 00                                                                        ..

0042beac  char data_42beac[0x8] = "collate", 0

0042beb4                                                              61 6c 6c 00 25 73 00 00                                  all.%s..

0042bebc  char data_42bebc[0x7] = "%s: %s", 0

0042bec3           00                                                                                         .

0042bec4  char data_42bec4[0x25] = "unable to generate a unique filename", 0

0042bee9                             00 00 00                                                                       ...

0042beec  char data_42beec[0x17] = "\'date\' format too long", 0

0042bf03           00                                                                                         .

0042bf04  char data_42bf04[0x6] = "isdst", 0

0042bf0a                                00 00                                                                        ..

0042bf0c  char data_42bf0c[0x5] = "yday", 0

0042bf11                                                     00 00 00                                                       ...

0042bf14  char data_42bf14[0x5] = "wday", 0

0042bf19                                                                             00 00 00                                       ...

0042bf1c  char data_42bf1c[0x5] = "year", 0

0042bf21     00 00 00                                                                                       ...

0042bf24  char data_42bf24[0x6] = "month", 0

0042bf2a                                00 00 64 61 79 00                                                            ..day.

0042bf30  char data_42bf30[0x5] = "hour", 0

0042bf35                                                                 00 00 00 73 65 63 00                                   ...sec.
0042bf3c  data_42bf3c:
0042bf3c                                                                                      2a 74 00 00                              *t..

0042bf40  char data_42bf40[0x21] = "field \'%s\' missing in date table", 0

0042bf61     00 00 00                                                                                       ...

0042bf64  char data_42bf64[0x10] = "string expected", 0
0042bf74  char data_42bf74[0xb] = "__tostring", 0

0042bf7f                                                                                               00                                 .

0042bf80  char data_42bf80[0x8] = "setvbuf", 0
0042bf88  char data_42bf88[0x6] = "write", 0

0042bf8e                                            00 00                                                                ..

0042bf90  char data_42bf90[0x5] = "type", 0

0042bf95                                                                 00 00 00                                               ...

0042bf98  char data_42bf98[0x8] = "tmpfile", 0
0042bfa0  char data_42bfa0[0x6] = "popen", 0

0042bfa6                    00 00                                                                                ..

0042bfa8  char data_42bfa8[0x6] = "lines", 0

0042bfae                                            00 00                                                                ..

0042bfb0  char data_42bfb0[0x6] = "flush", 0

0042bfb6                                                                    00 00                                                ..

0042bfb8  char data_42bfb8[0x6] = "close", 0

0042bfbe                                                                                            00 00                                ..

0042bfc0  char data_42bfc0[0x5] = "full", 0

0042bfc5                 00 00 00 6e 6f 00 00 63 75 72 00 73 65 74 00                                           ...no..cur.set.

0042bfd4  char data_42bfd4[0x7] = "output", 0

0042bfdb                                                                                   00                                         .

0042bfdc  char data_42bfdc[0x6] = "input", 0

0042bfe2        00 00                                                                                        ..

0042bfe4  char data_42bfe4[0x5] = "file", 0

0042bfe9                             00 00 00                                                                       ...

0042bfec  char data_42bfec[0xc] = "closed file", 0
0042bff8  char data_42bff8[0x6] = "FILE*", 0

0042bffe                                                                                            00 00                                ..

0042c000  char data_42c000[0x1d] = "attempt to use a closed file", 0

0042c01d                                                                                         00 00 00                               ...

0042c020  char data_42c020[0x8] = "__close", 0
0042c028  char data_42c028[0xa] = "file (%p)", 0

0042c032                                                        00 00                                                        ..

0042c034  char data_42c034[0xe] = "file (closed)", 0

0042c042        00 00 77 00 00 00                                                                            ..w...

0042c048  char data_42c048[0x1b] = "standard %s file is closed", 0

0042c063           00                                                                                         .

0042c064  char data_42c064[0xf] = "invalid format", 0

0042c073                                                           00                                                         .

0042c074  char data_42c074[0x13] = "too many arguments", 0

0042c087                       00 25 6c 66 00                                                                     .%lf.

0042c08c  char data_42c08c[0x17] = "file is already closed", 0

0042c0a3           00                                                                                         .

0042c0a4  char data_42c0a4[0x7] = "stderr", 0

0042c0ab                                   00                                                                         .

0042c0ac  char data_42c0ac[0x7] = "stdout", 0

0042c0b3                                                           00                                                         .

0042c0b4  char data_42c0b4[0x6] = "stdin", 0

0042c0ba                                                                                00 00                                        ..

0042c0bc  char data_42c0bc[0x5] = "sort", 0

0042c0c1     00 00 00                                                                                       ...

0042c0c4  char data_42c0c4[0x5] = "setn", 0

0042c0c9                             00 00 00                                                                       ...

0042c0cc  char data_42c0cc[0x7] = "insert", 0

0042c0d3                                                           00                                                         .

0042c0d4  char data_42c0d4[0x5] = "maxn", 0

0042c0d9                                                                             00 00 00                                       ...

0042c0dc  char data_42c0dc[0x5] = "getn", 0

0042c0e1     00 00 00                                                                                       ...

0042c0e4  char data_42c0e4[0x9] = "foreachi", 0

0042c0ed                                         00 00 00                                                               ...

0042c0f0  char data_42c0f0[0x8] = "foreach", 0
0042c0f8  char data_42c0f8[0x7] = "concat", 0

0042c0ff                                                                                               00                                 .

0042c100  char data_42c100[0x13] = "\'setn\' is obsolete", 0

0042c113                                                           00                                                         .

0042c114  char data_42c114[0x26] = "wrong number of arguments to \'insert\'", 0

0042c13a                                                                                00 00                                        ..

0042c13c  char data_42c13c[0x1b] = "table contains non-strings", 0

0042c157                                                                       00                                                 .

0042c158  char data_42c158[0x23] = "invalid order function for sorting", 0

0042c17b                                                                                   00                                         .

0042c17c  char data_42c17c[0x8] = "require", 0
0042c184  char data_42c184[0x7] = "module", 0

0042c18b                                   00                                                                         .

0042c18c  char data_42c18c[0x7] = "seeall", 0

0042c193                                                           00                                                         .

0042c194  char data_42c194[0x8] = "loadlib", 0
0042c19c  char data_42c19c[0x5] = "init", 0

0042c1a1     00 00 00                                                                                       ...

0042c1a4  char data_42c1a4[0x11] = "system error %d\n", 0

0042c1b5                                                                 00 00 00                                               ...

0042c1b8  char data_42c1b8[0x9] = "_LOADLIB", 0

0042c1c1     00 00 00                                                                                       ...

0042c1c4  char data_42c1c4[0x5] = "%s%s", 0

0042c1c9                             00 00 00                                                                       ...

0042c1cc  char data_42c1cc[0xa] = "LOADLIB: ", 0

0042c1d6                                                                    00 00                                                ..

0042c1d8  char data_42c1d8[0x5] = "path", 0

0042c1dd                                                                                         00 00 00                               ...

0042c1e0  char data_42c1e0[0xf] = "\n\tno file \'%s\'", 0

0042c1ef                                               00                                                                 .

0042c1f0  char data_42c1f0[0x1e] = "\'package.%s\' must be a string", 0

0042c20e                                            00 00                                                                ..
0042c210  data_42c210:
0042c210                                                  5c 00 00 00                                                      \...

0042c214  char data_42c214 = 0x3b

0042c215                                                                 00 00 00                                               ...

0042c218  char data_42c218[0x2e] = "error loading module \'%s\' from file \'%s\':\n"
0042c218      "\t%s", 0

0042c246                    00 00                                                                                ..

0042c248  char data_42c248[0x6] = "cpath", 0

0042c24e                                            00 00                                                                ..

0042c250  char data_42c250[0xb] = "luaopen_%s", 0

0042c25b                                                                                   00                                         .
0042c25c  data_42c25c:
0042c25c                                                                                      5f 00 00 00                              _...

0042c260  char data_42c260 = 0x2d

0042c261     00 00 00                                                                                       ...

0042c264  char data_42c264[0x1e] = "\n\tno module \'%s\' in file \'%s\'", 0

0042c282        00 00                                                                                        ..

0042c284  char data_42c284[0x21] = "\n\tno field package.preload[\'%s\']", 0

0042c2a5                 00 00 00                                                                               ...

0042c2a8  char data_42c2a8[0x22] = "\'package.preload\' must be a table", 0

0042c2ca                                00 00                                                                        ..

0042c2cc  char data_42c2cc[0x8] = "preload", 0
0042c2d4  char data_42c2d4[0x19] = "module \'%s\' not found:%s", 0

0042c2ed                                         00 00 00                                                               ...

0042c2f0  char data_42c2f0[0x22] = "\'package.loaders\' must be a table", 0

0042c312                                                        00 00                                                        ..

0042c314  char data_42c314[0x8] = "loaders", 0
0042c31c  char data_42c31c[0x2b] = "loop or previous error loading module \'%s\'", 0

0042c347                       00                                                                                 .

0042c348  char data_42c348[0x6] = "_NAME", 0

0042c34e                                            00 00 66 00 00 00                                                    ..f...

0042c354  char data_42c354[0x9] = "_PACKAGE", 0

0042c35d                                                                                         00 00 00                               ...
0042c360  5f 4d 00 00                                                                                      _M..

0042c364  char data_42c364[0x7] = "loaded", 0

0042c36b                                   00                                                                         .

0042c36c  char data_42c36c[0x7] = "config", 0

0042c373                                                           00                                                         .

0042c374  char data_42c374[0xa] = "\\\n;\n?\n"
0042c374      "!\n-", 0

0042c37e                                                                                            00 00                                ..

0042c380  char data_42c380[0xa] = "LUA_CPATH", 0

0042c38a                                00 00                                                                        ..

0042c38c  char data_42c38c[0x1e] = ".\\?.dll;!\\?.dll;!\\loadall.dll", 0

0042c3aa                                00 00                                                                        ..

0042c3ac  char data_42c3ac[0x9] = "LUA_PATH", 0

0042c3b5                                                                 00 00 00                                               ...

0042c3b8  char data_42c3b8[0x3a] = ".\\?.lua;!\\lua\\?.lua;!\\lua\\?\\init.lua;!\\?.lua;!\\?\\init.lua", 0

0042c3f2                                                        00 00 01 00 00 00 3b 3b 00 00 3b 01 3b 00                    ......;;..;.;.

0042c400  char data_42c400[0x1d] = "unable to get ModuleFileName", 0

0042c41d                                                                                         00 00 00                               ...
0042c420  21 00 00 00                                                                                      !...

0042c424  char data_42c424[0x6] = "yield", 0

0042c42a                                00 00                                                                        ..

0042c42c  char data_42c42c[0x5] = "wrap", 0

0042c431                                                     00 00 00                                                       ...

0042c434  char data_42c434[0x7] = "status", 0

0042c43b                                                                                   00                                         .

0042c43c  char data_42c43c[0x8] = "running", 0
0042c444  char data_42c444[0x7] = "resume", 0

0042c44b                                   00                                                                         .

0042c44c  char data_42c44c[0x7] = "create", 0

0042c453                                                           00                                                         .

0042c454  char data_42c454[0x7] = "xpcall", 0

0042c45b                                                                                   00                                         .

0042c45c  char data_42c45c[0x7] = "unpack", 0

0042c463           00                                                                                         .

0042c464  char data_42c464[0x9] = "tostring", 0

0042c46d                                         00 00 00                                                               ...

0042c470  char data_42c470[0x9] = "tonumber", 0

0042c479                                                                             00 00 00                                       ...

0042c47c  char data_42c47c[0x7] = "select", 0

0042c483           00                                                                                         .

0042c484  char data_42c484[0x7] = "rawset", 0

0042c48b                                   00                                                                         .

0042c48c  char data_42c48c[0x7] = "rawget", 0

0042c493                                                           00                                                         .

0042c494  char data_42c494[0x9] = "rawequal", 0

0042c49d                                                                                         00 00 00                               ...

0042c4a0  char data_42c4a0[0x6] = "print", 0

0042c4a6                    00 00                                                                                ..

0042c4a8  char data_42c4a8[0x6] = "pcall", 0

0042c4ae                                            00 00                                                                ..

0042c4b0  char data_42c4b0[0x5] = "next", 0

0042c4b5                                                                 00 00 00                                               ...

0042c4b8  char data_42c4b8[0xb] = "loadstring", 0

0042c4c3           00                                                                                         .

0042c4c4  char data_42c4c4[0x5] = "load", 0

0042c4c9                             00 00 00                                                                       ...

0042c4cc  char data_42c4cc[0x9] = "loadfile", 0

0042c4d5                                                                 00 00 00                                               ...

0042c4d8  char data_42c4d8[0x7] = "gcinfo", 0

0042c4df                                                                                               00                                 .

0042c4e0  char data_42c4e0[0x6] = "error", 0

0042c4e6                    00 00                                                                                ..

0042c4e8  char data_42c4e8[0x7] = "dofile", 0

0042c4ef                                               00                                                                 .

0042c4f0  char data_42c4f0[0xf] = "collectgarbage", 0

0042c4ff                                                                                               00                                 .

0042c500  char data_42c500[0x7] = "assert", 0

0042c507                       00                                                                                 .

0042c508  char data_42c508[0xb] = "setstepmul", 0

0042c513                                                           00                                                         .

0042c514  char data_42c514[0x9] = "setpause", 0

0042c51d                                                                                         00 00 00                               ...

0042c520  char data_42c520[0x5] = "step", 0

0042c525                 00 00 00                                                                               ...

0042c528  char data_42c528[0x8] = "collect", 0
0042c530  char data_42c530[0x8] = "restart", 0
0042c538  char data_42c538[0x5] = "stop", 0

0042c53d                                                                                         00 00 00                               ...

0042c540  char data_42c540[0x2b] = "\'tostring\' must return a string to \'print\'", 0

0042c56b                                   00 09 00 00 00                                                             .....

0042c570  char data_42c570[0x12] = "base out of range", 0

0042c582        00 00                                                                                        ..

0042c584  char data_42c584[0xc] = "__metatable", 0
0042c590  char data_42c590[0x24] = "cannot change a protected metatable", 0
0042c5b4  char data_42c5b4[0x32] = "no function environment for tail call at level %d", 0

0042c5e6                    00 00                                                                                ..

0042c5e8  char data_42c5e8[0xe] = "invalid level", 0

0042c5f6                                                                    00 00                                                ..

0042c5f8  char data_42c5f8[0x1b] = "level must be non-negative", 0

0042c613                                                           00                                                         .

0042c614  char data_42c614[0x8] = "=(load)", 0
0042c61c  char data_42c61c[0x25] = "reader function must return a string", 0

0042c641     00 00 00                                                                                       ...

0042c644  char data_42c644[0x1a] = "too many nested functions", 0

0042c65e                                                                                            00 00                                ..

0042c660  char data_42c660[0x12] = "assertion failed!", 0

0042c672                                                        00 00                                                        ..

0042c674  char data_42c674[0x18] = "table too big to unpack", 0
0042c68c  char data_42c68c[0x13] = "index out of range", 0

0042c69f                                                                                               00                                 .

0042c6a0  char data_42c6a0[0x7] = "%s: %p", 0

0042c6a7                       00                                                                                 .

0042c6a8  char data_42c6a8[0x13] = "coroutine expected", 0

0042c6bb                                                                                   00                                         .

0042c6bc  char data_42c6bc[0x1b] = "too many results to resume", 0

0042c6d7                                                                       00                                                 .

0042c6d8  char data_42c6d8[0x1d] = "too many arguments to resume", 0

0042c6f5                                                                 00 00 00                                               ...

0042c6f8  char data_42c6f8[0x16] = "Lua function expected", 0

0042c70e                                            00 00                                                                ..

0042c710  char data_42c710[0xa] = "suspended", 0

0042c71a                                                                                00 00                                        ..

0042c71c  char data_42c71c[0x7] = "normal", 0

0042c723           00                                                                                         .

0042c724  char data_42c724[0x5] = "dead", 0

0042c729                             00 00 00                                                                       ...

0042c72c  char data_42c72c[0xa] = "coroutine", 0

0042c736                                                                    00 00                                                ..

0042c738  char data_42c738[0x9] = "newproxy", 0

0042c741     00 00 00 6b 76 00 00                                                                           ...kv..

0042c748  char data_42c748[0x6] = "pairs", 0

0042c74e                                            00 00                                                                ..

0042c750  char data_42c750[0x7] = "ipairs", 0

0042c757                                                                       00                                                 .

0042c758  char data_42c758[0x9] = "_VERSION", 0

0042c761     00 00 00                                                                                       ...

0042c764  char data_42c764[0x8] = "Lua 5.1", 0

0042c76c                                      5f 47 00 00                                                              _G..

0042c770  char data_42c770[0x1a] = "boolean or proxy expected", 0

0042c78a                                00 00                                                                        ..

0042c78c  char data_42c78c[0xe] = "\'%s\' expected", 0

0042c79a                                                                                00 00                                        ..

0042c79c  char data_42c79c[0x21] = "chunk has too many syntax levels", 0

0042c7bd                                                                                         00 00 00                               ...

0042c7c0  char data_42c7c0[0x29] = "\'%s\' expected (to close \'%s\' at line %d)", 0

0042c7e9                             00 00 00                                                                       ...

0042c7ec  char data_42c7ec[0x11] = "no loop to break", 0

0042c7fd                                                                                         00 00 00                               ...

0042c800  char data_42c800[0x2b] = "cannot use \'...\' outside a vararg function", 0

0042c82b                                   00                                                                         .

0042c82c  char data_42c82c[0x17] = "items in a constructor", 0

0042c843           00                                                                                         .

0042c844  char data_42c844[0x28] = "function at line %d has more than %d %s", 0
0042c86c  char data_42c86c[0x22] = "main function has more than %d %s", 0

0042c88e                                            00 00                                                                ..

0042c890  char data_42c890[0x5] = "self", 0

0042c895                                                                 00 00 00                                               ...

0042c898  char data_42c898[0x10] = "local variables", 0
0042c8a8  char data_42c8a8[0x19] = "too many local variables", 0

0042c8c1     00 00 00                                                                                       ...

0042c8c4  char data_42c8c4[0x18] = "constant table overflow", 0
0042c8dc  char data_42c8dc[0x19] = "<name> or \'...\' expected", 0

0042c8f5                                                                 00 00 00                                               ...

0042c8f8  char data_42c8f8[0x31] = "ambiguous syntax (function call x new statement)", 0

0042c929                             00 00 00                                                                       ...

0042c92c  char data_42c92c[0x1c] = "function arguments expected", 0
0042c948  char data_42c948[0x12] = "unexpected symbol", 0

0042c95a                                                                                00 00                                        ..

0042c95c  char data_42c95c[0x9] = "upvalues", 0

0042c965                 00 00 00                                                                               ...

0042c968  char data_42c968[0x15] = "\'=\' or \'in\' expected", 0

0042c97d                                                                                         00 00 00                               ...

0042c980  char data_42c980[0xb] = "(for step)", 0

0042c98b                                   00                                                                         .

0042c98c  char data_42c98c[0xc] = "(for limit)", 0
0042c998  char data_42c998[0xc] = "(for index)", 0
0042c9a4  char data_42c9a4[0xe] = "(for control)", 0

0042c9b2                                                        00 00                                                        ..

0042c9b4  char data_42c9b4[0xc] = "(for state)", 0
0042c9c0  char data_42c9c0[0x10] = "(for generator)", 0
0042c9d0  char data_42c9d0[0xd] = "syntax error", 0

0042c9dd                                                                                         00 00 00                               ...
0042c9e0  3d 3f 00 00                                                                                      =?..

0042c9e4  char data_42c9e4[0xe] = "binary string", 0

0042c9f2                                                        00 00                                                        ..

0042c9f4  char data_42c9f4[0x9] = "bad code", 0

0042c9fd                                                                                         00 00 00                               ...

0042ca00  char data_42ca00[0x1c] = "%s: %s in precompiled chunk", 0
0042ca1c  char data_42ca1c[0xf] = "unexpected end", 0

0042ca2b                                   00                                                                         .

0042ca2c  char data_42ca2c[0xc] = "bad integer", 0
0042ca38  char data_42ca38[0xd] = "bad constant", 0

0042ca45                 00 00 00                                                                               ...

0042ca48  char data_42ca48[0xb] = "bad header", 0

0042ca53                                                           00                                                         .

0042ca54  char data_42ca54[0x7] = "VARARG", 0

0042ca5b                                                                                   00                                         .

0042ca5c  char data_42ca5c[0x8] = "CLOSURE", 0
0042ca64  char data_42ca64[0x6] = "CLOSE", 0

0042ca6a                                00 00                                                                        ..

0042ca6c  char data_42ca6c[0x8] = "SETLIST", 0
0042ca74  char data_42ca74[0x9] = "TFORLOOP", 0

0042ca7d                                                                                         00 00 00                               ...

0042ca80  char data_42ca80[0x8] = "FORPREP", 0
0042ca88  char data_42ca88[0x8] = "FORLOOP", 0
0042ca90  char data_42ca90[0x7] = "RETURN", 0

0042ca97                                                                       00                                                 .

0042ca98  char data_42ca98[0x9] = "TAILCALL", 0

0042caa1     00 00 00                                                                                       ...

0042caa4  char data_42caa4[0x5] = "CALL", 0

0042caa9                             00 00 00                                                                       ...

0042caac  char data_42caac[0x8] = "TESTSET", 0
0042cab4  char data_42cab4[0x5] = "TEST", 0

0042cab9                                                                             00 00 00 4c 45 00 00                           ...LE..
0042cac0  4c 54 00 00 45 51 00 00 4a 4d 50 00                                                              LT..EQ..JMP.

0042cacc  char data_42cacc[0x7] = "CONCAT", 0

0042cad3                                                           00 4c 45 4e 00 4e 4f 54 00 55 4e 4d 00                     .LEN.NOT.UNM.
0042cae0  50 4f 57 00 4d 4f 44 00 44 49 56 00 4d 55 4c 00 53 55 42 00 41 44 44 00                          POW.MOD.DIV.MUL.SUB.ADD.

0042caf8  char data_42caf8[0x5] = "SELF", 0

0042cafd                                                                                         00 00 00                               ...

0042cb00  char data_42cb00[0x9] = "NEWTABLE", 0

0042cb09                             00 00 00                                                                       ...

0042cb0c  char data_42cb0c[0x9] = "SETTABLE", 0

0042cb15                                                                 00 00 00                                               ...

0042cb18  char data_42cb18[0x9] = "SETUPVAL", 0

0042cb21     00 00 00                                                                                       ...

0042cb24  char data_42cb24[0xa] = "SETGLOBAL", 0

0042cb2e                                            00 00                                                                ..

0042cb30  char data_42cb30[0x9] = "GETTABLE", 0

0042cb39                                                                             00 00 00                                       ...

0042cb3c  char data_42cb3c[0xa] = "GETGLOBAL", 0

0042cb46                    00 00                                                                                ..

0042cb48  char data_42cb48[0x9] = "GETUPVAL", 0

0042cb51                                                     00 00 00                                                       ...

0042cb54  char data_42cb54[0x8] = "LOADNIL", 0
0042cb5c  char data_42cb5c[0x9] = "LOADBOOL", 0

0042cb65                 00 00 00                                                                               ...

0042cb68  char data_42cb68[0x6] = "LOADK", 0

0042cb6e                                            00 00                                                                ..

0042cb70  char data_42cb70[0x5] = "MOVE", 0

0042cb75                                                                 00 00 00                                               ...

0042cb78  char data_42cb78[0x1b] = "control structure too long", 0

0042cb93                                                           00                                                         .

0042cb94  char data_42cb94[0x23] = "function or expression too complex", 0

0042cbb7                                                                       00                                                 .

0042cbb8  char data_42cbb8[0x13] = "code size overflow", 0

0042cbcb                                   00 75 98 00 00 73 98 00 00                                                 .u...s...

0042cbd4  void* data_42cbd4 = sub_416db0
0042cbd8  void* data_42cbd8 = sub_416dc7
0042cbdc  void* data_42cbdc = sub_416dc7
0042cbe0  void* data_42cbe0 = sub_417034
0042cbe4  int32_t data_42cbe4 = 0x1

0042cbe8                          00 00 00 00 00 00 00 00                                                          ........
0042cbf0  data_42cbf0:
0042cbf0                                                  40 0f 43 00 00 00 00 00 40 0f 43 00 01 01 00 00                  @.C.....@.C.....
0042cc00  data_42cc00:
0042cc00  00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00 00 00  ................................
0042cc20  01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00 00 00  ................................
0042cc40  02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cc60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cc80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cca0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ccc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cce0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cd00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cd20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cd40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cd60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cd80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cda0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cdc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cde0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ce00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ce20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ce40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ce60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

0042ce70  wchar16 (* data_42ce70)[0x21] = data_42ce7a {u"         (((((                  H"}
0042ce74  wchar16 (* data_42ce74)[0x21] = data_42ce7a {u"         (((((                  H"}

0042ce78                                                                          00 00                                            ..

0042ce7a  wchar16 data_42ce7a[0x21] = "         (((((                  H"

0042cebc                                                                                      10 00 10 00                              ....
0042cec0  10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 84 00 84 00 84 00  ................................
0042cee0  84 00 84 00 84 00 84 00 84 00 84 00 84 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 81 00 81 00  ................................
0042cf00  81 00 81 00 81 00 81 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00  ................................
0042cf20  01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 10 00 10 00 10 00 10 00 10 00 10 00 82 00 82 00  ................................
0042cf40  82 00 82 00 82 00 82 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00  ................................
0042cf60  02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 10 00 10 00 10 00 10 00 20 00 00 00 00 00 00 00  ........................ .......
0042cf80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cfa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cfc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042cfe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ............................

0042d07c  int32_t data_42d07c = 0x1
0042d080  char data_42d080 = 0x2e

0042d081     00 00 00                                                                                       ...

0042d084  int32_t data_42d084 = 0x1

0042d088  data_42d088:
0042d088                          2e 00 00 00 00 00 00 00                                                          ........

0042d090  void* data_42d090 = data_42d088
0042d094  int32_t data_42d094 = 0x430830
0042d098  int32_t data_42d098 = 0x430830

0042d09c                                                                                      30 08 43 00                              0.C.
0042d0a0  30 08 43 00 30 08 43 00 30 08 43 00 30 08 43 00 30 08 43 00 30 08 43 00 7f 7f 7f 7f 7f 7f 7f 7f  0.C.0.C.0.C.0.C.0.C.0.C.........

0042d0c0  void* data_42d0c0 = data_42d090

0042d0c4              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

0042d0d0  int32_t data_42d0d0 = 0x173f

0042d0d4                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

0042d0e0  int64_t data_42d0e0 = 0x3fe0000000000000
0042d0e8  char data_42d0e8[0x4] = "pow", 0

0042d0ec                                      00 00 00 00                                                              ....

0042d0f0  char data_42d0f0[0x5] = "asin", 0

0042d0f5                                                                 00 00 00 00 00 00 00 00 00 00 00                       ...........

0042d100  char data_42d100[0x5] = "acos", 0

0042d105                 00 00 00                                                                               ...

0042d108  int32_t data_42d108 = 0x1b3f

0042d10c                                      00 00 00 00 04 66 6d 6f 64 00 00 00 00 00 00 00 00 02 16 00              .....fmod...........

0042d120  void* data_42d120 = sub_418684
0042d124  void* data_42d124 = __rtindfpop

0042d128                          5f f9 41 00                                                                      _.A.

0042d12c  void* data_42d12c = __rtindfpop

0042d130                                                  24 f9 41 00                                                      $.A.

0042d134  void* data_42d134 = __rtindfpop

0042d138                                                                          5f f9 41 00                                      _.A.

0042d13c  void* data_42d13c = __rtindfpop
0042d140  void* data_42d140 = sub_41f95d
0042d144  void* data_42d144 = sub_41f95d
0042d148  void* data_42d148 = __nan2
0042d14c  void* data_42d14c = sub_41f95d
0042d150  void* data_42d150 = __rtindfpop
0042d154  void* data_42d154 = __rtindfpop

0042d158                                                                          5f f9 41 00                                      _.A.

0042d15c  void* data_42d15c = __rtindfpop
0042d160  int32_t data_42d160 = 0x1f3f
0042d164  int32_t data_42d164 = 0x1
0042d168  int64_t data_42d168 = 0x7ff0000000000000
0042d170  int32_t data_42d170 = 0x42d178

0042d174                                                              00 00 00 00 fc 8b 42 00 f8 8b 42 00                      ......B...B.
0042d180  f4 8b 42 00 f0 8b 42 00 ec 8b 42 00 e8 8b 42 00 e4 8b 42 00                                      ..B...B...B...B...B.

0042d194  char const (* data_42d194)[0x7] = data_428bdc {"Sunday"}
0042d198  char const (* data_42d198)[0x7] = data_428bd4 {"Monday"}
0042d19c  char const (* data_42d19c)[0x8] = data_428bcc {"Tuesday"}
0042d1a0  char const (* data_42d1a0)[0xa] = data_428bc0 {"Wednesday"}
0042d1a4  char const (* data_42d1a4)[0x9] = data_428bb4 {"Thursday"}
0042d1a8  char const (* data_42d1a8)[0x7] = data_428bac {"Friday"}
0042d1ac  char const (* data_42d1ac)[0x9] = data_428ba0 {"Saturday"}

0042d1b0                                                  9c 8b 42 00 98 8b 42 00 94 8b 42 00 90 8b 42 00                  ..B...B...B...B.
0042d1c0  8c 8b 42 00 88 8b 42 00 84 8b 42 00 80 8b 42 00 7c 8b 42 00 78 8b 42 00 74 8b 42 00 70 8b 42 00  ..B...B...B...B.|.B.x.B.t.B.p.B.

0042d1e0  char const (* data_42d1e0)[0x8] = data_428b68 {"January"}
0042d1e4  char const (* data_42d1e4)[0x9] = data_428b5c {"February"}
0042d1e8  char const (* data_42d1e8)[0x6] = data_428b54 {"March"}
0042d1ec  char const (* data_42d1ec)[0x6] = data_428b4c {"April"}

0042d1f0                                                  8c 8b 42 00                                                      ..B.

0042d1f4  char const (* data_42d1f4)[0x5] = data_428b44 {"June"}
0042d1f8  char const (* data_42d1f8)[0x5] = data_428b3c {"July"}
0042d1fc  char const (* data_42d1fc)[0x7] = data_428b34 {"August"}
0042d200  char const (* data_42d200)[0xa] = data_428b28 {"September"}
0042d204  char const (* data_42d204)[0x8] = data_428b20 {"October"}
0042d208  char const (* data_42d208)[0x9] = data_428b14 {"November"}
0042d20c  char const (* data_42d20c)[0x9] = data_428b08 {"December"}

0042d210                                                  04 8b 42 00 00 8b 42 00                                          ..B...B.

0042d218  char const (* data_42d218)[0x7] = data_428af8 {"M/d/yy"}
0042d21c  char const (* data_42d21c)[0x14] = data_428ae4 {"dddd, MMMM dd, yyyy"}
0042d220  char const (* data_42d220)[0x8] = data_428adc {"H:mm:ss"}

0042d224  data_42d224:
0042d224              43 00 00 00 43 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      C...C.......................
0042d240  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d260  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d280  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d2a0  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............
0042d2ac  data_42d2ac:
0042d2ac                                      43 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              C...................
0042d2c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d2e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

0042d330  char const (* data_42d330)[0x7] = data_428c44 {"LC_ALL"}
0042d334  int32_t data_42d334 = 0x0
0042d338  void* data_42d338 = sub_41a390
0042d33c  char const (* data_42d33c)[0xb] = data_428c38 {"LC_COLLATE"}
0042d340  void* data_42d340 = data_42d224
0042d344  void* data_42d344 = sub_41a390
0042d348  char const (* data_42d348)[0x9] = data_428c2c {"LC_CTYPE"}
0042d34c  void* data_42d34c = data_42d224
0042d350  void* data_42d350 = sub_422af4
0042d354  char const (* data_42d354)[0xc] = data_428c20 {"LC_MONETARY"}
0042d358  void* data_42d358 = data_42d224
0042d35c  void* data_42d35c = sub_4228b9
0042d360  char const (* data_42d360)[0xb] = data_428c14 {"LC_NUMERIC"}
0042d364  void* data_42d364 = data_42d224
0042d368  void* data_42d368 = sub_4226ad
0042d36c  char const (* data_42d36c)[0x8] = data_428c0c {"LC_TIME"}
0042d370  void* data_42d370 = data_42d224
0042d374  void* data_42d374 = sub_42213e

0042d378                                                                          00 00 00 00 00 00 00 00                          ........

0042d380  void* data_42d380 = sub_425225
0042d384  void* data_42d384 = sub_425225
0042d388  void* data_42d388 = sub_425225
0042d38c  void* data_42d38c = sub_425225
0042d390  void* data_42d390 = sub_425225
0042d394  void* data_42d394 = sub_425225

0042d398                                                                          00 00 00 00 00 00 00 00                          ........

0042d3a0  char const (* data_42d3a0)[0x9] = data_428fc4 {"No error"}
0042d3a4  char const (* data_42d3a4)[0x18] = data_428fac {"Operation not permitted"}
0042d3a8  char const (* data_42d3a8)[0x1a] = data_428f90 {"No such file or directory"}
0042d3ac  char const (* data_42d3ac)[0x10] = data_428f80 {"No such process"}
0042d3b0  char const (* data_42d3b0)[0x1a] = data_428f64 {"Interrupted function call"}
0042d3b4  char const (* data_42d3b4)[0x13] = data_428f50 {"Input/output error"}
0042d3b8  char const (* data_42d3b8)[0x1a] = data_428f34 {"No such device or address"}
0042d3bc  char const (* data_42d3bc)[0x12] = data_428f20 {"Arg list too long"}
0042d3c0  char const (* data_42d3c0)[0x12] = data_428f0c {"Exec format error"}
0042d3c4  char const (* data_42d3c4)[0x14] = data_428ef8 {"Bad file descriptor"}
0042d3c8  char const (* data_42d3c8)[0x13] = data_428ee4 {"No child processes"}
0042d3cc  char const (* data_42d3cc)[0x21] = data_428ec0 {"Resource temporarily unavailable"}
0042d3d0  char const (* data_42d3d0)[0x11] = data_428eac {"Not enough space"}
0042d3d4  char const (* data_42d3d4)[0x12] = data_428e98 {"Permission denied"}
0042d3d8  char const (* data_42d3d8)[0xc] = data_428e8c {"Bad address"}
0042d3dc  char const (* data_42d3dc)[0xe] = data_428e7c {"Unknown error"}
0042d3e0  char const (* data_42d3e0)[0x10] = data_428e6c {"Resource device"}
0042d3e4  char const (* data_42d3e4)[0xc] = data_428e60 {"File exists"}
0042d3e8  char const (* data_42d3e8)[0xe] = data_428e50 {"Improper link"}
0042d3ec  char const (* data_42d3ec)[0xf] = data_428e40 {"No such device"}
0042d3f0  char const (* data_42d3f0)[0x10] = data_428e30 {"Not a directory"}
0042d3f4  char const (* data_42d3f4)[0xf] = data_428e20 {"Is a directory"}
0042d3f8  char const (* data_42d3f8)[0x11] = data_428e0c {"Invalid argument"}
0042d3fc  char const (* data_42d3fc)[0x1e] = data_428dec {"Too many open files in system"}
0042d400  char const (* data_42d400)[0x14] = data_428dd8 {"Too many open files"}
0042d404  char const (* data_42d404)[0x24] = data_428db4 {"Inappropriate I/O control operation"}
0042d408  char const (* data_42d408)[0xe] = data_428e7c {"Unknown error"}
0042d40c  char const (* data_42d40c)[0xf] = data_428da4 {"File too large"}
0042d410  char const (* data_42d410)[0x18] = data_428d8c {"No space left on device"}
0042d414  char const (* data_42d414)[0xd] = data_428d7c {"Invalid seek"}
0042d418  char const (* data_42d418)[0x16] = data_428d64 {"Read-only file system"}
0042d41c  char const (* data_42d41c)[0xf] = data_428d54 {"Too many links"}
0042d420  char const (* data_42d420)[0xc] = data_428d48 {"Broken pipe"}
0042d424  char const (* data_42d424)[0xd] = data_428d38 {"Domain error"}
0042d428  char const (* data_42d428)[0x11] = data_428d24 {"Result too large"}
0042d42c  char const (* data_42d42c)[0xe] = data_428e7c {"Unknown error"}
0042d430  char const (* data_42d430)[0x1a] = data_428d08 {"Resource deadlock avoided"}
0042d434  char const (* data_42d434)[0xe] = data_428e7c {"Unknown error"}
0042d438  char const (* data_42d438)[0x12] = data_428cf4 {"Filename too long"}
0042d43c  char const (* data_42d43c)[0x13] = data_428ce0 {"No locks available"}
0042d440  char const (* data_42d440)[0x19] = data_428cc4 {"Function not implemented"}
0042d444  char const (* data_42d444)[0x14] = data_428cb0 {"Directory not empty"}
0042d448  char const (* data_42d448)[0x16] = data_428c98 {"Illegal byte sequence"}
0042d44c  char const (* data_42d44c)[0xe] = data_428e7c {"Unknown error"}
0042d450  int32_t data_42d450 = 0x2b

0042d454                                                              00 00 00 00                                              ....

0042d458  int32_t data_42d458 = -0x3ffffffb

0042d45c                                                                                      0b 00 00 00                              ....
0042d460  data_42d460:
0042d460  00 00 00 00 1d 00 00 c0 04 00 00 00 00 00 00 00 96 00 00 c0 04 00 00 00 00 00 00 00 8d 00 00 c0  ................................
0042d480  08 00 00 00 00 00 00 00 8e 00 00 c0 08 00 00 00 00 00 00 00 8f 00 00 c0 08 00 00 00 00 00 00 00  ................................
0042d4a0  90 00 00 c0 08 00 00 00 00 00 00 00 91 00 00 c0 08 00 00 00 00 00 00 00 92 00 00 c0 08 00 00 00  ................................
0042d4c0  00 00 00 00 93 00 00 c0 08 00 00 00 00 00 00 00                                                  ................

0042d4d0  int32_t data_42d4d0 = 0x3
0042d4d4  int32_t data_42d4d4 = 0x7
0042d4d8  int32_t data_42d4d8 = 0xa
0042d4dc  int32_t data_42d4dc = 0x8c

0042d4e0  data_42d4e0:
0042d4e0  ff ff ff ff 00 0a 00 00 10 00 00 00 20 05 93 19                                                  ............ ...

0042d4f0  int32_t data_42d4f0 = 0x0
0042d4f4  int32_t data_42d4f4 = 0x0
0042d4f8  int32_t data_42d4f8 = 0x0

0042d4fc                                                                                      00 00 00 00                              ....
0042d500  data_42d500:
0042d500  02 00 00 00                                                                                      ....

0042d504  char const (* data_42d504)[0x25] = data_429264 {"R6002\r\n- floating point not loaded\r\n"}

0042d508                          08 00 00 00                                                                      ....

0042d50c  char const (* data_42d50c)[0x2a] = data_429238 {"R6008\r\n- not enough space for arguments\r\n"}

0042d510                                                  09 00 00 00                                                      ....

0042d514  char const (* data_42d514)[0x2c] = data_42920c {"R6009\r\n- not enough space for environment\r\n"}

0042d518                                                                          0a 00 00 00                                      ....

0042d51c  char const (* data_42d51c)[0x21] = data_4291e8 {"\r\nabnormal program termination\r\n"}

0042d520  10 00 00 00                                                                                      ....

0042d524  char const (* data_42d524)[0x2c] = data_4291bc {"R6016\r\n- not enough space for thread data\r\n"}

0042d528                          11 00 00 00                                                                      ....

0042d52c  char const (* data_42d52c)[0x2d] = data_42918c {"R6017\r\n- unexpected multithread lock error\r\n"}

0042d530                                                  12 00 00 00                                                      ....

0042d534  char const (* data_42d534)[0x21] = data_429168 {"R6018\r\n- unexpected heap error\r\n"}

0042d538                                                                          13 00 00 00                                      ....

0042d53c  char const (* data_42d53c)[0x29] = data_42913c {"R6019\r\n- unable to open console device\r\n"}

0042d540  18 00 00 00                                                                                      ....

0042d544  char const (* data_42d544)[0x35] = data_429104 {"R6024\r\n- not enough space for _onexit/atexit table\r\n"}

0042d548                          19 00 00 00                                                                      ....

0042d54c  char const (* data_42d54c)[0x26] = data_4290dc {"R6025\r\n- pure virtual function call\r\n"}

0042d550                                                  1a 00 00 00                                                      ....

0042d554  char const (* data_42d554)[0x35] = data_4290a4 {"R6026\r\n- not enough space for stdio initialization\r\n"}

0042d558                                                                          1b 00 00 00                                      ....

0042d55c  char const (* data_42d55c)[0x35] = data_42906c {"R6027\r\n- not enough space for lowio initialization\r\n"}

0042d560  1c 00 00 00                                                                                      ....

0042d564  char const (* data_42d564)[0x25] = data_429044 {"R6028\r\n- unable to initialize heap\r\n"}

0042d568                          78 00 00 00                                                                      x...

0042d56c  char const (* data_42d56c)[0xf] = data_429034 {"DOMAIN error\r\n"}

0042d570                                                  79 00 00 00                                                      y...

0042d574  char const (* data_42d574)[0xd] = data_429024 {"SING error\r\n"}

0042d578                                                                          7a 00 00 00                                      z...

0042d57c  char const (* data_42d57c)[0xe] = data_429014 {"TLOSS error\r\n"}

0042d580  fc 00 00 00 10 90 42 00 ff 00 00 00                                                              ......B.....

0042d58c  char const (* data_42d58c)[0xf] = data_429000 {"runtime error "}
0042d590  void* data_42d590 = data_42d590
0042d594  void* data_42d594 = data_42d590

0042d598                                                                          a8 d5 42 00 a8 d5 42 00                          ..B...B.

0042d5a0  int32_t data_42d5a0 = -0x1

0042d5a4              ff ff ff ff f0 00 00 00 f1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
0042d5c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d5e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d600  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d620  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d640  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d660  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d680  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d6a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d6c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d6e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d700  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d720  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d760  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d7a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d7c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d7e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d800  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d820  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d860  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d880  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d8a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d8c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d8e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d900  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d920  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d940  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d960  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d980  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d9a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d9c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042d9e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042da00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042da20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042da40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042da60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042da80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042daa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dac0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dae0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042db00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042db20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042db40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042db60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042db80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dba0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dbc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dbe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dc00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dc20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dc40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dc60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dc80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dca0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dcc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dce0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dd00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dd20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dd40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dd60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dd80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dda0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ddc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dde0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042de00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042de20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042de40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042de60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042de80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dea0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dec0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dee0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042df00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042df20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042df40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042df60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042df80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dfa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dfc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042dfe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e080  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e0a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e0c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e0e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e100  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e120  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e140  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e160  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e180  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e1a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e1c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e1e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e200  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e220  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e240  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e260  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e280  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e2a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e2c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e2e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e3a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e3c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e3e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e400  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e460  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e4a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e4c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e4e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e5a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e5c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e5e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e600  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e620  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e640  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e660  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e680  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e6a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e6c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e6e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e700  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e720  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e760  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e7a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e7c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e7e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e800  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e820  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e860  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e880  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e8a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e8c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e8e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e900  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e920  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e940  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e960  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e980  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e9a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e9c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042e9e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ea00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ea20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ea40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ea60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ea80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eaa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eac0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eae0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eb00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eb20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eb40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eb60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eb80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eba0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ebc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ebe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ec00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ec20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ec40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ec60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ec80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eca0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ecc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ece0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ed00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ed20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ed40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ed60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ed80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eda0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042edc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ede0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ee00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ee20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ee40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ee60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ee80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eea0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eec0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042eee0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ef00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ef20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ef40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ef60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042ef80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042efa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042efc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042efe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f080  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f0a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f0c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f0e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f100  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f120  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f140  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f160  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f180  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f1a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f1c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f1e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f200  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f220  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f240  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f260  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f280  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f2a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f2c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f2e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f3a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f3c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f3e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f400  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f460  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f4a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f4c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f4e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f5a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

0042f5b0  void* data_42f5b0 = data_42d590
0042f5b4  int32_t data_42f5b4 = 0x1e0
0042f5b8  char (* data_42f5b8)[0x7] = data_42b674 {"(null)"}
0042f5bc  wchar16 const (* data_42f5bc)[0x7] = data_429348 {u"(null)"}
0042f5c0  int32_t data_42f5c0 = 0x4309f0

0042f5c4              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............
0042f5d0  data_42f5d0:
0042f5d0                                                  14 00 00 00                                                      ....
0042f5d4  data_42f5d4:
0042f5d4                                                              28 bb 42 00 1d 00 00 00 e8 ba 42 00                      (.B.......B.
0042f5e0  1a 00 00 00 fc ba 42 00 1b 00 00 00                                                              ......B.....

0042f5ec  char (* data_42f5ec)[0x6] = data_42bb00 {"log10"}

0042f5f0                                                  1f 00 00 00                                                      ....

0042f5f4  char (* data_42f5f4)[0x5] = data_42bac8 {"sinh"}

0042f5f8                                                                          13 00 00 00                                      ....

0042f5fc  char (* data_42f5fc)[0x5] = data_42bb34 {"cosh"}

0042f600  21 00 00 00                                                                                      !...

0042f604  char (* data_42f604)[0x5] = data_42bab4 {"tanh"}

0042f608                          0e 00 00 00                                                                      ....

0042f60c  char (* data_42f60c)[0x5] = data_42bb54 {"asin"}

0042f610                                                  0d 00 00 00                                                      ....

0042f614  char (* data_42f614)[0x5] = data_42bb5c {"acos"}

0042f618                                                                          0f 00 00 00                                      ....

0042f61c  char (* data_42f61c)[0x5] = data_42bb44 {"atan"}

0042f620  10 00 00 00                                                                                      ....

0042f624  char (* data_42f624)[0x6] = data_42bb4c {"atan2"}

0042f628                          05 00 00 00                                                                      ....

0042f62c  char (* data_42f62c)[0x5] = data_42babc {"sqrt"}

0042f630                                                  1e 00 00 00 c4 ba 42 00 12 00 00 00 30 bb 42 00                  ......B.....0.B.
0042f640  20 00 00 00 b0 ba 42 00 0c 00 00 00                                                               .....B.....

0042f64c  char (* data_42f64c)[0x5] = data_42bb3c {"ceil"}

0042f650                                                  0b 00 00 00                                                      ....

0042f654  char (* data_42f654)[0x6] = data_42bb20 {"floor"}

0042f658                                                                          15 00 00 00                                      ....

0042f65c  char const (* data_42f65c)[0x5] = data_4293b4 {"fabs"}

0042f660  1c 00 00 00                                                                                      ....

0042f664  char (* data_42f664)[0x5] = data_42baec {"modf"}

0042f668                          19 00 00 00                                                                      ....

0042f66c  char (* data_42f66c)[0x6] = data_42bb08 {"ldexp"}

0042f670                                                  11 00 00 00                                                      ....

0042f674  char const (* data_42f674)[0x6] = data_4293ac {"_cabs"}

0042f678                                                                          18 00 00 00                                      ....

0042f67c  char const (* data_42f67c)[0x7] = data_4293a4 {"_hypot"}

0042f680  16 00 00 00                                                                                      ....

0042f684  char (* data_42f684)[0x5] = data_42bb18 {"fmod"}

0042f688                          17 00 00 00                                                                      ....

0042f68c  char (* data_42f68c)[0x6] = data_42bb10 {"frexp"}

0042f690                                                  22 00 00 00 a0 93 42 00 23 00 00 00 9c 93 42 00                  ".....B.#.....B.
0042f6a0  24 00 00 00 98 93 42 00                                                                          $.....B.

0042f6a8  int64_t data_42f6a8 = 0x7ff0000000000000
0042f6b0  int64_t data_42f6b0 = -0x8000000000000
0042f6b8  int64_t data_42f6b8 = 0x7fefffffffffffff

0042f6c0  00 00 00 00 00 00 10 00                                                                          ........

0042f6c8  int64_t data_42f6c8 = --0x8000000000000000
0042f6d0  int80_t data_42f6d0 = 
0042f6d0                                                  00 00 00 00 00 00 00 80 10 44                                    .........D

0042f6da                                                                                00 00                                        ..

0042f6dc  int80_t data_42f6dc = 
0042f6dc                                                                                      01 00 00 00                              ....
0042f6e0  00 00 00 80 00 30                                                                                .....0

0042f6e6                    00 00 00 00 00 00 00 00 00 00                                                        ..........

0042f6f0  int80_t data_42f6f0 = 
0042f6f0                                                  00 00 00 00 00 00 00 80 ff 7f                                    ..........
0042f6fa  int80_t data_42f6fa = 
0042f6fa                                                                                00 00 00 00 00 00                            ......
0042f700  00 80 ff ff                                                                                      ....

0042f704              dc a7 d7 b9 85 66 71 b1 0d 40                                                            .....fq..@

0042f70e  int80_t data_42f70e = 
0042f70e                                            00 00 00 00 00 00 ff ff 0d 40                                        .........@

0042f718                                                                          f7 36 43 0c 98 19 f6 95                          .6C.....
0042f720  fd 3f                                                                                            .?

0042f722  int64_t data_42f722 = 0x3fe0000000000000

0042f72a                                00 00 00 00 00 00 00 00 00 00 03 65 78 70 00 00 00 00 00 00 00 00            ...........exp........
0042f740  00 01 14 00                                                                                      ....

0042f744  void* data_42f744 = sub_41f621
0042f748  void* data_42f748 = sub_41f92d
0042f74c  void* data_42f74c = sub_41f932
0042f750  void* data_42f750 = __rtforexpinf

0042f754                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............

0042f760  int80_t data_42f760 = 
0042f760  00 00 00 00 00 00 00 c0 ff ff                                                                    ..........
0042f76a  int80_t data_42f76a = 
0042f76a                                35 c2 68 21 a2 da 0f c9 ff 3f                                                5.h!.....?
0042f774  int64_t data_42f774 = 0x3ff0000000000000

0042f77c                                                                                      01                                       .
0042f77d  data_42f77d:
0042f77d                                                                                         08 04 08                               ...
0042f780  08 08 04 08 08 00 04 0c 08 00 04 0c 08 00 00 00                                                  ................

0042f790  int80_t data_42f790 = 
0042f790                                                  00 90 69 96 99 0c 7e 98 03 40                                    ..i...~..@

0042f79a                                                                                04 73 69 6e 68 00                            .sinh.
0042f7a0  00 00 00 00 00 00 00 01 1f 00 80 fd 41 00 1c f9 41 00 32 f9 41 00 f4 fd 41 00 04 63 6f 73 68 00  ............A...A.2.A...A..cosh.
0042f7c0  00 00 00 00 00 00 00 01 13 00 d2 fd 41 00 2d f9 41 00 32 f9 41 00 01 fe 41 00 04 74 61 6e 68 00  ............A.-.A.2.A...A..tanh.
0042f7e0  00 00 00 00 00 00 00 01 21 00 99 fd 41 00 1c f9 41 00 32 f9 41 00 21 fe 41 00 00 00 00 00 00 00  ........!...A...A.2.A.!.A.......
0042f800  00 01 00 00 04 00 00 07 00 00 0a 00 00 0d 00 00                                                  ................

0042f810  int32_t data_42f810 = 0x3f700000
0042f814  int32_t data_42f814 = 0x3f880000
0042f818  int32_t data_42f818 = 0x5f000000

0042f81c                                                                                      00 01 00 00                              ....
0042f820  04 00 00 07 00 00 0a 00 00 0d 00 00 00 00 00 00 00 00 ee 3f                                      ...................?

0042f834  int64_t data_42f834 = 0x43f0000000000000
0042f83c  int64_t data_42f83c = 0x3bf0000000000000

0042f844              00 00 00 00 00 00 f0 3f                                                                  .......?

0042f84c  int64_t data_42f84c = 0x3fe0000000000000
0042f854  int80_t data_42f854 = 
0042f854                                                              00 00 00 00 00 00 ff ff fe 7f                            ..........

0042f85e  data_42f85e:
0042f85e                                                                                            f4 01                                ..
0042f860  42 00 fa 01 42 00 ff 01 42 00 05 02 42 00 0a 02 42 00 10 02 42 00 16 02 42 00 1c 02 42 00 22 02  B...B...B...B...B...B...B...B.".
0042f880  42 00 3e 02 42 00 43 02 42 00 59 02 42 00 5e 02 42 00 7a 02 42 00 8a 02 42 00 9e 02 42 00 ae 02  B.>.B.C.B.Y.B.^.B.z.B...B...B...
0042f8a0  42 00 ce 02 42 00 d3 02 42 00 ed 02 42 00 f2 02 42 00 12 03 42 00 26 03 42 00 3e 03 42 00 52 03  B...B...B...B...B...B.&.B.>.B.R.
0042f8c0  42 00 72 03 42 00 77 03 42 00 91 03 42 00 96 03 42 00 b6 03 42 00 ca 03 42 00 e2 03 42 00 f6 03  B.r.B.w.B...B...B...B...B...B...
0042f8e0  42 00 16 04 42 00 1b 04 42 00 35 04 42 00 3a 04 42 00 5a 04 42 00 6e 04 42 00 86 04 42 00 9a 04  B...B...B.5.B.:.B.Z.B.n.B...B...
0042f900  42 00 ba 04 42 00 bf 04 42 00 d9 04 42 00 de 04 42 00 fe 04 42 00 12 05 42 00 2a 05 42 00 3e 05  B...B...B...B...B...B...B.*.B.>.
0042f920  42 00 5e 05 42 00 63 05 42 00 7d 05 42 00 82 05 42 00 a2 05 42 00 b6 05 42 00 ce 05 42 00 e2 05  B.^.B.c.B.}.B...B...B...B...B...
0042f940  42 00 02 06 42 00 07 06 42 00 21 06 42 00 26 06 42 00 46 06 42 00 5a 06 42 00 72 06 42 00 00 00  B...B...B.!.B.&.B.F.B.Z.B.r.B...

0042f960  char const (* data_42f960)[0x5] = data_429478 {".cmd"}
0042f964  char const (* data_42f964)[0x5] = data_429470 {".bat"}
0042f968  char const (* data_42f968)[0x5] = data_429468 {".exe"}
0042f96c  char const (* data_42f96c)[0x5] = data_429460 {".com"}

0042f970  data_42f970:
0042f970                                                  01 00 00 00                                                      ....
0042f974  data_42f974:
0042f974                                                              16 00 00 00 02 00 00 00 02 00 00 00                      ............
0042f980  03 00 00 00 02 00 00 00 04 00 00 00 18 00 00 00 05 00 00 00 0d 00 00 00 06 00 00 00 09 00 00 00  ................................
0042f9a0  07 00 00 00 0c 00 00 00 08 00 00 00 0c 00 00 00 09 00 00 00 0c 00 00 00 0a 00 00 00 07 00 00 00  ................................
0042f9c0  0b 00 00 00 08 00 00 00 0c 00 00 00 16 00 00 00 0d 00 00 00 16 00 00 00 0f 00 00 00 02 00 00 00  ................................
0042f9e0  10 00 00 00 0d 00 00 00 11 00 00 00 12 00 00 00 12 00 00 00 02 00 00 00 21 00 00 00 0d 00 00 00  ........................!.......
0042fa00  35 00 00 00 02 00 00 00 41 00 00 00 0d 00 00 00 43 00 00 00 02 00 00 00 50 00 00 00 11 00 00 00  5.......A.......C.......P.......
0042fa20  52 00 00 00 0d 00 00 00 53 00 00 00 0d 00 00 00 57 00 00 00 16 00 00 00 59 00 00 00 0b 00 00 00  R.......S.......W.......Y.......
0042fa40  6c 00 00 00 0d 00 00 00 6d 00 00 00 20 00 00 00 70 00 00 00 1c 00 00 00 72 00 00 00 09 00 00 00  l.......m... ...p.......r.......
0042fa60  06 00 00 00 16 00 00 00 80 00 00 00 0a 00 00 00 81 00 00 00 0a 00 00 00 82 00 00 00 09 00 00 00  ................................
0042fa80  83 00 00 00 16 00 00 00 84 00 00 00 0d 00 00 00 91 00 00 00 29 00 00 00 9e 00 00 00 0d 00 00 00  ....................)...........
0042faa0  a1 00 00 00 02 00 00 00 a4 00 00 00 0b 00 00 00 a7 00 00 00 0d 00 00 00 b7 00 00 00 11 00 00 00  ................................
0042fac0  ce 00 00 00 02 00 00 00 d7 00 00 00 0b 00 00 00 18 07 00 00 0c 00 00 00 01 00 00 00 01 00 00 00  ................................

0042fae0  int32_t data_42fae0 = 0x7080
0042fae4  int32_t data_42fae4 = 0x1
0042fae8  int32_t data_42fae8 = -0xe10

0042faec                                      50 53 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              PST.................
0042fb00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042fb20  00 00 00 00 00 00 00 00 00 00 00 00 50 44 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ............PDT.................
0042fb40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042fb60  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............

0042fb6c  int32_t data_42fb6c = 0x42faec
0042fb70  int32_t data_42fb70 = 0x42fb2c

0042fb74                                                              00 00 00 00                                              ....

0042fb78  int32_t data_42fb78 = -0x1
0042fb7c  int32_t data_42fb7c = 0x0
0042fb80  int32_t data_42fb80 = 0x0

0042fb84              00 00 00 00                                                                              ....

0042fb88  int32_t data_42fb88 = -0x1
0042fb8c  int32_t data_42fb8c = 0x0
0042fb90  int32_t data_42fb90 = 0x0

0042fb94                                                              00 00 00 00 00 00 00 00                                  ........
0042fb9c  data_42fb9c:
0042fb9c                                                                                      00 00 00 00                              ....
0042fba0  data_42fba0:
0042fba0  ff ff ff ff 1e 00 00 00 3b 00 00 00 5a 00 00 00 78 00 00 00 97 00 00 00 b5 00 00 00 d4 00 00 00  ........;...Z...x...............
0042fbc0  f3 00 00 00 11 01 00 00 30 01 00 00 4e 01 00 00                                                  ........0...N...
0042fbd0  data_42fbd0:
0042fbd0                                                  6d 01 00 00                                                      m...
0042fbd4  data_42fbd4:
0042fbd4                                                              ff ff ff ff 1e 00 00 00 3a 00 00 00                      ........:...
0042fbe0  59 00 00 00 77 00 00 00 96 00 00 00 b4 00 00 00 d3 00 00 00 f2 00 00 00 10 01 00 00 2f 01 00 00  Y...w......................./...
0042fc00  4d 01 00 00 6c 01 00 00 00 00 00 00 00 00 00 00 0a 04 00 00                                      M...l...............

0042fc14  char data_42fc14[0x5] = "040a", 0

0042fc19                                                                             00 00 00                                       ...

0042fc1c  char const (* data_42fc1c)[0x1b] = data_429624 {"Spanish - Traditional Sort"}

0042fc20  data_42fc20:
0042fc20  45 53 50 00                                                                                      ESP.

0042fc24  char const (* data_42fc24)[0x6] = data_42961c {"Spain"}

0042fc28  data_42fc28:
0042fc28                          45 53 50 00                                                                      ESP.
0042fc2c  data_42fc2c:
0042fc2c                                      38 35 30 00 00 00 00 00                                                  850.....

0042fc34  char data_42fc34[0x5] = "1252", 0

0042fc39                                                                             00 00 00 0b 04 00 00                           .......
0042fc40  30 34 30 62 00 00 00 00                                                                          040b....

0042fc48  char const (* data_42fc48)[0x8] = data_429614 {"Finnish"}

0042fc4c                                      46 49 4e 00                                                              FIN.

0042fc50  char const (* data_42fc50)[0x8] = data_42960c {"Finland"}

0042fc54                                                              46 49 4e 00 38 35 30 00 00 00 00 00                      FIN.850.....
0042fc60  31 32 35 32 00 00 00 00 0c 04 00 00 30 34 30 63 00 00 00 00                                      1252........040c....

0042fc74  char const (* data_42fc74)[0x7] = data_429604 {"French"}

0042fc78                                                                          46 52 41 00                                      FRA.

0042fc7c  char const (* data_42fc7c)[0x7] = data_4295fc {"France"}

0042fc80  46 52 41 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 0f 04 00 00 30 34 30 66 00 00 00 00  FRA.850.....1252........040f....

0042fca0  char const (* data_42fca0)[0xa] = data_4295f0 {"Icelandic"}

0042fca4              49 53 4c 00                                                                              ISL.

0042fca8  char const (* data_42fca8)[0x8] = data_4295e8 {"Iceland"}

0042fcac                                      49 53 4c 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00              ISL.850.....1252....
0042fcc0  1d 04 00 00 30 34 31 64 00 00 00 00                                                              ....041d....

0042fccc  char const (* data_42fccc)[0x8] = data_4295e0 {"Swedish"}

0042fcd0                                                  53 56 45 00                                                      SVE.

0042fcd4  char const (* data_42fcd4)[0x7] = data_4295d8 {"Sweden"}

0042fcd8                                                                          53 57 45 00 38 35 30 00                          SWE.850.
0042fce0  00 00 00 00 31 32 35 32 00 00 00 00 2d 04 00 00 30 34 32 64 00 00 00 00                          ....1252....-...042d....

0042fcf8  char const (* data_42fcf8)[0x7] = data_4295d0 {"Basque"}

0042fcfc                                                                                      45 55 51 00                              EUQ.

0042fd00  char const (* data_42fd00)[0x6] = data_42961c {"Spain"}

0042fd04              45 53 50 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 0a 08 00 00 30 38 30 61      ESP.850.....1252........080a
0042fd20  00 00 00 00                                                                                      ....

0042fd24  char const (* data_42fd24)[0x8] = data_4295c8 {"Spanish"}

0042fd28                          45 53 4d 00                                                                      ESM.

0042fd2c  char const (* data_42fd2c)[0x7] = data_4295c0 {"Mexico"}

0042fd30                                                  4d 45 58 00 38 35 30 00 00 00 00 00 31 32 35 32                  MEX.850.....1252
0042fd40  00 00 00 00 0c 08 00 00 30 38 30 63 00 00 00 00                                                  ........080c....

0042fd50  char const (* data_42fd50)[0x7] = data_429604 {"French"}

0042fd54                                                              46 52 42 00                                              FRB.

0042fd58  char const (* data_42fd58)[0x8] = data_4295b8 {"Belgium"}

0042fd5c                                                                                      42 45 4c 00                              BEL.
0042fd60  38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 07 0c 00 00 30 63 30 37 00 00 00 00              850.....1252........0c07....

0042fd7c  char const (* data_42fd7c)[0x7] = data_4295b0 {"German"}

0042fd80  44 45 41 00                                                                                      DEA.

0042fd84  char const (* data_42fd84)[0x8] = data_4295a8 {"Austria"}

0042fd88                          41 55 54 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 09 0c 00 00          AUT.850.....1252........
0042fda0  30 63 30 39 00 00 00 00                                                                          0c09....

0042fda8  char const (* data_42fda8)[0x8] = data_4295a0 {"English"}

0042fdac                                      45 4e 41 00                                                              ENA.

0042fdb0  char const (* data_42fdb0)[0xa] = data_429594 {"Australia"}

0042fdb4                                                              41 55 53 00 38 35 30 00 00 00 00 00                      AUS.850.....
0042fdc0  31 32 35 32 00 00 00 00 0a 0c 00 00 30 63 30 61 00 00 00 00                                      1252........0c0a....

0042fdd4  char const (* data_42fdd4)[0x16] = data_42957c {"Spanish - Modern Sort"}

0042fdd8                                                                          45 53 4e 00                                      ESN.

0042fddc  char const (* data_42fddc)[0x6] = data_42961c {"Spain"}

0042fde0  45 53 50 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 0c 0c 00 00 30 63 30 63 00 00 00 00  ESP.850.....1252........0c0c....

0042fe00  char const (* data_42fe00)[0x7] = data_429604 {"French"}

0042fe04              46 52 43 00                                                                              FRC.

0042fe08  char const (* data_42fe08)[0x7] = data_429574 {"Canada"}

0042fe0c                                      43 41 4e 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00              CAN.850.....1252....
0042fe20  0a 10 00 00 31 30 30 61 00 00 00 00                                                              ....100a....

0042fe2c  char const (* data_42fe2c)[0x8] = data_4295c8 {"Spanish"}

0042fe30                                                  45 53 47 00                                                      ESG.

0042fe34  char const (* data_42fe34)[0xa] = data_429568 {"Guatemala"}

0042fe38                                                                          47 54 4d 00 38 35 30 00                          GTM.850.
0042fe40  00 00 00 00 31 32 35 32 00 00 00 00 0c 10 00 00 31 30 30 63 00 00 00 00                          ....1252........100c....

0042fe58  char const (* data_42fe58)[0x7] = data_429604 {"French"}

0042fe5c                                                                                      46 52 53 00                              FRS.

0042fe60  char const (* data_42fe60)[0xc] = data_42955c {"Switzerland"}

0042fe64              43 48 45 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 0a 14 00 00 31 34 30 61      CHE.850.....1252........140a
0042fe80  00 00 00 00                                                                                      ....

0042fe84  char const (* data_42fe84)[0x8] = data_4295c8 {"Spanish"}

0042fe88                          45 53 43 00                                                                      ESC.

0042fe8c  char const (* data_42fe8c)[0xb] = data_429550 {"Costa Rica"}

0042fe90                                                  43 52 49 00 38 35 30 00 00 00 00 00 31 32 35 32                  CRI.850.....1252
0042fea0  00 00 00 00 0c 14 00 00 31 34 30 63 00 00 00 00                                                  ........140c....

0042feb0  char const (* data_42feb0)[0x7] = data_429604 {"French"}

0042feb4                                                              46 52 4c 00                                              FRL.

0042feb8  char const (* data_42feb8)[0xb] = data_429544 {"Luxembourg"}

0042febc                                                                                      4c 55 58 00                              LUX.
0042fec0  38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 0a 18 00 00 31 38 30 61 00 00 00 00              850.....1252........180a....

0042fedc  char const (* data_42fedc)[0x8] = data_4295c8 {"Spanish"}

0042fee0  45 53 41 00                                                                                      ESA.

0042fee4  char const (* data_42fee4)[0x7] = data_42953c {"Panama"}

0042fee8                          50 41 4e 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 09 1c 00 00          PAN.850.....1252........
0042ff00  31 63 30 39 00 00 00 00                                                                          1c09....

0042ff08  char const (* data_42ff08)[0x8] = data_4295a0 {"English"}

0042ff0c                                      45 4e 53 00                                                              ENS.

0042ff10  char const (* data_42ff10)[0xd] = data_42952c {"South Africa"}

0042ff14                                                              5a 41 46 00 34 33 37 00 00 00 00 00                      ZAF.437.....
0042ff20  31 32 35 32 00 00 00 00 0a 1c 00 00 31 63 30 61 00 00 00 00                                      1252........1c0a....

0042ff34  char const (* data_42ff34)[0x8] = data_4295c8 {"Spanish"}

0042ff38                                                                          45 53 44 00                                      ESD.

0042ff3c  char const (* data_42ff3c)[0x13] = data_429518 {"Dominican Republic"}

0042ff40  44 4f 4d 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 0a 20 00 00 32 30 30 61 00 00 00 00  DOM.850.....1252..... ..200a....

0042ff60  char const (* data_42ff60)[0x8] = data_4295c8 {"Spanish"}

0042ff64              45 53 56 00                                                                              ESV.

0042ff68  char const (* data_42ff68)[0xa] = data_42950c {"Venezuela"}

0042ff6c                                      56 45 4e 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00              VEN.850.....1252....
0042ff80  0a 24 00 00 32 34 30 61 00 00 00 00                                                              .$..240a....

0042ff8c  char const (* data_42ff8c)[0x8] = data_4295c8 {"Spanish"}

0042ff90                                                  45 53 4f 00                                                      ESO.

0042ff94  char const (* data_42ff94)[0x9] = data_429500 {"Colombia"}

0042ff98                                                                          43 4f 4c 00 38 35 30 00                          COL.850.
0042ffa0  00 00 00 00 31 32 35 32 00 00 00 00 0a 28 00 00 32 38 30 61 00 00 00 00                          ....1252.....(..280a....

0042ffb8  char const (* data_42ffb8)[0x8] = data_4295c8 {"Spanish"}

0042ffbc                                                                                      45 53 52 00                              ESR.

0042ffc0  char const (* data_42ffc0)[0x5] = data_4294f8 {"Peru"}

0042ffc4              50 45 52 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 0a 2c 00 00 32 63 30 61      PER.850.....1252.....,..2c0a
0042ffe0  00 00 00 00                                                                                      ....

0042ffe4  char const (* data_42ffe4)[0x8] = data_4295c8 {"Spanish"}

0042ffe8                          45 53 53 00                                                                      ESS.

0042ffec  char const (* data_42ffec)[0xa] = data_4294ec {"Argentina"}

0042fff0                                                  41 52 47 00 38 35 30 00 00 00 00 00 31 32 35 32                  ARG.850.....1252
00430000  00 00 00 00 0a 30 00 00 33 30 30 61 00 00 00 00                                                  .....0..300a....

00430010  char const (* data_430010)[0x8] = data_4295c8 {"Spanish"}

00430014                                                              45 53 46 00                                              ESF.

00430018  char const (* data_430018)[0x8] = data_4294e4 {"Ecuador"}

0043001c                                                                                      45 43 55 00                              ECU.
00430020  38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 0a 34 00 00 33 34 30 61 00 00 00 00              850.....1252.....4..340a....

0043003c  char const (* data_43003c)[0x8] = data_4295c8 {"Spanish"}

00430040  45 53 4c 00                                                                                      ESL.

00430044  char const (* data_430044)[0x6] = data_4294dc {"Chile"}

00430048                          43 48 4c 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00 0a 38 00 00          CHL.850.....1252.....8..
00430060  33 38 30 61 00 00 00 00                                                                          380a....

00430068  char const (* data_430068)[0x8] = data_4295c8 {"Spanish"}

0043006c                                      45 53 59 00                                                              ESY.

00430070  char const (* data_430070)[0x8] = data_4294d4 {"Uruguay"}

00430074                                                              55 52 59 00 38 35 30 00 00 00 00 00                      URY.850.....
00430080  31 32 35 32 00 00 00 00 0a 3c 00 00 33 63 30 61 00 00 00 00                                      1252.....<..3c0a....

00430094  char const (* data_430094)[0x8] = data_4295c8 {"Spanish"}

00430098                                                                          45 53 5a 00                                      ESZ.

0043009c  char const (* data_43009c)[0x9] = data_4294c8 {"Paraguay"}

004300a0  50 52 59 00 38 35 30 00 00 00 00 00 31 32 35 32 00 00 00 00                                      PRY.850.....1252....
004300b4  data_4300b4:
004300b4                                                              0c 0c 1a 0c 07 10 36 04 0c 08 2d 04                      ......6...-.
004300c0  03 04 0c 10 10 08 1d 08                                                                          ........

004300c8  char const (* data_4300c8)[0x8] = data_42972c {"america"}

004300cc                                      55 53 41 00                                                              USA.

004300d0  char const (* data_4300d0)[0x8] = data_429724 {"britain"}

004300d4                                                              47 42 52 00                                              GBR.

004300d8  char const (* data_4300d8)[0x6] = data_42971c {"china"}

004300dc                                                                                      43 48 4e 00                              CHN.

004300e0  char const (* data_4300e0)[0x6] = data_429714 {"czech"}

004300e4              43 5a 45 00                                                                              CZE.

004300e8  char const (* data_4300e8)[0x8] = data_42970c {"england"}

004300ec                                      47 42 52 00                                                              GBR.

004300f0  char const (* data_4300f0)[0xe] = data_4296fc {"great britain"}

004300f4                                                              47 42 52 00                                              GBR.

004300f8  char const (* data_4300f8)[0x8] = data_4296f4 {"holland"}

004300fc                                                                                      4e 4c 44 00                              NLD.

00430100  char const (* data_430100)[0xa] = data_4296e8 {"hong-kong"}

00430104              48 4b 47 00                                                                              HKG.

00430108  char const (* data_430108)[0xc] = data_4296dc {"new-zealand"}

0043010c                                      4e 5a 4c 00 d8 96 42 00 4e 5a 4c 00                                      NZL...B.NZL.

00430118  char const (* data_430118)[0x9] = data_4296cc {"pr china"}

0043011c                                                                                      43 48 4e 00                              CHN.

00430120  char const (* data_430120)[0x9] = data_4296c0 {"pr-china"}

00430124              43 48 4e 00                                                                              CHN.

00430128  char const (* data_430128)[0xc] = data_4296b4 {"puerto-rico"}

0043012c                                      50 52 49 00                                                              PRI.

00430130  char const (* data_430130)[0x7] = data_4296ac {"slovak"}

00430134                                                              53 56 4b 00                                              SVK.

00430138  char const (* data_430138)[0xd] = data_42969c {"south africa"}

0043013c                                                                                      5a 41 46 00                              ZAF.

00430140  char const (* data_430140)[0xc] = data_429690 {"south korea"}

00430144              4b 4f 52 00                                                                              KOR.

00430148  char const (* data_430148)[0xd] = data_429680 {"south-africa"}

0043014c                                      5a 41 46 00                                                              ZAF.

00430150  char const (* data_430150)[0xc] = data_429674 {"south-korea"}

00430154                                                              4b 4f 52 00                                              KOR.

00430158  char const (* data_430158)[0x12] = data_429660 {"trinidad & tobago"}

0043015c                                                                                      54 54 4f 00                              TTO.
00430160  3c 97 42 00 47 42 52 00                                                                          <.B.GBR.

00430168  char const (* data_430168)[0xf] = data_429650 {"united-kingdom"}

0043016c                                      47 42 52 00                                                              GBR.

00430170  char const (* data_430170)[0xe] = data_429640 {"united-states"}

00430174                                                              55 53 41 00 38 97 42 00 55 53 41 00                      USA.8.B.USA.

00430180  char const (* data_430180)[0x9] = data_429b3c {"american"}

00430184              45 4e 55 00                                                                              ENU.

00430188  char const (* data_430188)[0x11] = data_429b28 {"american english"}

0043018c                                      45 4e 55 00                                                              ENU.

00430190  char const (* data_430190)[0x11] = data_429b14 {"american-english"}

00430194                                                              45 4e 55 00                                              ENU.

00430198  char const (* data_430198)[0xb] = data_429b08 {"australian"}

0043019c                                                                                      45 4e 41 00                              ENA.

004301a0  char const (* data_4301a0)[0x8] = data_429b00 {"belgian"}

004301a4              4e 4c 42 00                                                                              NLB.

004301a8  char const (* data_4301a8)[0x9] = data_429af4 {"canadian"}

004301ac                                      45 4e 43 00 f0 9a 42 00 5a 48 48 00 ec 9a 42 00 5a 48 49 00              ENC...B.ZHH...B.ZHI.

004301c0  char const (* data_4301c0)[0x8] = data_429ae4 {"chinese"}

004301c4              43 48 53 00                                                                              CHS.

004301c8  char const (* data_4301c8)[0x11] = data_429ad0 {"chinese-hongkong"}

004301cc                                      5a 48 48 00                                                              ZHH.

004301d0  char const (* data_4301d0)[0x13] = data_429abc {"chinese-simplified"}

004301d4                                                              43 48 53 00                                              CHS.

004301d8  char const (* data_4301d8)[0x12] = data_429aa8 {"chinese-singapore"}

004301dc                                                                                      5a 48 49 00                              ZHI.

004301e0  char const (* data_4301e0)[0x14] = data_429a94 {"chinese-traditional"}

004301e4              43 48 54 00                                                                              CHT.

004301e8  char const (* data_4301e8)[0xe] = data_429a84 {"dutch-belgian"}

004301ec                                      4e 4c 42 00                                                              NLB.

004301f0  char const (* data_4301f0)[0x11] = data_429a70 {"english-american"}

004301f4                                                              45 4e 55 00                                              ENU.

004301f8  char const (* data_4301f8)[0xc] = data_429a64 {"english-aus"}

004301fc                                                                                      45 4e 41 00                              ENA.

00430200  char const (* data_430200)[0xf] = data_429a54 {"english-belize"}

00430204              45 4e 4c 00                                                                              ENL.

00430208  char const (* data_430208)[0xc] = data_429a48 {"english-can"}

0043020c                                      45 4e 43 00                                                              ENC.

00430210  char const (* data_430210)[0x12] = data_429a34 {"english-caribbean"}

00430214                                                              45 4e 42 00                                              ENB.

00430218  char const (* data_430218)[0xc] = data_429a28 {"english-ire"}

0043021c                                                                                      45 4e 49 00                              ENI.

00430220  char const (* data_430220)[0x10] = data_429a18 {"english-jamaica"}

00430224              45 4e 4a 00                                                                              ENJ.

00430228  char const (* data_430228)[0xb] = data_429a0c {"english-nz"}

0043022c                                      45 4e 5a 00                                                              ENZ.

00430230  char const (* data_430230)[0x15] = data_4299f4 {"english-south africa"}

00430234                                                              45 4e 53 00                                              ENS.

00430238  char const (* data_430238)[0x1a] = data_4299d8 {"english-trinidad y tobago"}

0043023c                                                                                      45 4e 54 00                              ENT.

00430240  char const (* data_430240)[0xb] = data_4299cc {"english-uk"}

00430244              45 4e 47 00                                                                              ENG.

00430248  char const (* data_430248)[0xb] = data_4299c0 {"english-us"}

0043024c                                      45 4e 55 00                                                              ENU.

00430250  char const (* data_430250)[0xc] = data_4299b4 {"english-usa"}

00430254                                                              45 4e 55 00                                              ENU.

00430258  char const (* data_430258)[0xf] = data_4299a4 {"french-belgian"}

0043025c                                                                                      46 52 42 00                              FRB.

00430260  char const (* data_430260)[0x10] = data_429994 {"french-canadian"}

00430264              46 52 43 00                                                                              FRC.

00430268  char const (* data_430268)[0x12] = data_429980 {"french-luxembourg"}

0043026c                                      46 52 4c 00                                                              FRL.

00430270  char const (* data_430270)[0xd] = data_429970 {"french-swiss"}

00430274                                                              46 52 53 00                                              FRS.

00430278  char const (* data_430278)[0x10] = data_429960 {"german-austrian"}

0043027c                                                                                      44 45 41 00                              DEA.

00430280  char const (* data_430280)[0x14] = data_42994c {"german-lichtenstein"}

00430284              44 45 43 00                                                                              DEC.

00430288  char const (* data_430288)[0x12] = data_429938 {"german-luxembourg"}

0043028c                                      44 45 4c 00                                                              DEL.

00430290  char const (* data_430290)[0xd] = data_429928 {"german-swiss"}

00430294                                                              44 45 53 00                                              DES.

00430298  char const (* data_430298)[0xe] = data_429918 {"irish-english"}

0043029c                                                                                      45 4e 49 00                              ENI.

004302a0  char const (* data_4302a0)[0xe] = data_429908 {"italian-swiss"}

004302a4              49 54 53 00                                                                              ITS.

004302a8  char const (* data_4302a8)[0xa] = data_4298fc {"norwegian"}

004302ac                                      4e 4f 52 00                                                              NOR.

004302b0  char const (* data_4302b0)[0x11] = data_4298e8 {"norwegian-bokmal"}

004302b4                                                              4e 4f 52 00                                              NOR.

004302b8  char const (* data_4302b8)[0x12] = data_4298d4 {"norwegian-nynorsk"}

004302bc                                                                                      4e 4f 4e 00                              NON.

004302c0  char const (* data_4302c0)[0x15] = data_4298bc {"portuguese-brazilian"}

004302c4              50 54 42 00                                                                              PTB.

004302c8  char const (* data_4302c8)[0x12] = data_4298a8 {"spanish-argentina"}

004302cc                                      45 53 53 00                                                              ESS.

004302d0  char const (* data_4302d0)[0x10] = data_429898 {"spanish-bolivia"}

004302d4                                                              45 53 42 00                                              ESB.

004302d8  char const (* data_4302d8)[0xe] = data_429888 {"spanish-chile"}

004302dc                                                                                      45 53 4c 00                              ESL.

004302e0  char const (* data_4302e0)[0x11] = data_429874 {"spanish-colombia"}

004302e4              45 53 4f 00                                                                              ESO.

004302e8  char const (* data_4302e8)[0x13] = data_429860 {"spanish-costa rica"}

004302ec                                      45 53 43 00                                                              ESC.

004302f0  char const (* data_4302f0)[0x1b] = data_429844 {"spanish-dominican republic"}

004302f4                                                              45 53 44 00                                              ESD.

004302f8  char const (* data_4302f8)[0x10] = data_429834 {"spanish-ecuador"}

004302fc                                                                                      45 53 46 00                              ESF.

00430300  char const (* data_430300)[0x14] = data_429820 {"spanish-el salvador"}

00430304              45 53 45 00                                                                              ESE.

00430308  char const (* data_430308)[0x12] = data_42980c {"spanish-guatemala"}

0043030c                                      45 53 47 00                                                              ESG.

00430310  char const (* data_430310)[0x11] = data_4297f8 {"spanish-honduras"}

00430314                                                              45 53 48 00                                              ESH.

00430318  char const (* data_430318)[0x10] = data_4297e8 {"spanish-mexican"}

0043031c                                                                                      45 53 4d 00                              ESM.

00430320  char const (* data_430320)[0xf] = data_4297d8 {"spanish-modern"}

00430324              45 53 4e 00                                                                              ESN.

00430328  char const (* data_430328)[0x12] = data_4297c4 {"spanish-nicaragua"}

0043032c                                      45 53 49 00                                                              ESI.

00430330  char const (* data_430330)[0xf] = data_4297b4 {"spanish-panama"}

00430334                                                              45 53 41 00                                              ESA.

00430338  char const (* data_430338)[0x11] = data_4297a0 {"spanish-paraguay"}

0043033c                                                                                      45 53 5a 00                              ESZ.

00430340  char const (* data_430340)[0xd] = data_429790 {"spanish-peru"}

00430344              45 53 52 00                                                                              ESR.

00430348  char const (* data_430348)[0x14] = data_42977c {"spanish-puerto rico"}

0043034c                                      45 53 55 00                                                              ESU.

00430350  char const (* data_430350)[0x10] = data_42976c {"spanish-uruguay"}

00430354                                                              45 53 59 00                                              ESY.

00430358  char const (* data_430358)[0x12] = data_429758 {"spanish-venezuela"}

0043035c                                                                                      45 53 56 00                              ESV.

00430360  char const (* data_430360)[0x10] = data_429748 {"swedish-finland"}

00430364              53 56 46 00                                                                              SVF.

00430368  char const (* data_430368)[0x6] = data_429740 {"swiss"}

0043036c                                      44 45 53 00 3c 97 42 00 45 4e 47 00 38 97 42 00 45 4e 55 00              DES.<.B.ENG.8.B.ENU.
00430380  34 97 42 00 45 4e 55 00 00 00 00 00 00 00 00 00                                                  4.B.ENU.........

00430390  char data_430390[0x6] = " \t-\r]", 0

00430396                                                                    00 00                                                ..
00430398  data_430398:
00430398                                                                          5d 00 00 00 00 00 00 00                          ].......
004303a0  00 04 00 00 01 fc ff ff 35 00 00 00 0b 00 00 00 40 00 00 00 ff 03 00 00 80 00 00 00 81 ff ff ff  ........5.......@...............
004303c0  18 00 00 00 08 00 00 00 20 00 00 00 7f 00 00 00 01 02 04 08 00 00 00 00                          ........ ...............
004303d8  data_4303d8:
004303d8                                                                          a4 03 00 00 60 82 79 82                          ....`.y.
004303e0  21 00 00 00 00 00 00 00 a6 df 00 00 00 00 00 00 a1 a5 00 00 00 00 00 00 81 9f e0 fc 00 00 00 00  !...............................
00430400  40 7e 80 fc 00 00 00 00 a8 03 00 00 c1 a3 da a3 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  @~.............. ...............
00430420  00 00 00 00 00 00 00 00 81 fe 00 00 00 00 00 00 40 fe 00 00 00 00 00 00 b5 03 00 00 c1 a3 da a3  ................@...............
00430440  20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 81 fe 00 00 00 00 00 00   ...............................
00430460  41 fe 00 00 00 00 00 00 b6 03 00 00 cf a2 e4 a2 1a 00 e5 a2 e8 a2 5b 00 00 00 00 00 00 00 00 00  A.....................[.........
00430480  00 00 00 00 00 00 00 00 81 fe 00 00 00 00 00 00 40 7e a1 fe 00 00 00 00 51 05 00 00 51 da 5e da  ................@~......Q...Q.^.
004304a0  20 00 5f da 6a da 32 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 81 d3 d8 de e0 f9 00 00   ._.j.2.........................
004304c0  31 7e 81 fe 00 00 00 00 00 00 00 00 00 00 00 00                                                  1~..............

004304d0  int32_t data_4304d0 = 0x2694

004304d4                                                              02 00 00 00 00 00 00 00 00 00 00 00                      ............
004304e0  00 00 00 00 00 00 00 00 00 a0 02 40 00 00 00 00 00 00 00 00 00 c8 05 40 00 00 00 00 00 00 00 00  ...........@...........@........
00430500  00 fa 08 40 00 00 00 00 00 00 00 00 40 9c 0c 40 00 00 00 00 00 00 00 00 50 c3 0f 40 00 00 00 00  ...@........@..@........P..@....
00430520  00 00 00 00 24 f4 12 40 00 00 00 00 00 00 00 80 96 98 16 40 00 00 00 00 00 00 00 20 bc be 19 40  ....$..@...........@....... ...@
00430540  00 00 00 00 00 04 bf c9 1b 8e 34 40 00 00 00 a1 ed cc ce 1b c2 d3 4e 40 20 f0 9e b5 70 2b a8 ad  ..........4@..........N@ ...p+..
00430560  c5 9d 69 40 d0 5d fd 25 e5 1a 8e 4f 19 eb 83 40 71 96 d7 95 43 0e 05 8d 29 af 9e 40 f9 bf a0 44  ..i@.].%...O...@q...C...)..@...D
00430580  ed 81 12 8f 81 82 b9 40 bf 3c d5 a6 cf ff 49 1f 78 c2 d3 40 6f c6 e0 8c e9 80 c9 47 ba 93 a8 41  .......@.<....I.x..@o......G...A
004305a0  bc 85 6b 55 27 39 8d f7 70 e0 7c 42 bc dd 8e de f9 9d fb eb 7e aa 51 43 a1 e6 76 e3 cc f2 29 2f  ..kU'9..p.|B........~.QC..v...)/
004305c0  84 81 26 44 28 10 17 aa f8 ae 10 e3 c5 c4 fa 44 eb a7 d4 f3 f7 eb e1 4a 7a 95 cf 45 65 cc c7 91  ..&D(..........D.......Jz..Ee...
004305e0  0e a6 ae a0 19 e3 a3 46 0d 65 17 0c 75 81 86 75 76 c9 48 4d 58 42 e4 a7 93 39 3b 35 b8 b2 ed 53  .......F.e..u..uv.HMXB...9;5...S
00430600  4d a7 e5 5d 3d c5 5d 3b 8b 9e 92 5a ff 5d a6 f0 a1 20 c0 54 a5 8c 37 61 d1 fd 8b 5a 8b d8 25 5d  M..]=.];...Z.]... .T..7a...Z..%]
00430620  89 f9 db 67 aa 95 f8 f3 27 bf a2 c8 5d dd 80 6e 4c c9 9b 97 20 8a 02 52 60 c4 25 75 00 00 00 00  ...g....'...]..nL... ..R`.%u....
00430640  cd cc cd cc cc cc cc cc cc cc fb 3f 71 3d 0a d7 a3 70 3d 0a d7 a3 f8 3f 5a 64 3b df 4f 8d 97 6e  ...........?q=...p=....?Zd;.O..n
00430660  12 83 f5 3f c3 d3 2c 65 19 e2 58 17 b7 d1 f1 3f d0 0f 23 84 47 1b 47 ac c5 a7 ee 3f 40 a6 b6 69  ...?..,e..X....?..#.G.G....?@..i
00430680  6c af 05 bd 37 86 eb 3f 33 3d bc 42 7a e5 d5 94 bf d6 e7 3f c2 fd fd ce 61 84 11 77 cc ab e4 3f  l...7..?3=.Bz......?....a..w...?
004306a0  2f 4c 5b e1 4d c4 be 94 95 e6 c9 3f 92 c4 53 3b 75 44 cd 14 be 9a af 3f de 67 ba 94 39 45 ad 1e  /L[.M......?..S;uD.....?.g..9E..
004306c0  b1 cf 94 3f 24 23 c6 e2 bc ba 3b 31 61 8b 7a 3f 61 55 59 c1 7e b1 53 7c 12 bb 5f 3f d7 ee 2f 8d  ...?$#....;1a.z?aUY.~.S|.._?../.
004306e0  06 be 92 85 15 fb 44 3f 24 3f a5 e9 39 a5 27 ea 7f a8 2a 3f 7d ac a1 e4 bc 64 7c 46 d0 dd 55 3e  ......D?$?..9.'...*?}....d|F..U>
00430700  63 7b 06 cc 23 54 77 83 ff 91 81 3d 91 fa 3a 19 7a 63 25 43 31 c0 ac 3c 21 89 d1 38 82 47 97 b8  c{..#Tw....=..:.zc%C1..<!..8.G..
00430720  00 fd d7 3b dc 88 58 08 1b b1 e8 e3 86 a6 03 3b c6 84 45 42 07 b6 99 75 37 db 2e 3a 33 71 1c d2  ...;..X........;..EB...u7..:3q..
00430740  23 db 32 ee 49 90 5a 39 a6 87 be c0 57 da a5 82 a6 a2 b5 32 e2 68 b2 11 a7 52 9f 44 59 b7 10 2c  #.2.I.Z9....W......2.h...R.DY..,
00430760  25 49 e4 2d 36 34 4f 53 ae ce 6b 25 8f 59 04 a4 c0 de c2 7d fb e8 c6 1e 9e e7 88 5a 57 91 3c bf  %I.-64OS..k%.Y.....}.......ZW.<.
00430780  50 83 22 18 4e 4b 65 62 fd 83 8f af 06 94 7d 11 e4 2d de 9f ce d2 c8 04 dd a6 d8 0a 00 00 00 00  P.".NKeb......}..-..............

004307a0  char data_4307a0 = 0x0

004307a1     00 00 00                                                                                       ...

004307a4  int32_t data_4307a4 = 0x0
004307a8  int32_t data_4307a8 = 0x0

004307ac                                      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ....................
004307c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                      ....................

004307d4  int32_t data_4307d4 = 0x0
004307d8  int32_t data_4307d8 = 0x0
004307dc  int32_t data_4307dc = 0x0
004307e0  int32_t data_4307e0 = 0x0
004307e4  int32_t data_4307e4 = 0x0
004307e8  int32_t data_4307e8 = 0x0
004307ec  int32_t data_4307ec = 0x0
004307f0  int32_t data_4307f0 = 0x0
004307f4  int32_t data_4307f4 = 0x0

004307f8                                                                          00 00 00 00                                      ....

004307fc  int32_t data_4307fc = 0x0
00430800  int32_t data_430800 = 0x0
00430804  int32_t data_430804 = 0x0

00430808                          00 00 00 00                                                                      ....

0043080c  int32_t data_43080c = 0x0

00430810                                                  00 00 00 00                                                      ....

00430814  char data_430814 = 0x0

00430815                                                                 00 00 00                                               ...

00430818  int32_t data_430818 = 0x0
0043081c  int32_t data_43081c = 0x0
00430820  int32_t data_430820 = 0x0

00430824              00 00 00 00                                                                              ....

00430828  int32_t data_430828 = 0x0
0043082c  int32_t data_43082c = 0x0

00430830                                                  00 00 00 00                                                      ....

00430834  char data_430834 = 0x0

00430835                                                                 00 00 00 00 00 00 00 00 00 00 00                       ...........
00430840  00 00 00 00                                                                                      ....

00430844  char data_430844 = 0x0

00430845                 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                               ...................

00430858  int32_t data_430858 = 0x0
0043085c  int32_t data_43085c = 0x0
00430860  int32_t data_430860 = 0x0
00430864  int32_t data_430864 = 0x0
00430868  int32_t data_430868 = 0x0
0043086c  int32_t data_43086c = 0x0
00430870  int32_t data_430870 = 0x0
00430874  int32_t data_430874 = 0x0
00430878  int32_t data_430878 = 0x0
0043087c  int32_t data_43087c = 0x0
00430880  int32_t data_430880 = 0x0

00430884              00 00 00 00                                                                              ....

00430888  int32_t data_430888 = 0x0

0043088c  data_43088c:
0043088c                                      00 00 00 00                                                              ....

00430890  int16_t data_430890 = 0x0
00430892  int16_t data_430892 = 0x0

00430894  data_430894:
00430894                                                              00 00                                                    ..

00430896  int16_t data_430896 = 0x0
00430898  int16_t data_430898 = 0x0
0043089a  int16_t data_43089a = 0x0

0043089c                                                                                      00 00 00 00                              ....
004308a0  00 00 00 00                                                                                      ....

004308a4  int16_t data_4308a4 = 0x0

004308a6                    00 00                                                                                ..

004308a8  int32_t data_4308a8 = 0x0
004308ac  int32_t data_4308ac = 0x0
004308b0  int32_t data_4308b0 = 0x0
004308b4  int32_t data_4308b4 = 0x0
004308b8  char data_4308b8 = 0x0

004308b9                                                                             00 00 00                                       ...

004308bc  int32_t data_4308bc = 0x0
004308c0  char data_4308c0 = 0x0

004308c1     00 00 00                                                                                       ...

004308c4  int32_t data_4308c4 = 0x0

004308c8  data_4308c8:
004308c8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
004308e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430900  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430920  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430940  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430960  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430980  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004309a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004309c0  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............

004309cc  int32_t data_4309cc = 0x0
004309d0  int32_t data_4309d0 = 0x0
004309d4  int32_t data_4309d4 = 0x0
004309d8  int32_t data_4309d8 = 0x0
004309dc  int32_t data_4309dc = 0x0

004309e0  data_4309e0:
004309e0  00 00 00 00 00 00 00 00                                                                          ........

004309e8  int32_t data_4309e8 = 0x0

004309ec                                      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ....................
00430a00  00 00 00 00 00 00 00 00                                                                          ........

00430a08  int32_t data_430a08 = 0x0

00430a0c  data_430a0c:
00430a0c                                      00 00 00 00                                                              ....

00430a10  int32_t data_430a10 = 0x0
00430a14  int32_t data_430a14 = 0x0
00430a18  int32_t data_430a18 = 0x0
00430a1c  int32_t data_430a1c = 0x0
00430a20  int32_t data_430a20 = 0x0
00430a24  int32_t data_430a24 = 0x0
00430a28  int32_t data_430a28 = 0x0

00430a2c                                      00 00 00 00                                                              ....

00430a30  int64_t data_430a30 = 0x0
00430a38  char data_430a38 = 0x0

00430a39                                                                             00 00 00                                       ...

00430a3c  int32_t data_430a3c = 0x0
00430a40  int32_t data_430a40 = 0x0

00430a44              00 00 00 00                                                                              ....

00430a48  int32_t data_430a48 = 0x0

00430a4c                                      00 00 00 00                                                              ....

00430a50  int32_t data_430a50 = 0x0

00430a54  data_430a54:
00430a54                                                              00 00 00 00 00 00 00 00 00 00 00 00                      ............
00430a60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430a80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                      ....................

00430a94  int16_t data_430a94 = 0x0
00430a96  int16_t data_430a96 = 0x0
00430a98  int16_t data_430a98 = 0x0
00430a9a  int16_t data_430a9a = 0x0
00430a9c  int16_t data_430a9c = 0x0
00430a9e  int16_t data_430a9e = 0x0
00430aa0  int16_t data_430aa0 = 0x0
00430aa2  int16_t data_430aa2 = 0x0
00430aa4  int32_t data_430aa4 = 0x0

00430aa8  data_430aa8:
00430aa8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
00430ac0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ae0  00 00 00 00 00 00 00 00                                                                          ........

00430ae8  int16_t data_430ae8 = 0x0
00430aea  int16_t data_430aea = 0x0
00430aec  int16_t data_430aec = 0x0
00430aee  int16_t data_430aee = 0x0
00430af0  int16_t data_430af0 = 0x0
00430af2  int16_t data_430af2 = 0x0
00430af4  int16_t data_430af4 = 0x0
00430af6  int16_t data_430af6 = 0x0
00430af8  int32_t data_430af8 = 0x0
00430afc  int32_t data_430afc = 0x0
00430b00  int32_t data_430b00 = 0x0
00430b04  int32_t data_430b04 = 0x0
00430b08  int32_t data_430b08 = 0x0
00430b0c  int32_t data_430b0c = 0x0
00430b10  int32_t data_430b10 = 0x0
00430b14  int32_t data_430b14 = 0x0
00430b18  int32_t data_430b18 = 0x0
00430b1c  int32_t data_430b1c = 0x0

00430b20  data_430b20:
00430b20  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............

00430b2c  int16_t data_430b2c = 0x0

00430b2e                                            00 00 00 00 00 00                                                    ......

00430b34  int16_t data_430b34 = 0x0

00430b36                                                                    00 00 00 00                                          ....

00430b3a  int16_t data_430b3a = 0x0

00430b3c                                                                                      00 00                                    ..

00430b3e  int16_t data_430b3e = 0x0
00430b40  int16_t data_430b40 = 0x0

00430b42        00 00                                                                                        ..

00430b44  int32_t data_430b44 = 0x0
00430b48  int32_t data_430b48 = 0x0
00430b4c  int32_t data_430b4c = 0x0
00430b50  int32_t data_430b50 = 0x0
00430b54  int32_t data_430b54 = 0x0
00430b58  int32_t data_430b58 = 0x0
00430b5c  char data_430b5c = 0x0
00430b5d  char data_430b5d = 0x0

00430b5e                                                                                            00 00                                ..

00430b60  int32_t data_430b60 = 0x0
00430b64  int32_t data_430b64 = 0x0
00430b68  int16_t data_430b68 = 0x0
00430b6a  char data_430b6a = 0x0

00430b6b                                   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00             .....................
00430b80  00 00 00 00 00 00 00 00                                                                          ........

00430b88  int32_t data_430b88 = 0x0
00430b8c  int32_t data_430b8c = 0x0
00430b90  int32_t data_430b90 = 0x0
00430b94  int32_t data_430b94 = 0x0
00430b98  int32_t data_430b98 = 0x0
00430b9c  int32_t data_430b9c = 0x0
00430ba0  int32_t data_430ba0 = 0x0
00430ba4  int32_t data_430ba4 = 0x0
00430ba8  int32_t data_430ba8 = 0x0

00430bac  data_430bac:
00430bac                                      00 00 00 00 00 00 00 00                                                  ........

00430bb4  int32_t data_430bb4 = 0x0
00430bb8  int32_t data_430bb8 = 0x0
00430bbc  int32_t data_430bbc = 0x0
00430bc0  int32_t data_430bc0 = 0x0

00430bc4              00 00 00 00 00 00 00 00                                                                  ........
00430bcc  data_430bcc:
00430bcc                                      00 00 00 00                                                              ....

00430bd0  int32_t data_430bd0 = 0x0

00430bd4  data_430bd4:
00430bd4                                                              00 00 00 00 00 00 00 00                                  ........

00430bdc  int32_t data_430bdc = 0x0

00430be0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430c00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430c20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430c40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430c60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430c80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ca0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430cc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ce0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430da0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430dc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430de0  00 00 00 00                                                                                      ....

00430de4  int32_t data_430de4 = 0x0
00430de8  int32_t data_430de8 = 0x0
00430dec  int32_t data_430dec = 0x0
00430df0  int32_t data_430df0 = 0x0
00430df4  int32_t data_430df4 = 0x0
00430df8  int32_t data_430df8 = 0x0
00430dfc  int32_t data_430dfc = 0x0
00430e00  int32_t data_430e00 = 0x0
00430e04  int32_t data_430e04 = 0x0
00430e08  int32_t data_430e08 = 0x0

00430e0c                                      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ....................

00430e20  int32_t data_430e20 = 0x0

00430e24  data_430e24:
00430e24              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00      ............................
00430e40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430e60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430e80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ea0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ec0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ee0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430f00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00430f20  int32_t data_430f20 = 0x0
00430f24  int32_t data_430f24 = 0x0
00430f28  int32_t data_430f28 = 0x0
00430f2c  int32_t data_430f2c = 0x0

00430f30                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
00430f40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430f60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430f80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430fa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430fc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430fe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431080  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004310a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004310c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004310e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431100  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431120  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431140  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431160  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431180  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004311a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004311c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004311e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431200  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431220  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431240  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431260  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431280  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004312a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004312c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004312e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004313a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004313c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004313e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431400  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431460  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004314a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004314c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004314e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004315a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004315c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004315e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431600  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431620  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431640  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431660  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431680  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004316a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004316c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004316e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431700  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431720  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431760  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004317a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004317c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004317e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431800  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431820  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431860  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431880  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004318a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004318c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004318e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431900  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431920  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431940  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431960  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431980  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004319a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004319c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004319e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431a00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431a20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431a40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431a60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431a80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431aa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431ac0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431ae0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431b00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431b20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431b40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431b60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431b80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431ba0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431bc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431be0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431c00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431c20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431c40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431c60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431c80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431ca0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431cc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431ce0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431d00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431d20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431d40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431d60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431d80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431da0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431dc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431de0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431e00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431e20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431e40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431e60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431e80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431ea0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431ec0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431ee0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431f00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00431f20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00431f40  int32_t data_431f40 = 0x0
00431f44  int32_t data_431f44 = 0x0
00431f48  int32_t data_431f48 = 0x0
00431f4c  int32_t data_431f4c = 0x0
00431f50  int32_t data_431f50 = 0x0
00431f54  int32_t data_431f54 = 0x0
.data section ended  {0x42b000-0x431f58}

.extern section started  {0x431f60-0x432080}
00431f60  extern BOOL __stdcall CloseHandle(HANDLE hObject)
00431f64  extern enum COMPARESTRING_RESULT __stdcall CompareStringA(uint32_t Locale, uint32_t dwCmpFlags, char* lpString1, int32_t cchCount1, char* lpString2, int32_t cchCount2)
00431f68  extern enum COMPARESTRING_RESULT __stdcall CompareStringW(uint32_t Locale, uint32_t dwCmpFlags, wchar16* lpString1, int32_t cchCount1, wchar16* lpString2, int32_t cchCount2)
00431f6c  extern HANDLE __stdcall CreateFileA(PSTR lpFileName, uint32_t dwDesiredAccess, enum FILE_SHARE_MODE dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, enum FILE_CREATION_DISPOSITION dwCreationDisposition, enum FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile)
00431f70  extern BOOL __stdcall CreatePipe(HANDLE* hReadPipe, HANDLE* hWritePipe, SECURITY_ATTRIBUTES* lpPipeAttributes, uint32_t nSize)
00431f74  extern BOOL __stdcall CreateProcessA(PSTR lpApplicationName, PSTR lpCommandLine, SECURITY_ATTRIBUTES* lpProcessAttributes, SECURITY_ATTRIBUTES* lpThreadAttributes, BOOL bInheritHandles, enum PROCESS_CREATION_FLAGS dwCreationFlags, void* lpEnvironment, PSTR lpCurrentDirectory, STARTUPINFOA* lpStartupInfo, PROCESS_INFORMATION* lpProcessInformation)
00431f78  extern BOOL __stdcall DeleteFileA(PSTR lpFileName)
00431f7c  extern BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, HANDLE* lpTargetHandle, uint32_t dwDesiredAccess, BOOL bInheritHandle, enum DUPLICATE_HANDLE_OPTIONS dwOptions)
00431f80  extern BOOL __stdcall EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, uint32_t dwFlags)
00431f84  extern void __stdcall ExitProcess(uint32_t uExitCode) __noreturn
00431f88  extern BOOL __stdcall FlushFileBuffers(HANDLE hFile)
00431f8c  extern uint32_t __stdcall FormatMessageA(enum FORMAT_MESSAGE_OPTIONS dwFlags, void* lpSource, uint32_t dwMessageId, uint32_t dwLanguageId, PSTR lpBuffer, uint32_t nSize, char** Arguments)
00431f90  extern BOOL __stdcall FreeEnvironmentStringsA(PSTR penv)
00431f94  extern BOOL __stdcall FreeEnvironmentStringsW(PWSTR penv)
00431f98  extern BOOL __stdcall FreeLibrary(HMODULE hLibModule)
00431f9c  extern uint32_t __stdcall GetACP()
00431fa0  extern BOOL __stdcall GetCPInfo(uint32_t CodePage, CPINFO* lpCPInfo)
00431fa4  extern PSTR __stdcall GetCommandLineA()
00431fa8  extern HANDLE __stdcall GetCurrentProcess()
00431fac  extern uint32_t __stdcall GetCurrentProcessId()
00431fb0  extern PSTR __stdcall GetEnvironmentStrings()
00431fb4  extern PWSTR __stdcall GetEnvironmentStringsW()
00431fb8  extern uint32_t __stdcall GetEnvironmentVariableA(PSTR lpName, uint8_t* lpBuffer, uint32_t nSize)
00431fbc  extern BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, uint32_t* lpExitCode)
00431fc0  extern uint32_t __stdcall GetFileAttributesA(PSTR lpFileName)
00431fc4  extern enum FILE_TYPE __stdcall GetFileType(HANDLE hFile)
00431fc8  extern enum WIN32_ERROR __stdcall GetLastError()
00431fcc  extern void __stdcall GetLocalTime(SYSTEMTIME* lpSystemTime)
00431fd0  extern int32_t __stdcall GetLocaleInfoA(uint32_t Locale, uint32_t LCType, uint8_t* lpLCData, int32_t cchData)
00431fd4  extern int32_t __stdcall GetLocaleInfoW(uint32_t Locale, uint32_t LCType, wchar16* lpLCData, int32_t cchData)
00431fd8  extern uint32_t __stdcall GetModuleFileNameA(HMODULE hModule, uint8_t* lpFilename, uint32_t nSize)
00431fdc  extern HMODULE __stdcall GetModuleHandleA(PSTR lpModuleName)
00431fe0  extern uint32_t __stdcall GetOEMCP()
00431fe4  extern FARPROC __stdcall GetProcAddress(HMODULE hModule, PSTR lpProcName)
00431fe8  extern void __stdcall GetStartupInfoA(STARTUPINFOA* lpStartupInfo)
00431fec  extern HANDLE __stdcall GetStdHandle(enum STD_HANDLE nStdHandle)
00431ff0  extern BOOL __stdcall GetStringTypeA(uint32_t Locale, uint32_t dwInfoType, uint8_t* lpSrcStr, int32_t cchSrc, uint16_t* lpCharType)
00431ff4  extern BOOL __stdcall GetStringTypeW(uint32_t dwInfoType, wchar16* lpSrcStr, int32_t cchSrc, uint16_t* lpCharType)
00431ff8  extern void __stdcall GetSystemTime(SYSTEMTIME* lpSystemTime)
00431ffc  extern void __stdcall GetSystemTimeAsFileTime(FILETIME* lpSystemTimeAsFileTime)
00432000  extern uint32_t __stdcall GetTimeZoneInformation(TIME_ZONE_INFORMATION* lpTimeZoneInformation)
00432004  extern uint32_t __stdcall GetUserDefaultLCID()
00432008  extern uint32_t __stdcall GetVersion()
0043200c  extern BOOL __stdcall GetVersionExA(OSVERSIONINFOA* lpVersionInformation)
00432010  extern void* __stdcall HeapAlloc(HANDLE hHeap, enum HEAP_FLAGS dwFlags, uint32_t dwBytes)
00432014  extern HANDLE __stdcall HeapCreate(enum HEAP_FLAGS flOptions, uint32_t dwInitialSize, uint32_t dwMaximumSize)
00432018  extern BOOL __stdcall HeapDestroy(HANDLE hHeap)
0043201c  extern BOOL __stdcall HeapFree(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem)
00432020  extern void* __stdcall HeapReAlloc(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem, uint32_t dwBytes)
00432024  extern BOOL __stdcall IsValidCodePage(uint32_t CodePage)
00432028  extern BOOL __stdcall IsValidLocale(uint32_t Locale, enum IS_VALID_LOCALE_FLAGS dwFlags)
0043202c  extern int32_t __stdcall LCMapStringA(uint32_t Locale, uint32_t dwMapFlags, uint8_t* lpSrcStr, int32_t cchSrc, PSTR lpDestStr, int32_t cchDest)
00432030  extern int32_t __stdcall LCMapStringW(uint32_t Locale, uint32_t dwMapFlags, wchar16* lpSrcStr, int32_t cchSrc, PWSTR lpDestStr, int32_t cchDest)
00432034  extern HMODULE __stdcall LoadLibraryA(PSTR lpLibFileName)
00432038  extern enum MESSAGEBOX_RESULT __stdcall MessageBoxA(HWND hWnd, PSTR lpText, PSTR lpCaption, enum MESSAGEBOX_STYLE uType)
0043203c  extern BOOL __stdcall MoveFileA(PSTR lpExistingFileName, PSTR lpNewFileName)
00432040  extern int32_t __stdcall MultiByteToWideChar(uint32_t CodePage, enum MULTI_BYTE_TO_WIDE_CHAR_FLAGS dwFlags, uint8_t* lpMultiByteStr, int32_t cbMultiByte, wchar16* lpWideCharStr, int32_t cchWideChar)
00432044  extern void __stdcall RaiseException(uint32_t dwExceptionCode, uint32_t dwExceptionFlags, uint32_t nNumberOfArguments, uint32_t* lpArguments) __noreturn
00432048  extern BOOL __stdcall ReadFile(HANDLE hFile, uint8_t* lpBuffer, uint32_t nNumberOfBytesToRead, uint32_t* lpNumberOfBytesRead, OVERLAPPED* lpOverlapped)
0043204c  extern void __stdcall RtlUnwind(void* TargetFrame, void* TargetIp, EXCEPTION_RECORD* ExceptionRecord, void* ReturnValue)
00432050  extern BOOL __stdcall SetEndOfFile(HANDLE hFile)
00432054  extern BOOL __stdcall SetEnvironmentVariableA(PSTR lpName, PSTR lpValue)
00432058  extern uint32_t __stdcall SetFilePointer(HANDLE hFile, int32_t lDistanceToMove, int32_t* lpDistanceToMoveHigh, enum SET_FILE_POINTER_MOVE_METHOD dwMoveMethod)
0043205c  extern uint32_t __stdcall SetHandleCount(uint32_t uNumber)
00432060  extern BOOL __stdcall SetStdHandle(enum STD_HANDLE nStdHandle, HANDLE hHandle)
00432064  extern BOOL __stdcall TerminateProcess(HANDLE hProcess, uint32_t uExitCode)
00432068  extern int32_t __stdcall UnhandledExceptionFilter(EXCEPTION_POINTERS* ExceptionInfo)
0043206c  extern void* __stdcall VirtualAlloc(void* lpAddress, uint32_t dwSize, enum VIRTUAL_ALLOCATION_TYPE flAllocationType, enum PAGE_PROTECTION_FLAGS flProtect)
00432070  extern BOOL __stdcall VirtualFree(void* lpAddress, uint32_t dwSize, enum VIRTUAL_FREE_TYPE dwFreeType)
00432074  extern enum WAIT_EVENT __stdcall WaitForSingleObject(HANDLE hHandle, uint32_t dwMilliseconds)
00432078  extern int32_t __stdcall WideCharToMultiByte(uint32_t CodePage, uint32_t dwFlags, wchar16* lpWideCharStr, int32_t cchWideChar, PSTR lpMultiByteStr, int32_t cbMultiByte, PSTR lpDefaultChar, BOOL* lpUsedDefaultChar)
0043207c  extern BOOL __stdcall WriteFile(HANDLE hFile, uint8_t* lpBuffer, uint32_t nNumberOfBytesToWrite, uint32_t* lpNumberOfBytesWritten, OVERLAPPED* lpOverlapped)
.extern section ended  {0x431f60-0x432080}

.synthetic_builtins section started  {0x432080-0x432098}
00432080  extern void* __builtin_memcpy(void* dest, void const* src, uint32_t count)
00432084  extern void* __builtin_memset(void* dest, int32_t ch, uint32_t count)
00432088  extern char* __builtin_strcpy(char* dest, char const* src)
0043208c  extern char* __builtin_strncpy(char* dest, char const* src, uint32_t count)
00432090  extern wchar16* __builtin_wcscpy(wchar16* dest, wchar16 const* src)
00432094  extern wchar16* __builtin_wmemcpy(wchar16* dest, wchar16 const* src, uint32_t count)
.synthetic_builtins section ended  {0x432080-0x432098}

